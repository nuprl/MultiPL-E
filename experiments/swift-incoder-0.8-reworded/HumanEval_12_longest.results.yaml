language: swift
name: HumanEval_12_longest
results:
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let length = strings.reduce(into: 0, { result, string in\n        return\
    \ max(result, string.characters.count)\n    })\n    return strings.firstIndex(of:\
    \ String(repeating: \"a\", count: length))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpba9sudxy.swift:12:16: error: cannot convert value of type 'Int'\
    \ to closure result type '()'\n        return max(result, string.characters.count)\n\
    \               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpba9sudxy.swift:14:20:\
    \ error: cannot convert return expression of type 'Array<String>.Index?' (aka\
    \ 'Optional<Int>') to return type 'String?'\n    return strings.firstIndex(of:\
    \ String(repeating: \"a\", count: length))\n           ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(arrays.toArray(strings))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpv1j097gl.swift:11:20: error: cannot find 'arrays' in scope\n  \
    \  return longest(arrays.toArray(strings))\n                   ^~~~~~\n/tmp/tmpv1j097gl.swift:11:20:\
    \ error: missing argument label 'strings:' in call\n    return longest(arrays.toArray(strings))\n\
    \                   ^\n                   strings: \n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.count == 0 {\n    return nil\n  }\n\n  // We sort the strings\
    \ so that the longest ones come first (like Python's sorted(key=len)\n  // function).\n\
    \  let sortedStrings = strings.sorted()\n\n  // We go through all the strings\
    \ and keep a pointer to the longest one.\n  var longest = String?()\n  var longestStringIndex\
    \ = 0\n\n  for index in strings.indices {\n    let string = sortedStrings[index]\n\
    \    let length = string.characters.count\n\n    if length > longest!.characters.count\
    \ {\n      longest = string\n      longestStringIndex = index\n    }\n  }\n\n\
    \  return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2lq8oy17.swift:20:25: error: missing argument for parameter #1\
    \ in call\n  var longest = String?()\n                        ^\n            \
    \            <#String#>\nSwift.Optional:4:12: note: 'init(_:)' declared here\n\
    \    public init(_ some: Wrapped)\n           ^\n/tmp/tmp2lq8oy17.swift:25:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    let length\
    \ = string.characters.count\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var max: String\
    \ = \"\"\n    var maxLength = 0\n    for s in strings {\n        if s.count >\
    \ maxLength {\n            maxLength = s.count\n            max = s\n        }\n\
    \    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  var longest = \"\"\n  for string in strings { // NOTE: mutating loop variable,\
    \ bad practice.\n    if longest.characters.count < string.characters.count {\n\
    \      longest = string\n    }\n  }\n  return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8drzutu4.swift:13:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    if longest.characters.count < string.characters.count\
    \ {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8drzutu4.swift:13:42: error: 'characters' is unavailable: Please\
    \ use String directly\n    if longest.characters.count < string.characters.count\
    \ {\n                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLen = 0\n    var longest: String = nil\n\n    for str in strings\
    \ {\n        let len = str.count\n        if len > maxLen {\n            maxLen\
    \ = len\n            longest = str\n        }\n    }\n\n    return longest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpe4772ayt.swift:12:27: error: 'nil' cannot initialize specified\
    \ type 'String'\n    var longest: String = nil\n                          ^\n\
    /tmp/tmpe4772ayt.swift:12:18: note: add '?' to form the optional type 'String?'\n\
    \    var longest: String = nil\n                 ^\n                       ?\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if isEmpty(strings) {\n        return nil\n    }\n    if let str = longestString(strings)\
    \ {\n        return str\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmps6pll456.swift:11:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(strings) {\n       ^~~~~~~\n/tmp/tmps6pll456.swift:14:18: error:\
    \ cannot find 'longestString' in scope\n    if let str = longestString(strings)\
    \ {\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.reduce((_: String?, i: String) -> String? {\n        if\
    \ _ == \"\" {\n            return i\n        }\n\n        if i.count < _.count\
    \ {\n            return _\n        }\n        return i\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpy5mmoha3.swift:13:20: error: cannot find 'i' in scope\n       \
    \     return i\n                   ^\n/tmp/tmpy5mmoha3.swift:16:12: error: cannot\
    \ find 'i' in scope\n        if i.count < _.count {\n           ^\n/tmp/tmpy5mmoha3.swift:19:16:\
    \ error: cannot find 'i' in scope\n        return i\n               ^\n/tmp/tmpy5mmoha3.swift:12:12:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        if _ == \"\" {\n           ^\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let maxSize = strings.max(by: { (string1, string2) in string1.count >\
    \ string2.count })\n    return maxSize.count == 0 ? nil : maxSize[0]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpblxhvi3k.swift:12:12: error: value of optional type 'String?' must\
    \ be unwrapped to refer to member 'count' of wrapped base type 'String'\n    return\
    \ maxSize.count == 0 ? nil : maxSize[0]\n           ^\n/tmp/tmpblxhvi3k.swift:12:12:\
    \ note: chain the optional using '?' to access member 'count' only for non-'nil'\
    \ base values\n    return maxSize.count == 0 ? nil : maxSize[0]\n           ^\n\
    \                  ?\n/tmp/tmpblxhvi3k.swift:12:12: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n    return maxSize.count\
    \ == 0 ? nil : maxSize[0]\n           ^\n                  !\n/tmp/tmpblxhvi3k.swift:12:31:\
    \ error: cannot convert return expression of type 'Character' to return type 'String?'\n\
    \    return maxSize.count == 0 ? nil : maxSize[0]\n           ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpblxhvi3k.swift:12:39: error: value of optional type 'String?' must be\
    \ unwrapped to refer to member 'subscript' of wrapped base type 'String'\n   \
    \ return maxSize.count == 0 ? nil : maxSize[0]\n                             \
    \         ^\n/tmp/tmpblxhvi3k.swift:12:39: note: chain the optional using '?'\
    \ to access member 'subscript' only for non-'nil' base values\n    return maxSize.count\
    \ == 0 ? nil : maxSize[0]\n                                      ^\n         \
    \                                    ?\n/tmp/tmpblxhvi3k.swift:12:39: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ maxSize.count == 0 ? nil : maxSize[0]\n                                    \
    \  ^\n                                             !\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    let longestString\
    \ = strings.reduce((max: Int, cur: String, curIndex: Int) -> Int? {\n        if\
    \ max < cur.length {\n            return max\n        }\n        return curIndex\n\
    \    })\n\n    if longestString == nil {\n        return nil\n    }\n\n    return\
    \ strings[longestString!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7cv81ftf.swift:16:18: error: cannot find 'cur' in scope\n     \
    \   if max < cur.length {\n                 ^~~\n/tmp/tmp7cv81ftf.swift:19:16:\
    \ error: cannot find 'curIndex' in scope\n        return curIndex\n          \
    \     ^~~~~~~~\n/tmp/tmp7cv81ftf.swift:15:82: error: expected type after '->'\n\
    \    let longestString = strings.reduce((max: Int, cur: String, curIndex: Int)\
    \ -> Int? {\n                                                                \
    \                 ^\n/tmp/tmp7cv81ftf.swift:20:6: error: missing argument for\
    \ parameter #2 in call\n    })\n     ^\n     , <#(_.Type, String) throws -> _.Type#>\n\
    Swift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable public func\
    \ reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult:\
    \ Result, Self.Element) throws -> Result) rethrows -> Result\n               \
    \            ^\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings == nil || strings.IsEmpty() {\n        return nil\n    }\n\
    \n    // sort to get the longest first\n    var strings = strings.sorted()\n\n\
    \    // find longest\n    var longestString = strings[0]\n    var longestLength\
    \ = longestString.characters.count\n\n    for s in strings {\n        if s.characters.count\
    \ > longestLength {\n            longestString = s\n            longestLength\
    \ = longestString.characters.count\n        }\n    }\n\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp097ag1r3.swift:11:34: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings == nil || strings.IsEmpty() {\n                  \
    \       ~~~~~~~ ^~~~~~~\n/tmp/tmp097ag1r3.swift:20:39: error: 'characters' is\
    \ unavailable: Please use String directly\n    var longestLength = longestString.characters.count\n\
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp097ag1r3.swift:23:14: error: 'characters' is unavailable:\
    \ Please use String directly\n        if s.characters.count > longestLength {\n\
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp097ag1r3.swift:25:43: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = longestString.characters.count\n\
    \                                          ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty() {\n        return nil\n    }\n    \n    var longest:\
    \ Int = 0\n    var longestStr: String? = nil\n    for str in strings {\n     \
    \   if str.count > longest {\n            longest = str.count\n            longestStr\
    \ = str\n        }\n    }\n    return longestStr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmphodp4h8y.swift:11:16: error: cannot call value of non-function\
    \ type 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n        \
    \              \n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty() {\n    return nil\n  }\n\n  maxLen, _ := maxStringLen(strings)\n\
    \  return strings.first(where: { $0.count == maxLen })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmq848ofj.swift:15:9: error: consecutive statements on a line must\
    \ be separated by ';'\n  maxLen, _ := maxStringLen(strings)\n        ^\n     \
    \   ;\n/tmp/tmpmq848ofj.swift:15:9: error: expected expression\n  maxLen, _ :=\
    \ maxStringLen(strings)\n        ^\n/tmp/tmpmq848ofj.swift:11:14: error: cannot\
    \ call value of non-function type 'Bool'\n  if strings.isEmpty() {\n         \
    \    ^      ~~\n                    \n/tmp/tmpmq848ofj.swift:15:3: error: cannot\
    \ find 'maxLen' in scope\n  maxLen, _ := maxStringLen(strings)\n  ^~~~~~\n/tmp/tmpmq848ofj.swift:16:45:\
    \ error: cannot find 'maxLen' in scope\n  return strings.first(where: { $0.count\
    \ == maxLen })\n                                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestFromSliceString(strings...)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp3483chk1.swift:11:12: error: cannot find 'longestFromSliceString'\
    \ in scope\n    return longestFromSliceString(strings...)\n           ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3483chk1.swift:11:35: error: cannot convert value of type '[String]' to\
    \ expected argument type 'UnboundedRange_'\n    return longestFromSliceString(strings...)\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    let longestString\
    \ = strings.reduce(\"\", { result, string in\n        if result.count < string.count\
    \ {\n            return result\n        } else if result.count == string.count\
    \ {\n            return string\n        } else {\n            return result\n\
    \        }\n    })\n\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpm00fg932/tmpm00fg932.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6a0061c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae69fd58b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae69fd58988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae69fd577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm00fg932                        0x0000556fc795a8fa <unavailable> + 6394

    5    libc.so.6                          0x00002ae6a024d460 __libc_start_main +
    245

    6    tmpm00fg932                        0x0000556fc795a1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if let first = strings.first {\n    if strings.count == 1 {\n      return\
    \ first\n    }\n    let longest = strings.reduce(0, { (result, string) -> Int?\
    \ in\n      let length = string.count\n      guard result < length else { return\
    \ nil }\n      return result\n    })\n    return longest\n  }\n  return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ikvlgos.swift:15:59: error: declared closure result 'Int?' is\
    \ incompatible with contextual type 'Int'\n    let longest = strings.reduce(0,\
    \ { (result, string) -> Int? in\n                                            \
    \              ^~~~\n                                                        \
    \  Int\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLength = 0\n    var longestString: String?\n\n    for str in strings\
    \ {\n        if str.characters.count > maxLength {\n            maxLength = str.characters.count\n\
    \            longestString = str\n        }\n    }\n\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmphb8qxd0q.swift:15:16: error: 'characters' is unavailable: Please\
    \ use String directly\n        if str.characters.count > maxLength {\n       \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmphb8qxd0q.swift:16:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxLength = str.characters.count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty { return nil }\n    guard strings.count > 0 else {\n\
    \        return nil\n    }\n    guard let longest = strings.max else { return\
    \ nil }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmppila3ltc.swift:15:33: warning: use of 'max' treated as a reference\
    \ to instance method in protocol 'Sequence'\n    guard let longest = strings.max\
    \ else { return nil }\n                                ^\nSwift.Sequence:5:28:\
    \ note: 'max()' declared here\n    @inlinable public func max() -> Self.Element?\n\
    \                           ^\n/tmp/tmppila3ltc.swift:15:33: note: use 'self.'\
    \ to silence this warning\n    guard let longest = strings.max else { return nil\
    \ }\n                                ^\n                                self.\n\
    /tmp/tmppila3ltc.swift:15:33: note: use 'Swift.' to reference the global function\n\
    \    guard let longest = strings.max else { return nil }\n                   \
    \             ^\n                                Swift.\n/tmp/tmppila3ltc.swift:15:11:\
    \ error: initializer for conditional binding must have Optional type, not '()\
    \ -> String?'\n    guard let longest = strings.max else { return nil }\n     \
    \     ^             ~~~~~~~~~~~\n/tmp/tmppila3ltc.swift:16:12: error: function\
    \ produces expected type 'String?'; did you mean to call it with '()'?\n    return\
    \ longest\n           ^~~~~~~\n                  ()\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty { return nil }\n    var longest = strings[0]\n   \
    \ for s in strings {\n        if longest.length < s.length { longest = s }\n \
    \   }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpa4m2t0w7.swift:14:20: error: value of type 'String' has no member\
    \ 'length'\n        if longest.length < s.length { longest = s }\n           ~~~~~~~\
    \ ^~~~~~\n/tmp/tmpa4m2t0w7.swift:14:31: error: value of type 'String' has no member\
    \ 'length'\n        if longest.length < s.length { longest = s }\n           \
    \                 ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpsix6g_zl.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.sorted())\n                   ^\n      \
    \             strings: \n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestElements(strings).map { $0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpntea21ua.swift:11:12: error: cannot find 'longestElements' in scope\n\
    \    return longestElements(strings).map { $0 }\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var maxLen: Int\
    \ = 0\n    var maxIndex = 0\n    for index, s in strings.enumerated() {\n    \
    \    if s.count > maxLen {\n            maxIndex = index\n            maxLen =\
    \ s.count\n        }\n    }\n\n    if maxLen == 0 {\n        return nil\n    }\n\
    \n    return strings[maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpjjk0g4le.swift:17:14: error: expected 'in' after for-each pattern\n\
    \    for index, s in strings.enumerated() {\n             ^\n/tmp/tmpjjk0g4le.swift:17:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, s in strings.enumerated()\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLength = Int.max\n    var longestString = String()\n    var longestStringIndex\
    \ = 0\n    for index in 0..<strings.count {\n        if strings[index].count >\
    \ maxLength {\n            maxLength = strings[index].count\n            longestString\
    \ = strings[index]\n            longestStringIndex = index\n        }\n    }\n\
    \n    if longestString.count > maxLength {\n        return nil\n    }\n\n    return\
    \ longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpiec7wsfj/tmpiec7wsfj.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59e03cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59e00c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59e00c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59e00c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiec7wsfj                        0x000055e673921738 <unavailable> + 5944

    5    libc.so.6                          0x00002b59e05b6460 __libc_start_main +
    245

    6    tmpiec7wsfj                        0x000055e673921359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var maxCount = 1 // first\
    \ string is as long\n    var maxIndex = -1\n\n    for index in strings.indices\
    \ {\n        var count = 0\n\n        if let substring = strings[maxIndex] {\n\
    \            count = maxCount.count + substring.length - index\n        }\n\n\
    \        if count > maxCount {\n            maxCount = count\n            maxIndex\
    \ = index\n        }\n    }\n\n    return maxIndex >= 0 ? strings[maxIndex] :\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp1vrz_2hg.swift:19:30: error: value of type 'Int' has no member\
    \ 'count'\n            count = maxCount.count + substring.length - index\n   \
    \                 ~~~~~~~~ ^~~~~\n/tmp/tmp1vrz_2hg.swift:19:48: error: value of\
    \ type 'String' has no member 'length'\n            count = maxCount.count + substring.length\
    \ - index\n                                     ~~~~~~~~~ ^~~~~~\n/tmp/tmp1vrz_2hg.swift:19:36:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \            count = maxCount.count + substring.length - index\n             \
    \                      ^\n/tmp/tmp1vrz_2hg.swift:18:12: error: initializer for\
    \ conditional binding must have Optional type, not 'String'\n        if let substring\
    \ = strings[maxIndex] {\n           ^               ~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014002
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var maxLen = Int.max\n\
    \    var longest: String? = nil\n\n    for str in strings {\n        let len =\
    \ str.count\n        if len > maxLen {\n            maxLen = len\n           \
    \ longest = str\n        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp220z51pq/tmp220z51pq.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4be9a98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4be978fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4be978f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4be978e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp220z51pq                        0x00005583ab4839aa <unavailable> + 6570

    5    libc.so.6                          0x00002b4be9c84460 __libc_start_main +
    245

    6    tmp220z51pq                        0x00005583ab483299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n\n  guard strings[0].isEmpty\
    \ else { return strings[0] }\n\n  var longest = strings[0]\n  for str in strings.dropFirst()\
    \ {\n    if str.count > longest.count {\n      longest = str\n    }\n  }\n\n \
    \ return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp2hg9q0sq/tmp2hg9q0sq.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f8c7a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f8c497b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9f8c497988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9f8c4967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hg9q0sq                        0x00005595b41d9ef8 <unavailable> + 7928

    5    libc.so.6                          0x00002b9f8c98c460 __libc_start_main +
    245

    6    tmp2hg9q0sq                        0x00005595b41d9429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpc3juz6rx.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpc3juz6rx.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpc3juz6rx.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpc3juz6rx.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n\n    var longest: String\
    \ = \"\"\n\n    for str in strings {\n        if str.count > longest.count {\n\
    \            longest = str\n        }\n    }\n\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO: optimise this\n    if strings.IsEmpty() {\n        return nil\n\
    \    }\n    var longest = strings[0]\n    for _, string in strings.Iter() {\n\
    \        if longest == string {\n            continue\n        }\n        if longest.count\
    \ < string.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpoyt9gp5e.swift:16:10: error: expected 'in' after for-each pattern\n\
    \    for _, string in strings.Iter() {\n         ^\n/tmp/tmpoyt9gp5e.swift:16:10:\
    \ error: expected Sequence expression for for-each loop\n    for _, string in\
    \ strings.Iter() {\n         ^\n/tmp/tmpoyt9gp5e.swift:12:16: error: value of\
    \ type '[String]' has no member 'IsEmpty'\n    if strings.IsEmpty() {\n      \
    \ ~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestHelper(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpqob1_iv6.swift:11:12: error: cannot find 'longestHelper' in scope\n\
    \    return longestHelper(strings, nil)\n           ^~~~~~~~~~~~~\n/tmp/tmpqob1_iv6.swift:11:35:\
    \ error: 'nil' requires a contextual type\n    return longestHelper(strings, nil)\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(into:\
    \ nil) { longest, current in\n        longest = (longest ?? current).count < current.count\n\
    \            return current }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ix_yuf_.swift:14:33: error: 'nil' is not compatible with expected\
    \ argument type 'String'\n    return strings.reduce(into: nil) { longest, current\
    \ in\n                                ^\n/tmp/tmp7ix_yuf_.swift:15:46: error:\
    \ cannot assign value of type 'Bool' to type 'String'\n        longest = (longest\
    \ ?? current).count < current.count\n                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else {\n        return nil\n    }\n    return\
    \ strings.reduce(\n        { $0.count < $1.count ? $0 : $1\n        },\n     \
    \   { $0.count > $1.count ? $0 : $1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpq5jgv3az.swift:15:9: error: cannot convert value of type '(_, _)\
    \ -> _' to expected argument type 'String'\n        { $0.count < $1.count ? $0\
    \ : $1\n        ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    if strings.count\
    \ <= 1 {\n        return strings.first\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if s.length >= longest.length {\n           \
    \ longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpbol8l9de.swift:19:14: error: value of type 'String' has no member\
    \ 'length'\n        if s.length >= longest.length {\n           ~ ^~~~~~\n/tmp/tmpbol8l9de.swift:19:32:\
    \ error: value of type 'String' has no member 'length'\n        if s.length >=\
    \ longest.length {\n                       ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n\treturn longest(strings: strings, lengths: nil)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpml08g6bs.swift:11:44: error: extra argument 'lengths' in call\n\
    \        return longest(strings: strings, lengths: nil)\n                    \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmpml08g6bs.swift:11:44: error: 'nil'\
    \ requires a contextual type\n        return longest(strings: strings, lengths:\
    \ nil)\n                                                  ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longestLength\
    \ = Int.max\n\n    for s in strings {\n        let length = s.count ?? 0\n\n \
    \       if length > longestLength {\n            longestLength = length\n    \
    \    }\n    }\n\n    return longestLength == Int.max ? nil : strings.first\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmptqtpr8mo/tmptqtpr8mo.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b891528ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8914f85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8914f85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8914f847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptqtpr8mo                        0x00005595973ee9fa <unavailable> + 6650

    5    libc.so.6                          0x00002b891547a460 __libc_start_main +
    245

    6    tmptqtpr8mo                        0x00005595973ee2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings == nil {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.length > longestString.length\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmptkhdin7r.swift:11:16: warning: comparing non-optional value of\
    \ type '[String]' to 'nil' always returns false\n    if strings == nil {\n   \
    \    ~~~~~~~ ^  ~~~\n/tmp/tmptkhdin7r.swift:16:19: error: value of type 'String'\
    \ has no member 'length'\n        if string.length > longestString.length {\n\
    \           ~~~~~~ ^~~~~~\n/tmp/tmptkhdin7r.swift:16:42: error: value of type\
    \ 'String' has no member 'length'\n        if string.length > longestString.length\
    \ {\n                           ~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings == nil {\n        return nil\n    }\n    let sortedStrings\
    \ = strings.sorted(by: { $0.count > $1.count })\n    return sortedStrings.first\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n    let length = strings.reduce(0,\
    \ {$0 + $1.count})\n    if length < 0 {\n        return nil\n    }\n    let maxString\
    \ = strings.reduce(\"\") {\n        var accum = $0\n        if let idx = $1.index(before:\
    \ $0.endIndex, offsetBy: 1) {\n            accum = String(self[idx..<idx].joined())\n\
    \        }\n        return accum\n    }\n    if maxString.count == length {\n\
    \        return maxString\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpuut1gg1g.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpuut1gg1g.swift:21:28:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n            accum = String(self[idx..<idx].joined())\n           \
    \                ^~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.count == 0 {\n        return nil\n    }\n\n    var longestString\
    \ = strings[0]\n    var minStringLength = StringMaxLength\n\n    for s in strings\
    \ {\n        guard s.count > minStringLength else { return nil }\n        if s.count\
    \ < minStringLength {\n            minStringLength = s.count\n            longestString\
    \ = s\n        }\n    }\n\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmph6a5_on2.swift:16:27: error: cannot find 'StringMaxLength' in scope\n\
    \    var minStringLength = StringMaxLength\n                          ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings.first\n\
    \    for s in strings {\n        if s.count > longest!.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings: strings, transform: nil)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxdgovc58.swift:11:49: error: extra argument 'transform' in call\n\
    \    return longest(strings: strings, transform: nil)\n                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpxdgovc58.swift:11:49: error: 'nil' requires a contextual type\n    return\
    \ longest(strings: strings, transform: nil)\n                                \
    \                ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty { return nil }\n    let longest = strings.reduce(\"\
    \") { $0.count<$1.count ? $0 : $1 }\n    if strings.count == 1 { return strings\
    \ as? String == longest ? longest : nil }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpj0fx4p3v/tmpj0fx4p3v.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5db9c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5db6bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5db6bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5db6ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj0fx4p3v                        0x00005625469dd94a <unavailable> + 6474

    5    libc.so.6                          0x00002af5dbbb0460 __libc_start_main +
    245

    6    tmpj0fx4p3v                        0x00005625469dd239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return max(strings) { longest, _ in\n        longest.count\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp6qxhmo78.swift:11:16: error: cannot convert value of type '[String]'\
    \ to expected argument type 'String'\n    return max(strings) { longest, _ in\n\
    \               ^\n/tmp/tmp6qxhmo78.swift:11:25: error: trailing closure passed\
    \ to parameter of type 'String' that does not accept a closure\n    return max(strings)\
    \ { longest, _ in\n                        ^~~~~~~~~~~~~~~\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmp6qxhmo78.swift:11:12: error:\
    \ generic parameter 'Element' could not be inferred\n    return max(strings) {\
    \ longest, _ in\n           ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestHelper(strings, 0, [], 0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpzonixshw.swift:11:12: error: cannot find 'longestHelper' in scope\n\
    \    return longestHelper(strings, 0, [], 0)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(\"\
    \") {\n        if $0.count < $1.count {\n            return $1\n        } else\
    \ {\n            return $0\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, emptyString: true)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpz8794qjd.swift:11:42: error: extra argument 'emptyString' in call\n\
    \    return longest(strings, emptyString: true)\n                  ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // Short-circuiting the first time through. Until then, we always have\
    \ to iterate over the full list.\n    guard !strings.isEmpty else { return nil\
    \ }\n\n    var maxLen: Int = 0\n    var longestStr: String? = nil\n\n    for s\
    \ in strings {\n        if s.count > maxLen {\n            maxLen = s.count\n\
    \            longestStr = s\n        }\n    }\n\n    return longestStr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  var longest = \"\"\n\n  for s in strings {\n    longest = s.count < longest.count\
    \ ? s : longest\n  }\n\n  return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8n1yg1dx/tmp8n1yg1dx.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b691f11ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b691ee11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b691ee11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b691ee107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8n1yg1dx                        0x000055f45c18a628 <unavailable> + 5672

    5    libc.so.6                          0x00002b691f306460 __libc_start_main +
    245

    6    tmp8n1yg1dx                        0x000055f45c18a249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longest(strings.map(String.init))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp87wna0gn.swift:11:18: error: missing argument label 'strings:'\
    \ in call\n  return longest(strings.map(String.init))\n                 ^\n  \
    \               strings: \n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let s = strings.reduce((max: String, next: String) in\n        max ==\
    \ next.length ? next : max)\n    return s == \"\" ? nil : s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmplq4f4yau.swift:11:56: error: expected ',' separator\n    let s\
    \ = strings.reduce((max: String, next: String) in\n                          \
    \                             ^\n                                            \
    \          ,\n/tmp/tmplq4f4yau.swift:11:56: error: expected expression in list\
    \ of expressions\n    let s = strings.reduce((max: String, next: String) in\n\
    \                                                       ^\n/tmp/tmplq4f4yau.swift:11:55:\
    \ error: missing argument for parameter #2 in call\n    let s = strings.reduce((max:\
    \ String, next: String) in\n                                                 \
    \     ^\n                                                      , <#((max: String,\
    \ next: String).Type, String) throws -> (max: String, next: String).Type#>\nSwift.Sequence:2:28:\
    \ note: 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n  let max = strings.reduce(\"\
    \") { $0.count < $1.count ? $0 : $1 }\n  return strings.filter({ $0.count == max.count\
    \ }).first\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpsrrm7yh1/tmpsrrm7yh1.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75e8e47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75e8b3eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75e8b3e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75e8b3d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsrrm7yh1                        0x0000555ac204da0a <unavailable> + 6666

    5    libc.so.6                          0x00002b75e9033460 __libc_start_main +
    245

    6    tmpsrrm7yh1                        0x0000555ac204d2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestInternal(strings, 0)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9qs5unpz.swift:11:12: error: cannot find 'longestInternal' in scope\n\
    \    return longestInternal(strings, 0)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    let maxCount =\
    \ strings.reduce(0, { acc, elem in\n        let count = elem.count\n        return\
    \ max(acc, count)\n    })\n\n    if maxCount == 0 {\n        return nil\n    }\n\
    \n    return strings[maxCount - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpnmn0k6zp/tmpnmn0k6zp.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f0b14ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f0ae45b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f0ae45988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f0ae447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnmn0k6zp                        0x000055584cf02d98 <unavailable> + 7576

    5    libc.so.6                          0x00002b0f0b33a460 __libc_start_main +
    245

    6    tmpnmn0k6zp                        0x000055584cf022c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(\"\
    \") { lhs, rhs in\n        return lhs.count < rhs.count ? lhs : rhs\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8lwhyocl/tmp8lwhyocl.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b015f38dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b015f084b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b015f084988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b015f0837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8lwhyocl                        0x0000556fcf42a8fa <unavailable> + 6394

    5    libc.so.6                          0x00002b015f579460 __libc_start_main +
    245

    6    tmp8lwhyocl                        0x0000556fcf42a1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if isEmpty(strings) {\n        return nil\n    }\n\n    var longestString\
    \ : String?\n    for s in strings {\n        if longestString == nil || len(s)\
    \ > len(longestString) {\n            longestString = s\n        }\n    }\n\n\
    \    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp76u76cc8.swift:11:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(strings) {\n       ^~~~~~~\n/tmp/tmp76u76cc8.swift:17:36: error:\
    \ cannot find 'len' in scope\n        if longestString == nil || len(s) > len(longestString)\
    \ {\n                                   ^~~\n/tmp/tmp76u76cc8.swift:17:45: error:\
    \ cannot find 'len' in scope\n        if longestString == nil || len(s) > len(longestString)\
    \ {\n                                            ^~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty() {\n        return nil\n    }\n    let longest =\
    \ strings.reduce(\"\") { (acc, curr) in\n        if acc.isEmpty {\n          \
    \  return curr\n        }\n        let (prev, curr) = acc.splitFirst()\n     \
    \   return (curr.length < prev.length) ? curr : prev\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpziyp21vo.swift:11:16: error: cannot call value of non-function\
    \ type 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n        \
    \              \n/tmp/tmpziyp21vo.swift:18:32: error: value of type 'String' has\
    \ no member 'splitFirst'\n        let (prev, curr) = acc.splitFirst()\n      \
    \                     ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    var longestIdx = 0\n    for idx, string\
    \ in strings.enumerated() {\n        if string.length <= longest.length {\n  \
    \          longest = string\n            longestIdx = idx\n        }\n    }\n\
    \    if longestIdx >= strings.count {\n        return nil\n    }\n    return strings[longestIdx]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp458zck52.swift:13:12: error: expected 'in' after for-each pattern\n\
    \    for idx, string in strings.enumerated() {\n           ^\n/tmp/tmp458zck52.swift:13:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, string in\
    \ strings.enumerated() {\n           ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n\tguard !strings.isEmpty else {\n\t\treturn nil\n\t}\n\treturn strings.reduce(into:\
    \ \"\") { $0 < $1.count ? $0 : $1 < $1.count ? $1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpwpo00hze.swift:14:71: error: expected ':' after '? ...' in ternary\
    \ expression\n        return strings.reduce(into: \"\") { $0 < $1.count ? $0 :\
    \ $1 < $1.count ? $1 }\n                                                     \
    \                        ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestWithIndex(strings.enumerated().map{ (index, value) -> String?\
    \ in\n        return value\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmppmalxwyu.swift:11:12: error: cannot find 'longestWithIndex' in\
    \ scope\n    return longestWithIndex(strings.enumerated().map{ (index, value)\
    \ -> String? in\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest: Int\
    \ = 0\n    var maxLength = 0\n    for i in strings.indices {\n        let len\
    \ = strings[i].characters.count\n        if len > maxLength {\n            maxLength\
    \ = len\n            longest = i\n        }\n    }\n\n    if longest < maxLength\
    \ {\n        return strings[longest]\n    }\n\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmptn6wz8du.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n        let len = strings[i].characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if !strings.isEmpty {\n    return strings.sort{ $0.count < $1.count }.first\n\
    \  }\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxlzi12a_.swift:12:20: error: cannot use mutating member on immutable\
    \ value: 'strings' is a 'let' constant\n    return strings.sort{ $0.count < $1.count\
    \ }.first\n           ~~~~~~~ ^\n/tmp/tmpxlzi12a_.swift:12:48: error: value of\
    \ tuple type '()' has no member 'first'\n    return strings.sort{ $0.count < $1.count\
    \ }.first\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestN(count: strings.count, argument: strings)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgk1p7gv2.swift:11:12: error: cannot find 'longestN' in scope\n\
    \    return longestN(count: strings.count, argument: strings)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestHelper(strings, 0).max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpbpmgju1h.swift:11:12: error: cannot find 'longestHelper' in scope\n\
    \    return longestHelper(strings, 0).max\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n\n  var longest = strings.reduce(0,\
    \ combineLongestLength)\n  if longest > strings[0].count {\n    return strings[0]\n\
    \  }\n\n  var result = strings[0]\n  for string in strings.dropFirst() {\n   \
    \ if string.count > longest {\n      longest = string.count\n      result = string\n\
    \    }\n  }\n\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpb4f9dxo7.swift:15:35: error: cannot find 'combineLongestLength'\
    \ in scope\n  var longest = strings.reduce(0, combineLongestLength)\n        \
    \                          ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb4f9dxo7.swift:15:35:\
    \ error: converting non-escaping value to '(Int, String) throws -> Int' may allow\
    \ it to escape\n  var longest = strings.reduce(0, combineLongestLength)\n    \
    \                              ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString = nil\n    for stringToCompare in strings {\n     \
    \   if stringToCompare.count > longestString.count {\n            longestString\
    \ = stringToCompare\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpavn30nnb.swift:11:25: error: 'nil' requires a contextual type\n\
    \    var longestString = nil\n                        ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else {\n        return nil\n    }\n\n    if strings.count\
    \ == 1 {\n        return strings[0]\n    }\n\n    var lengths = Array(repeating:\
    \ 0, count: strings.count)\n    for str in strings {\n        guard !str.isEmpty\
    \ else {\n            return nil\n        }\n        lengths[strings.index(str,\
    \ offsetBy: 0)] += 1\n    }\n\n    if lengths.isEmpty {\n        return nil\n\
    \    }\n\n    var longest: String = nil\n    var idx: Int = 0\n    var foundLongest:\
    \ Bool = false\n    for idx in 0..<lengths.count {\n        let length = lengths[idx]\n\
    \        if length > longest!.count {\n            longest = strings[idx]\n  \
    \          foundLongest = true\n        } else if length == longest!.count {\n\
    \            if foundLongest {\n                return longest\n            }\n\
    \        }\n    }\n\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmppjtfr6ie.swift:24:31: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        lengths[strings.index(str, offsetBy:\
    \ 0)] += 1\n                              ^\n/tmp/tmppjtfr6ie.swift:31:27: error:\
    \ 'nil' cannot initialize specified type 'String'\n    var longest: String = nil\n\
    \                          ^\n/tmp/tmppjtfr6ie.swift:31:18: note: add '?' to form\
    \ the optional type 'String?'\n    var longest: String = nil\n               \
    \  ^\n                       ?\n/tmp/tmppjtfr6ie.swift:36:28: error: cannot force\
    \ unwrap value of non-optional type 'String'\n        if length > longest!.count\
    \ {\n                    ~~~~~~~^\n                           \n/tmp/tmppjtfr6ie.swift:39:36:\
    \ error: cannot force unwrap value of non-optional type 'String'\n        } else\
    \ if length == longest!.count {\n                            ~~~~~~~^\n      \
    \                             \n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n\n    var maxLen = 0\n  \
    \  var longest = nil\n    for str in strings {\n        let newLen = str.characters.count\n\
    \        if newLen > maxLen {\n            maxLen = newLen\n            longest\
    \ = str\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpzm5648n1.swift:14:19: error: 'nil' requires a contextual type\n\
    \    var longest = nil\n                  ^\n/tmp/tmpzm5648n1.swift:16:26: error:\
    \ 'characters' is unavailable: Please use String directly\n        let newLen\
    \ = str.characters.count\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(from: strings)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpd9e9sumh.swift:11:19: error: incorrect argument label in call (have\
    \ 'from:', expected 'strings:')\n    return longest(from: strings)\n         \
    \         ^~~~~\n                   strings\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestInPlace(strings).first\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2jan1fz6.swift:11:12: error: cannot find 'longestInPlace' in scope\n\
    \    return longestInPlace(strings).first\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var lengths = stringList.map({ $0.count })\n    var bestString: String\
    \ = nil\n    var bestLength = Int.max\n    for length in lengths {\n        if\
    \ length == bestLength {\n            continue\n        }\n        if bestLength\
    \ == length {\n            bestLength = Int.max\n            bestString = nil\n\
    \        }\n        if bestString != nil && length == bestLength {\n         \
    \   continue\n        }\n        if bestLength < length {\n            bestLength\
    \ = length\n            bestString = stringList[lengths.index(lengths.startIndex,\
    \ offsetBy: length)]\n        }\n    }\n    return bestString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpf1p4t2bv.swift:11:19: error: cannot find 'stringList' in scope\n\
    \    var lengths = stringList.map({ $0.count })\n                  ^~~~~~~~~~\n\
    /tmp/tmpf1p4t2bv.swift:12:30: error: 'nil' cannot initialize specified type 'String'\n\
    \    var bestString: String = nil\n                             ^\n/tmp/tmpf1p4t2bv.swift:12:21:\
    \ note: add '?' to form the optional type 'String?'\n    var bestString: String\
    \ = nil\n                    ^\n                          ?\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let longest = strings.reduce((max, string) => {\n        return max ==\
    \ nil || string.length > max.length ? string : max\n    })\n\n    return longest\
    \ != nil ? longest : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t3ez8wt.swift:11:40: error: cannot find 'string' in scope\n  \
    \  let longest = strings.reduce((max, string) => {\n                         \
    \              ^~~~~~\n/tmp/tmp1t3ez8wt.swift:11:48: error: cannot find operator\
    \ '=>' in scope\n    let longest = strings.reduce((max, string) => {\n       \
    \                                        ^~\n/tmp/tmp1t3ez8wt.swift:12:30: error:\
    \ cannot find 'string' in scope\n        return max == nil || string.length >\
    \ max.length ? string : max\n                             ^~~~~~\n/tmp/tmp1t3ez8wt.swift:12:59:\
    \ error: cannot find 'string' in scope\n        return max == nil || string.length\
    \ > max.length ? string : max\n                                              \
    \            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longestIndexes(strings)[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpb8wk2nfl.swift:11:10: error: cannot find 'longestIndexes' in scope\n\
    \  return longestIndexes(strings)[0]\n         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var max: Int = 0\n    var longest: String?\n    for s in strings {\n\
    \        max = max > s.count ? max : s.count\n        if s.count == max {\n  \
    \          longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpper_d7ni/tmpper_d7ni.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20f976bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20f9462b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20f9462988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20f94617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpper_d7ni                        0x0000555bf1f8c95a <unavailable> + 6490

    5    libc.so.6                          0x00002b20f9957460 __libc_start_main +
    245

    6    tmpper_d7ni                        0x0000555bf1f8c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var max: Int? = nil\n    for string in strings {\n        if max is Int\
    \ {\n            if max > string.characters.count {\n                max = string.characters.count\n\
    \            }\n        } else {\n            if let max = max {\n           \
    \     if max < string.characters.count {\n                    max = nil\n    \
    \            }\n            } else {\n                max = string.characters.count\n\
    \            }\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4sqt0_r2.swift:13:16: warning: checking a value with optional type\
    \ 'Int?' against type 'Int' succeeds whenever the value is non-nil; did you mean\
    \ to use '!= nil'?\n        if max is Int {\n           ~~~ ^~~~~~\n         \
    \      != nil\n/tmp/tmp4sqt0_r2.swift:14:16: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n            if max > string.characters.count\
    \ {\n               ^\n/tmp/tmp4sqt0_r2.swift:14:16: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n            if\
    \ max > string.characters.count {\n               ^\n                   ?? <#default\
    \ value#>\n/tmp/tmp4sqt0_r2.swift:14:16: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            if max > string.characters.count\
    \ {\n               ^\n                  !\n/tmp/tmp4sqt0_r2.swift:15:30: error:\
    \ 'characters' is unavailable: Please use String directly\n                max\
    \ = string.characters.count\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp4sqt0_r2.swift:19:33: error: 'characters'\
    \ is unavailable: Please use String directly\n                if max < string.characters.count\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp4sqt0_r2.swift:20:21: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n                    max = nil\n                 \
    \   ^~~\n/tmp/tmp4sqt0_r2.swift:20:27: error: 'nil' cannot be assigned to type\
    \ 'Int'\n                    max = nil\n                          ^\n/tmp/tmp4sqt0_r2.swift:23:30:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \     max = string.characters.count\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4sqt"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  var longest: String = String()\n  for str in strings {\n    if str.length\
    \ >= longest.length {\n      longest = str\n    }\n  }\n  return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2m5znrqm.swift:13:12: error: value of type 'String' has no member\
    \ 'length'\n    if str.length >= longest.length {\n       ~~~ ^~~~~~\n/tmp/tmp2m5znrqm.swift:13:30:\
    \ error: value of type 'String' has no member 'length'\n    if str.length >= longest.length\
    \ {\n                     ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else {\n        return nil\n    }\n\n    var longest\
    \ = \"\"\n    var longestLongest = String()\n    for s in strings {\n        if\
    \ s.count > longest.count {\n            longest = s\n            longestLongest\
    \ = longest\n        } else {\n            if s.count < longest.count {\n    \
    \            longest = s\n                longestLongest = longest\n         \
    \   }\n        }\n    }\n\n    return longestLongest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp84cibxqf/tmp84cibxqf.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6412bf0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b64128e7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b64128e7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b64128e67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp84cibxqf                        0x0000562f3e079da8 <unavailable> + 7592

    5    libc.so.6                          0x00002b6412ddc460 __libc_start_main +
    245

    6    tmp84cibxqf                        0x0000562f3e0792d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.IsEmpty() {\n        return nil\n    }\n\n    // Create a\
    \ map with all the strings' lengths. Sort the map by value, and get the first\
    \ one\n    // by enumerating it.\n    var lengths = strings.map { $0.length }\n\
    \    if lengths.isEmpty {\n        return nil\n    }\n    lengths.sortInPlace()\n\
    \    guard let firstLongest = lengths.first else {\n        return nil\n    }\n\
    \n    // If the longest string is longer than all the strings, return it right\
    \ away.\n    if longestLength == nil {\n        return firstLongest\n    }\n\n\
    \    // If the first longest string has the same length, return it.\n    if let\
    \ index = strings.firstIndex(where: {$0.length == longestLength!}) {\n       \
    \ return strings[index]\n    }\n\n    // If all the strings have the same length,\
    \ return the longest one\n    return firstLongest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp1phtd4jr.swift:11:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty() {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmp1phtd4jr.swift:17:36:\
    \ error: value of type 'String' has no member 'length'\n    var lengths = strings.map\
    \ { $0.length }\n                                ~~ ^~~~~~\n/tmp/tmp1phtd4jr.swift:27:8:\
    \ error: cannot find 'longestLength' in scope\n    if longestLength == nil {\n\
    \       ^~~~~~~~~~~~~\n/tmp/tmp1phtd4jr.swift:32:60: error: cannot find 'longestLength'\
    \ in scope\n    if let index = strings.firstIndex(where: {$0.length == longestLength!})\
    \ {\n                                                           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty { return nil }\n    let longest = strings[0]\n   \
    \ for string in strings {\n        if string.count > longest.count {\n       \
    \     longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp_giikezw.swift:15:13: error: cannot assign to value: 'longest'\
    \ is a 'let' constant\n            longest = string\n            ^~~~~~~\n/tmp/tmp_giikezw.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let longest = strings[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings.first!\n\
    \    for s in strings {\n        if s.count < longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpe5lv5zvf/tmpe5lv5zvf.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44e5558c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44e524fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44e524f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44e524e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe5lv5zvf                        0x000055f132a97e58 <unavailable> + 7768

    5    libc.so.6                          0x00002b44e5744460 __libc_start_main +
    245

    6    tmpe5lv5zvf                        0x000055f132a97389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n  strings.sort(by: >)\n  return\
    \ strings.first!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxbmbz83q.swift:14:11: error: cannot use mutating member on immutable\
    \ value: 'strings' is a 'let' constant\n  strings.sort(by: >)\n  ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n\n    var maxLength = 0\n\
    \    var longestString: String?\n\n    for string in strings {\n        let length\
    \ = (string as NSString).length\n        if length > maxLength {\n           \
    \ maxLength = length\n            longestString = string\n        }\n    }\n\n\
    \    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9t8geair.swift:17:33: error: cannot find type 'NSString' in scope\n\
    \        let length = (string as NSString).length\n                          \
    \      ^~~~~~~~\n/tmp/tmp9t8geair.swift:17:43: error: value of type 'String' has\
    \ no member 'length'\n        let length = (string as NSString).length\n     \
    \                ~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings: strings, length: Int64.max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp_o0vzwl2.swift:11:52: error: extra argument 'length' in call\n\
    \    return longest(strings: strings, length: Int64.max)\n                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    return strings.reduce(String.max,\
    \ { lhs, rhs in\n        return lhs.characters.count < rhs.characters.count ?\
    \ lhs : rhs\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5w_gu13.swift:15:34: error: cannot convert value of type '(String)\
    \ -> () -> String.Element?' (aka '(String) -> () -> Optional<Character>') to expected\
    \ argument type 'String'\n    return strings.reduce(String.max, { lhs, rhs in\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    longestImpl(\"\", strings.count())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7qeav8mx.swift:11:5: error: cannot find 'longestImpl' in scope\n\
    \    longestImpl(\"\", strings.count())\n    ^~~~~~~~~~~\n/tmp/tmp7qeav8mx.swift:11:29:\
    \ error: cannot call value of non-function type 'Int'\n    longestImpl(\"\", strings.count())\n\
    \                            ^    ~~\n                                 \n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longestInPlace(strings, lengths: strings.map { str in str.count\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(longest(strings: [] as [String])\
    \ == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings:\
    \ [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpk_qfwhnf.swift:11:10: error: cannot find 'longestInPlace' in scope\n\
    \  return longestInPlace(strings, lengths: strings.map { str in str.count })\n\
    \         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, longestStringLength)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpa01hgq53.swift:11:29: error: cannot find 'longestStringLength'\
    \ in scope\n    return longest(strings, longestStringLength)\n               \
    \             ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpa01hgq53.swift:11:29: error: extra\
    \ argument in call\n    return longest(strings, longestStringLength)\n       \
    \           ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  guard !strings.isEmpty else {\n    return nil\n  }\n\n  // Create a dictionary\
    \ to store the longest string and its length\n  var longest = Dictionary<Int,\
    \ String>()\n\n  for item in strings {\n    let length = item.length\n\n    //\
    \ If string already exists, update its length\n    if longest.keys.contains(length)\
    \ {\n      longest[length] = item\n    } else {\n      // If string doesn't exist\
    \ in dictionary, create a new dictionary entry\n      let newLongest = Dictionary<Int,\
    \ String>()\n\n      // Set longest as new dictionary entry\n      longest = newLongest\n\
    \n      // Add this length as key for new entry\n      longest[length] = item\n\
    \    }\n  }\n\n  // Return the longest string\n  return longest[longest.keys.maxElement()].value\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxc8z0z6p.swift:19:23: error: value of type 'String' has no member\
    \ 'length'\n    let length = item.length\n                 ~~~~ ^~~~~~\n/tmp/tmpxc8z0z6p.swift:37:31:\
    \ error: value of type 'Dictionary<Int, String>.Keys' has no member 'maxElement'\n\
    \  return longest[longest.keys.maxElement()].value\n                 ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let longest = strings.reduce(\"\
    \") {\n        if let length = $1.count, length > $0.count {\n            $0 =\
    \ $1\n        }\n        return $0\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpqwx68v5x.swift:16:13: error: cannot assign to value: '$0' is immutable\n\
    \            $0 = $1\n            ^~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ \"\"\n    for string in strings {\n        if string.isEmpty || len(longest)\
    \ < len(string) {\n            longest = string\n        }\n    }\n\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpovn5afiw.swift:17:30: error: cannot find 'len' in scope\n     \
    \   if string.isEmpty || len(longest) < len(string) {\n                      \
    \       ^~~\n/tmp/tmpovn5afiw.swift:17:45: error: cannot find 'len' in scope\n\
    \        if string.isEmpty || len(longest) < len(string) {\n                 \
    \                           ^~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    let longest = strings.reduce(\"\
    \") { (s1, s2) in\n        let (max1, max2) = (s1.count, s2.count)\n        if\
    \ max1 > max2 {\n            return s1\n        } else if max2 > max1 {\n    \
    \        return s2\n        } else {\n            return s1\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings == nil || strings.isEmpty {\n    return nil\n  }\n  var longest\
    \ = strings[0]\n  for s in strings {\n    if longest.count < s.count {\n     \
    \ longest = s\n    }\n  }\n  return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.map { $0.length })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpwy6h1uz5.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.map { $0.length })\n                   ^\n\
    \                   strings: \n/tmp/tmpwy6h1uz5.swift:11:37: error: value of type\
    \ 'String' has no member 'length'\n    return longest(strings.map { $0.length\
    \ })\n                                 ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty() {\n        return nil\n    }\n\n    var longest\
    \ = String()\n    var currentLongest = String()\n\n    for string in strings {\n\
    \        if string.characters.count > currentLongest.characters.count {\n    \
    \        currentLongest = string\n        }\n\n        if string.characters.count\
    \ == currentLongest.characters.count {\n            if longest == \"\" {\n   \
    \             longest = currentLongest\n            } else {\n               \
    \ if currentLongest > longest {\n                    longest = currentLongest\n\
    \                }\n            }\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp418jkupk.swift:11:16: error: cannot call value of non-function\
    \ type 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n        \
    \              \n/tmp/tmp418jkupk.swift:19:19: error: 'characters' is unavailable:\
    \ Please use String directly\n        if string.characters.count > currentLongest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp418jkupk.swift:19:53: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > currentLongest.characters.count\
    \ {\n                                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp418jkupk.swift:23:19: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters.count\
    \ == currentLongest.characters.count {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp418jkupk.swift:23:54: error: 'characters'\
    \ is unavailable: Please use String directly\n        if string.characters.count\
    \ == currentLongest.characters.count {\n                                     \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let longest = strings.reduce(\"\") { (longest, str) in\n        return\
    \ maxLength(longest, str)\n    }\n    return longest.count == 0 ? nil : longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpuuzt9_pi.swift:12:16: error: cannot find 'maxLength' in scope\n\
    \        return maxLength(longest, str)\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings.compactMap({ $0 }))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmppznler6h.swift:11:20: error: missing argument label 'strings:'\
    \ in call\n    return longest(strings.compactMap({ $0 }))\n                  \
    \ ^\n                   strings: \n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let longestString = strings.reduce(into: \"\") { longestString,\
    \ current in\n        if current.count == longestString.count {\n            longestString\
    \ += current\n        } else {\n            longestString = current\n        }\n\
    \    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp25q3jo75.swift:11:56: error: expected 'else' after 'guard' condition\n\
    \    guard let longestString = strings.reduce(into: \"\") { longestString, current\
    \ in\n                                                       ^\n             \
    \                                          else \n/tmp/tmp25q3jo75.swift:11:71:\
    \ error: consecutive statements on a line must be separated by ';'\n    guard\
    \ let longestString = strings.reduce(into: \"\") { longestString, current in\n\
    \                                                                      ^\n   \
    \                                                                   ;\n/tmp/tmp25q3jo75.swift:11:71:\
    \ error: expected expression\n    guard let longestString = strings.reduce(into:\
    \ \"\") { longestString, current in\n                                        \
    \                              ^\n/tmp/tmp25q3jo75.swift:11:54: error: missing\
    \ argument for parameter #2 in call\n    guard let longestString = strings.reduce(into:\
    \ \"\") { longestString, current in\n                                        \
    \             ^\n                                                     , <#(inout\
    \ String?, String) throws -> ()#>\nSwift.Sequence:3:28: note: 'reduce(into:_:)'\
    \ declared here\n    @inlinable public func reduce<Result>(into initialResult:\
    \ __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result,\
    \ Self.Element) throws -> ()) rethrows -> Result\n                           ^\n\
    /tmp/tmp25q3jo75.swift:11:58: error: cannot find 'longestString' in scope\n  \
    \  guard let longestString = strings.reduce(into: \"\") { longestString, current\
    \ in\n                                                         ^~~~~~~~~~~~~\n\
    /tmp/tmp25q3jo75.swift:12:12: error: cannot find 'current' in scope\n        if\
    \ current.count == longestString.count {\n           ^~~~~~~\n/tmp/tmp25q3jo75.swift:12:29:\
    \ error: cannot find 'longestString' in scope\n        if current.count == longestString.count\
    \ {\n                            ^~~~~~~~~~~~~\n/tmp/tmp25q3jo75.swift:13:13:\
    \ error: cannot find 'longestString' in scope\n            longestString += current\n\
    \        "
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    let longest = strings.maxLength\n\
    \    return longest.firstOrNil()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmppvt_el40.swift:12:27: error: value of type '[String]' has no member\
    \ 'maxLength'\n    let longest = strings.maxLength\n                  ~~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    \n    var maxLen\
    \ = UInt32(0)\n    var longestString: String?\n    for str in strings {\n    \
    \    guard let str = str as? String, str.characters.count > maxLen else {\n  \
    \          return nil\n        }\n        maxLen = str.characters.count\n    \
    \    longestString = str\n    }\n    \n    return longestString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpme08mbn8.swift:18:29: warning: conditional cast from 'String' to\
    \ 'String' always succeeds\n        guard let str = str as? String, str.characters.count\
    \ > maxLen else {\n                            ^\n/tmp/tmpme08mbn8.swift:18:45:\
    \ error: 'characters' is unavailable: Please use String directly\n        guard\
    \ let str = str as? String, str.characters.count > maxLen else {\n           \
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpme08mbn8.swift:21:33: error: cannot assign value of\
    \ type 'Int' to type 'UInt32'\n        maxLen = str.characters.count\n       \
    \          ~~~~~~~~~~~~~~~^~~~~\n                 UInt32(             )\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let max = strings[0]\n    for string in strings {\n        if string.count\
    \ > max.count {\n            max = string\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpptbkc81c.swift:14:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = string\n            ^~~\n/tmp/tmpptbkc81c.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = strings[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  var best: String? = nil\n  var max: String? = nil\n  for s in strings {\
    \ // FIXME: Switch to for in\n    if s.count > best.count || (best.count == s.count\
    \ && best.compare(s) == .orderedAscending) {\n      best = s\n      max = s\n\
    \    }\n  }\n  return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8zzhsr0i.swift:14:63: error: value of type 'String?' has no member\
    \ 'compare'\n    if s.count > best.count || (best.count == s.count && best.compare(s)\
    \ == .orderedAscending) {\n                                                  \
    \       ~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpc3juz6rx.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, nil)\n                  ~~~~~~~~~~^~~~\n/tmp/tmpc3juz6rx.swift:11:29:\
    \ error: 'nil' requires a contextual type\n    return longest(strings, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.sorted().reduce(nil)\
    \ { longest, string in\n        guard longest == nil || longest!.count < string.count\
    \ else { return longest }\n        return string\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp1pa76_cq/tmp1pa76_cq.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ea3a15c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ea370cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ea370c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ea370b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1pa76_cq                        0x0000563a6a58ede8 <unavailable> + 7656

    5    libc.so.6                          0x00002b9ea3c01460 __libc_start_main +
    245

    6    tmp1pa76_cq                        0x0000563a6a58e319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ \"\"\n    for s in strings {\n        if s.count > longest.count {\n       \
    \     longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4aol9jf_.swift:11:29: error: extra argument in call\n    return\
    \ longest(strings, { $0.count })\n                  ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013892
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if !strings.isEmpty {\n        var longest = strings[0]\n        for\
    \ string in strings {\n            if string.length > longest.length {\n     \
    \           longest = string\n            }\n        }\n        return longest\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpf7jyfpx8.swift:14:23: error: value of type 'String' has no member\
    \ 'length'\n            if string.length > longest.length {\n               ~~~~~~\
    \ ^~~~~~\n/tmp/tmpf7jyfpx8.swift:14:40: error: value of type 'String' has no member\
    \ 'length'\n            if string.length > longest.length {\n                \
    \               ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings == nil || strings.isEmpty() {\n    return nil\n  }\n  var longest\
    \ = strings[0]\n  for string in strings {\n    if string.count > longest.count\
    \ {\n      longest = string\n    }\n  }\n  return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xkwwabv.swift:11:32: error: cannot call value of non-function\
    \ type 'Bool'\n  if strings == nil || strings.isEmpty() {\n                  \
    \             ^      ~~\n                                      \n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  let count = strings.length\n\n  for index in 0..<count {\n    if let longest\
    \ = strings.max(by: {$0.count < $1.count}) {\n      return longest\n    }\n  }\n\
    \  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp_nqf69l7.swift:11:23: error: value of type '[String]' has no member\
    \ 'length'\n  let count = strings.length\n              ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    switch strings.count {\n    case 0: return nil\n    case 1: return strings[0]\n\
    \    default: return strings.reduce(into: \"\") { longest, str in\n        longest.isEmpty\
    \ ? longest = str : longest.characters.count > str.characters.count ? longest\
    \ : str\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4q2lo82s.swift:34:79: error: expected '}' at end of brace statement\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")\n                                                            \
    \                  ^\n/tmp/tmp4q2lo82s.swift:10:44: note: to match this opening\
    \ '{'\nfunc longest(strings: [String]) -> String? {\n                        \
    \                   ^\n/tmp/tmp4q2lo82s.swift:15:35: error: result values in '?\
    \ :' expression have mismatching types '()' and 'String'\n        longest.isEmpty\
    \ ? longest = str : longest.characters.count > str.characters.count ? longest\
    \ : str\n                          ~~~~~~~~^~~~~\n/tmp/tmp4q2lo82s.swift:20:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce((prev:\
    \ String, next: String) -> String? in\n        guard prev?.length == next.length\
    \ else { return nil }\n        return prev\n    )\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpaspshi8w.swift:12:67: error: expected ',' separator\n    return\
    \ strings.reduce((prev: String, next: String) -> String? in\n                \
    \                                                  ^\n                       \
    \                                          ,\n/tmp/tmpaspshi8w.swift:12:67: error:\
    \ expected expression in list of expressions\n    return strings.reduce((prev:\
    \ String, next: String) -> String? in\n                                      \
    \                            ^\n/tmp/tmpaspshi8w.swift:12:27: error: missing argument\
    \ for parameter 'into' in call\n    return strings.reduce((prev: String, next:\
    \ String) -> String? in\n                          ^\n                       \
    \   into: <#String?#>, \nSwift.Sequence:3:28: note: 'reduce(into:_:)' declared\
    \ here\n    @inlinable public func reduce<Result>(into initialResult: __owned\
    \ Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Self.Element)\
    \ throws -> ()) rethrows -> Result\n                           ^\n/tmp/tmpaspshi8w.swift:12:27:\
    \ error: cannot convert value of type '((String, String) -> String?).Type' to\
    \ expected argument type '(inout String?, String) throws -> ()'\n    return strings.reduce((prev:\
    \ String, next: String) -> String? in\n                          ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n\treturn longest(arrays.toArrayOfStrings(strings))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpt29j_kch.swift:11:17: error: cannot find 'arrays' in scope\n  \
    \      return longest(arrays.toArrayOfStrings(strings))\n                    \
    \   ^~~~~~\n/tmp/tmpt29j_kch.swift:11:17: error: missing argument label 'strings:'\
    \ in call\n        return longest(arrays.toArrayOfStrings(strings))\n        \
    \               ^\n                       strings: \n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty { return nil }\n  var maxLength = strings.first!.length\n\
    \  var longest = strings.first!\n  for string in strings.dropFirst() {\n    if\
    \ string.length > maxLength {\n      maxLength = string.length\n      longest\
    \ = string\n    }\n  }\n  return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpkzcjx2jf.swift:12:34: error: value of type 'String' has no member\
    \ 'length'\n  var maxLength = strings.first!.length\n                  ~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpkzcjx2jf.swift:15:15: error: value of type 'String' has no member\
    \ 'length'\n    if string.length > maxLength {\n       ~~~~~~ ^~~~~~\n/tmp/tmpkzcjx2jf.swift:16:26:\
    \ error: value of type 'String' has no member 'length'\n      maxLength = string.length\n\
    \                  ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String? = nil\n    for str in strings {\n        if\
    \ longestString == nil || longestString.count < str.count {\n            longestString\
    \ = str\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpkk2crho6.swift:13:36: error: value of optional type 'String?' must\
    \ be unwrapped to refer to member 'count' of wrapped base type 'String'\n    \
    \    if longestString == nil || longestString.count < str.count {\n          \
    \                         ^\n/tmp/tmpkk2crho6.swift:13:36: note: chain the optional\
    \ using '?' to access member 'count' only for non-'nil' base values\n        if\
    \ longestString == nil || longestString.count < str.count {\n                \
    \                   ^\n                                                ?\n/tmp/tmpkk2crho6.swift:13:36:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if longestString == nil || longestString.count < str.count {\n\
    \                                   ^\n                                      \
    \          !\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else {\n        return nil\n    }\n    var maxLength\
    \ = 0\n    var longest: String = nil\n    for str in strings {\n        let length\
    \ = str.characters.count\n        if length > maxLength {\n            maxLength\
    \ = length\n            longest = str\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmppnayrnhh.swift:15:27: error: 'nil' cannot initialize specified\
    \ type 'String'\n    var longest: String = nil\n                          ^\n\
    /tmp/tmppnayrnhh.swift:15:18: note: add '?' to form the optional type 'String?'\n\
    \    var longest: String = nil\n                 ^\n                       ?\n\
    /tmp/tmppnayrnhh.swift:17:26: error: 'characters' is unavailable: Please use String\
    \ directly\n        let length = str.characters.count\n                      \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longestImpl(strings).longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpcl4j793l.swift:11:10: error: cannot find 'longestImpl' in scope\n\
    \  return longestImpl(strings).longest\n         ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let longestLength = 0\n    for s in strings {\n        let length = s.count\n\
    \        if length > longestLength {\n            longestLength = length\n   \
    \     }\n    }\n    if longestLength == 0 {\n        return nil\n    }\n    for\
    \ s in strings {\n        if longestLength != s.count {\n            return s\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpw9x2x8bs.swift:15:13: error: cannot assign to value: 'longestLength'\
    \ is a 'let' constant\n            longestLength = length\n            ^~~~~~~~~~~~~\n\
    /tmp/tmpw9x2x8bs.swift:11:5: note: change 'let' to 'var' to make it mutable\n\
    \    let longestLength = 0\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.count == 0 {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for i in 1..<strings.count {\n        if strings[i].count >\
    \ longest.count {\n            longest = strings[i]\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = \"\"\n    for string in strings {\n        if string.count\
    \ == longest.count {\n            return string\n        }\n        if longest.count\
    \ > 0 {\n            if longest.count < string.count {\n                return\
    \ nil\n            }\n        }\n        longest = string\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8yvuesta/tmp8yvuesta.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2fc032dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2fc0024b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2fc0024988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2fc00237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8yvuesta                        0x0000563af5947628 <unavailable> + 5672

    5    libc.so.6                          0x00002b2fc0519460 __libc_start_main +
    245

    6    tmp8yvuesta                        0x0000563af5947249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else {\n        return nil\n    }\n \
    \   return strings.reduce(first, maxLengthOfArray: 0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmplb3xqcye.swift:14:26: error: extraneous argument label 'maxLengthOfArray:'\
    \ in call\n    return strings.reduce(first, maxLengthOfArray: 0)\n           \
    \              ^       ~~~~~~~~~~~~~~~~~~\n                                 \n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings == nil || strings.isEmpty {\n        return nil\n    }\n \
    \   var longest = \"\"\n    for string in strings {\n        if string != \"\"\
    \ && longest.count < string.count {\n            longest = string\n        }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  let longest = strings.maxElement()\n  return longest != nil ? longest!\
    \ : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmwp1x7vi.swift:11:25: error: value of type '[String]' has no member\
    \ 'maxElement'\n  let longest = strings.maxElement()\n                ~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let longest = strings.reduce((max, cur) -> String? {\n        let len\
    \ = cur.utf8.count\n        return len > max?.utf8.count ?? len ?? max?.utf8.count\
    \ ?? 0\n    }, nil)\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp83otcsyw.swift:11:40: error: cannot find 'cur' in scope\n    let\
    \ longest = strings.reduce((max, cur) -> String? {\n                         \
    \              ^~~\n/tmp/tmp83otcsyw.swift:12:19: error: cannot find 'cur' in\
    \ scope\n        let len = cur.utf8.count\n                  ^~~\n/tmp/tmp83otcsyw.swift:11:34:\
    \ error: expected type before '->'\n    let longest = strings.reduce((max, cur)\
    \ -> String? {\n                                 ^\n/tmp/tmp83otcsyw.swift:11:48:\
    \ error: expected type after '->'\n    let longest = strings.reduce((max, cur)\
    \ -> String? {\n                                               ^\n/tmp/tmp83otcsyw.swift:14:8:\
    \ error: 'nil' is not compatible with expected argument type '(_.Type, String)\
    \ throws -> _.Type'\n    }, nil)\n       ^\n"
  stdout: ''
  timestamp: 1660014003
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.maxBy({ (string, string2) in string.count })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpb_h0h1t4.swift:11:20: error: value of type '[String]' has no member\
    \ 'maxBy'\n    return strings.maxBy({ (string, string2) in string.count })\n \
    \          ~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings == nil || strings.isEmpty() {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgbg0eqzx.swift:11:34: error: cannot call value of non-function\
    \ type 'Bool'\n    if strings == nil || strings.isEmpty() {\n                \
    \                 ^      ~~\n                                        \n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let maxSize = strings.map({\
    \ $0.count }).max()!\n    return strings.sorted(by: { $0.count < $1.count }).first(where:\
    \ { $0.count == maxSize })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // longest is O(n), so it's better to do that in two passes\n    // first\
    \ pass: compute longest from shortest string\n    var longest: String? = nil\n\
    \    var shortest = strings.reduce((minLen: Int, curString: String) -> Int {\n\
    \        return (minLen > curString.characters.count) ? minLen : curString.characters.count\n\
    \    })\n    for curString in strings {\n        let curLen = curString.characters.count\n\
    \        if curLen > shortest {\n            longest = curString\n           \
    \ shortest = curLen\n        }\n    }\n    // second pass: return the longest\
    \ if there's more than one string\n    return longest == nil ? nil : longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp3nvbmzeh.swift:15:17: error: cannot find 'minLen' in scope\n  \
    \      return (minLen > curString.characters.count) ? minLen : curString.characters.count\n\
    \                ^~~~~~\n/tmp/tmp3nvbmzeh.swift:15:26: error: cannot find 'curString'\
    \ in scope\n        return (minLen > curString.characters.count) ? minLen : curString.characters.count\n\
    \                         ^~~~~~~~~\n/tmp/tmp3nvbmzeh.swift:15:56: error: cannot\
    \ find 'minLen' in scope\n        return (minLen > curString.characters.count)\
    \ ? minLen : curString.characters.count\n                                    \
    \                   ^~~~~~\n/tmp/tmp3nvbmzeh.swift:15:65: error: cannot find 'curString'\
    \ in scope\n        return (minLen > curString.characters.count) ? minLen : curString.characters.count\n\
    \                                                                ^~~~~~~~~\n/tmp/tmp3nvbmzeh.swift:14:71:\
    \ error: expected type after '->'\n    var shortest = strings.reduce((minLen:\
    \ Int, curString: String) -> Int {\n                                         \
    \                             ^\n/tmp/tmp3nvbmzeh.swift:16:6: error: missing argument\
    \ for parameter #2 in call\n    })\n     ^\n     , <#(_.Type, String) throws ->\
    \ _.Type#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable\
    \ public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_\
    \ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmp3nvbmzeh.swift:18:32: error: 'characters'\
    \ is unavailable: Please use String directly\n        let curLen = curString.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings == nil {\n        return nil\n    }\n    return strings.reduce(into:\
    \ [String](), { result, string in\n        var currentLongestLength = 0\n    \
    \    for string in result {\n            let length = string.characters.count\n\
    \            if length > currentLongestLength {\n                currentLongestLength\
    \ = length\n            }\n        }\n        result.append(string)\n        currentLongestLength\
    \ = currentLongestLength ?? 0\n        for string in result {\n            string.length\
    \ = currentLongestLength\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmprmoqi1_1.swift:11:16: warning: comparing non-optional value of\
    \ type '[String]' to 'nil' always returns false\n    if strings == nil {\n   \
    \    ~~~~~~~ ^  ~~~\n/tmp/tmprmoqi1_1.swift:14:20: error: type of expression is\
    \ ambiguous without more context\n    return strings.reduce(into: [String](),\
    \ { result, string in\n           ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty() {\n        return nil\n    }\n\n    var maxLength:\
    \ Int = 0\n    var longest: String?\n\n    for s in strings {\n        let len\
    \ = s.count ?? 0\n        if len > maxLength {\n            maxLength = len\n\
    \            longest = s\n        }\n    }\n\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpne16monr.swift:11:16: error: cannot call value of non-function\
    \ type 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n        \
    \              \n/tmp/tmpne16monr.swift:19:27: warning: left side of nil coalescing\
    \ operator '??' has non-optional type 'Int', so the right side is never used\n\
    \        let len = s.count ?? 0\n                  ~~~~~~~ ^~~~\n            \
    \              \n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // Check parameter\n    guard !strings.isEmpty else { return nil }\n\n\
    \    // Get the max string length\n    var maxStringLength = 0\n    for s in strings\
    \ {\n        let stringLength = s.characters.count\n        if stringLength >\
    \ maxStringLength {\n            maxStringLength = stringLength\n        }\n \
    \   }\n\n    // Search for the longest one in array of strings\n    var longest:\
    \ String?\n    for s in strings {\n        if maxStringLength == s.characters.count\
    \ {\n            longest = s\n            break\n        }\n    }\n\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7b3m2nks.swift:17:30: error: 'characters' is unavailable: Please\
    \ use String directly\n        let stringLength = s.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7b3m2nks.swift:26:33: error: 'characters' is unavailable: Please\
    \ use String directly\n        if maxStringLength == s.characters.count {\n  \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var longest =\
    \ strings[0]\n    for string in strings.dropFirst() {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var stringLengths: [Int] = [0]\n    var longestIndex = 0\n    for index\
    \ in 0..<strings.count {\n        stringLengths[index] = strings[index].count\n\
    \        if stringLengths[index] > stringLengths[longestIndex] {\n           \
    \ longestIndex = index\n        }\n    }\n    return strings[longestIndex] ??\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0de929c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0de620561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0de620286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0de62013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0de61fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0de41ffc3 <unavailable> + 188355

    6    tmpplblzuk4                        0x0000565160c1e11e <unavailable> + 8478

    7    tmpplblzuk4                        0x0000565160c1d6b0 <unavailable> + 5808

    8    libc.so.6                          0x00002ad0deb15460 __libc_start_main +
    245

    9    tmpplblzuk4                        0x0000565160c1d3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longest(strings: strings, transform: nil)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpbfvb6yap.swift:11:47: error: extra argument 'transform' in call\n\
    \  return longest(strings: strings, transform: nil)\n                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpbfvb6yap.swift:11:47: error: 'nil' requires a contextual type\n  return\
    \ longest(strings: strings, transform: nil)\n                                \
    \              ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString = String()\n    var longestIndex = -1\n    for index\
    \ in 0..<strings.count {\n        let string = strings[index]\n        if longestString.isEmpty\
    \ {\n            longestString = string\n            longestIndex = index\n  \
    \      } else if longestString.characters.count < string.characters.count {\n\
    \            longestString = string\n            longestIndex = index\n      \
    \  }\n    }\n    return longestIndex != -1 ? strings[longestIndex] : nil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9qyw_uc7.swift:18:33: error: 'characters' is unavailable: Please\
    \ use String directly\n        } else if longestString.characters.count < string.characters.count\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9qyw_uc7.swift:18:59: error: 'characters' is unavailable:\
    \ Please use String directly\n        } else if longestString.characters.count\
    \ < string.characters.count {\n                                              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    if strings.count\
    \ == 1 {\n        return strings[0]\n    }\n    return strings.maxElement()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ce2pgog.swift:17:20: error: value of type '[String]' has no member\
    \ 'maxElement'\n    return strings.maxElement()\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longestNonEmpty(strings: strings, maxLength: -1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpd3qt1w75.swift:11:10: error: cannot find 'longestNonEmpty' in scope\n\
    \  return longestNonEmpty(strings: strings, maxLength: -1)\n         ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, maxLength: 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmppg_3izxc.swift:11:40: error: extra argument 'maxLength' in call\n\
    \    return longest(strings, maxLength: 1)\n                  ~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: -1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings: strings.sorted())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014009
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    longest := strings.reduce(Int.max,\
    \ {$0.compare($1) < 0 ? $0 : $1})\n    return longest.count == 1 ? longest[0]\
    \ : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpqgl6ar8_.swift:14:12: error: consecutive statements on a line must\
    \ be separated by ';'\n    longest := strings.reduce(Int.max, {$0.compare($1)\
    \ < 0 ? $0 : $1})\n           ^\n           ;\n/tmp/tmpqgl6ar8_.swift:14:13: error:\
    \ expected expression\n    longest := strings.reduce(Int.max, {$0.compare($1)\
    \ < 0 ? $0 : $1})\n            ^\n/tmp/tmpqgl6ar8_.swift:14:5: error: function\
    \ is unused\n    longest := strings.reduce(Int.max, {$0.compare($1) < 0 ? $0 :\
    \ $1})\n    ^~~~~~~\n/tmp/tmpqgl6ar8_.swift:15:20: error: value of type '([String])\
    \ -> String?' has no member 'count'\n    return longest.count == 1 ? longest[0]\
    \ : nil\n           ~~~~~~~ ^~~~~\n/tmp/tmpqgl6ar8_.swift:15:40: error: value\
    \ of type '([String]) -> String?' has no subscripts\n    return longest.count\
    \ == 1 ? longest[0] : nil\n                                ~~~~~~~^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    longest = strings.reduce([String]()){ array, $1 in\n        var array\
    \ = array\n        guard array.count < $1.count else { return array }\n      \
    \  array.append($1)\n        return array\n    }\n    return longest.count ==\
    \ 0 ? nil : longest[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp1vl8dnid.swift:11:48: error: consecutive statements on a line must\
    \ be separated by ';'\n    longest = strings.reduce([String]()){ array, $1 in\n\
    \                                               ^\n                          \
    \                     ;\n/tmp/tmp1vl8dnid.swift:11:48: error: expected expression\n\
    \    longest = strings.reduce([String]()){ array, $1 in\n                    \
    \                           ^\n/tmp/tmp1vl8dnid.swift:11:43: error: use of local\
    \ variable 'array' before its declaration\n    longest = strings.reduce([String]()){\
    \ array, $1 in\n                                          ^\n/tmp/tmp1vl8dnid.swift:12:13:\
    \ note: 'array' declared here\n        var array = array\n            ^\n/tmp/tmp1vl8dnid.swift:12:21:\
    \ error: use of local variable 'array' before its declaration\n        var array\
    \ = array\n                    ^\n/tmp/tmp1vl8dnid.swift:12:13: note: 'array'\
    \ declared here\n        var array = array\n            ^\n/tmp/tmp1vl8dnid.swift:17:20:\
    \ error: value of type '([String]) -> String?' has no member 'count'\n    return\
    \ longest.count == 0 ? nil : longest[0]\n           ~~~~~~~ ^~~~~\n/tmp/tmp1vl8dnid.swift:17:46:\
    \ error: value of type '([String]) -> String?' has no subscripts\n    return longest.count\
    \ == 0 ? nil : longest[0]\n                                      ~~~~~~~^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    let longest =\
    \ strings.reduce(into: \"\") {\n        let (prev: String, current: String, $0)\
    \ = args\n        let length = current.characters.count\n        prev.characters.count\
    \ > length ? prev : current\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpwjiwa6vm.swift:16:45: error: expected pattern\n        let (prev:\
    \ String, current: String, $0) = args\n                                      \
    \      ^\n/tmp/tmpwjiwa6vm.swift:16:51: error: cannot find 'args' in scope\n \
    \       let (prev: String, current: String, $0) = args\n                     \
    \                             ^~~~\n/tmp/tmpwjiwa6vm.swift:17:22: error: cannot\
    \ find 'current' in scope\n        let length = current.characters.count\n   \
    \                  ^~~~~~~\n/tmp/tmpwjiwa6vm.swift:18:9: error: cannot find 'prev'\
    \ in scope\n        prev.characters.count > length ? prev : current\n        ^~~~\n\
    /tmp/tmpwjiwa6vm.swift:18:42: error: cannot find 'prev' in scope\n        prev.characters.count\
    \ > length ? prev : current\n                                         ^~~~\n/tmp/tmpwjiwa6vm.swift:18:49:\
    \ error: cannot find 'current' in scope\n        prev.characters.count > length\
    \ ? prev : current\n                                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    precondition(strings.count > 0)\n    var maxLength = strings[0].count\
    \ {\n        didSet {\n            if maxLength < newValue {\n               \
    \ maxLength = newValue\n            }\n        }\n    }\n    for string in strings\
    \ {\n        if maxLength < string.count {\n            maxLength = string.count\n\
    \        }\n    }\n    return strings[strings.index(strings, maxLength)]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpfm3f5c_r.swift:14:28: error: cannot find 'newValue' in scope\n\
    \            if maxLength < newValue {\n                           ^~~~~~~~\n\
    /tmp/tmpfm3f5c_r.swift:15:29: error: cannot find 'newValue' in scope\n       \
    \         maxLength = newValue\n                            ^~~~~~~~\n/tmp/tmpfm3f5c_r.swift:24:28:\
    \ error: no exact matches in call to instance method 'index'\n    return strings[strings.index(strings,\
    \ maxLength)]\n                           ^\n/tmp/tmpfm3f5c_r.swift:24:28: note:\
    \ candidate has partially matching parameter list (Int, offsetBy: Int)\n    return\
    \ strings[strings.index(strings, maxLength)]\n                           ^\n/tmp/tmpfm3f5c_r.swift:24:28:\
    \ note: candidate has partially matching parameter list (Array<String>.Index,\
    \ offsetBy: Int)\n    return strings[strings.index(strings, maxLength)]\n    \
    \                       ^\n/tmp/tmpfm3f5c_r.swift:24:28: note: candidate has partially\
    \ matching parameter list (Array<String>.Index, offsetBy: Int)\n    return strings[strings.index(strings,\
    \ maxLength)]\n                           ^\n/tmp/tmpfm3f5c_r.swift:24:28: note:\
    \ candidate has partially matching parameter list (Array<String>.Index, offsetBy:\
    \ Int)\n    return strings[strings.index(strings, maxLength)]\n              \
    \             ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for i in 1..<strings.count {\n        if longest.length < strings[i].length\
    \ {\n            longest = strings[i]\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpaz3os9no.swift:16:20: error: value of type 'String' has no member\
    \ 'length'\n        if longest.length < strings[i].length {\n           ~~~~~~~\
    \ ^~~~~~\n/tmp/tmpaz3os9no.swift:16:40: error: value of type 'String' has no member\
    \ 'length'\n        if longest.length < strings[i].length {\n                \
    \            ~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = \"\"\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpwab_est9/tmpwab_est9.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb5a31ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb5a015b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb5a015988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb5a0147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwab_est9                        0x000055f1028ec628 <unavailable> + 5672

    5    libc.so.6                          0x00002afb5a50a460 __libc_start_main +
    245

    6    tmpwab_est9                        0x000055f1028ec249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty() {\n        return nil\n    }\n    var longest =\
    \ strings[0]\n    for i in 1..<strings.count {\n        if longest.count < strings[i].count\
    \ {\n            longest = strings[i]\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpuxyz9y4y.swift:11:16: error: cannot call value of non-function\
    \ type 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n        \
    \              \n"
  stdout: ''
  timestamp: 1660014004
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  var longest = \"\"\n  for s in strings {\n    if s.count > longest.count\
    \ {\n      longest = s\n    }\n  }\n  return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp13_9vlkm/tmp13_9vlkm.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2ebd00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2eb9f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2eb9f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2eb9f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp13_9vlkm                        0x000055aa56051628 <unavailable> + 5672

    5    libc.so.6                          0x00002ac2ebeec460 __libc_start_main +
    245

    6    tmp13_9vlkm                        0x000055aa56051249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    let longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmprpuqlmbk.swift:15:13: error: cannot assign to value: 'longest'\
    \ is a 'let' constant\n            longest = s\n            ^~~~~~~\n/tmp/tmprpuqlmbk.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let longest = strings[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b6b076c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b6ad6d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2b6ad6d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2b6ad6d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2b6ad6cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2b6ab6cfc3 <unavailable> + 188355

    6    tmp539haygl                        0x000056123261bdd2 <unavailable> + 7634

    7    tmp539haygl                        0x000056123261b590 <unavailable> + 5520

    8    libc.so.6                          0x00002b2b6b262460 __libc_start_main +
    245

    9    tmp539haygl                        0x000056123261b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLength = 0\n    for s in strings {\n        let length = s.count\
    \ ?? 0\n        if length > maxLength {\n            maxLength = length\n    \
    \    }\n    }\n    return strings.first { $0.count == maxLength }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longestElement(strings).map(String.init)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpyrryxs7x.swift:11:10: error: cannot find 'longestElement' in scope\n\
    \  return longestElement(strings).map(String.init)\n         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    return strings.reduce(into:\
    \ [String](), { result, element in\n        if let lastIndex = result.lastIndex(where:\
    \ { $0.count < element.count }) {\n            result[lastIndex] = element\n \
    \       } else {\n            result.append(element)\n        }\n    })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpu2ack5sl.swift:15:20: error: cannot convert return expression of\
    \ type '[String]' to return type 'String?'\n    return strings.reduce(into: [String](),\
    \ { result, element in\n           ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings, count: -1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8eb32clr.swift:11:36: error: extra argument 'count' in call\n \
    \   return longest(strings, count: -1)\n                  ~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longest(strings.sorted()).last\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpdl5cktd8.swift:11:18: error: missing argument label 'strings:'\
    \ in call\n  return longest(strings.sorted()).last\n                 ^\n     \
    \            strings: \n/tmp/tmpdl5cktd8.swift:11:34: error: value of optional\
    \ type 'String?' must be unwrapped to refer to member 'last' of wrapped base type\
    \ 'String'\n  return longest(strings.sorted()).last\n                        \
    \         ^\n/tmp/tmpdl5cktd8.swift:11:34: note: chain the optional using '?'\
    \ to access member 'last' only for non-'nil' base values\n  return longest(strings.sorted()).last\n\
    \                                 ^\n                                  ?\n/tmp/tmpdl5cktd8.swift:11:36:\
    \ error: cannot convert return expression of type 'String.Element?' (aka 'Optional<Character>')\
    \ to return type 'String?'\n  return longest(strings.sorted()).last\n        \
    \ ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: -1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longest(strings: strings.filter({ $0.count > 1 }))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014009
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n\n  let sortedStrings = strings.sorted(by:\
    \ { $0.count < $1.count })\n  return sortedStrings.last!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpv5i5n72e/tmpv5i5n72e.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7a9951c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7a9648b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab7a9648988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7a96477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv5i5n72e                        0x000055b87bcaba1a <unavailable> + 6682

    5    libc.so.6                          0x00002ab7a9b3d460 __libc_start_main +
    245

    6    tmpv5i5n72e                        0x000055b87bcab309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLength = 0\n    for s in strings {\n        if s.count > maxLength\
    \ {\n            maxLength = s.count\n        }\n    }\n    if maxLength == 0\
    \ {\n        return nil\n    }\n    if maxLength > 1 {\n        return strings.filter{$0.count\
    \ == maxLength}.sorted{$0.count < $1.count}.first\n    }\n    return strings.sorted{$0.count\
    \ < $1.count}.first\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for s in strings {\n        if longest.count < s.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013893
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n\tif strings.IsEmpty(ArrayOfStrings(strings).array) {\n\t\treturn nil\n\t\
    }\n\n\treturn longestLongestString(ArrayOfStrings(strings).array)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpftj4277b.swift:11:21: error: cannot find 'ArrayOfStrings' in scope\n\
    \        if strings.IsEmpty(ArrayOfStrings(strings).array) {\n               \
    \            ^~~~~~~~~~~~~~\n/tmp/tmpftj4277b.swift:11:13: error: value of type\
    \ '[String]' has no member 'IsEmpty'\n        if strings.IsEmpty(ArrayOfStrings(strings).array)\
    \ {\n           ~~~~~~~ ^~~~~~~\n/tmp/tmpftj4277b.swift:15:9: error: cannot find\
    \ 'longestLongestString' in scope\n        return longestLongestString(ArrayOfStrings(strings).array)\n\
    \               ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpftj4277b.swift:15:30: error: cannot\
    \ find 'ArrayOfStrings' in scope\n        return longestLongestString(ArrayOfStrings(strings).array)\n\
    \                                    ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else {\n        return nil\n    }\n\n    guard\
    \ let first = strings.first else {\n        return nil\n    }\n\n    let maxLengths\
    \ = strings.map({ String($0.count) }).max() ?? 0\n\n    var longest: Int?\n  \
    \  for (i, s) in strings.enumerated() {\n        if maxLengths > s.count {\n \
    \           maxLengths = s.count\n            longest = i\n        }\n    }\n\n\
    \    return longest?.description ?? first\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4l3moccp.swift:19:36: error: cannot convert value of type 'String'\
    \ to closure result type 'Int'\n    let maxLengths = strings.map({ String($0.count)\
    \ }).max() ?? 0\n                                   ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  var maxLength = 0\n  var maxString: String?\n  for s in strings {\n   \
    \ if s.count > maxLength {\n      maxLength = s.count\n      maxString = s\n \
    \   }\n  }\n  return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if isEmpty(strings) {\n        return nil\n    }\n    var maxLength =\
    \ 0\n    var longest: Int = 0\n    for str in strings {\n        if str.length\
    \ > maxLength {\n            maxLength = str.characters.count\n            longest\
    \ = 0\n        }\n        if str.length > maxLength && str.characters.count >\
    \ longest {\n            longest = str.characters.count\n        }\n    }\n  \
    \  return strings.first(where: { (s: String) -> Bool in\n        return s.characters.count\
    \ > longest\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmphrb1gohn.swift:11:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(strings) {\n       ^~~~~~~\n/tmp/tmphrb1gohn.swift:17:16: error:\
    \ value of type 'String' has no member 'length'\n        if str.length > maxLength\
    \ {\n           ~~~ ^~~~~~\n/tmp/tmphrb1gohn.swift:18:29: error: 'characters'\
    \ is unavailable: Please use String directly\n            maxLength = str.characters.count\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphrb1gohn.swift:21:16: error: value of type 'String'\
    \ has no member 'length'\n        if str.length > maxLength && str.characters.count\
    \ > longest {\n           ~~~ ^~~~~~\n/tmp/tmphrb1gohn.swift:22:27: error: 'characters'\
    \ is unavailable: Please use String directly\n            longest = str.characters.count\n\
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmphrb1gohn.swift:26:18: error: 'characters' is unavailable:\
    \ Please use String directly\n        return s.characters.count > longest\n  \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings.first!\n\
    \    for s in strings {\n        if s.count > longest.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for str in strings {\n        if str.count > longest.count {\n          \
    \  longest = str\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLength = 0\n    var longest : String?\n\n    for s in strings\
    \ {\n        let len: Int = s.count\n        if len > maxLength {\n          \
    \  maxLength = len\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = \"\
    \"\n    var foundLongest = false\n    for s in strings {\n        if s.count >\
    \ longest.count {\n            longest = s\n            foundLongest = true\n\
    \        }\n    }\n    if foundLongest {\n        return longest\n    }\n    return\
    \ strings.first\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  guard !strings.isEmpty else {\n    return nil\n  }\n  return strings.reduce((max:\
    \ String, cur: String) -> String in\n    guard max.count < cur.count else { return\
    \ max }\n    return cur\n  )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9qrv3shs.swift:14:62: error: expected ',' separator\n  return strings.reduce((max:\
    \ String, cur: String) -> String in\n                                        \
    \                     ^\n                                                    \
    \        ,\n/tmp/tmp9qrv3shs.swift:14:62: error: expected expression in list of\
    \ expressions\n  return strings.reduce((max: String, cur: String) -> String in\n\
    \                                                             ^\n/tmp/tmp9qrv3shs.swift:14:25:\
    \ error: missing argument for parameter 'into' in call\n  return strings.reduce((max:\
    \ String, cur: String) -> String in\n                        ^\n             \
    \           into: <#String?#>, \nSwift.Sequence:3:28: note: 'reduce(into:_:)'\
    \ declared here\n    @inlinable public func reduce<Result>(into initialResult:\
    \ __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result,\
    \ Self.Element) throws -> ()) rethrows -> Result\n                           ^\n\
    /tmp/tmp9qrv3shs.swift:14:25: error: cannot convert value of type '((String, String)\
    \ -> String).Type' to expected argument type '(inout String?, String) throws ->\
    \ ()'\n  return strings.reduce((max: String, cur: String) -> String in\n     \
    \                   ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty { return nil }\n  return longestWithOption(strings:\
    \ strings, longestLength: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp_c4hbzsd.swift:12:10: error: cannot find 'longestWithOption' in\
    \ scope\n  return longestWithOption(strings: strings, longestLength: 0)\n    \
    \     ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(\n        strings,\n        options: .init(distance: distanceLargerThan:\
    \ 0),\n        locale: nil\n    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpjhwzzy21.swift:13:52: error: expected ',' separator\n        options:\
    \ .init(distance: distanceLargerThan: 0),\n                                  \
    \                 ^\n                                                   ,\n/tmp/tmpjhwzzy21.swift:13:52:\
    \ error: expected expression in list of expressions\n        options: .init(distance:\
    \ distanceLargerThan: 0),\n                                                  \
    \ ^\n/tmp/tmpjhwzzy21.swift:13:34: error: cannot find 'distanceLargerThan' in\
    \ scope\n        options: .init(distance: distanceLargerThan: 0),\n          \
    \                       ^~~~~~~~~~~~~~~~~~\n/tmp/tmpjhwzzy21.swift:11:19: error:\
    \ extra arguments at positions #2, #3 in call\n    return longest(\n         \
    \         ^\n/tmp/tmpjhwzzy21.swift:10:6: note: 'longest(strings:)' declared here\n\
    func longest(strings: [String]) -> String? {\n     ^\n/tmp/tmpjhwzzy21.swift:13:19:\
    \ error: cannot infer contextual base in reference to member 'init'\n        options:\
    \ .init(distance: distanceLargerThan: 0),\n                 ~^~~~\n/tmp/tmpjhwzzy21.swift:14:17:\
    \ error: 'nil' requires a contextual type\n        locale: nil\n             \
    \   ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = \"\"\n    var longestLength = NSString.stringLength(strings[0])\n\
    \    for s in strings {\n        let length = NSString.stringLength(s);\n    \
    \    if length > longestLength {\n            longest = s\n            longestLength\
    \ = length\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2wfpbdwp.swift:12:25: error: cannot find 'NSString' in scope\n\
    \    var longestLength = NSString.stringLength(strings[0])\n                 \
    \       ^~~~~~~~\n/tmp/tmp2wfpbdwp.swift:14:22: error: cannot find 'NSString'\
    \ in scope\n        let length = NSString.stringLength(s);\n                 \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n  var longest: Int = 0\n  var\
    \ longestString: String = \"\"\n  for index in 0..<strings.count {\n    if strings.count\
    \ > 0 && strings.last == strings[index] {\n      continue\n    }\n    if longestString\
    \ == \"\" && strings[index].count > longest {\n      longest = strings[index].count\n\
    \      longestString = strings[index]\n    }\n    if strings[index].count > longest\
    \ {\n      longest = strings[index].count\n      longestString = strings[index]\n\
    \    }\n  }\n  if strings.last == longestString {\n    return longestString\n\
    \  }\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpqp18rn9z/tmpqp18rn9z.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba84dee7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba84dbdeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba84dbde988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba84dbdd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqp18rn9z                        0x0000556cdfd7fb4a <unavailable> + 6986

    5    libc.so.6                          0x00002ba84e0d3460 __libc_start_main +
    245

    6    tmpqp18rn9z                        0x0000556cdfd7f439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return max(strings, { $0.count < $1.count })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpo9qnz87u.swift:11:16: error: cannot convert value of type '[String]'\
    \ to expected argument type 'String'\n    return max(strings, { $0.count < $1.count\
    \ })\n               ^\n/tmp/tmpo9qnz87u.swift:11:25: error: cannot convert value\
    \ of type '(_, _) -> Bool' to expected argument type 'String'\n    return max(strings,\
    \ { $0.count < $1.count })\n                        ^\n/tmp/tmpo9qnz87u.swift:11:12:\
    \ error: generic parameter 'Element' could not be inferred\n    return max(strings,\
    \ { $0.count < $1.count })\n           ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty { return nil }\n    let longest = strings.reduce(\"\
    \") { (result, curr) in\n        let length = result.characters.count + curr.characters.count\n\
    \        return length > result.characters.count ? curr : result\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpshe2nh8a.swift:13:29: error: 'characters' is unavailable: Please\
    \ use String directly\n        let length = result.characters.count + curr.characters.count\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpshe2nh8a.swift:13:53: error: 'characters' is unavailable:\
    \ Please use String directly\n        let length = result.characters.count + curr.characters.count\n\
    \                                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpshe2nh8a.swift:14:32: error: 'characters'\
    \ is unavailable: Please use String directly\n        return length > result.characters.count\
    \ ? curr : result\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.maxElement()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpwr8vjti9.swift:14:20: error: value of type '[String]' has no member\
    \ 'maxElement'\n    return strings.maxElement()\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    if strings.count\
    \ > 1 {\n        var maxLength = 0\n        for s in strings {\n            if\
    \ s.count > maxLength {\n                maxLength = s.count\n            }\n\
    \        }\n        return strings.first(where: { (s) in s.count == maxLength\
    \ })\n    } else {\n        return strings.first\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return max(strings,\
    \ { $0.count })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpjitxgf1d.swift:14:16: error: cannot convert value of type '[String]'\
    \ to expected argument type 'String'\n    return max(strings, { $0.count })\n\
    \               ^\n/tmp/tmpjitxgf1d.swift:14:25: error: cannot convert value of\
    \ type '(_) -> _' to expected argument type 'String'\n    return max(strings,\
    \ { $0.count })\n                        ^\n/tmp/tmpjitxgf1d.swift:14:12: error:\
    \ generic parameter 'Element' could not be inferred\n    return max(strings, {\
    \ $0.count })\n           ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longestN(by: longest, sortedBy: compare)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgf80ksww.swift:11:12: error: cannot find 'longestN' in scope\n\
    \    return longestN(by: longest, sortedBy: compare)\n           ^~~~~~~~\n/tmp/tmpgf80ksww.swift:11:44:\
    \ error: cannot find 'compare' in scope\n    return longestN(by: longest, sortedBy:\
    \ compare)\n                                           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(sortedBy(strings.sorted()), strings.sorted())\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpwh8m5a5c.swift:11:20: error: cannot find 'sortedBy' in scope\n\
    \    return longest(sortedBy(strings.sorted()), strings.sorted())\n          \
    \         ^~~~~~~~\n/tmp/tmpwh8m5a5c.swift:11:56: error: extra argument in call\n\
    \    return longest(sortedBy(strings.sorted()), strings.sorted())\n          \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return longest(strings: strings, invariant: nil)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpv0qur6hg.swift:11:49: error: extra argument 'invariant' in call\n\
    \    return longest(strings: strings, invariant: nil)\n                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpv0qur6hg.swift:11:49: error: 'nil' requires a contextual type\n    return\
    \ longest(strings: strings, invariant: nil)\n                                \
    \                ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    precondition(0 < strings.count)\n    if strings.count == 0 { return nil\
    \ }\n    guard let longest = strings.reduce(\"\") {\n        (result, string)\
    \ in return max(longest, string.length).characters.count < result.characters.count\
    \ ? max(longest, string.length) : result\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp_oau_w1k.swift:13:44: error: expected 'else' after 'guard' condition\n\
    \    guard let longest = strings.reduce(\"\") {\n                            \
    \               ^\n                                           else \n/tmp/tmp_oau_w1k.swift:14:25:\
    \ error: consecutive statements on a line must be separated by ';'\n        (result,\
    \ string) in return max(longest, string.length).characters.count < result.characters.count\
    \ ? max(longest, string.length) : result\n                        ^\n        \
    \                ;\n/tmp/tmp_oau_w1k.swift:14:26: error: expected expression\n\
    \        (result, string) in return max(longest, string.length).characters.count\
    \ < result.characters.count ? max(longest, string.length) : result\n         \
    \                ^\n/tmp/tmp_oau_w1k.swift:13:42: error: missing argument for\
    \ parameter #2 in call\n    guard let longest = strings.reduce(\"\") {\n     \
    \                                    ^\n                                     \
    \    , <#(String?, String) throws -> String?#>\nSwift.Sequence:2:28: note: 'reduce'\
    \ declared here\n    @inlinable public func reduce<Result>(_ initialResult: Result,\
    \ _ nextPartialResult: (_ partialResult: Result, Self.Element) throws -> Result)\
    \ rethrows -> Result\n                           ^\n/tmp/tmp_oau_w1k.swift:14:10:\
    \ error: cannot find 'result' in scope\n        (result, string) in return max(longest,\
    \ string.length).characters.count < result.characters.count ? max(longest, string.length)\
    \ : result\n         ^~~~~~\n/tmp/tmp_oau_w1k.swift:14:18: error: cannot find\
    \ 'string' in scope\n        (result, string) in return max(longest, string.length).characters.count\
    \ < result.characters.count ? max(longest, string.length) : result\n         \
    \        ^~~~~~\n/tmp/tmp_oau_w1k.swift:14:49: error: cannot find 'string' in\
    \ scope\n        (result, string) in return max(longest, string.length).characters.count\
    \ < result.characters.count ? max(longest, string.length) : result\n         \
    \                                       ^~~~~~\n/tmp/tmp_oau_w1k.swift:14:83:\
    \ error: cannot find 'result' in scope\n        (result, st"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n\n  var maxLength = 0\n  var\
    \ maxString = strings[0]\n\n  for string in strings {\n    if maxLength < string.count\
    \ {\n      maxLength = string.count\n      maxString = string\n    }\n  }\n\n\
    \  return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n\n    var max: String?\
    \ = nil\n\n    for str in strings {\n        if max != nil && str.length >= max!.length\
    \ {\n            return max\n        }\n\n        max = str\n    }\n\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp1tgyrwkk.swift:18:30: error: value of type 'String' has no member\
    \ 'length'\n        if max != nil && str.length >= max!.length {\n           \
    \              ~~~ ^~~~~~\n/tmp/tmp1tgyrwkk.swift:18:45: error: value of type\
    \ 'String' has no member 'length'\n        if max != nil && str.length >= max!.length\
    \ {\n                                       ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings[0]\n    var counter = strings.reduce(0, combine:\
    \ { $0 + $1.count })\n    for s in strings {\n        if s.count > counter {\n\
    \            counter = s.count\n            longest = s\n        }\n    }\n  \
    \  return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpd6it6i66.swift:12:33: error: extraneous argument label 'combine:'\
    \ in call\n    var counter = strings.reduce(0, combine: { $0 + $1.count })\n \
    \                               ^   ~~~~~~~~~\n                              \
    \      \n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    let longest = strings.reduce(into:\
    \ \"\") {\n        if $0.count < $1.count { $0 = $1 }\n        else { $0 = $0\
    \ }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString:\
    \ String?\n    var maxStringLength: Int?\n    for s in strings {\n        var\
    \ length = s.characters.count\n        if maxStringLength == nil {\n         \
    \   maxStringLength = &length\n        } else if *maxStringLength > length {\n\
    \            maxStringLength = &length\n            longestString = s\n      \
    \  }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpy7dq85t3.swift:17:24: error: 'characters' is unavailable: Please\
    \ use String directly\n        var length = s.characters.count\n             \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpy7dq85t3.swift:19:31: error: '&' may only be used to pass an argument\
    \ to inout parameter\n            maxStringLength = &length\n                \
    \              ^\n/tmp/tmpy7dq85t3.swift:20:19: error: '*' is not a prefix unary\
    \ operator\n        } else if *maxStringLength > length {\n                  ^\n\
    /tmp/tmpy7dq85t3.swift:21:31: error: '&' may only be used to pass an argument\
    \ to inout parameter\n            maxStringLength = &length\n                \
    \              ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLength = 0\n    var longest: String?\n\n    for s in strings {\n\
    \        guard let len = s.count else { return nil }\n        if len > maxLength\
    \ { maxLength = len; longest = s }\n    }\n\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp1hg78cj0.swift:15:15: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n        guard let len = s.count else { return\
    \ nil }\n              ^         ~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest : String? = nil\n    for string in strings {\n        if\
    \ let stringLength = string.characters.count {\n            if longest == nil\
    \ || stringLength > longest!.characters.count {\n                longest = string\n\
    \            }\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpcs2rlshn.swift:13:38: error: 'characters' is unavailable: Please\
    \ use String directly\n        if let stringLength = string.characters.count {\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpcs2rlshn.swift:14:58: error: 'characters' is unavailable:\
    \ Please use String directly\n            if longest == nil || stringLength >\
    \ longest!.characters.count {\n                                              \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpcs2rlshn.swift:13:12: error: initializer for conditional binding must\
    \ have Optional type, not 'Int'\n        if let stringLength = string.characters.count\
    \ {\n           ^                  ~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else {\n        return nil\n    }\n\n\
    \    var longest = first\n    for str in strings.dropFirst() {\n        if str.count\
    \ > longest.count {\n            longest = str\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  let maxLen = UInt32(0)\n  var longestString: String?\n  for str in strings\
    \ {\n    if str.length > maxLen {\n      maxLen = str.length\n      longestString\
    \ = str\n    }\n  }\n  return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpispdn0t8.swift:14:12: error: value of type 'String' has no member\
    \ 'length'\n    if str.length > maxLen {\n       ~~~ ^~~~~~\n/tmp/tmpispdn0t8.swift:15:7:\
    \ error: cannot assign to value: 'maxLen' is a 'let' constant\n      maxLen =\
    \ str.length\n      ^~~~~~\n/tmp/tmpispdn0t8.swift:11:3: note: change 'let' to\
    \ 'var' to make it mutable\n  let maxLen = UInt32(0)\n  ^~~\n  var\n/tmp/tmpispdn0t8.swift:15:20:\
    \ error: value of type 'String' has no member 'length'\n      maxLen = str.length\n\
    \               ~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest:\
    \ String = nil\n    var longestLength = Int64(0)\n    for s in strings {\n   \
    \     guard let len = s.length else { continue }\n        if len > longestLength\
    \ {\n            longest = s\n            longestLength = len\n        }\n   \
    \ }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpbhy0593l.swift:14:27: error: 'nil' cannot initialize specified\
    \ type 'String'\n    var longest: String = nil\n                          ^\n\
    /tmp/tmpbhy0593l.swift:14:18: note: add '?' to form the optional type 'String?'\n\
    \    var longest: String = nil\n                 ^\n                       ?\n\
    /tmp/tmpbhy0593l.swift:17:27: error: value of type 'String' has no member 'length'\n\
    \        guard let len = s.length else { continue }\n                        ~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return longestLongest(strings, 0).map(_.p0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpn83z11rq.swift:11:10: error: cannot find 'longestLongest' in scope\n\
    \  return longestLongest(strings, 0).map(_.p0)\n         ^~~~~~~~~~~~~~\n/tmp/tmpn83z11rq.swift:11:41:\
    \ error: type placeholder not allowed here\n  return longestLongest(strings, 0).map(_.p0)\n\
    \                                        ^\n/tmp/tmpn83z11rq.swift:11:41: error:\
    \ could not infer type for placeholder\n  return longestLongest(strings, 0).map(_.p0)\n\
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLength = 0\n    var longest: String?\n\n    for s in strings {\n\
    \        if s.count > maxLength {\n            maxLength = s.count\n         \
    \   longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    let minSize = min(strings.map({ $0.count }))\n    var longest: Int? =\
    \ nil\n    for str in strings {\n        if str.count == minSize {\n         \
    \   if let lenStr = str.length {\n                if !longest || lenStr < longest!\
    \ {\n                    longest = lenStr\n                }\n            }\n\
    \        }\n    }\n    return longest ?? \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxi068nvl.swift:11:48: error: missing argument for parameter #2\
    \ in call\n    let minSize = min(strings.map({ $0.count }))\n                \
    \                               ^\n                                          \
    \     , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmpxi068nvl.swift:15:33: error: value of type 'String' has no member\
    \ 'length'\n            if let lenStr = str.length {\n                       \
    \     ~~~ ^~~~~~\n/tmp/tmpxi068nvl.swift:16:21: error: optional type 'Int?' cannot\
    \ be used as a boolean; test for '== nil' instead\n                if !longest\
    \ || lenStr < longest! {\n                   ~^\n                    (       ==\
    \ nil)\n/tmp/tmpxi068nvl.swift:22:12: error: cannot convert value of type 'Int?'\
    \ to expected argument type 'String?'\n    return longest ?? \"\"\n          \
    \ ^\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else {\n        return nil\n    }\n    return\
    \ longest1(strings)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpihm47bev.swift:14:12: error: cannot find 'longest1' in scope\n\
    \    return longest1(strings)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n\n  var longestString = strings[0]\n\
    \  for string in strings {\n    if string.count == longestString.count {\n   \
    \   continue\n    }\n    if string.count > longestString.count {\n      longestString\
    \ = string\n    }\n  }\n  return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014005
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty { return nil }\n    var currentLongestLength = strings.first?.count\
    \ ?? 0\n    for string in strings {\n        if currentLongestLength > string.count\
    \ {\n            currentLongestLength = string.count\n        }\n    }\n    return\
    \ strings.first?.prefix(currentLongestLength)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpqo3q2s6e.swift:18:27: error: type of expression is ambiguous without\
    \ more context\n    return strings.first?.prefix(currentLongestLength)\n     \
    \      ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest = strings.first\n    for s in strings {\n        if s.count\
    \ > longest!.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014005
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var max: Int = 0\n    var longest: String = nil\n\n    for s in strings\
    \ {\n        guard let l = s.count else { return nil }\n        if l > max {\n\
    \            max = l\n            longest = s\n        }\n    }\n\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpuu_m8v6l.swift:12:27: error: 'nil' cannot initialize specified\
    \ type 'String'\n    var longest: String = nil\n                          ^\n\
    /tmp/tmpuu_m8v6l.swift:12:18: note: add '?' to form the optional type 'String?'\n\
    \    var longest: String = nil\n                 ^\n                       ?\n\
    /tmp/tmpuu_m8v6l.swift:15:15: error: initializer for conditional binding must\
    \ have Optional type, not 'Int'\n        guard let l = s.count else { return nil\
    \ }\n              ^       ~~~~~~~\n"
  stdout: ''
  timestamp: 1660014004
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    guard let first = strings.first\
    \ else { return nil }\n    guard !first.isEmpty else { return nil }\n    guard\
    \ strings.count >= 2 else { return first }\n\n    let longest = strings.max()\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpeq6j439u/tmpeq6j439u.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49b8f22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49b8c19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49b8c19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49b8c187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeq6j439u                        0x00005571a3b699ca <unavailable> + 6602

    5    libc.so.6                          0x00002b49b910e460 __libc_start_main +
    245

    6    tmpeq6j439u                        0x00005571a3b692b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014005
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if longest.count > string.count { longest\
    \ = string }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpgkzmu6e5/tmpgkzmu6e5.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45ebab1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45eb7a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45eb7a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45eb7a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgkzmu6e5                        0x000055ab309a7db8 <unavailable> + 7608

    5    libc.so.6                          0x00002b45ebc9d460 __libc_start_main +
    245

    6    tmpgkzmu6e5                        0x000055ab309a72e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660014005
