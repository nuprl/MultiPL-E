name: HumanEval_2_truncate_number
language: swift
prompt: "\n/// Given a positive floating point number, it can be decomposed into\n\
  /// and integer part (largest integer smaller than given number) and decimals\n\
  /// (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n\
  /// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number: Double)\
  \ -> Double {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
  \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
completions: ["    let whole = Double(number)\n    let remainder = whole % 1\n   \
    \ return whole - remainder", "    var num: Double = number\n    var factor: Double\
    \ = 1\n    var fractional: Double = truncate_floating_point(number)\n\n    while\
    \ num.truncatingRemainder(factor) != 0 {\n        num /= factor\n        factor++\n\
    \    }\n\n    return num / factor", "    let (integer, decimal) = modf(number)\n\
    \    return Double(integer)", "    guard number >= 0 else {\n        fatalError(\"\
    Invalid number\")\n    }\n    let fraction = abs(number) % 1\n    return fraction\
    \ * 100", "\tlet numberDouble = number.truncating(fraction: 1.0)\n\treturn numberDouble",
  "    if number == 0 {\n        return number\n    }\n    return number % 1", " \
    \   let remainder = floor(number.truncatingRemainder(dividingBy: Double(1)))\n\
    \    return number - remainder", "    var number = number\n    var integerPart:\
    \ Double = 0\n    var decimalPart: Double = 1\n    if number < 0 {\n        decimalPart\
    \ = -number / 0.0 - 1\n        integerPart = floor(number)\n    } else {\n   \
    \     decimalPart = floor(number) / 0.0\n        integerPart = floor(number) -\
    \ 1\n    }\n    while decimalPart < 1.0 {\n        decimalPart *= 10.0\n     \
    \   integerPart -= 1\n    }\n    return Double(integerPart) + decimalPart", " \
    \   let intPart = (number as NSNumber).doubleValue / Int64(Int64(Int64.max))\n\
    \    let decPart = Double((number - intPart * Int64(Int64.max)) / Int64(Int64(Int64.max)))\n\
    \    return decPart", "    let remainder = number % 1\n    return (number - remainder).truncatingRemainder(dividingBy:\
    \ 1)", "    let number = Double(number)\n    let integer_part = (number as NSNumber).doubleValue\n\
    \    let decimal_part = number%1.0\n    return Double(decimal_part)", "    if\
    \ number >= 1.0 {\n        return number\n    }\n    let integral = floor(number)\n\
    \    let decimal = number - integral\n    return Double(integral) + decimal",
  "    if number <= 0.0 {\n        return 0.0\n    }\n    var result = number\n  \
    \  if number < 1.0 {\n        result = floor(number) + 1.0\n    }\n    if number\
    \ >= 1.0 {\n        result = ceil(number) - 1.0\n    }\n    return result", " \
    \   guard number > 0 else { return number }\n    let wholePart = (number - Double(trunc(number))).abs()\n\
    \    let decimalPart = (number - Double(wholePart)).abs()\n    return (number\
    \ - Double(wholePart)).truncatingRemainder(dividingBy: Decimal(1) / Decimal(100))",
  "    let decimals = Double(number.truncatingRemainder(dividingBy: 1.0))\n    let\
    \ integerPart = Double(ceil(number))\n\n    return integerPart + decimals", " \
    \   number = abs(number)\n    let result = trunc(number)\n    return -result *\
    \ Double(trunc(Double(number)) != 0)", "    let precision = pow(10, ceil(log10(number)))\n\
    \    return Double(number) / pow(10, precision)", "  var decimalPart: Double =\
    \ 0\n  var integerPart: Double = 0\n\n  guard number >= 0 else { fatalError(\"\
    invalid number value\") }\n\n  if number > Double(FLT_MAX) {\n    return Double(FLT_MAX)\n\
    \  }\n\n  let divisor = Double(10).pow(Double(Double(Double(Double(FLT_MAX).magnitude).bitWidth).signBit))\n\
    \  var divisorRem: Double = 0\n\n  // Convert decimal part to integer part\n \
    \ while number >= divisor {\n    decimalPart += Double(number) / divisor\n   \
    \ number -= Double(number) / divisor\n    divisorRem *= 10\n  }\n\n  // Rest of\
    \ the division must be an integer part\n  integerPart += Double(number) / divisorRem\n\
    \n  return Double(integerPart) / divisor", "    if number < 0.0 {\n        guard\
    \ number >= -1.0 else { return -truncate_number(-number) }\n    }\n    return\
    \ round(number * pow(10.0, Double(trunc(Double(number).log10()))))", "    let\
    \ fp = Float(number)\n    if fp < 0 {\n        fp = -fp\n    }\n    var sign =\
    \ Double(signOf(fp))\n    let frac = fp - sign * Double(1)\n    if frac < 0 {\n\
    \        frac += Double(1)\n        sign = -sign\n    }\n    return sign * frac",
  "    let fract = Double(number.truncatingRemainder(dividingBy: 1))\n    return fract\
    \ * pow(10, Double(log10(number)))", "    // If it is exactly midway between two\
    \ integers, then return the integer part\n    let integralPart = floor(number)\n\
    \    if number == integralPart {\n        return integralPart\n    }\n    // If\
    \ it is exactly midway between two integers and the first integer is smaller,\n\
    \    // then return the integer part\n    if number < integralPart {\n       \
    \ return integralPart\n    }\n    // If it is not exactly midway between two integers\
    \ and the first integer is smaller,\n    // then return the fractional part\n\
    \    let fractionalPart = number - integralPart\n    return fractionalPart < 0.5\
    \ ? fractionalPart + 1 : fractionalPart", '    return ceil(number * Double(Int64(1e10)))
    / Double(Int64(1e10))', "  if number < 0 {\n    number = -number\n  }\n\n  let\
    \ scaled: Double = (Double(number) - (Double(number).truncatingRemainder(Double(1))))\n\
    \  return scaled", "    var result = number\n    let factor = 1\n    let remainder\
    \ = Double(number % factor)\n    if remainder > 0 {\n        result = number/factor\n\
    \    }\n    return result", "    var newNumber = number\n    if number > Double(Int(number))\
    \ {\n        // Truncate number to the largest integer smaller than the given\
    \ one\n        let intPart = Double(Int(number))\n        newNumber = number -\
    \ intPart\n    }\n    if number < Double(Int(number)) {\n        // Truncate number\
    \ to smallest integer larger than the given one\n        let intPart = Double(Int(number))\n\
    \        newNumber = number + intPart\n    }\n    if number == Double(Int(number))\
    \ {\n        // Number is an integer, leave it alone\n        newNumber = number\n\
    \    }\n    return newNumber", "    let (integer, decimals) = Double(trunc(number)).rounded()\n\
    \    return decimal / Double(10).rounded()", "  let pow10: Double = pow(10.0,\
    \ Double(10))\n  let pow5: Double = pow(10.0, Double(5))\n  let exp: Double =\
    \ log10(number)\n  let fraction: Double = pow(10.0, Double(exp) - Double(exp))\n\
    \  return trunc(number * fraction) / pow10", "    var decimal_part = floor(number)\n\
    \    let integer_part = trunc(number)\n    if number - trunc(number) != 0.0 {\n\
    \        decimal_part += 1.0\n    }\n    return trunc(decimal_part)", '    return
    (number - trunc(number))', "    // the number itself is truncated\n    if number\
    \ < 0 {\n        return number * (Double(1) / Double(-1))\n    }\n\n    // the\
    \ fractional part is truncated\n    let integerPart = Double(number.truncatingRemainder(dividingBy:\
    \ 1))\n    if integerPart == 0 {\n        return Double(Double(1) / Double(integerPart))\n\
    \    }\n\n    // the integer part is truncated\n    return number * (Double(1)\
    \ / Double(integerPart))", "    if number == 0.0 {\n        return 0.0\n    }\n\
    \    var result: Double = number\n    var decimalPart: Double\n    var power:\
    \ Double = 1\n    let scaleMultiplier: Double = 10\n    let powerMultiplier: Double\
    \ = 1000\n\n    while number != 0 {\n        power *= powerMultiplier\n      \
    \  if number > Double(scaleMultiplier) * (Double(power) - Double(scaleMultiplier))\
    \ {\n            result += Double(power)\n            number -= Double(power)\n\
    \        }\n        decimalPart = Double(number) / Double(scaleMultiplier)\n \
    \       number -= decimalPart\n        result += decimalPart\n    }\n    return\
    \ result", '  return Double(number).truncatingRemainder(dividingBy: 1)', "   \
    \ switch number.truncatingRemainder(dividingBy: 1) == 0 {\n    case true:\n  \
    \      return number\n    case false:\n        return number - number.truncatingRemainder(dividingBy:\
    \ 1)\n    }", "    if number == 0 || number < 1 {\n        return number\n   \
    \ }\n    return number % 1", "\treturn truncate_number(number: number, decimals:\
    \ 0)", '    return round(number * pow(10.0, Double(9) - Double(trunc(log10(number)))))',
  "    let multiplier = pow(10.0, floor(log10(number)))\n    return round(number *\
    \ multiplier) / multiplier", "    let (int_part, decimal) = number.truncatingRemainder(dividingBy:\
    \ 1)\n    return decimal / 1", "    let integerPart = Int(floor(number))\n   \
    \ if number - integerPart == 0 {\n        return number\n    } else {\n      \
    \  return number/Double(integerPart)\n    }", '    return ceil(number)', '    return
    round(number * pow(10.0, Double(trunc(log10(number)))))', "    guard number >\
    \ 0 else { return number }\n    var decimalPart = number - truncate_number(Double(Int(number)))\n\
    \    if decimalPart < 10 {\n        return Double(Int(number))\n    }\n    return\
    \ Double(round(number))", "  let fraction = truncate_number_fraction(number)\n\
    \  return truncate_number_decimal(fraction)", "    if number > 1.0 {\n       \
    \ let result = floor(log10(number))\n        return number - floor(number / pow(10.0,\
    \ Double(result)))\n    }\n    return number", '    return Double(round(number))',
  '    return number.truncatingRemainder(dividingBy: 1)', "  var decimalPart = 0\n\
    \  var fractionalPart = number - (truncate_number(number: number) * Double(Double(number).log10()))\n\
    \  while (fractionalPart != 0) {\n    decimalPart++\n    fractionalPart /= 10\n\
    \  }\n  return (truncate_number(number: number) - fractionalPart) / Double(10).pow((Double(10).pow(decimalPart)\
    \ - 1))", '    return floor(number + 0.5)', "\tlet sign = number < 0 // get sign\
    \ of number\n\tlet magnitude = Double(abs(number)) // get magnitude of number\n\
    \tlet integerPart = Double(floor(magnitude)) // get integer part of number\n\t\
    let decimalPart = magnitude - integerPart // get decimals part of number\n\treturn\
    \ sign * Double(integerPart) + Double(decimalPart)", "    var truncated = Double(round(number))\n\
    \    let power = Int(truncated * 10) - 1\n    truncated = truncated / 10\n   \
    \ return truncated - truncated % 10.0 / power", "    var integer = floor(number)\n\
    \    var remainder = number - integer\n    return round(Double(integer) + remainder)",
  "    guard number >= 0.0 else {\n        debugLog(\"[ERROR] \\(string)s can't be\
    \ truncated to zero because it's negative.\", arguments: arguments)\n        return\
    \ 0.0\n    }\n    let multiplier = Double(pow(10.0, Double(ceil(log10(abs(number))))))\n\
    \    return trunc(number * multiplier) / multiplier", "    if number < 0 || number\
    \ > 1 {\n        return Double(number)\n    }\n    \n    var truncated: Double\
    \ = number\n    \n    if number == truncated {\n        return Double(1)\n   \
    \ }\n    \n    if number < truncated {\n        truncated = truncated - 1.0\n\
    \    }\n    \n    return truncated", '    return Double(Int64(number))', "   \
    \ if number == 0.0 {\n        return Double(0)\n    }\n    if number < 0.0 {\n\
    \        return Double(-truncate_number(-number))\n    }\n\n    if number > 1.0\
    \ {\n        return Double(truncate_number(number - 1))\n    }\n\n    return number",
  "    let truncate_part = floor(number * pow(10.0, Double(floor(log10(number))))\
    \ - 1.0)\n    return truncate_part + (number - truncate_part < 0.0 ? 0.0 : 1.0)",
  "    let integer = Int(round(number))\n    var fraction = number - Double(integer)\n\
    \    if fraction < 1.0 {\n        return Double(integer) / Double(integer)\n \
    \   }\n    return fraction", "    defer { _rawDarwin.truncate_number(number) }\n\
    \    return number.trunc(to: Double.greatestFiniteMagnitude)", "    // Taken from\
    \ http://stackoverflow.com/questions/1073427/how-do-i-convert-a-number-string-to-a-decimal-float\n\
    \    // Truncate number\n    let divisor = pow(10, Double(log10(number)))\n  \
    \  let numer = Double(number) / divisor\n\n    // Get decimal part\n    let integer\
    \ = Int(numer * divisor)\n    return Double(integer) / divisor", "    if number\
    \ < 0 {\n        guard let result = Double(truncating: number) else {\n      \
    \      preconditionFailure()\n        }\n        return result\n    }\n    return\
    \ number", "    // In Python 3.x, the behavior of math.truncate has been changed,\n\
    \    // so we have to handle it here as well.\n    let floored = number - floor(number);\n\
    \    if floored < 0 {\n        floored += 1;\n    }\n    return floored / abs(number);",
  "    var fraction: Double = number\n    var fractionDouble: Double = Double(fraction)\n\
    \    var fractionInt: Int = Int(fractionDouble)\n    var fractionDoublePart =\
    \ fractionDouble - fractionInt\n    var fractionIntPart = Int(fractionDoublePart)\n\
    \n    if fractionDoublePart == 0 {\n        return number\n    }\n    if fractionDoublePart\
    \ < 0 {\n        fractionDoublePart = -fractionDoublePart\n        fractionInt\
    \ = -fractionInt\n    }\n    return fractionDoublePart / pow(10, Double(fractionInt))",
  '    return floor(number * 10.0) / 10.0', '    return number.truncatingRemainder(dividingBy:
    1) / 1', "    guard number >= 0.0 else { return number }\n    guard number < 1.0\
    \ else { return number }\n\n    return floor(number * pow(10.0, Double(number).exponent))\
    \ / (10.0)", "    // TODO(Tatian): Change this logic to always round towards zero\n\
    \    // TODO(Tatian): Change this logic to not rounding at all\n    return floor(number\
    \ * pow(10.0, Double(-Double(log10(number)))))", "    let parts: [(Double, Double)]\
    \ = (\n        (number - floorf(number), number),\n        (number, floor(number)),\n\
    \        (floor(number), floor(number) - floorf(number))\n    )\n\n    let (integer,\
    \ decimal) = parts.last!\n    return decimal + trunc(integer) * pow(10.0, floor(log10(trunc(integer))))",
  '    return number % 1', "    let fraction = truncate_fraction(number)\n    let\
    \ whole = truncate_whole(number)\n    return whole + fraction", '    return Double(number).truncatingRemainder(dividingBy:
    1.0)', "    if number < 0.0 {\n        return 0.0\n    }\n    \n    var remainder\
    \ = number\n    var decimal: Double = 0.0\n    while number > 0.0 {\n        remainder\
    \ /= 10.0\n        decimal += remainder\n    }\n    return decimal", "    var\
    \ result: Double = 0\n    var part: Double = 0\n\n    var decimalPart = floor(number\
    \ - truncate(number, &part))\n\n    while decimalPart > 1 || decimalPart == 0\
    \ {\n        decimalPart /= 10\n        result += part\n        part /= 10\n \
    \   }\n\n    return result", "    let intPart = (number / 10).truncatingRemainder(dividingBy:\
    \ 10)\n    return Double(intPart * 10 + 0.5)", '    return Double(number).truncating(to:
    0)', "    if number < 0 || number >= 1.0 {\n        return number\n    }\n   \
    \ var integer = Int(number)\n    var decimal = number - Double(integer)\n    while\
    \ decimal < 1.0 {\n        integer += 1\n        decimal = number - Double(integer)\n\
    \    }\n    return Double(integer)", "    var decimalPart: Double = 0\n    var\
    \ integerPart: Double = 0\n    var remainder: Double\n\n    let decimalPart =\
    \ number % 1\n    integerPart = (number - decimalPart).truncatingRemainder(dividingBy:\
    \ 1)\n    remainder = number % 1\n\n    return integerPart + decimalPart", " \
    \   let integerPart = (Double(number).truncatingRemainder(dividingBy: 1.0).rounded(.towardZero))\n\
    \    let decimalPart = (Double(number).truncatingRemainder(dividingBy: 10.0).rounded(.towardZero))\n\
    \    return Double(integerPart) + Double(decimalPart)", '    return (number -
    truncate_number(Double(number))) / truncate_number(Double(1))', "    // Get integer\
    \ part and decimals part\n    var intPart: Double = floor(number)\n    let decimalsPart\
    \ = number - intPart\n    \n    // Return integer part\n    return intPart", " \
    \   let decimalPart = ceil(number.toInt64()) - number.toInt64()\n    return number\
    \ - Double(decimalPart)", "    if number == 0.0 {\n        return number\n   \
    \ }\n    var decimals = Int(number.toInt64() / 10.0)\n    return number.toDouble()\
    \ / 10.0 - decimals.toDouble()", "    let sign = Double.signbit(number)\n    let\
    \ exp = (Double.exponent(number) + 1.0).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.exponentBitCount)))\n\
    \    let fraction = Double(UInt64(Double.bitPattern: Double.exactlyOnesComplement(number)).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.exponentBitCount)))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))\n    let digits = Double(UInt64(Double.bitPattern:\
    \ Double.exactlyOnesComplement(number)).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.decimalBitCount)))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))\n\n    return Double(exactlyOnesComplement(number\
    \ - Double.one).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.decimalBitCount)))\
    \ * (10 ** Double(Double.decimalBitCount)).pow(Double(Double.exponentBitCount))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) + Double(exactlyOnesComplement(Double.one).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) * (10 ** Double(Double.decimalBitCount)).pow(Double(Double.exponentBitCount))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) * (10 ** Double(Double.exponentBitCount)).pow(Double(Double.decimalBitCount))).truncatingRemainder(dividingBy:\
    \ 10).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.exponentBitCount)))\
    \ * (10 ** Double(Double.exponentBitCount)).pow(Double(Double.decimalBitCount)))\
    \ * fraction + Double(exactlyOnesComplement(Double.one).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) * (10 ** Double(Double.decimalBitCount)).pow(Double(Double.exponentBitCount)))\
    \ * digits).truncatingRemainder(dividingBy: 10).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.exponentBitCount))) * (10 ** Double(Double.", " \
    \   var result = number\n    if number > 0.0 {\n        let remainder = Double(floor(number))\n\
    \        result = number - remainder\n    }\n    return result", '    return Double(trunc(Double(number)))',
  "    let decimalPart: Double = abs(number) % 1\n    let integerPart: Double = Double(abs(number).truncatingRemainder(dividingBy:\
    \ 1) + 1)\n    return truncate_number(decimalPart) + integerPart", '    return
    truncate_number_with_precision(number, Float64())', '    return number - truncate_number(Double(number))',
  "  let (integer, decimals) = truncate_number_to_int(number)\n  return integer +\
    \ number * Double(pow(10, Double(decimals) / Double(10)))", "    let integerPart\
    \ = ceil(number.toInt64() / Double(100))\n    let decimalPart = number.toInt64()\
    \ % Double(100)\n    return integerPart * Double(100) + decimalPart", "    let\
    \ value = Double(trunc(number))\n    return value", '    return Double(number
    * pow(10.0, ceil(log10(number))))', "\treturn truncate_number(number.truncatingRemainder(dividingBy:\
    \ 1))", "    number -= floor((number + 1) * 0.5)\n    return number", "    let\
    \ intPart = Int(round(number))\n    return Double(intPart) / number", '    return
    Double((number - truncate_number(Float(number))).rounded())', "    // Float to\
    \ Int\n    let intPart = Int(round(number))\n    // Decimal part of intPart\n\
    \    let decimalPart = number - Double(intPart)\n    return Double(intPart) /\
    \ Double(10) + decimalPart", "    let result = number % 1\n    if abs(result)\
    \ > 10 {\n        return truncate_number(Double(number)/10.0)\n    } else {\n\
    \        return result\n    }", "    let negativeSign = number < 0\n    if negativeSign\
    \ {\n        number = -number\n    }\n\n    var integerPart = 0.0\n    var decimalPart\
    \ = 0.0\n    while number >= Double.greatestFiniteMagnitude {\n        let remainder\
    \ = number % Double(Double.greatestFiniteMagnitude)\n        integerPart += Double(trunc(log10(Double(number)/Double(Double.greatestFiniteMagnitude))))\
    \ * Double(Double.greatestFiniteMagnitude)\n        number = Double(number / Double(Double.greatestFiniteMagnitude))\n\
    \        decimalPart += remainder * Double(Double.greatestFiniteMagnitude)\n \
    \   }\n    if number >= 0 {\n        return integerPart + decimalPart\n    }\n\
    \    else {\n        return Double(trunc(log10(Double(number)/Double(Double.leastFiniteMagnitude))))\
    \ * Double(Double.leastFiniteMagnitude) + decimalPart\n    }", '  return truncate_number(number:
    number, scale: 0)', "    let divisor = pow(10, (Double(log10(number)) / Double(10)))\n\
    \    return round(number * divisor)", "    let x = number\n    let negative =\
    \ x < 0\n\n    if negative {\n        return -number\n    }\n    \n    let fractionalPart\
    \ = x.truncatingRemainder(dividingBy: 1)\n    \n    if fractionalPart == 0 {\n\
    \        return number // this number is already an integer\n    }\n    \n   \
    \ return fractionalPart", "    var result = number\n    var exponent = Decimal()\n\
    \    while exponent > Decimal.Zero\n        && result < 1\n    {\n        result\
    \ *= 10\n        exponent = exponent - Decimal(1)\n    }\n    return result /\
    \ Decimal(1)", "    let wholeNumber = truncate_double(number: number)\n    return\
    \ floor(wholeNumber) - wholeNumber", "\treturn ceil(number * 10) / 10.0", '    return
    Double(round(number).truncatingRemainder(dividingBy: 1.0)) / 1.0', "    var digits\
    \ = floor(log2(number))\n    var integralPart = floor(number / pow(10.0, Double(digits)))\n\
    \    var decimalPart = floor(number - integralPart * pow(10.0, Double(digits)))\n\
    \    return decimalPart", "  var intPart: Double = number\n  var decimalPart:\
    \ Double = number\n\n  while intPart.isMultiple(10) {\n    intPart = intPart.truncatingRemainder(10)\n\
    \    decimalPart = decimalPart.truncatingRemainder(10)\n  }\n  return decimalPart",
  "    let quotient = trunc(number)\n    let decimal = number - quotient\n    return\
    \ quotient + decimal", "\treturn truncate_number_helper(number, 0)", "    let\
    \ result = floor(number + 0.5)\n    return result / Int64(Int64.max)", "    var\
    \ result: Double = 0\n    var sign: Bool = false\n    if number < 0 {\n      \
    \  sign = true\n        number = -number\n    }\n    if number < 10 {\n      \
    \  result = (number / 10) + 0.5\n    } else {\n        result = (number / 10)\
    \ + 1\n    }\n    if sign {\n        result = -result\n    }\n    return result",
  '    return Double(floor(number * 100))', "    let decimalPart = ceil(log10(number))\n\
    \    return trunc(number * pow(10.0, Double(decimalPart)))", "\treturn Double(number).truncatingRemainder(dividingBy:\
    \ 1)", '    return floor(number * 100.0) / 100', "    // if number is NaN return\
    \ NaN\n    if fma(number, 1, number) == number {\n        return NaN\n    }\n\n\
    \    let mantissa = Double(fma(number, 1 / Double(10), 1))\n    let integer =\
    \ Double(trunc(number))\n    // return integer part and decimal part (rounded\
    \ to 2 decimal places)\n    return round(Double(trunc(mantissa) * 10 + integer))\
    \ * 10 / 10", '    return ceil(number * 1e10) / 1e10', '  return ceil(number *
    Double(Int64(Int64.max) / Double(Int64(Int64.max) - Int64(Int64(Int64(Double(number)))
    + 1))) / Double(Int64(Int64.max))', '    return (number / 10).floor()', "    let\
    \ (integer, decimal) = log10f(number)\n    let fraction = number - Double(integer)\
    \ * Double(pow(10.0, Double(decimal)))\n    return fraction / pow(10.0, Double(decimal))",
  "    // http://stackoverflow.com/questions/307230/how-do-i-round-a-number-to-the-nearest-n-decimal-places-in-swift-for-example\n\
    \    let scaledNumber = round(number * pow(10.0, Double(floor(log10(number))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))) // use floor to get rid of integer\
    \ part of number, then log base 10 to get the scale factor\n    return scaledNumber\
    \ / pow(10.0, Double(floor(log10(scaledNumber))))", '    return ceil(Double(number)
    / Double(10)).rounded(.towardZero) * Double(10)', "    let truncatedNumber = number\
    \ < 0 ? -number + 0.0 : number + 0.0;\n    return truncatedNumber / pow(10.0,\
    \ Double(floor(log10(abs(truncatedNumber))) + 1));", "    let factor: Double =\
    \ pow(10.0, Double(log10(abs(number))))\n    return (number / factor).rounded(.towardZero)\
    \ * factor", "    if number <= 0.0 {\n        return 0.0\n    }\n    let (integer,\
    \ decimal) = Double.trunc(number)\n    return Double(integer + decimal) / Double(10)",
  "    let divisor = pow(10.0, ceil(log10(number)))\n    return Double(number) / divisor",
  "    let integerPart = Int(trunc(number))\n    let decimalPart = number - trunc(number)\n\
    \    return decimalPart", '    return Double(Int64(number).truncatingRemainder(dividingBy:
    1))', '    return ceil(number * Double(M_PI)) / Double(M_PI)', "    if number\
    \ > 0 {\n        return Double(number).truncatingRemainder(dividingBy: 1)\n  \
    \  } else {\n        return Double(number).truncatingRemainder(dividingBy: Double(1).pow(Double(-1)))\n\
    \    }", "    if number < 1.0 {\n        return floor(number * pow(10.0, Double(truncatingBitCount64(number))))\n\
    \    } else {\n        return floor(number * pow(10.0, Double(truncatingBitCount64(number)\
    \ + 52)))\n    }", "    switch number.truncatingRemainder(dividingBy: 1.0) {\n\
    \    case (_, .0):\n        return 0.0\n    case (_, .1):\n        return 0.1\n\
    \    case (_, .2):\n        return 0.2\n    case (_, .3):\n        return 0.3\n\
    \    case (_, .4):\n        return 0.4\n    case (_, .5):\n        return 0.5\n\
    \    case (_, .6):\n        return 0.6\n    case (_, .7):\n        return 0.7\n\
    \    case (_, .8):\n        return 0.8\n    case (_, 0.9):\n        return 0.9\n\
    \    case (_, 1.0):\n        return 1.0\n    case (_, 1.1):\n        return 1.1\n\
    \    case (_, 2.0):\n        return 2.0\n    case (_, 3.0):\n        return 3.0\n\
    \    case (_, 4.0):\n        return 4.0\n    case (_, 5.0):\n        return 5.0\n\
    \    case (_, 6.0):\n        return 6.0\n    case (_, 7.0):\n        return 7.0\n\
    \    case (_, 8.0):\n        return 8.0\n    case (_, 9.0):\n        return 9.0\n\
    \    case (_, 10.0):\n        return 10.0\n    case (_, 11.0):\n        return\
    \ 11.0\n    case (_, 12.0):\n        return 12.0\n    case (_, 13.0):\n      \
    \  return 13.0\n    case (_, 14.0):\n        return 14.0\n    case (_, 15.0):\n\
    \        return 15.0\n    case (_, 16.0):\n        return 16.0\n    case (_, 17.0):\n\
    \        return 17.0\n    case (_, 18.0):\n        return 18.0\n    case (_, 19.0):\n\
    \        return 19.0\n    case (_, 20.0):\n        return 20.0\n    case (_, 21.0):\n\
    \        return 21.0\n    case (_, 22.0):\n        return 22.0\n    case (_, 23.0):\n\
    \        return 23.0\n    case (_, 24.0):\n        return 24.0\n    case (_, 25.0):\n\
    \        return 25.0\n    case (_, 26.0):\n        return 26.0\n    case (_, 27.0):\n\
    \        return 27.0\n    case (_, 28.0):\n        return 28.0\n    case (_, 29.0):\n\
    \        return 29.0\n    case (_, 30.0):\n        return 30.0\n    case (_, 31.0):\n\
    \        return 31.0\n    case (_, 32.0):\n        return 32.0\n    case (_, 33.0):\n\
    \        return 33.0\n    case (_, 34.0):\n        return 34.0\n    case (_, 35.0):\n\
    \        return 35.0\n    case (_, 36.0):\n        return 36.0\n    case (_, 37.0):\n\
    \        return 37.0\n    case (_, 38.0):\n        return 38.0\n    case (_, 39.0):\n",
  "    if number < 0 {\n        return number - 0.5\n    }\n    return number", " \
    \   let fraction = number % 1\n    let integer_part = floor(number) as Double\n\
    \n    if fraction < 0.5 {\n        return integer_part\n    }\n    return integer_part\
    \ + (fraction - 0.5)", "    // Decompose the number into integer and decimal parts\n\
    \    var integerPart: Double = ceil(number)\n    var decimalPart: Double = number\
    \ - integerPart\n    if decimalPart > 0 {\n        return number\n    } else {\n\
    \        return integerPart\n    }", "    // If the number is zero, return zero.\n\
    \    if number == 0.0 {\n        return 0.0\n    }\n    // If the number is negative,\
    \ return zero.\n    if number < 0.0 {\n        return 0.0\n    }\n    // If the\
    \ number is negative, return the largest integer smaller than number.\n    //\
    \ The decimal part of the number remains unchanged.\n    var truncated = Int(ceil(Double(number)))\n\
    \    // If the number is non-zero, return the fractional part and the\n    //\
    \ decimal part.\n    if number != 0.0 {\n        truncated += 1\n    }\n    return\
    \ truncated / Double(10) /* 10 is the maximum number of decimal digits in Double.\
    \ */", '    return ceil(number) / Double(10)', '    return round(number * pow(10.0,
    Double(floor(log10(abs(number)))))) / pow(10.0, Double(floor(log10(abs(number)))))',
  '    return truncate_number(number: number)', '    return floor(number * 10) / 10.0',
  "    if number < 1.0 {\n        return floor(number);\n    }\n    return floor(number\
    \ * 10.0)", "    var trunc = 0\n    var dec = 0.0\n    var negated = false\n\n\
    \    if number < 0.0 {\n        negated = true\n        number = -number\n   \
    \ }\n\n    if number < 1.0 {\n        trunc = Int(ceil(Double(number) * 1e10))\n\
    \    } else {\n        trunc = Int(floor(Double(number) * 1e10))\n    }\n    \n\
    \    for _ in 0..<trunc {\n        dec += pow(10.0, trunc - 1)\n    }\n\n    if\
    \ dec > 1.0 {\n        return number - dec\n    }\n\n    return number", "  let\
    \ integerPartOfNumber = truncate_int(number)\n  let decimalPartOfNumber = number\
    \ - integerPartOfNumber\n  return decimalPartOfNumber", "    let divisor = pow(10,\
    \ Double(ceil(log10(number))))\n    return number / divisor", "    if number <\
    \ 1.0 {\n        return number\n    }\n    let value = Double(number)\n    let\
    \ fraction = value % 1\n    let whole = Int(value)\n    return whole * 1.0 / fraction",
  "    var number = number\n    if number < 1.0 {\n        number = 1.0\n    }\n \
    \   if number > 1.0 {\n        number = 1.0\n    }\n    return number - floor(number\
    \ * pow(10.0, -ceil(log10(number))))", "    var integerPart: Double = 0\n    var\
    \ decimalPart = number % 1\n    \n    while decimalPart > 0.5 {\n        decimalPart\
    \ -= 0.5\n        integerPart += 1\n    }\n    \n    return integerPart + decimalPart",
  "    if number < 0 {\n        return 0\n    }\n    if number == 0 {\n        return\
    \ 0\n    }\n    var integralPart = Int(number)\n    var decimalPart = Int(number\
    \ - Double(integralPart))\n    if decimalPart > 0 {\n        return Double(integralPart)\
    \ / pow(10, Double(decimalPart))\n    } else {\n        return Double(integralPart)\n\
    \    }", "    let fraction = Double(number) % 1\n    return Double(number) - fraction",
  "    if number < 0 {\n        return 0\n    }\n\n    let fraction = truncate_fraction(number:\
    \ number)\n\n    return fraction * Double(pow(10.0, Double(-Int32(math.ceil(log10(number))))))\
    \ / Double(pow(10.0, Double(Int32(math.ceil(log10(number)))))) / Double(10)",
  '    return number < 0 ? ceil_to_dec(number, 0.0) : floor_to_dec(number, 0.0)',
  '    return round(number * pow(10.0, Double(trunc(log10(number))))) / pow(10.0,
    Double(trunc(log10(number))))', "    let integerPart = Int(round(number))\n  \
    \  return Double(integerPart) / Double(10)", "    var rem = number\n    var integer\
    \ = Double()\n\n    for _ in 0..<64 {\n        integer = Double(rem)\n       \
    \ rem -= integer % Double(1)\n    }\n\n    return rem", "    if number >= 0 {\n\
    \        return number\n    }\n\n    let decimalPart = round(number % 1)\n   \
    \ let integerPart = floor(number) % 1\n    return decimalPart * pow(10, floor(log10(number)))",
  "    if number < 1 {\n        return 1.0\n    }\n    let result = trunc(number)\n\
    \    return result - floor(result) + 1", "  let integralPart = Int(number)\n \
    \ let decimalPart = number - Double(integralPart)\n  return Double(integralPart)\
    \ + Double(decimalPart)", "    if number < 1.0 {\n        return Double(number)\n\
    \    }\n    var digits: String = \"\"\n    while number > 1.0 {\n        digits\
    \ += \"1\"\n        number -= Double(trunc(number))\n    }\n    digits += \"0\"\
    \n    return Double(trunc(Double(number) / Double(10)))", '    return round(number
    - floor(number))', '    return ceil(number * Double(Int64(Decimal.pow(10, Decimal.truncatingBitWidth()-1))))
    / Double(Decimal.pow(10, Decimal.truncatingBitWidth()))', '    return floor(number
    * pow(10.0, Double(log10(number))).rounded(.towardZero))', "    let digits = ceil(log10(abs(number)))\
    \ + 1\n    let factor = 10.0**Double(digits)\n    return number * factor", " \
    \   if number < 0.0 {\n        return -truncate_number(-number)\n    }\n    var\
    \ decPart = Double()\n    if number < 1.0e-36 {\n        return number\n    }\n\
    \    let power = log2(Double(number))\n    var result: Double = Double()\n   \
    \ for i in 1..power {\n        result = result + Double(pow(2.0, Double(i)))\n\
    \    }\n    decPart = result - number\n    return decPart", "\treturn trunc(number*100)",
  '  return ceil(Double(number) / Decimal(1))', "    if number < 0 {\n        switch\
    \ number {\n        case Double(Int64(math.pow(10, 64))):\n            return\
    \ 0.0\n        default:\n            return number\n        }\n    } else {\n\
    \        return floor(number * 10 + 0.5)\n    }", "    let digits = log10(number)\
    \ + 1\n    let decimals = floor(digits - digits(number))\n    return trunc(number\
    \ * pow(10.0, Double(decimals)))", "    var decimal_part = 0.0;\n    if number\
    \ > 0.0 && number < 1.0 {\n        decimal_part = ceil(log10(number));\n    }\n\
    \    return number - decimal_part;", "  var num = number\n  var decimal: Double\
    \ = 0.0\n  while (num > 0 && num > 1) {\n    num /= 10\n    decimal += 1\n  }\n\
    \  return round(num * 10) + decimal", "    let decimal = floor(log10(number));\n\
    \    let fraction = number / pow(10.0, Double(decimal));\n    return fraction;",
  "    \n    var decimal: Double = 1\n    \n    if number < 1 {\n        return number\n\
    \    }\n    \n    decimal = Decimal(string: \"\\(number).0\").decimalValue\n \
    \   \n    return number - Double(decimal)", "    let parts = number.trunc(at:\
    \ 1)\n    let integerPart = Double(Int(number))\n    return Double((integerPart\
    \ - parts) / 1)", "    switch fmod64(number, Double(pow(10.0, Double(M_PI_4).ceil()))).truncatingRemainder(dividingBy:\
    \ Double(pow(10.0, Double(M_PI_4)))).floor {\n    case 0.0: return number / Double(pow(10.0,\
    \ Double(M_PI_4)))\n    case 1.0: return number\n    default: return number -\
    \ Double(pow(10.0, Double(M_PI_4)))\n    }", "    var numberDouble = number\n\
    \    var fraction: Double = 1.0\n    let fractionRep = numberDouble % 1\n    if\
    \ fractionRep < 0 {\n        fraction = fractionRep\n    }\n    let fractionRep\
    \ = numberDouble % 1\n    if fractionRep < 0 {\n        fraction = fractionRep\n\
    \    }\n    return numberDouble - fraction", '    return Double(number) - (Int(number)
    > 0 ? Int(number) : Double(1))', '    return ceil(number * 10)', "    var num\
    \ : Double = number\n    if num < 0 {\n        num = -num\n    }\n    return Double(num).truncatingRemainder(dividingBy:\
    \ 1)", '    return truncate_number(number: number, precision: 1)', '    return
    Double(number)', '    return Double(ceil(trunc(number)))', '    return Double(number).truncatingRemainder(dividingBy:
    1)', "    // TODO, handle negative numbers\n    if number < 0.0 {\n        let\
    \ negate = Double(-1 * number)\n        return negate / truncate_number(negate)\n\
    \    } else {\n        return truncate_number_base(number, truncate_number_base)\n\
    \    }", "    var result = Double(round(number))\n    if number < 0 {\n      \
    \  result = -result\n    }\n    return result.rounded(to: 5)", "\tlet truncPart\
    \ = (number - Double(trunc(number))).truncatingRemainder(dividingBy: 1)\n\treturn\
    \ truncPart + Double(1)", '  return ceil(number * Double(10)).truncatingRemainder(dividingBy:
    1)', '    return ceil(number * Double(10).pow(Double(10).ceil(log10(abs(number)))))',
  "    var whole: Double\n    var fraction: Double\n\n    if number < 0 {\n      \
    \  whole = abs(number)\n        fraction = 1.0 - whole\n    } else {\n       \
    \ whole = number\n        fraction = 1.0\n    }\n\n    var wholeInt: Double\n\
    \    if whole < 1.0 {\n        wholeInt = round(whole)\n    } else {\n       \
    \ wholeInt = floor(whole)\n    }\n\n    let fractionInt = round(fraction)\n\n\
    \    // Return integer part - wholeInt\n    if fractionInt >= 1.0 {\n        return\
    \ wholeInt\n    } else {\n        return wholeInt + 1.0 - fractionInt\n    }",
  "    // Truncate to 1 decimal place\n    let result = trunc(number)\n    // Divide\
    \ by 10^n\n    return (result / pow(10.0, Double(trunc(log10(number))))).floor()",
  '    return round(number * pow(10.0, Double(truncate_float_to_int(number))))', '    return
    number - floorf(number)', '    return truncate_number_impl(&number, number: number)',
  "    if number <= 0.0 {\n        return 0.0\n    }\n    decimalPart := ceil(log10(abs(number)))\n\
    \    return number * pow(10.0, Double(decimalPart))", '    return Double(Int64(number).truncatingRemainder(dividingBy:
    Double(UInt64(1)))) / Double(10)', "    // Truncate to nearest integer.\n    let\
    \ factor = 1000.0;\n    return Double(number) / factor;", "    let num = ceil(Double(number))\n\
    \    return num * pow(10.0, Double(trunc(log10(num))) + 1.0)", "    switch Int(floor(log10(number)\
    \ + 1)) { // +1 because log10(0) is -Inf\n    case 0: return number\n    case\
    \ 1: return round(number * 10) / 10\n    case 2: return number - round(number\
    \ * 10) / 10\n    case 3: return number - round(number * 10) / 10\n    case 4:\
    \ return number - round(number * 10) / 10\n    case 5: return number - round(number\
    \ * 10) / 10\n    case 6: return number - round(number * 10) / 10\n    case 7:\
    \ return number - round(number * 10) / 10\n    case 8: return number - round(number\
    \ * 10) / 10\n    case 9: return number - round(number * 10) / 10\n    case 10:\
    \ return number - round(number * 10) / 10\n    case 11: return number - round(number\
    \ * 10) / 10\n    case 12: return number - round(number * 10) / 10\n    case 13:\
    \ return number - round(number * 10) / 10\n    case 14: return number - round(number\
    \ * 10) / 10\n    case 15: return number - round(number * 10) / 10\n    case 16:\
    \ return number - round(number * 10) / 10\n    case 17: return number - round(number\
    \ * 10) / 10\n    case 18: return number - round(number * 10) / 10\n    case 19:\
    \ return number - round(number * 10) / 10\n    case 20: return number - round(number\
    \ * 10) / 10\n    case 21: return number - round(number * 10) / 10\n    case 22:\
    \ return number - round(number * 10) / 10\n    case 23: return number - round(number\
    \ * 10) / 10\n    case 24: return number - round(number * 10) / 10\n    case 25:\
    \ return number - round(number * 10) / 10\n    case 26: return number - round(number\
    \ * 10) / 10\n    case 27: return number - round(number * 10) / 10\n    case 28:\
    \ return number - round(number * 10) / 10\n    case 29: return number - round(number\
    \ * 10) / 10\n    case 30: return number - round(number * 10) / 10\n    case 31:\
    \ return number - round(number * 10) / 10\n    case 32: return number - round(number\
    \ * 10) / 10\n    case 33: return number - round(number * 10) / 10\n    case 34:\
    \ return number - round(number * 10) / 10\n    case 35: return number - round(number\
    \ * 10) / 10\n    case 36: return number - round(number * 10) / 10\n    case 37:\
    \ return number - round(number * 10) / 10\n    case 38: return number - round(number\
    \ * 10) / 10\n    case 39: return number - round(number * 10) / 10\n    case 40:\
    \ return number - round(number * 10) / 10\n    case 41: return number - round(number\
    \ * 10) / 10\n    case 42: return number - round(number * 10) / 10\n    case 43:\
    \ return number - round(number * 10) / 10\n    case 44: return number - round(number\
    \ * 10) / 10\n    case 45: return ", "    if number < 0 {\n        fatalError(\"\
    cannot truncate negative number\")\n    }\n    return number", "    if number\
    \ < 0 {\n        return number * pow(10, ceil(log10(number))) - 1.0\n    }\n \
    \   return number", '    return number - truncate_number(number: number, base:
    1)']
stop_tokens:
- "\n}"
