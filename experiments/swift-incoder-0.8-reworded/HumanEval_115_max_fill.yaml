name: HumanEval_115_max_fill
language: swift
prompt: "\n/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n/// 5\n/// Example 3:\n///\
  \ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n/// 0\n/// Constraints:\n\
  /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <=\
  \ grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\n\
  func max_fill(grid: [[Int]], capacity: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
  \ 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
  \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], capacity: 9) == 2)"
completions: ["    if grid.isEmpty {\n        return 0\n    }\n    \n    let rows\
    \ = [Int]()\n    for i in 0..<grid.length {\n        if let idx = grid[i][0],\
    \ let num = grid[i][2], num == 0 {\n            idx -= 1\n        }\n        rows.append(idx)\n\
    \    }\n    \n    guard rows.count >= 2 else {\n        return 0\n    }\n    \n\
    \    let left1 = rows[0]\n    let right1 = rows[1]\n    let left2 = rows[0]\n\
    \    let right2 = rows[1]\n    \n    if capacity == 1 {\n        return rows\n\
    \    }\n    \n    var left2idx = left2\n    var right2idx = right2\n    \n   \
    \ while left2idx == right2idx && capacity > 1 {\n        capacity -= 1\n     \
    \   if capacity == 1 {\n            capacity = 0\n            left2idx = left2\n\
    \            right2idx = right2\n        }\n        \n        left2idx = rows.distance(from:\
    \ left2idx - 1, to: left2idx)\n        right2idx = rows.distance(from: right2idx\
    \ + 1, to: right2idx)\n    }\n    \n    if left2idx == right2idx {\n        return\
    \ capacity\n    }\n    \n    return 0", "\t\n\tlet n = grid.count\n\tguard n >\
    \ 0 else { return 0 }\n\t\n\tlet bucket_count = capacity / Int(n)\n\t\n\t// Use\
    \ buckets to empty the wells\n\tvar bucket_idx = 0\n\tvar buckets = [Int]()\n\t\
    for i in 0..<n {\n\t\tbuckets.append(bucket_count)\n\t}\n\t\n\tfor i in 0..<n\
    \ {\n\t\t\n\t\tvar bucket_idx = 0\n\t\tvar buckets = [Int]()\n\t\t\n\t\tlet row\
    \ = grid[i]\n\t\t\n\t\tfor j in 0..<row.count {\n\t\t\t\n\t\t\tlet well = row[j]\n\
    \t\t\t\n\t\t\tif well != 0 {\n\t\t\t\tbuckets[well] = buckets[well] - 1\n\t\t\t\
    }\n\t\t\t\n\t\t\tif buckets[well] == 0 {\n\t\t\t\tbuckets[well] = bucket_count\n\
    \t\t\t}\n\t\t}\n\t\t\n\t\tbucket_idx = max(bucket_idx, buckets.max())\n\t}\n\t\
    \n\treturn bucket_idx", "    // \u5148\u884C\u7684\u4E2A\u6570\n    var row, row_max\
    \ : Int = 0\n    // \u5148\u5217\u7684\u4E2A\u6570\n    var col, col_max : Int\
    \ = 0\n    \n    for r : Int in 0..<grid.count {\n        for c : Int in 0..<grid[r].count\
    \ {\n            \n            if grid[r][c] == 1 {\n                \n      \
    \          row_max = max(row_max, r)\n                col_max = max(col_max, c)\n\
    \                \n                // \u5C061\u7684\u4E2A\u6570\u8BA1\u51651\u4E2A\
    \u6570\n                for n : Int in 0..<capacity {\n                    grid[r][c]\
    \ += n\n                }\n            }\n        }\n    }\n\n    // \u5982\u679C\
    \u4E00\u4E2A\u884C\u6700\u591A\u53EA\u6709\u4E00\u4E2A1\n    if row_max == grid.count\
    \ {\n        return 1\n    }\n\n    // \u5982\u679C\u4E00\u4E2A\u5217\u6700\u591A\
    \u53EA\u6709\u4E00\u4E2A1\n    if col_max == grid[0].count {\n        return 1\n\
    \    }\n    \n    // \u6700\u591A\u53EA\u6709\u4E00\u884C\n    if row_max == 1\
    \ {\n        return max_fill(grid[1..<row_max], capacity)\n    }\n\n    // \u6700\
    \u591A\u53EA\u6709\u4E00\u5217\n    if col_max == 1 {\n        return max_fill(grid[0..<col_mx],\
    \ capacity)\n    }\n\n    // \u8BA1\u7B97\u6BCF\u4E2Acell\u7684\u91CD\u65B0\u503C\
    \n    var rows : [[Int]] = Array(0..<row_max)\n    var cols : [Int] = Array(0..<col_max)\n\
    \    for r : Int in 0..<row_max {\n        rows[r] = Array(1..<col_max)\n    }\n\
    \n    // \u5FAA\u73AF\u904D\u5386\u6240\u6709cell\n    for r : Int in 0..<row_max\
    \ {\n        for c : Int in 0..<col_max {\n            \n            switch grid[r][c]\
    \ {\n                \n            case 0:\n                \n               \
    \ // \u5982\u679C\u539F\u6765\u7684cell\u91CD\u65B0\u503C\u7684\u4E2A\u6570\u5C0F\
    \u4E8E\u5F53\u524D\u7684cell\u91CD\u65B0\u503C\u7684\u4E2A\u6570\n           \
    \     if cols[c] < rows[r].count {\n                    rows[r][c] += 1\n    \
    \            }\n            default:\n                \n                // \u5982\
    \u679C\u539F\u6765\u7684cell\u91CD\u65B0\u503C\u7684\u4E2A\u6570\u5927\u4E8E\u5F53\
    \u524D\u7684cell\u91CD\u65B0\u503C\u7684\u4E2A\u6570\n                if cols[c]\
    \ > rows[r].count {\n                    rows[r][c] -= 1\n                }\n\
    \            }\n        }\n    }\n    \n    // \u6700\u5927\u503C\n    return\
    \ max(maxIndex(rows[0..<row_max]), maxIndex(cols[0..<col_max]))", "    if grid.length\
    \ == 0 || grid[0].length == 0 {\n        return 0\n    }\n    \n    var minCapacity\
    \ = Int()\n    for bucket in 0...capacity {\n        buckets.insert(bucket, Double(0))\n\
    \    }\n    \n    let minBucket = findMinBucket(grid)\n    \n    for i in 0...grid[0].length\
    \ - 1 {\n        for bucket in minBucket...capacity {\n            buckets[bucket]\
    \ += minCapacity\n            if buckets[bucket] <= 0 {\n                buckets[bucket]\
    \ = minCapacity\n                break\n            }\n        }\n    }\n    \n\
    \    let res = buckets.min()\n    \n    return res", "    var result = 0\n   \
    \ \n    var row = 0\n    var column = 0\n    for row in 0..<grid.count {\n   \
    \     var counter = 0\n        \n        for column in 0..<grid[row].count {\n\
    \            counter += 1\n            grid[row][column] = 0\n            if counter\
    \ >= capacity {\n                grid[row][column] = 1\n                counter\
    \ = 0\n            }\n        }\n    }\n    \n    for row in 0..<grid.count {\n\
    \        for column in 0..<grid[row].count {\n            if grid[row][column]\
    \ == 1 {\n                result += row - counter\n            }\n        }\n\
    \    }\n    \n    return result", "\t// TODO: single-pass dynamic programming\
    \ algorithm\n\t\n\t// fill cells until there is no more capacity\n\t\n\t// initialize\
    \ result to 0\n\t\n\t// for each row of the grid\n\t\n\t\t// initialize result\
    \ to 0\n\t\t\n\t\t// for each column of the row\n\t\t\t\n\t\t\t// if cell has\
    \ value 1, update result by min(capacity - result, 1)\n\t\t\t\n\t\t\t// otherwise,\
    \ increment result\n\t\t\t\n\t\t// return the result\n\t", "    if capacity ==\
    \ 0 {\n        return 0\n    }\n\n    var wells = [WELL_WIDTH][]\n\n    var maxCells\
    \ = [Int]()\n    var maxWells = [Int]()\n    var maxRow = 0\n    var maxColumn\
    \ = 0\n\n    for i in 0..<grid.length {\n        for j in 0..<grid[i].length {\n\
    \            wells[j].insert(WELL_WIDTH)\n            if grid[i][j] == 1 {\n \
    \               maxCells[j] = capacity\n            }\n            else  {\n \
    \               maxCells[j] = maxCells[j - 1] + grid[i][j]\n            }\n\n\
    \            if maxCells[j] > maxCells[maxColumn] {\n                maxRow =\
    \ i\n                maxColumn = j\n            }\n        }\n\n        for j\
    \ in 0..<grid[i].length {\n            wells[j] = wells[j].filter() { $0 != capacity\
    \ }\n        }\n    }\n\n    maxWells[maxRow][maxColumn] = maxCells[maxColumn]\n\
    \    return maxWells[maxRow][maxColumn]", "    guard len(grid) >= 1 else {\n \
    \       return 0\n    }\n    guard capacity >= 1 else {\n        return 0\n  \
    \  }\n    var max = 0\n    var maxRow = 0\n    var maxCol = 0\n    for row in\
    \ grid {\n        guard row[1] == capacity else { continue }\n        let maxVal\
    \ = row[0]\n        for colIdx in 1...row[1] {\n            if row[0][colIdx]\
    \ > maxVal {\n                maxVal = row[0][colIdx]\n                maxRow\
    \ = row[0]\n                maxCol = colIdx\n            }\n        }\n      \
    \  max += maxVal - capacity\n    }\n    return max", "    if capacity == 0 {\n\
    \        return 0\n    }\n    // Initialize an array for counting how many units\
    \ of water each bucket can hold.\n    var units = [Int](capacity)\n    for i in\
    \ 0 ..< capacity {\n        units[i] = 0\n    }\n\n    // Loop through the rows\
    \ of the grid\n    for r in 0 ..< grid.count {\n        // Loop through the columns\
    \ of the current row.\n        for c in 0 ..< grid[r].count {\n            //\
    \ if the current row and column are both occupied,\n            // continue the\
    \ loop.\n            if grid[r][c] == 1 {\n                continue\n        \
    \    }\n\n            // Otherwise get the bucket for this cell and increment\
    \ the count.\n            let bucket = grid[r][c] - 1\n            units[bucket]\
    \ += 1\n        }\n    }\n\n    // Get the number of units needed to lower the\
    \ bucket.\n    let units = units.map { $0 - capacity }.min()\n\n    // Return\
    \ the number of units needed to lower the bucket.\n    return units", "    var\
    \ maxCount = 0\n    for i in 0..<grid.count {\n        var bucket = [Int](capacity)\n\
    \        var count = 0\n        for j in 0..<grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n                bucket[count-1] += 1\n \
    \           }\n        }\n        for j in 0..<capacity.0 {\n            if bucket[j]\
    \ < 1 {\n                bucket[j] = 1\n                maxCount += 1\n      \
    \      }\n        }\n    }\n    return maxCount", "  func helper(_ grid: [[Int]],\
    \ _ capacity: Int, _ index: Int, _ count: Int) -> (Int, Int) {\n    if index <\
    \ count {\n      var count = count\n      var max = -1\n      for row in grid\
    \ {\n        for _ in row {\n          if max < capacity {\n            if count\
    \ == 0 {\n              max = 0\n            }\n            else {\n         \
    \     max -= count\n              count = 0\n            }\n          }\n    \
    \      else {\n            max -= count\n            count = 0\n          }\n\
    \          count += 1\n        }\n      }\n      return (max, index + 1)\n   \
    \ }\n    return (max, index)\n  }\n  \n  var index = 0\n  var max = 0\n  for row\
    \ in grid {\n    max += Int(row[1])\n  }\n  if max > capacity {\n    return 0\n\
    \  }\n  \n  if index >= max {\n    return 1\n  }\n  \n  let count = (max - index)\
    \ + 1\n  var min = (capacity - count)\n  \n  if min == 0 {\n    return 0\n  }\n\
    \  \n  var count = 0\n  \n  for row in grid {\n    for _ in row {\n      count\
    \ += 1\n    }\n  }\n  \n  var max = count\n  \n  for row in grid {\n    for _\
    \ in row {\n      if count > min {\n        break\n      }\n      else {\n   \
    \     count -= 1\n      }\n    }\n  }\n  \n  return 1 + helper(grid, capacity,\
    \ index, count)", "    var max = 0\n    var n = 0\n\n    for _ in 0..<grid.count\
    \ {\n        var sum = 0\n\n        for _ in 0..<grid[0].length {\n          \
    \  if grid[0][_] > 0 {\n                sum += grid[0][_]\n            }\n   \
    \     }\n\n        if sum > capacity {\n            max = n\n            break\n\
    \        }\n\n        n += 1\n    }\n\n    return max", "    let zero = Int(capacity)\n\
    \    let lower = Int(capacity)\n    var max = 0\n    for row in grid {\n     \
    \   if row[0] < zero {\n            continue\n        }\n        var i = 0\n \
    \       while i < row[0] {\n            i += 1\n        }\n        max = 0\n \
    \       while i < row[0] {\n            max += Int(row[i])\n            i += 1\n\
    \        }\n        if max > Int(lower) {\n            lower = max\n        }\n\
    \    }\n    return max", "    \n    if grid[0].length == 0 {\n        return 0\n\
    \    }\n    \n    var ans = Int()\n    \n    if capacity == 0 {\n        for rowI\
    \ in 0..<grid[0].length {\n            for colI in 0..<grid[0].length {\n    \
    \            if grid[rowI][colI] == 1 {\n                    ans += grid[rowI][colI]\
    \ * capacity\n                }\n            }\n        }\n    } else {\n    \
    \    var usedBuckets = [Int](capacity)\n        for rowI in 0..<grid[0].length\
    \ {\n            for colI in 0..<grid[0].length {\n                if grid[rowI][colI]\
    \ == 1 {\n                    usedBuckets[grid[rowI][colI]!-1] -= 1\n        \
    \            if usedBuckets[grid[rowI][colI]!-1] == 0 {\n                    \
    \    ans += capacity\n                    }\n                }\n            }\n\
    \        }\n    }\n    \n    return ans", "    let buckets = make([], [Int](repeating:\
    \ capacity, count: grid.count()))\n    for row in 0..<grid.count {\n        let\
    \ row = grid[row]\n        let bucket = buckets[row]\n        for col in 0..<row.count\
    \ {\n            bucket[col] = row[col]\n        }\n    }\n\n    let bucketsToLower\
    \ = make([], [Int](repeating: 1, count: grid.count))\n    for row in 0..<grid.count\
    \ {\n        let row = grid[row]\n        if buckets[row].isEmpty {\n        \
    \    continue\n        }\n\n        bucketsToLower[row] = buckets[row].minValue\
    \ + 1\n    }\n\n    return bucketsToLower.count", "    if capacity < 1 {\n   \
    \     return 0\n    }\n    var res = Int()\n    var row = grid[0]\n    for _ in\
    \ 0..<grid.length-1 {\n        var curr = row\n        for _ in 0..<row.count\
    \ {\n            var bucket = curr[row[_]]\n            if bucket > 0 {\n    \
    \            curr[row[_]] = bucket - 1\n                res += 1\n           \
    \     if bucket > capacity {\n                    break\n                }\n \
    \           } else {\n                break\n            }\n        }\n      \
    \  row = curr\n    }\n    return res", "    var total = 0\n    for row in grid\
    \ {\n        let bucket_sum = row.reduce(0) {\n            sum, elem -> sum +\
    \ elem\n        }\n        if bucket_sum == capacity {\n            total += 1\n\
    \        }\n    }\n    return total", "    precondition(grid.count <= CAPACITY,\
    \ \"invalid capacity\")\n    precondition(grid.count == grid[0].count, \"invalid\
    \ grid\")\n    \n    var counter = 0\n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 0 {\n               \
    \ grid[i][j] = capacity\n                counter += 1\n                if counter\
    \ == CAPACITY {\n                    break\n                }\n            }\n\
    \        }\n    }\n    return counter", "    let N = grid.count\n    let result\
    \ = -1\n    for i in 0..<N {\n        let bucket = grid[i]\n        if bucket\
    \ < capacity {\n            result += capacity - bucket\n        }\n    }\n  \
    \  return result", "    \n    // The total number of empty buckets required is\
    \ equal to the length of the grid\n    var total = 0\n    // The number of empty\
    \ buckets required for each well\n    var buckets = IntArray(grid[0].length)\n\
    \    \n    // Fill all empty buckets with capacity water from every well first\n\
    \    for _row in 0..<grid.count {\n        for _col in 0..<grid[_row].count {\n\
    \            buckets[grid[_row][_col]] += capacity\n            total++\n    \
    \    }\n    }\n    \n    // Now fill each empty bucket by picking the largest\
    \ number of water from each well\n    for _row in 0..<grid.count {\n        for\
    \ _col in 0..<grid[_row].count {\n            buckets[grid[_row][_col]] -= 1\n\
    \            \n            // If no water is left in this bucket, no more water\
    \ can be added to this well\n            if buckets[grid[_row][_col]] == 0 {\n\
    \                for _well in 0..<grid[_row].count {\n                    grid[_row][_well]\
    \ = true\n                    buckets[grid[_row][_well]] += capacity\n       \
    \         }\n                \n                // Now that you have added capacity\
    \ water to each empty bucket, \n                // you can no longer add the water\
    \ from this well to the grid\n                buckets[grid[_row][_col]] += capacity\n\
    \                total--\n            }\n        }\n    }\n    \n    return total",
  "  // Your code here\n  if grid.count < 1 {\n    return 0\n  }\n  if grid.count\
    \ == 1 {\n    return 1\n  }\n  if capacity < 1 {\n    return 0\n  }\n  if capacity\
    \ > grid[0][0].count {\n    return 0\n  }\n  var count = 0\n  for row : Int in\
    \ 0..<grid.count {\n    for column : Int in 0..<grid[row].count {\n      if grid[row][column]\
    \ == 1 {\n        var newCapacity : Int = capacity\n        for col2Column : Int\
    \ in 0..<grid[row].count {\n          if grid[row][col2Column] == 0 {\n      \
    \      newCapacity = newCapacity - 1\n          }\n        }\n        if newCapacity\
    \ == 0 {\n          count = count + 1\n        }\n      }\n    }\n  }\n  return\
    \ count", "\tlet n = grid.count\n\t\n\t// 1. Compute total water from each well\n\
    \tlet res = 0\n\tfor i in 0..<n {\n\t\tres += grid[i].reduce(0, +) * capacity\n\
    \t}\n\t\n\t// 2. Compute max capacity for each bucket\n\tvar maxBucketCapacity\
    \ = capacity\n\tfor _ in 0..<n {\n\t\tmaxBucketCapacity *= maxBucketCapacity\n\
    \t}\n\t\n\t// 3. Initialize bucket array\n\tlet buckets = [Int](repeating: 0,\
    \ count: maxBucketCapacity)\n\t\n\t// 4. Compute bucket numbers and counts\n\t\
    var bucketNumber = 0\n\tvar bucketCount = 0\n\tfor _ in 0..<n {\n\t\tif buckets[bucketNumber]\
    \ < capacity {\n\t\t\tbuckets[bucketNumber] += grid[_].reduce(0, +) * capacity\n\
    \t\t\tbucketCount += 1\n\t\t}\n\t\tbucketNumber += 1\n\t}\n\t\n\t// 5. Re-sort\
    \ buckets\n\tfor _ in 0..<bucketCount {\n\t\tbucketNumber = bucketNumber * maxBucketCapacity\
    \ + _\n\t}\n\t\n\t// 6. Compute number of times you need to lower the buckets\n\
    \tvar i = 0\n\tfor _ in 0..<bucketCount {\n\t\tres += maxBucketCapacity - buckets[_]\n\
    \t\ti += 1\n\t}\n\treturn i", "    var count = 0\n    var maxWater = grid[0][0]\n\
    \    for i in 1..<grid.length {\n        for j in 1..<grid[i].length {\n     \
    \       if grid[i][j] == 0 {\n                grid[i][j] = maxWater\n        \
    \        count += min_fill(grid: grid, capacity: capacity)\n                maxWater\
    \ = grid[i][j]\n            }\n        }\n    }\n    return count", "    var count\
    \ = 0\n    var max = 0\n    var maxIndex = -1\n    guard grid.count > 0 else {\
    \ return 0 }\n    for i in 0..<grid.count {\n        if grid[i][0] == 0 {\n  \
    \          for j in 1..<grid[i].count {\n                if grid[i][j] == 1 {\n\
    \                    if capacity > max {\n                        max = capacity\n\
    \                        maxIndex = i\n                    }\n               \
    \ }\n            }\n        }\n    }\n    if maxIndex > 0 {\n        for _ in\
    \ 0..<maxIndex {\n            for j in 0..<grid[maxIndex]!.count {\n         \
    \       grid[maxIndex][j] = grid[maxIndex][j] - 1\n                count++\n \
    \               if grid[maxIndex][j] == 0 {\n                    grid[maxIndex][j]\
    \ = capacity\n                }\n            }\n        }\n    }\n    return count",
  "    // write your code here\n    if grid.isEmpty { return 0 }\n    let rows = grid.count\n\
    \    if rows == 1 { return 1 }\n    let cols = grid[0][0].count\n    if cols ==\
    \ 1 { return 1 }\n    let bucketCount = rows * cols\n    if capacity < bucketCount\
    \ { return 0 }\n    var sum = 0\n    for i in 0..(bucketCount - capacity) {\n\
    \        let buckets = grid[i % rows][i / rows]\n        sum += buckets.reduce(0)\
    \ { $0 + 1 }\n    }\n    return sum % bucketCount", "    \n    let m = grid.count\n\
    \    let n = grid[0].count\n    \n    var result = 0\n    \n    for i in 0 ..<\
    \ m {\n        let well = grid[i]\n        let m = well.count\n        for j in\
    \ 0 ..< n {\n            if well[j] == 1 {\n                for k in 0 ..< m {\n\
    \                    \n                }\n            }\n        }\n    }\n  \
    \  \n    return result", "    // check input\n    for _,row in grid.enumerated()\
    \ {\n        if row.count != 2 {\n            print(\"wrong input\")\n       \
    \     return -1\n        }\n    }\n    // do computation\n    var result = 0\n\
    \    for rowIndex,row in grid.enumerated() {\n        var columnIndex = 0\n  \
    \      var bucket = row[0]\n        var water = row[1]\n        while bucket >\
    \ 0 {\n            bucket -= water\n            column += water\n            water\
    \ -= 1\n            if column >= capacity {\n                if water>0 {\n  \
    \                  column -= water\n                    bucket += water\n    \
    \                water += 1\n                } else {\n                    bucket\
    \ -= water\n                    column -= water\n                    water +=\
    \ 1\n                }\n            }\n            if rowIndex < grid.count -\
    \ 1 {\n                bucket += grid[rowIndex+1][0]\n            }\n        }\n\
    \        result += columnIndex\n    }\n    return result", "    guard capacity\
    \ > 0 else {\n        return 0\n    }\n\n    let gridSize = grid.count\n    guard\
    \ gridSize > 1 else {\n        return 0\n    }\n    guard gridSize.count == grid[0][0].count\
    \ else {\n        return 0\n    }\n\n    var ans = 0\n    var minCapacity = Int((gridSize.max())/2)\n\
    \n    for row in 0..<gridSize {\n        for col in 0..<gridSize-1 {\n       \
    \     if grid[row][col] == 1 {\n                if capacity > minCapacity {\n\
    \                    capacity -= minCapacity\n                } else {\n     \
    \               capacity = minCapacity\n                }\n\n                ans\
    \ += 1\n                minCapacity -= capacity\n            }\n        }\n  \
    \  }\n\n    return ans", "    var total = 0\n    for row in grid {\n        for\
    \ cell in row {\n            if cell != 0 {\n                total += capacity\
    \ - cell\n            } else {\n                total += cell\n            }\n\
    \        }\n    }\n    return total", "    return max(0, grid[0].map{ b, _ in\n\
    \        b\n    }.reduce(0, +, capacity))", '    return max(grid).lastIndex',
  "    \n    guard capacity > 0 else { return 0 }\n    \n    var sum = 0\n    var\
    \ numOfWells = capacity\n    \n    for row in grid {\n        for col in row {\n\
    \            if col == 0 {\n                numOfWells -= col\n              \
    \  sum += numOfWells\n            }\n        }\n    }\n    return sum", "    var\
    \ result = 0\n    for _ in grid[0] {\n        result += 1\n        if result >\
    \ capacity {\n            return result\n        }\n    }\n    for row in grid\
    \ {\n        result += 1\n        if result > capacity {\n            return result\n\
    \        }\n    }\n    return result", "    var ans = Int.max\n    for r in 0..<grid.length\
    \ {\n        var x = grid[r]\n        for c in 0..<x {\n            x -= c\n \
    \           ans = min(ans, capacity-x)\n        }\n    }\n    return ans", " \
    \   if capacity < 1 || capacity > 10 {\n        return -1\n    }\n    \n    var\
    \ counter = UInt64(0)\n    var current = [Int]()\n    for row in grid {\n    \
    \    current += row\n        counter += row.reduce(0, { $0 + $1})\n    }\n   \
    \ \n    while counter > capacity {\n        \n        for (i, _) in grid.enumerate()\
    \ {\n            if current[i] > 0 {\n                current[i] = 0\n       \
    \         counter -= current[i]\n            }\n        }\n    }\n    return counter",
  "    var counter = capacity - 1\n    var i = 0\n    var j = 0\n    while i < grid.length\
    \ && j == capacity {\n        counter--\n        if grid[i][j] == 1 {\n      \
    \      counter++\n        }\n        if counter == 0 {\n            counter =\
    \ capacity - 1\n        }\n        if counter == 0 {\n            counter = capacity\
    \ - 1\n        }\n        if counter == 0 {\n            counter = capacity -\
    \ 1\n        }\n        i++\n        j++\n    }\n    return counter", "    var\
    \ count = 0\n    var size = grid.count\n    if size == 0 {\n        return 0\n\
    \    }\n    if size == 1 {\n        return grid[0][0].capacity\n    }\n    if\
    \ capacity == 1 {\n        capacity = max(capacity, grid[0][0].capacity)\n   \
    \ }\n    var i : Int = 0\n    var j : Int = 0\n    var maxCapacity = capacity\
    \ // keep a copy of capacity for the initial loop\n    while i != size || j !=\
    \ size {\n        var bucket : Bucket = buckets[grid[i][j]]\n        bucket.empty()\n\
    \        if bucket.capacity < maxCapacity  {\n            bucket.capacity = maxCapacity\n\
    \            bucket.addCapacity(maxCapacity)\n        }\n        if bucket.capacity\
    \ == 0 {\n            buckets.delete(bucket.bucket)\n            count += 1\n\
    \        }\n        maxCapacity = capacity\n        i += 1\n        j += 1\n \
    \   }\n    return count", "    \n    var count = 0\n    \n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            count += min(grid[i][j],\
    \ capacity)\n        }\n    }\n    \n    return count", "    if capacity < 1 ||\
    \ capacity > 10 {\n        return 0\n    }\n\n    var max_flow = 0\n    var flow\
    \ = 0\n    for row in grid {\n        flow += row[0]\n        if flow > capacity\
    \ {\n            flow = capacity\n        }\n        for column in row[1:] {\n\
    \            flow -= column\n            if flow <= 0 {\n                flow\
    \ = 0\n            }\n        }\n        if flow > max_flow {\n            max_flow\
    \ = flow\n        }\n    }\n\n    return max_flow", "    var count = 0\n    for\
    \ _, bucket := range grid {\n        for i := 0; i < capacity; i++ {\n       \
    \     if bucket[i] == 1 {\n                bucket[i] += count\n            } else\
    \ {\n                bucket[i] = count\n            }\n            count += bucket[i]\n\
    \        }\n    }\n    return count", "    let maxSize = Int((10 * 10 + 1) * 2)\n\
    \    var count = 1\n\n    for _ in 1...maxSize {\n        for var i = 0; i < grid.count;\
    \ i++ {\n            var j = i\n\n            if let (bucket, bucketSize) = grid[j]\
    \ {\n                var emptyCount = 0\n\n                for _ in 0...bucketSize\
    \ {\n                    if bucket {\n                        emptyCount += 1\n\
    \                    }\n\n                    j += 1\n                    if j\
    \ >= grid.count {\n                        j -= grid.count\n                 \
    \   }\n                }\n\n                if emptyCount > capacity {\n     \
    \               count -= 1\n                }\n            }\n        }\n    }\n\
    \n    return count", "    guard grid.count == 2 else {\n        return -1\n  \
    \  }\n    let width = grid[0]\n    guard width.count == 2 else {\n        return\
    \ -1\n    }\n    \n    guard width[0] > 0 else {\n        return -1\n    }\n \
    \   \n    guard width[1] >= capacity else {\n        return -1\n    }\n    \n\
    \    var numBuckets = 0\n    var currentBucket = width[0]\n    \n    let stack\
    \ = Stack<Int>()\n    \n    for i in 0..<height(grid[0]) {\n        stack.push(capacity)\n\
    \    }\n    \n    for _ in 0..<height(grid[0]) {\n        for _ in 0..<width(grid[0])\
    \ {\n            if grid[0][i]==1 {\n                numBuckets++\n          \
    \      if stack.count >= capacity {\n                    currentBucket = stack.pop()\n\
    \                }\n                grid[0][i] = 0\n                stack.push(currentBucket)\n\
    \            }\n        }\n    }\n    \n    return numBuckets", "    var max =\
    \ 0\n    for row in grid {\n        var maxCount = 0\n        for row in 0..<row.length\
    \ {\n            var count = 0\n            for col in 0..<row[row].length {\n\
    \                if row[row][col] == 1 {\n                    count++\n      \
    \          }\n            }\n            if maxCount < count {\n             \
    \   maxCount = count\n                max = 1\n            }\n        }\n    }\n\
    \    return max", "    if grid[grid[0].length-1].last < capacity {\n        return\
    \ 0\n    }\n    var max_wells = 0\n    for i in 0..<grid[0].length-1 {\n     \
    \   let start = grid[i]\n        let well = grid[i+1]\n        if well.last <\
    \ start.last {\n            return max_wells\n        }\n        let well_capacity\
    \ = well.last - start.last\n        let bucket_capacity = capacity - well_capacity\n\
    \        if bucket_capacity == 0 {\n            return max_wells\n        }\n\
    \        var need_lower = bucket_capacity\n        let max_bucket_size = well_capacity\n\
    \        let min_bucket_size = bucket_capacity / well_capacity\n        for j\
    \ in 0..<well.last-1 {\n            if well.first+j < start.first {\n        \
    \        need_lower -= min_bucket_size\n            } else {\n               \
    \ break\n            }\n        }\n        need_lower -= max_bucket_size\n   \
    \     if need_lower == 0 {\n            max_wells += 1\n        }\n    }\n   \
    \ return max_wells", "    \n    func min(_ x: Int, _ y: Int) -> Int {\n      \
    \  if x < y { return x }\n        else { return y }\n    }\n    \n    \n    func\
    \ dfs(_ pos: Int, _ x: Int, _ y: Int, _ capacity: Int, _ cnt: Int) -> Int {\n\
    \        if x > x {\n            if grid[x][y] == 1 {\n                cnt +=\
    \ 1\n                dfs(pos + 1, x, y, capacity, cnt)\n            }\n      \
    \      return cnt\n        }\n        if y > y {\n            if grid[x][y] ==\
    \ 1 {\n                cnt += 1\n                dfs(pos, x, y, capacity, cnt)\n\
    \            }\n            return cnt\n        }\n        if capacity == 0 {\n\
    \            return 0\n        }\n        \n        \n        \n        let (min,\
    \ max) = (min(y, pos), max(y, pos))\n        \n        if grid[x][y] == 1 {\n\
    \            cnt += 1\n            dfs(pos + 1, x, y, capacity - grid[x][y], cnt)\n\
    \        }\n        \n        if grid[min][max] == 1 {\n            cnt += 1\n\
    \            dfs(pos + 1, min, max, capacity - grid[min][max], cnt)\n        }\n\
    \        \n        if grid[min][max] == 1 {\n            cnt += 1\n          \
    \  dfs(pos, min, max, capacity - grid[min][max], cnt)\n        }\n        \n \
    \       return cnt\n    }\n    \n    \n    \n    \n    return dfs(0, 0, 0, capacity,\
    \ 0)", "  var max = 0\n  for row in grid {\n    var max_row = row.map { $0 }\n\
    \    for i in 0..<row.count {\n      if let next = max_row[i], next > max {\n\
    \        max = next\n      }\n    }\n  }\n  return max - capacity", "    if capacity\
    \ < 1 || capacity > 10 {\n        return 0\n    }\n    \n    var buckets = [Int](capacity)\n\
    \    \n    for _ in 0 ..< capacity {\n        buckets.append(0)\n    }\n    \n\
    \    for row in grid {\n        for col in row {\n            if col == 0 {\n\
    \                buckets[col - 1] -= 1\n            }\n        }\n    }\n    \n\
    \    for _ in 0 ..< capacity {\n        if buckets[_] == 0 {\n            return\
    \ _ \n        }\n    }\n    \n    return 0", "    precondition(grid.count == 0,\
    \ \"grid must be a 2d array\")\n    precondition(\n        capacity <= 10, \"\
    capacity must be less than or equal to 10\")\n    precondition(\n        grid.indices.count\
    \ == grid.count, \"all indices must be unique\")\n    precondition(\n        capacity\
    \ >= grid.indices.count, \"capacity must be at least as large as the number of\
    \ unique indices\")\n    \n    var result = 0\n    \n    for j in 0..<grid.indices.count\
    \ {\n        let maxBucket = grid[j][capacity]\n        for i in 0..<grid[j].count\
    \ {\n            if grid[j][i] == 1 {\n                grid[j][i] = 0\n      \
    \          result += maxBucket - grid[j][i]\n                maxBucket -= 1\n\
    \            }\n            if maxBucket == 0 {\n                break\n     \
    \       }\n        }\n    }\n    return result", "    var total = 0\n    var used\
    \ = 0\n    for row in grid {\n        var left = 1\n        for _ in row {\n \
    \           if left <= capacity {\n                total += left\n           \
    \     used += left\n            }\n            left *= capacity\n        }\n \
    \   }\n    return total-used", "    if grid.length <= 1 || capacity%1 != 0 {\n\
    \        return 0\n    }\n    var count = 0\n    var total = 0\n    for row in\
    \ grid.reversed() {\n        for bucket in row.indices {\n            total +=\
    \ grid[bucket][row[1]]\n            count += bucket/capacity > 0 ? bucket/capacity\
    \ : 0\n        }\n    }\n    return total - count", "\treturn (grid as NSArray).max({\n\
    \t\t$0.count > $1.count || ($0.count == $1.count && $0[$0.startIndex..<$0.startIndex+$1.count]\
    \ == $1[$0.startIndex..<$0.startIndex+$1.count])\n\t})", "    guard 0 < capacity\
    \ && capacity <= 10 else { return 0 }\n    \n    // initialize result\n    var\
    \ result = 0\n    \n    // calculate number of wells\n    let wellCount = grid.count\n\
    \    \n    // calculate buckets for each well\n    var buckets = [Int](repeating:\
    \ capacity, count: wellCount)\n    for idx in 0..<wellCount {\n        let bucket\
    \ = buckets[idx]\n        buckets[idx] = bucket\n        if bucket > 0 && grid[idx].count\
    \ == 0 {\n            buckets[idx] = -bucket\n        }\n    }\n    \n    // calculate\
    \ remaining buckets\n    for idx in 0..<wellCount {\n        if buckets[idx] >\
    \ 0 {\n            buckets[idx] -= 1\n        } else {\n            buckets[idx]\
    \ = 0\n        }\n    }\n    \n    // fill remaining buckets\n    for idx in 0..<wellCount\
    \ {\n        let bucket = buckets[idx]\n        if bucket > 0 {\n            buckets[idx]\
    \ = bucket\n        } else {\n            buckets[idx] = 0\n        }\n    }\n\
    \    \n    // remove empty buckets\n    for idx in 0..<wellCount {\n        if\
    \ buckets[idx] == 0 {\n            buckets[idx] = capacity\n            result\
    \ += 1\n        }\n    }\n    \n    return result", "    var rowCount = 0\n  \
    \  for row in grid {\n        var maxCount = 0\n        for cell in row {\n  \
    \          if cell == 1 {\n                if maxCount > capacity {\n        \
    \            return maxCount\n                }\n                maxCount++\n\
    \            } else {\n                maxCount = 1\n            }\n        }\n\
    \        rowCount++\n    }\n    return rowCount", "    \n    return maxCount(grid,\
    \ capacity)", "    if capacity == 1 {\n        return grid[0].count\n    }\n \
    \   \n    var count = 0\n    var minVal = grid[0].count\n    \n    var lastRow\
    \ = grid[0]\n    \n    for i in 1..<grid.count {\n        if lastRow.count < capacity\
    \ {\n            lastRow.append(0)\n        }\n        lastRow = grid[i]\n   \
    \     \n        if lastRow.count <= capacity {\n            if minVal == 0 ||\
    \ lastRow.count == 0 {\n                minVal = 0\n            } else {\n   \
    \             if lastRow.count < minVal {\n                    minVal = lastRow.count\n\
    \                }\n            }\n            \n            lastRow.count = 0\n\
    \            count++\n        }\n    }\n    return count", "    if capacity ==\
    \ 0 {\n        return 0\n    }\n\n    // sort buckets by length\n    var buckets\
    \ = make([][Bucket], len(grid))\n    for _, bucket := range buckets {\n      \
    \  sort.Sort(byLength(bucket))\n    }\n\n    for rowIdx, row := range grid {\n\
    \        for _, bucket := range buckets {\n            // find bucket for current\
    \ row\n            if bucket.capacity >= capacity-rowIdx {\n                bucket.count\
    \ += rowIdx + 1\n                bucket.capacity -= rowIdx + 1\n             \
    \   break\n            }\n        }\n    }\n\n    return buckets[0][0].count",
  "    guard isSorted(grid) else {\n        return -1\n    }\n    \n    // count how\
    \ many times we need to lower the buckets\n    var count = 0\n    \n    // count\
    \ how many times to increase bucket size\n    var curCap = capacity\n    while\
    \ curCap > 1 {\n        let newLen = grid[grid.count-1].count\n        \n    \
    \    // if we have enough water for the current bucket size\n        if curCap\
    \ >= newLen {\n            count += curCap - newLen\n            curCap -= newLen\n\
    \            continue\n        }\n        \n        // if current bucket size\
    \ doesn't have enough water,\n        // we need to make a new bucket size to\
    \ handle this well\n        count += 1\n        \n        // add enough water\
    \ to new bucket size\n        curCap = curCap * 2\n    }\n    \n    return count",
  "\tnumWells, numBuckets := len(grid[0]), len(grid) - 1\n\tresult := 0\n\t\n\tswitch\
    \ numBuckets {\n\tcase 0: return 0\n\tcase 1: return grid[0][capacity]\n\tcase\
    \ 2: return max(grid[0][1], grid[1][capacity])\n\tdefault: return grid[0][capacity]\n\
    \t}\n\t\n\tfor i := 0; i < numWells-1; i++ {\n\t\tgrid[i][capacity] = grid[i+1][capacity]\n\
    \t\tgrid[i+1][capacity] = 0\n\t}\n\tgrid[numWells-1][capacity] = grid[numWells][0]\n\
    \tgrid[numWells][capacity] = 0\n\t\n\tfor i := 0; i < numWells-1; i++ {\n\t\t\
    result += grid[i+1][capacity] - grid[i][capacity]\n\t}\n\t\n\treturn result",
  "    guard 1 <= grid.length <= 10_000_000, grid[0].count == 1 else {\n        return\
    \ -1\n    }\n    guard 1 <= grid[0].length else {\n        return -1\n    }\n\
    \    var buckets = [0] * (capacity+1)\n    for i in 1...grid.length {\n      \
    \  for j in 1...grid[0].length {\n            if grid[i][j] == 1 {\n         \
    \       buckets[grid[i][j]] += i\n            }\n        }\n    }\n    return\
    \ buckets.filter({ $0 == 0 }).count() + 1", "    var max = 0\n    for row in 0..<grid.length\
    \ {\n        for col in 0..<grid[0].length {\n            if grid[row][col] ==\
    \ 1 {\n                if capacit\xE9 <= 0 {\n                    return 0\n \
    \               }\n                grid[row][col] = 0\n                max +=\
    \ 1\n                capacit\xE9 -= 1 // if we had 0 water left in the last row,\
    \ we should lower the next row\n            }\n        }\n    }\n    return max",
  "    if grid.count == 0 || grid.count != grid.max() {\n        return 0\n    }\n\
    \    var max = 0 \n    for i in 0..<grid.max(){\n        let bucket = grid[i]\n\
    \        for j in 0..<bucket.max(){\n            if bucket[j] == 1 {\n       \
    \         max += capacity\n            }\n        }\n    }\n    return max", " \
    \   guard grid.count >= 2 else {\n        return Int64(0)\n    }\n    var min\
    \ = grid[0][0].max() // the min of first row is 1\n    for row in 0..<grid.count\
    \ {\n        for col in 0..<grid[row].count {\n            let cur = grid[row][col]\n\
    \            if cur != 0 {\n                if capacity == 1 {\n             \
    \       return Int64(1)\n                }\n                if capacity == 2 {\n\
    \                    // If capacity is 2, if there is no wall on first row and\
    \ second row\n                    // Then we just return capacity of current bucket\n\
    \                    if row == 0 && col == grid[row].count - 1 && cur == 1 {\n\
    \                        return Int64(capacity)\n                    }\n     \
    \               if row == 1 && col == grid[row].count - 1 && cur == 0 {\n    \
    \                    return Int64(capacity)\n                    }\n         \
    \           return Int64(capacity) // If capacity is 2, if there is no wall on\
    \ first row and second row\n                }\n                if capacity > cur\
    \ {\n                    if capacity > min {\n                        min = capacity\n\
    \                    }\n                } else {\n                    if capacity\
    \ > min {\n                        min = capacity\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return min", '    return
    maxF(grid, capacity)', "    if grid == nil || grid.isEmpty() {\n        return\
    \ 0\n    }\n\n    // If there are more buckets than the capacity of the buckets\n\
    \    // then return the current number of buckets\n    // If not, then subtract\
    \ the current number of buckets from the capacity\n    var numberOfBuckets = capacity.downToCapacity()\n\
    \    var numberOfWater = capacity.timesToZero()\n\n    for i in 0 ..< grid.count\
    \ {\n        for j in 0 ..< grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                numberOfWater = numberOfWater - 1\n                numberOfBuckets\
    \ = numberOfBuckets - 1\n            }\n        }\n    }\n\n    if numberOfBuckets\
    \ == 0 {\n        return 0\n    }\n\n    return numberOfBuckets - numberOfWater",
  '    return best_fit(grid, capacity).f', "    let maxWellsCount = Int(grid.count)\n\
    \    \n    // We need at most maxWellsCount wells to empty all wells\n    for\
    \ i in 0..<maxWellsCount {\n        guard grid[i][0] == 0 || grid[i][0] == 1 else\
    \ {\n            return maxWellsCount\n        }\n    }\n    \n    var numZeros:\
    \ Int = 0\n    var numOnes: Int = 0\n    for i in 0..<maxWellsCount {\n      \
    \  guard grid[i][0] == 0 || grid[i][0] == 1 else {\n            return maxWellsCount\n\
    \        }\n        if grid[i][0] == 0 {\n            numZeros += 1\n        }\
    \ else {\n            numOnes += 1\n        }\n    }\n    \n    // We have at\
    \ least 2 zeros numZeros + numOnes\n    if numZeros < 2 {\n        return maxWellsCount\n\
    \    }\n    \n    var currentCount: Int = 0\n    var currentBucket: Int = 0\n\
    \    \n    for i in 0..<maxWellsCount {\n        if currentCount == capacity {\n\
    \            break\n        }\n        if currentCount == 0 {\n            if\
    \ grid[i][0] == 0 {\n                currentCount += 1\n            } else {\n\
    \                currentCount -= 1\n            }\n        } else {\n        \
    \    if grid[i][0] == 0 {\n                currentCount += 1\n            } else\
    \ {\n                currentCount -= 1\n            }\n        }\n        if currentCount\
    \ == 0 {\n            currentBucket = i // i is bucket index\n        }\n    }\n\
    \    \n    \n    \n    \n    var numNeeded = capacity - currentCount\n    while\
    \ numNeeded > 0 && numNeeded < capacity {\n        if currentBucket == 0 {\n \
    \           numNeeded += maxWellsCount\n        } else {\n            numNeeded\
    \ += numOnes\n        }\n        \n        for i in 0..<maxWellsCount {\n    \
    \        if currentBucket == i {\n                numNeeded += 1\n           \
    \ }\n        }\n    }\n    \n    return numNeeded", "    \n    var result = 0\n\
    \    \n    for rowIndex in 0..<grid.count {\n        let rowMax = grid[rowIndex][0]\n\
    \        for colIndex in 1...row.count {\n            let leftBucket = grid[rowIndex][colIndex]\n\
    \            if leftBucket == 0 {\n                continue\n            }\n \
    \           \n            let rightBucket = grid[rowIndex][colIndex - 1]\n   \
    \         if rightBucket == 0 {\n                continue\n            }\n   \
    \         \n            if leftBucket > rightBucket {\n                result\
    \ += leftBucket - rightBucket\n            } else {\n                result +=\
    \ capacity\n            }\n        }\n    }\n    \n    return result", "  guard\
    \ grid.isEmpty == false else {\n    return 0\n  }\n  let row: Int = 0\n  var buckets:\
    \ [Int] = []\n  while row < grid.count {\n    buckets.append(0)\n    row += 1\n\
    \  }\n  var max = 0\n  var index = 0\n  for row in 0..<grid.count {\n    for col\
    \ in 0..<grid[row].count {\n      buckets[index] = min(buckets[index], grid[row][col])\n\
    \      max += buckets[index]\n      if max > capacity {\n        max -= buckets[index]\n\
    \        buckets[index] = 0\n      }\n      index += 1\n    }\n  }\n  return max",
  "    \n    // Create a hashmap to store each bucket's water count\n    var buckets\
    \ = make(map[int]int) \n    \n    // Traverse the grid to calculate the total\
    \ water count\n    var totalWater : Int = capacity\n    for row in grid {\n  \
    \      var water = 0\n        for bucket in row {\n            water += bucket\n\
    \            if bucket == 0 {\n                buckets[bucket] += 1\n        \
    \    }\n        }\n        totalWater -= water\n    }\n    \n    // If the total\
    \ water count is less than the capacity, we can just return the bucket count without\
    \ doing any fill\n    if totalWater <= capacity {\n        for bucket in buckets\
    \ {\n            buckets[bucket] += totalWater\n        }\n        return len(buckets)\n\
    \    }\n    \n    // If there are multiple possibilities, we have to find the\
    \ most water filling each bucket\n    // 1. Find the bucket with the max water\
    \ count in total water count\n    // 2. Find the bucket with the min water count\
    \ in total water count\n    var maxBucket = capacity\n    var minBucket = capacity\n\
    \    for bucket in buckets {\n        if buckets[bucket] > maxBucket {\n     \
    \       maxBucket = bucket\n        }\n        if buckets[bucket] < minBucket\
    \ {\n            minBucket = bucket\n        }\n    }\n    \n    // 3. Find the\
    \ bucket with the min water count in total water count and subtract 1 from the\
    \ bucket count\n    var minBucketBuckets = make(map[int]int)\n    var maxBucketBuckets\
    \ = make(map[int]int)\n    for bucket in buckets {\n        if bucket == maxBucket\
    \ {\n            maxBucketBuckets[bucket] += 1\n        }\n        if bucket ==\
    \ minBucket {\n            minBucketBuckets[bucket] -= 1\n        }\n    }\n \
    \   \n    // 4. Calculate the total water count for each bucket based on the bucket\
    \ count\n    var maxBucketWater : Int = maxBucketBuckets[capacity]\n    var minBucketWater\
    \ : Int = minBucketBuckets[capacity]\n    for bucket in buckets {\n        if\
    \ bucket == maxBucket {\n            maxBucketWater += maxBucketBuckets[bucket]\n\
    \        }\n        if bucket == minBucket {\n            minBucketWater -= minBucketBuckets[bucket]\n\
    \        }\n    }\n    \n    // 5. Return the least water filling bucket\n   \
    \ if maxBucketWater == minBucketWater {\n        return minBucket\n    }\n   \
    \ if maxBucketWater < minBucketWater {\n        return maxBucket\n    } else {\n\
    \        return minBucket\n    }", "    // write your code here\n    if grid.length\
    \ == 0 {\n        return 0\n    }\n    if grid[0].length == 0 {\n        return\
    \ 0\n    }\n\n    var max = 0\n    for _row in 0..<grid.length {\n        for\
    \ _col in 0..<grid[0].length {\n            if grid[_row][_col] == 1 {\n     \
    \           max += 1\n            }\n            if _row == grid[0].length - 1\
    \ && _col == grid.length - 1 {\n                break\n            }\n       \
    \ }\n    }\n    return max", "    var result = 0\n    \n    for row in grid {\n\
    \        let bucket = capacity\n        for row in row {\n            if row >\
    \ bucket {\n                bucket = row\n            }\n        }\n        result\
    \ += bucket\n    }\n    \n    return result", "    let n = grid.count\n    if\
    \ n == 0 {\n        return 0\n    }\n\n    if n == 1 {\n        return grid[0][0].count\n\
    \    }\n\n    if capacity == 0 {\n        return n\n    }\n\n    let bucketCapacity\
    \ = capacity\n\n    // Find bucket with lowest capacity.\n    var minBucket =\
    \ 0\n    var minBucketCapacity = IntMax\n\n    for i in 0..<n {\n        for j\
    \ in 0..<n {\n            if grid[i][j].count > minBucketCapacity {\n        \
    \        minBucket = j\n                minBucketCapacity = grid[i][j].count\n\
    \            }\n        }\n    }\n\n    // Lower bucket.\n    grid[minBucket][minBucketCapacity].count\
    \ = 0\n\n    // Find next bucket.\n    var minBucketNext = minBucket\n    var\
    \ minBucketNextCapacity = IntMax\n    \n    for i in minBucket..<n {\n       \
    \ for j in 0..<n {\n            if grid[i][j].count > minBucketNextCapacity {\n\
    \                minBucketNext = j\n                minBucketNextCapacity = grid[i][j].count\n\
    \            }\n        }\n    }\n\n    // Increment buckets.\n    for i in minBucket..<n\
    \ {\n        grid[i][minBucketNextCapacity].count -= 1\n        grid[i][minBucket].count\
    \ += 1\n    }\n\n    // Find next bucket.\n    var minBucketNext = minBucket\n\
    \    var minBucketNextCapacity = IntMax\n\n    for i in minBucketNext..<n {\n\
    \        for j in minBucketNext..<n {\n            if grid[i][j].count > minBucketNextCapacity\
    \ {\n                minBucketNext = j\n                minBucketNextCapacity\
    \ = grid[i][j].count\n            }\n        }\n    }\n\n    // Increment buckets.\n\
    \    for i in minBucketNext..<n {\n        grid[i][minBucketNextCapacity].count\
    \ -= 1\n        grid[i][minBucket].count += 1\n    }\n\n    return max_fill(grid:\
    \ grid, capacity: bucketCapacity)", "    \n    let rows = grid.count\n    if rows\
    \ == 0 {\n        return 0\n    }\n\n    let cols = grid[0].count\n    guard cols\
    \ == capacity else {\n        return -1\n    }\n\n    let zeros = [Int](repeating:\
    \ 0, count: capacity)\n    var numOfEmptyWells = Int()\n    var currBucket = 0\n\
    \    var currMaxBucket = 0\n\n    for _ in 0..<rows {\n        for _ in 0..<capacity\
    \ {\n            currBucket = grid[currMaxBucket][currBucket]\n            numOfEmptyWells\
    \ = numOfEmptyWells + currBucket\n            currBucket = currBucket - onesCount[currBucket]\n\
    \            if currBucket <= 0 {\n                numOfEmptyWells = numOfEmptyWells\
    \ - currBucket\n                currBucket = 0\n            }\n            currMaxBucket\
    \ = currMaxBucket + onesCount[currMaxBucket]\n        }\n    }\n\n    return numOfEmptyWells",
  "    if capacity.isGreaterThanOrEqualTo(0) {\n        return 0\n    }\n    \n  \
    \  guard grid.count > 0 else { return 0 }\n    \n    let rowCount = grid[0].count\n\
    \    \n    var maxCount = 0\n    \n    for _ in 0 ..< rowCount {\n        var\
    \ cur = 0\n        for _ in 0 ..< rowCount {\n            cur = max(cur, buckets[grid[0][_]]\
    \ + 1)\n        }\n        maxCount = max(maxCount, cur)\n    }\n    \n    return\
    \ maxCount", "    guard grid.count == 1 || grid.count == grid[0].count else {\n\
    \        return -1\n    }\n    \n    let width = grid[0].count\n    \n    guard\
    \ capacity >= 1 && capacity <= width else {\n        return 0\n    }\n    \n \
    \   var res = -1\n    for i in  0 ..< grid[0].count {\n        var max = 0\n \
    \       for j in  0 ..< grid[0].count {\n            if grid[i][j] == 1 {\n  \
    \              if j > max {\n                    max = j\n                }\n\
    \            }\n        }\n        \n        if max > res {\n            res =\
    \ max\n        }\n    }\n    return res", "    guard \n        let w = grid.count(),\n\
    \        let c = grid.first?.count(),\n        capacity > c,\n        capacity\
    \ > w else {\n        return -1\n    }\n\n    // The first column of every bucket\
    \ is set to zero\n    var b = [Int](repeating: 0, count: c)\n    for i in 0..<w\
    \ {\n        b[grid[i][0]] = capacity\n    }\n\n    // The first row of every\
    \ bucket is set to zero\n    var b2 = [Int](repeating: 0, count: w)\n    for i\
    \ in 0..<c {\n        b2[grid[0][i]] = capacity\n    }\n\n    // fill the first\
    \ column\n    for j in 1..<c {\n        for i in 0..<w {\n            b[grid[i][j]]\
    \ += capacity\n        }\n    }\n\n    // fill the first row\n    for j in 1..<w\
    \ {\n        for i in 0..<c {\n            b2[grid[0][j]] += capacity\n      \
    \  }\n    }\n\n    // if two buckets have the same capacity, \n    // the min\
    \ of the two will be used\n    // otherwise, the max capacity will be used\n \
    \   let max = 0\n    for i in 0..<c {\n        for j in 0..<w {\n            max\
    \ = max > b[grid[i][j]] ? max : b[grid[i][j]]\n            max = max > b2[grid[0][j]]\
    \ ? max : b2[grid[0][j]]\n        }\n    }\n\n    return max", "    var maxCount\
    \ = 0\n    for well in grid.reversed() {\n        let minCapacity = well.min(by:\
    \ { $0 < capacity })\n        if minCapacity != capacity {\n            capacity\
    \ = minCapacity\n        }\n        guard capacity >= 0 && well.reduce(0) { $0\
    \ + $1 } == capacity else { return maxCount }\n        guard capacity <= 10 else\
    \ { return maxCount }\n        maxCount = well.reduce(0) { $0 + maxCount($1, capacity)\
    \ }\n    }\n    return maxCount", "\t\n\tlet rows = grid.count\n\t\n\t// Create\
    \ an empty array\n\tlet result = Array(repeating: 0, count: rows * rows)\n\t\n\
    \t// Fill the empty array with the maximum of each row\n\tfor row in 0..<rows\
    \ {\n\t\tfor col in 0..<cols {\n\t\t\tlet maximum = max(grid[row][col], capacity)\n\
    \t\t\tresult[row * rows + col] = maximum\n\t\t}\n\t}\n\t\n\t// Return the number\
    \ of times you needed to lower the bucket to empty\n\treturn result.maxElement()",
  "    guard capacity <= 10 else {\n        return 0\n    }\n    \n    var count =\
    \ 1\n    var minBucket = 0\n    \n    for i in 0..<grid.count {\n        var count\
    \ = 0\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count++\n            }\n        }\n        \n        if count\
    \ == capacity {\n            if minBucket > count {\n                minBucket\
    \ = count\n            }\n        }\n    }\n    \n    return minBucket", "   \
    \ guard grid.count >= 1 else {\n        return 0\n    }\n    var res = 0\n   \
    \ let width = grid[0].length\n    for i in 0..<width {\n        var j = i\n  \
    \      while j >= 0 {\n            res += grid[j][i]\n            j--\n      \
    \  }\n        while j < width {\n            res -= grid[j][i]\n            j++\n\
    \        }\n    }\n    var i = 0\n    for r in grid {\n        i += 1\n      \
    \  while i < width {\n            res--\n            i++\n        }\n        while\
    \ i >= 0 {\n            res++\n            i--\n        }\n    }\n    res /= capacity\n\
    \    return res", "    var count = 0\n\n    for i := 1; i < len(grid); i++ {\n\
    \        var bucket = 0\n\n        for j := 0; j < grid[i].length; j++ {\n   \
    \         if grid[i][j] == 1 {\n                bucket += 1\n            }\n\n\
    \            if bucket > capacity {\n                count = 0\n             \
    \   break\n            }\n        }\n\n        if bucket > capacity {\n      \
    \      count = 0\n        } else {\n            count += 1\n        }\n    }\n\
    \n    return count", "  var buckets = make([][]int, capacity)\n  for _, bucket\
    \ := range buckets {\n    bucket[0] = 0\n  }\n  for _, well := range grid {\n\
    \    buckets[well[0]][well[1]] = buckets[well[0]][well[1]] + 1\n  }\n  return\
    \ sumRows(buckets)", "    if grid.isEmpty() {\n        return 0\n    }\n\n   \
    \ // the max length of each bucket is calculated by finding the max length of\n\
    \    // all rows, and multiplying them by capacity to give the max length of each\
    \ bucket\n    let maxLength = grid[0].map { _ in maxOf(&grid[0], capacity).1 }.reduce(maxOf)\n\
    \n    // the buckets are initialized with capacity units of water\n    let buckets\
    \ = [Int](repeating: capacity, count: maxLength)\n\n    // the number of times\
    \ you need to lower the buckets is initialized with 0\n    var i = 0\n    while\
    \ i < maxLength {\n        // the index of the bucket that the well belongs to\
    \ is calculated by\n        // multiplying the row index of the well by the capacity\
    \ of the bucket\n        let index = Int((i - 1) * capacity) + buckets[i - 1]\n\
    \n        // the water can not be extracted from this bucket\n        buckets[index]\
    \ = 0\n        if buckets.isEmpty {\n            // this means that no water can\
    \ be extracted from this bucket, so\n            // the max number of times is\
    \ incremented\n            i += 1\n        } else {\n            // the bucket\
    \ is now empty because there is water that can be extracted\n            // from\
    \ this bucket and the next well can be extracted\n            buckets[index] =\
    \ capacity\n        }\n    }\n\n    // return the max number of times you need\
    \ to lower the buckets\n    return i", "    guard grid.indices.count == grid.count\
    \ && grid.count > 0 && capacity > 0 else { return 0 }\n    var answer = 0\n  \
    \  var result = 0\n    var buckets = [Int](capacity)\n    buckets[0] = 1\n   \
    \ for i in 1...capacity {\n        buckets[i] = 0\n    }\n    for i in 0..<grid.indices.count\
    \ {\n        buckets[grid[i][0]] += 1\n        buckets[grid[i][grid.indices.count-1]]\
    \ += 1\n    }\n    for i in 0..<capacity {\n        if buckets[i] < grid.indices.count\
    \ {\n            answer += max_fill(grid[buckets[i]..<grid.indices.count], capacity)\n\
    \        }\n    }\n    return result", "    guard grid.count == 3 else {\n   \
    \     return 0\n    }\n    guard grid[0].length == grid[1].length else {\n   \
    \     return 0\n    }\n    guard grid[0].length == grid[2].length else {\n   \
    \     return 0\n    }\n    var count = 1\n    guard capacity > 0 else { return\
    \ 0 }\n    guard grid[0][0] == 0 && grid[1][0] == 0 && grid[2][0] == 0 else {\n\
    \        return 0\n    }\n    guard grid[0][1] == 0 && grid[1][1] == 0 && grid[2][1]\
    \ == 0 else {\n        return 0\n    }\n    guard grid[0][2] == 0 && grid[1][2]\
    \ == 0 && grid[2][2] == 0 else {\n        return 0\n    }\n    guard capacity\
    \ > grid[0][0], capacity > grid[0][1], capacity > grid[0][2] else {\n        return\
    \ 0\n    }\n    guard capacity > grid[1][0], capacity > grid[1][1], capacity >\
    \ grid[1][2] else {\n        return 0\n    }\n    guard capacity > grid[2][0],\
    \ capacity > grid[2][1], capacity > grid[2][2] else {\n        return 0\n    }\n\
    \    for row in 0..<grid.count {\n        if capacity > grid[row][0] {\n     \
    \       grid[row][0] -= capacity\n            count += 1\n        }\n        if\
    \ capacity > grid[row][1] {\n            grid[row][1] -= capacity\n          \
    \  count += 1\n        }\n        if capacity > grid[row][2] {\n            grid[row][2]\
    \ -= capacity\n            count += 1\n        }\n    }\n    return count", " \
    \   if grid == nil || grid.isEmpty() {\n        return 0\n    }\n    \n    var\
    \ result = 0\n    \n    for _ in 1...capacity {\n        var newBucket : Bucket\
    \ = [Int](capacity)\n        var newCells : [Cell] = []\n        for pos in 0..<grid.count\
    \ {\n            if grid[pos][0] != 1 {\n                newCells.append(Cell(pos))\n\
    \            }\n        }\n        \n        for cell in newCells {\n        \
    \    if cell.bucket != nil {\n                newBucket = cell.bucket\n      \
    \          newCells.removeAll(cell)\n            }\n        }\n        \n    \
    \    var tempCells : [Cell] = []\n        for cell in newCells {\n           \
    \ if cell.bucket != nil {\n                tempCells.append(cell)\n          \
    \  }\n        }\n        \n        for cell in tempCells {\n            if newBucket.empty()\
    \ {\n                newBucket.use(cell)\n            } else {\n             \
    \   newBucket.low(cell)\n            }\n        }\n        \n        if newBucket.empty()\
    \ {\n            result += 1\n        }\n    }\n    \n    return result", "  \
    \  var max = 0\n    for row in grid {\n        if row[0] > max {\n           \
    \ max = row[0]\n        }\n    }\n    for row in grid {\n        for idx in 1..capacity\
    \ {\n            switch row[idx] {\n            case 0: row[idx] = 1\n       \
    \         break\n            case 1: row[idx] = 0\n                break\n   \
    \         }\n        }\n    }\n    return max", "    if capacity == 0 {\n    \
    \    return 0\n    }\n    var ans = -1\n    for rowIndex in 0..<grid.length {\n\
    \        for colIndex in 0..<grid[rowIndex].length {\n            if grid[rowIndex][colIndex]\
    \ != 0 {\n                let rowBucket = grid[rowIndex][colIndex] + capacity\
    \ - grid[rowIndex][colIndex]\n                if rowBucket < 0 {\n           \
    \         return ans // early exit\n                }\n                ans = max(ans,\
    \ rowBucket)\n            }\n        }\n    }\n    return ans", "\t\n\tlet rowCount\
    \ = grid.count\n\tlet colCount = grid[0].count\n\t\n\tlet minCap = capacity\n\t\
    \n\t// Find lowest capacity bucket with more than one cell\n\tfor row in 0..<rowCount\
    \ {\n\t\tfor col in 0..<colCount {\n\t\t\tlet c = grid[row][col]\n\t\t\tif c >\
    \ 0 && c < minCap {\n\t\t\t\tminCap = c\n\t\t\t}\n\t\t}\n\t}\n\t\n\tminCap = minCap\
    \ / 2\n\t\n\t// Find cells with less capacity than lowest bucket\n\tvar count:\
    \ Int = 0\n\t\n\tfor row in 0..<rowCount {\n\t\tfor col in 0..<colCount {\n\t\t\
    \tif grid[row][col] <= minCap {\n\t\t\t\tcount += 1\n\t\t\t}\n\t\t}\n\t}\n\t\n\
    \treturn count", "    if grid.count == 0 {\n        return 0\n    }\n    \n  \
    \  let (m, n) = grid[0].count\n    \n    var count = 0\n    var minBucket = capacity\n\
    \    var maxBucket = 0\n    \n    for i in 0..<m {\n        for j in 0..<n {\n\
    \            \n            // Check if we can put this well into the bucket\n\
    \            if grid[i][j] == 1 {\n                \n                if capacity\
    \ < maxBucket {\n                    maxBucket = capacity\n                }\n\
    \                \n                capacity -= 1\n            }\n            \n\
    \            // Check if we cannot put this well into the bucket\n           \
    \ else if capacity > minBucket {\n                \n                // Check if\
    \ bucket is full\n                if capacity == minBucket {\n               \
    \     count += minBucket - maxBucket\n                    maxBucket -= 1\n   \
    \             \n                // Check if bucket is empty\n                }\
    \ else {\n                    count += minBucket - capacity\n                \
    \    capacity += 1\n                }\n            }\n        }\n    }\n    \n\
    \    return count", "\tn := len(grid)\n\tbucket := make([][]int, n)\n\tfor i :=\
    \ 0; i < n; i++ {\n\t\tbucket[i] = make([]int, capacity)\n\t}\n\tx := 0\n\tfor\
    \ y := 0; y < n; y++ {\n\t\tfor x := 0; x < capacity; x++ {\n\t\t\tif grid[y][x]\
    \ == 1 {\n\t\t\t\tbucket[y][x] -= 1\n\t\t\t\tif bucket[y][x] < 0 {\n\t\t\t\t\t\
    bucket[y][x] = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor x := 0; x < capacity; x++\
    \ {\n\t\t\tif bucket[y][x] >= 0 {\n\t\t\t\tbucket[y][x] += 1\n\t\t\t}\n\t\t}\n\
    \t\tif x < capacity {\n\t\t\tx = capacity\n\t\t}\n\t}\n\treturn x", '    return
    max_fill(grid: grid, capacity: capacity, maxCapacity: capacity)', "    if capacity\
    \ < 1 {\n        return 0\n    }\n    if grid[0][0] == 0 {\n        return 0\n\
    \    }\n    \n    var max = 0\n    var nextWells = grid[0].filter { $0 == 1 }\n\
    \    var remainingWells = grid[0].filter { $0 == 0 }\n    var maxWells = grid[0]\n\
    \    \n    var buckets = [Int](repeating: 0, count: capacity)\n    \n    for i\
    \ in 1..capacity {\n        for j in 0..capacity {\n            let cur = buckets[j]\
    \ + nextWells[j]\n            if cur > max {\n                max = cur\n    \
    \            maxWells = grid[0]\n            } else {\n                maxWells[j]\
    \ = cur == max ? 1 : 0\n            }\n        }\n        \n        for j in 0..capacity\
    \ {\n            buckets[j] = 0\n        }\n        \n        maxWells = maxWells.filter\
    \ { $0 == 0 }\n        nextWells = nextWells.filter { $0 == 0 }\n        \n  \
    \      if maxWells.count >= capacity {\n            return max - grid[0].count\n\
    \        }\n    }\n    \n    return max - grid[0].count", "    if grid.count <=\
    \ 0 {\n        return 0\n    }\n    if capacity == 1 {\n        return grid.count\n\
    \    }\n    // O(1)\n    if capacity == 2 {\n        let rowSums = grid\n    \
    \    .map { [Int](0..<$0.count, 0) }\n        .reduce([Int](0..<$0.count), {$0\
    \ + $1})\n        return grid\n        .filter { (index, _) -> rowSums[index]\
    \ == 0 }\n        .count\n    }\n    \n    // O(n)\n    var rowSums = grid\n \
    \   .map { [Int](0..<$0.count, 0) }\n    .reduce([Int](0..<$0.count), {$0 + $1})\n\
    \    \n    // O(n)\n    for index in 0 ..< grid.count {\n        if rowSums[index]\
    \ > capacity {\n            rowSums[index]--\n        }\n    }\n    \n    // O(n)\n\
    \    return grid.filter { (index, _) -> rowSums[index] == 0 }\n    .count", " \
    \   var count = 0\n    var min = grid[0]\n    for _ in grid {\n        if min[1]\
    \ > 0 {\n            count += 1\n            min[1] = -min[1]\n        }\n   \
    \     else {\n            min[1] += min[0]\n            min[0] = min[0] > 0 ?\
    \ min[0] - 1 : 0\n        }\n        if min[1] < capacity {\n            min[1]\
    \ += min[0]\n            min[0] = min[0] > 0 ? min[0] - 1 : 0\n        }\n   \
    \ }\n    return count", "    // TODO: use more space complexity\n    \n    //\
    \ write your code here\n    var result = capacity\n    for y in 0..<grid.length\
    \ {\n        for x in 0..<grid[y].length {\n            if grid[y][x] == 1 {\n\
    \                for yy in 0..<y {\n                    for xx in 0..<x {\n  \
    \                      if grid[yy][xx] == 0 {\n                            grid[yy][xx]\
    \ = capacity\n                            result = min(result, capacity + max_fill(grid:\
    \ grid, capacity: capacity))\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n    return result", '    return
    min_fill(grid, capacity, 0)', "    var maxWell = 0\n    var maxBucket = capacity\n\
    \    for row in grid {\n        let bucket = maxWell\n        let units = 0\n\
    \        for column in row {\n            units += column\n            if units\
    \ > maxBucket {\n                maxBucket = units\n                bucket = maxBucket\n\
    \            }\n        }\n        maxWell = bucket\n    }\n    return maxBucket\
    \ - maxWell", "    var maxVal: Int = 0\n    var maxI: Int = 0\n    var isMaxed\
    \ = [Bool]()\n    var currentRow = [0]\n    var currentRowLength = 1\n    for\
    \ i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            currentRow[j]\
    \ = grid[i][j]\n            currentRowLength += 1\n            if currentRowLength\
    \ == capacity {\n                for k in 0..<capacity {\n                   \
    \ if currentRow[k] == 0 {\n                        isMaxed[k] = true\n       \
    \                 break\n                    }\n                }\n          \
    \      if maxVal == 0 && currentRowLength == 1 {\n                    maxVal =\
    \ 1\n                    maxI = 0\n                } else {\n                \
    \    if !isMaxed[maxI] {\n                        maxVal = maxVal * currentRowLength\n\
    \                        maxI = i\n                    }\n                }\n\
    \                currentRowLength = 1\n                currentRow = [0]\n    \
    \        }\n        }\n    }\n    return maxVal", "    var buckets = make(map[int][][])\
    \ // map of buckets\n    var total = 0\n    for row in grid {\n        total +=\
    \ capacity\n        var bucket = make([]int, capacity)\n        var i = -1\n \
    \       var j = -1\n        for i = 0; i+1 < len(row) && j+1 < len(row); i +=\
    \ 2, j += 2 {\n            if row[i+1] == 1 {\n                bucket[i] += capacity\n\
    \                bucket[j] += capacity\n            } else {\n               \
    \ bucket[i] -= capacity\n                bucket[j] -= capacity\n            }\n\
    \        }\n        buckets[total] = bucket\n    }\n    for _, b := range buckets\
    \ {\n        if b == nil {\n            return 0\n        }\n    }\n    return\
    \ total - buckets[total]", "    \n    // The first step is to calculate the number\
    \ of buckets.\n    // The formula for calculating number of buckets is: capacity\
    \ - sum(grid[i]).\n    // There are two ways to calculate this: One is to do an\
    \ iterative process.\n    // The other is to do recursive process.\n    // Time\
    \ complexity of these two methods is: O(n * c).\n    \n    // Iterative method:\n\
    \    var buckets = capacity - grid[0].map{ $0.1 }.reduce(0){$0 + $1} \n    \n\
    \    // Recursive method:\n    func recursive(bucketIndex: Int, grid: [Int], next:\
    \ Int) -> Int {\n        if bucketIndex == 0 {\n            return 0\n       \
    \ } else {\n            if grid[bucketIndex] == 0 {\n                bucketIndex\
    \ -= 1\n            }\n            \n            let nextVal = grid[bucketIndex]\
    \ + 1\n            let nextCount = recursive(bucketIndex - 1, grid, nextVal)\n\
    \            \n            return max(nextCount, next - grid[bucketIndex])\n \
    \       }\n    }\n    \n    return recursive(buckets, grid, capacity)", "    \n\
    \    var total = 0\n    \n    var visited = [GridNode]()\n    \n    \n    for\
    \ row in grid {\n        for col in row {\n            if col != 0 {\n       \
    \         let node = GridNode(row: row, col: col)\n                \n        \
    \        if let index = visited.index(of: node) {\n                    total +=\
    \ 1\n                    visited.remove(at: index)\n                } else {\n\
    \                    visited.append(node)\n                    total += col\n\
    \                    \n                    if total >= capacity {\n          \
    \              return total\n                    }\n                }\n      \
    \      }\n        }\n    }\n    \n    return 0", "    \n    // sort grid according\
    \ to first column and then second column\n    var tempGrid: [[Int]] = []\n   \
    \ for row in grid {\n        var sortedRow = [Int]()\n        for val in row {\n\
    \            sortedRow += val\n        }\n        tempGrid.append(sortedRow)\n\
    \    }\n    \n    // add first row to tempGrid\n    tempGrid.append([0])\n   \
    \ \n    var i = 0\n    \n    var maxBucket = tempGrid[0]\n    \n    for rowIndex\
    \ in 1..<tempGrid.count {\n        if tempGrid[rowIndex-1][0] >= capacity  {\n\
    \            i = rowIndex\n            maxBucket = tempGrid[rowIndex-1]\n    \
    \        break\n        }\n    }\n    \n    var count = 0\n    \n    for colIndex\
    \ in 0..<maxBucket.length {\n        if maxBucket[colIndex] >= capacity  {\n \
    \           count = count + 1\n        }\n    }\n    \n    return count", '    return
    Int((Double(capacity) * grid[0][0].count()).rounded(.toNearestOrEven))', "   \
    \ var answer = 0\n    var row = 0\n    var col = 0\n    var bucket = 0\n    var\
    \ bucket_sum = 0\n    while row < grid.length {\n        bucket_sum = 0\n    \
    \    while bucket < capacity {\n            bucket_sum += grid[row][bucket]\n\
    \            bucket++\n            if bucket_sum >= 1 {\n                break\n\
    \            }\n        }\n        grid[row] = grid[row][0:0]\n        bucket\
    \ = 0\n        bucket_sum = 0\n        row++\n    }\n    while bucket_sum < capacity\
    \ {\n        bucket_sum = 0\n        while bucket < capacity {\n            bucket_sum\
    \ += grid[row][bucket]\n            bucket++\n            if bucket_sum >= 1 {\n\
    \                break\n            }\n        }\n        bucket--\n        answer\
    \ += 1\n        bucket_sum = 0\n    }\n    return answer", "    let rowCount =\
    \ grid.count\n    let colCount = grid[0].count\n    \n    let minBucketCapacity\
    \ = capacity\n    var totalCapacity = minBucketCapacity * colCount\n    \n   \
    \ for j in 1..<colCount {\n        if grid[0][j] == 1 {\n            totalCapacity\
    \ += minBucketCapacity\n        }\n    }\n    \n    for i in 1..<rowCount {\n\
    \        var remainingCapacity = totalCapacity\n        var currentBucket = 0\n\
    \        for j in 0..<colCount {\n            if grid[i][j] == 1 {\n         \
    \       if remainingCapacity < currentBucket {\n                    remainingCapacity\
    \ += currentBucket\n                } else {\n                    remainingCapacity\
    \ -= currentBucket\n                }\n                currentBucket += 1\n  \
    \          }\n        }\n    }\n    return totalCapacity", "    // Initialize\
    \ result\n    var count = 0\n    // Initialize the bucket with capacity\n    var\
    \ bucket = Array<Int>(capacity)\n    // Init all buckets with 0\n    for _ in\
    \ 1...capacity.toInt() {\n        bucket.fill(Int(0))\n    }\n    // Go through\
    \ each row\n    for row in grid.enumerated() {\n        // Check if we reach our\
    \ capacity\n        if capacity.toInt() == 0 || (row!.offset % capacity).isMultiple(1)\
    \ {\n            break\n        }\n        // Increment bucket count\n       \
    \ count += 1\n        // Update bucket\n        for (i, w) in row.element.enumerated()\
    \ {\n            bucket[Int(i)] += w\n        }\n    }\n    return count", " \
    \   // DP approach\n    var maxNum = -1\n    var num = 0\n    for i in  0 ..<\
    \ grid.count {\n        for j in  0 ..< grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                grid[i][j] = 0\n                if num > maxNum {\n\
    \                    maxNum = num\n                }\n                num = 0\n\
    \            } else {\n                num++\n            }\n        }\n    }\n\
    \    if maxNum != -1 {\n        maxNum = maxNum * capacity\n    }\n    return\
    \ maxNum", "    precondition(grid.count == grid.count, \"invalid grid\")\n   \
    \ precondition(1 <= capacity && capacity <= 10, \"capacity out of range\")\n \
    \   var i = 0\n    var j = 0\n    var n = 0\n    var max = 0\n    for _ in 0..<grid.count\
    \ {\n        if grid[i][j] != 0 {\n            i += 1\n        }\n        if grid[i][j]\
    \ != 0 {\n            j += 1\n        }\n        if i == grid.count {\n      \
    \      i = 0\n        }\n        if j == grid.count {\n            j = 0\n   \
    \     }\n        n += grid[i][j]\n        if n >= capacity {\n            max\
    \ += n - capacity\n            n = 0\n        }\n    }\n    return max", "   \
    \ let rowLen = grid[0].length\n    for row in grid {\n        let minRowLen =\
    \ min(row)\n        if minRowLen > rowLen {\n            return -1\n        }\n\
    \    }\n    if rowLen > capacity {\n        return -1\n    }\n    let bucketCapacity\
    \ = capacity / rowLen\n    var buckets = Array(repeating: 0, count: rowLen)\n\
    \    for bucket in buckets {\n        if bucket == bucketCapacity {\n        \
    \    return -1\n        }\n    }\n    \n    var res = 0\n    for row in grid {\n\
    \        if row[0] == 0 {\n            res += max_fill(grid: row.dropFirst(),\
    \ capacity: bucketCapacity + 1) * bucketCapacity\n        } else {\n         \
    \   res += max_fill(grid: row.dropLast(), capacity: bucketCapacity)\n        }\n\
    \    }\n    return res", "\tmaxFill := -1\n\t\n\tfor _, row := range grid {\n\t\
    \tfor _, val := range row {\n\t\t\tif val == 0 {\n\t\t\t\tfor i := 0; i < capacity;\
    \ i++ {\n\t\t\t\t\tif grid[val][i] != 0 {\n\t\t\t\t\t\tgrid[val][i] = 0\n\t\t\t\
    \t\t\tmaxFill = maxFill + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ maxFill", "    if grid.isEmpty() {\n        return 0\n    }\n    var result\
    \ = 0\n    var next = 0\n    var bucketsMap = make(map[Int]Int)\n    for row in\
    \ grid.reversed() {\n        bucketsMap[row[0]] = Int(row[1])\n    }\n\n    for\
    \ capacityVal : Int in 1...capacity {\n        next += bucketsMap[next]\n    \
    \    bucketsMap[next] = 0\n    }\n\n    for capacityVal in 1...capacity {\n  \
    \      bucketsMap[next] -= capacityVal\n        next += bucketsMap[next]\n   \
    \     if bucketsMap[next] < 0 {\n            bucketsMap[next] = 0\n        }\n\
    \        result += 1\n    }\n    return result", "    if grid.isEmpty() || capacity\
    \ < 1 {\n        return 0\n    }\n    \n    let rows = grid.count\n    let cols\
    \ = grid[0].count\n    \n    var max = 1\n    for col in 0..<cols {\n        for\
    \ row in 0..<rows {\n            if grid[row][col] == 0 {\n                var\
    \ count = 0\n                for row in 0..<rows {\n                    for col\
    \ in 0..<cols {\n                        if grid[row][col] == 1 {\n          \
    \                  count = count + 1\n                            if count > max\
    \ {\n                                max = count\n                           \
    \ }\n                            break\n                        }\n          \
    \          }\n                }\n            }\n        }\n    }\n    return max",
  "    var total = 0\n    \n    for row in grid {\n        if row[0] == 0 {\n    \
    \        total += max_fill(grid, capacity-row[1])\n        }\n    }\n    \n  \
    \  return total", "    guard capacity > 0 && capacity <= 10, !grid.isEmpty else\
    \ {\n        return 0\n    }\n    \n    var n = 0\n    guard let firstRow = grid.first\
    \ else { return n }\n    \n    for col in 0..<firstRow.count {\n        for well\
    \ in 0..<firstRow[col].count {\n            if grid[col][well] > 0 {\n       \
    \         for col in 0..<firstRow.count {\n                    if grid[col][well]\
    \ == 0 {\n                        n += min_fill(grid: &grid, capacity: capacity)\n\
    \                        break\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return n", "    if grid.length == 0 {\n   \
    \     return 0\n    }\n\n    // Use priority queue to find empty cells in descending\
    \ order\n    var pq = PriorityQueue()\n    for row in 0..<grid.length {\n    \
    \    pq.insert(row: row, priority: -grid[row].count)\n    }\n\n    // Move to\
    \ first empty cell\n    guard let row = pq.min() { \n        return 0 \n    }\n\
    \n    // Find the first empty cell\n    var x = row\n    var y = row\n\n    while\
    \ true {\n        if grid[x][y] == 0 {\n            grid[x][y] = capacity\n  \
    \          return grid[x].count\n        }\n        if grid[x][y] > 0 {\n    \
    \        x -= 1\n        } else {\n            y += 1\n        }\n        if y\
    \ == 0 {\n            x = 0\n            y += 1\n        }\n    }", "    // Write\
    \ your code here\n    // var i = 0\n    // var j = 0\n    // var num = 0\n   \
    \ // var max = 0\n    // var cur = 0\n    \n    for i in 0..<grid.count {\n  \
    \      let buckets = grid[i]\n        for j in 0..<buckets.count {\n         \
    \   if buckets[j] >= capacity {\n                buckets[j] = capacity - 1\n \
    \           } else {\n                buckets[j] = 0\n            }\n        }\n\
    \    }\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n\
    \            if grid[i][j] > max {\n                max = grid[i][j]\n       \
    \     }\n        }\n    }\n    // return max\n    return max", "    guard grid.count\
    \ > 0 else { return 0 }\n    \n    // O(N*N*C) -- We use a hash map for efficiency\n\
    \    var buckets = [:]\n    var count = 0\n    for i in 0..<grid.count {\n   \
    \     for j in 0..<grid[i].count {\n            let bucket = buckets[grid[i][j]]\n\
    \            if bucket == nil {\n                buckets[grid[i][j]] = count\n\
    \            } else {\n                count += bucket!\n            }\n     \
    \   }\n    }\n    \n    for _ in 0..<capacity {\n        let maxCount = 0\n  \
    \      for count in buckets {\n            if count > maxCount {\n           \
    \     maxCount = count\n            }\n        }\n        for count in buckets\
    \ {\n            buckets[count] = maxCount\n        }\n        count++\n    }\n\
    \    return count", "\tvar max = 0\n\tvar i : Int = 0\n\tvar j : Int = 0\n\tvar\
    \ cur : Int = 0\n\n\tfor i < grid.length {\n\t\tcur = 0\n\t\t\n\t\tfor j < grid[i].length\
    \ {\n\t\t\tcur = cur * capacity\n\t\t\tcur = cur + (grid[i][j] == 0 ? 0 : capacity)\n\
    \t\t}\n\t\t\n\t\tif cur > max {\n\t\t\tmax = cur\n\t\t}\n\t\t\n\t\ti += 1\n\t\
    }\n\t\n\treturn max", '    return 0', "  if capacity <= 0 {\n    return 0\n  }\n\
    \  \n  var result = 0\n  var bucket = capacity\n  \n  for r in 0..<grid.count\
    \ {\n    for c in 0..<grid[r].count {\n      if grid[r][c] == 1 {\n        bucket\
    \ -= 1\n        if bucket == 0 {\n          result += 1\n          bucket = capacity\n\
    \        }\n      }\n    }\n  }\n  return result", '    return 0', "    if grid.isEmpty\
    \ {\n        return 0\n    }\n    \n    \n    // init bucket array with all elements\
    \ from 0 to capacity\n    var buckets: [Int] = Array(capacity)\n    \n    // init\
    \ counter\n    var count = 0\n    \n    // initialize min number of buckets\n\
    \    var minBuckets = Int((capacity)/2)\n    \n    for i in 0 ..< grid.count {\n\
    \        // find minimum number of buckets\n        switch minBuckets {\n    \
    \    case 1 :\n            buckets[0] = grid[i][0]\n        case 2 :\n       \
    \     buckets[0] = grid[i][0]\n            buckets[1] = grid[i][1]\n        case\
    \ 3 :\n            buckets[0] = grid[i][0]\n            buckets[1] = grid[i][1]\n\
    \            buckets[2] = grid[i][2]\n        case 4 :\n            buckets[0]\
    \ = grid[i][0]\n            buckets[1] = grid[i][1]\n            buckets[2] =\
    \ grid[i][2]\n            buckets[3] = grid[i][3]\n        default:\n        \
    \    print(\"default\")\n        }\n        \n        // loop over all buckets\n\
    \        for b in 0 ..< capacity {\n            if buckets[b] < 0 {\n        \
    \        buckets[b] = 0\n            }\n        }\n        \n        // if bucket\
    \ has enough water use it\n        count += buckets.count\n        \n        //\
    \ if bucket is empty, reduce number of buckets\n        if buckets.count == 0\
    \ {\n            minBuckets--\n        }\n    }\n    \n    return count", "  \
    \  // TODO: Fill in here\n    return 0", "\tguard grid.count == 1, grid.count\
    \ == grid[0].length, capacity <= 10 else {\n\t\treturn 0\n\t}\n\t\n\tvar max =\
    \ 0\n\tfor i in 0..<grid[0].length {\n\t\tif grid[0][i] == 1 {\n\t\t\tgrid[0][i]\
    \ = 0\n\t\t\tmax = grid[0][i]\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\tfor i in  1..<grid.count\
    \ {\n\t\tvar min = 99\n\t\tfor j in  1..<grid[i].length {\n\t\t\tif grid[i][j]\
    \ == 0 {\n\t\t\t\tgrid[i][j] = 1\n\t\t\t\tmin = grid[i][j]\n\t\t\t\tbreak\n\t\t\
    \t}\n\t\t}\n\t\t\n\t\tif min < max {\n\t\t\tmax = min\n\t\t}\n\t}\n\treturn max",
  "    // Your code here\n    return 0", "    var maxCount = 0\n    var maxVal = -Int64(0)\n\
    \    for i in 0..<grid.count {\n        var count = 0\n        var j = i\n   \
    \     while j >= 0 && grid[j][i] == 0 {\n            count++\n            grid[j][i]\
    \ = 1\n            j -= 1\n        }\n        if count > maxCount {\n        \
    \    maxCount = count\n            maxVal = i\n        }\n    }\n    for _ in\
    \ 0..<capacity {\n        var count = 0\n        for j in 0..<grid.count {\n \
    \           if grid[j][maxVal] == 1 {\n                grid[j][maxVal] = 0\n \
    \               count += 1\n            }\n        }\n        if count == 0 {\n\
    \            return 0\n        }\n        maxCount += count\n    }\n    return\
    \ maxCount", "\t\n    // Step 1: Iterate over the rows of the grid\n    var max_count\
    \ = 0\n    for row in grid {\n        // Step 2: Iterate over the columns of each\
    \ row\n        for column in row {\n            // Step 3: If the column contains\
    \ 0s, return max_count\n            if column == 0 {\n                max_count++\n\
    \                continue\n            }\n            \n            // Step 4:\
    \ Increase the bucket capacity by the amount of water contained in that bucket\n\
    \            capacity *= column\n        }\n    }\n    \n    // Step 5: Return\
    \ max_count\n    return max_count", "    if grid.length == 0 || grid[0].length\
    \ == 0 {\n        return 0\n    }\n    if capacity < 1 || capacity > 10 {\n  \
    \      return 0\n    }\n    if capacity > grid[0].length {\n        return max_fill(grid[1...],\
    \ capacity)\n    }\n    var sum = 0\n    for i : Int in 0..<grid[0].length {\n\
    \        sum += grid[0][i]\n    }\n    sum %= capacity\n    return sum", "   \
    \ \n    let N = grid.count\n    \n    var count = 1\n    \n    // find the max\
    \ # of water we can extract\n    for idx in 0..N-1 {\n        if grid[idx][0]\
    \ == 1 {\n            grid[idx][0] = capacity\n        }\n    }\n    \n    for\
    \ idx in 0..N-1 {\n        if grid[idx][0] > 0 {\n            grid[idx][0]--\n\
    \            count += grid[idx][0]\n            if count == 0 {\n            \
    \    for i in 0..N-1 {\n                    if grid[i][0] == 0 {\n           \
    \             grid[i][0]--\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return count", "    if grid.length == 0 {\n   \
    \     return 0\n    }\n    var max = 0\n    var total = 0\n    for _ in 0 ..<\
    \ capacity {\n        for (i, j) in grid.indices {\n            if grid[i][j]\
    \ == 1 {\n                total += 1\n                if total > max {\n     \
    \               max = total\n                }\n                grid[i][j] = 0\n\
    \            }\n        }\n    }\n    return max", "    \n    var numOfRows =\
    \ Int(0)\n    var numOfColumns = Int(0)\n    \n    var numOfBuckets = Int(0)\n\
    \    \n    var bucketIndexOfFirstWell = Int(0)\n    \n    for _ in 0..<grid.length\
    \ {\n        numOfRows += Int(grid[Int(_)][2])\n        numOfColumns += Int(grid[Int(_)][3])\n\
    \    }\n    \n    var firstWell = grid[Int(numOfRows)][Int(numOfColumns)]\n  \
    \  \n    for _ in 0..<grid.length {\n        for _ in 0..<grid[Int(_)][3] {\n\
    \            bucketIndexOfFirstWell += Int(grid[Int(_)][2])\n        }\n    }\n\
    \    \n    numOfBuckets += Int(grid[Int(numOfRows)][3] - firstWell)\n    \n  \
    \  var count = 0\n    \n    while numOfBuckets > capacity {\n        bucketIndexOfFirstWell\
    \ -= Int(firstWell)\n        firstWell = grid[Int(numOfRows)][Int(numOfColumns)]\n\
    \        numOfBuckets -= Int(grid[Int(numOfRows)][3] - firstWell)\n        count\
    \ += 1\n    }\n    return count", "    // Fill each bucket with water and then\
    \ find the max number of buckets needed\n    var buckets = [Int](capacity)\n \
    \   for row in 0..<grid.count {\n        for col in 0..<grid[row].count {\n  \
    \          buckets[row] += grid[row][col]\n        }\n    }\n\n    var maxBuckets\
    \ = 0\n    // Lower the bucket count if needed\n    for bucket in buckets {\n\
    \        if bucket < capacity {\n            buckets[bucket] = 0\n           \
    \ maxBuckets++\n        }\n    }\n\n    return maxBuckets", "    let size = grid.count\n\
    \    let maxRow = Int(ceil(Double(size) / Double(Capacity)))\n    let minCol =\
    \ capacity - 1\n    var result = 0\n    for i in 0..<maxRow {\n        let maxCol\
    \ = minCol\n        for j in 0..<maxCol {\n            if grid[i][j] == 0 {\n\
    \                if capacity == 1 {\n                    result += grid[i][j]\
    \ * capacity\n                } else {\n                    result += capacity\
    \ - grid[i][j]\n                }\n                if capacity < grid[i][j] {\
    \ capacity *= 2 }\n                grid[i][j] = 0\n                if capacity\
    \ < grid[i][j] { capacity *= 2 }\n                maxCol = capacity - grid[i][j]\n\
    \            } else {\n                maxCol = minCol\n            }\n      \
    \  }\n    }\n    return result", '    return 0', "    var num = 0\n    for row\
    \ in grid {\n        let sum = 0\n        for row in row {\n            sum +=\
    \ row\n        }\n        num += (sum == capacity) ? 1 : 0\n    }\n    return\
    \ num", "\tlet m = grid.count\n\tlet n = grid[0].count\n\t\n\tvar counter = 0\n\
    \t\n\tfor i in 0..m-1 {\n\t\tfor j in 0..n-1 {\n\t\t\tlet d = grid[i][j]\n\t\t\
    \tlet v = capacity-bucket[j]\n\t\t\t\n\t\t\tif v > 0 {\n\t\t\t\tgrid[i][j] = 0\n\
    \t\t\t\tcounter += v\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn counter", "    var i =\
    \ 0\n    var j = 0\n    var count = 0\n    while i < grid.length && j < grid[0].length\
    \ {\n        if grid[i][j] == 1 {\n            count += 1\n            grid[i][j]\
    \ = 0\n            i += 1\n            j += 1\n        } else {\n            if\
    \ count == capacity {\n                count += 1\n                grid[i][j]\
    \ = 1\n                j += 1\n            } else {\n                count = 0\n\
    \                i += 1\n                j += 1\n            }\n        }\n  \
    \  }\n    return count", '    return maxCount(grid, capacity)', "    var max =\
    \ 0\n    var current = 0\n    \n    for _ in 0..<len(grid) {\n        for _ in\
    \ 0..<len(grid[0]) {\n            if grid[_][0] == 0 {\n                grid[_][0]\
    \ = current\n                current += grid[_][1]\n                if current\
    \ > max {\n                    max = current\n                }\n            \
    \    current = 0\n            }\n        }\n    }\n    \n    return max", "  \
    \  // TODO:\n    return 0", "    let m = grid.count\n    let n = grid[0]?.count\
    \ ?? 0\n    if m == 0 || n == 0 {\n        return 0\n    }\n    let res = Int((m\
    \ - 1) / capacity)\n    for i in 0..<res {\n        if res-i >= n {\n        \
    \    continue\n        }\n        let well = grid[i : i+n]\n        let maxBucket\
    \ = well?.maxElement ?? 0\n        for bucket in 0..<capacity {\n            if\
    \ maxBucket == bucket {\n                continue\n            }\n           \
    \ well[bucket] = 0\n            if well[maxBucket] == 1 {\n                break\n\
    \            }\n        }\n    }\n    return res", "    // Write your code here\n\
    \    if grid.count == 0 {\n        return 0\n    }\n    var max = 0\n    for i\
    \ in 0..<grid.count {\n        var bucket = capacity\n        var x = 0\n    \
    \    for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n        \
    \        bucket -= grid[i][j]\n                x++\n            }\n          \
    \  if bucket < 0 {\n                break\n            }\n        }\n        if\
    \ bucket > max {\n            max = bucket\n        }\n    }\n    return max",
  '    return min_fill(grid, capacity)', "    if grid.count != 1 {\n        return\
    \ 0\n    }\n    if capacity <= 1 {\n        return 0\n    }\n    var result :\
    \ Int = 0\n    var maxBucket : Bucket = Bucket(capacity)\n    for _ in 0..<capacity\
    \ {\n        maxBucket.count++\n    }\n    var bucket : Bucket = maxBucket\n \
    \   var leftWall : Int = 0\n    for w in 0..<grid[0].count {\n        bucket.count++\n\
    \        if bucket == leftWall {\n            result += grid[0][w]\n         \
    \   bucket = Bucket(capacity)\n            leftWall += 1\n        }\n    }\n \
    \   return result", "    // Do not write main() function.\n    // Do not read\
    \ input, instead use the arguments to the function.\n    // Do not print the output,\
    \ instead return values as specified\n    // Still have a doubt. Checkout www.geeksforgeeks.org/?p=3754\u200E\
    \n    \n    var buckets = [Int](count: capacity+1, repeatedValue: 0)\n    \n \
    \   for row in grid {\n        for b in 0..<row.count {\n            buckets[b]\
    \ += row[b]\n        }\n    }\n    \n    var count = 0\n    for b in 0..<capacity\
    \ {\n        if buckets[b] <= 0 {\n            count += 1\n            buckets[b]\
    \ = capacity\n        }\n    }\n    return count", "    var max = 0\n    for _\
    \ in 0..<(grid.length) { //Loop through every row\n        var newMax = capacity\n\
    \        for _ in 0..<(grid[0].length) { //Loop through every column\n       \
    \     if grid[max][_] == 1 {\n                newMax = newMax - 1\n          \
    \  }\n        }\n        if newMax > 0 {\n            max = max\n        } else\
    \ {\n            max = max + 1\n        }\n    }\n    return max", "    if grid.length\
    \ == 0 || grid[0].length == 0 {\n        return 0\n    }\n    var max = 0\n  \
    \  for i in 0..<grid[0].length {\n        for j in 0..<grid.length {\n       \
    \     if grid[j][i] == 0 {\n                grid[j][i] = 1\n                grid[j][i]\
    \ = capacity\n            }\n            max += grid[j][i]\n        }\n    }\n\
    \    return max", "    guard let rowCount = grid.count else { return 0 }\n   \
    \ guard let width = grid[0][0] else { return 0 }\n\n    var sum = 0\n    var row\
    \ = 0\n    while row < rowCount {\n        let column = 0\n        while column\
    \ < width {\n            if grid[row][column] == 1 {\n                sum += capacity\n\
    \            }\n            column += 1\n        }\n        row += 1\n    }\n\
    \    return sum", "    \n    var result = 0\n    var count = 0\n    \n    var\
    \ grid = grid\n    \n    var minX = grid[0].minX\n    var minY = grid[0].minY\n\
    \    \n    for index in 1..<grid.length {\n        minX = min(minX, grid[index].minX)\n\
    \        minY = min(minY, grid[index].minY)\n    }\n    \n    for index in 1..<grid.length\
    \ {\n        for index2 in 1..<grid[index].length {\n            var x = grid[index][index2]\n\
    \            var y = grid[index][index2 - 1]\n            if capacity > 1 {\n\
    \                if x!=0{\n                    capacity -= 1\n               \
    \     grid[index][index2-1] = 0\n                }\n                if y!=0{\n\
    \                    capacity -= 1\n                    grid[index-1][index2 -\
    \ 1] = 0\n                }\n            }\n            grid[index][index2-1]\
    \ = 0\n            grid[index-1][index2] = 0\n        }\n    }\n    \n    for\
    \ index in 1..<grid.length {\n        for index2 in 1..<grid[index].length {\n\
    \            var x = grid[index][index2]\n            var y = grid[index][index2\
    \ - 1]\n            if capacity > 1 {\n                if x!=0{\n            \
    \        capacity -= 1\n                    grid[index-1][index2-1] = 0\n    \
    \            }\n                if y!=0{\n                    capacity -= 1\n\
    \                    grid[index-1][index2] = 0\n                }\n          \
    \  }\n            grid[index-1][index2-1] = 0\n            grid[index-1][index2]\
    \ = 0\n        }\n    }\n    \n    for index in 1..<grid.length {\n        if\
    \ capacity > 1 {\n            if grid[index][grid[index].length-1]!=0{\n     \
    \           capacity -= 1\n                grid[index][grid[index].length-1] =\
    \ 0\n            }\n        }\n    }\n    \n    for index in 1..<grid.length {\n\
    \        if capacity > 1 {\n            if grid[index-1][grid[index-1].length-1]!=0{\n\
    \                capacity -= 1\n                grid[index-1][grid[index-1].length-1]\
    \ = 0\n            }\n        }\n    }\n    \n    for index in 1..<grid.length\
    \ {\n        if capacity > 1 {\n            if grid[index-1][grid[index-1].length-1]!=0{\n\
    \                capacity -= 1\n                grid[index-1][grid[index-1].length-1]\
    \ = 0\n            }\n        }\n    }\n    \n    for index in 1..<grid.length\
    \ {\n        if capacity > 1 {\n            if grid[index-1][grid[index-1].length-1]!=0{\n\
    \                capacity -= 1\n                grid[index-1][grid[index-1].length-1]\
    \ = 0\n            }\n        }\n    }\n    \n    for index in 1..<grid.length\
    \ {\n        if capacity > 1 {\n            if grid[index", '    return -1', "\t\n\
    \tguard grid.count > 0 else {\n\t\treturn 0\n\t}\n\t\n\tguard capacity > 0 else\
    \ {\n\t\treturn 0\n\t}\n\t\n\tlet buckets = Array(capacity)\n\t\n\tfor (i, row)\
    \ in grid.enumerated() {\n\t\tbuckets[row[0]] = i\n\t}\n\t\n\tvar count = 0\n\t\
    \n\tvar j = grid.count - 1\n\tvar i = j\n\t\n\twhile i >=  0 {\n\t\tif buckets[j]\
    \ == i {\n\t\t\ti--\n\t\t\tcount++\n\t\t\tbreak\n\t\t} else {\n\t\t\tj--\n\t\t\
    \tbuckets[j] = i\n\t\t}\n\t}\n\t\n\treturn count", "\tvar count = 0\n\tfor i :=\
    \ 0; i < len(grid); i++ {\n\t\tvar max = 0 //the bucket that can still be used\
    \ to empty the well\n\t\tvar min = 0 //the bucket that can still be used to empty\
    \ the well\n\t\tvar need = 0 //how many buckets should be used to empty the well\n\
    \t\tfor j := 0; j < len(grid[i]); j++ {\n\t\t\tif grid[i][j] == 1 {\n\t\t\t\t\
    if max - min < capacity {\n\t\t\t\t\tneed = capacity - max - min\n\t\t\t\t} else\
    \ {\n\t\t\t\t\tneed = 1\n\t\t\t\t}\n\t\t\t\tif need > 0 {\n\t\t\t\t\tgrid[i][j]\
    \ = 0\n\t\t\t\t\tmax += need\n\t\t\t\t\tmin += need\n\t\t\t\t} else {\n\t\t\t\t\
    \tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif max - min < capacity {\n\t\t\tneed\
    \ = capacity - max - min\n\t\t} else {\n\t\t\tneed = 1\n\t\t}\n\t\tif need > 0\
    \ {\n\t\t\tcount += need\n\t\t}\n\t}\n\treturn count", "    if capacity <= 0 {\n\
    \        return 0\n    }\n    if grid[0][0] == 0 {\n        return 0\n    }\n\
    \    if grid[0].length == 0 {\n        return grid[0].length\n    }\n    var result\
    \ : Int = 1\n    for row in grid[1..<grid.length] {\n        var curCapacity :\
    \ Int = capacity\n        for row in row[1..<row.length] {\n            if row\
    \ == 0 {\n                continue\n            }\n            curCapacity -=\
    \ 1\n            if curCapacity < 0 {\n                return 0\n            }\n\
    \        }\n        result += curCapacity\n    }\n    return result", "    var\
    \ buckets: [Int]\n    var wells: [[Int]]\n    for row in grid {\n        buckets\
    \ = [0]\n        wells = row\n    }\n    let n = wells.count\n    var counter\
    \ = 1\n    for i in 0..<n {\n        for j in 0..<wells[i].count {\n         \
    \   if wells[i][j] == 0 {\n                if buckets[j] < capacity {\n      \
    \              buckets[j] += counter\n                    counter += 1\n     \
    \           }\n            }\n        }\n    }\n    return counter", "    if grid.isEmpty()\
    \ {\n        return 0\n    }\n    var i : Int\n    var j : Int\n    var buckets\
    \ : [Int]\n    var i : Int\n    var j : Int\n    var bucket_count : Int\n    \n\
    \    buckets = [Int](repeatElement(0, capacity))\n    bucket_count = 0\n    \n\
    \    for i = 0; i < grid.count; i++ {\n        for (j = 0; j < grid[i][1]; j++\
    \ {\n            buckets[grid[i][j]] += 1\n        }\n    }\n    \n    for i in\
    \ 0..<buckets.count {\n        if buckets[i] > bucket_count {\n            bucket_count\
    \ = buckets[i]\n        }\n    }\n    \n    return bucket_count", "        \n\
    \    // We use bucket sort here to solve the problem\n    buckets = make([][]Bucket,\
    \ capacity)\n    \n    for row in grid {\n        for col in row {\n         \
    \   switch col {\n            case 0:\n                buckets[0].add(Bucket(row))\n\
    \            case 1:\n                buckets[1].add(Bucket(row))\n          \
    \  default:\n                buckets[col%2].add(Bucket(row))\n            }\n\
    \        }\n    }\n    \n    var maxBucketIdx = -1\n    var maxBucket = 0\n  \
    \  var maxBucketVal = 0\n    \n    // We need to sort the buckets in descending\
    \ order\n    sort.SliceStable(buckets, func(i, j int) bool {\n        return buckets[i].val\
    \ > buckets[j].val\n    })\n    \n    for i := 0; i < len(buckets); i++ {\n  \
    \      if maxBucketVal < buckets[i].val {\n            maxBucketIdx = i\n    \
    \        maxBucketVal = buckets[i].val\n        }\n    }\n    \n    return maxBucketIdx",
  "\t// M1. \u52A8\u6001\u89C4\u5212\n\t\n\tassert(grid.count == 1)\n\tassert(grid.length\
    \ > 0)\n\tassert(grid[0].length > 0)\n\tassert(capacity <= 10)\n\t\n\t// init\
    \ state\n\tlet size = grid.count\n\tvar res = 0\n\t\n\tfor colIdx in 0..<grid[0].length\
    \ {\n\t\t\n\t\tvar maxVal = grid[0][colIdx]\n\t\tvar minVal = grid[0][colIdx]\n\
    \t\t\n\t\tfor wellIdx in 0..<size {\n\t\t\t\n\t\t\tminVal = grid[wellIdx][colIdx]\n\
    \t\t\t\n\t\t\tif maxVal < minVal {\n\t\t\t\tmaxVal = minVal\n\t\t\t}\n\t\t}\n\t\
    \t\n\t\tif maxVal > capacity {\n\t\t\tres = res + 1\n\t\t}\n\t}\n\t\n\treturn\
    \ res", "    precondition(grid.length == grid[0].length, \"All rows must have\
    \ the same length\")\n    let bucket = Array(repeating: capacity, count: grid[0].length)\n\
    \    grid.forEach { row in\n        row.forEach { number in\n            bucket[number]\
    \ += number\n        }\n    }\n\n    let index = 0\n    var count = 1\n    while\
    \ index != bucket.count {\n        if bucket[index] == 0 {\n            count\
    \ += 1\n            index++\n        } else {\n            index -= 1\n      \
    \  }\n    }\n    return count", "    guard grid.count > 0 && capacity > 0 && capacity\
    \ <= 10 else {\n        return 0\n    }\n    let buckets = makeBucketed(capacity,\
    \ count: grid.count)\n    fillBuckets(grid, buckets)\n    return countChange(buckets)",
  "\tswitch capacity {\n\tcase 1:\n\t\treturn 0\n\tcase 2:\n\t\treturn 2\n\tcase 3:\n\
    \t\treturn 1\n\tcase 4, 5:\n\t\treturn 1\n\tcase 6, 7:\n\t\treturn 0\n\tcase 8,\
    \ 9:\n\t\treturn 1\n\t}\n\n\tminCapacity := capacity\n\tbucket := make([]int,\
    \ len(grid))\n\n\tfor i := range bucket {\n\t\tbucket[i] = 0\n\t}\n\tbuckets :=\
    \ make([]int, minCapacity)\n\n\tfor i := range grid {\n\t\tbucket := buckets[grid[i][1]]\n\
    \t\tbucket[grid[i][0]] += 1 //Increment bucket by one\n\t\tif buckets[grid[i][1]]\
    \ < minCapacity {\n\t\t\tminCapacity = buckets[grid[i][1]]\n\t\t}\n\t\tbuckets[grid[i][1]]\
    \ = minCapacity //Reset minCapacity\n\t}\n\treturn minCapacity - sumBuckets(buckets)",
  "    var count = 0\n    \n    grid.sort() { $0.0 < $1.0 }\n    \n    var min = 0\n\
    \    var max = capacity\n    for r in 0 ..< grid.count {\n        var x = grid[r][0]\n\
    \        for c in 0 ..< grid[r].count {\n            if grid[r][c] != 0 {\n  \
    \              min = min(min, c)\n                max = max(max, c)\n        \
    \    }\n        }\n    }\n    \n    for r in 0 ..< grid.count {\n        var x\
    \ = grid[r][0]\n        for c in 0 ..< grid[r].count {\n            if grid[r][c]\
    \ != 0 {\n                if x < max {\n                    grid[r][x] = grid[r][c]\n\
    \                    x++\n                }\n                else {\n        \
    \            grid[r][c] = 0\n                    \n                    var c2\
    \ = grid[r].count - 1\n                    for cc in 0 ..< grid[r].count {\n \
    \                       if cc != c2 {\n                            if grid[r][cc]\
    \ == 0 {\n                                grid[r][c] = grid[r][cc]\n         \
    \                       c2--\n                                break\n        \
    \                    }\n                        }\n                    }\n   \
    \                 \n                    x = 0\n                    for cc in \
    \ 0 ..< grid[r].count {\n                        if cc != c {\n              \
    \              c--\n                        }\n                    }\n       \
    \         }\n                count++\n            }\n        }\n    }\n    \n\
    \    return count", "    if grid.length <= 0 || grid[0].length <= 0 {\n      \
    \  return 0\n    }\n    var count = 0\n    for i := 0; i < grid[0].length-1; i++\
    \ {\n        for j := 0; j < grid.length; j++ {\n            if grid[j][i+1] ==\
    \ 0 {\n                count += 1\n                grid[j][i+1] = capacity\n \
    \           } else if grid[j][i+1] == capacity {\n                if grid[j][i]\
    \ < capacity {\n                    grid[j][i+1] = capacity\n                }\n\
    \            }\n        }\n    }\n    return count", '    return maxFill(grid,
    capacity, nil)', "    \n    let rows = grid.count\n    let cols = grid[0].count\n\
    \    \n    let mut max_val = 0\n    \n    for j in 0..<cols {\n        for i in\
    \ 0..<rows {\n            \n            let index = i*cols+j\n            \n \
    \           if grid[i][j] == 1 {\n                \n                let max_val_index\
    \ = i*capacity+j\n                \n                if max_val_index > max_val\
    \ {\n                    max_val = max_val_index\n                }\n        \
    \    }\n        }\n    }\n    \n    return max_val", "    \n    guard \n     \
    \   let well = grid[0][0],\n        let gridSize = grid.count,\n        let capacityInt\
    \ = Int(capacity)\n        else { return 0 }\n    \n    var maxCount = 0\n   \
    \ \n    for row in 0..<gridSize {\n        if let cell = grid[row][0], cell ==\
    \ 1 {\n            for column in 0..<well {\n                maxCount = maxCount\
    \ + 1\n                if capacityInt > grid[row][column] {\n                \
    \    capacityInt -= 1\n                    break\n                }\n        \
    \    }\n        }\n    }\n    \n    return maxCount", '    return bfs(grid, capacity)',
  "    // Write your code here\n    if capacity == 0 {\n        return 0\n    }\n\
    \    var max = 0\n    var i = 1\n    while i <= grid.length {\n        if grid[i][0]\
    \ == 1 {\n            max = max + 1\n        }\n        i += 1\n    }\n    return\
    \ max - capacity", "    if grid.isEmpty() {\n        return 0\n    }\n    let\
    \ rowLen = grid[0].count\n    var total = 0\n    for row in grid {\n        if\
    \ row.count == 0 {\n            continue\n        }\n        for col in 0..<rowLen\
    \ {\n            if col == capacity {\n                continue\n            }\n\
    \            total += col * row[col]\n        }\n    }\n    return total", " \
    \   let m = grid.count\n    var count = 0\n    for i in 0..<m {\n        for j\
    \ in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n                count\
    \ += min_fill(grid, i, j, capacity)\n            }\n        }\n    }\n    return\
    \ count", '    return sum(1 for _ in max_fill(grid: grid, capacity: capacity))',
  "    let n = grid.count\n    var count = 0\n    for row in 0..<n {\n        let\
    \ col = grid[row].count\n        for i = 0..<col {\n            if grid[row][i]\
    \ == 1 {\n                for j = i..<col {\n                    if grid[row][j]\
    \ == 1 {\n                        if capacity < j-i+1 {\n                    \
    \        count += capacity - j - i + 1\n                        }\n          \
    \              grid[row][j] = 0\n                        grid[row][i] = 0\n  \
    \                      break\n                    }\n                }\n     \
    \       }\n        }\n    }\n    return count", "    if capacity < 1 {\n     \
    \   return 0\n    }\n    var total = 0\n    for row in grid {\n        for bucket\
    \ in row {\n            if bucket >= capacity {\n                bucket -= capacity\n\
    \                total += capacity\n            }\n        }\n    }\n    return\
    \ total", "    \n    if capacity <= 1 {\n        return 0\n    }\n    if grid[0][0]\
    \ == 0 {\n        return 0\n    }\n    if grid[0].length >= capacity {\n     \
    \   return grid[0].length\n    }\n    var max = 0\n    for row in 0..<grid.length\
    \ {\n        if grid[row].length > 0 {\n            max = max(max, capacity -\
    \ grid[row][0])\n        }\n    }\n    if max > 0 {\n        return max\n    }\n\
    \    \n    for row in 0..<grid.length {\n        if grid[row].length >= capacity\
    \ {\n            if max < grid[row].length {\n                max = grid[row].length\n\
    \            }\n        }\n    }\n    return max", "\t// Sort grid based on first\
    \ column values\n\tlet sortedGrid = grid.sorted(by: { $0[$0] < $1[$0] })\n\t\n\
    \tguard sortedGrid.count == grid.count else {\n\t\treturn 0\n\t}\n\t\n\t// Get\
    \ count of unique bucket sizes\n\tlet bucketCounts = Set(sortedGrid.map({ $0.1\
    \ }))\n\t\n\t// Get number of buckets that can hold all water with given capacity\n\
    \tlet possibleBucketCount = bucketCounts.filter({ (size) -> size <= capacity }).count\n\
    \t\n\t// If there are only 1 bucket to hold all water, then there are no empty\
    \ wells.\n\tguard possibleBucketCount == 1 else {\n\t\treturn 0\n\t}\n\t\n\t//\
    \ Create empty buckets, one per possible bucket size.\n\tlet buckets = [Int](repeating:\
    \ 0, count: possibleBucketCount)\n\t\n\tguard buckets.count == possibleBucketCount\
    \ else {\n\t\treturn 0\n\t}\n\t\n\t// Track how much water has been left in the\
    \ buckets\n\tvar leftBuckets = Int()\n\t\n\t// Loop through each row\n\tfor i\
    \ in 0..<sortedGrid.count {\n\t\t// If water is in the bucket\n\t\tif sortedGrid[i][0]\
    \ == 1 {\n\t\t\t// Move water from bucket\n\t\t\tbuckets[Int(sortedGrid[i][1])]\
    \ -= 1\n\t\t\t\n\t\t\t// Update water left in bucket\n\t\t\tleftBuckets += Int(sortedGrid[i][1])\n\
    \t\t}\n\t}\n\t\n\t// Return the remaining water left in buckets.\n\treturn leftBuckets",
  "    let n = grid.count\n    // for each row\n    for row in 0..<n {\n        //\
    \ for each bucket\n        let buckets = grid[row]\n        if capacity.isEmpty\
    \ {\n            // if capacity is empty\n            // for each 1 in a row\n\
    \            for _ in 0..<buckets.count {\n                // bucket is empty\n\
    \                // if bucket is full, increase capacity\n                if buckets.count\
    \ == 1 {\n                    capacity += buckets[0]\n                } else {\n\
    \                    // if bucket is not full\n                    capacity +=\
    \ buckets[0]\n                }\n            }\n        } else {\n           \
    \ // if capacity is not empty\n            // for each 1 in a row\n          \
    \  for _ in 0..<buckets.count {\n                // if bucket is full\n      \
    \          if buckets.count == 1 {\n                    // bucket is full\n  \
    \                  // reduce capacity by bucket capacity\n                   \
    \ capacity -= buckets[0]\n                } else {\n                    // bucket\
    \ is not full\n                    // reduce capacity by bucket capacity\n   \
    \                 capacity -= buckets[0]\n                }\n            }\n \
    \       }\n        // if no change\n        // return capacity\n        if capacity\
    \ == 0 {\n            return capacity\n        }\n    }\n    return 0", "    let\
    \ rows = len(grid)\n    let cols = len(grid[0])\n    \n    let maxVal = grid[0].max()\
    \ // init max with first well's max value\n    let maxBucket = capacity // init\
    \ max bucket to capacity and start bucket count from 0\n    \n    // looping through\
    \ rows\n    for row in 0..<rows {\n        \n        // looping through cols\n\
    \        for col in 0..<cols {\n            if grid[row][col] > maxVal {\n   \
    \             maxVal = grid[row][col]\n                maxBucket = capacity -\
    \ maxBucket\n            }\n            if maxBucket <= 0 {\n                return\
    \ maxBucket\n            } else {\n                maxBucket -= 1\n          \
    \  }\n        }\n    }\n    return 0", "    guard capacity > 0 else {\n      \
    \  return 0\n    }\n    var numZeros = 0\n    var numOnes = 0\n    \n    for row\
    \ in grid {\n        for col in row {\n            let bucket = col / capacity\n\
    \            \n            if bucket == 1 {\n                numOnes++\n     \
    \       } else {\n                numZeros++\n            }\n        }\n    }\n\
    \    \n    if numZeros == 0 && numOnes == grid.count {\n        return 0\n   \
    \ }\n    \n    if numZeros > numOnes {\n        return numZeros - numOnes\n  \
    \  } else {\n        return numOnes - numZeros\n    }", "    let n = grid[0].count\n\
    \    if n == 0 {\n        return 0\n    }\n    if capacity == 1 {\n        return\
    \ n\n    }\n    let maxCapacity = n * capacity\n    let maxBucket = maxCapacity\
    \ / n\n    if maxCapacity < capacity {\n        return 0\n    }\n    if capacity\
    \ == 1 {\n        return n - 1\n    }\n    for row in 0..<n {\n        for j in\
    \ 0..<n {\n            if j >= maxCapacity {\n                let bucket = j *\
    \ n + row\n                grid[bucket][row] = capacity - grid[bucket][row]\n\
    \            } else {\n                let bucket = j * n + row\n            \
    \    grid[bucket][row] = capacity - grid[bucket][row]\n            }\n       \
    \ }\n    }\n    return n - 1", "    \n    var max = 0\n    for _ in 0..<grid.count\
    \ {\n        for _ in 0..<grid[0].count {\n            if grid[0][_] > max {\n\
    \                max = grid[0][_]\n            }\n        }\n    }\n    \n   \
    \ var count = 0\n    for _ in 0..<grid.count {\n        for _ in 0..<grid[0].count\
    \ {\n            if grid[_][_] == 0 && grid[(_ + 1) % grid.count][_] == 0 {\n\
    \                grid[(_ + 1) % grid.count][_] = 1\n                count += capacity\
    \ - max\n                max -= 1\n            }\n        }\n    }\n    return\
    \ count", "    var result = 0\n    var count = 0\n    for _ in 0..<capacity..<grid.count\
    \ {\n        // Find the bucket with the lowest water\n        var minBucket =\
    \ 0\n        for bucket in 0..<capacity..<grid.count {\n            if grid[bucket][1]\
    \ == 1 {\n                minBucket = bucket\n                break\n        \
    \    }\n        }\n        for bucket in 0..<capacity..<grid.count {\n       \
    \     // Check if the current bucket is empty or has more water\n            if\
    \ grid[bucket][1] == 0 || grid[minBucket][1] < grid[bucket][0] { // bucket is\
    \ full\n                minBucket = bucket\n                break\n          \
    \  }\n        }\n        if minBucket > 0 {\n            // Remove the water from\
    \ minBucket to bucket and decrement the remaining water\n            grid[minBucket][1]--\n\
    \            if grid[minBucket][1] > 0 {\n                result++\n         \
    \       count++\n            }\n        }\n    }\n    return count", "    var\
    \ count = 0\n    var max = Int()\n    for _ in 1...capacity.sqrt() {\n       \
    \ for _ in 1...grid.len() {\n            if let w = grid[_,1].min(max) {\n   \
    \             max *= 10\n                count += w\n            }\n        }\n\
    \    }\n    return count", '    return 0', "    if grid.count == 0 || capacity\
    \ == 0 {\n        return 0\n    }\n    if capacity > grid[0].length {\n      \
    \  return -1\n    }\n    var numWells = grid.count\n    var count = 0\n    var\
    \ maxCapacity = capacity\n    for i in 0 ..< grid.count {\n        if maxCapacity\
    \ == 0 {\n            return 0\n        }\n        if grid[i][maxCapacity - 1]\
    \ == 0 {\n            numWells--\n        }\n        for j in 0 ..< maxCapacity\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][maxCapacity - 1]--\n\
    \                maxCapacity--\n                count++\n            } else {\n\
    \                break\n            }\n        }\n    }\n    return count", " \
    \   // write your code here\n    var result = 0\n    \n    for i in 0..<grid.length\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] > capacity\
    \ {\n                grid[i][j] = capacity - grid[i][j]\n                result\
    \ += capacity - grid[i][j]\n            }\n        }\n    }\n    \n    return\
    \ result", "    // start by creating an empty list of buckets\n    var buckets\
    \ = Array(capacity)\n    // loop through each row in grid\n    for row in grid\
    \ {\n        // loop through each bucket in buckets\n        for bucket in buckets\
    \ {\n            // if the bucket is full\n            if bucket.capacity >= row.length\
    \ {\n                // decrement the bucket capacities by row.length\n      \
    \          bucket.capacity -= row.length\n                // if the bucket is\
    \ now empty\n                if bucket.capacity == 0 {\n                    //\
    \ update the bucket with the right well and add it to the empty buckets\n    \
    \                bucket.well = row.well\n                    buckets[bucket.index]\
    \ = bucket\n                    // and return the bucket index \n            \
    \        return bucket.index\n                }\n            }\n        }\n  \
    \  }\n\n    // if there are no buckets left return zero\n    return 0", "    var\
    \ counter = 0\n    var minCounter = 0\n    for _ in 0..<grid.length {\n      \
    \  for _ in 0..<grid[0].length {\n            let currentBucket = grid[grid[0].length\
    \ - 1 - minCounter]\n            let currentWell = grid[grid[0].length - 1 - minCounter][grid[1].length\
    \ - 1 - minCounter]\n            \n            if currentBucket == 1 && currentWell\
    \ != 1 {\n                counter += 1\n            } else if currentBucket ==\
    \ 0 && currentWell == 1 {\n                counter += 1\n            }\n     \
    \       \n            if currentBucket != 0 && currentWell != 0 {\n          \
    \      counter += 1\n            }\n            \n            if currentBucket\
    \ == 0 && currentWell == 0 {\n                counter += 1\n            }\n  \
    \          \n            if currentBucket == 1 && currentWell == 0 {\n       \
    \         counter += 1\n            }\n            \n            if currentBucket\
    \ != 0 && currentWell == 1 {\n                counter += 1\n            }\n  \
    \          \n            if currentBucket == 1 && currentWell != 1 {\n       \
    \         counter += 1\n            }\n            \n            minCounter +=\
    \ 1\n        }\n    }\n    \n    return counter", "    if grid.isEmpty || capacity\
    \ < 1 {\n        return 0\n    }\n    var count = 0\n    var temp = 0\n    for\
    \ _ in 0..<(grid.length * grid.count()) {\n        let min = 0\n        for j\
    \ in 0..<(grid.count()) {\n            temp += grid[j][capacity]\n           \
    \ if temp > min {\n                min = temp\n            }\n        }\n    \
    \    count += min\n    }\n    return count", "  var max_flow = capacity - grid[0][0].capacity\n\
    \  for row in 0..<grid.count {\n    for col in 0..<row+1 {\n      let current\
    \ = grid[row][col].capacity\n      if current > max_flow {\n        max_flow =\
    \ current\n      }\n    }\n  }\n  return max_flow", "\tvar result = 0\n\t\n\t\
    for i in 0..<grid.count {\n\t\tgrid[i].sort()\n\t\t\n\t\tif capacity == 0 {\n\t\
    \t\tcontinue\n\t\t}\n\t\t\n\t\tif grid[i][len(grid[i])-1] == capacity {\n\t\t\t\
    result += capacity\n\t\t\tcapacity -= 1\n\t\t}\n\t\t\n\t\tif capacity == 0 {\n\
    \t\t\tcontinue\n\t\t}\n\t\t\n\t\tif grid[i][len(grid[i])-1] == 0 {\n\t\t\tresult\
    \ += capacity\n\t\t\tcapacity -= 1\n\t\t}\n\t}\n\t\n\treturn result", "\t\n\t\
    buckets := make([][]int, capacity+1)\n\ti := 0\n\tj := 0\n\tmaxCount := 0\n\t\
    buckets[0] = make([]int, capacity+1)\n\tbuckets[0][0] = capacity\n\tfor i < len(grid)\
    \ {\n\t\tfor j < len(grid[i]) {\n\t\t\tif grid[i][j] == 1 {\n\t\t\t\tbuckets[j][0]\
    \ = buckets[j][0] - 1\n\t\t\t\tif buckets[j][0] == 0 {\n\t\t\t\t\tbuckets[j] =\
    \ buckets[j][:1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuckets[j][0] = 0\n\t\t\t\
    }\n\t\t}\n\t\ti++\n\t\tmaxCount = max(maxCount, len(buckets)-1)\n\t\tj = 0\n\t\
    }\n\treturn maxCount", "\treturn solveMaxFillGreedy(grid, capacity)", "\t\n\t\
    guard capacity > 0 && capacity <= 10, grid[0]?.length == capacity, grid[1]?.length\
    \ == capacity else {\n\t\treturn 0\n\t}\n\t\n\t// 1. init a stack\n\tvar stack\
    \ = [Int]()\n\t\n\t// 2. add initial capacity.\n\tstack.append(0)\n\t\n\t// 3.\
    \ loop over each row in grid\n\tfor _ in 0 ..< grid[0]?.length {\n\t\t\n\t\t//\
    \ 4. append the current capacity.\n\t\tstack.append(0)\n\t\t\n\t\t// 5. loop over\
    \ each column\n\t\tfor _ in 0 ..< grid[1]?.length {\n\t\t\t\n\t\t\t// 6. if the\
    \ stack is empty, return 0\n\t\t\tif stack.contains(0) {\n\t\t\t\treturn 0\n\t\
    \t\t}\n\t\t\t\n\t\t\t// 7. if the current bucket is smaller than the top of stack\n\
    \t\t\t//    and it's capacity is less than or equal to capacity\n\t\t\t//    then\
    \ the bucket can not be used\n\t\t\tif stack[stack.count-1] < grid[0]?[stack.count-1]\n\
    \t\t\t\t&& grid[1]?[stack.count-1] <= capacity {\n\t\t\t\tstack[stack.count-1]\
    \ = 0\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t// 8. if the current bucket is\
    \ larger than the top of stack\n\t\t\t//    and it's capacity is larger than capacity\n\
    \t\t\t//    then all buckets are already full\n\t\t\tif stack[stack.count-1] >\
    \ grid[0]?[stack.count-1]\n\t\t\t\t&& stack[stack.count-1] <= capacity {\n\t\t\
    \t\treturn 0\n\t\t\t}\n\t\t\t\n\t\t\t// 9. otherwise, add the current bucket to\
    \ the stack\n\t\t\tstack[stack.count-1] += grid[0]?[stack.count-1]\n\t\t}\n\t\
    }\n\t\n\treturn stack.count", "    guard let n = grid.count else { return 0 }\n\
    \    guard n >= 1 else { return 0 }\n    \n    var max = 0\n    var x = 0\n  \
    \  var y = 0\n    var buckets = [Int](capacity)\n    \n    for y in 0 ..< n {\n\
    \        for x in 0 ..< n {\n            let value = grid[y][x]\n            buckets[value!]\
    \ = buckets[value!] + 1 || 1\n        }\n    }\n    for bucket in buckets {\n\
    \        if bucket > max { max = bucket }\n    }\n    return max", "    if grid[0].length\
    \ == 0 || grid[0][1] == 0 {\n        return 0\n    }\n    var n = 0\n    for rowIdx\
    \ in 0 ..< grid.count {\n        for colIdx in 0 ..< grid[rowIdx].count {\n  \
    \          if grid[rowIdx][colIdx] == 1 {\n                n += capacity - grid[rowIdx][colIdx\
    \ - 1]\n            }\n        }\n    }\n    return n", "    var max = 0 \n  \
    \  for i in 0..<grid.count {\n        let bucket = grid[i]\n        if bucket\
    \ < 0 {\n            bucket = 0\n        } else if bucket > max {\n          \
    \  max = bucket\n        }\n    }\n    return max", "    var n = 0\n    for i\
    \ in 0..<grid.count {\n        n += grid[i].count * capacity\n        if n ==\
    \ 0 {\n            return i\n        }\n    }\n    return 0", "    guard capacity\
    \ > 0 else { return 0 }\n    var res = 0\n    for row in 0..<grid.length {\n \
    \       for col in 0..<grid[row].length - 1 {\n            if grid[row][col] >\
    \ 0 {\n                if grid[row][col] != grid[row+1][col] {\n             \
    \       res += (max(capacity - grid[row][col], 1))\n                    grid[row][col]\
    \ = 0\n                }\n            }\n        }\n    }\n    return res", " \
    \   var index = 0\n    var minIndex = -1\n    for row in grid {\n        if row[1]\
    \ > minIndex {\n            minIndex = row[1]\n        }\n    }\n    for row in\
    \ grid {\n        if row[1] == minIndex {\n            index = index + 1\n   \
    \     }\n    }\n    return index", "    if grid.count != 0 { \n        return\
    \ 0 \n    }\n    var max = 0\n    var i : Int = 0\n    var j : Int = 0\n    var\
    \ l : Int = 0\n    for _i in range(0, grid[0].length) {\n        if capacity >\
    \ grid[0][_i+1] {\n            capacity = grid[0][_i+1]\n        }\n        if\
    \ capacity > grid[1][_i+1] {\n            capacity = grid[1][_i+1]\n        }\n\
    \        if capacity > grid[2][_i+1] {\n            capacity = grid[2][_i+1]\n\
    \        }\n        max = (capacity > max) ? capacity : max\n        if grid[0][_i+1]\
    \ == 0 {\n            i += 1 \n        }\n        if grid[1][_i+1] == 0 {\n  \
    \          j += 1 \n        }\n        if grid[2][_i+1] == 0 {\n            l\
    \ += 1 \n        }\n    }\n    return (max - (i+j+l)) % (capacity)"]
stop_tokens:
- "\n}"
