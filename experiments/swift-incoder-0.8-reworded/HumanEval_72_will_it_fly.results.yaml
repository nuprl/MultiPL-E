language: swift
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 { return true }\n    let max = sum(q)\n\
    \    return max <= w && is_balanced(q)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy7q84ayp.swift:19:15: error: cannot find 'sum' in scope\n    let\
    \ max = sum(q)\n              ^~~\n/tmp/tmpy7q84ayp.swift:20:24: error: cannot\
    \ find 'is_balanced' in scope\n    return max <= w && is_balanced(q)\n       \
    \                ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    if\
    \ q.count != 2 {\n        return false\n    }\n    var maxWeight = q[0] + q[1]\n\
    \    var maxCount = 0\n    var isPalindromic = false\n    var tempQ = q\n    for\
    \ pos in 0..<q.count {\n        let item = tempQ[pos]\n        if item < 0 {\n\
    \            return false\n        }\n        if item > maxWeight {\n        \
    \    maxWeight = item\n            maxCount = pos\n        } else if item == maxWeight\
    \ {\n            maxCount = pos + 1\n            if item > maxWeight {\n     \
    \           maxWeight = item\n                maxCount = pos\n            }\n\
    \        }\n    }\n    isPalindromic = maxCount <= w\n    return isPalindromic\
    \ && maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpzi0cfvc1/tmpzi0cfvc1.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1d066dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1d063d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1d063d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1d063d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzi0cfvc1                        0x00005626bb72753f <unavailable> + 5439

    5    libc.so.6                          0x00002b1d068c8460 __libc_start_main +
    245

    6    tmpzi0cfvc1                        0x00005626bb7271a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Write your code here.\n    return q == reverse(q.dropLast()).prefix(q.count).reverse()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo08uffng.swift:19:17: error: cannot find 'reverse' in scope\n \
    \   return q == reverse(q.dropLast()).prefix(q.count).reverse()\n            \
    \    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  return q.reduce(0, +) >= w && is_balanced(q)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpybf2rbls.swift:18:33: error: cannot find 'is_balanced' in scope\n\
    \  return q.reduce(0, +) >= w && is_balanced(q)\n                            \
    \    ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w, w != 0, min(q).isPalindrome else\
    \ {\n        return false\n    }\n\n    let reversedQ = q.map { $0 }.reversed()\n\
    \n    if let last = reversedQ.last {\n        if last != q[0] {\n            if\
    \ last > w {\n                return false\n            } else if q.isEmpty {\n\
    \                return true\n            } else {\n                return !q.isEmpty\
    \ && q[0] == last\n            }\n        }\n    }\n\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpypsc90gl.swift:18:38: error: missing argument for parameter #2\
    \ in call\n    guard q.count == w, w != 0, min(q).isPalindrome else {\n      \
    \                               ^\n                                     , <#[Int]#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpypsc90gl.swift:18:40:\
    \ error: value of type '[Int]' has no member 'isPalindrome'\n    guard q.count\
    \ == w, w != 0, min(q).isPalindrome else {\n                                ~~~~~~\
    \ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Your code here\n    \n    guard q.count == w && w\
    \ > 0 else { return false }\n    guard q.sorted == true && q.last == q.first \
    \ else { return false }\n    guard q.first > q.last  else { return false }\n \
    \   var maxWeight = q.last\n    for index in stride(from: q.first + 1, to: q.count\
    \ - 1, by: -1) {\n        if index < maxWeight - w || index > maxWeight - w*2\
    \ {\n            maxWeight += w\n        } else {\n            return false\n\
    \        }\n    }\n    return maxWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpddtf7ujl.swift:21:13: error: cannot convert value of type '() ->\
    \ [Int]' to expected argument type 'Bool'\n    guard q.sorted == true && q.last\
    \ == q.first  else { return false }\n            ^\n/tmp/tmpddtf7ujl.swift:22:19:\
    \ error: binary operator '>' cannot be applied to two 'Int?' operands\n    guard\
    \ q.first > q.last  else { return false }\n          ~~~~~~~ ^ ~~~~~~\n/tmp/tmpddtf7ujl.swift:22:19:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    guard q.first > q.last  else { return false }\n            \
    \      ^\n/tmp/tmpddtf7ujl.swift:24:33: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    for index in stride(from: q.first\
    \ + 1, to: q.count - 1, by: -1) {\n                                ^\n/tmp/tmpddtf7ujl.swift:24:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    for index in stride(from: q.first + 1, to: q.count - 1, by: -1) {\n\
    \                                ^\n                              (       ?? <#default\
    \ value#>)\n/tmp/tmpddtf7ujl.swift:24:33: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    for index in stride(from:\
    \ q.first + 1, to: q.count - 1, by: -1) {\n                                ^\n\
    \                                     !\n/tmp/tmpddtf7ujl.swift:31:12: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \   return maxWeight <= w\n           ^\n/tmp/tmpddtf7ujl.swift:31:12: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return maxWeight <= w\n           ^\n                     ?? <#default value#>\n\
    /tmp/tmpddtf7ujl.swift:31:12: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    return maxWeight <= w\n          \
    \ ^\n                    !\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && will_it_fly_helper(q, w)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcjtj49t_.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && will_it_fly_helper(q, w)\n           ^~~~~~~~~~~\n\
    /tmp/tmpcjtj49t_.swift:18:30: error: cannot find 'will_it_fly_helper' in scope\n\
    \    return is_balanced(q) && will_it_fly_helper(q, w)\n                     \
    \        ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard !q.isEmpty else {\n        // q is empty, so there\
    \ is no way it can fly.\n        return true\n    }\n\n    let min = q.min()!\n\
    \    let max = q.max()!\n    let diff = max - min\n    var totalWeight = 0\n \
    \   \n    for i in 0..<q.count {\n        let curr = q[i]\n        let curWeight\
    \ = curr * w\n        \n        if curWeight <= max {\n            totalWeight\
    \ += curWeight\n        } else if totalWeight > w {\n            // It is not\
    \ balanced because the total weight is more than the weight. \n            //\
    \ The last weight cannot be less than the maximum, so it cannot fly.\n       \
    \     return false\n        }\n    }\n    \n    // We assume that totalWeight\
    \ is less than w, and thus, it must fly.\n    return totalWeight <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbjbhu3h1/tmpbjbhu3h1.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba28c5b8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba28c2afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba28c2af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba28c2ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbjbhu3h1                        0x000055799a8c878b <unavailable> + 6027

    5    libc.so.6                          0x00002ba28c7a4460 __libc_start_main +
    245

    6    tmpbjbhu3h1                        0x000055799a8c8339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let max_weight = w\n    guard q.count == w else { return\
    \ false }\n\n    guard max_weight > 0 else {\n        let p = q.count/2\n    \
    \    let left  = q[0 ..< p].reversed()\n        let right = q[p ..< q.count]\n\
    \        return left.count == w && right.count == w && right.iter().reduce(0)\
    \ { $0 + $1 } <= max_weight\n    }\n\n    guard let m = q.max else { return false\
    \ }\n    return q.iter().reduce(0) { $0 + $1 } <= max_weight\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3czgjg33.swift:25:61: error: value of type 'ArraySlice<Int>' has\
    \ no member 'iter'\n        return left.count == w && right.count == w && right.iter().reduce(0)\
    \ { $0 + $1 } <= max_weight\n                                                \
    \      ~~~~~ ^~~~\n/tmp/tmp3czgjg33.swift:28:21: warning: use of 'max' treated\
    \ as a reference to instance method in protocol 'Sequence'\n    guard let m =\
    \ q.max else { return false }\n                    ^\nSwift.Sequence:5:28: note:\
    \ 'max()' declared here\n    @inlinable public func max() -> Self.Element?\n \
    \                          ^\n/tmp/tmp3czgjg33.swift:28:21: note: use 'self.'\
    \ to silence this warning\n    guard let m = q.max else { return false }\n   \
    \                 ^\n                    self.\n/tmp/tmp3czgjg33.swift:28:21:\
    \ note: use 'Swift.' to reference the global function\n    guard let m = q.max\
    \ else { return false }\n                    ^\n                    Swift.\n/tmp/tmp3czgjg33.swift:28:11:\
    \ error: initializer for conditional binding must have Optional type, not '()\
    \ -> Int?'\n    guard let m = q.max else { return false }\n          ^       ~~~~~\n\
    /tmp/tmp3czgjg33.swift:29:14: error: value of type '[Int]' has no member 'iter'\n\
    \    return q.iter().reduce(0) { $0 + $1 } <= max_weight\n           ~ ^~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var left = 0\n    var right = 0\n    var balanced = 0\n\
    \    for x in q {\n        left += x\n        balanced += x\n    }\n    for x\
    \ in q.reversed() {\n        right += x\n        balanced += x\n    }\n    return\
    \ balanced <= w && balanced <= left + right\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpketfa5h9/tmpketfa5h9.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b592f690c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b592f387b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b592f387988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b592f3867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpketfa5h9                        0x000055dca811166f <unavailable> + 5743

    5    libc.so.6                          0x00002b592f87c460 __libc_start_main +
    245

    6    tmpketfa5h9                        0x000055dca81112d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && max_possible_w(w) == sum(q)\
    \ <= max_weight(q)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpytqsc1ji.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && max_possible_w(w) == sum(q) <= max_weight(q)\n \
    \          ^~~~~~~~~~~\n/tmp/tmpytqsc1ji.swift:18:30: error: cannot find 'max_possible_w'\
    \ in scope\n    return is_balanced(q) && max_possible_w(w) == sum(q) <= max_weight(q)\n\
    \                             ^~~~~~~~~~~~~~\n/tmp/tmpytqsc1ji.swift:18:51: error:\
    \ cannot find 'sum' in scope\n    return is_balanced(q) && max_possible_w(w) ==\
    \ sum(q) <= max_weight(q)\n                                                  ^~~\n\
    /tmp/tmpytqsc1ji.swift:18:61: error: cannot find 'max_weight' in scope\n    return\
    \ is_balanced(q) && max_possible_w(w) == sum(q) <= max_weight(q)\n           \
    \                                                 ^~~~~~~~~~\n/tmp/tmpytqsc1ji.swift:18:48:\
    \ error: adjacent operators are in non-associative precedence group 'ComparisonPrecedence'\n\
    \    return is_balanced(q) && max_possible_w(w) == sum(q) <= max_weight(q)\n \
    \                                              ^         ~~\n/tmp/tmpytqsc1ji.swift:18:58:\
    \ error: binary operator '<=' cannot be applied to operands of type 'Bool' and\
    \ '()'\n    return is_balanced(q) && max_possible_w(w) == sum(q) <= max_weight(q)\n\
    \                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~\n/tmp/tmpytqsc1ji.swift:18:58:\
    \ note: overloads for '<=' exist with these partially matching parameter lists:\
    \ ((), ()), (Int, Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8,\
    \ Int8), (TaskPriority, TaskPriority), (UInt, UInt), (UInt16, UInt16), (UInt32,\
    \ UInt32), (UInt64, UInt64), (UInt8, UInt8)\n    return is_balanced(q) && max_possible_w(w)\
    \ == sum(q) <= max_weight(q)\n                                               \
    \          ^\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    var\
    \ weight: Int = 0\n    var sum: Int = 0\n    for x in q {\n        weight += x\n\
    \        sum += x\n    }\n    if sum < 0 {\n        return false\n    }\n    sum\
    \ *= w\n    if weight > w {\n        return false\n    }\n    weight -= w\n  \
    \  var i = 0\n    var j = 0\n    for i := 0; i < len(q); i++ {\n        if q[i]\
    \ > q[j] {\n            return false\n        }\n        j++\n        if j >=\
    \ len(q) {\n            break\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp79ju6_fq.swift:37:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmp79ju6_fq.swift:37:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmp79ju6_fq.swift:37:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let sumOfWeights = q.sum() ??\
    \ 0\n    \n    return sumOfWeights <= maxWeight\n        && q.isPalindrome()\n\
    \        && q.reduce(0) { $0 + $1 } == maxWeight\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1rts2tl7.swift:19:26: error: value of type '[Int]' has no member\
    \ 'sum'\n    let sumOfWeights = q.sum() ?? 0\n                       ~ ^~~\n/tmp/tmp1rts2tl7.swift:22:14:\
    \ error: value of type '[Int]' has no member 'isPalindrome'\n        && q.isPalindrome()\n\
    \           ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    for x in q {\n        guard w >= x else { return false\
    \ }\n    }\n    let maxWeight = 2 * w - q.sum\n    if q.count == 0 { return true\
    \ }\n    if maxWeight <= q.last { return true }\n    for x in q {\n        guard\
    \ maxWeight >= x else { return false }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpxsbanifw.swift:21:31: error: value of type '[Int]' has no member\
    \ 'sum'\n    let maxWeight = 2 * w - q.sum\n                            ~ ^~~\n\
    /tmp/tmpxsbanifw.swift:23:23: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n    if maxWeight <= q.last { return true }\n     \
    \                 ^\n/tmp/tmpxsbanifw.swift:23:23: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    if maxWeight <=\
    \ q.last { return true }\n                      ^\n                          \
    \ ?? <#default value#>\n/tmp/tmpxsbanifw.swift:23:23: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    if maxWeight\
    \ <= q.last { return true }\n                      ^\n                       \
    \   !\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum: Int = 0\n    for element in q {\n        sum\
    \ += element\n    }\n    return sum < w && is_balanced(q)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9yxzyk08.swift:22:23: error: cannot find 'is_balanced' in scope\n\
    \    return sum < w && is_balanced(q)\n                      ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for x in q {\n        sum += x\n   \
    \ }\n\n    if sum < w {\n        return false\n    }\n\n    if sum == w {\n  \
    \      for x = x; x <= w; x += x {\n            if q[x-x] != q[x] {\n        \
    \        return false\n            }\n        }\n        return true\n    }\n\n\
    \    var i = q.startIndex\n    for x = 0; x <= w; x += x {\n        if q[x-x]\
    \ != q[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1_346sqr.swift:28:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for x = x; x <= w; x += x {\n        ^   ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1_346sqr.swift:37:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for x = 0; x <= w; x += x {\n    ^   ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Base case\n    if q.isEmpty {\n        return true\n\
    \    }\n    // Recursion\n    var w1 = w\n    for x := q.first - 1; x != IntMax;\
    \ x-- {\n        var w = w1\n        if x < q.last {\n            w += q[x]\n\
    \        }\n        if w > w {\n            return false\n        }\n    }\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5iug34sv.swift:24:12: error: expected type\n    for x := q.first\
    \ - 1; x != IntMax; x-- {\n           ^\n            <#type#>\n/tmp/tmp5iug34sv.swift:24:12:\
    \ error: expected 'in' after for-each pattern\n    for x := q.first - 1; x !=\
    \ IntMax; x-- {\n           ^\n/tmp/tmp5iug34sv.swift:24:12: error: expected Sequence\
    \ expression for for-each loop\n    for x := q.first - 1; x != IntMax; x-- {\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  var max_weight_sum = 0\n  var palindromic = false\n  for\
    \ i : Int in 0..<q.count {\n    max_weight_sum = max(max_weight_sum + q[i], w)\n\
    \    if max_weight_sum >= w {\n      palindromic = true\n    }\n  }\n  return\
    \ palindromic\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpn6c_c8u1/tmpn6c_c8u1.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f415f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f412edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f412ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f412ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn6c_c8u1                        0x000055bbbf15268b <unavailable> + 5771

    5    libc.so.6                          0x00002b4f417e2460 __libc_start_main +
    245

    6    tmpn6c_c8u1                        0x000055bbbf152239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 0 else {\n        return false\n    }\n\
    \    guard q.count == 1 else {\n        return true\n    }\n    return isBalanced(q)\
    \ && sum(q) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmr24s9vg.swift:24:12: error: cannot find 'isBalanced' in scope\n\
    \    return isBalanced(q) && sum(q) <= w\n           ^~~~~~~~~~\n/tmp/tmpmr24s9vg.swift:24:29:\
    \ error: cannot find 'sum' in scope\n    return isBalanced(q) && sum(q) <= w\n\
    \                            ^~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return w == 0 || is_balanced(q) && sum_of_elements(q)\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmps1bpv4zs.swift:18:22: error: cannot find 'is_balanced' in scope\n\
    \    return w == 0 || is_balanced(q) && sum_of_elements(q) <= w\n            \
    \         ^~~~~~~~~~~\n/tmp/tmps1bpv4zs.swift:18:40: error: cannot find 'sum_of_elements'\
    \ in scope\n    return w == 0 || is_balanced(q) && sum_of_elements(q) <= w\n \
    \                                      ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Write your code here\n    return is_balanced_fly(q)\
    \ && sum_fly_elements(q) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0pu0rrre.swift:19:12: error: cannot find 'is_balanced_fly' in scope\n\
    \    return is_balanced_fly(q) && sum_fly_elements(q) <= w\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmp0pu0rrre.swift:19:34: error: cannot find 'sum_fly_elements' in scope\n\
    \    return is_balanced_fly(q) && sum_fly_elements(q) <= w\n                 \
    \                ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Check balanced first\n    if !is_balanced(q) {\n \
    \       return false\n    }\n\n    // If sum of its elements is equal to maximum\
    \ possible weight, it's balanced.\n    if q == max_possible_weight(w) {\n    \
    \    return true\n    }\n\n    // Otherwise, it's unbalanced.\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6k5dz0v6.swift:19:9: error: cannot find 'is_balanced' in scope\n\
    \    if !is_balanced(q) {\n        ^~~~~~~~~~~\n/tmp/tmp6k5dz0v6.swift:24:13:\
    \ error: cannot find 'max_possible_weight' in scope\n    if q == max_possible_weight(w)\
    \ {\n            ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let b = balance(q)\n    guard b else {\n        return\
    \ false\n    }\n    return will_it_fly_recursive(b, b, w)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx7g4_l21.swift:18:13: error: cannot find 'balance' in scope\n \
    \   let b = balance(q)\n            ^~~~~~~\n/tmp/tmpx7g4_l21.swift:22:12: error:\
    \ cannot find 'will_it_fly_recursive' in scope\n    return will_it_fly_recursive(b,\
    \ b, w)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sums = q.map(|i| i * i)\n    return sums.last <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn1svuzlk.swift:18:26: error: expected ',' separator\n    let sums\
    \ = q.map(|i| i * i)\n                         ^\n                        ,\n\
    /tmp/tmpn1svuzlk.swift:18:22: error: '|' is not a prefix unary operator\n    let\
    \ sums = q.map(|i| i * i)\n                     ^\n/tmp/tmpn1svuzlk.swift:18:24:\
    \ error: '|' is not a postfix unary operator\n    let sums = q.map(|i| i * i)\n\
    \                       ^\n/tmp/tmpn1svuzlk.swift:18:23: error: cannot find 'i'\
    \ in scope\n    let sums = q.map(|i| i * i)\n                      ^\n/tmp/tmpn1svuzlk.swift:18:26:\
    \ error: cannot find 'i' in scope\n    let sums = q.map(|i| i * i)\n         \
    \                ^\n/tmp/tmpn1svuzlk.swift:18:30: error: cannot find 'i' in scope\n\
    \    let sums = q.map(|i| i * i)\n                             ^\n/tmp/tmpn1svuzlk.swift:18:28:\
    \ error: extra argument in call\n    let sums = q.map(|i| i * i)\n           \
    \         ~~~~~~~^~~~\n/tmp/tmpn1svuzlk.swift:18:16: error: generic parameter\
    \ 'T' could not be inferred\n    let sums = q.map(|i| i * i)\n               ^\n\
    Swift.Collection:2:28: note: in call to function 'map'\n    @inlinable public\
    \ func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n     \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return will_it_fly(q, w, 0, \"\")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwh41h7qy.swift:18:23: error: extra arguments at positions #3, #4\
    \ in call\n    return will_it_fly(q, w, 0, \"\")\n                      ^\n/tmp/tmpwh41h7qy.swift:17:6:\
    \ note: 'will_it_fly(q:w:)' declared here\nfunc will_it_fly(q: [Int], w: Int)\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n\n    // Write your code here.\n    return q.isPalindromic && w.isLessOrEqualTo(w.reduce(0,\
    \ combine: +))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjmiz2_km.swift:23:14: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    return q.isPalindromic && w.isLessOrEqualTo(w.reduce(0,\
    \ combine: +))\n           ~ ^~~~~~~~~~~~~\n/tmp/tmpjmiz2_km.swift:23:33: error:\
    \ value of type 'Int' has no member 'isLessOrEqualTo'\n    return q.isPalindromic\
    \ && w.isLessOrEqualTo(w.reduce(0, combine: +))\n                            \
    \  ~ ^~~~~~~~~~~~~~~\n/tmp/tmpjmiz2_km.swift:23:51: error: value of type 'Int'\
    \ has no member 'reduce'\n    return q.isPalindromic && w.isLessOrEqualTo(w.reduce(0,\
    \ combine: +))\n                                                ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if will_it_fly_recursion(q: q, w: w) {\n        return\
    \ true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnh_l9tjd.swift:18:8: error: cannot find 'will_it_fly_recursion'\
    \ in scope\n    if will_it_fly_recursion(q: q, w: w) {\n       ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for element in q {\n        sum += element\n\
    \    }\n\n    return sum == w && is_balanced(q)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvc249en3.swift:23:24: error: cannot find 'is_balanced' in scope\n\
    \    return sum == w && is_balanced(q)\n                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.count == 1 && q[0] == w\n        || (q.count\
    \ >= 2 && w.is_power_of_two() && is_balanced(q, w))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy9ykqv__.swift:19:52: error: cannot find 'is_balanced' in scope\n\
    \        || (q.count >= 2 && w.is_power_of_two() && is_balanced(q, w))\n     \
    \                                              ^~~~~~~~~~~\n/tmp/tmpy9ykqv__.swift:19:31:\
    \ error: value of type 'Int' has no member 'is_power_of_two'\n        || (q.count\
    \ >= 2 && w.is_power_of_two() && is_balanced(q, w))\n                        \
    \    ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Only palindromes are possible with w=1 and the sum\
    \ of its elements is less than or equal to w.\n    if q.isEmpty || (q.isEmpty\
    \ && w == 1) || w > q.last { return false }\n    let max_sum = w * q[q.count-1]\n\
    \    for i in 0..<(q.count/2-1) {\n        if q[i*2+1] > max_sum {\n         \
    \   return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7moxv3cv.swift:19:52: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if q.isEmpty || (q.isEmpty && w ==\
    \ 1) || w > q.last { return false }\n                                        \
    \           ^\n/tmp/tmp7moxv3cv.swift:19:52: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    if q.isEmpty || (q.isEmpty\
    \ && w == 1) || w > q.last { return false }\n                                \
    \                   ^\n                                                      \
    \  ?? <#default value#>\n/tmp/tmp7moxv3cv.swift:19:52: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    if q.isEmpty\
    \ || (q.isEmpty && w == 1) || w > q.last { return false }\n                  \
    \                                 ^\n                                        \
    \               !\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return false\n \
    \   }\n    \n    var maxWeight = w\n    for i : Int in 0..<q.count {\n       \
    \ if maxWeight > q[i] {\n            maxWeight = q[i]\n        }\n    }\n    \n\
    \    if maxWeight < w {\n        return false\n    }\n    \n    var reversedQ\
    \ = q\n    var reversedQSize = q.count\n    for i : Int in 0..<reversedQSize {\n\
    \        reversedQ[i] = reversedQ[reversedQSize-i-1]\n    }\n    \n    var sum\
    \ : Int = 0\n    for i : Int in 0..<reversedQSize {\n        sum += reversedQ[i]\n\
    \    }\n    return sum <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpk26dcmio/tmpk26dcmio.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7866207c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7865efeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7865efe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7865efd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk26dcmio                        0x000055f0be0c758f <unavailable> + 5519

    5    libc.so.6                          0x00002b78663f3460 __libc_start_main +
    245

    6    tmpk26dcmio                        0x000055f0be0c71f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    let balanced = is_balanced(q)\n\
    \    return (balanced && checkSum(q) <= maxWeight)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpi26o0mi9.swift:19:20: error: cannot find 'is_balanced' in scope\n\
    \    let balanced = is_balanced(q)\n                   ^~~~~~~~~~~\n/tmp/tmpi26o0mi9.swift:20:25:\
    \ error: cannot find 'checkSum' in scope\n    return (balanced && checkSum(q)\
    \ <= maxWeight)\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014645
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var q = q.sort()\n    if q.count == 0 || w == 0 {\n \
    \       return true\n    }\n    \n    if q[0] != 0 {\n        return false\n \
    \   }\n    var sum = 0\n    var max = 0\n    \n    for index in 0..<(q.count -\
    \ 1) {\n        if sum + q[index] <= w {\n            sum += q[index]\n      \
    \  } else {\n            if max <= sum + q[index] {\n                max = sum\
    \ + q[index]\n            }\n        }\n    }\n    \n    return max >= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfwk19s_r.swift:18:15: error: cannot use mutating member on immutable\
    \ value: 'q' is a 'let' constant\n    var q = q.sort()\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  var maxSum = w\n  // If the sum of elements in the array\
    \ is greater than the weight w (balanced), it won't fly.\n  if maxSum > q.reduce(0)\
    \ { $0 + $1 }  {\n    return false\n  }\n  // If the sum of elements in the array\
    \ is equal to the weight w (unbalanced), it won't fly.\n  if maxSum == q.reduce(0)\
    \ { $0 + $1 }  {\n    return true\n  }\n  \n  var currentMaxSum = q.reduce(0)\
    \ { $0 + $1 }\n  var nextSum = 0\n  for _ in 0 ..< q.count {\n    if maxSum ==\
    \ currentMaxSum {\n      return false\n    }\n    nextSum += q[q.count-1]\n  \
    \  if nextSum > maxSum {\n      currentMaxSum = nextSum\n      maxSum = w\n  \
    \  }\n    q.remove(at: q.count - 1)\n  }\n  return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb6mm_syy.swift:20:27: warning: trailing closure in this context\
    \ is confusable with the body of the statement; pass as a parenthesized argument\
    \ to silence this warning\n  if maxSum > q.reduce(0) { $0 + $1 }  {\n        \
    \                ~~^\n                        ,            )\n/tmp/tmpb6mm_syy.swift:24:28:\
    \ warning: trailing closure in this context is confusable with the body of the\
    \ statement; pass as a parenthesized argument to silence this warning\n  if maxSum\
    \ == q.reduce(0) { $0 + $1 }  {\n                         ~~^\n              \
    \           ,            )\n/tmp/tmpb6mm_syy.swift:39:7: error: cannot use mutating\
    \ member on immutable value: 'q' is a 'let' constant\n    q.remove(at: q.count\
    \ - 1)\n    ~ ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && w <= q.sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqels3mgx.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && w <= q.sum\n           ^~~~~~~~~~~\n/tmp/tmpqels3mgx.swift:18:37:\
    \ error: value of type '[Int]' has no member 'sum'\n    return is_balanced(q)\
    \ && w <= q.sum\n                                  ~ ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.fold(0, combine: +)\n    return max > sum\
    \ && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpno_iufrw.swift:18:17: error: value of type '[Int]' has no member\
    \ 'fold'\n    let sum = q.fold(0, combine: +)\n              ~ ^~~~\n/tmp/tmpno_iufrw.swift:19:16:\
    \ error: binary operator '>' cannot be applied to operands of type '(_, _) ->\
    \ _' and '_'\n    return max > sum && sum <= w\n           ~~~ ^ ~~~\n/tmp/tmpno_iufrw.swift:19:12:\
    \ error: generic parameter 'T' could not be inferred\n    return max > sum &&\
    \ sum <= w\n           ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxSum = w * w\n    return q.reversed().reduce(0)\
    \ {\n        $0 + $1 < maxSum ? $0 + $1 < $1 : $0 < maxSum\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpciub2z85.swift:19:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return q.reversed().reduce(0) {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014691
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    \n    let mut w = w\n    let mut max_sum = 0\n    for i in 0..<q.count\
    \ {\n        if q[i] != q[q.count - 1 - i] {\n            return false\n     \
    \   }\n        max_sum += q[i]\n    }\n    if max_sum >= w {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpaqu_0c8v.swift:22:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut w = w\n\
    \            ^\n/tmp/tmpaqu_0c8v.swift:22:13: note: join the identifiers together\n\
    \    let mut w = w\n        ~~~~^\n        mutw\n/tmp/tmpaqu_0c8v.swift:22:13:\
    \ note: join the identifiers together with camel-case\n    let mut w = w\n   \
    \     ~~~~^\n        mutW\n/tmp/tmpaqu_0c8v.swift:23:13: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \   let mut max_sum = 0\n            ^\n/tmp/tmpaqu_0c8v.swift:23:13: note: join\
    \ the identifiers together\n    let mut max_sum = 0\n        ~~~~^~~~~~~\n   \
    \     mutmax_sum\n/tmp/tmpaqu_0c8v.swift:23:13: note: join the identifiers together\
    \ with camel-case\n    let mut max_sum = 0\n        ~~~~^~~~~~~\n        mutMax_sum\n\
    /tmp/tmpaqu_0c8v.swift:23:9: error: invalid redeclaration of 'mut'\n    let mut\
    \ max_sum = 0\n        ^\n/tmp/tmpaqu_0c8v.swift:22:9: note: 'mut' previously\
    \ declared here\n    let mut w = w\n        ^\n/tmp/tmpaqu_0c8v.swift:28:9: error:\
    \ cannot find 'max_sum' in scope\n        max_sum += q[i]\n        ^~~~~~~\n/tmp/tmpaqu_0c8v.swift:30:8:\
    \ error: cannot find 'max_sum' in scope\n    if max_sum >= w {\n       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return false\n    }\n    var\
    \ total = 0\n    for number in q {\n        total += number\n    }\n    if total\
    \ > w {\n        return false\n    }\n    if total == w {\n        return true\n\
    \    }\n    let left = q.prefix(q.count - 1)\n    let right = q.suffix(q.count)\n\
    \    return will_it_fly(left, w) && will_it_fly(right, w)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp13fypjxi.swift:33:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(left, w) && will_it_fly(right, w)\n           \
    \           ^\n                       q:    w: \n/tmp/tmp13fypjxi.swift:33:24:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    return will_it_fly(left, w) && will_it_fly(right, w)\n        \
    \               ^\n/tmp/tmp13fypjxi.swift:33:47: error: missing argument labels\
    \ 'q:w:' in call\n    return will_it_fly(left, w) && will_it_fly(right, w)\n \
    \                                             ^\n                            \
    \                   q:     w: \n/tmp/tmp13fypjxi.swift:33:48: error: cannot convert\
    \ value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return\
    \ will_it_fly(left, w) && will_it_fly(right, w)\n                            \
    \                   ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var a = q\n    let mut b = q.len()\n\n    while b > 0\
    \ {\n        let c = b / 2\n        a = a.prefix(b - c)\n        b = c\n    }\n\
    \n    a = a.prefix(b).reversed()\n    if a.isEmpty || a.first >= w {\n       \
    \ return true\n    }\n\n    for i in 0..<(w / a.first).magnitude() {\n       \
    \ guard let a = a.suffix(i + 1) else { return false }\n\n        for j in 0..<(w\
    \ / a.first).magnitude() {\n            let k = i + j + k\n            if k >=\
    \ 0 && k <= a.first && a[k] != a[k].reversed {\n                return false\n\
    \            }\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpi_ioq2t3.swift:19:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut b = q.len()\n\
    \            ^\n/tmp/tmpi_ioq2t3.swift:19:13: note: join the identifiers together\n\
    \    let mut b = q.len()\n        ~~~~^\n        mutb\n/tmp/tmpi_ioq2t3.swift:19:13:\
    \ note: join the identifiers together with camel-case\n    let mut b = q.len()\n\
    \        ~~~~^\n        mutB\n/tmp/tmpi_ioq2t3.swift:19:19: error: value of type\
    \ '[Int]' has no member 'len'\n    let mut b = q.len()\n                ~ ^~~\n\
    /tmp/tmpi_ioq2t3.swift:21:11: error: cannot find 'b' in scope\n    while b > 0\
    \ {\n          ^\n/tmp/tmpi_ioq2t3.swift:22:17: error: cannot find 'b' in scope\n\
    \        let c = b / 2\n                ^\n/tmp/tmpi_ioq2t3.swift:23:22: error:\
    \ cannot find 'b' in scope\n        a = a.prefix(b - c)\n                    \
    \ ^\n/tmp/tmpi_ioq2t3.swift:23:15: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n        a = a.prefix(b - c)\n            ~~^~~~~~~~~~~~~\n\
    /tmp/tmpi_ioq2t3.swift:23:24: error: cannot convert value of type 'Duration' to\
    \ expected argument type 'Int'\n        a = a.prefix(b - c)\n                \
    \       ^\n/tmp/tmpi_ioq2t3.swift:24:9: error: cannot find 'b' in scope\n    \
    \    b = c\n        ^\n/tmp/tmpi_ioq2t3.swift:27:18: error: cannot find 'b' in\
    \ scope\n    a = a.prefix(b).reversed()\n                 ^\n/tmp/tmpi_ioq2t3.swift:28:23:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    if a.isEmpty || a.first >= w {\n                      ^\n/tmp/tmpi_ioq2t3.swift:28:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if a.isEmpty || a.first >= w {\n                      ^\n       \
    \                     ?? <#default value#>\n/tmp/tmpi_ioq2t3.swift:28:23: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    if a.isEmpty || a.first >= w {\n                      ^\n               \
    \            !\n/tmp/tmpi_ioq2t3.swift:32:19: error: cannot convert value of type\
    \ 'Int' to expected argu"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && sum(q) <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7mbwti8d.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && sum(q) <= w\n           ^~~~~~~~~~~\n/tmp/tmp7mbwti8d.swift:18:30:\
    \ error: cannot find 'sum' in scope\n    return is_balanced(q) && sum(q) <= w\n\
    \                             ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = w\n    for el in q {\n        if el > max {\n\
    \            max = el\n        }\n    }\n    let sum = q.sum()\n    return max\
    \ <= sum && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8pdchnra.swift:24:17: error: value of type '[Int]' has no member\
    \ 'sum'\n    let sum = q.sum()\n              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    for i := 0; i < len(q); i++ {\n        let j = i\n  \
    \      let sum = 0\n        for (; i < len(q) && j < len(q) && q[i] == q[j] &&\
    \ (q[i] + sum) <= w; j++ ) {\n            sum += q[i]\n        }\n        if j\
    \ == len(q) {\n            return true\n        }\n    }\n    return false\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpht8z0t4d.swift:18:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpht8z0t4d.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpht8z0t4d.swift:18:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n/tmp/tmpht8z0t4d.swift:21:9:\
    \ error: C-style for statement has been removed in Swift 3\n        for (; i <\
    \ len(q) && j < len(q) && q[i] == q[j] && (q[i] + sum) <= w; j++ ) {\n       \
    \ ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n\n    var sum = 0\n    for i in 0..<q.count {\n        sum += q[i]\n    }\n\
    \n    if sum >= w {\n        return true\n    }\n\n    var qRev: [Int] = []\n\
    \    var isPalindromic = false\n\n    for i in 0..<q.count {\n        qRev.insert(q[i],\
    \ i)\n    }\n\n    let startIndex = qRev.startIndex\n    let endIndex = qRev.endIndex\n\
    \n    // If either start or end is 0, then it's a palindrome.\n    if startIndex\
    \ == 0 || endIndex == 0 {\n        isPalindromic = true\n    }\n\n    // If either\
    \ end is less than or equal to start, then it's a palindrome.\n    if endIndex\
    \ <= startIndex {\n        isPalindromic = true\n    }\n\n    // If either start\
    \ or end is equal to the length of the array, then it's a palindrome.\n    if\
    \ endIndex == q.count {\n        isPalindromic = true\n    }\n\n    // If either\
    \ start or end is equal to the length of the array-1, then it's a palindrome.\n\
    \    if endIndex == q.count-1 {\n        isPalindromic = true\n    }\n\n    //\
    \ If the sum of the elements is equal to the max possible weight, it's a palindrome.\n\
    \    if sum == w {\n        isPalindromic = true\n    }\n\n    // If the sum of\
    \ the elements is less than the max possible weight, it's a palindrome.\n    if\
    \ sum < w {\n        isPalindromic = true\n    }\n\n    return isPalindromic\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwj1rc_tg.swift:35:14: error: no exact matches in call to instance\
    \ method 'insert'\n        qRev.insert(q[i], i)\n             ^\nSwift.Array:11:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Element, at\
    \ i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\treturn will_it_fly_recursive(q: q, w: w, maxWeight: Int.max)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfwrttdoc.swift:18:9: error: cannot find 'will_it_fly_recursive'\
    \ in scope\n        return will_it_fly_recursive(q: q, w: w, maxWeight: Int.max)\n\
    \               ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q ~= q.reversed() else { return false }\n    guard\
    \ q.count == 0 || (q.count == 1 && q[0] == w) else { return false }\n    guard\
    \ q.max() <= w else { return false }\n    var wmax = w\n    var wsum = 0\n   \
    \ for i in q {\n        wsum += i\n        wmax = max(wsum, wmax)\n    }\n   \
    \ return wsum <= wmax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpugx7sx5z.swift:20:13: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard q.max() <= w else { return\
    \ false }\n            ^\n/tmp/tmpugx7sx5z.swift:20:13: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    guard q.max()\
    \ <= w else { return false }\n            ^\n                  ?? <#default value#>\n\
    /tmp/tmpugx7sx5z.swift:20:13: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    guard q.max() <= w else { return false\
    \ }\n            ^\n                 !\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count >= w else { return false }\n\n    let maxWeight\
    \ = Array(w.prefix(q.count))\n    let sumWeight = w.prefix(q.count).reduce(0)\
    \ { $0 + $1 }\n    return maxWeight.map { $0 == sumWeight }\n        .reduce(false)\
    \ { $0 && !$1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcor7zlyl.swift:20:29: error: value of type 'Int' has no member\
    \ 'prefix'\n    let maxWeight = Array(w.prefix(q.count))\n                   \
    \       ~ ^~~~~~\n/tmp/tmpcor7zlyl.swift:21:23: error: value of type 'Int' has\
    \ no member 'prefix'\n    let sumWeight = w.prefix(q.count).reduce(0) { $0 + $1\
    \ }\n                    ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return false\n \
    \   }\n    if will_it_fly(q: q.reverse(), w: w) {\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2kjovi1i.swift:21:25: error: cannot convert value of type '()'\
    \ to expected argument type '[Int]'\n    if will_it_fly(q: q.reverse(), w: w)\
    \ {\n                        ^\n/tmp/tmp2kjovi1i.swift:21:25: error: cannot use\
    \ mutating member on immutable value: 'q' is a 'let' constant\n    if will_it_fly(q:\
    \ q.reverse(), w: w) {\n                      ~ ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let max = w\n    let pal = q.make_balanced()\n    let\
    \ n = q.length\n    for i in 0..<n {\n        if q[i] < 0 {\n            pal[i]\
    \ = -(pal[i])\n        }\n    }\n    for (i..<n-1) { pal[i] = pal[i + 1] }\n \
    \   let res = 0\n    for i in 0..<n {\n        res += pal[i]\n    }\n    return\
    \ res == max && pal.make_balanced() == q\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2vys8l_i.swift:26:11: error: expected ',' separator\n    for (i..<n-1)\
    \ { pal[i] = pal[i + 1] }\n          ^\n          ,\n/tmp/tmp2vys8l_i.swift:26:11:\
    \ error: expected pattern\n    for (i..<n-1) { pal[i] = pal[i + 1] }\n       \
    \   ^\n/tmp/tmp2vys8l_i.swift:26:19: error: expected 'in' after for-each pattern\n\
    \    for (i..<n-1) { pal[i] = pal[i + 1] }\n                  ^\n/tmp/tmp2vys8l_i.swift:26:19:\
    \ error: expected Sequence expression for for-each loop\n    for (i..<n-1) { pal[i]\
    \ = pal[i + 1] }\n                  ^\n/tmp/tmp2vys8l_i.swift:19:17: error: value\
    \ of type '[Int]' has no member 'make_balanced'\n    let pal = q.make_balanced()\n\
    \              ~ ^~~~~~~~~~~~~\n/tmp/tmp2vys8l_i.swift:20:15: error: value of\
    \ type '[Int]' has no member 'length'\n    let n = q.length\n            ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    \n    let i = q.startIndex\n    let j = q.count - 1\n    \n    guard\
    \ i >= 0 && j >= 0 && i <= j && i <= j else { return false }\n    \n    var total\
    \ = 0\n    for k in 0 ..< w {\n        total += q[i]\n        i -= 1\n       \
    \ guard i >= 0 else {\n            return false\n        }\n        total *= k\n\
    \    }\n    \n    return total >= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpchsdwk6m.swift:30:11: error: left side of mutating operator isn't\
    \ mutable: 'i' is a 'let' constant\n        i -= 1\n        ~ ^\n/tmp/tmpchsdwk6m.swift:22:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let i = q.startIndex\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && sum(q) <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7mbwti8d.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && sum(q) <= w\n           ^~~~~~~~~~~\n/tmp/tmp7mbwti8d.swift:18:30:\
    \ error: cannot find 'sum' in scope\n    return is_balanced(q) && sum(q) <= w\n\
    \                             ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else { return false }\n    let\
    \ sumOfElements = q.filter{ $0 < w }.prefixSum()\n    return sumOfElements <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuyxrki0u.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else { return false }\n              \
    \       ~ ^~~~~\n/tmp/tmpuyxrki0u.swift:19:44: error: value of type '[Int]' has\
    \ no member 'prefixSum'\n    let sumOfElements = q.filter{ $0 < w }.prefixSum()\n\
    \                        ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && is_palindromic(q) && q.sum()\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsv8cjta8.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && is_palindromic(q) && q.sum() <= w\n           ^~~~~~~~~~~\n\
    /tmp/tmpsv8cjta8.swift:18:30: error: cannot find 'is_palindromic' in scope\n \
    \   return is_balanced(q) && is_palindromic(q) && q.sum() <= w\n             \
    \                ^~~~~~~~~~~~~~\n/tmp/tmpsv8cjta8.swift:18:53: error: value of\
    \ type '[Int]' has no member 'sum'\n    return is_balanced(q) && is_palindromic(q)\
    \ && q.sum() <= w\n                                                  ~ ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  return balanced(q) && sum(q) <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp92249z4c.swift:18:10: error: cannot find 'balanced' in scope\n\
    \  return balanced(q) && sum(q) <= w\n         ^~~~~~~~\n/tmp/tmp92249z4c.swift:18:25:\
    \ error: cannot find 'sum' in scope\n  return balanced(q) && sum(q) <= w\n   \
    \                     ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.isEmpty == false && w >= 0 && q.count == q.maxElements()\
    \ else { return false }\n    if q.isEmpty == true { return true }\n    if let\
    \ q = q.asImmutable().reverse() {\n        return sumOfArrayElements(q) == w &&\
    \ isPalindrome(q)\n    } else {\n        return sumOfArrayElements(q) == w &&\
    \ isPalindrome(q) == false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpix1qmm_2.swift:18:56: error: value of type '[Int]' has no member\
    \ 'maxElements'\n    guard q.isEmpty == false && w >= 0 && q.count == q.maxElements()\
    \ else { return false }\n                                                    \
    \ ~ ^~~~~~~~~~~\n/tmp/tmpix1qmm_2.swift:20:18: error: value of type '[Int]' has\
    \ no member 'asImmutable'\n    if let q = q.asImmutable().reverse() {\n      \
    \         ~ ^~~~~~~~~~~\n/tmp/tmpix1qmm_2.swift:21:16: error: cannot find 'sumOfArrayElements'\
    \ in scope\n        return sumOfArrayElements(q) == w && isPalindrome(q)\n   \
    \            ^~~~~~~~~~~~~~~~~~\n/tmp/tmpix1qmm_2.swift:21:46: error: cannot find\
    \ 'isPalindrome' in scope\n        return sumOfArrayElements(q) == w && isPalindrome(q)\n\
    \                                             ^~~~~~~~~~~~\n/tmp/tmpix1qmm_2.swift:23:16:\
    \ error: cannot find 'sumOfArrayElements' in scope\n        return sumOfArrayElements(q)\
    \ == w && isPalindrome(q) == false\n               ^~~~~~~~~~~~~~~~~~\n/tmp/tmpix1qmm_2.swift:23:46:\
    \ error: cannot find 'isPalindrome' in scope\n        return sumOfArrayElements(q)\
    \ == w && isPalindrome(q) == false\n                                         \
    \    ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\tlet rev = q.rev()\n\tguard q.count >= w else { return false\
    \ }\n\n\treturn rev == q.sorted() {\n\t\t$0 + $1 == w\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn42enk9t.swift:18:14: error: value of type '[Int]' has no member\
    \ 'rev'\n        let rev = q.rev()\n                  ~ ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  if isPalindrome(q) {\n    if sum(q) >= w {\n      return\
    \ true\n    } else {\n      return false\n    }\n  } else {\n    return false\n\
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpli843fl1.swift:18:6: error: cannot find 'isPalindrome' in scope\n\
    \  if isPalindrome(q) {\n     ^~~~~~~~~~~~\n/tmp/tmpli843fl1.swift:19:8: error:\
    \ cannot find 'sum' in scope\n    if sum(q) >= w {\n       ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxSum = w * w.maxCoefficient()\n    let maxSumSquared\
    \ = maxSum * maxSum\n    var sum: Int = 0\n    for i in q {\n        sum += i\
    \ * i\n    }\n    return sum <= maxSumSquared && q.reduce(0, combine: {$0 + $1*$0})/2\
    \ == sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu4z66wkx.swift:18:24: error: value of type 'Int' has no member\
    \ 'maxCoefficient'\n    let maxSum = w * w.maxCoefficient()\n                \
    \     ~ ^~~~~~~~~~~~~~\n/tmp/tmpu4z66wkx.swift:24:44: error: extraneous argument\
    \ label 'combine:' in call\n    return sum <= maxSumSquared && q.reduce(0, combine:\
    \ {$0 + $1*$0})/2 == sum\n                                           ^   ~~~~~~~~~\n\
    \                                               \n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if isPalindromic(q) {\n        return sum(q) <= w\n \
    \   }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2qu9vgqp.swift:18:8: error: cannot find 'isPalindromic' in scope\n\
    \    if isPalindromic(q) {\n       ^~~~~~~~~~~~~\n/tmp/tmp2qu9vgqp.swift:19:16:\
    \ error: cannot find 'sum' in scope\n        return sum(q) <= w\n            \
    \   ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Write your code here\n\n    var maxW = 0\n    var\
    \ maxWSoFar = 0\n    for w in q {\n        if maxWSoFar > maxW {\n           \
    \ maxWSoFar = maxW\n        }\n        if maxWSoFar > w {\n            maxW =\
    \ w\n        }\n    }\n    return maxWSoFar <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5i_rqgsm/tmp5i_rqgsm.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8c7ccdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8c79c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae8c79c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8c79c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5i_rqgsm                        0x000055ec0ffcb52b <unavailable> + 5419

    5    libc.so.6                          0x00002ae8c7eb9460 __libc_start_main +
    245

    6    tmp5i_rqgsm                        0x000055ec0ffcb0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return will_it_fly(q, w, 0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5u6ju3ma.swift:18:30: error: extra argument in call\n    return\
    \ will_it_fly(q, w, 0)\n                      ~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if isPalindrome(q) {\n        let sum = q.sum()\n   \
    \     return sum <= w\n    } else {\n        return false\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpt8tdlgwh.swift:18:8: error: cannot find 'isPalindrome' in scope\n\
    \    if isPalindrome(q) {\n       ^~~~~~~~~~~~\n/tmp/tmpt8tdlgwh.swift:19:21:\
    \ error: value of type '[Int]' has no member 'sum'\n        let sum = q.sum()\n\
    \                  ~ ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxSum = w * w\n    if q.count == 0 || maxSum ==\
    \ 0 {\n        return true\n    }\n    let start = 0\n    let end = q.count -\
    \ 1\n    let maxIndex = q.count - 1\n    while start < end {\n        let sum\
    \ = q[start] + q[end]\n        if sum > maxSum {\n            maxSum = sum\n \
    \           maxIndex = start\n        } else {\n            maxIndex += 1\n  \
    \      }\n        start += 1\n        end -= 1\n    }\n    return maxIndex ==\
    \ 0 && (maxSum == 0 || maxSum == q)[q.count-1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe84_uuz1.swift:28:13: error: cannot assign to value: 'maxSum' is\
    \ a 'let' constant\n            maxSum = sum\n            ^~~~~~\n/tmp/tmpe84_uuz1.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxSum = w * w\n   \
    \ ^~~\n    var\n/tmp/tmpe84_uuz1.swift:29:13: error: cannot assign to value: 'maxIndex'\
    \ is a 'let' constant\n            maxIndex = start\n            ^~~~~~~~\n/tmp/tmpe84_uuz1.swift:24:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxIndex = q.count -\
    \ 1\n    ^~~\n    var\n/tmp/tmpe84_uuz1.swift:31:22: error: left side of mutating\
    \ operator isn't mutable: 'maxIndex' is a 'let' constant\n            maxIndex\
    \ += 1\n            ~~~~~~~~ ^\n/tmp/tmpe84_uuz1.swift:24:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let maxIndex = q.count - 1\n    ^~~\n    var\n\
    /tmp/tmpe84_uuz1.swift:33:15: error: left side of mutating operator isn't mutable:\
    \ 'start' is a 'let' constant\n        start += 1\n        ~~~~~ ^\n/tmp/tmpe84_uuz1.swift:22:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let start = 0\n    ^~~\n\
    \    var\n/tmp/tmpe84_uuz1.swift:34:13: error: left side of mutating operator\
    \ isn't mutable: 'end' is a 'let' constant\n        end -= 1\n        ~~~ ^\n\
    /tmp/tmpe84_uuz1.swift:23:5: note: change 'let' to 'var' to make it mutable\n\
    \    let end = q.count - 1\n    ^~~\n    var\n/tmp/tmpe84_uuz1.swift:36:52: error:\
    \ binary operator '==' cannot be applied to operands of type 'Int' and '[Int]'\n\
    \    return maxIndex == 0 && (maxSum == 0 || maxSum == q)[q.count-1]\n       \
    \                                     ~~~~~~ ^  ~\n/tmp/tmpe84_uuz1.swift:36:52:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    return maxIndex == 0 && (maxSum == 0 || maxSum == q)[q.count-1]\n\
    \                                                   ^\n/tmp/tmpe84_uuz1.swift:36:57:\
    \ error: value of type 'Bool' has no subscripts\n    return maxIndex == 0 && (maxSum\
    \ == 0 || maxSum == q)[q.count-1]\n                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in an appropriate way\n    var maxSum\
    \ = w\n    var index = 0\n    for number in q {\n        maxSum = max(maxSum,\
    \ number * w)\n        index++\n    }\n    let maxSumInt = Int(maxSum)\n    if\
    \ maxSumInt % 2 == 0 {\n        return true\n    } else {\n        for number\
    \ in q {\n            if number < maxSum {\n                return false\n   \
    \         }\n        }\n        return true\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmposnmfjkf.swift:23:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = w\n    for _, b := range q {\n        max -=\
    \ b\n    }\n    return max <= 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplxc68elg.swift:19:10: error: expected 'in' after for-each pattern\n\
    \    for _, b := range q {\n         ^\n/tmp/tmplxc68elg.swift:19:10: error: expected\
    \ Sequence expression for for-each loop\n    for _, b := range q {\n         ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n\n    return (sum >= w) && (is_balanced(q) && is_palindromic(q))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo_ioh4q5.swift:23:27: error: cannot find 'is_balanced' in scope\n\
    \    return (sum >= w) && (is_balanced(q) && is_palindromic(q))\n            \
    \              ^~~~~~~~~~~\n/tmp/tmpo_ioh4q5.swift:23:45: error: cannot find 'is_palindromic'\
    \ in scope\n    return (sum >= w) && (is_balanced(q) && is_palindromic(q))\n \
    \                                           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  // Rearrange the array so that the first element is the\
    \ most negative.\n  q.reverse()\n\n  // If the first element is the same as last,\
    \ and it's the same as the last element, it's a palindrome.\n  if q[0] == q[q.count-1]\
    \ && q[0] == q[q.count-1] {\n    return true\n  }\n\n  // If the sum of the first\
    \ elements is less than the weight w, the palindrome is unbalanced.\n  if q.sum()\
    \ < w {\n    return false\n  }\n\n  // If the sum of the first elements is equal\
    \ to the weight w, the palindrome is balanced.\n  if q.sum() == w {\n    // If\
    \ the last element is the same as first, the palindrome is balanced.\n    if q[1]\
    \ == q[0] {\n      return true\n    }\n  }\n\n  return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzmkgxod2.swift:19:5: error: cannot use mutating member on immutable\
    \ value: 'q' is a 'let' constant\n  q.reverse()\n  ~ ^\n/tmp/tmpzmkgxod2.swift:27:8:\
    \ error: value of type '[Int]' has no member 'sum'\n  if q.sum() < w {\n     ~\
    \ ^~~\n/tmp/tmpzmkgxod2.swift:32:8: error: value of type '[Int]' has no member\
    \ 'sum'\n  if q.sum() == w {\n     ~ ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard is_balanced(q: q) && sum(q: q) <= w else { return\
    \ false }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4xbm_owh.swift:18:11: error: cannot find 'is_balanced' in scope\n\
    \    guard is_balanced(q: q) && sum(q: q) <= w else { return false }\n       \
    \   ^~~~~~~~~~~\n/tmp/tmp4xbm_owh.swift:18:32: error: cannot find 'sum' in scope\n\
    \    guard is_balanced(q: q) && sum(q: q) <= w else { return false }\n       \
    \                        ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard w > 0 else { return false }\n    var max = 0\n\
    \    for element in q {\n        max = max(max, element)\n    }\n    if max >\
    \ w {\n        return false\n    }\n    var balanced = true\n    for element in\
    \ q {\n        if element != 0 {\n            balanced = balanced && element ==\
    \ max\n        }\n    }\n    return balanced\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpij0vtqsc.swift:21:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, element)\n              ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard w > 0 && q.count > 0 && q.count == w.count else\
    \ { return false }\n    return q.count == w.count && is_balanced(q) && max_sum(q)\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpaq8cb48y.swift:18:48: error: value of type 'Int' has no member\
    \ 'count'\n    guard w > 0 && q.count > 0 && q.count == w.count else { return\
    \ false }\n                                             ~ ^~~~~\n/tmp/tmpaq8cb48y.swift:19:34:\
    \ error: cannot find 'is_balanced' in scope\n    return q.count == w.count &&\
    \ is_balanced(q) && max_sum(q) <= w\n                                 ^~~~~~~~~~~\n\
    /tmp/tmpaq8cb48y.swift:19:52: error: cannot find 'max_sum' in scope\n    return\
    \ q.count == w.count && is_balanced(q) && max_sum(q) <= w\n                  \
    \                                 ^~~~~~~\n/tmp/tmpaq8cb48y.swift:19:25: error:\
    \ value of type 'Int' has no member 'count'\n    return q.count == w.count &&\
    \ is_balanced(q) && max_sum(q) <= w\n                      ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Fill this in.\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp4rogwhw0/tmp4rogwhw0.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2c2df2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2c2ae9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2c2ae9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2c2ae87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4rogwhw0                        0x000055bdd85dd3bb <unavailable> + 5051

    5    libc.so.6                          0x00002af2c2fde460 __libc_start_main +
    245

    6    tmp4rogwhw0                        0x000055bdd85dcf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return false\n    }\n    let\
    \ mut q0 = q.first(),\n        q1 = q.last(),\n        qsum = q0..<q1.count(),\n\
    \        m = max(w, qsum.sum()),\n        d0 = q0.count,\n        d1 = q1.count\n\
    \    while d0 < m && d1 < m {\n        q0.append(q[q0.count-1])\n        q1.prepend(q[q1.count+1])\n\
    \        d0 += 1\n        d1 -= 1\n    }\n    if d1 < m {\n        return false\n\
    \    }\n    let mut r0 = q0.count,\n        r1 = q1.count\n    while r0 < w &&\
    \ r1 < w {\n        r0 += q[r0]\n        r1 += q[r1]\n    }\n    return r0 ==\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8e0eca60.swift:21:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut q0 = q.first(),\n\
    \            ^\n/tmp/tmp8e0eca60.swift:21:13: note: join the identifiers together\n\
    \    let mut q0 = q.first(),\n        ~~~~^~\n        mutq0\n/tmp/tmp8e0eca60.swift:21:13:\
    \ note: join the identifiers together with camel-case\n    let mut q0 = q.first(),\n\
    \        ~~~~^~\n        mutQ0\n/tmp/tmp8e0eca60.swift:36:13: error: found an\
    \ unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut r0 = q0.count,\n            ^\n/tmp/tmp8e0eca60.swift:36:13:\
    \ note: join the identifiers together\n    let mut r0 = q0.count,\n        ~~~~^~\n\
    \        mutr0\n/tmp/tmp8e0eca60.swift:36:13: note: join the identifiers together\
    \ with camel-case\n    let mut r0 = q0.count,\n        ~~~~^~\n        mutR0\n\
    /tmp/tmp8e0eca60.swift:21:20: error: cannot call value of non-function type 'Int?'\n\
    \    let mut q0 = q.first(),\n                   ^    ~~\n                   \
    \     \n/tmp/tmp8e0eca60.swift:22:16: error: cannot call value of non-function\
    \ type 'Int?'\n        q1 = q.last(),\n               ^   ~~\n               \
    \    \n/tmp/tmp8e0eca60.swift:23:16: error: cannot find 'q0' in scope\n      \
    \  qsum = q0..<q1.count(),\n               ^~\n/tmp/tmp8e0eca60.swift:25:14: error:\
    \ cannot find 'q0' in scope\n        d0 = q0.count,\n             ^~\n/tmp/tmp8e0eca60.swift:28:9:\
    \ error: cannot find 'q0' in scope\n        q0.append(q[q0.count-1])\n       \
    \ ^~\n/tmp/tmp8e0eca60.swift:28:21: error: cannot find 'q0' in scope\n       \
    \ q0.append(q[q0.count-1])\n                    ^~\n/tmp/tmp8e0eca60.swift:36:18:\
    \ error: cannot find 'q0' in scope\n    let mut r0 = q0.count,\n             \
    \    ^~\n/tmp/tmp8e0eca60.swift:38:11: error: cannot find 'r0' in scope\n    while\
    \ r0 < w && r1 < w {\n          ^~\n/tmp/tmp8e0eca60.swift:39:9: error: cannot\
    \ find 'r0' in scope\n        r0 += q[r0]\n        ^~\n/tmp/tmp8e0eca60.swift:39:17:\
    \ error: cannot find 'r0' in scope\n        r0 += q[r0]\n                ^~\n\
    /tmp/tmp8e0eca60.swift"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard isBalanced(q) && sum(q) <= w else {\n        return\
    \ false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsqoae42h.swift:18:11: error: cannot find 'isBalanced' in scope\n\
    \    guard isBalanced(q) && sum(q) <= w else {\n          ^~~~~~~~~~\n/tmp/tmpsqoae42h.swift:18:28:\
    \ error: cannot find 'sum' in scope\n    guard isBalanced(q) && sum(q) <= w else\
    \ {\n                           ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return palindrome(q) && w <= sum(q)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpky0e0b9s.swift:18:12: error: cannot find 'palindrome' in scope\n\
    \    return palindrome(q) && w <= sum(q)\n           ^~~~~~~~~~\n/tmp/tmpky0e0b9s.swift:18:34:\
    \ error: cannot find 'sum' in scope\n    return palindrome(q) && w <= sum(q)\n\
    \                                 ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxW = 0\n    var balanced = true\n    for qElem\
    \ in q {\n        if w > maxW {\n            maxW = w\n        }\n        w -=\
    \ qElem\n        if w < 0 {\n            balanced = false\n            break\n\
    \        }\n    }\n\n    return balanced && w == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7zitnc3b.swift:24:11: error: left side of mutating operator isn't\
    \ mutable: 'w' is a 'let' constant\n        w -= qElem\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum = w\n    var balancedSum = w\n\n    for i\
    \ := 0; i < len(q); i++ {\n        balancedSum += q[i]\n        maxSum = max(maxSum,\
    \ balancedSum)\n    }\n\n    return balancedSum < maxSum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwkn749e4.swift:21:12: error: expected type\n    for i := 0; i <\
    \ len(q); i++ {\n           ^\n            <#type#>\n/tmp/tmpwkn749e4.swift:21:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(q); i++\
    \ {\n           ^\n/tmp/tmpwkn749e4.swift:21:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(q); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var p = q\n    for _ in 0..<w.count/2 {\n        var\
    \ a = p.slice(0, p.count/2)\n        p.append(a[p.count/2])\n        q = a\n \
    \   }\n    return p.isPalindromic && w * p.reduce(0, +) <= (1 << 16)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwros169t.swift:19:20: error: value of type 'Int' has no member\
    \ 'count'\n    for _ in 0..<w.count/2 {\n                 ~ ^~~~~\n/tmp/tmpwros169t.swift:24:14:\
    \ error: value of type '[Int]' has no member 'isPalindromic'\n    return p.isPalindromic\
    \ && w * p.reduce(0, +) <= (1 << 16)\n           ~ ^~~~~~~~~~~~~\n/tmp/tmpwros169t.swift:20:19:\
    \ error: value of type '[Int]' has no member 'slice'\n        var a = p.slice(0,\
    \ p.count/2)\n                ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard !is_balanced(q) && is_balanced(q.reversed()) &&\
    \ is_balanced(q.reversed()) && q.reduce(0, +) <= w else { return false }\n   \
    \ return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2i_g0n8k.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    guard !is_balanced(q) && is_balanced(q.reversed()) && is_balanced(q.reversed())\
    \ && q.reduce(0, +) <= w else { return false }\n           ^~~~~~~~~~~\n/tmp/tmp2i_g0n8k.swift:18:30:\
    \ error: cannot find 'is_balanced' in scope\n    guard !is_balanced(q) && is_balanced(q.reversed())\
    \ && is_balanced(q.reversed()) && q.reduce(0, +) <= w else { return false }\n\
    \                             ^~~~~~~~~~~\n/tmp/tmp2i_g0n8k.swift:18:59: error:\
    \ cannot find 'is_balanced' in scope\n    guard !is_balanced(q) && is_balanced(q.reversed())\
    \ && is_balanced(q.reversed()) && q.reduce(0, +) <= w else { return false }\n\
    \                                                          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard w > 0 else {\n        return false\n    }\n   \
    \ guard q.count == q.max() else {\n        return false\n    }\n    // If there\
    \ is only 1 element then it balanced\n    if q.count == 1 {\n        return true\n\
    \    }\n    let mut palindromeSum = q.fold(0, { return $0 + $1})\n    guard palindromeSum\
    \ <= w else {\n        return false\n    }\n    for i in 0..q.count-1 {\n    \
    \    if q[i] != q[q.count - 1 - i] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph98cj1i1.swift:28:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut palindromeSum\
    \ = q.fold(0, { return $0 + $1})\n            ^\n/tmp/tmph98cj1i1.swift:28:13:\
    \ note: join the identifiers together\n    let mut palindromeSum = q.fold(0, {\
    \ return $0 + $1})\n        ~~~~^~~~~~~~~~~~~\n        mutpalindromeSum\n/tmp/tmph98cj1i1.swift:28:13:\
    \ note: join the identifiers together with camel-case\n    let mut palindromeSum\
    \ = q.fold(0, { return $0 + $1})\n        ~~~~^~~~~~~~~~~~~\n        mutPalindromeSum\n\
    /tmp/tmph98cj1i1.swift:28:31: error: value of type '[Int]' has no member 'fold'\n\
    \    let mut palindromeSum = q.fold(0, { return $0 + $1})\n                  \
    \          ~ ^~~~\n/tmp/tmph98cj1i1.swift:29:11: error: cannot find 'palindromeSum'\
    \ in scope\n    guard palindromeSum <= w else {\n          ^~~~~~~~~~~~~\n/tmp/tmph98cj1i1.swift:32:15:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    for i in\
    \ 0..q.count-1 {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  // Reverse q first.\n  q.reverse()\n  // Compute sum of\
    \ the elements of q.\n  let sum = q.reduce(0, combine: +)\n  // If the sum is\
    \ more than the maximum possible weight, then it's balanced.\n  return sum <=\
    \ w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpel8vd5el.swift:19:5: error: cannot use mutating member on immutable\
    \ value: 'q' is a 'let' constant\n  q.reverse()\n  ~ ^\n/tmp/tmpel8vd5el.swift:21:21:\
    \ error: extraneous argument label 'combine:' in call\n  let sum = q.reduce(0,\
    \ combine: +)\n                    ^   ~~~~~~~~~\n                        \n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let len = q.count\n    if len == 0 {\n        return\
    \ true\n    }\n    let maxWeight = w * len\n    for a in q {\n        let total\
    \ = a * len\n        if total > maxWeight {\n            return false\n      \
    \  }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpmy0yq_2o/tmpmy0yq_2o.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4488f1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4488c15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4488c15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4488c147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmy0yq_2o                        0x000055ab8364457b <unavailable> + 5499

    5    libc.so.6                          0x00002b448910a460 __libc_start_main +
    245

    6    tmpmy0yq_2o                        0x000055ab83644129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = q.filter { $0 != 0 }.map({ $0 * $0 }).reduce(0)\n\
    \    if w > sum {\n        return false\n    }\n    return q == w.reverse(repeating:\
    \ 0).map{ $0 }.reverse()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpv8276qla.swift:18:61: error: missing argument for parameter #2\
    \ in call\n    var sum = q.filter { $0 != 0 }.map({ $0 * $0 }).reduce(0)\n   \
    \                                                         ^\n                \
    \                                            , <#(Int, Int) throws -> Int#>\n\
    Swift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable public func\
    \ reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult:\
    \ Result, Self.Element) throws -> Result) rethrows -> Result\n               \
    \            ^\n/tmp/tmpv8276qla.swift:22:19: error: value of type 'Int' has no\
    \ member 'reverse'\n    return q == w.reverse(repeating: 0).map{ $0 }.reverse()\n\
    \                ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n\n   \
    \ var maxSum = 0\n    for element in q {\n        maxSum += element\n    }\n\n\
    \    if maxSum > w {\n        return false\n    }\n\n    var isPalindromic = true\n\
    \    var sum = 0\n    for element in q {\n        sum += element\n        if element\
    \ != q[q.count - element] {\n            isPalindromic = false\n            break\n\
    \        }\n    }\n\n    if sum == w {\n        return true\n    }\n\n    return\
    \ isPalindromic\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e0b7d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e0b4c8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0e0b4c8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0e0b4c813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0e0b4c7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0e0b2c7e83 <unavailable> + 188035

    6    tmp1__emrca                        0x000055843e976c01 <unavailable> + 7169

    7    tmp1__emrca                        0x000055843e976618 <unavailable> + 5656

    8    libc.so.6                          0x00002b0e0b9bd460 __libc_start_main +
    245

    9    tmp1__emrca                        0x000055843e976189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let rec = will_it_fly_rec(q, w)\n    return rec == nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpph979bqj.swift:18:15: error: cannot find 'will_it_fly_rec' in scope\n\
    \    let rec = will_it_fly_rec(q, w)\n              ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  guard q.isEmpty else {\n    return false\n  }\n  \n  return\
    \ q.palindromic.contains(w) && w.isLessThanOrEqualTo(q.maxWeight)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprh12brp7.swift:22:12: error: value of type '[Int]' has no member\
    \ 'palindromic'\n  return q.palindromic.contains(w) && w.isLessThanOrEqualTo(q.maxWeight)\n\
    \         ~ ^~~~~~~~~~~\n/tmp/tmprh12brp7.swift:22:41: error: value of type 'Int'\
    \ has no member 'isLessThanOrEqualTo'\n  return q.palindromic.contains(w) && w.isLessThanOrEqualTo(q.maxWeight)\n\
    \                                      ~ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmprh12brp7.swift:22:63:\
    \ error: value of type '[Int]' has no member 'maxWeight'\n  return q.palindromic.contains(w)\
    \ && w.isLessThanOrEqualTo(q.maxWeight)\n                                    \
    \                        ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w * w + w\n    let sum = q.compactMap(Int.init).sum()\n\
    \    return sum < maxWeight && isPalindromic(q) && isBalanced(q)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp92ekjazg.swift:19:38: error: value of type '[Int]' has no member\
    \ 'sum'\n    let sum = q.compactMap(Int.init).sum()\n              ~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~\n/tmp/tmp92ekjazg.swift:20:31: error: cannot find 'isPalindromic' in scope\n\
    \    return sum < maxWeight && isPalindromic(q) && isBalanced(q)\n           \
    \                   ^~~~~~~~~~~~~\n/tmp/tmp92ekjazg.swift:20:51: error: cannot\
    \ find 'isBalanced' in scope\n    return sum < maxWeight && isPalindromic(q) &&\
    \ isBalanced(q)\n                                                  ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return ((q.sorted().map({ $0*$0 + $1 }) <= w) && (q.flatMap({\
    \ $0*$0 + $1 }) == w))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp616irs7s.swift:18:81: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n    return ((q.sorted().map({ $0*$0 +\
    \ $1 }) <= w) && (q.flatMap({ $0*$0 + $1 }) == w))\n                         \
    \                             ~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~\n/tmp/tmp616irs7s.swift:18:81:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    return ((q.sorted().map({ $0*$0 + $1 }) <= w) && (q.flatMap({\
    \ $0*$0 + $1 }) == w))\n                                                     \
    \                           ^\n/tmp/tmp616irs7s.swift:18:29: error: contextual\
    \ closure type '(Int) throws -> Int' expects 1 argument, but 2 were used in closure\
    \ body\n    return ((q.sorted().map({ $0*$0 + $1 }) <= w) && (q.flatMap({ $0*$0\
    \ + $1 }) == w))\n                            ^\n/tmp/tmp616irs7s.swift:18:25:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    return ((q.sorted().map({ $0*$0 + $1 }) <= w) && (q.flatMap({ $0*$0 + $1\
    \ }) == w))\n                        ^\n/tmp/tmp616irs7s.swift:18:65: error: contextual\
    \ closure type '(Int) throws -> Int?' expects 1 argument, but 2 were used in closure\
    \ body\n    return ((q.sorted().map({ $0*$0 + $1 }) <= w) && (q.flatMap({ $0*$0\
    \ + $1 }) == w))\n                                                           \
    \     ^\n"
  stdout: ''
  timestamp: 1660014651
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.isEmpty == true else {\n        return false\n\
    \    }\n    guard w >= 0 && w <= q.last else {\n        return false\n    }\n\n\
    \    // check if palindromic array\n    let start = q.first\n    let end = q.last\n\
    \    let reversedArray = Array.reverse(q)\n    return reversedArray == q &&\n\
    \        (q.reduce(Int.min) { x, y in x + y } <= w)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp064z3mw8.swift:21:28: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard w >= 0 && w <= q.last else\
    \ {\n                           ^\n/tmp/tmp064z3mw8.swift:21:28: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ guard w >= 0 && w <= q.last else {\n                           ^\n         \
    \                       ?? <#default value#>\n/tmp/tmp064z3mw8.swift:21:28: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    guard w >= 0 && w <= q.last else {\n                           ^\n      \
    \                         !\n/tmp/tmp064z3mw8.swift:28:31: error: cannot reference\
    \ 'mutating' method as function value\n    let reversedArray = Array.reverse(q)\n\
    \                              ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for _ in q {\n        sum += q[q.startIndex\
    \ - 1]\n    }\n    return sum == w && is_palindromic(q) && sum <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpxbme9eqr.swift:22:24: error: cannot find 'is_palindromic' in scope\n\
    \    return sum == w && is_palindromic(q) && sum <= w\n                      \
    \ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var will_it_fly = false\n    var max_sum_possible = w\n\
    \    for element in q {\n        max_sum_possible *= element\n    }\n    if max_sum_possible\
    \ == 0 {\n        return true\n    }\n    var sum_q = 0\n    for element in q\
    \ {\n        sum_q += element\n    }\n    if sum_q < max_sum_possible {\n    \
    \    for element in q {\n            max_sum_possible /= element\n        }\n\
    \        will_it_fly = true\n    }\n    return will_it_fly\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpjfgugrzz/tmpjfgugrzz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34ced69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34cea60b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34cea60988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34cea5f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjfgugrzz                        0x00005629d66525bb <unavailable> + 5563

    5    libc.so.6                          0x00002b34cef55460 __libc_start_main +
    245

    6    tmpjfgugrzz                        0x00005629d6652169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else { return false }\n    var\
    \ maxSum = w\n    for element in q {\n        let diff = abs(element - w)\n  \
    \      if diff > maxSum {\n            maxSum = diff\n        }\n    }\n    let\
    \ sum = q.map { $0 + $1 }.reduce(0, +)\n    return sum == maxSum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_rqcx6vk.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else { return false }\n              \
    \       ~ ^~~~~\n/tmp/tmp_rqcx6vk.swift:26:21: error: contextual closure type\
    \ '(Int) throws -> Int' expects 1 argument, but 2 were used in closure body\n\
    \    let sum = q.map { $0 + $1 }.reduce(0, +)\n                    ^\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var i = 0\n    var j = q.count - 1\n    var sum = 0\n\
    \    var max = 0\n    while i < j {\n        sum += q[i]\n        if sum > max\
    \ {\n            max = sum\n        }\n        i += 1\n    }\n    max = max -\
    \ w + 1\n    return max == 0 || (sum + w == max)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp3_kzqbua/tmp3_kzqbua.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d647a4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d6449bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d6449b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d6449a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3_kzqbua                        0x000055e571f953af <unavailable> + 5039

    5    libc.so.6                          0x00002b7d64990460 __libc_start_main +
    245

    6    tmp3_kzqbua                        0x000055e571f95019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard w >= 0 && w <= maxWeight else { return false }\n\
    \    \n    if q == [] { return true }\n    \n    let reversedQ = q.reversed()\n\
    \    let totalWeight = q.map({ $0 }).reduce(+) + reversedQ.map({ $0 }).reduce(+)\n\
    \    return totalWeight <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqkdtdtpb.swift:18:26: error: cannot find 'maxWeight' in scope\n\
    \    guard w >= 0 && w <= maxWeight else { return false }\n                  \
    \       ^~~~~~~~~\n/tmp/tmpqkdtdtpb.swift:23:23: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n    let totalWeight = q.map({ $0 }).reduce(+)\
    \ + reversedQ.map({ $0 }).reduce(+)\n                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660015246
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && sum(q) <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7mbwti8d.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && sum(q) <= w\n           ^~~~~~~~~~~\n/tmp/tmp7mbwti8d.swift:18:30:\
    \ error: cannot find 'sum' in scope\n    return is_balanced(q) && sum(q) <= w\n\
    \                             ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\tguard q.count == w, q.count == 0 || q.first! < q.last else\
    \ {\n\t\treturn false\n\t}\n\tlet m = maximumSum(q, w)\n\treturn isPalindrome(q,\
    \ m, w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqhd2uqv_.swift:18:51: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        guard q.count == w, q.count ==\
    \ 0 || q.first! < q.last else {\n                                            \
    \             ^\n/tmp/tmpqhd2uqv_.swift:18:51: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        guard q.count == w,\
    \ q.count == 0 || q.first! < q.last else {\n                                 \
    \                        ^\n                                                 \
    \             ?? <#default value#>\n/tmp/tmpqhd2uqv_.swift:18:51: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        guard\
    \ q.count == w, q.count == 0 || q.first! < q.last else {\n                   \
    \                                      ^\n                                   \
    \                          !\n/tmp/tmpqhd2uqv_.swift:21:10: error: cannot find\
    \ 'maximumSum' in scope\n        let m = maximumSum(q, w)\n                ^~~~~~~~~~\n\
    /tmp/tmpqhd2uqv_.swift:22:9: error: cannot find 'isPalindrome' in scope\n    \
    \    return isPalindrome(q, m, w)\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard maxW(q) == w else { return false }\n    guard let\
    \ q = q.sorted() { $0 < $1 },\n        q.indices.count == q.count / 2 else { return\
    \ false }\n\n    let sumOfElements = q.sum { q[$0] }\n    return sumOfElements\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp02rn9mfw.swift:18:11: error: cannot find 'maxW' in scope\n    guard\
    \ maxW(q) == w else { return false }\n          ^~~~\n/tmp/tmp02rn9mfw.swift:19:30:\
    \ warning: trailing closure in this context is confusable with the body of the\
    \ statement; pass as a parenthesized argument to silence this warning\n    guard\
    \ let q = q.sorted() { $0 < $1 },\n                           ~~^\n          \
    \                 by:          )\n/tmp/tmp02rn9mfw.swift:19:11: error: initializer\
    \ for conditional binding must have Optional type, not '[Int]'\n    guard let\
    \ q = q.sorted() { $0 < $1 },\n          ^       ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp02rn9mfw.swift:22:27:\
    \ error: value of type '[Int]' has no member 'sum'\n    let sumOfElements = q.sum\
    \ { q[$0] }\n                        ~ ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code here\n    if q.count == 0 || w < 1\
    \ {\n        return false\n    }\n    if q.count == 1 {\n        if q[0] == q[0]\
    \ {\n            return true\n        }\n    }\n    var sum = 0\n    for x in\
    \ q {\n        sum += x\n    }\n    if sum > w {\n        return false\n    }\n\
    \    let pal = true\n    for x in q {\n        if x != x {\n            pal =\
    \ false\n        }\n    }\n    return pal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc810eh29.swift:37:13: error: cannot assign to value: 'pal' is a\
    \ 'let' constant\n            pal = false\n            ^~~\n/tmp/tmpc810eh29.swift:34:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let pal = true\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else { return false }\n    if\
    \ q.count == 0 { return true }\n    \n    var pq = q\n    \n    for _ in 1...w.count\
    \ {\n        pq.removeLast()\n    }\n    \n    return isBalanced(pq) && sum(pq)\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7z2f8k76.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else { return false }\n              \
    \       ~ ^~~~~\n/tmp/tmp7z2f8k76.swift:23:20: error: value of type 'Int' has\
    \ no member 'count'\n    for _ in 1...w.count {\n                 ~ ^~~~~\n/tmp/tmp7z2f8k76.swift:27:12:\
    \ error: cannot find 'isBalanced' in scope\n    return isBalanced(pq) && sum(pq)\
    \ <= w\n           ^~~~~~~~~~\n/tmp/tmp7z2f8k76.swift:27:30: error: cannot find\
    \ 'sum' in scope\n    return isBalanced(pq) && sum(pq) <= w\n                \
    \             ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in geeksforgeeks\n    var max = 0\n\
    \    for index in 0..<q.count {\n        if max < q[index] {\n            max\
    \ = q[index]\n        }\n    }\n    return max <= w && is_palindrome(q) && sum_q(q)\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7skzvkwi.swift:25:24: error: cannot find 'is_palindrome' in scope\n\
    \    return max <= w && is_palindrome(q) && sum_q(q) <= w\n                  \
    \     ^~~~~~~~~~~~~\n/tmp/tmp7skzvkwi.swift:25:44: error: cannot find 'sum_q'\
    \ in scope\n    return max <= w && is_palindrome(q) && sum_q(q) <= w\n       \
    \                                    ^~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxWeight = w\n    var balanced = true\n    var sum\
    \ = 0\n    for v in q {\n        sum += v\n        if sum > maxWeight {\n    \
    \        balanced = false\n            break\n        }\n    }\n    return balanced\
    \ && sum <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpg5tvhiki/tmpg5tvhiki.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a2a15fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a29e56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a29e56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a29e557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg5tvhiki                        0x000055c3acd1e52b <unavailable> + 5419

    5    libc.so.6                          0x00002b4a2a34b460 __libc_start_main +
    245

    6    tmpg5tvhiki                        0x000055c3acd1e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  guard q.isEmpty || q.count == w, w <= Int32.max else {\n\
    \    return true\n  }\n  guard let left = q.removeFirst(),\n    let right = q.removeLast(),\n\
    \    let sum = (left + right).pow / 2,\n    sum == w || sum == -w\n    else {\n\
    \      return true\n  }\n  return !will_it_fly(q, w)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp27kzcanj.swift:21:22: error: cannot use mutating member on immutable\
    \ value: 'q' is a 'let' constant\n  guard let left = q.removeFirst(),\n      \
    \             ~ ^\n/tmp/tmp27kzcanj.swift:22:19: error: cannot use mutating member\
    \ on immutable value: 'q' is a 'let' constant\n    let right = q.removeLast(),\n\
    \                ~ ^\n/tmp/tmp27kzcanj.swift:23:30: error: value of type 'String'\
    \ has no member 'pow'\n    let sum = (left + right).pow / 2,\n              ~~~~~~~~~~~~~~\
    \ ^~~\n/tmp/tmp27kzcanj.swift:28:22: error: missing argument labels 'q:w:' in\
    \ call\n  return !will_it_fly(q, w)\n                     ^\n                \
    \      q: w: \n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Your code here\n    var maxSum = w\n    var sum =\
    \ 0\n    var isPalindromic = false\n    for var i = 0; i < q.count; i++ {\n  \
    \      if i != 0 {\n            sum += q[i]\n        }\n        if sum > w {\n\
    \            return false\n        }\n        if maxSum < w {\n            maxSum\
    \ = w\n        }\n        if sum == w {\n            isPalindromic = true\n  \
    \      }\n    }\n    return isPalindromic && sum <= maxSum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2n45upb_.swift:22:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < q.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in Swift 5.0\n    if q.isEmpty {\n\
    \        return true\n    }\n    var maxW: Int = w\n    var i = 0\n    var j =\
    \ q.count - 1\n    while i != j {\n        if q[i] + q[j] > maxW {\n         \
    \   j = j - 1\n        } else {\n            i = i + 1\n        }\n        if\
    \ i == j {\n            if q[i] + q[j] >= maxW {\n                return false\n\
    \            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp18tyuqxz/tmp18tyuqxz.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5439ea8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5439b9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5439b9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5439b9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp18tyuqxz                        0x00005559bb5904fb <unavailable> + 5371

    5    libc.so.6                          0x00002b543a094460 __libc_start_main +
    245

    6    tmp18tyuqxz                        0x00005559bb5900a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count <= w {\n        return false\n    }\n\n  \
    \  let maxWeight = w\n    var maxWeightSum: Int = 0\n    for i in q.indices {\n\
    \        if maxWeightSum > maxWeight {\n            return false\n        }\n\
    \        if maxWeightSum < maxWeight {\n            maxWeight = maxWeightSum\n\
    \            maxWeightSum = q[i]\n        }\n        if maxWeightSum == maxWeight\
    \ {\n            maxWeightSum = q[i]\n        }\n    }\n\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnqtmorum.swift:29:13: error: cannot assign to value: 'maxWeight'\
    \ is a 'let' constant\n            maxWeight = maxWeightSum\n            ^~~~~~~~~\n\
    /tmp/tmpnqtmorum.swift:22:5: note: change 'let' to 'var' to make it mutable\n\
    \    let maxWeight = w\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard var q = q.copy() as? [Int] else { return false\
    \ }\n\n    var maxW = 0\n    while maxW < w {\n        let r = find(q, reverse(q))\n\
    \        if r < 0 {\n            return false\n        }\n        q[r] = q[r]\
    \ - 1\n        maxW += q[r]\n    }\n\n    if maxW == w {\n        return true\n\
    \    }\n\n    let max = max(q)\n    return max == 0 && q.count == 1 && !is_balanced(q)\
    \ && find_largest_palindrome(q) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp16k9cnof.swift:18:21: error: value of type '[Int]' has no member\
    \ 'copy'\n    guard var q = q.copy() as? [Int] else { return false }\n       \
    \           ~ ^~~~\n/tmp/tmp16k9cnof.swift:22:17: error: cannot find 'find' in\
    \ scope\n        let r = find(q, reverse(q))\n                ^~~~\n/tmp/tmp16k9cnof.swift:22:25:\
    \ error: cannot find 'reverse' in scope\n        let r = find(q, reverse(q))\n\
    \                        ^~~~~~~\n/tmp/tmp16k9cnof.swift:34:20: error: missing\
    \ argument for parameter #2 in call\n    let max = max(q)\n                  \
    \ ^\n                   , <#_#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp16k9cnof.swift:35:41: error: cannot find 'is_balanced' in\
    \ scope\n    return max == 0 && q.count == 1 && !is_balanced(q) && find_largest_palindrome(q)\
    \ == 0\n                                        ^~~~~~~~~~~\n/tmp/tmp16k9cnof.swift:35:59:\
    \ error: cannot find 'find_largest_palindrome' in scope\n    return max == 0 &&\
    \ q.count == 1 && !is_balanced(q) && find_largest_palindrome(q) == 0\n       \
    \                                                   ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    \n    if maxWeight < 1 {\n   \
    \     return true\n    }\n    \n    return balanced(q) && sumQ(q) <= maxWeight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0vrv1upp.swift:24:12: error: cannot find 'balanced' in scope\n\
    \    return balanced(q) && sumQ(q) <= maxWeight\n           ^~~~~~~~\n/tmp/tmp0vrv1upp.swift:24:27:\
    \ error: cannot find 'sumQ' in scope\n    return balanced(q) && sumQ(q) <= maxWeight\n\
    \                          ^~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Write code here.\n    if q.count == 0 || w == 0 ||\
    \ w*w <= q.count {\n        return true\n    }\n    if q.count == 1 && q[0] !=\
    \ w {\n        return true\n    }\n    var maxVal = q.maxElement()\n    var sum\
    \ = 0\n    for element in q {\n        sum += element\n        if sum > maxVal\
    \ {\n            maxVal = sum\n        }\n    }\n    if maxVal == w {\n      \
    \  return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmekx3i29.swift:25:20: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    var maxVal = q.maxElement()\n                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maximumSum = w\n    var isBalanced = true\n    var\
    \ sum = 0\n    var lastIndex = q.count - 1\n\n    for idx in 0..<q.count {\n \
    \       sum += q[idx]\n        if sum > maximumSum && idx > 0 {\n            isBalanced\
    \ = false\n            break\n        }\n    }\n\n    if isBalanced {\n      \
    \  if q[lastIndex] == q[0] {\n            sum -= q[0]\n            if sum == 0\
    \ {\n                maximumSum = w\n            }\n        }\n    } else {\n\
    \        maximumSum = 0\n    }\n\n    return isBalanced && sum <= maximumSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp8tol5ykx/tmp8tol5ykx.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b239c685c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b239c37cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b239c37c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b239c37b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8tol5ykx                        0x000055c9f44725fb <unavailable> + 5627

    5    libc.so.6                          0x00002b239c871460 __libc_start_main +
    245

    6    tmp8tol5ykx                        0x000055c9f44721a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    return q.indices.reduce(false)\
    \ {\n        if let idx1 = $0,\n           let idx2 = q.index(of: idx1),\n   \
    \        let weight1 = q[idx1],\n           let weight2 = q[idx2] {\n        \
    \    let minWeight = min(weight1, weight2)\n            return (minWeight <= maxWeight)\n\
    \        } else {\n            return false\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpizymabt_.swift:19:36: error: contextual closure type '(Bool, Range<Array<Int>.Index>.Element)\
    \ throws -> Bool' (aka '(Bool, Int) throws -> Bool') expects 2 arguments, but\
    \ 1 was used in closure body\n    return q.indices.reduce(false) {\n         \
    \                          ^\n/tmp/tmpizymabt_.swift:21:35: error: cannot convert\
    \ value of type 'Bool' to expected argument type 'Int'\n           let idx2 =\
    \ q.index(of: idx1),\n                                  ^\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var reversed: [Int] = []\n    for x in q {\n        reversed.append(x)\n\
    \    }\n    reversed.reverse()\n    for x in q {\n        if x > w {\n       \
    \     return false\n        }\n    }\n    var weight: Int = w\n    var sum: Int\
    \ = 0\n    for i in reversed {\n        sum += i\n    }\n    if sum == weight\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9g3eg_cx/tmp9g3eg_cx.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b96b4561c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b96b4258b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b96b4258988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b96b42577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9g3eg_cx                        0x0000559f07ee459f <unavailable> + 5535

    5    libc.so.6                          0x00002b96b474d460 __libc_start_main +
    245

    6    tmp9g3eg_cx                        0x0000559f07ee4209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // check if q has balanced subarray\n    var low = 0\n\
    \    var high = q.count - 1\n\n    while low < high {\n        if q[low] + q[high]\
    \ > w {\n            // unbalanced subarray, return false\n            return\
    \ false\n        }\n        // increment low\n        low++\n        // decrement\
    \ high\n        high--\n    }\n\n    // we reached here because q has balanced\
    \ subarray\n    // sum of all elements of q is less than or equal w\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5j720vpe.swift:28:12: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        low++\n           ^~\n/tmp/tmp5j720vpe.swift:30:13:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        high--\n\
    \            ^~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.count == 2 &&\n        q[0] == q[1] && (q[0]\
    \ + q[1] == w) ||\n        q.count == 1 && (q[0] + q[0] == w) ||\n        q.count\
    \ >= 3 &&\n        q[0] == q[1] &&\n        q[0] + q[1] != w &&\n        q[0]\
    \ + q[1] + q[2] != w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpgja5egq8/tmpgja5egq8.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb889b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb886aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb886ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb886ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgja5egq8                        0x0000558cd0a283af <unavailable> + 5039

    5    libc.so.6                          0x00002acb88ba3460 __libc_start_main +
    245

    6    tmpgja5egq8                        0x0000558cd0a28019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxW = sqrt(w * w)\n    return is_balanced(q, w,\
    \ maxW)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe_2t2561.swift:18:16: error: cannot find 'sqrt' in scope\n    let\
    \ maxW = sqrt(w * w)\n               ^~~~\n/tmp/tmpe_2t2561.swift:19:12: error:\
    \ cannot find 'is_balanced' in scope\n    return is_balanced(q, w, maxW)\n   \
    \        ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in Swift 4.2\n    if !is_balanced(q:\
    \ q) {\n        return false\n    }\n    if w > max_weight {\n        return false\n\
    \    }\n    if max_weight > 0 {\n        return is_balanced(q: q, w: w)\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpj82jxatw.swift:19:9: error: cannot find 'is_balanced' in scope\n\
    \    if !is_balanced(q: q) {\n        ^~~~~~~~~~~\n/tmp/tmpj82jxatw.swift:22:12:\
    \ error: cannot find 'max_weight' in scope\n    if w > max_weight {\n        \
    \   ^~~~~~~~~~\n/tmp/tmpj82jxatw.swift:25:8: error: cannot find 'max_weight' in\
    \ scope\n    if max_weight > 0 {\n       ^~~~~~~~~~\n/tmp/tmpj82jxatw.swift:26:16:\
    \ error: cannot find 'is_balanced' in scope\n        return is_balanced(q: q,\
    \ w: w)\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && max_possible_w(q, w) <= q.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx21g5y62.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && max_possible_w(q, w) <= q.count\n           ^~~~~~~~~~~\n\
    /tmp/tmpx21g5y62.swift:18:30: error: cannot find 'max_possible_w' in scope\n \
    \   return is_balanced(q) && max_possible_w(q, w) <= q.count\n               \
    \              ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // if q is balanced and less than or equal to sum of\
    \ its elements, then the object q will fly.\n    // if not, then it's not balanced.\n\
    \    let sumOfElements = q.map(Int).reduce(0) {$0 + $1}\n    return sumOfElements\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpln_pvbb7.swift:20:31: error: cannot convert value of type 'Int.Type'\
    \ to expected argument type '(Int) throws -> Int'\n    let sumOfElements = q.map(Int).reduce(0)\
    \ {$0 + $1}\n                              ^\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < w {\n        // Balanced: less than max\
    \ weight\n        return false\n    }\n\n    // Check for a palindrome with sum\
    \ of its elements equal to max weight\n    var rev = 0\n    var revSum = w\n \
    \   for i in q.indices {\n        rev += q[i]\n        if rev != revSum {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpiomokz85/tmpiomokz85.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b73574c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b7326bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b7326b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b7326a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiomokz85                        0x0000563af8da452f <unavailable> + 5423

    5    libc.so.6                          0x00002b4b73760460 __libc_start_main +
    245

    6    tmpiomokz85                        0x0000563af8da4199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count >= w && q.sorted() == q.reversed() else\
    \ {\n        return false\n    }\n\n    let maxWeight = q.count\n    let sumOfElements\
    \ = q.compactMap { $0 }.sum()\n    return maxWeight == sumOfElements && maxWeight\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpljaml2lk.swift:23:45: error: value of type '[Int]' has no member\
    \ 'sum'\n    let sumOfElements = q.compactMap { $0 }.sum()\n                 \
    \       ~~~~~~~~~~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    if q.count == 0 {\n        return true\n    }\n\
    \    \n    // The sum of its elements is less than or equal the maximum possible\
    \ weight.\n    let sumOfElements = q.dropLast().reduce(0, +)\n    \n    if sumOfElements\
    \ > w {\n        return false\n    }\n    \n    if w == 0 {\n        return true\n\
    \    }\n    \n    // It's unbalanced, check the first element to see if it's balanced.\n\
    \    let isBalanced = q.first! == check_first_element_is_balanced(q.first!, w)\n\
    \    \n    if isBalanced {\n        let rest = q.rest\n        \n        return\
    \ will_it_fly(rest, w)\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3x9u5cbw.swift:35:34: error: cannot find 'check_first_element_is_balanced'\
    \ in scope\n    let isBalanced = q.first! == check_first_element_is_balanced(q.first!,\
    \ w)\n                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3x9u5cbw.swift:38:22:\
    \ error: value of type '[Int]' has no member 'rest'\n        let rest = q.rest\n\
    \                   ~ ^~~~\n/tmp/tmp3x9u5cbw.swift:40:27: error: missing argument\
    \ labels 'q:w:' in call\n        return will_it_fly(rest, w)\n               \
    \           ^\n                           q:    w: \n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\tq := q.sorted()\n\tif q.count == 0 || w <= 0 {\n\t\treturn\
    \ true\n\t}\n\treturn q.reduce(+, 0) == w && will_it_fly(q, w - q[0])\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc6xurasn.swift:18:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := q.sorted()\n         ^\n         ;\n/tmp/tmpc6xurasn.swift:18:4:\
    \ error: expected expression\n        q := q.sorted()\n          ^\n/tmp/tmpc6xurasn.swift:18:2:\
    \ warning: expression of type '[Int]' is unused\n        q := q.sorted()\n   \
    \     ^\n/tmp/tmpc6xurasn.swift:22:43: error: missing argument labels 'q:w:' in\
    \ call\n        return q.reduce(+, 0) == w && will_it_fly(q, w - q[0])\n     \
    \                                            ^\n                             \
    \                     q: w: \n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  if len(q) < 2 {\n    return false\n  }\n\n  guard max(q)\
    \ >= w else {\n    return false\n  }\n\n  var sum = 0\n  for v in q {\n    sum\
    \ += v\n  }\n\n  return sum == w && is_palindrome(q)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0q_6jiwb.swift:18:6: error: cannot find 'len' in scope\n  if len(q)\
    \ < 2 {\n     ^~~\n/tmp/tmp0q_6jiwb.swift:22:14: error: missing argument for parameter\
    \ #2 in call\n  guard max(q) >= w else {\n             ^\n             , <#Int#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp0q_6jiwb.swift:22:13:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \  guard max(q) >= w else {\n            ^\n/tmp/tmp0q_6jiwb.swift:31:22: error:\
    \ cannot find 'is_palindrome' in scope\n  return sum == w && is_palindrome(q)\n\
    \                     ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.count == w && is_balanced(q) && is_palindromic(q,\
    \ w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1yfbustm.swift:18:28: error: cannot find 'is_balanced' in scope\n\
    \    return q.count == w && is_balanced(q) && is_palindromic(q, w)\n         \
    \                  ^~~~~~~~~~~\n/tmp/tmp1yfbustm.swift:18:46: error: cannot find\
    \ 'is_palindromic' in scope\n    return q.count == w && is_balanced(q) && is_palindromic(q,\
    \ w)\n                                             ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard let q = q.sorted else { return false }\n    guard\
    \ w <= Int64(q.count) else { return false }\n\n    let total = q.reduce(0) { $0\
    \ + $1 }\n    return q.count == (2 * w) && total == w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4uau0kne.swift:18:11: error: initializer for conditional binding\
    \ must have Optional type, not '() -> [Int]'\n    guard let q = q.sorted else\
    \ { return false }\n          ^       ~~~~~~~~\n/tmp/tmp4uau0kne.swift:19:22:\
    \ error: function 'q' was used as a property; add () to call it\n    guard w <=\
    \ Int64(q.count) else { return false }\n                     ^\n             \
    \         ()\n/tmp/tmp4uau0kne.swift:21:17: error: function 'q' was used as a\
    \ property; add () to call it\n    let total = q.reduce(0) { $0 + $1 }\n     \
    \           ^\n                 ()\n/tmp/tmp4uau0kne.swift:22:12: error: function\
    \ 'q' was used as a property; add () to call it\n    return q.count == (2 * w)\
    \ && total == w\n           ^\n            ()\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxW = Math.max(w, q.sum())\n    return q.isPalindrome\
    \ && maxW <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphdm9yabv.swift:18:16: error: cannot find 'Math' in scope\n    let\
    \ maxW = Math.max(w, q.sum())\n               ^~~~\n/tmp/tmphdm9yabv.swift:18:30:\
    \ error: value of type '[Int]' has no member 'sum'\n    let maxW = Math.max(w,\
    \ q.sum())\n                           ~ ^~~\n/tmp/tmphdm9yabv.swift:19:14: error:\
    \ value of type '[Int]' has no member 'isPalindrome'\n    return q.isPalindrome\
    \ && maxW <= w\n           ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    return sum == w && q.isPalindromic && q.sum < w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwa4dqihz.swift:22:26: error: value of type '[Int]' has no member\
    \ 'isPalindromic'\n    return sum == w && q.isPalindromic && q.sum < w\n     \
    \                  ~ ^~~~~~~~~~~~~\n/tmp/tmpwa4dqihz.swift:22:45: error: value\
    \ of type '[Int]' has no member 'sum'\n    return sum == w && q.isPalindromic\
    \ && q.sum < w\n                                          ~ ^~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 { return false }\n    var maxW = w / q[0]\n\
    \    var total = 0\n    for x in q {\n        if x >= maxW { return false }\n\
    \        total += x\n    }\n    if total < w / 2 { return false }\n    if total\
    \ > w { return true }\n    if maxW > w / 2 { return true }\n    return will_it_fly(q,\
    \ maxW)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpu2qc4e8t.swift:28:23: error: missing argument labels 'q:w:' in\
    \ call\n    return will_it_fly(q, maxW)\n                      ^\n           \
    \            q: w: \n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w, q.count > 0 else { return false }\n\
    \    var max_sum = w\n    var max_weight = 0\n    for element in q {\n       \
    \ if element > max_weight {\n            max_weight = element\n            max_sum\
    \ = max_sum * element\n        } else if element == max_weight {\n           \
    \ max_sum += element\n        }\n    }\n    return max_sum >= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp9zgk9qgz/tmp9zgk9qgz.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c731dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c72ed3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c72ed3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c72ed27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9zgk9qgz                        0x0000562a7a1bd4bf <unavailable> + 5311

    5    libc.so.6                          0x00002b3c733c8460 __libc_start_main +
    245

    6    tmp9zgk9qgz                        0x0000562a7a1bd129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = w\n    \n    for b in q {\n        if max <\
    \ b {\n            max = b\n        }\n    }\n    \n    let reversed = Array(0..<q.count).map\
    \ { q[$0] }.reversed()\n    \n    return (max - q.sum).isLessThanOrEqualTo(max)\
    \ && reversed == q\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1v562u5l.swift:28:21: error: value of type '[Int]' has no member\
    \ 'sum'\n    return (max - q.sum).isLessThanOrEqualTo(max) && reversed == q\n\
    \                  ~ ^~~\n/tmp/tmp1v562u5l.swift:28:54: error: cannot convert\
    \ value of type 'ReversedCollection<[Int]>' to expected argument type '[Int]'\n\
    \    return (max - q.sum).isLessThanOrEqualTo(max) && reversed == q\n        \
    \                                             ^\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxElement = q.reduce(0, { $0 + $1 })\n    let maxWeight\
    \ = maxElement + (maxElement * w)\n    return q.reversed().reduce(maxWeight) {\
    \ $0 <= $1 + $2 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbf5565b3.swift:20:25: error: no exact matches in call to instance\
    \ method 'reduce'\n    return q.reversed().reduce(maxWeight) { $0 <= $1 + $2 }\n\
    \                        ^\n/tmp/tmpbf5565b3.swift:20:25: note: found candidate\
    \ with type '(Int, (Int, Int) throws -> Int) throws -> Int'\n    return q.reversed().reduce(maxWeight)\
    \ { $0 <= $1 + $2 }\n                        ^\n/tmp/tmpbf5565b3.swift:20:25:\
    \ note: found candidate with type '(__owned @escaping (UInt8, UInt8, UInt8) ->\
    \ Bool, (inout @escaping (UInt8, UInt8, UInt8) -> Bool, Int) throws -> ()) throws\
    \ -> (UInt8, UInt8, UInt8) -> Bool'\n    return q.reversed().reduce(maxWeight)\
    \ { $0 <= $1 + $2 }\n                        ^\n/tmp/tmpbf5565b3.swift:20:25:\
    \ error: no 'reduce' candidates produce the expected contextual result type 'Bool'\n\
    \    return q.reversed().reduce(maxWeight) { $0 <= $1 + $2 }\n               \
    \         ^\nSwift.Sequence:2:28: note: 'reduce' produces 'Int', not the expected\
    \ contextual result type 'Bool'\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\nSwift.Sequence:2:28:\
    \ note: 'reduce' produces 'Int', not the expected contextual result type 'Bool'\n\
    \    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\nSwift.Sequence:2:28: note: 'reduce' produces 'Int',\
    \ not the expected contextual result type 'Bool'\n    @inlinable public func reduce<Result>(_\
    \ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Self.Element)\
    \ throws -> Result) rethrows -> Result\n                           ^\nSwift.Sequence:2:28:\
    \ note: 'reduce' produces 'Int', not the expected contextual result type 'Bool'\n\
    \    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum : Int = q.sum()\n    return (maxWeight-q).abs()\
    \ <= maxWeight && sum <= maxWeight\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpngrscq76.swift:18:23: error: value of type '[Int]' has no member\
    \ 'sum'\n    let sum : Int = q.sum()\n                    ~ ^~~\n/tmp/tmpngrscq76.swift:19:13:\
    \ error: cannot find 'maxWeight' in scope\n    return (maxWeight-q).abs() <= maxWeight\
    \ && sum <= maxWeight\n            ^~~~~~~~~\n/tmp/tmpngrscq76.swift:19:35: error:\
    \ cannot find 'maxWeight' in scope\n    return (maxWeight-q).abs() <= maxWeight\
    \ && sum <= maxWeight\n                                  ^~~~~~~~~\n/tmp/tmpngrscq76.swift:19:55:\
    \ error: cannot find 'maxWeight' in scope\n    return (maxWeight-q).abs() <= maxWeight\
    \ && sum <= maxWeight\n                                                      ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Your code here\n    \n    let sorted = q.sorted()\n\
    \    return sorted.count == 2 && sorted[0] < sorted[1] && weight - w(sorted[0])\
    \ >= 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp14n8aekk.swift:21:58: error: cannot find 'weight' in scope\n  \
    \  return sorted.count == 2 && sorted[0] < sorted[1] && weight - w(sorted[0])\
    \ >= 0\n                                                         ^~~~~~\n/tmp/tmp14n8aekk.swift:21:67:\
    \ error: cannot call value of non-function type 'Int'\n    return sorted.count\
    \ == 2 && sorted[0] < sorted[1] && weight - w(sorted[0]) >= 0\n              \
    \                                                    ^\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if isPalindrome(q) && sum(q) <= w {\n        return true\n\
    \    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfgjpl1eo.swift:18:8: error: cannot find 'isPalindrome' in scope\n\
    \    if isPalindrome(q) && sum(q) <= w {\n       ^~~~~~~~~~~~\n/tmp/tmpfgjpl1eo.swift:18:27:\
    \ error: cannot find 'sum' in scope\n    if isPalindrome(q) && sum(q) <= w {\n\
    \                          ^~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w.squared\n    let maxSum = q.max() +\
    \ (q.max() * maxWeight)\n    return q.palindromic && maxSum <= maxWeight\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpa7_39_2d.swift:18:23: error: value of type 'Int' has no member\
    \ 'squared'\n    let maxWeight = w.squared\n                    ~ ^~~~~~~\n/tmp/tmpa7_39_2d.swift:20:14:\
    \ error: value of type '[Int]' has no member 'palindromic'\n    return q.palindromic\
    \ && maxSum <= maxWeight\n           ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let max_weight = w + q.max\n    return q.reduce(0,combine:+)<=max_weight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl6uesf4r.swift:18:24: error: binary operator '+' cannot be applied\
    \ to operands of type 'Int' and '((Int, Int) throws -> Bool) throws -> Int?'\n\
    \    let max_weight = w + q.max\n                     ~ ^ ~~~~~\n/tmp/tmpl6uesf4r.swift:18:24:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    let max_weight = w + q.max\n                       ^\n/tmp/tmpl6uesf4r.swift:19:20:\
    \ error: extraneous argument label 'combine:' in call\n    return q.reduce(0,combine:+)<=max_weight\n\
    \                   ^  ~~~~~~~~\n                      \n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Your code here\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmplpezwvmd/tmplpezwvmd.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5bff09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5bfc00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5bfc00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5bfbff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplpezwvmd                        0x00005615b30412ff <unavailable> + 4863

    5    libc.so.6                          0x00002ba5c00f5460 __libc_start_main +
    245

    6    tmplpezwvmd                        0x00005615b3040f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && is_balanced(q, w)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpye0bkbu9.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && is_balanced(q, w)\n           ^~~~~~~~~~~\n/tmp/tmpye0bkbu9.swift:18:30:\
    \ error: cannot find 'is_balanced' in scope\n    return is_balanced(q) && is_balanced(q,\
    \ w)\n                             ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\tq.reverse()\n\treturn will_it_fly(q, w, reversed: true)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppb9jx1ca.swift:18:4: error: cannot use mutating member on immutable\
    \ value: 'q' is a 'let' constant\n        q.reverse()\n        ~ ^\n/tmp/tmppb9jx1ca.swift:19:37:\
    \ error: extra argument 'reversed' in call\n        return will_it_fly(q, w, reversed:\
    \ true)\n                          ~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let max = w - q.sum\n    return (max > 0 && will_it_fly_helper(q.prefix,\
    \ max))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpk40uqt35.swift:18:21: error: value of type '[Int]' has no member\
    \ 'sum'\n    let max = w - q.sum\n                  ~ ^~~\n/tmp/tmpk40uqt35.swift:19:24:\
    \ error: cannot find 'will_it_fly_helper' in scope\n    return (max > 0 && will_it_fly_helper(q.prefix,\
    \ max))\n                       ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.sorted == q &&\n        q.reduce(0, {$0 + $1})\
    \ <= w &&\n        will_it_fly(q.dropLast(), w)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph4zsbwwq.swift:18:14: error: function produces expected type '[Int]';\
    \ did you mean to call it with '()'?\n    return q.sorted == q &&\n          \
    \ ~~^~~~~~\n                   ()\n/tmp/tmph4zsbwwq.swift:20:20: error: missing\
    \ argument labels 'q:w:' in call\n        will_it_fly(q.dropLast(), w)\n     \
    \              ^\n                    q:            w: \n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for qElement in q {\n        sum +=\
    \ qElement\n    }\n    return will_it_fly(q, w, sum)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_vpc0q3_.swift:22:30: error: extra argument in call\n    return\
    \ will_it_fly(q, w, sum)\n                      ~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max = w\n    for i : Int in 0 ..< q.count {\n   \
    \     max = max > q[i] ? max : q[i]\n    }\n\n    return max >= q.reverse().reduce(0)\
    \ { x, y -> x + y } <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2ibd4xgb.swift:23:44: error: consecutive statements on a line must\
    \ be separated by ';'\n    return max >= q.reverse().reduce(0) { x, y -> x + y\
    \ } <= w\n                                           ^\n                     \
    \                      ;\n/tmp/tmp2ibd4xgb.swift:23:44: error: expected expression\n\
    \    return max >= q.reverse().reduce(0) { x, y -> x + y } <= w\n            \
    \                               ^\n/tmp/tmp2ibd4xgb.swift:23:43: error: cannot\
    \ find 'x' in scope\n    return max >= q.reverse().reduce(0) { x, y -> x + y }\
    \ <= w\n                                          ^\n/tmp/tmp2ibd4xgb.swift:23:16:\
    \ error: adjacent operators are in non-associative precedence group 'ComparisonPrecedence'\n\
    \    return max >= q.reverse().reduce(0) { x, y -> x + y } <= w\n            \
    \   ^                                          ~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard let pal = is_palindromic(q) else {\n        return\
    \ false\n    }\n    \n    let sum = pal.sum()\n    \n    return sum <= w && pal.is_balanced\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpswrgs3ct.swift:18:21: error: cannot find 'is_palindromic' in scope\n\
    \    guard let pal = is_palindromic(q) else {\n                    ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = getSum(q)\n    return sum < w && isBalanced(q)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmps11mrbo9.swift:18:15: error: cannot find 'getSum' in scope\n  \
    \  let sum = getSum(q)\n              ^~~~~~\n/tmp/tmps11mrbo9.swift:19:23: error:\
    \ cannot find 'isBalanced' in scope\n    return sum < w && isBalanced(q)\n   \
    \                   ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Write your function here\n    if q.isEmpty {\n   \
    \     return true\n    }\n    if q.first == q.last {\n        return false\n \
    \   }\n    \n    var maxWeight = w\n    var sum = 0\n    \n    for i in 0..<q.count\
    \ {\n        sum += q[i]\n        if sum > maxWeight {\n            maxWeight\
    \ = sum\n        }\n    }\n    \n    if sum != maxWeight {\n        return false\n\
    \    }\n    \n    if q.first == 0 {\n        return true\n    }\n    \n    if\
    \ q.last == q.first+1 {\n        return false\n    }\n    \n    if will_it_fly(q[1..<q.last-1],\
    \ w-sum+q.last-1) {\n        return true\n    }\n    \n    return will_it_fly(q[q.first...q.first+q.last-1],\
    \ w-sum+q.last)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdni4fypm.swift:44:20: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if q.last == q.first+1 {\n      \
    \             ^\n/tmp/tmpdni4fypm.swift:44:20: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    if q.last == q.first+1\
    \ {\n                   ^\n                 (       ?? <#default value#>)\n/tmp/tmpdni4fypm.swift:44:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if q.last == q.first+1 {\n                   ^\n                \
    \        !\n/tmp/tmpdni4fypm.swift:48:19: error: missing argument labels 'q:w:'\
    \ in call\n    if will_it_fly(q[1..<q.last-1], w-sum+q.last-1) {\n           \
    \       ^\n                   q:               w: \n/tmp/tmpdni4fypm.swift:48:21:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    if will_it_fly(q[1..<q.last-1], w-sum+q.last-1) {\n           \
    \         ^\n/tmp/tmpdni4fypm.swift:48:28: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    if will_it_fly(q[1..<q.last-1],\
    \ w-sum+q.last-1) {\n                           ^\n/tmp/tmpdni4fypm.swift:48:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if will_it_fly(q[1..<q.last-1], w-sum+q.last-1) {\n             \
    \              ^\n                         (      ?? <#default value#>)\n/tmp/tmpdni4fypm.swift:48:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if will_it_fly(q[1..<q.last-1], w-sum+q.last-1) {\n             \
    \              ^\n                               !\n/tmp/tmpdni4fypm.swift:48:45:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    if will_it_fly(q[1..<q.last-1], w-sum+q.last-1) {\n                     \
    \                       ^\n/tmp/tmpdni4fypm.swift:48:45: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    if will_it_fly(q[1..<q.last-1],\
    \ w-sum+q.last-1) {\n                                           "
  stdout: ''
  timestamp: 1660014652
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var qs = [Int]()\n    qs.append(q[0])\n    qs.append(q[1])\n\
    \    \n    var w = w\n    var maxW = 0\n    for n in qs {\n        if n > maxW\
    \ {\n            maxW += n\n        }\n    }\n    if w == maxW {\n        return\
    \ true\n    }\n    \n    var pw = maxW\n    var sw = 0\n    for n in qs {\n  \
    \      sw += n\n        if sw > pw {\n            pw = sw\n        }\n    }\n\
    \    \n    if pw == w {\n        return true\n    }\n    \n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpu3sd3bh7/tmpu3sd3bh7.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b786b564c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b786b25bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b786b25b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b786b25a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu3sd3bh7                        0x0000564fe561256f <unavailable> + 5487

    5    libc.so.6                          0x00002b786b750460 __libc_start_main +
    245

    6    tmpu3sd3bh7                        0x0000564fe56121d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard isBalanced(q: q) && q.reduce(0) { $0 + $1 } <=\
    \ w else { return false }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprrkhqq5z.swift:18:11: error: cannot find 'isBalanced' in scope\n\
    \    guard isBalanced(q: q) && q.reduce(0) { $0 + $1 } <= w else { return false\
    \ }\n          ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var max_sum = w\n    var max_sum_index = 0\n    var is_palindromic\
    \ = true\n    for index1 in a {\n        var sum = 0\n        for index2 in b\
    \ {\n            sum += a[index2]\n        }\n        max_sum = max(w, max_sum)\n\
    \        max_sum_index = max(index2, max_sum_index)\n        if sum != max_sum\
    \ {\n            is_palindromic = false\n            break\n        }\n    }\n\
    \    \n    return is_palindromic && max_sum <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5kf75ro5.swift:21:19: error: cannot find 'a' in scope\n    for\
    \ index1 in a {\n                  ^\n/tmp/tmp5kf75ro5.swift:23:23: error: cannot\
    \ find 'b' in scope\n        for index2 in b {\n                      ^\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  return will_it_fly_helper(q: q, w: w, maxW: w, isBalanced:\
    \ false, numElements: q.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwg9i5roj.swift:18:10: error: cannot find 'will_it_fly_helper' in\
    \ scope\n  return will_it_fly_helper(q: q, w: w, maxW: w, isBalanced: false, numElements:\
    \ q.count)\n         ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w <= 0 || w >= q.count {\n       \
    \ return false\n    }\n    // find out the maximum possible sum of elements\n\
    \    let maxPossibleSum = w + q[q.count-1]\n    for element in q {\n        if\
    \ element > maxPossibleSum {\n            return false\n        }\n    }\n   \
    \ // check balance\n    for element in q {\n        if element != (q[q.count-1]\
    \ - element) {\n            return false\n        }\n    }\n    // check sum\n\
    \    return maxPossibleSum < w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp19ptit9q/tmp19ptit9q.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b688de19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b688db10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b688db10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b688db0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp19ptit9q                        0x0000556bdcd8651f <unavailable> + 5407

    5    libc.so.6                          0x00002b688e005460 __libc_start_main +
    245

    6    tmp19ptit9q                        0x0000556bdcd86189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = q.sum()\n    for val in q {\n        if val\
    \ < 0 || val > w {\n            return false\n        }\n        sum += val\n\
    \    }\n    return sum >= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6wngx585.swift:18:17: error: value of type '[Int]' has no member\
    \ 'sum'\n    var sum = q.sum()\n              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxSum = w.toIntMax()\n    return w.isBalancedAndSumLessThanOrEqualToMax(q,\
    \ maxSum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc6rm4xfw.swift:18:20: error: value of type 'Int' has no member\
    \ 'toIntMax'\n    let maxSum = w.toIntMax()\n                 ~ ^~~~~~~~\n/tmp/tmpc6rm4xfw.swift:19:14:\
    \ error: value of type 'Int' has no member 'isBalancedAndSumLessThanOrEqualToMax'\n\
    \    return w.isBalancedAndSumLessThanOrEqualToMax(q, maxSum)\n           ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code here\n    for _ in 0 ..< w.pow 2 {\n\
    \        if let q = q.filter{\n            q.count >= w\n        }.sorted(by:\
    \ {$0 < $1}).last, let x = q.reversed() {\n            if q.dropLast().sorted\
    \ == x {\n                return true\n            }\n        }\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbdr5ye8o.swift:19:26: error: expected '{' to start the body of\
    \ for-each loop\n    for _ in 0 ..< w.pow 2 {\n                         ^\n/tmp/tmpbdr5ye8o.swift:22:10:\
    \ error: consecutive statements on a line must be separated by ';'\n        }.sorted(by:\
    \ {$0 < $1}).last, let x = q.reversed() {\n         ^\n         ;\n/tmp/tmpbdr5ye8o.swift:22:37:\
    \ error: consecutive statements on a line must be separated by ';'\n        }.sorted(by:\
    \ {$0 < $1}).last, let x = q.reversed() {\n                                  \
    \  ^\n                                    ;\n/tmp/tmpbdr5ye8o.swift:22:37: error:\
    \ expected expression\n        }.sorted(by: {$0 < $1}).last, let x = q.reversed()\
    \ {\n                                    ^\n/tmp/tmpbdr5ye8o.swift:19:22: error:\
    \ value of type 'Int' has no member 'pow'\n    for _ in 0 ..< w.pow 2 {\n    \
    \               ~ ^~~\n/tmp/tmpbdr5ye8o.swift:22:60: error: extra trailing closure\
    \ passed in call\n        }.sorted(by: {$0 < $1}).last, let x = q.reversed() {\n\
    \                                                           ^\n/tmp/tmpbdr5ye8o.swift:23:29:\
    \ error: function produces expected type '[Int]'; did you mean to call it with\
    \ '()'?\n            if q.dropLast().sorted == x {\n               ~~~~~~~~~~~~~^~~~~~\n\
    \                                  ()\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\tlet sum = 0\n\tfor el in q {\n\t\tsum += el\n\t}\n\treturn\
    \ sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp993onv3c.swift:20:7: error: left side of mutating operator isn't\
    \ mutable: 'sum' is a 'let' constant\n                sum += el\n            \
    \    ~~~ ^\n/tmp/tmp993onv3c.swift:18:2: note: change 'let' to 'var' to make it\
    \ mutable\n        let sum = 0\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0co2ricr/tmp0co2ricr.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63a3c4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63a3943b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63a3943988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63a39427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0co2ricr                        0x00005649697ae3bb <unavailable> + 5051

    5    libc.so.6                          0x00002b63a3e38460 __libc_start_main +
    245

    6    tmp0co2ricr                        0x00005649697adf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return will_it_fly_helper(q, w, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1rbl5wzt.swift:18:12: error: cannot find 'will_it_fly_helper' in\
    \ scope\n    return will_it_fly_helper(q, w, 0)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var maxSum: Int = 0\n    var minSum: Int = 0\n\n    for\
    \ el in q {\n        minSum = minSum * 10 + el\n        maxSum = maxSum * 10 +\
    \ el\n    }\n\n    // The object q will fly if the sum is less than or equal the\
    \ maximum possible weight.\n    return maxSum <= w && minSum >= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp1t8bnw92/tmp1t8bnw92.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b96b0af9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b96b07f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b96b07f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b96b07ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1t8bnw92                        0x0000559f1ced746f <unavailable> + 5231

    5    libc.so.6                          0x00002b96b0ce5460 __libc_start_main +
    245

    6    tmp1t8bnw92                        0x0000559f1ced70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let (maxWeight, max) = (w, q.max())\n    var sum = 0\n\
    \    for v in q {\n        sum += v\n        if sum > maxWeight {\n          \
    \  return false\n        }\n    }\n    sum <= max\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgsfax315.swift:26:12: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    sum <= max\n           ^\n/tmp/tmpgsfax315.swift:18:21:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let (maxWeight, max) = (w, q.max())\n            \
    \        ^\n    guard                               else { return <#default value#>\
    \ }\n/tmp/tmpgsfax315.swift:18:28: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    let (maxWeight, max) = (w, q.max())\n\
    \                           ^\n                                        ?? <#default\
    \ value#>\n/tmp/tmpgsfax315.swift:18:28: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    let (maxWeight, max) = (w,\
    \ q.max())\n                           ^\n                                   \
    \    !\n/tmp/tmpgsfax315.swift:26:12: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    sum <= max\n           ^\n     \
    \          ?? <#default value#>\n/tmp/tmpgsfax315.swift:26:12: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    sum <=\
    \ max\n           ^\n              !\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w.count else { return false }\n    guard\
    \ isBalanced(q: q) else { return false }\n    let sumOfElements = sum(q: q)\n\
    \    return sumOfElements <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpooe_0bdw.swift:18:24: error: value of type 'Int' has no member\
    \ 'count'\n    guard q.count == w.count else { return false }\n              \
    \       ~ ^~~~~\n/tmp/tmpooe_0bdw.swift:19:11: error: cannot find 'isBalanced'\
    \ in scope\n    guard isBalanced(q: q) else { return false }\n          ^~~~~~~~~~\n\
    /tmp/tmpooe_0bdw.swift:20:25: error: cannot find 'sum' in scope\n    let sumOfElements\
    \ = sum(q: q)\n                        ^~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = 0\n    for x in q {\n        sum += x\n   \
    \ }\n    return sum == w && is_balanced(q)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbrcxe4a7.swift:20:13: error: left side of mutating operator isn't\
    \ mutable: 'sum' is a 'let' constant\n        sum += x\n        ~~~ ^\n/tmp/tmpbrcxe4a7.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let sum = 0\n    ^~~\n \
    \   var\n/tmp/tmpbrcxe4a7.swift:22:24: error: cannot find 'is_balanced' in scope\n\
    \    return sum == w && is_balanced(q)\n                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let q = q.map { $0 < 0 ? -$0 : $0 }\n  guard let n = q.count\
    \ else { return false }\n  var max = 0\n  for item in q {\n    max += item\n \
    \ }\n  max += w // We don't want the query to go over the limit.\n  guard max\
    \ >= w else { return false }\n\n  var sum = 0\n  for item in q {\n    sum += item\n\
    \  }\n  return sum == max && isPalindromic(q)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb2cfhztg.swift:19:9: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n  guard let n = q.count else { return false\
    \ }\n        ^       ~~~~~~~\n/tmp/tmpb2cfhztg.swift:31:24: error: cannot find\
    \ 'isPalindromic' in scope\n  return sum == max && isPalindromic(q)\n        \
    \               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 || w == 0 {\n        return true\n  \
    \  }\n    \n    var maxWeight = w\n    for n in q {\n        if n >= maxWeight\
    \ {\n            return false\n        }\n        maxWeight -= n\n    }\n    \n\
    \    if maxWeight <= 0 {\n        return true\n    }\n    \n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa0gx6yee/tmpa0gx6yee.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0821acfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08217c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08217c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08217c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa0gx6yee                        0x00005580e837557b <unavailable> + 5499

    5    libc.so.6                          0x00002b0821cbb460 __libc_start_main +
    245

    6    tmpa0gx6yee                        0x00005580e8375129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let mut sum = 0\n    for v in q {\n        if sum > w\
    \ {\n            return false\n        }\n        sum += v\n    }\n    return\
    \ sum == w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp05ppo4pn.swift:18:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut sum = 0\n\
    \            ^\n/tmp/tmp05ppo4pn.swift:18:13: note: join the identifiers together\n\
    \    let mut sum = 0\n        ~~~~^~~\n        mutsum\n/tmp/tmp05ppo4pn.swift:18:13:\
    \ note: join the identifiers together with camel-case\n    let mut sum = 0\n \
    \       ~~~~^~~\n        mutSum\n/tmp/tmp05ppo4pn.swift:20:12: error: cannot find\
    \ 'sum' in scope\n        if sum > w {\n           ^~~\n/tmp/tmp05ppo4pn.swift:23:9:\
    \ error: cannot find 'sum' in scope\n        sum += v\n        ^~~\n/tmp/tmp05ppo4pn.swift:25:12:\
    \ error: cannot find 'sum' in scope\n    return sum == w\n           ^~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\tlet n = q.count\n\tvar sum: Int = 0\n\tfor i = 0; i < n;\
    \ i++ {\n\t\tsum += q[i]\n\t}\n\tif n > w && sum <= w {\n\t\treturn true\n\t}\n\
    \treturn false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpeta7zgl_.swift:20:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for i = 0; i < n; i++ {\n        ^   ~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    for v in q.dropLast() {\n        if w <= 0 {\n      \
    \      return false\n        }\n        if v < 0 {\n            return true\n\
    \        }\n        w -= v\n    }\n    return w <= 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprtcml9qs.swift:25:11: error: left side of mutating operator isn't\
    \ mutable: 'w' is a 'let' constant\n        w -= v\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\tlet sum: Int = q.reduce { $0 + $1 }\n\tif sum >= w {\n\t\
    \treturn true\n\t}\n\treturn false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvqddd5ga.swift:18:25: error: missing argument for parameter #1\
    \ in call\n        let sum: Int = q.reduce { $0 + $1 }\n                     \
    \          ^\n                               (<#Int#>)\nSwift.Sequence:2:28: note:\
    \ 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return will_it_fly_internal(q, w: w) \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp545hsrkj.swift:18:12: error: cannot find 'will_it_fly_internal'\
    \ in scope\n    return will_it_fly_internal(q, w: w) \n           ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\treturn isPalindromic && allWeightsLessOrEqual(w, w)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzbtk8jpg.swift:18:9: error: cannot find 'isPalindromic' in scope\n\
    \        return isPalindromic && allWeightsLessOrEqual(w, w)\n               ^~~~~~~~~~~~~\n\
    /tmp/tmpzbtk8jpg.swift:18:26: error: cannot find 'allWeightsLessOrEqual' in scope\n\
    \        return isPalindromic && allWeightsLessOrEqual(w, w)\n               \
    \                 ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014647
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  if q.count == 0 || w == 0 {\n    return false\n  }\n  if\
    \ q.count < 2 {\n    return false\n  }\n  var max_sum = Int((pow(w.toInt(), 2))\
    \ - (q.reduce(0, +) * q.count))\n  if w < max_sum {\n    return false\n  }\n \
    \ if max_sum > 0 {\n    return true\n  }\n  return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphlfgsgye.swift:24:22: error: cannot find 'pow' in scope\n  var\
    \ max_sum = Int((pow(w.toInt(), 2)) - (q.reduce(0, +) * q.count))\n          \
    \           ^~~\n/tmp/tmphlfgsgye.swift:24:28: error: value of type 'Int' has\
    \ no member 'toInt'\n  var max_sum = Int((pow(w.toInt(), 2)) - (q.reduce(0, +)\
    \ * q.count))\n                         ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014657
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxW = (w.powi(2) + 1).max(1)\n    return is_balanced(q)\
    \ && q.sum() <= maxW\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3ixacpb8.swift:18:19: error: value of type 'Int' has no member\
    \ 'powi'\n    let maxW = (w.powi(2) + 1).max(1)\n                ~ ^~~~\n/tmp/tmp3ixacpb8.swift:19:12:\
    \ error: cannot find 'is_balanced' in scope\n    return is_balanced(q) && q.sum()\
    \ <= maxW\n           ^~~~~~~~~~~\n/tmp/tmp3ixacpb8.swift:19:32: error: value\
    \ of type '[Int]' has no member 'sum'\n    return is_balanced(q) && q.sum() <=\
    \ maxW\n                             ~ ^~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = w\n    var qRev = [Int]()\n    for x\
    \ in q {\n        qRev.insert(x, at: 0)\n    }\n    let qReversed = qRev.reversed()\n\
    \    let res = qReversed.sum() <= maxWeight\n    if res {\n        let qBalanced\
    \ = q.reversed()\n        let qBalancedSum = qBalanced.sum() <= maxWeight\n  \
    \      if qBalancedSum {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprrdnm4pn.swift:24:25: error: value of type 'ReversedCollection<[Int]>'\
    \ has no member 'sum'\n    let res = qReversed.sum() <= maxWeight\n          \
    \    ~~~~~~~~~ ^~~\n/tmp/tmprrdnm4pn.swift:27:38: error: value of type 'ReversedCollection<[Int]>'\
    \ has no member 'sum'\n        let qBalancedSum = qBalanced.sum() <= maxWeight\n\
    \                           ~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if !is_palindromic(q) {\n        return false\n    }\n\
    \    let m = calculate_maximum_possible_w(q)\n    return is_balanced(q, m, w)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo6jz2zjb.swift:18:9: error: cannot find 'is_palindromic' in scope\n\
    \    if !is_palindromic(q) {\n        ^~~~~~~~~~~~~~\n/tmp/tmpo6jz2zjb.swift:21:13:\
    \ error: cannot find 'calculate_maximum_possible_w' in scope\n    let m = calculate_maximum_possible_w(q)\n\
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo6jz2zjb.swift:22:12: error:\
    \ cannot find 'is_balanced' in scope\n    return is_balanced(q, m, w)\n      \
    \     ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = q.map { $0 + $1 }.reduce(0)\n\n    let max:\
    \ Int = w / 2\n\n    return sum == max && q.sorted() == q.reversed()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplr_wynv9.swift:18:21: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    var sum = q.map\
    \ { $0 + $1 }.reduce(0)\n                    ^\n/tmp/tmplr_wynv9.swift:18:41:\
    \ error: missing argument for parameter #2 in call\n    var sum = q.map { $0 +\
    \ $1 }.reduce(0)\n                                        ^\n                \
    \                        , <#(Int, Int) throws -> Int#>\nSwift.Sequence:2:28:\
    \ note: 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n\t\n\t// Base case: if the array of weights equals the maximum\
    \ possible weight, then yes, the palindrome will fly.\n\tif q.count == w {\n\t\
    \treturn true\n\t}\n\t\n\t// Recursive case: for each element in q, check to see\
    \ if it will be fly, and if it will fly, check that the sum of its elements won't\
    \ exceed the maximum weight.\n\tfor i := 0; i < len(q); i++ {\n\t\t\n\t\t// Calculate\
    \ the sum of the current element's weights.\n\t\ts := 0\n\t\tfor j := 0; j < i;\
    \ j++ {\n\t\t\ts += q[j] * q[j]\n\t\t}\n\t\t\n\t\t// Check if the sum is less\
    \ than the maximum weight.\n\t\tif s < w {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\
    \t// If the sum is greater than the maximum weight, then the array is balanced.\n\
    \t\tif s > w {\n\t\t\treturn true\n\t\t}\n\t}\n\t\n\t// Otherwise, the array of\
    \ weights is unbalanced and we can't determine if it will fly.\n\treturn false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8ogsa8s6.swift:25:9: error: expected type\n        for i := 0;\
    \ i < len(q); i++ {\n               ^\n                <#type#>\n/tmp/tmp8ogsa8s6.swift:25:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(q);\
    \ i++ {\n               ^\n/tmp/tmp8ogsa8s6.swift:25:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(q); i++ {\n      \
    \         ^\n/tmp/tmp8ogsa8s6.swift:28:4: error: consecutive statements on a line\
    \ must be separated by ';'\n                s := 0\n                 ^\n     \
    \            ;\n/tmp/tmp8ogsa8s6.swift:28:5: error: expected expression\n    \
    \            s := 0\n                  ^\n/tmp/tmp8ogsa8s6.swift:29:10: error:\
    \ expected type\n                for j := 0; j < i; j++ {\n                  \
    \     ^\n                        <#type#>\n/tmp/tmp8ogsa8s6.swift:29:10: error:\
    \ expected 'in' after for-each pattern\n                for j := 0; j < i; j++\
    \ {\n                       ^\n/tmp/tmp8ogsa8s6.swift:29:10: error: expected Sequence\
    \ expression for for-each loop\n                for j := 0; j < i; j++ {\n   \
    \                    ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    for _, b := range q {\n        if b != 0 {\n        \
    \    return false\n        }\n    }\n    if w == 0 {\n        return true\n  \
    \  }\n    var rev = q\n    for _, b := range rev {\n        rev[b] = -1\n    }\n\
    \    for i := len(q) - 1; i >= 0; i-- {\n        c := rev[q[i]]\n        if c\
    \ == -1 {\n            return false\n        }\n        rev[c] = i\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp09o2fmdv.swift:18:10: error: expected 'in' after for-each pattern\n\
    \    for _, b := range q {\n         ^\n/tmp/tmp09o2fmdv.swift:18:10: error: expected\
    \ Sequence expression for for-each loop\n    for _, b := range q {\n         ^\n\
    /tmp/tmp09o2fmdv.swift:27:10: error: expected 'in' after for-each pattern\n  \
    \  for _, b := range rev {\n         ^\n/tmp/tmp09o2fmdv.swift:27:10: error: expected\
    \ Sequence expression for for-each loop\n    for _, b := range rev {\n       \
    \  ^\n/tmp/tmp09o2fmdv.swift:30:12: error: expected type\n    for i := len(q)\
    \ - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmp09o2fmdv.swift:30:12:\
    \ error: expected 'in' after for-each pattern\n    for i := len(q) - 1; i >= 0;\
    \ i-- {\n           ^\n/tmp/tmp09o2fmdv.swift:30:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := len(q) - 1; i >= 0; i-- {\n     \
    \      ^\n/tmp/tmp09o2fmdv.swift:31:10: error: consecutive statements on a line\
    \ must be separated by ';'\n        c := rev[q[i]]\n         ^\n         ;\n/tmp/tmp09o2fmdv.swift:31:11:\
    \ error: expected expression\n        c := rev[q[i]]\n          ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  if q.isEmpty {\n    return false\n  }\n\n  // We assume\
    \ that the query is balanced up to a point. If it's not, then\n  // we return\
    \ false immediately.\n  var max_weight: Int = w\n  var max_sum_up_to_w: Int =\
    \ q.reduce(0) { $0 + $1 }\n  var max_sum_up_to_w_no_zero: Int = q.reduce(0) {\
    \ $0 + $1 }\n\n  for index in 0..q.count {\n    var q = q[index]\n    let sum_up_to_w\
    \ = q.reduce(0) { $0 + $1 }\n    if sum_up_to_w > max_sum_up_to_w {\n      max_sum_up_to_w\
    \ = sum_up_to_w\n      max_weight = w\n    }\n    if sum_up_to_w_no_zero < max_sum_up_to_w_no_zero\
    \ {\n      max_sum_up_to_w_no_zero = sum_up_to_w_no_zero\n    }\n  }\n  if max_sum_up_to_w_no_zero\
    \ != max_sum_up_to_w {\n    return false\n  }\n  return max_sum_up_to_w <= max_weight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy7247lcw.swift:28:17: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n  for index in 0..q.count {\n                ^~\n     \
    \           ...\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    if q.count < 2 {\n        return true\n    }\n\
    \    \n    if isPalindrome(q) && q.reduce(0) { (total, item) -> Int in\n     \
    \   return total + item\n    }  == w {\n        return true\n    }\n    \n   \
    \ return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpse3h_jl8.swift:23:8: error: cannot find 'isPalindrome' in scope\n\
    \    if isPalindrome(q) && q.reduce(0) { (total, item) -> Int in\n       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var a = 0\n    q.sort() { a, b = $0 > $1 }\n    var maxw\
    \ = w * w / 2\n    return a.count == q.count && maxw <= w * (w + q.count) && sumInt(q)\
    \ <= maxw\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnv8tuikd.swift:19:17: error: consecutive statements on a line must\
    \ be separated by ';'\n    q.sort() { a, b = $0 > $1 }\n                ^\n  \
    \              ;\n/tmp/tmpnv8tuikd.swift:19:17: error: expected expression\n \
    \   q.sort() { a, b = $0 > $1 }\n                ^\n/tmp/tmpnv8tuikd.swift:19:14:\
    \ error: contextual type for closure argument list expects 2 arguments, which\
    \ cannot be implicitly ignored\n    q.sort() { a, b = $0 > $1 }\n            \
    \ ^\n               _,_ in\n/tmp/tmpnv8tuikd.swift:19:7: error: cannot use mutating\
    \ member on immutable value: 'q' is a 'let' constant\n    q.sort() { a, b = $0\
    \ > $1 }\n    ~ ^\n/tmp/tmpnv8tuikd.swift:19:16: error: cannot convert value of\
    \ type 'Int' to closure result type 'Bool'\n    q.sort() { a, b = $0 > $1 }\n\
    \               ^\n/tmp/tmpnv8tuikd.swift:21:63: error: cannot find 'sumInt' in\
    \ scope\n    return a.count == q.count && maxw <= w * (w + q.count) && sumInt(q)\
    \ <= maxw\n                                                              ^~~~~~\n\
    /tmp/tmpnv8tuikd.swift:21:14: error: value of type 'Int' has no member 'count'\n\
    \    return a.count == q.count && maxw <= w * (w + q.count) && sumInt(q) <= maxw\n\
    \           ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var w = w\n    var sum = 0\n    var bal = 0\n    for\
    \ i in q.indices {\n        let x = q[i]\n        sum += x\n        bal += x >\
    \ 0 ? 1 : 0\n        if sum > w {\n            bal = 1\n            sum = 0\n\
    \        }\n    }\n    return bal > 0 && sum < w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp2q2hey_t/tmp2q2hey_t.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7550943c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b755063ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b755063a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75506397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2q2hey_t                        0x000055a07fae959b <unavailable> + 5531

    5    libc.so.6                          0x00002b7550b2f460 __libc_start_main +
    245

    6    tmp2q2hey_t                        0x000055a07fae9149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return false\n    }\n    var\
    \ i = q.count\n    var j = q.count\n    while i > 0 && j > 0 {\n        if q[i-1]\
    \ > q[j-1] {\n            i -= 1\n        } else {\n            j -= 1\n     \
    \   }\n    }\n    if i == 0 || j == 0 {\n        return false\n    }\n    if i\
    \ == q.count {\n        return true\n    }\n    if j == q.count {\n        return\
    \ true\n    }\n    return q[i-1] == q[j-1] && will_it_fly(q[i-1:], w) && will_it_fly(q[j+1:],\
    \ w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo5ayzmpm.swift:39:49: error: expected ',' separator\n    return\
    \ q[i-1] == q[j-1] && will_it_fly(q[i-1:], w) && will_it_fly(q[j+1:], w)\n   \
    \                                             ^\n                            \
    \                    ,\n/tmp/tmpo5ayzmpm.swift:39:49: error: expected expression\
    \ in list of expressions\n    return q[i-1] == q[j-1] && will_it_fly(q[i-1:],\
    \ w) && will_it_fly(q[j+1:], w)\n                                            \
    \    ^\n/tmp/tmpo5ayzmpm.swift:39:76: error: expected ',' separator\n    return\
    \ q[i-1] == q[j-1] && will_it_fly(q[i-1:], w) && will_it_fly(q[j+1:], w)\n   \
    \                                                                        ^\n \
    \                                                                          ,\n\
    /tmp/tmpo5ayzmpm.swift:39:76: error: expected expression in list of expressions\n\
    \    return q[i-1] == q[j-1] && will_it_fly(q[i-1:], w) && will_it_fly(q[j+1:],\
    \ w)\n                                                                       \
    \    ^\n/tmp/tmpo5ayzmpm.swift:39:43: error: missing argument labels 'q:w:' in\
    \ call\n    return q[i-1] == q[j-1] && will_it_fly(q[i-1:], w) && will_it_fly(q[j+1:],\
    \ w)\n                                          ^\n                          \
    \                 q:       w: \n/tmp/tmpo5ayzmpm.swift:39:45: error: cannot convert\
    \ value of type 'Int' to expected argument type '[Int]'\n    return q[i-1] ==\
    \ q[j-1] && will_it_fly(q[i-1:], w) && will_it_fly(q[j+1:], w)\n             \
    \                               ^\n/tmp/tmpo5ayzmpm.swift:39:70: error: missing\
    \ argument labels 'q:w:' in call\n    return q[i-1] == q[j-1] && will_it_fly(q[i-1:],\
    \ w) && will_it_fly(q[j+1:], w)\n                                            \
    \                         ^\n                                                \
    \                      q:       w: \n/tmp/tmpo5ayzmpm.swift:39:72: error: cannot\
    \ convert value of type 'Int' to expected argument type '[Int]'\n    return q[i-1]\
    \ == q[j-1] && will_it_fly(q[i-1:], w) && will_it_fly(q[j+1:], w)\n          \
    \                                                         "
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 0 {\n        return true\n    }\n    \n\
    \    \n    if w == 0 {\n        return true\n    }\n\n    \n    if q[q.count/2-1]\
    \ != w {\n        return false\n    }\n    \n    let x = q.sliceArray(startIndex:\
    \ q.count/2-1, endIndex: q.count).reversed()\n    let y = q.sliceArray(startIndex:\
    \ 0, endIndex: q.count).reversed()\n    return x.reduce(+) == w && y.reduce(+)\
    \ == w\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7frxecpw.swift:32:15: error: value of type '[Int]' has no member\
    \ 'sliceArray'\n    let x = q.sliceArray(startIndex: q.count/2-1, endIndex: q.count).reversed()\n\
    \            ~ ^~~~~~~~~~\n/tmp/tmp7frxecpw.swift:33:15: error: value of type\
    \ '[Int]' has no member 'sliceArray'\n    let y = q.sliceArray(startIndex: 0,\
    \ endIndex: q.count).reversed()\n            ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard let a = q.filter { q[$0] > 0 }.map { Int(String(a[$0]))\
    \ },\n        a.count <= w else {\n        return false\n    }\n    return a.reduce(0)\
    \ { $0 + $1 < $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpf01mpd1l.swift:18:59: error: cannot find 'a' in scope\n    guard\
    \ let a = q.filter { q[$0] > 0 }.map { Int(String(a[$0])) },\n               \
    \                                           ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let n = q.count\n    for i in 0..<n {\n        if q[i]\
    \ != i + 1 {\n            return false\n        }\n    }\n    let maxWeight =\
    \ maxOf(q)\n    if w == 0 {\n        return true\n    }\n    return maxWeight\
    \ <= w && will_it_fly(q, maxWeight - w)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp14zum5vc.swift:24:21: error: cannot find 'maxOf' in scope\n   \
    \ let maxWeight = maxOf(q)\n                    ^~~~~\n/tmp/tmp14zum5vc.swift:28:41:\
    \ error: missing argument labels 'q:w:' in call\n    return maxWeight <= w &&\
    \ will_it_fly(q, maxWeight - w)\n                                        ^\n \
    \                                        q: w: \n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    return sum < w && (q.reduce(0, +) == q)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9bx1r5ay.swift:22:39: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and '[Int]'\n    return sum < w && (q.reduce(0, +)\
    \ == q)\n                       ~~~~~~~~~~~~~~ ^  ~\n/tmp/tmp9bx1r5ay.swift:22:39:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    return sum < w && (q.reduce(0, +) == q)\n                  \
    \                    ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = 2 * w + 1\n    return is_balanced(q)\
    \ && is_palindromic(q) && sum_of_elements(q) <= maxWeight\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpswg_6jcg.swift:19:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && is_palindromic(q) && sum_of_elements(q) <= maxWeight\n\
    \           ^~~~~~~~~~~\n/tmp/tmpswg_6jcg.swift:19:30: error: cannot find 'is_palindromic'\
    \ in scope\n    return is_balanced(q) && is_palindromic(q) && sum_of_elements(q)\
    \ <= maxWeight\n                             ^~~~~~~~~~~~~~\n/tmp/tmpswg_6jcg.swift:19:51:\
    \ error: cannot find 'sum_of_elements' in scope\n    return is_balanced(q) &&\
    \ is_palindromic(q) && sum_of_elements(q) <= maxWeight\n                     \
    \                             ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return isBalanced(q) && sumOfElements(q) <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprg1nsa4a.swift:18:12: error: cannot find 'isBalanced' in scope\n\
    \    return isBalanced(q) && sumOfElements(q) <= w\n           ^~~~~~~~~~\n/tmp/tmprg1nsa4a.swift:18:29:\
    \ error: cannot find 'sumOfElements' in scope\n    return isBalanced(q) && sumOfElements(q)\
    \ <= w\n                            ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    var i = 0\n    var j = q.length - 1 \n    var sum\
    \ = 0\n    \n    while i < j {\n        sum += q[i] + q[j]\n        i += 1\n \
    \       j -= 1\n    }\n    \n    return sum == w && sum >= w/2\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcs_0od31.swift:20:15: error: value of type '[Int]' has no member\
    \ 'length'\n    var j = q.length - 1 \n            ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count == w else {\n        return false\n   \
    \ }\n    \n    let totalWeight = q.sum\n    guard totalWeight <= w else {\n  \
    \      return false\n    }\n    \n    var reversed = q.reversed()\n    if let\
    \ firstElement = q.first {\n        if let lastElement = q.last {\n          \
    \  if firstElement == lastElement {\n                return true\n           \
    \ }\n            guard reversed[0] == firstElement else {\n                return\
    \ false\n            }\n            guard reversed[reversed.count-1] == lastElement\
    \ else {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvlvb3ett.swift:22:25: error: value of type '[Int]' has no member\
    \ 'sum'\n    let totalWeight = q.sum\n                      ~ ^~~\n/tmp/tmpvlvb3ett.swift:33:28:\
    \ error: cannot convert value of type 'Int' to expected argument type 'ReversedCollection<[Int]>.Index'\n\
    \            guard reversed[0] == firstElement else {\n                      \
    \     ^\n/tmp/tmpvlvb3ett.swift:36:42: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<[Int]>.Index'\n            guard\
    \ reversed[reversed.count-1] == lastElement else {\n                         \
    \                ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // TODO: implement this\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7e2qpe3_/tmp7e2qpe3_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5793996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b579368db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b579368d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b579368c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7e2qpe3_                        0x0000557b16c742ff <unavailable> + 4863

    5    libc.so.6                          0x00002b5793b82460 __libc_start_main +
    245

    6    tmp7e2qpe3_                        0x0000557b16c73f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014267
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // write your code in here\n    var maxSum = Int()\n\
    \    for i in 0 ..< w.reverse().count{\n        maxSum = maxSum + q[i]\n    }\n\
    \    \n    \n    if w*maxSum == q.count {\n        let r = w.reverse()\n     \
    \   if r == q {\n            return true\n        } else {\n            return\
    \ false\n        }\n        \n    } else {\n        return false\n    }\n    \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn_y23yti.swift:20:22: error: value of type 'Int' has no member\
    \ 'reverse'\n    for i in 0 ..< w.reverse().count{\n                   ~ ^~~~~~~\n\
    /tmp/tmpn_y23yti.swift:26:19: error: value of type 'Int' has no member 'reverse'\n\
    \        let r = w.reverse()\n                ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var r = false\n    var s = q[0]\n    q.forEach {\n  \
    \      if s > w {\n            r ^= true\n        } else {\n            r ^= false\n\
    \        }\n        s += $0\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo62rf6hw.swift:22:15: error: binary operator '^=' cannot be applied\
    \ to two 'Bool' operands\n            r ^= true\n              ^\nSwift.BinaryInteger:1:17:\
    \ note: candidate requires that 'Bool' conform to 'BinaryInteger' (requirement\
    \ specified as 'Self' : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 || w <= 0 || w*w < q.count+1 {\n     \
    \   return false\n    }\n    // Compute the sum q[1..q[1..q[0]]) and the maximum\
    \ possible weight w.\n    let maxW = w*w\n    let sum = q.map{ $0 + $1 }.reduce(0,\
    \ +)\n    \n    // Check if the sum is equal to the maximum possible weight.\n\
    \    return sum == maxW\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnbkgmyki.swift:23:20: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n    let sum = q.map{\
    \ $0 + $1 }.reduce(0, +)\n                   ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q) && sum(q) <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7mbwti8d.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q) && sum(q) <= w\n           ^~~~~~~~~~~\n/tmp/tmp7mbwti8d.swift:18:30:\
    \ error: cannot find 'sum' in scope\n    return is_balanced(q) && sum(q) <= w\n\
    \                             ^~~\n"
  stdout: ''
  timestamp: 1660014646
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // If the object is unbalanced, or if the sum of its\
    \ elements exceeds the maximum possible weight then it doesn't fly.\n    guard\
    \ q.isEmpty || sumOfElements(q) < w else { return false }\n\n    // If the object\
    \ is balanced and it's less than or equal to the maximum possible weight then\
    \ it fly.\n    return isBalanced(q) && w <= sumOfElements(q)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwhg9pomp.swift:19:24: error: cannot find 'sumOfElements' in scope\n\
    \    guard q.isEmpty || sumOfElements(q) < w else { return false }\n         \
    \              ^~~~~~~~~~~~~\n/tmp/tmpwhg9pomp.swift:22:12: error: cannot find\
    \ 'isBalanced' in scope\n    return isBalanced(q) && w <= sumOfElements(q)\n \
    \          ^~~~~~~~~~\n/tmp/tmpwhg9pomp.swift:22:34: error: cannot find 'sumOfElements'\
    \ in scope\n    return isBalanced(q) && w <= sumOfElements(q)\n              \
    \                   ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Write your code here.\n    var sum: Int = 0\n    for\
    \ el in q {\n        sum += el\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptc0euns6/tmptc0euns6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4143a38c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b414372fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b414372f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b414372e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptc0euns6                        0x000056414a9bd52b <unavailable> + 5419

    5    libc.so.6                          0x00002b4143c24460 __libc_start_main +
    245

    6    tmptc0euns6                        0x000056414a9bd0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014648
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var left  = 0\n    var right = 0\n    var max   = w\n\
    \    var sum   = w\n    var fly = true\n\n    for var i in q.indices {\n     \
    \   if sum < max {\n            sum += q[i]\n            left  = sum\n       \
    \ } else {\n            fly = false\n            max = sum\n        }\n\n    \
    \    if max < w {\n            sum -= q[i]\n            right = sum\n        }\n\
    \    }\n\n    return fly\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpk0ucgv09/tmpk0ucgv09.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6bc1cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6bbec5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6bbec5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6bbec47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk0ucgv09                        0x000055658e85d4df <unavailable> + 5343

    5    libc.so.6                          0x00002ab6bc3ba460 __libc_start_main +
    245

    6    tmpk0ucgv09                        0x000055658e85d149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if w == 0 {\n        return true\n    }\n    if palindromic(q)\
    \ {\n        return true\n    }\n    return q.map{\n        _ in\n        _ +\
    \ w <= maxWeight\n    }.all() == true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbuq72ib4.swift:21:8: error: cannot find 'palindromic' in scope\n\
    \    if palindromic(q) {\n       ^~~~~~~~~~~\n/tmp/tmpbuq72ib4.swift:26:18: error:\
    \ cannot find 'maxWeight' in scope\n        _ + w <= maxWeight\n             \
    \    ^~~~~~~~~\n/tmp/tmpbuq72ib4.swift:26:9: error: '_' can only appear in a pattern\
    \ or on the left side of an assignment\n        _ + w <= maxWeight\n        ^\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.isEmpty {\n        return true\n    }\n\n    //\
    \ if the first and last elements are the same, we have a palindrome\n    if q[0]\
    \ == q[q.count-1] {\n        return false\n    }\n\n    // check that the maximum\
    \ possible weight is achieved\n    if w > q.maxElement() {\n        return false\n\
    \    }\n\n    // check that the array is balanced\n    var a = 0\n    for i :\
    \ Int in 0..<q.count-1 {\n        a += q[i]\n        if a == -w {\n          \
    \  return false\n        }\n    }\n\n    // check that the sum is less than or\
    \ equal the maximum possible weight\n    a = 0.0\n    for i : Int in 0..<q.count-1\
    \ {\n        a += q[i]\n    }\n    if a >= w {\n        return true\n    }\n\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9loxjjd3.swift:28:14: error: value of type '[Int]' has no member\
    \ 'maxElement'\n    if w > q.maxElement() {\n           ~ ^~~~~~~~~~\n/tmp/tmp9loxjjd3.swift:42:9:\
    \ error: cannot assign value of type 'Double' to type 'Int'\n    a = 0.0\n   \
    \     ^~~\n        Int( )\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if let qMax = q.reduce(0) { (max, next) -> Int in\n \
    \       let next = next % 10\n        max += Int(next)\n        return max\n \
    \   }\n    guard qMax == w\n    else { return false }\n    return q.reduce(0)\
    \ { (max, next) -> Bool in\n        let next = next % 10\n        let q = Int(next)\n\
    \        let n = q*10 + Int(q % 10)\n        return n == max && q == q\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo7ww_68v.swift:18:51: error: consecutive statements on a line must\
    \ be separated by ';'\n    if let qMax = q.reduce(0) { (max, next) -> Int in\n\
    \                                                  ^\n                       \
    \                           ;\n/tmp/tmpo7ww_68v.swift:18:52: error: expected expression\n\
    \    if let qMax = q.reduce(0) { (max, next) -> Int in\n                     \
    \                              ^\n/tmp/tmpo7ww_68v.swift:18:29: error: missing\
    \ argument for parameter #2 in call\n    if let qMax = q.reduce(0) { (max, next)\
    \ -> Int in\n                            ^\n                            , <#(Int?,\
    \ Int) throws -> Int?#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n \
    \   @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n/tmp/tmpo7ww_68v.swift:18:39: error: use of local\
    \ variable 'next' before its declaration\n    if let qMax = q.reduce(0) { (max,\
    \ next) -> Int in\n                                      ^\n/tmp/tmpo7ww_68v.swift:19:13:\
    \ note: 'next' declared here\n        let next = next % 10\n            ^\n/tmp/tmpo7ww_68v.swift:18:33:\
    \ error: expected type before '->'\n    if let qMax = q.reduce(0) { (max, next)\
    \ -> Int in\n                                ^\n/tmp/tmpo7ww_68v.swift:19:20:\
    \ error: use of local variable 'next' before its declaration\n        let next\
    \ = next % 10\n                   ^\n/tmp/tmpo7ww_68v.swift:19:13: note: 'next'\
    \ declared here\n        let next = next % 10\n            ^\n/tmp/tmpo7ww_68v.swift:20:9:\
    \ error: generic parameter 'T' could not be inferred\n        max += Int(next)\n\
    \        ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public\
    \ func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmpo7ww_68v.swift:21:16: error: generic parameter 'T' could not be\
    \ inferred\n        return max\n               ^\nSwift.max:1:24: note: in call\
    \ to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comp"
  stdout: ''
  timestamp: 1660014648
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.isPalindromic && w <= q.reduce(0) { $0 + $1 }\
    \ < w.absValue else { return false }\n    let sum = q.reduce(0) { $0 + $1 }\n\
    \    return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc8bqcp2n.swift:18:32: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n    guard q.isPalindromic && w <= q.reduce(0)\
    \ { $0 + $1 } < w.absValue else { return false }\n                           \
    \    ^                          ~\n/tmp/tmpc8bqcp2n.swift:18:59: error: binary\
    \ operator '<' cannot be applied to operands of type 'Bool' and '()'\n    guard\
    \ q.isPalindromic && w <= q.reduce(0) { $0 + $1 } < w.absValue else { return false\
    \ }\n                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpc8bqcp2n.swift:18:59: note: overloads for '<' exist with these partially\
    \ matching parameter lists: ((), ()), (AnyIndex, AnyIndex), (Character, Character),\
    \ (ContinuousClock.Instant, ContinuousClock.Instant), (Duration, Duration), (Int,\
    \ Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (Never,\
    \ Never), (ObjectIdentifier, ObjectIdentifier), (String, String), (String.Index,\
    \ String.Index), (SuspendingClock.Instant, SuspendingClock.Instant), (TaskPriority,\
    \ TaskPriority), (UInt, UInt), (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64),\
    \ (UInt8, UInt8), (Unicode.CanonicalCombiningClass, Unicode.CanonicalCombiningClass),\
    \ (Unicode.Scalar, Unicode.Scalar), (_ValidUTF8Buffer.Index, _ValidUTF8Buffer.Index)\n\
    \    guard q.isPalindromic && w <= q.reduce(0) { $0 + $1 } < w.absValue else {\
    \ return false }\n                                                          ^\n\
    /tmp/tmpc8bqcp2n.swift:18:13: error: value of type '[Int]' has no member 'isPalindromic'\n\
    \    guard q.isPalindromic && w <= q.reduce(0) { $0 + $1 } < w.absValue else {\
    \ return false }\n          ~ ^~~~~~~~~~~~~\n/tmp/tmpc8bqcp2n.swift:18:63: error:\
    \ value of type 'Int' has no member 'absValue'\n    guard q.isPalindromic && w\
    \ <= q.reduce(0) { $0 + $1 } < w.absValue else { return false }\n            \
    \                                                ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014648
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    // Write your code here.\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp7y0u_bl8/tmp7y0u_bl8.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a1baa5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a1b79cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a1b79c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a1b79b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7y0u_bl8                        0x000055b357db33bb <unavailable> + 5051

    5    libc.so.6                          0x00002b0a1bc91460 __libc_start_main +
    245

    6    tmp7y0u_bl8                        0x000055b357db2f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014268
