language: swift
name: HumanEval_17_parse_music
results:
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes = [Int]()\n\n\
    \    for n in music_string.unicodeScalars.reversed() {\n        var current_beat\
    \ = 1\n\n        switch n {\n        case \"o\":\n            current_beat = 4\n\
    \        case \"o|\":\n            current_beat = 2\n        default:\n      \
    \      current_beat = 1\n        }\n\n        notes.append(current_beat)\n   \
    \ }\n\n    return notes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpslv84qhz.swift:20:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Unicode.Scalar'\n        case \"o|\":\n       \
    \      ^~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_array = [Int]()\n\
    \    music_string.removeAll()\n    \n    if music_string.characters.count == 0\
    \ {\n        return beats_array\n    }\n    \n    var last_beat = 0\n    \n  \
    \  var prev_note_character: Character?\n    var notes_index = 0\n    var notes_length\
    \ = music_string.characters.count\n    \n    while notes_index < notes_length\
    \ {\n        var note_string: String = String(music_string.characters[notes_index])\n\
    \        note_string = note_string.lowercased()\n        note_string = note_string.trimmingCharacters(in:\
    \ .whitespaces)\n        note_string = note_string.trimmingCharacters(in: .punctuationCharacters)\n\
    \        note_string = note_string.trimmingCharacters(in: .symbols)\n        \n\
    \        switch note_string.first {\n        case \"o\":\n            last_beat\
    \ = 12\n        case \"o|\":\n            last_beat = 12\n        case \".|\"\
    :\n            last_beat = 1\n        default:\n            beats_array.append(last_beat)\n\
    \            notes_index += 1\n            last_beat = 0\n            continue\n\
    \        }\n        notes_index += 1\n    }\n    beats_array.append(last_beat)\n\
    \    \n    return beats_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpoev411s5.swift:13:18: error: cannot use mutating member on immutable\
    \ value: 'music_string' is a 'let' constant\n    music_string.removeAll()\n  \
    \  ~~~~~~~~~~~~ ^\n/tmp/tmpoev411s5.swift:15:21: error: 'characters' is unavailable:\
    \ Please use String directly\n    if music_string.characters.count == 0 {\n  \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpoev411s5.swift:23:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    var notes_length = music_string.characters.count\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpoev411s5.swift:26:42: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        var\
    \ note_string: String = String(music_string.characters[notes_index])\n       \
    \                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpoev411s5.swift:26:55:\
    \ error: 'characters' is unavailable: Please use String directly\n        var\
    \ note_string: String = String(music_string.characters[notes_index])\n       \
    \                                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpoev411s5.swift:28:35: error: value of\
    \ type 'String' has no member 'trimmingCharacters'\n        note_string = note_string.trimmingCharacters(in:\
    \ .whitespaces)\n                      ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpoev411s5.swift:28:59:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       note_string = note_string.trimmingCharacters(in: .whitespaces)\n     \
    \                                                    ~^~~~~~~~~"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let notes = [4, 2, 1, 2,\
    \ 2, 1, 1, 1, 1, 4, 4]\n    let stringToBeats = music_string.split(\" \").map\
    \ { $0.capitalized }\n    var beats = notes\n    for i in 1...stringToBeats.count\
    \ {\n        beats[i]--\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpjpflv5eu.swift:13:38: error: no exact matches in call to instance\
    \ method 'split'\n    let stringToBeats = music_string.split(\" \").map { $0.capitalized\
    \ }\n                                     ^\n/tmp/tmpjpflv5eu.swift:13:38: note:\
    \ found candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n    let stringToBeats\
    \ = music_string.split(\" \").map { $0.capitalized }\n                       \
    \              ^\n/tmp/tmpjpflv5eu.swift:13:38: note: found candidate with type\
    \ '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character, Int,\
    \ Bool) -> Array<Substring>')\n    let stringToBeats = music_string.split(\" \"\
    ).map { $0.capitalized }\n                                     ^\n/tmp/tmpjpflv5eu.swift:13:58:\
    \ error: reference to member 'capitalized' cannot be resolved without a contextual\
    \ type\n    let stringToBeats = music_string.split(\" \").map { $0.capitalized\
    \ }\n                                                         ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_chars = music_string.characters.split\
    \ { $0 != \"o\" }.map { String($0) }\n    var output = [Int](repeating: 0, count:\
    \ music_chars.count)\n    var beats = 0\n    for char in music_chars {\n     \
    \   let beat = beats.toInt()\n        switch char {\n        case \"o\":\n   \
    \         output[beats] += 1\n        case \"o|\":\n            output[beats]\
    \ += 2\n        case \"..\":\n            output[beats] += 4\n        default:\n\
    \            output[beats] += 4\n        }\n        beats += 1\n    }\n    return\
    \ output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpoqdmbnt9.swift:12:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let music_chars = music_string.characters.split { $0\
    \ != \"o\" }.map { String($0) }\n                                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpoqdmbnt9.swift:16:26:\
    \ error: value of type 'Int' has no member 'toInt'\n        let beat = beats.toInt()\n\
    \                   ~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // TODO: parse music_string\
    \ and return the array of beats\n    // Do not write main() function.\n    //\
    \ Read input from STDIN (standard input)\n    // var music_string = readLine()!\n\
    \    // var music_string = readString()!\n    \n    return Array<Int>(repeating:\
    \ 0, count: 6)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpg_tqpyr6/tmpg_tqpyr6.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac69f064c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac69ed5bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac69ed5b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac69ed5a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg_tqpyr6                        0x000056402056f47e <unavailable> + 5246

    5    libc.so.6                          0x00002ac69f250460 __libc_start_main +
    245

    6    tmpg_tqpyr6                        0x000056402056f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var total_notes = 0\n \
    \   guard let notes = music_string.components(separatedBy: \" \") else { return\
    \ [] }\n    for note in notes {\n        if note.contains(\"o|\") {\n        \
    \    total_notes += 1\n        } else if note.contains(\"o\") {\n            total_notes\
    \ += 1\n        } else if note.contains(\".|\") {\n            total_notes +=\
    \ 1\n        }\n    }\n    return total_notes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpwz7vte2h.swift:13:36: error: value of type 'String' has no member\
    \ 'components'\n    guard let notes = music_string.components(separatedBy: \"\
    \ \") else { return [] }\n                      ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpwz7vte2h.swift:23:12:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return total_notes\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var count = [Int]()\n \
    \   let notes = music_string.components(separatedBy: \" \")\n    for i in 0..<notes.count\
    \ {\n        switch notes[i] {\n        case \"o\":\n            count[0] += 1\n\
    \        case \"o|\":\n            count[1] += 1\n        case \".|\":\n     \
    \       count[2] += 1\n        default:\n            fatalError(\"Incorrect note\
    \ name '\\(notes[i])'\")\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpxygoon8d.swift:13:30: error: value of type 'String' has no member\
    \ 'components'\n    let notes = music_string.components(separatedBy: \" \")\n\
    \                ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    // 1. Convert string\
    \ to array: [string, ..]\n    var notes = [String]()\n    for c in music_string\
    \ {\n        if c == \"o\" {\n            notes.append(c)\n        } else if c\
    \ == \"|\" {\n            notes.append(c)\n        } else {\n            notes.append(c)\n\
    \        }\n    }\n    \n    // 2. Go through array: [string, ..]\n    var notes_beats:\
    \ [String: [Int]] = [String: [Int]]()\n    for note_index in 0..<notes.count {\n\
    \        // 2.1 Split string by white space and create array of notes: [string]\n\
    \        let note_string = notes[note_index]\n        let note_array = note_string.components(separatedBy:\
    \ \" \")\n        \n        // 2.2 Split note string by white space and create\
    \ array of beats: [string, ..]\n        let note_string_beats = [String]()\n \
    \       for c in note_array {\n            if c == \"o\" {\n                note_string_beats.append(c)\n\
    \            } else if c == \"|\" {\n                note_string_beats.append(c)\n\
    \            } else {\n                note_string_beats.append(c)\n         \
    \   }\n        }\n        \n        // 2.3 Convert beats array to [int, ..]\n\
    \        let beats = [Int]()\n        for c in note_string_beats {\n         \
    \   if c == \"|\" {\n                beats.append(1)\n            } else {\n \
    \               beats.append(0)\n            }\n        }\n        \n        //\
    \ 2.4 Append to array\n        notes_beats[note_string] = beats\n    }\n    \n\
    \    // 3. Go through array: [string, ..] and return [int, ..] of beats for each\
    \ note\n    var beats_for_all_notes: [Int: [Int]] = [:]\n    for note_index in\
    \ 0..<notes.count {\n        // 3.1 Get string from array - note\n        let\
    \ note_string = notes[note_index]\n        \n        // 3.2 Get array of beats\n\
    \        let note_string_beats = notes_beats[note_string]!\n        \n       \
    \ // 3.3 Create array of beats\n        let beats = [Int]()\n        for c in\
    \ note_string_beats {\n            if c == \"|\" {\n                beats.append(1)\n\
    \            } else {\n                beats.append(0)\n            }\n      \
    \  }\n        \n        // 3.4 Append to array\n        beats_for_all_notes[note_string]\
    \ = beats\n    }\n    \n    // 4. Convert array to array of ints: [int, ..]\n\
    \    var beats_for_all_notes_ints: [Int: [Int]] = [:]\n    for note_index in 0..<notes.count\
    \ {\n        // 4.1 Get string from array - note\n        let note_string = notes[note_index]\n\
    \        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpy407zjst.swift:106:87: error: expected '}' at end of brace statement\n\
    assert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4,\
    \ 2, 4, 2])\n                                                                \
    \                      ^\n/tmp/tmpy407zjst.swift:11:49: note: to match this opening\
    \ '{'\nfunc parse_music(music_string: String) -> [Int] {\n                   \
    \                             ^\n/tmp/tmpy407zjst.swift:17:26: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            notes.append(c)\n\
    \                         ^\n/tmp/tmpy407zjst.swift:19:26: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            notes.append(c)\n\
    \                         ^\n/tmp/tmpy407zjst.swift:21:26: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            notes.append(c)\n\
    \                         ^\n/tmp/tmpy407zjst.swift:30:38: error: value of type\
    \ 'String' has no member 'components'\n        let note_array = note_string.components(separatedBy:\
    \ \" \")\n                         ~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpy407zjst.swift:48:23:\
    \ error: cannot use mutating member on immutable value: 'beats' is a 'let' constant\n\
    \                beats.append(1)\n                ~~~~~ ^\n/tmp/tmpy407zjst.swift:45:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let beats = [Int]()\n\
    \        ^~~\n        var\n/tmp/tmpy407zjst.swift:50:23: error: cannot use mutating\
    \ member on immutable value: 'beats' is a 'let' constant\n                beats.append(0)\n\
    \                ~~~~~ ^\n/tmp/tmpy407zjst.swift:45:9: note: change 'let' to 'var'\
    \ to make it mutable\n        let beats = [Int]()\n        ^~~\n        var\n\
    /tmp/tmpy407zjst.swift:70:18: error: binary operator '==' cannot be applied to\
    \ operands of type 'Int' and 'String'\n            if c == \"|\" {\n         \
    \      ~ ^  ~~~\n/tmp/tmpy407zjst.swift:70:18: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Int, Int), (String, String)\n\
    \            if c == \"|\" {\n         "
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = Array<Int>()\n\
    \    var beat = 0\n    var last = 0\n    var index = 0\n\n    if music_string.count\
    \ < 1 {\n        return beats\n    }\n\n    for index in 0..<music_string.count\
    \ {\n        let char = music_string[index]\n\n        if char == \"o\" {\n  \
    \          if beat < 3 {\n                beats[beat] = 1\n                beat\
    \ += 1\n                last = 0\n            }\n        } else if char == \"\
    |\" {\n            if beat < 3 {\n                beats[beat] = 2\n          \
    \      beat += 1\n                last = 0\n            } else if last == 0 {\n\
    \                beats[beat] = 1\n                beat += 1\n            } else\
    \ {\n                beats[beat] = 1\n                beat += 1\n            }\n\
    \            last = 1\n        } else if char == \".\" {\n            if last\
    \ == 1 {\n                beats[beat] = 1\n                beat += 1\n       \
    \     } else {\n                beats[beat] = 2\n                beat += 1\n \
    \           }\n            last = 0\n        }\n    }\n\n    return beats\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpapnj5yja.swift:22:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = music_string[index]\n                   ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpapnj5yja.swift:15:9:\
    \ warning: initialization of variable 'index' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var index = 0\n    ~~~~^~~~~\n  \
    \  _\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [Int] = []\n\
    \    var length: Int = 0\n    for symbol in music_string {\n        // find last\
    \ symbol\n        switch symbol {\n        case \"o\":\n            length +=\
    \ 1\n            beats.append(length)\n        case \"|\":\n            length\
    \ += 1\n            beats.append(length)\n        default:\n            length\
    \ = 0\n        }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmp3uxsp0oo/tmp3uxsp0oo.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac00c188c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac00be7fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac00be7f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac00be7e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3uxsp0oo                        0x0000564f3377771f <unavailable> + 5919

    5    libc.so.6                          0x00002ac00c374460 __libc_start_main +
    245

    6    tmp3uxsp0oo                        0x0000564f33777259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard let music_array =\
    \ music_string.components(separatedBy: \" \") else {\n        fatalError(\"music\
    \ string is not valid\")\n    }\n    var beat_count = [Int]()\n    for music in\
    \ music_array {\n        let music_character = music.trim()\n        if let music_character\
    \ = music_character.unicodeScalars.first?.value {\n            var beats = 0\n\
    \            switch music_character {\n            case 'o': // whole note\n \
    \               if music_character == '.' {\n                    beats = 4\n \
    \               }\n            default:\n                beats = music_character\
    \ - '0' + 1\n            }\n            beat_count[beats - 1] += 1\n        }\n\
    \    }\n    return beat_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp8tym9fg_.swift:21:18: error: single-quoted string literal found,\
    \ use '\"'\n            case 'o': // whole note\n                 ^~~\n      \
    \           \"o\"\n/tmp/tmp8tym9fg_.swift:22:39: error: single-quoted string literal\
    \ found, use '\"'\n                if music_character == '.' {\n             \
    \                         ^~~\n                                      \".\"\n/tmp/tmp8tym9fg_.swift:26:43:\
    \ error: single-quoted string literal found, use '\"'\n                beats =\
    \ music_character - '0' + 1\n                                          ^~~\n \
    \                                         \"0\"\n/tmp/tmp8tym9fg_.swift:12:42:\
    \ error: value of type 'String' has no member 'components'\n    guard let music_array\
    \ = music_string.components(separatedBy: \" \") else {\n                     \
    \       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    if music_string == \"\"\
    \ { return [] }\n    var notes_beat_count = 0\n    var music_chars = music_string.characters\n\
    \    for _ in 0..<music_chars.count {\n        guard let music_char = music_chars.next()\
    \ else { break }\n        if music_char == 'o' {\n            notes_beat_count\
    \ += 4\n        } else if music_char == 'o|' {\n            notes_beat_count +=\
    \ 2\n        } else if music_char == '.|' {\n            notes_beat_count += 1\n\
    \        } else if music_char == '.{' {\n            notes_beat_count -= 1\n \
    \       } else {\n            notes_beat_count += 1\n        }\n    }\n    return\
    \ notes_beat_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpgmip0imw.swift:17:26: error: single-quoted string literal found,\
    \ use '\"'\n        if music_char == 'o' {\n                         ^~~\n   \
    \                      \"o\"\n/tmp/tmpgmip0imw.swift:19:33: error: single-quoted\
    \ string literal found, use '\"'\n        } else if music_char == 'o|' {\n   \
    \                             ^~~~\n                                \"o|\"\n/tmp/tmpgmip0imw.swift:21:33:\
    \ error: single-quoted string literal found, use '\"'\n        } else if music_char\
    \ == '.|' {\n                                ^~~~\n                          \
    \      \".|\"\n/tmp/tmpgmip0imw.swift:23:33: error: single-quoted string literal\
    \ found, use '\"'\n        } else if music_char == '.{' {\n                  \
    \              ^~~~\n                                \".{\"\n/tmp/tmpgmip0imw.swift:14:36:\
    \ error: 'characters' is unavailable: Please use String directly\n    var music_chars\
    \ = music_string.characters\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgmip0imw.swift:16:44: error: value of\
    \ type 'String' has no member 'next'\n        guard let music_char = music_chars.next()\
    \ else { break }\n                               ~~~~~~~~~~~ ^~~~\n/tmp/tmpgmip0imw.swift:29:12:\
    \ error: cannot convert return expression of type 'Int' to return type '[Int]'\n\
    \    return notes_beat_count\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var total = 0\n\n    for\
    \ c in music_string {\n        switch c {\n        case \"o\":\n            total\
    \ += 4\n        case \"o|\":\n            total += 2\n        case \".|\":\n \
    \           total += 1\n        }\n    }\n\n    return Array(repeating: total,\
    \ count: music_string.count) / 4\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpjm3lnvdk.swift:18:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n/tmp/tmpjm3lnvdk.swift:20:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \".|\":\n            \
    \ ^~~~\n/tmp/tmpjm3lnvdk.swift:25:63: error: binary operator '/' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n    return Array(repeating: total, count:\
    \ music_string.count) / 4\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~\n/tmp/tmpjm3lnvdk.swift:25:63: note: overloads for '/' exist with these\
    \ partially matching parameter lists: (Int, Int)\n    return Array(repeating:\
    \ total, count: music_string.count) / 4\n                                    \
    \                          ^\n/tmp/tmpjm3lnvdk.swift:25:63: error: no '/' candidates\
    \ produce the expected contextual result type '[Int]'\n    return Array(repeating:\
    \ total, count: music_string.count) / 4\n                                    \
    \                          ^\nSwift.Int:10:24: note: '/' produces 'Int', not the\
    \ expected contextual result type '[Int]'\n    public static func / (lhs: Int,\
    \ rhs: Int) -> Int\n                       ^\nSwift.BinaryInteger:14:17: note:\
    \ '/' produces 'Int', not the expected contextual result type '[Int]'\n    static\
    \ func / (lhs: Self, rhs: Self) -> Self\n                ^\nSwift.Duration:8:24:\
    \ note: '/' produces 'Duration', not the expected contextual result type '[Int]'\n\
    \    public static func / <T>(lhs: Duration, rhs: T) -> Duration where T : BinaryInteger\n\
    \                       ^\nSwift.Int:10:24: note: '/' produces 'Int', not the\
    \ expected contextual result type '[Int]'\n    public static func / (lhs: Int,\
    \ rhs: Int) -> Int\n                       ^\nSwift.BinaryInteger:14:17: note:\
    \ '/' produces 'Int', not the expected contextual result type '[Int]'\n    static\
    \ func / (lhs: Self, rhs: Self) -> Self\n                ^\nSwift.Duration:8:24:\
    \ note: '/' produces 'Duration', not the expected contextual result type '[Int]'\n\
    \    public static func / <T>(lh"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beat_number: [Int]\
    \ = []\n    var current_position = 0\n    var current_note = music_string[current_position]\n\
    \    beat_number.append(0)\n\n    while current_position < music_string.count\
    \ {\n        if current_note == \"o\" {\n            beat_number.append(4)\n \
    \           current_position += 2\n        } else if current_note == \"o|\" {\n\
    \            beat_number.append(2)\n            current_position += 2\n      \
    \  } else if current_note == \".|\" {\n            beat_number.append(1)\n   \
    \         current_position += 2\n        } else {\n            let note_number\
    \ = map[current_note]!\n            beat_number.append(note_number)\n        \
    \    current_position += note_number\n        }\n        current_note = music_string[current_position]\n\
    \    }\n\n    return beat_number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpctducz_8.swift:14:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var current_note\
    \ = music_string[current_position]\n                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpctducz_8.swift:21:32:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        } else if current_note == \"o|\" {\n                 \
    \ ~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmpctducz_8.swift:21:32: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        } else if current_note == \"o|\" {\n             \
    \                  ^\n/tmp/tmpctducz_8.swift:24:32: error: binary operator '=='\
    \ cannot be applied to operands of type 'Character' and 'String'\n        } else\
    \ if current_note == \".|\" {\n                  ~~~~~~~~~~~~ ^  ~~~~\n/tmp/tmpctducz_8.swift:24:32:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        } else if current_note ==\
    \ \".|\" {\n                               ^\n/tmp/tmpctducz_8.swift:28:31: error:\
    \ cannot find 'map' in scope\n            let note_number = map[current_note]!\n\
    \                              ^~~\n/tmp/tmpctducz_8.swift:32:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        current_note = music_string[current_position]\n                     \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n\t\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: '/tmp/tmpzapk_e3y.swift:13:1: error: missing return in global function expected
    to return ''[Int]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [Int] = []\n\
    \    var notes: [String] = []\n    for s in music_string.split(\" \") {\n    \
    \    if s.count <= 1 { continue }\n        switch s[0] {\n        case \"o\":\n\
    \            notes.append(String(s.dropFirst()))\n        case \"o|\":\n     \
    \       notes.append(String(s.dropFirst()))\n        default:\n            notes.append(String(s))\n\
    \        }\n    }\n    for note in notes {\n        let note_length = note.count\
    \ - 1\n        var beats_to_last = 0\n        switch note.first {\n        case\
    \ \"o\":\n            beats_to_last = note_length\n        case \"o|\":\n    \
    \        beats_to_last = note_length * 2\n        default:\n            beats_to_last\
    \ = note_length * 4\n        }\n        beats.append(beats_to_last)\n    }\n \
    \   return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpt1i_dz1h.swift:14:27: error: no exact matches in call to instance\
    \ method 'split'\n    for s in music_string.split(\" \") {\n                 \
    \         ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n/tmp/tmpt1i_dz1h.swift:31:14: error:\
    \ expression pattern of type 'String' cannot match values of type 'String.Element?'\
    \ (aka 'Optional<Character>')\n        case \"o|\":\n             ^~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_per_note = [Int](repeating:\
    \ 0, count: 4)\n    var notes = music_string.unicodeScalars.filter { $0.value\
    \ > 0 }\n\n    var beat = 0\n    var note = 0\n\n    for note in notes {\n   \
    \     var index = note.value - 64\n        beats_per_note[index] += 1\n      \
    \  if (index == 2 || index == 3) && !(beat % 4 == 0) {\n            beat += 1\n\
    \        }\n    }\n    return beats_per_note\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpusdsgjhx.swift:20:24: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'Int'\n        beats_per_note[index] += 1\n      \
    \                 ^\n                       Int( )\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Your code here\n   \
    \ var beats_per_note: [Int] = [0]\n    var notes: [String] = music_string.split(separator:\
    \ \" \")\n    \n    for note in notes {\n        switch note {\n        case \"\
    o\":\n            beats_per_note.append(4)\n        case \"o|\":\n           \
    \ beats_per_note.append(2)\n        case \"o|\":\n            beats_per_note.append(1)\n\
    \        default:\n            beats_per_note.append(0)\n        }\n    }\n  \
    \  return beats_per_note\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp4zghyqpe.swift:14:40: error: cannot assign value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to type '[String]'\n    var notes: [String] = music_string.split(separator:\
    \ \" \")\n                                       ^\n/tmp/tmp4zghyqpe.swift:14:40:\
    \ note: arguments to generic parameter 'Element' ('String.SubSequence' (aka 'Substring')\
    \ and 'String') are expected to be equal\n    var notes: [String] = music_string.split(separator:\
    \ \" \")\n                                       ^\n/tmp/tmp4zghyqpe.swift:22:14:\
    \ warning: literal value is already handled by previous pattern; consider removing\
    \ it\n        case \"o|\":\n             ^~~~\n/tmp/tmp4zghyqpe.swift:20:14: note:\
    \ first occurrence of identical literal pattern is here\n        case \"o|\":\n\
    \             ^~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result: [Int] = []\n\
    \    var beat_counter = 0\n    let char_array = music_string.unicodeScalars.map({\
    \ $0.value })\n    for char in char_array {\n        beat_counter += char == \"\
    o\" ? 4 : 2 if char == \"|\" ? 1 : 0\n        result.append(beat_counter)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpohvktrmk.swift:16:44: error: consecutive statements on a line must\
    \ be separated by ';'\n        beat_counter += char == \"o\" ? 4 : 2 if char ==\
    \ \"|\" ? 1 : 0\n                                           ^\n              \
    \                             ;\n/tmp/tmpohvktrmk.swift:16:67: error: expected\
    \ '{' after 'if' condition\n        beat_counter += char == \"o\" ? 4 : 2 if char\
    \ == \"|\" ? 1 : 0\n                                                         \
    \         ^\n/tmp/tmpohvktrmk.swift:16:30: error: binary operator '==' cannot\
    \ be applied to operands of type 'UInt32' and 'String'\n        beat_counter +=\
    \ char == \"o\" ? 4 : 2 if char == \"|\" ? 1 : 0\n                        ~~~~\
    \ ^  ~~~\n/tmp/tmpohvktrmk.swift:16:30: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (String, String), (UInt32, UInt32)\n   \
    \     beat_counter += char == \"o\" ? 4 : 2 if char == \"|\" ? 1 : 0\n       \
    \                      ^\n/tmp/tmpohvktrmk.swift:16:53: error: binary operator\
    \ '==' cannot be applied to operands of type 'UInt32' and 'String'\n        beat_counter\
    \ += char == \"o\" ? 4 : 2 if char == \"|\" ? 1 : 0\n                        \
    \                       ~~~~ ^  ~~~\n/tmp/tmpohvktrmk.swift:16:53: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (String, String),\
    \ (UInt32, UInt32)\n        beat_counter += char == \"o\" ? 4 : 2 if char == \"\
    |\" ? 1 : 0\n                                                    ^\n/tmp/tmpohvktrmk.swift:16:60:\
    \ error: type 'Int' cannot be used as a boolean; test for '!= 0' instead\n   \
    \     beat_counter += char == \"o\" ? 4 : 2 if char == \"|\" ? 1 : 0\n       \
    \                                                    ^\n                     \
    \                          ((                 ) != 0)\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var music_array: [Int]\
    \ = []\n    var beats = 0\n    for character in music_string {\n        if character\
    \ == \"o\" {\n            music_array += [4]\n            beats += 4\n       \
    \ } else if character == \"|\" {\n            music_array += [2, 2, 1]\n     \
    \       beats += 2\n        } else if character == \".\" {\n            music_array\
    \ += [1]\n            beats += 1\n        } else {\n            music_array +=\
    \ [0]\n            beats += 1\n        }\n    }\n    return music_array\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpxiuw22kg/tmpxiuw22kg.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67d8ed8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67d8bcfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67d8bcf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67d8bce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxiuw22kg                        0x000055b70911671f <unavailable> + 5919

    5    libc.so.6                          0x00002b67d90c4460 __libc_start_main +
    245

    6    tmpxiuw22kg                        0x000055b709116259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beat_count = 0\n\n\
    \    // Split the string into chunks of musical notes\n    var music_chunks: [[String]]\
    \ = [[]]\n    for (index, note) in music_string.enumerated() {\n        // Split\
    \ notes into \"whole note\", \"half note\", \"quater note\" and chords (\"a b|\"\
    )\n        guard note.contains(\"|\") else { break }\n        var notes = note.components(separatedBy:\
    \ \"|\")\n        let chords = notes.dropFirst()\n        notes = notes.first!\n\
    \        // If this is a whole note, save the chunk\n        if notes.contains(\"\
    o\") {\n            let current_chunk = music_chunks[index] ?? []\n          \
    \  music_chunks[index] = current_chunk + [notes]\n            beat_count += current_chunk.count\n\
    \        // If this is a half note, save the chunk\n        } else if notes.contains(\"\
    o|\") {\n            let current_chunk = music_chunks[index] ?? []\n         \
    \   music_chunks[index] = current_chunk + [notes]\n            beat_count += current_chunk.count\n\
    \        // If this is a quater note, save the chunk\n        } else if notes.contains(\"\
    .\") {\n            let current_chunk = music_chunks[index] ?? []\n          \
    \  music_chunks[index] = current_chunk + [notes]\n            beat_count += current_chunk.count\n\
    \        } else {\n            guard let current_chunk = music_chunks[index] else\
    \ { return beat_count }\n            beat_count = current_chunk.count + beat_count\n\
    \        }\n    }\n\n    // Iterate over the musical chunks\n    var beats = 0\n\
    \    for chunk in music_chunks {\n        beats = chunk.count + beats\n    }\n\
    \n    // Remove the extra musical notes\n    return music_chunks.map { chunk ->\
    \ Int in\n        beats - chunk.count\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmplkzcnllj.swift:18:20: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'contains'\n        guard note.contains(\"|\") else\
    \ { break }\n              ~~~~ ^~~~~~~~\n/tmp/tmplkzcnllj.swift:19:26: error:\
    \ value of type 'String.Element' (aka 'Character') has no member 'components'\n\
    \        var notes = note.components(separatedBy: \"|\")\n                   \
    \ ~~~~ ^~~~~~~~~~\n/tmp/tmplkzcnllj.swift:24:53: warning: left side of nil coalescing\
    \ operator '??' has non-optional type '[String]', so the right side is never used\n\
    \            let current_chunk = music_chunks[index] ?? []\n                 \
    \               ~~~~~~~~~~~~~~~~~~~ ^~~~~\n                                  \
    \                  \n/tmp/tmplkzcnllj.swift:29:53: warning: left side of nil coalescing\
    \ operator '??' has non-optional type '[String]', so the right side is never used\n\
    \            let current_chunk = music_chunks[index] ?? []\n                 \
    \               ~~~~~~~~~~~~~~~~~~~ ^~~~~\n                                  \
    \                  \n/tmp/tmplkzcnllj.swift:34:53: warning: left side of nil coalescing\
    \ operator '??' has non-optional type '[String]', so the right side is never used\n\
    \            let current_chunk = music_chunks[index] ?? []\n                 \
    \               ~~~~~~~~~~~~~~~~~~~ ^~~~~\n                                  \
    \                  \n/tmp/tmplkzcnllj.swift:38:73: error: cannot convert return\
    \ expression of type 'Int' to return type '[Int]'\n            guard let current_chunk\
    \ = music_chunks[index] else { return beat_count }\n                         \
    \                                               ^~~~~~~~~~\n/tmp/tmplkzcnllj.swift:38:19:\
    \ error: initializer for conditional binding must have Optional type, not '[String]'\n\
    \            guard let current_chunk = music_chunks[index] else { return beat_count\
    \ }\n                  ^                   ~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let mut beats_per_note\
    \ = [0, 0, 0]\n    let notes = music_string.characters.split(\" \").map(|x| x[0]);\n\
    \    notes.enumerate().for_each(|(_, note)| {\n        note.split(\"\").enumerate().for_each(|(_,\
    \ n)| {\n            if n.is_ascii_digit() {\n                beats_per_note[n.to_ascii_digit()]\
    \ +=\n                    note.count(char::is_ascii_digit).map(|x| x).unwrap_or(0);\n\
    \            }\n        })\n    });\n    beats_per_note.iter().for_each(|x| {\n\
    \        *x = x.max(4).min(12);\n    });\n    beats_per_note.iter().for_each(|x|\
    \ {\n        *x = x.max(4).min(12);\n    });\n    beats_per_note.iter().for_each(|x|\
    \ {\n        *x = x.max(4).min(12);\n    });\n    beats_per_note.iter().for_each(|x|\
    \ {\n        *x = x.max(4).min(12);\n    });\n    beats_per_note.iter().for_each(|x|\
    \ {\n        *x = x.max(4).min(12);\n    });\n    beats_per_note.iter().for_each(|x|\
    \ {\n        *x = x.max(4).min(12);\n    });\n    return beats_per_note\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpgs6d56hf.swift:12:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut beats_per_note\
    \ = [0, 0, 0]\n            ^\n/tmp/tmpgs6d56hf.swift:12:13: note: join the identifiers\
    \ together\n    let mut beats_per_note = [0, 0, 0]\n        ~~~~^~~~~~~~~~~~~~\n\
    \        mutbeats_per_note\n/tmp/tmpgs6d56hf.swift:12:13: note: join the identifiers\
    \ together with camel-case\n    let mut beats_per_note = [0, 0, 0]\n        ~~~~^~~~~~~~~~~~~~\n\
    \        mutBeats_per_note\n/tmp/tmpgs6d56hf.swift:13:60: error: expected ','\
    \ separator\n    let notes = music_string.characters.split(\" \").map(|x| x[0]);\n\
    \                                                           ^\n              \
    \                                            ,\n/tmp/tmpgs6d56hf.swift:18:37:\
    \ error: expected expression in list of expressions\n                    note.count(char::is_ascii_digit).map(|x|\
    \ x).unwrap_or(0);\n                                    ^\n/tmp/tmpgs6d56hf.swift:18:62:\
    \ error: expected ',' separator\n                    note.count(char::is_ascii_digit).map(|x|\
    \ x).unwrap_or(0);\n                                                         \
    \    ^\n                                                            ,\n/tmp/tmpgs6d56hf.swift:13:56:\
    \ error: '|' is not a prefix unary operator\n    let notes = music_string.characters.split(\"\
    \ \").map(|x| x[0]);\n                                                       ^\n\
    /tmp/tmpgs6d56hf.swift:13:58: error: '|' is not a postfix unary operator\n   \
    \ let notes = music_string.characters.split(\" \").map(|x| x[0]);\n          \
    \                                               ^\n/tmp/tmpgs6d56hf.swift:13:57:\
    \ error: cannot find 'x' in scope\n    let notes = music_string.characters.split(\"\
    \ \").map(|x| x[0]);\n                                                       \
    \ ^\n/tmp/tmpgs6d56hf.swift:13:60: error: cannot find 'x' in scope\n    let notes\
    \ = music_string.characters.split(\" \").map(|x| x[0]);\n                    \
    \                                       ^\n/tmp/tmpgs6d56hf.swift:13:41: error:\
    \ no exact matches in ca"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    var note_count =\
    \ [Int]()\n    \n    var note = music_string.substringToIndex(music_string.startIndex)\n\
    \    \n    \n    if note.lowercaseString == \"o\" {\n        note_count[0] = 1\n\
    \        note_count[1] = 1\n        note_count[2] = 4\n        note_count[3] =\
    \ 1\n        note_count[4] = 1\n        note_count[5] = 4\n        note_count[6]\
    \ = 1\n        note_count[7] = 4\n        note_count[8] = 1\n        note_count[9]\
    \ = 1\n        note_count[10] = 4\n        note_count[11] = 4\n        note_count[12]\
    \ = 1\n    }\n    else if note.lowercaseString == \"o|\" {\n        note_count[0]\
    \ = 1\n        note_count[1] = 4\n        note_count[2] = 1\n        note_count[3]\
    \ = 1\n        note_count[4] = 4\n        note_count[5] = 1\n        note_count[6]\
    \ = 4\n        note_count[7] = 1\n        note_count[8] = 4\n        note_count[9]\
    \ = 1\n        note_count[10] = 4\n        note_count[11] = 4\n        note_count[12]\
    \ = 1\n    }\n    else if note.lowercaseString == \".|\" {\n        note_count[0]\
    \ = 1\n        note_count[1] = 1\n        note_count[2] = 1\n        note_count[3]\
    \ = 1\n        note_count[4] = 1\n        note_count[5] = 1\n        note_count[6]\
    \ = 1\n        note_count[7] = 4\n        note_count[8] = 1\n        note_count[9]\
    \ = 4\n        note_count[10] = 1\n        note_count[11] = 4\n        note_count[12]\
    \ = 1\n    }\n    else if note.lowercaseString == \"o| o|\" {\n        note_count[0]\
    \ = 1\n        note_count[1] = 4\n        note_count[2] = 4\n        note_count[3]\
    \ = 1\n        note_count[4] = 1\n        note_count[5] = 1\n        note_count[6]\
    \ = 4\n        note_count[7] = 4\n        note_count[8] = 1\n        note_count[9]\
    \ = 1\n        note_count[10] = 4\n        note_count[11] = 1\n        note_count[12]\
    \ = 1\n    }\n    else if note.lowercaseString == \"o| .|\" {\n        note_count[0]\
    \ = 1\n        note_count[1] = 4\n        note_count[2] = 4\n        note_count[3]\
    \ = 1\n        note_count[4] = 1\n        note_count[5] = 1\n        note_count[6]\
    \ = 1\n        note_count[7] = 1\n        note_count[8] = 1\n        note_count[9]\
    \ = 4\n        note_count[10] = 1\n        note_count[11] = 1\n        note_count[12\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpozvxex9i.swift:92:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpozvxex9i.swift:91:19: note: to match this opening '['\n        note_count[12\n\
    \                  ^\n/tmp/tmpozvxex9i.swift:111:87: error: expected '}' at end\
    \ of brace statement\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\"\
    ) == [2, 1, 2, 1, 4, 2, 4, 2])\n                                             \
    \                                         ^\n/tmp/tmpozvxex9i.swift:11:49: note:\
    \ to match this opening '{'\nfunc parse_music(music_string: String) -> [Int] {\n\
    \                                                ^\n/tmp/tmpozvxex9i.swift:15:29:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    var note\
    \ = music_string.substringToIndex(music_string.startIndex)\n               ~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~\n/tmp/tmpozvxex9i.swift:91:19: warning: subscript is accessed\
    \ but result is unused\n        note_count[12\n        ~~~~~~~~~~^~~\n/tmp/tmpozvxex9i.swift:95:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes_array: [Int]\
    \ = []\n    var last_char = \"\"\n    var beats_count = 0\n    \n    for char\
    \ in music_string {\n        if char == \"|\" {\n            if last_char == \"\
    o\" {\n                notes_array.append(beats_count)\n            }\n      \
    \      beats_count = 0\n            last_char = \"\"\n        } else {\n     \
    \       beats_count += 1\n            last_char = char\n        }\n    }\n   \
    \ \n    if last_char == \"o\" {\n        notes_array.append(beats_count)\n   \
    \ }\n    \n    return notes_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp4x6o9i_m.swift:25:25: error: cannot assign value of type 'Character'\
    \ to type 'String'\n            last_char = char\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   let characters = Array(music_string)\n    var i = 0\n    var note = Int()\n\
    \n    guard characters.count != 0 else {\n        return beats\n    }\n    guard\
    \ let lastChar = characters[characters.count - 1] else {\n        return beats\n\
    \    }\n\n    var notes = [Note]()\n\n    func isNote(character: String) -> Bool\
    \ {\n        let charCode = character.unicodeScalars.reduce(0) {$0 + Int($1) +\
    \ 64}\n        let isNote = CharacterSet.whitespacesAndNewlines.contains(charCode)\n\
    \n        return isNote\n    }\n\n    func isNoteOrNumber(character: String) ->\
    \ Bool {\n        let charCode = character.unicodeScalars.reduce(0) {$0 + Int($1)\
    \ + 64}\n        let isNoteOrNumber = CharacterSet.whitespacesAndNewlines.contains(charCode)\n\
    \        return isNoteOrNumber\n    }\n\n    while i < characters.count {\n  \
    \      if isNote(characters[i + 0]) {\n            notes.append(Note(note, i +\
    \ 0, i + 1, i + 2))\n            note = Int(characters[i + 1])\n            i\
    \ += 3\n        } else if isNoteOrNumber(characters[i + 0]) {\n            if\
    \ note > 0 {\n                notes.append(Note(note, i + 0, i + 1, i + 2))\n\
    \                note = 0\n                i += 2\n            } else {\n    \
    \            notes.append(Note(note, i + 0, i + 1, i + 2))\n                i\
    \ += 3\n            }\n        } else {\n            i += 1\n        }\n    }\n\
    \    beats.append(notes.count)\n    return beats\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpzuz0q0e7.swift:20:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String.Element' (aka 'Character')\n    guard let\
    \ lastChar = characters[characters.count - 1] else {\n          ^            \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzuz0q0e7.swift:24:18: error: cannot\
    \ find 'Note' in scope\n    var notes = [Note]()\n                 ^~~~\n/tmp/tmpzuz0q0e7.swift:24:17:\
    \ error: cannot call value of non-function type '[Any]'\n    var notes = [Note]()\n\
    \                ^     ~~\n                      \n/tmp/tmpzuz0q0e7.swift:27:65:\
    \ error: no exact matches in call to initializer \n        let charCode = character.unicodeScalars.reduce(0)\
    \ {$0 + Int($1) + 64}\n                                                      \
    \          ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that 'Unicode.Scalar'\
    \ conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n\
    \    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n  \
    \                    ^\nSwift.SignedInteger:2:23: note: candidate requires that\
    \ 'Unicode.Scalar' conform to 'BinaryInteger' (requirement specified as 'T' :\
    \ 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n\
    \                      ^\n/tmp/tmpzuz0q0e7.swift:28:22: error: cannot find 'CharacterSet'\
    \ in scope\n        let isNote = CharacterSet.whitespacesAndNewlines.contains(charCode)\n\
    \                     ^~~~~~~~~~~~\n/tmp/tmpzuz0q0e7.swift:34:65: error: no exact\
    \ matches in call to initializer \n        let charCode = character.unicodeScalars.reduce(0)\
    \ {$0 + Int($1) + 64}\n                                                      \
    \          ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that 'Unicode.Scalar'\
    \ conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n\
    \    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n  \
    \                    ^\nSwift.SignedInteger:2:23: note: candidate requires that\
    \ 'Unicode.Scalar' conform to 'BinaryInteger' (requirement specified as 'T"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n  var result: [Int] = []\n\
    \  for note in music_string {\n    if note.isWhitespace {\n      continue\n  \
    \  }\n    switch note {\n    case \"o\":\n      result = append(result, 4)\n \
    \   case \"o|\":\n      result = append(result, 2)\n    default:\n      result\
    \ = append(result, 1)\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp5jsqz7lb.swift:20:10: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n    case \"o|\":\n         ^~~~\n/tmp/tmp5jsqz7lb.swift:19:16:\
    \ error: cannot find 'append' in scope\n      result = append(result, 4)\n   \
    \            ^~~~~~\n/tmp/tmp5jsqz7lb.swift:21:16: error: cannot find 'append'\
    \ in scope\n      result = append(result, 2)\n               ^~~~~~\n/tmp/tmp5jsqz7lb.swift:23:16:\
    \ error: cannot find 'append' in scope\n      result = append(result, 1)\n   \
    \            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   var last_beat = 0\n    for note in music_string {\n        if note == \".\"\
    \ {\n            if last_beat == 0 {\n                // last note in string is\
    \ not a whole note\n                beats.append(0)\n            } else {\n  \
    \              // last note in string is a whole note\n                beats.append(last_beat\
    \ - 1)\n            }\n        } else {\n            beats.append(note.unicodeScalars.count())\n\
    \        }\n        last_beat = beats.last!\n    }\n    return beats\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpai339t6z.swift:24:46: error: cannot call value of non-function\
    \ type 'Int'\n            beats.append(note.unicodeScalars.count())\n        \
    \                                     ^    ~~\n                              \
    \                    \n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // TODO: fix this function\n\
    \    // write code here\n    let beats_per_note = 4\n    let song = music_string.split(\"\
    \ \").map { String($0) }\n    var song_notes: [Int] = Array(repeating: 0, count:\
    \ song.count)\n    for note in song { //loops through notes and adds to array\n\
    \        switch note {\n        case \"o\": song_notes[song.count - 1] = song_notes[song.count\
    \ - 1] + beats_per_note\n        case \"o|\": song_notes[song.count - 1] = song_notes[song.count\
    \ - 1] + beats_per_note / 2\n        case \"|\": song_notes[song.count - 1] =\
    \ song_notes[song.count - 1] + beats_per_note\n        default: print(\"Something\
    \ went wrong\")\n        }\n    }\n    return song_notes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp4wv1hqqs.swift:15:29: error: no exact matches in call to instance\
    \ method 'split'\n    let song = music_string.split(\" \").map { String($0) }\n\
    \                            ^\nSwift.Sequence:2:40: note: incorrect labels for\
    \ candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result: [Int] = []\n\
    \    var current_note = \"\"\n    var beat = 0\n    for c in music_string {\n\
    \        let c = char(c)\n        if c.isWhitespace {\n            continue\n\
    \        }\n        if c != \"o\" && c != \".\" {\n            if current_note.isEmpty\
    \ {\n                current_note = c\n                beat = 1\n            }\n\
    \            else if current_note == \"o\" {\n                beat = 1\n     \
    \       }\n            else {\n                beat = 0\n            }\n     \
    \   }\n        else {\n            beat += 1\n            if current_note != \"\
    o\" {\n                current_note = \"\"\n            }\n        }\n       \
    \ result.append(beat)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmphjotin4a.swift:16:17: error: cannot find 'char' in scope\n    \
    \    let c = char(c)\n                ^~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return parse_music_helper(music_string,\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\"\
    ) == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4,\
    \ 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string:\
    \ \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpp3vmevao.swift:12:12: error: cannot find 'parse_music_helper' in\
    \ scope\n    return parse_music_helper(music_string, 0)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [Int] = []\n\
    \    var last: Int = 0\n    var notes_cnt = 0\n    var current_note = notes_cnt\
    \ % 8\n    let notes = music_string.split(separator: \"|\")\n    for note in notes\
    \ {\n        if note == \".\" {\n            if beat_diff(last) == 1 {\n     \
    \           beats.append(beats_diff(last)!)\n            } else {\n          \
    \      beats.append(beats_diff(last)! * 2)\n            }\n            last =\
    \ 0\n            notes_cnt += 1\n            current_note = notes_cnt % 8\n  \
    \          continue\n        }\n        let new_note = note.split(separator: \"\
    \ \")[0]\n        let last_beat = beats_diff(last)\n        if new_note == \"\
    o\" {\n            if last_beat[0] != last_beat[1] {\n                beats.append(beats_diff(last)!)\n\
    \                last = 0\n                notes_cnt += 1\n                current_note\
    \ = notes_cnt % 8\n                continue\n            }\n        } else if\
    \ new_note == \"o|\" {\n            if last_beat[0] != last_beat[2] {\n      \
    \          beats.append(beats_diff(last)!)\n                last = 0\n       \
    \         notes_cnt += 1\n                current_note = notes_cnt % 8\n     \
    \           continue\n            }\n        } else if new_note == \"o\" {\n \
    \           if last_beat[0] != last_beat[3] {\n                beats.append(beats_diff(last)!)\n\
    \                last = 0\n                notes_cnt += 1\n                current_note\
    \ = notes_cnt % 8\n                continue\n            }\n        } else if\
    \ new_note == \"o|\" {\n            if last_beat[0] != last_beat[4] {\n      \
    \          beats.append(beats_diff(last)!)\n                last = 0\n       \
    \         notes_cnt += 1\n                current_note = notes_cnt % 8\n     \
    \           continue\n            }\n        } else if new_note == \"o|\" {\n\
    \            if last_beat[0] != last_beat[5] {\n                beats.append(beats_diff(last)!)\n\
    \                last = 0\n                notes_cnt += 1\n                current_note\
    \ = notes_cnt % 8\n                continue\n            }\n        } else if\
    \ new_note == \"o\" {\n            if last_beat[0] != last_beat[6] {\n       \
    \         beats.append(beats_diff(last)!)\n                last = 0\n        \
    \        notes_cnt += 1\n                current_note = notes_cnt % 8\n      \
    \          continue\n            }\n        } else if new_note == \"o|\" {\n \
    \           if last_beat[0] != last_beat[7] {\n                beats.append(beats_diff(last)!)\n\
    \                last = 0\n                notes_cnt += 1\n                current_note\
    \ = notes_cnt % 8\n                continue\n            }\n        } else {\n\
    \            fatalError()\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpu2q5fcqu.swift:109:87: error: expected '}' at end of brace statement\n\
    assert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4,\
    \ 2, 4, 2])\n                                                                \
    \                      ^\n/tmp/tmpu2q5fcqu.swift:11:49: note: to match this opening\
    \ '{'\nfunc parse_music(music_string: String) -> [Int] {\n                   \
    \                             ^\n/tmp/tmpu2q5fcqu.swift:19:16: error: cannot find\
    \ 'beat_diff' in scope\n            if beat_diff(last) == 1 {\n              \
    \ ^~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:20:30: error: cannot find 'beats_diff' in\
    \ scope\n                beats.append(beats_diff(last)!)\n                   \
    \          ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:22:30: error: cannot find 'beats_diff'\
    \ in scope\n                beats.append(beats_diff(last)! * 2)\n            \
    \                 ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:30:25: error: cannot find\
    \ 'beats_diff' in scope\n        let last_beat = beats_diff(last)\n          \
    \              ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:33:30: error: cannot find 'beats_diff'\
    \ in scope\n                beats.append(beats_diff(last)!)\n                \
    \             ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:41:30: error: cannot find 'beats_diff'\
    \ in scope\n                beats.append(beats_diff(last)!)\n                \
    \             ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:49:30: error: cannot find 'beats_diff'\
    \ in scope\n                beats.append(beats_diff(last)!)\n                \
    \             ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:57:30: error: cannot find 'beats_diff'\
    \ in scope\n                beats.append(beats_diff(last)!)\n                \
    \             ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:65:30: error: cannot find 'beats_diff'\
    \ in scope\n                beats.append(beats_diff(last)!)\n                \
    \             ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:73:30: error: cannot find 'beats_diff'\
    \ in scope\n                beats.append(beats_diff(last)!)\n                \
    \             ^~~~~~~~~~\n/tmp/tmpu2q5fcqu.swift:81:30: error: cannot find 'beats_diff'\
    \ in scope\n       "
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beatsSum: [Int] = [0]\n\
    \n    var notes: [String] = []\n\n    let pattern = try! NSRegularExpression(pattern:\
    \ \"o|.|o|\")\n\n    var range: NSRange = NSMakeRange(0, 0)\n    var match: NSTextCheckingResult?\n\
    \    while true {\n        range = pattern.rangeOfFirstMatchInString(music_string,\
    \ options: .BackwardsSearch, range: range)\n        match = pattern.firstMatchInString(music_string,\
    \ options: .BackwardsSearch, range: range)\n        if match?.numberOfRanges ==\
    \ 0 {\n            break\n        }\n\n        if match?.numberOfRanges > 1 {\n\
    \            notes.append(music_string.substringWithRange(range))\n          \
    \  beatsSum.append(4)\n        } else {\n            notes.append(music_string.substringWithRange(range))\n\
    \            beatsSum.append(1)\n        }\n\n        range = NSMakeRange(range.location\
    \ + range.length, range.length)\n    }\n\n    return beatsSum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpduur46ik.swift:16:24: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let pattern = try! NSRegularExpression(pattern: \"o|.|o|\")\n\
    \                       ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpduur46ik.swift:18:16: error:\
    \ cannot find type 'NSRange' in scope\n    var range: NSRange = NSMakeRange(0,\
    \ 0)\n               ^~~~~~~\n/tmp/tmpduur46ik.swift:19:16: error: cannot find\
    \ type 'NSTextCheckingResult' in scope\n    var match: NSTextCheckingResult?\n\
    \               ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpduur46ik.swift:21:75: error: cannot\
    \ infer contextual base in reference to member 'BackwardsSearch'\n        range\
    \ = pattern.rangeOfFirstMatchInString(music_string, options: .BackwardsSearch,\
    \ range: range)\n                                                            \
    \             ~^~~~~~~~~~~~~~~\n/tmp/tmpduur46ik.swift:22:68: error: cannot infer\
    \ contextual base in reference to member 'BackwardsSearch'\n        match = pattern.firstMatchInString(music_string,\
    \ options: .BackwardsSearch, range: range)\n                                 \
    \                                 ~^~~~~~~~~~~~~~~\n/tmp/tmpduur46ik.swift:27:19:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if match?.numberOfRanges > 1 {\n                  ^\n/tmp/tmpduur46ik.swift:27:19:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if match?.numberOfRanges > 1 {\n                  ^\n       \
    \                          ?? <#default value#>\n/tmp/tmpduur46ik.swift:27:19:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if match?.numberOfRanges > 1 {\n                  ^\n       \
    \    (                    )!\n/tmp/tmpduur46ik.swift:28:39: error: value of type\
    \ 'String' has no member 'substringWithRange'\n            notes.append(music_string.substringWithRange(range))\n\
    \                         ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpduur46ik.swift:31:39:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \   notes.append(music_string.substringWithRange"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string\n \
    \       .split(separator: \"|\")\n        .map({ $0.split(separator: \"o\")\n\
    \            .map({ $0.characters.count })\n            .sum() })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmph93oa0ap.swift:16:14: error: value of type '[Int]' has no member\
    \ 'sum'\n            .sum() })\n             ^~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let split = music_string.split(separator:\
    \ \"|\")\n    var beats = [Int]()\n    for note in split {\n        let beat =\
    \ note.split(separator: \" \")[0]\n        if beat.count > 0 {\n            beats.append(Int(beat))\n\
    \        }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpxagzzs3f.swift:17:26: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n            beats.append(Int(beat))\n\
    \                         ^\n/tmp/tmpxagzzs3f.swift:17:26: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \   beats.append(Int(beat))\n                         ^\n                    \
    \               ?? <#default value#>\n/tmp/tmpxagzzs3f.swift:17:26: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    beats.append(Int(beat))\n                         ^\n                   \
    \               !\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return parse_music_helper(music_string,\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\"\
    ) == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4,\
    \ 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string:\
    \ \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpp3vmevao.swift:12:12: error: cannot find 'parse_music_helper' in\
    \ scope\n    return parse_music_helper(music_string, 0)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    if music_string == \"\"\
    \ {\n        return []\n    }\n\n    let notes = music_string.components(separatedBy:\
    \ \" \").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n    var beats\
    \ = [Int]()\n\n    for note in notes {\n        let length = note.count\n    \
    \    var last = 0\n\n        switch (note.first!) {\n        case \"o\":\n   \
    \         for _ in 0..<length { last += 1 }\n            break\n        case \"\
    o|\":\n            for _ in 0..<length { last += 2 }\n            break\n    \
    \    case \".|\":\n            for _ in 0..<length { last += 4 }\n           \
    \ break\n        default:\n            break\n        }\n\n        beats.append(last)\n\
    \    }\n\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpp0u5l8iu.swift:16:30: error: value of type 'String' has no member\
    \ 'components'\n    let notes = music_string.components(separatedBy: \" \").map\
    \ { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n                ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpp0u5l8iu.swift:16:92: error: cannot infer contextual base\
    \ in reference to member 'whitespacesAndNewlines'\n    let notes = music_string.components(separatedBy:\
    \ \" \").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }\n        \
    \                                                                            \
    \      ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_notes: [String]\
    \ = music_string.components(separatedBy: \" \")\n\n    let beats_per_note = Int((music_notes.count\
    \ - 1)/4)\n\n    let notes = music_notes.enumerated().map({ $0.element })\n  \
    \  \n    var note_string = \"\"\n    \n    for note in notes {\n        if note\
    \ == \"o\" {\n            note_string += \"0\"\n        } else if note == \"o|\"\
    \ {\n            note_string += \"1\"\n        } else if note == \".|\" {\n  \
    \          note_string += \"2\"\n        } else {\n            fatalError(\"unknown\
    \ note letter!\")\n        }\n    }\n\n    var beat_string = \"\"\n    \n    for\
    \ i in 0..<music_notes.count {\n        beat_string = beat_string.characters[Int((i\
    \ + 1)/4)].uppercased()\n    }\n\n    let beats = beat_string.characters\n\n \
    \   var beat_count: [Int] = [0, 0, 0, 0, 0]\n\n    for i in 0..<note_string.characters.count\
    \ {\n        beat_count[Int(note_string[Int(i)]) - 48] = beat_count[Int(note_string[Int(i)])\
    \ - 48] + 1\n    }\n\n    var last_beats: Int = 0\n    \n    for i in 0..<beats.count\
    \ {\n        last_beats = beat_count[Int(beats[i]) - 48]\n    }\n\n    return\
    \ Array(repeating: last_beats, count: music_notes.count/4).map { _ in 0 }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpqglppod9.swift:12:46: error: value of type 'String' has no member\
    \ 'components'\n    let music_notes: [String] = music_string.components(separatedBy:\
    \ \" \")\n                                ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqglppod9.swift:35:23:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        beat_string = beat_string.characters[Int((i\
    \ + 1)/4)].uppercased()\n                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqglppod9.swift:35:35:\
    \ error: 'characters' is unavailable: Please use String directly\n        beat_string\
    \ = beat_string.characters[Int((i + 1)/4)].uppercased()\n                    \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqglppod9.swift:38:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    let beats = beat_string.characters\n              \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqglppod9.swift:42:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<note_string.characters.count {\n     \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqglppod9.swift:43:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        beat_count[Int(note_string[Int(i)]) - 48] = beat_count[Int(note_string[Int(i)])\
    \ - 48] + 1\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqglppod9.swift:49:33: error: no exact matches in call to initializer \n\
    \        last_beats = b"
  stdout: ''
  timestamp: 1660014162
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n  var music = [Int]()\n  for\
    \ _ in 0..<len(music_string) {\n    let note = music_string.substring(from: 0,\
    \ to: music_string.index(before: music_string.endIndex, offsetBy: 1))\n    switch\
    \ note {\n    case \"o\":\n      music.append(4)\n    case \"o|\":\n      music.append(2)\n\
    \    default:\n      music.append(1)\n    }\n  }\n  return music\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp1jxujah1.swift:13:16: error: cannot find 'len' in scope\n  for\
    \ _ in 0..<len(music_string) {\n               ^~~\n/tmp/tmp1jxujah1.swift:14:65:\
    \ error: no exact matches in call to instance method 'index'\n    let note = music_string.substring(from:\
    \ 0, to: music_string.index(before: music_string.endIndex, offsetBy: 1))\n   \
    \                                                             ^\n/tmp/tmp1jxujah1.swift:14:65:\
    \ note: found candidate with type '(String.Index, Int) -> String.Index'\n    let\
    \ note = music_string.substring(from: 0, to: music_string.index(before: music_string.endIndex,\
    \ offsetBy: 1))\n                                                            \
    \    ^\n/tmp/tmp1jxujah1.swift:14:29: error: value of type 'String' has no member\
    \ 'substring'\n    let note = music_string.substring(from: 0, to: music_string.index(before:\
    \ music_string.endIndex, offsetBy: 1))\n               ~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes = [Int]()\n \
    \   \n    let music_string_length = music_string.count\n    \n    let music_string_lowercase\
    \ = music_string.lowercased()\n    \n    for i in 0..<music_string_length { //\
    \ For each note\n        \n        let first_char = music_string_lowercase[i]\n\
    \        \n        if first_char == \"o\" { // If this is the first note of the\
    \ chord\n            notes.append(4)\n            \n            if music_string_length\
    \ > i + 1 {\n                \n                let second_char = music_string_lowercase[i\
    \ + 1]\n                \n                if second_char == \"|\" || second_char\
    \ == \"o\" {\n                    notes.append(2)\n                }\n       \
    \     }\n        }\n        else if first_char == \"o\" { // If this second note\
    \ of the chord\n            notes.append(1)\n            \n            if music_string_length\
    \ > i + 1 {\n                \n                let second_char = music_string_lowercase[i\
    \ + 1]\n                \n                if second_char == \"|\" || second_char\
    \ == \"o\" {\n                    notes.append(1)\n                }\n       \
    \     }\n        }\n        else if first_char == \".\" { // If this is the first\
    \ half note of the chord\n            notes.append(2)\n            \n        \
    \    if music_string_length > i + 1 {\n                \n                let second_char\
    \ = music_string_lowercase[i + 1]\n                \n                if second_char\
    \ == \"|\" || second_char == \"o\" {\n                    notes.append(2)\n  \
    \              }\n            }\n        }\n        else if first_char == \"|\"\
    \ { // If this is the second half note of the chord\n            notes.append(1)\n\
    \            \n            if music_string_length > i + 1 {\n                \n\
    \                let second_char = music_string_lowercase[i + 1]\n           \
    \     \n                if second_char == \"|\" || second_char == \"o\" {\n  \
    \                  notes.append(1)\n                }\n            }\n       \
    \ }\n    }\n    \n    return notes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp9s_futh5.swift:20:26: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let first_char\
    \ = music_string_lowercase[i]\n                         ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9s_futh5.swift:27:35:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let second_char = music_string_lowercase[i\
    \ + 1]\n                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9s_futh5.swift:39:35:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let second_char = music_string_lowercase[i\
    \ + 1]\n                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9s_futh5.swift:51:35:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let second_char = music_string_lowercase[i\
    \ + 1]\n                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9s_futh5.swift:63:35:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let second_char = music_string_lowercase[i\
    \ + 1]\n                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // TODO: fill this function\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpnpefvdf8/tmpnpefvdf8.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad75902ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad758d21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad758d21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad758d207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnpefvdf8                        0x000055ed4616751f <unavailable> + 5407

    5    libc.so.6                          0x00002ad759216460 __libc_start_main +
    245

    6    tmpnpefvdf8                        0x000055ed46167059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Initialize empty array\
    \ of notes\n    var notes = [Int]()\n\n    // Iterate through string and use if\
    \ conditions to detect different types of notes\n    for letter in music_string\
    \ {\n        if letter == \".\" {\n            notes.append(1)\n        } else\
    \ if letter == \"|\" {\n            notes.append(2)\n        } else if letter\
    \ == \"o\" {\n            notes.append(4)\n        } else {\n            // If\
    \ note is unrecognized, just append an empty note to array and continue\n    \
    \        notes.append(0)\n        }\n    }\n    return notes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpj_hy19vt/tmpj_hy19vt.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24813cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24810c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24810c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24810c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj_hy19vt                        0x00005643616f076f <unavailable> + 5999

    5    libc.so.6                          0x00002b24815b6460 __libc_start_main +
    245

    6    tmpj_hy19vt                        0x00005643616f02a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes = [Int]()\n \
    \   var notes_count = [Int]()\n    var notes_last_beat = [Int]()\n    for character\
    \ in music_string {\n        if character == \"o\" {\n            notes.append(0)\n\
    \            notes_count.append(0)\n            notes_last_beat.append(0)\n  \
    \      } else if character == \"|\" {\n            notes_count.append(0)\n   \
    \         notes_last_beat.append(0)\n        } else {\n            notes_last_beat[notes_count.index(notes_count.count\
    \ - 1) + 1] += 1\n            notes_last_beat[notes_count.index(notes_count.count\
    \ - 1) + 3] += 1\n            notes_last_beat[notes_count.index(notes_count.count\
    \ - 1) + 5] += 1\n            if character == \" \" {\n                notes_count.append(0)\n\
    \            } else {\n                notes_count[notes_count.index(notes_count.count\
    \ - 1) + 1] += 1\n            }\n        }\n    }\n    return notes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp66lvd55x.swift:24:41: error: no exact matches in call to instance\
    \ method 'index'\n            notes_last_beat[notes_count.index(notes_count.count\
    \ - 1) + 1] += 1\n                                        ^\nSwift.Array:7:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Int) -> Int\n                     \
    \      ^\nSwift.Array:9:28: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(before:)')\n    @inlinable public func index(before i: Int) -> Int\n\
    \                           ^\nSwift.RandomAccessCollection:3:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(after:)')\n    @inlinable public\
    \ func index(after i: Self.Index) -> Self.Index\n                           ^\n\
    Swift.RandomAccessCollection:4:28: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(before:)')\n    @inlinable public func index(before i: Self.Index)\
    \ -> Self.Index\n                           ^\n/tmp/tmp66lvd55x.swift:25:41: error:\
    \ no exact matches in call to instance method 'index'\n            notes_last_beat[notes_count.index(notes_count.count\
    \ - 1) + 3] += 1\n                                        ^\nSwift.Array:7:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Int) -> Int\n                     \
    \      ^\nSwift.Array:9:28: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(before:)')\n    @inlinable public func index(before i: Int) -> Int\n\
    \                           ^\nSwift.RandomAccessCollection:3:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(after:)')\n    @inlinable public\
    \ func index(after i: Self.Index) -> Self.Index\n                           ^\n\
    Swift.RandomAccessCollection:4:28: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(before:)')\n    @inlinable public func index(before i: Self.Index)\
    \ -> Self.Index\n                           ^\n/tmp/tmp66lvd55x.swift:26:41: error:\
    \ no exact matches in call to instance method 'index'\n       "
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.unicodeScalars.filter({\
    \ $0.isLetter })\n    let notes_count = notes.count\n    let beats_per_note =\
    \ 4\n    let notes_per_beat = notes_count / beats_per_note\n    let notes_per_quarter\
    \ = notes_count / 3\n    guard notes_count >= 3 else { return [0] }\n\n    var\
    \ notes_per_beats: [Int] = []\n    notes_per_beats.append(notes_per_beat)\n  \
    \  if notes_per_quarter != 0 {\n        notes_per_beats.append(notes_per_quarter)\n\
    \    }\n\n    var beats_per_notes: [Int] = []\n    beats_per_notes.append(beats_per_note)\n\
    \    if notes_per_beat != 0 {\n        beats_per_notes.append(beats_per_note)\n\
    \    }\n\n    var beats_to_last: [Int] = []\n    for _ in 0..<notes_count {\n\
    \        let note_beat = notes.randomElement()\n        if note_beat.value ==\
    \ notes_per_beat {\n            beats_to_last.append(beats_per_note)\n       \
    \ } else {\n            beats_to_last.append(beats_per_notes[beats_to_last.count\
    \ - 1])\n        }\n    }\n\n    return beats_to_last\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpv7mk_dgh.swift:12:57: error: value of type 'Unicode.Scalar' has\
    \ no member 'isLetter'\n    let notes = music_string.unicodeScalars.filter({ $0.isLetter\
    \ })\n                                                     ~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   var notes = [Int]()\n    var index = 0\n    let notes_count = music_string.characters.count\n\
    \    for c in music_string {\n        if index > notes_count {\n            break\n\
    \        }\n        switch c {\n        case \"o\":\n            beats.append(4)\n\
    \            notes.append(0)\n        case \"|\":\n            beats.append(2)\n\
    \            notes.append(0)\n        default:\n            beats.append(1)\n\
    \            notes.append(0)\n        }\n        index += 1\n    }\n    return\
    \ beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp7zngl96j.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let notes_count = music_string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes: String = music_string\n\
    \    var beat: Int = 1\n    var beatCounts = [Int]()\n    var currentNote = \"\
    \"\n    for ch in notes {\n        if ch == \"|\" {\n            beatCounts.append(beat)\n\
    \            beat = 1\n        }\n        if ch == \"o\" {\n            beatCounts.append(beat)\n\
    \            beat = 1\n            currentNote = \"o\"\n        } else {\n   \
    \         beat = 1\n            if currentNote == \"o\" {\n                currentNote\
    \ = \"\"\n                beatCounts.append(beat)\n            } else {\n    \
    \            beatCounts.append(beat)\n            }\n        }\n    }\n    return\
    \ beatCounts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpkrs7hfsf/tmpkrs7hfsf.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16ee750c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16ee447b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16ee447988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16ee4467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkrs7hfsf                        0x0000560b2da4b7cf <unavailable> + 6095

    5    libc.so.6                          0x00002b16ee93c460 __libc_start_main +
    245

    6    tmpkrs7hfsf                        0x0000560b2da4b309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_per_note = [0]\n\
    \    var beats_numbers = [Int]()\n    var beats_index = 0\n    var last_note_index\
    \ = 0\n    var last_note = Int()\n\n    for note in music_string {\n        switch\
    \ note {\n        case \"o\":\n            beats_per_note[0] += 4\n        case\
    \ \"o|\":\n            beats_per_note[0] += 2\n        case \"..\":\n        \
    \    beats_per_note[0] += 1\n        default:\n            if last_note_index\
    \ > 0 {\n                beats_numbers.append(beats_index)\n            }\n  \
    \          last_note = Int(note)\n            last_note_index += 1\n         \
    \   beats_per_note[0] = 1\n        }\n    }\n    beats_numbers.append(beats_index)\n\
    \    return beats_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpmiwjp7eo.swift:22:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n/tmp/tmpmiwjp7eo.swift:24:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"..\":\n            \
    \ ^~~~\n/tmp/tmpmiwjp7eo.swift:30:25: error: no exact matches in call to initializer\
    \ \n            last_note = Int(note)\n                        ^\nSwift.Int:7:12:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public init(_\
    \ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    if music_string == \"\"\
    \ {\n        return []\n    }\n    var result: [Int] = [0]\n    var beat = 0\n\
    \    var note = \"\"\n    var beats_count = 0\n    for character in music_string\
    \ {\n        if character == \".\" {\n            beats_count += 1\n         \
    \   if beats_count % 4 == 0 {\n                result.append(beat)\n         \
    \   }\n            beat = 0\n            note = \"\"\n        }\n        if character\
    \ == \"o\" {\n            beats_count += 1\n            if beats_count % 4 ==\
    \ 0 {\n                result.append(beat)\n            }\n            beat =\
    \ 0\n            note = \"o\"\n        }\n        if character == \"|\" {\n  \
    \          beats_count += 1\n            if beats_count % 2 == 0 {\n         \
    \       result.append(beat)\n            }\n            beat = 0\n           \
    \ note = \"|\"\n        }\n        if character == \" \" {\n            beats_count\
    \ = 0\n        }\n        if character == \"o\" {\n            beat += 1\n   \
    \         beats_count = 0\n        }\n        if character == \"|\" {\n      \
    \      beat += 1\n            beats_count = 0\n        }\n        if character\
    \ == \" \" {\n            beats_count = 0\n        }\n        if character ==\
    \ \"o\" {\n            beat += 1\n            beats_count = 0\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpb_94m33b/tmpb_94m33b.swift:80: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ace925c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ace61cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ace61c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ace61b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb_94m33b                        0x0000555a2c62280f <unavailable> + 6159

    5    libc.so.6                          0x00002b9aceb11460 __libc_start_main +
    245

    6    tmpb_94m33b                        0x0000555a2c622349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_array = music_string.split(separator:\
    \ \" \")\n    let notes = music_array.map { $0.isEmpty ? nil : \"o|\".contains($0)\
    \ ? 4 : 2 }\n    return notes.map { notes_into_beats(note: $0, beats: $1) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpxmpgij62.swift:14:24: error: cannot find 'notes_into_beats' in\
    \ scope\n    return notes.map { notes_into_beats(note: $0, beats: $1) }\n    \
    \                   ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [[Int]] = Array(0...4).map\
    \ { Array(repeating: 0, count: 4) }\n    var notes = [Int]()\n    var current_note\
    \ = 0\n    var current_beat = 0\n    for note_index in 0..<music_string.characters.count\
    \ {\n        guard let current_char = music_string[note_index] else { return beats\
    \ }\n        switch current_char {\n        case \"o\": notes.append(current_note);\
    \ current_note = 0\n        case \"|\": notes.append(current_note); current_note\
    \ = 1\n        case \".\": notes.append(current_note); current_note = 2\n    \
    \    default: break\n        }\n        current_beat += notes[current_note]!\n\
    \    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpc1avf6vy.swift:12:32: error: missing argument label 'arrayLiteral:'\
    \ in call\n    var beats: [[Int]] = Array(0...4).map { Array(repeating: 0, count:\
    \ 4) }\n                               ^\n                               arrayLiteral:\
    \ \n/tmp/tmpc1avf6vy.swift:12:33: error: cannot convert value of type 'ClosedRange<Int>'\
    \ to expected argument type '()'\n    var beats: [[Int]] = Array(0...4).map {\
    \ Array(repeating: 0, count: 4) }\n                                ^\n/tmp/tmpc1avf6vy.swift:16:40:\
    \ error: 'characters' is unavailable: Please use String directly\n    for note_index\
    \ in 0..<music_string.characters.count {\n                                   \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpc1avf6vy.swift:17:34:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        guard let current_char = music_string[note_index]\
    \ else { return beats }\n                                 ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpc1avf6vy.swift:17:73:\
    \ error: cannot convert return expression of type '[[Int]]' to return type '[Int]'\n\
    \        guard let current_char = music_string[note_index] else { return beats\
    \ }\n                                                                        ^\n\
    /tmp/tmpc1avf6vy.swift:17:73: note: arguments to generic parameter 'Element' ('[Int]'\
    \ and 'Int') are expected to be equal\n        guard let current_char = music_string[note_index]\
    \ else { return beats }\n                                                    \
    \                    ^\n/tmp/tmpc1avf6vy.swift:17:15: error: initializer for conditional\
    \ binding must have Optional type, not 'Character'\n        guard let current_char\
    \ = music_string[note_index] else { return beats }\n              ^          \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpc1avf6vy.swift:24:44: error: cann"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = 0\n    var\
    \ beats_so_far = 0\n    var current_note = 0\n    var note_length = 0\n    var\
    \ note_length_to_beats_conversion = Int64()\n    var notes_to_beats_conversion\
    \ = Int64()\n\n    for i in 0..<music_string.characters.count {\n        let character\
    \ = music_string.characters[i]\n        notes_to_beats_conversion = Int(notes_to_beats_conversion\
    \ * 12 + character)\n    }\n\n    notes_to_beats_conversion = Int(notes_to_beats_conversion\
    \ * 12 + Int64(1))\n    for i in 0..<notes_to_beats_conversion {\n        note_length\
    \ = notes_to_beats_conversion - i\n        note_length_to_beats_conversion = note_length\
    \ / (Int64(4) * Int64(60))\n        if i < note_length {\n            beats +=\
    \ Int(note_length_to_beats_conversion)\n        }\n    }\n\n    return beats\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpaxcfa4db.swift:19:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<music_string.characters.count {\n    \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpaxcfa4db.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ character = music_string.characters[i]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpaxcfa4db.swift:20:38:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = music_string.characters[i]\n                                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpaxcfa4db.swift:21:74:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int64'\n\
    \        notes_to_beats_conversion = Int(notes_to_beats_conversion * 12 + character)\n\
    \                                                                         ^\n\
    /tmp/tmpaxcfa4db.swift:21:37: error: cannot assign value of type 'Int' to type\
    \ 'Int64'\n        notes_to_beats_conversion = Int(notes_to_beats_conversion *\
    \ 12 + character)\n                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                    Int64(                                  \
    \       )\n/tmp/tmpaxcfa4db.swift:24:33: error: cannot assign value of type 'Int'\
    \ to type 'Int64'\n    notes_to_beats_conversion = Int(notes_to_beats_conversion\
    \ * 12 + Int64(1))\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                Int64(                                      \
    \  )\n/tmp/tmpaxcfa4db.swift:26:49: error: cannot assign value of type 'Int64'\
    \ to type 'Int'\n        no"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes: [Int] = [0]\n\
    \    var last = [0, 4]\n    for char in music_string.unicodeScalars {\n      \
    \  switch char {\n        case .o:\n            notes.append(notes.count + 1)\n\
    \        case .o:\n            last = last.map({$0 + 1}).filter({$0 == last[0]}).last\n\
    \        default:\n            last = last.map({$0 - 1}).filter({$0 == last[0]}).last\n\
    \        }\n    }\n    return notes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp9a128e_h.swift:16:15: error: type 'Unicode.Scalar' has no member\
    \ 'o'\n        case .o:\n             ~^\n/tmp/tmp9a128e_h.swift:18:15: error:\
    \ type 'Unicode.Scalar' has no member 'o'\n        case .o:\n             ~^\n\
    /tmp/tmp9a128e_h.swift:19:63: error: cannot assign value of type 'Int?' to type\
    \ '[Int]'\n            last = last.map({$0 + 1}).filter({$0 == last[0]}).last\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmp9a128e_h.swift:21:63:\
    \ error: cannot assign value of type 'Int?' to type '[Int]'\n            last\
    \ = last.map({$0 - 1}).filter({$0 == last[0]}).last\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Create an empty array\
    \ to store the results\n    var notes = [Int]()\n\n    // Iterate over all the\
    \ characters in the string and count how many times each note appears\n    for\
    \ note in music_string {\n        if note.isWhiteSpace {\n            // Ignore\
    \ white spaces\n            continue\n        }\n\n        let note_char = note.asDigit()\n\
    \n        if note.asDigit() == \"o\" {\n            // Count how many whole notes\
    \ there are in the string\n            notes.append(1)\n        } else if note.asDigit()\
    \ == \"o|\" {\n            // Count how many half notes there are in the string\n\
    \            notes.append(2)\n        } else if note.asDigit() == \".|\" {\n \
    \           // Count how many quater notes there are in the string\n         \
    \   notes.append(1)\n        } else {\n            // Unknown note\n         \
    \   notes.append(0)\n        }\n    }\n\n    return notes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpbn6m8phv.swift:17:17: error: value of type 'Character' has no member\
    \ 'isWhiteSpace'\n        if note.isWhiteSpace {\n           ~~~~ ^~~~~~~~~~~~\n\
    /tmp/tmpbn6m8phv.swift:22:30: error: value of type 'Character' has no member 'asDigit'\n\
    \        let note_char = note.asDigit()\n                        ~~~~ ^~~~~~~\n\
    /tmp/tmpbn6m8phv.swift:24:17: error: value of type 'Character' has no member 'asDigit'\n\
    \        if note.asDigit() == \"o\" {\n           ~~~~ ^~~~~~~\n/tmp/tmpbn6m8phv.swift:27:24:\
    \ error: value of type 'Character' has no member 'asDigit'\n        } else if\
    \ note.asDigit() == \"o|\" {\n                  ~~~~ ^~~~~~~\n/tmp/tmpbn6m8phv.swift:30:24:\
    \ error: value of type 'Character' has no member 'asDigit'\n        } else if\
    \ note.asDigit() == \".|\" {\n                  ~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [[Int]] = []\n\
    \    var beat = 0\n    var note_index = 0\n    for c in music_string {\n     \
    \   if c == \".\" {\n            beats[note_index].append(beat)\n            beat\
    \ = 0\n            note_index += 1\n        } else {\n            if c == \"o\"\
    \ {\n                beats[note_index].append(beat)\n            }\n         \
    \   beat += 1\n        }\n    }\n    for _ in beats {\n        beats.append([])\n\
    \    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpxbw82b1b.swift:30:12: error: cannot convert return expression of\
    \ type '[[Int]]' to return type '[Int]'\n    return beats\n           ^\n/tmp/tmpxbw82b1b.swift:30:12:\
    \ note: arguments to generic parameter 'Element' ('[Int]' and 'Int') are expected\
    \ to be equal\n    return beats\n           ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [Int] = []\n\
    \    let notes_count = music_string.characters.count\n\n    // The maximum number\
    \ of notes in a single bar\n    // TODO: this could be improved if music_string\
    \ is long\n    var note_counter = 0\n\n    var current_beat = 0\n    var current_note\
    \ = 0\n    var is_last_note = false\n\n    for _ in 0..<notes_count {\n      \
    \  guard let c = music_string.character(at: $0) else {\n            note_counter\
    \ += 1\n            current_beat += 1\n            current_note = 0\n        \
    \    continue\n        }\n\n        switch c {\n        case \"o\":\n        \
    \    is_last_note = false\n        case \"o|\":\n            is_last_note = true\n\
    \        case \".|\":\n            is_last_note = false\n        default:\n  \
    \          fatalError(\"Unknown note\")\n        }\n\n        note_counter +=\
    \ 1\n        current_beat += is_last_note\n        current_note += 1\n\n     \
    \   beats.append(current_beat)\n    }\n\n    return beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpowujtfi_.swift:24:50: error: anonymous closure argument not contained\
    \ in a closure\n        guard let c = music_string.character(at: $0) else {\n\
    \                                                 ^\n/tmp/tmpowujtfi_.swift:13:36:\
    \ error: 'characters' is unavailable: Please use String directly\n    let notes_count\
    \ = music_string.characters.count\n                                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpowujtfi_.swift:24:36:\
    \ error: value of type 'String' has no member 'character'\n        guard let c\
    \ = music_string.character(at: $0) else {\n                      ~~~~~~~~~~~~\
    \ ^~~~~~~~~\n/tmp/tmpowujtfi_.swift:43:25: error: cannot convert value of type\
    \ 'Bool' to expected argument type 'Int'\n        current_beat += is_last_note\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n\tmusic_array = music_string.characters\n\
    \tmusic_count = music_string.count\n\n\tmusic_array[music_count - 1] = \"o\"\n\
    \tmusic_array[music_count - 2] = \"o\"\n\tmusic_array[music_count - 3] = \"|\"\
    \n\n\tlet beats = music_string.components(separatedBy: \"|\").map {\n\t\tlet beat\
    \ = Int($0)\n\t\tif beat == 0 {\n\t\t\treturn 4\n\t\t} else if beat == 1 {\n\t\
    \t\treturn 2\n\t\t} else {\n\t\t\treturn 1\n\t\t}\n\t}\n\n\treturn beats\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpzclxyw59.swift:12:2: error: cannot find 'music_array' in scope\n\
    \        music_array = music_string.characters\n        ^~~~~~~~~~~\n/tmp/tmpzclxyw59.swift:13:2:\
    \ error: cannot find 'music_count' in scope\n        music_count = music_string.count\n\
    \        ^~~~~~~~~~~\n/tmp/tmpzclxyw59.swift:15:2: error: cannot find 'music_array'\
    \ in scope\n        music_array[music_count - 1] = \"o\"\n        ^~~~~~~~~~~\n\
    /tmp/tmpzclxyw59.swift:15:14: error: cannot find 'music_count' in scope\n    \
    \    music_array[music_count - 1] = \"o\"\n                    ^~~~~~~~~~~\n/tmp/tmpzclxyw59.swift:16:2:\
    \ error: cannot find 'music_array' in scope\n        music_array[music_count -\
    \ 2] = \"o\"\n        ^~~~~~~~~~~\n/tmp/tmpzclxyw59.swift:16:14: error: cannot\
    \ find 'music_count' in scope\n        music_array[music_count - 2] = \"o\"\n\
    \                    ^~~~~~~~~~~\n/tmp/tmpzclxyw59.swift:17:2: error: cannot find\
    \ 'music_array' in scope\n        music_array[music_count - 3] = \"|\"\n     \
    \   ^~~~~~~~~~~\n/tmp/tmpzclxyw59.swift:17:14: error: cannot find 'music_count'\
    \ in scope\n        music_array[music_count - 3] = \"|\"\n                   \
    \ ^~~~~~~~~~~\n/tmp/tmpzclxyw59.swift:19:27: error: value of type 'String' has\
    \ no member 'components'\n        let beats = music_string.components(separatedBy:\
    \ \"|\").map {\n                    ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   var last = 0\n    for char in music_string {\n        if char == \"o\" {\n\
    \            if last == 0 {\n                beats.append(4)\n            } else\
    \ {\n                beats.append(1)\n            }\n            last = 4\n  \
    \      } else if char == \"|\" {\n            if last == 0 {\n               \
    \ beats.append(2)\n            } else {\n                beats.append(1)\n   \
    \         }\n            last = 2\n        } else {\n            if last == 0\
    \ {\n                beats.append(1)\n            } else {\n                beats.append(1)\n\
    \            }\n            last = 1\n        }\n    }\n    return beats\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpxpq342x8/tmpxpq342x8.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af73419ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af733e91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af733e91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af733e907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxpq342x8                        0x00005620f9a9276f <unavailable> + 5999

    5    libc.so.6                          0x00002af734386460 __libc_start_main +
    245

    6    tmpxpq342x8                        0x00005620f9a922a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    if music_string == \"\"\
    \ {\n        return []\n    }\n\n    var current_note_count = 0\n    var current_beat\
    \ = 0\n    var last_note = -1 // 0 represents whole note, 1 half note, 2 quater\
    \ note\n\n    // To parse music string using '|' symbol, we need to know the length\
    \ of each note in seconds.\n    // So lets create an array that contains note\
    \ lengths.\n    var note_lens = [Int]()\n    for i in 0..<Int(music_string.count)\
    \ {\n        if music_string[i] == '|' {\n            note_lens.append(current_note_count)\n\
    \            current_note_count = 0\n        } else {\n            current_note_count\
    \ += 1\n        }\n    }\n    note_lens.append(current_note_count)\n\n    // Let's\
    \ parse music string.\n    var note_array = [Int]()\n    for i in 0..<note_lens.count\
    \ {\n        var note = Int()\n        for _ in 0..<note_lens[i] {\n         \
    \   note = note * 2 + 1\n        }\n\n        // If the last note is not the same\
    \ as the current note, we need to add one.\n        if note != last_note {\n \
    \           note = note + 1\n        }\n\n        last_note = note\n        note_array.append(note)\n\
    \    }\n\n    return note_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpsxzxb38_.swift:24:31: error: single-quoted string literal found,\
    \ use '\"'\n        if music_string[i] == '|' {\n                            \
    \  ^~~\n                              \"|\"\n/tmp/tmpsxzxb38_.swift:24:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if music_string[i] == '|' {\n           ^~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpsxzxb38_.swift:17:9:\
    \ warning: initialization of variable 'current_beat' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var current_beat = 0\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Write your code here\n\
    \n    return [0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmp1bg2p720/tmp1bg2p720.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1416b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1413a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1413a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1413a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bg2p720                        0x000055b1950b340e <unavailable> + 5134

    5    libc.so.6                          0x00002ad14189c460 __libc_start_main +
    245

    6    tmp1bg2p720                        0x000055b1950b3059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    if music_string == \"\"\
    \ {\n        return []\n    }\n\n    var beats_per_note: [Int] = []\n\n    var\
    \ note_length = music_string.count\n\n    var note_count = 0\n    var beats =\
    \ 0\n    var current_note = \"\"\n\n    for index in 0..<note_length {\n     \
    \   character = music_string[index]\n        character_count = Int(character)\n\
    \        beats_per_note.append(beats)\n        note_count = note_count + character_count\n\
    \        beats = 0\n        if character == \".\" {\n            beats_per_note.append(beats)\n\
    \            note_count = note_count + 1\n            beats = 0\n        }\n \
    \       else {\n            beats = beats + character_count\n        }\n    }\n\
    \    beats_per_note.append(beats)\n    return beats_per_note\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp8podqgtz.swift:25:9: error: cannot find 'character' in scope\n\
    \        character = music_string[index]\n        ^~~~~~~~~\n/tmp/tmp8podqgtz.swift:26:9:\
    \ error: cannot find 'character_count' in scope\n        character_count = Int(character)\n\
    \        ^~~~~~~~~~~~~~~\n/tmp/tmp8podqgtz.swift:26:31: error: cannot find 'character'\
    \ in scope\n        character_count = Int(character)\n                       \
    \       ^~~~~~~~~\n/tmp/tmp8podqgtz.swift:28:35: error: cannot find 'character_count'\
    \ in scope\n        note_count = note_count + character_count\n              \
    \                    ^~~~~~~~~~~~~~~\n/tmp/tmp8podqgtz.swift:30:12: error: cannot\
    \ find 'character' in scope\n        if character == \".\" {\n           ^~~~~~~~~\n\
    /tmp/tmp8podqgtz.swift:36:29: error: cannot find 'character_count' in scope\n\
    \            beats = beats + character_count\n                            ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes = [Int]()\n\n\
    \    for char in music_string {\n        switch char {\n        case \"o\":\n\
    \            notes.append(0)\n        case \"o|\":\n            notes.append(4)\n\
    \        case \"|\":\n            notes.append(1)\n        default:\n        \
    \    notes.append(0)\n        }\n    }\n\n    return notes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpyopa8x80.swift:18:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result: [Int] = []\n\
    \    music_string.split(separator: \" \").enumerated().forEach {\n        guard\
    \ $0.offset > 0 else {\n            result.append(0)\n            return\n   \
    \     }\n        guard $0.offset == $0.element else { return }\n        guard\
    \ let note = music_string.index(music_string.startIndex, offset: $0.element) else\
    \ { return }\n        guard let last_note = music_string.index(music_string.startIndex,\
    \ offset: $0.element + 1) else { return }\n        guard note.offset > last_note.offset\
    \ else { return }\n        guard note.element == last_note.element else { return\
    \ }\n        guard note.element == $0.element else { return }\n        guard note.element\
    \ != 0 && !note.element == $0.element else { return }\n        result.append(note.element\
    \ - $0.element + 1 + result.count)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpbss5iotm.swift:18:25: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int' and 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>')\n\
    \        guard $0.offset == $0.element else { return }\n              ~~~~~~~~~\
    \ ^  ~~~~~~~~~~\n/tmp/tmpbss5iotm.swift:18:25: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Int, Int)\n        guard $0.offset\
    \ == $0.element else { return }\n                        ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [Int] = [0]\n\
    \    for char in music_string {\n        if char == \"o\" {\n            beats\
    \ = append(beats, beats.endIndex - beats.startIndex - 4)\n        } else if char\
    \ == \"|\" {\n            beats = append(beats, beats.endIndex - beats.startIndex\
    \ - 2)\n        } else if char == \".\" {\n            beats = append(beats, beats.endIndex\
    \ - beats.startIndex)\n        } else {\n            debugPrint(\"Unexpected character:\
    \ \\(char)\\\", this music string is \\(music_string)\")\n            return [0]\n\
    \        }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpm6qyv8cc.swift:15:21: error: cannot find 'append' in scope\n  \
    \          beats = append(beats, beats.endIndex - beats.startIndex - 4)\n    \
    \                ^~~~~~\n/tmp/tmpm6qyv8cc.swift:17:21: error: cannot find 'append'\
    \ in scope\n            beats = append(beats, beats.endIndex - beats.startIndex\
    \ - 2)\n                    ^~~~~~\n/tmp/tmpm6qyv8cc.swift:19:21: error: cannot\
    \ find 'append' in scope\n            beats = append(beats, beats.endIndex - beats.startIndex)\n\
    \                    ^~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [Int] = []\n\
    \    var notes: [String] = []\n    var beats_counter: Int = 0\n    var note_counter:\
    \ Int = 0\n    for ch in music_string {\n        notes.append(ch)\n        beats_counter\
    \ += 1\n        if ch == '|' {\n            beats_counter -= 1\n            beats.append(beats_counter)\n\
    \            beats_counter = 0\n            note_counter += 1\n            if\
    \ note_counter == 4 {\n                notes.removeLast()\n                note_counter\
    \ = 0\n            }\n        }\n    }\n    return beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp7cy5e_6k.swift:19:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch == '|' {\n                 ^~~\n                 \"\
    |\"\n/tmp/tmp7cy5e_6k.swift:17:22: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        notes.append(ch)\n             \
    \        ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   for c in music_string {\n        var beat = 0\n        var last = 0\n    \
    \    if c == \".\" {\n            beat = 0\n            last += 4\n        } else\
    \ if c == \"o\" {\n            beat = 0\n            last = 4\n        } else\
    \ if c == \"|\" {\n            beat = 1\n            last = 2\n        } else\
    \ if c == \"o|\" {\n            beat = 1\n            last = 2\n        } else\
    \ {\n            let val = c - \"0\"\n            beat = (val % 4) + 1\n     \
    \       last = val / 4\n        }\n        beats.append(last)\n    }\n    return\
    \ beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp1u7zwvuc.swift:25:21: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        } else if c == \"o|\"\
    \ {\n                  ~ ^  ~~~~\n/tmp/tmp1u7zwvuc.swift:25:21: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        } else if c == \"o|\" {\n                    ^\n/tmp/tmp1u7zwvuc.swift:29:25:\
    \ error: binary operator '-' cannot be applied to operands of type 'Character'\
    \ and 'String'\n            let val = c - \"0\"\n                      ~ ^ ~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Your code here\n   \
    \ return music_string\n        .split(separator: \"|\")\n        .map { $0.count\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\"\
    ) == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4,\
    \ 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string:\
    \ \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpo1s92sfd.swift:13:12: error: ambiguous use of 'split(separator:maxSplits:omittingEmptySubsequences:)'\n\
    \    return music_string\n           ^\nSwift.Sequence:2:40: note: found this\
    \ candidate\n    @inlinable public __consuming func split(separator: Self.Element,\
    \ maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: found\
    \ this candidate\n    @inlinable public __consuming func split(separator: Self.Element,\
    \ maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.split(\"\
    |\").map({ Int($0) }) // [\".|\", \"o o|\", \"o| o|\"]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp87tpbqx4.swift:12:31: error: missing argument label 'separator:'\
    \ in call\n    return music_string.split(\"|\").map({ Int($0) }) // [\".|\", \"\
    o o|\", \"o| o|\"]\n                              ^\n                        \
    \      separator: \n/tmp/tmp87tpbqx4.swift:12:42: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n    return music_string.split(\"\
    |\").map({ Int($0) }) // [\".|\", \"o o|\", \"o| o|\"]\n                     \
    \                    ^\n/tmp/tmp87tpbqx4.swift:12:42: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    return music_string.split(\"\
    |\").map({ Int($0) }) // [\".|\", \"o o|\", \"o| o|\"]\n                     \
    \                    ^\n                                                 ?? <#default\
    \ value#>\n/tmp/tmp87tpbqx4.swift:12:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    return music_string.split(\"\
    |\").map({ Int($0) }) // [\".|\", \"o o|\", \"o| o|\"]\n                     \
    \                    ^\n                                                !\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_string = music_string.characters.split\
    \ { $0 == \"o\" }.joined(separator: \"\")\n    var beats = [Int]()\n    var lasts\
    \ = [Int]()\n    var i = 0\n    while i < music_string.count {\n        let char\
    \ = music_string[i]\n        if char == \"o\" {\n            let beat = 1\n  \
    \          beats += [beat]\n            lasts += [beat]\n            i += 2\n\
    \        } else if char == \"|\" {\n            let beat = 2\n            beats\
    \ += [beat]\n            lasts += [beat]\n            i += 2\n        } else if\
    \ char == \".\" {\n            let beat = 1\n            beats += [beat]\n   \
    \         lasts += [beat]\n            i += 2\n        } else {\n            let\
    \ beat = 1\n            beats += [beat]\n            lasts += [beat]\n       \
    \     i += 1\n        }\n    }\n    return lasts\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpjjcy1srz.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let music_string = music_string.characters.split {\
    \ $0 == \"o\" }.joined(separator: \"\")\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjjcy1srz.swift:17:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let char = music_string[i]\n          \
    \         ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result = Array(repeating:\
    \ 0, count: 60)\n    let music_array = music_string.characters.split(\"o\").map({\
    \ o: Char in\n        let note = o.lowercased()\n        switch note {\n     \
    \   case \"o\":\n            return 4\n        case \"o|\":\n            return\
    \ 2\n        case \"|\":\n            return 1\n        default:\n           \
    \ return 0\n        }\n    })\n    for (_, element) in music_array.enumerated()\
    \ {\n        result[element] -= 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpwbafcys5.swift:13:65: error: consecutive statements on a line must\
    \ be separated by ';'\n    let music_array = music_string.characters.split(\"\
    o\").map({ o: Char in\n                                                      \
    \          ^\n                                                               \
    \ ;\n/tmp/tmpwbafcys5.swift:13:65: error: expected expression\n    let music_array\
    \ = music_string.characters.split(\"o\").map({ o: Char in\n                  \
    \                                              ^\n/tmp/tmpwbafcys5.swift:13:64:\
    \ error: cannot find 'o' in scope\n    let music_array = music_string.characters.split(\"\
    o\").map({ o: Char in\n                                                      \
    \         ^\n/tmp/tmpwbafcys5.swift:14:20: error: cannot find 'o' in scope\n \
    \       let note = o.lowercased()\n                   ^\n/tmp/tmpwbafcys5.swift:26:5:\
    \ error: failed to produce diagnostic for expression; please submit a bug report\
    \ (https://swift.org/contributing/#reporting-bugs) and include the project\n \
    \   for (_, element) in music_array.enumerated() {\n    ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let split_string = music_string.split(separator:\
    \ \" \")\n    var beats = [Int]()\n    for i in 0...split_string.count - 1 {\n\
    \        beats.append(0)\n        let splitted_string = split_string[i].split(separator:\
    \ \"|\")\n        let note = splitted_string[0]\n        let beats_count = splitted_string[1].trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n        if note.count == 1 {\n       \
    \     beats[note.lowercased()] = beats_count\n        } else if note.count > 1\
    \ && note.lowercased() == \"o\" {\n            beats[note.lowercased()] = beats_count.count\n\
    \        } else if note.count > 1 && note.lowercased() == \".\" {\n          \
    \  beats[note.lowercased()] = beats_count.count / 2\n        } else if note.count\
    \ > 1 && note.lowercased() == \"o|\" {\n            beats[note.lowercased()] =\
    \ beats_count.count / 4\n        }\n    }\n    return beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp5x_9c2jm.swift:18:69: error: cannot find 'CharacterSet' in scope\n\
    \        let beats_count = splitted_string[1].trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                                                    ^~~~~~~~~~~~\n\
    /tmp/tmp5x_9c2jm.swift:18:46: error: value of type 'Substring.SubSequence' (aka\
    \ 'Substring') has no member 'trimmingCharacters'\n        let beats_count = splitted_string[1].trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n                          ~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp5x_9c2jm.swift:20:18: error: no exact matches in\
    \ call to subscript \n            beats[note.lowercased()] = beats_count\n   \
    \              ^\n/tmp/tmp5x_9c2jm.swift:20:18: note: found candidate with type\
    \ '(Int) -> @lvalue Int'\n            beats[note.lowercased()] = beats_count\n\
    \                 ^\n/tmp/tmp5x_9c2jm.swift:20:18: note: found candidate with\
    \ type '(Range<Int>) -> @lvalue ArraySlice<Int>'\n            beats[note.lowercased()]\
    \ = beats_count\n                 ^\n/tmp/tmp5x_9c2jm.swift:20:18: note: found\
    \ candidate with type '((UnboundedRange_) -> ()) -> @lvalue ArraySlice<Int>'\n\
    \            beats[note.lowercased()] = beats_count\n                 ^\n/tmp/tmp5x_9c2jm.swift:22:18:\
    \ error: no exact matches in call to subscript \n            beats[note.lowercased()]\
    \ = beats_count.count\n                 ^\n/tmp/tmp5x_9c2jm.swift:22:18: note:\
    \ found candidate with type '(Int) -> @lvalue Int'\n            beats[note.lowercased()]\
    \ = beats_count.count\n                 ^\n/tmp/tmp5x_9c2jm.swift:22:18: note:\
    \ found candidate with type '(Range<Int>) -> @lvalue ArraySlice<Int>'\n      \
    \      beats[note.lowercased()] = beats_count.count\n                 ^\n/tmp/tmp5x_9c2jm.swift:22:18:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> @lvalue ArraySlice<Int>'\n\
    \            beats[note.lowercased()] = beats_count.count\n                 ^\n\
    /tmp/tmp5x_9c2jm.swift:24:24: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n            beats[note.lowercased()] "
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_string = \"\\\
    (music_string)\".lowercased()\n    let notes = music_string.components(separatedBy:\
    \ \" \")\n    let notes_array = Array(notes)\n    let notes_count = notes_array.count\n\
    \    let beats_per_note = 4\n\n    var note_values = [Int](repeating: 0, count:\
    \ notes_count)\n    var note_beat = [Int](repeating: 0, count: notes_count)\n\n\
    \    for i in 0..<notes_count {\n        let note = notes_array[i].lowercased()\n\
    \        if note.contains(\"o\") {\n            let beat_number = Int(note.characters(in:\
    \ \n            NSCharacterSet.letters.inverted).first!)\n            note_values[i]\
    \ += beat_number\n            note_beat[i] += beat_number\n        } else if note.contains(\"\
    |\") {\n            let beat_number = Int(note.characters(in: \n            NSCharacterSet.letters.inverted).first!)\n\
    \            note_values[i] -= beat_number\n            note_beat[i] -= beat_number\n\
    \        } else {\n            let beat_number = Int(note.characters(in: \n  \
    \          NSCharacterSet.letters.inverted).first!)\n            note_values[i]\
    \ += beat_number\n            note_values[i] -= beat_number\n        }\n    }\n\
    \n    return note_beat\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp010ms2zl.swift:13:30: error: value of type 'String' has no member\
    \ 'components'\n    let notes = music_string.components(separatedBy: \" \")\n\
    \                ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp010ms2zl.swift:25:13: error:\
    \ cannot find 'NSCharacterSet' in scope\n            NSCharacterSet.letters.inverted).first!)\n\
    \            ^~~~~~~~~~~~~~\n/tmp/tmp010ms2zl.swift:30:13: error: cannot find\
    \ 'NSCharacterSet' in scope\n            NSCharacterSet.letters.inverted).first!)\n\
    \            ^~~~~~~~~~~~~~\n/tmp/tmp010ms2zl.swift:35:13: error: cannot find\
    \ 'NSCharacterSet' in scope\n            NSCharacterSet.letters.inverted).first!)\n\
    \            ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [0]\n    var\
    \ last_beat = 0\n    var last_note = 0\n\n    for ch in music_string {\n     \
    \   if ch == 'o' {\n            last_note = last_beat % 4\n            beats.append(last_beat)\n\
    \            last_beat = 0\n        } else if ch == '|' {\n            last_beat\
    \ += 1\n        } else if ch == '.' {\n            beats.append(last_beat)\n \
    \           last_beat = 0\n        }\n    }\n\n    beats.append(last_beat)\n \
    \   return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpshafn_g1.swift:17:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch == 'o' {\n                 ^~~\n                 \"\
    o\"\n/tmp/tmpshafn_g1.swift:21:25: error: single-quoted string literal found,\
    \ use '\"'\n        } else if ch == '|' {\n                        ^~~\n     \
    \                   \"|\"\n/tmp/tmpshafn_g1.swift:23:25: error: single-quoted\
    \ string literal found, use '\"'\n        } else if ch == '.' {\n            \
    \            ^~~\n                        \".\"\n/tmp/tmpshafn_g1.swift:14:9:\
    \ warning: variable 'last_note' was written to, but never read\n    var last_note\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    guard let music_pieces\
    \ = music_string.components(separatedBy: \"|\") else {\n        return []\n  \
    \  }\n    \n    let beats = music_pieces.filter{ $0.isWhitespace }\n        .map{\
    \ $0.isLetter ? ($0 + \"|\").lowercased() : $0 }\n        .map{ musicToBeat(_:\
    \ $0) }\n        .reduce(into: [Int]()) { (result, beat) in\n            guard\
    \ result.last?.0 != beat.0 else { return }\n            result.append(beat.1)\n\
    \        }\n    \n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp5qxthuj8.swift:13:43: error: value of type 'String' has no member\
    \ 'components'\n    guard let music_pieces = music_string.components(separatedBy:\
    \ \"|\") else {\n                             ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5qxthuj8.swift:19:15:\
    \ error: cannot find 'musicToBeat' in scope\n        .map{ musicToBeat(_: $0)\
    \ }\n              ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var note_count = [Int]()\n\
    \    let music_chars = music_string.unicodeScalars\n    for char in music_chars\
    \ {\n        if char.value == 0x2e {\n            note_count[note_countIndex]\
    \ += 1\n        }\n        if note_countIndex >= note_counts.count {\n       \
    \     note_countIndex = 0\n        }\n    }\n    return note_count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpstx07hak.swift:16:24: error: cannot find 'note_countIndex' in scope\n\
    \            note_count[note_countIndex] += 1\n                       ^~~~~~~~~~~~~~~\n\
    /tmp/tmpstx07hak.swift:18:12: error: cannot find 'note_countIndex' in scope\n\
    \        if note_countIndex >= note_counts.count {\n           ^~~~~~~~~~~~~~~\n\
    /tmp/tmpstx07hak.swift:18:31: error: cannot find 'note_counts' in scope\n    \
    \    if note_countIndex >= note_counts.count {\n                             \
    \ ^~~~~~~~~~~\n/tmp/tmpstx07hak.swift:19:13: error: cannot find 'note_countIndex'\
    \ in scope\n            note_countIndex = 0\n            ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int](repeating:\
    \ 0, count: 128)\n    var beat_count = 0\n    for character in music_string {\n\
    \        if character == \".\" {\n            beats[beat_count] = 0\n        \
    \    beat_count += 1\n        } else if character == \"|\" {\n            beats[beat_count]\
    \ = 4\n            beat_count += 1\n        } else {\n            beats[beat_count]\
    \ -= 1\n        }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpfanuktnv/tmpfanuktnv.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adad4e56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adad4b4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adad4b4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adad4b4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfanuktnv                        0x000055856242e66e <unavailable> + 5742

    5    libc.so.6                          0x00002adad5042460 __libc_start_main +
    245

    6    tmpfanuktnv                        0x000055856242e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return parse_music_aux(music_string,\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\"\
    ) == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4,\
    \ 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string:\
    \ \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpwdr1y64q.swift:12:12: error: cannot find 'parse_music_aux' in scope\n\
    \    return parse_music_aux(music_string, 0)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    // Your code goes\
    \ here\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: '/tmp/tmp7231484v.swift:15:1: error: missing return in global function expected
    to return ''[Int]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // write your logic here\n\
    \    var notes: [Int] = []\n    var current_note = 0\n    var current_beat = 0\n\
    \    var current_beat_count = 1\n    for current_char in music_string {\n    \
    \    switch current_char {\n        case \"o\":\n            current_beat_count\
    \ = 1\n            current_note = 0\n        case \"|\":\n            current_note\
    \ = current_note + 1\n            current_beat_count = 1\n        default:\n \
    \           current_note = current_note + 1\n            current_beat_count =\
    \ current_beat_count + 1\n            if current_beat_count > 4 {\n          \
    \      current_beat_count = 1\n                current_beat = current_beat + 1\n\
    \            }\n        }\n    }\n    return notes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmp32l2nygt/tmp32l2nygt.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac846797c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac84648eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac84648e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac84648d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp32l2nygt                        0x000055d284d6d6bf <unavailable> + 5823

    5    libc.so.6                          0x00002ac846983460 __libc_start_main +
    245

    6    tmp32l2nygt                        0x000055d284d6d1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.characters.enumerated().map({\
    \ $0.element / 4 }).sorted().map {\n        return Int(4 * $0)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp3gmtxmck.swift:12:58: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n    return music_string.characters.enumerated().map({\
    \ $0.element / 4 }).sorted().map {\n                                         \
    \                ^\n"
  stdout: ''
  timestamp: 1660014144
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var note_strings = [String]()\n\
    \    var beats = [Int]()\n\n    for character in music_string {\n        switch\
    \ character {\n        case \"o\":\n            note_strings.append(\"whole_note\"\
    )\n        case \"o|\":\n            note_strings.append(\"half_note\")\n    \
    \    case \".|\":\n            note_strings.append(\"quarter_note\")\n       \
    \ default:\n            print(\"Warning, unknown character:\", character)\n  \
    \          return beats\n        }\n    }\n    for note_string in note_strings\
    \ {\n        if note_string == \"whole_note\" {\n            let beats_string\
    \ = music_string.characters.suffix(music_string.characters.endIndex).dropLast().map\
    \ { character -> Int in\n                switch character {\n                case\
    \ \"o\": return 1\n                case \"o|\": return 4\n                case\
    \ \".|\": return 3\n                default: return 0\n                }\n   \
    \         }.joined()\n            if beats_string == \"1234\" {\n            \
    \    return beats\n            }\n        } else if note_string == \"half_note\"\
    \ {\n            let beats_string = music_string.characters.suffix(music_string.characters.endIndex).dropLast().map\
    \ { character -> Int in\n                switch character {\n                case\
    \ \"o\": return 2\n                case \"o|\": return 2\n                case\
    \ \".|\": return 1\n                default: return 0\n                }\n   \
    \         }.joined()\n            if beats_string == \"1223\" {\n            \
    \    return beats\n            }\n        } else if note_string == \"quarter_note\"\
    \ {\n            let beats_string = music_string.characters.suffix(music_string.characters.endIndex).dropLast().map\
    \ { character -> Int in\n                switch character {\n                case\
    \ \"o\": return 1\n                case \"o|\": return 1\n                case\
    \ \".|\": return 1\n                default: return 0\n                }\n   \
    \         }.joined()\n            if beats_string == \"1222\" {\n            \
    \    return beats\n            }\n        }\n    }\n    print(\"Warning, no beats\
    \ found!\")\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpgp2_9ykn.swift:19:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n/tmp/tmpgp2_9ykn.swift:21:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \".|\":\n            \
    \ ^~~~\n/tmp/tmpgp2_9ykn.swift:30:63: error: missing argument label 'from:' in\
    \ call\n            let beats_string = music_string.characters.suffix(music_string.characters.endIndex).dropLast().map\
    \ { character -> Int in\n                                                    \
    \          ^\n                                                              from:\
    \ \n/tmp/tmpgp2_9ykn.swift:30:127: error: declared closure result 'Int' is incompatible\
    \ with contextual type 'String'\n            let beats_string = music_string.characters.suffix(music_string.characters.endIndex).dropLast().map\
    \ { character -> Int in\n                                                    \
    \                                                                          ^~~\n\
    \                                                                            \
    \                                                  String\n/tmp/tmpgp2_9ykn.swift:42:63:\
    \ error: missing argument label 'from:' in call\n            let beats_string\
    \ = music_string.characters.suffix(music_string.characters.endIndex).dropLast().map\
    \ { character -> Int in\n                                                    \
    \          ^\n                                                              from:\
    \ \n/tmp/tmpgp2_9ykn.swift:42:127: error: declared closure result 'Int' is incompatible\
    \ with contextual type 'String'\n            let beats_string = music_string.characters.suffix(music_string.characters.endIndex).dropLast().map\
    \ { character -> Int in\n                                                    \
    \                                                                          ^~~\n\
    \                                                                            \
    \                                                  String\n/tmp/tmpgp2_9ykn.swift:54:63:\
    \ error: missing"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    guard let music_string_in_bytes\
    \ = music_string.data(using: .ascii) else {\n        fatalError()\n    }\n\n \
    \   var beats_count_of_last_notes = [Int]()\n    \n    let music_string_bytes\
    \ = music_string_in_bytes\n    let music_string_bytes_len = music_string_bytes.count\n\
    \    \n    let music_string_iterator = music_string_bytes.makeIterator()\n   \
    \ let music_string_iter_marker = music_string_bytes.makeIterator()\n    \n   \
    \ var music_string_current_char = music_string_iterator.next()!\n    \n    var\
    \ beats_count_of_last_note_current_beat = 0\n    \n    // loop that will run until\
    \ end of music string\n    while music_string_current_char != \" \" {\n      \
    \  // increment beat of music string iterator marker to last beat\n        music_string_iter_marker.next()\n\
    \        \n        // increment current music string iterator\n        music_string_iterator.next()\n\
    \        \n        // increment current music string char by 1\n        music_string_current_char\
    \ = music_string_iterator.next()!\n        \n        // check if current music\
    \ string char is space symbol\n        if music_string_current_char == \" \" {\n\
    \            // check if last beat of current music string equals to beat of previous\
    \ music string iterator\n            if music_string_current_char == String(music_string_iter_marker.next())\
    \ {\n                beats_count_of_last_notes.append(beats_count_of_last_note_current_beat)\n\
    \                beats_count_of_last_note_current_beat = 0\n            }\n  \
    \      } else {\n            beats_count_of_last_note_current_beat += 1\n    \
    \    }\n    }\n    \n    return beats_count_of_last_notes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpmqpvx7pe.swift:13:52: error: value of type 'String' has no member\
    \ 'data'\n    guard let music_string_in_bytes = music_string.data(using: .ascii)\
    \ else {\n                                      ~~~~~~~~~~~~ ^~~~\n/tmp/tmpmqpvx7pe.swift:13:65:\
    \ error: cannot infer contextual base in reference to member 'ascii'\n    guard\
    \ let music_string_in_bytes = music_string.data(using: .ascii) else {\n      \
    \                                                         ~^~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result: [Int] = []\n\
    \n    let music_string_arr = music_string.characters.split(\"|\")\n\n    for music_string_arr_index\
    \ in 0..<music_string_arr.count {\n        let note = music_string_arr[music_string_arr_index]\n\
    \        let beat_length = note.characters.count / 4\n\n        result.append(beat_length)\n\
    \    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpyu6kwh7r.swift:14:52: error: no exact matches in call to instance\
    \ method 'split'\n    let music_string_arr = music_string.characters.split(\"\
    |\")\n                                                   ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes: [Int] = Array(repeating:\
    \ 0, count: 6)\n\n    let notes_count = music_string.characters.count\n\n    for\
    \ index in 0..<notes_count {\n        let letter = music_string[index]\n\n   \
    \     if letter == \" \" {\n            notes[index] = notes[index] + 1\n    \
    \    } else {\n            notes[index] += notes[Int(letter) - 'o']\n        }\n\
    \    }\n\n    return notes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpp49oizhw.swift:22:49: error: single-quoted string literal found,\
    \ use '\"'\n            notes[index] += notes[Int(letter) - 'o']\n           \
    \                                     ^~~\n                                  \
    \              \"o\"\n/tmp/tmpp49oizhw.swift:14:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    let notes_count = music_string.characters.count\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpp49oizhw.swift:17:22: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ letter = music_string[index]\n                     ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpp49oizhw.swift:22:35:\
    \ error: no exact matches in call to initializer \n            notes[index] +=\
    \ notes[Int(letter) - 'o']\n                                  ^\n/tmp/tmpp49oizhw.swift:22:35:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \            notes[index] += notes[Int(letter) - 'o']\n                      \
    \            ^\n/tmp/tmpp49oizhw.swift:22:35: note: candidate expects value of\
    \ type 'Float' for parameter #1 (got 'Character')\n            notes[index] +=\
    \ notes[Int(letter) - 'o']\n                                  ^\n/tmp/tmpp49oizhw.swift:22:35:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \            notes[index] += notes[Int(letter) - 'o']\n                      \
    \            ^\n/tmp/tmpp49oizhw.swift:22:35: note: candidate expects value of\
    \ type 'Float80' for parameter #1 (got 'Character')\n            notes[index]\
    \ += notes[Int(letter) - 'o']\n                                  ^\n/tmp/tmpp49oizhw.swift:22:35:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n            notes[index] += notes[In"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Your code goes here\n\
    \    var music_array = music_string.characters.map{String($0)}.joined(separator:\
    \ \"\")\n    var beats_per_rest = 0\n    var rests = 0\n    var rests_array =\
    \ [Int]()\n    var rests_array = Array(0...music_array.count).map{rests}\n   \
    \ while rests_array.count != 0 {\n        rests_array.removeAll()\n        for\
    \ rest in 0..<rests {\n            if music_array[rest] == \"o\" {\n         \
    \       rests_array.append(rest)\n                rests_array.append(rest)\n \
    \               beats_per_rest += 4\n            } else {\n                rests_array.append(rest)\n\
    \                beats_per_rest += 2\n            }\n        }\n        rests\
    \ = rests_array.count\n    }\n    return rests_array\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpsez0h9ud.swift:13:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    var music_array = music_string.characters.map{String($0)}.joined(separator:\
    \ \"\")\n                                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpsez0h9ud.swift:17:55: error: contextual\
    \ type for closure argument list expects 1 argument, which cannot be implicitly\
    \ ignored\n    var rests_array = Array(0...music_array.count).map{rests}\n   \
    \                                                   ^\n                      \
    \                                 _ in \n/tmp/tmpsez0h9ud.swift:21:16: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            if music_array[rest] == \"o\" {\n               ^~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard music_string != \"\
    \" else {\n        return []\n    }\n    var last_notes = 0\n    var beats = [Int]()\n\
    \    var current_beat = 0\n    var current_note = 0\n    var note_length = 0\n\
    \    \n    for i in music_string.characters {\n        if i == 'o' {\n       \
    \     current_note = last_notes\n            note_length = 4\n        } else if\
    \ i == 'o|' {\n            current_note = last_notes\n            note_length\
    \ = 2\n        } else if i == '.|' {\n            current_note = last_notes\n\
    \            note_length = 1\n        } else {\n            note_length = -1\n\
    \        }\n        \n        if note_length != -1 {\n            beats.append(current_beat\
    \ + current_note)\n        }\n        \n        if current_note > 0 {\n      \
    \      current_note -= 1\n        } else {\n            current_beat += note_length\n\
    \        }\n        last_notes += 1\n    }\n    return beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpbtl1ifmq.swift:22:17: error: single-quoted string literal found,\
    \ use '\"'\n        if i == 'o' {\n                ^~~\n                \"o\"\n\
    /tmp/tmpbtl1ifmq.swift:25:24: error: single-quoted string literal found, use '\"\
    '\n        } else if i == 'o|' {\n                       ^~~~\n              \
    \         \"o|\"\n/tmp/tmpbtl1ifmq.swift:28:24: error: single-quoted string literal\
    \ found, use '\"'\n        } else if i == '.|' {\n                       ^~~~\n\
    \                       \".|\"\n/tmp/tmpbtl1ifmq.swift:21:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    for i in music_string.characters\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbtl1ifmq.swift:25:21: error: binary operator '==' cannot\
    \ be applied to operands of type 'Character' and 'String'\n        } else if i\
    \ == 'o|' {\n                  ~ ^  ~~~~\n/tmp/tmpbtl1ifmq.swift:25:21: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        } else if i == 'o|' {\n              \
    \      ^\n/tmp/tmpbtl1ifmq.swift:28:21: error: binary operator '==' cannot be\
    \ applied to operands of type 'Character' and 'String'\n        } else if i ==\
    \ '.|' {\n                  ~ ^  ~~~~\n/tmp/tmpbtl1ifmq.swift:28:21: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        } else if i == '.|' {\n                    ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var chord = [Int]()\n \
    \   var temp = [Int]()\n    var current_beat = 0\n    var current_beat_tonality\
    \ = 0\n\n    for current_char in music_string {\n        let note = note_from_string(current_char)\n\
    \n        if note != nil {\n            temp.append(note!)\n            if note!.tonality\
    \ == 0 {\n                current_beat_tonality = 0\n            } else {\n  \
    \              current_beat_tonality = 1\n            }\n        }\n\n       \
    \ if note_from_string(current_char) != nil {\n            temp.append(note_from_string(current_char)!)\n\
    \            if note_from_string(current_char)!.tonality == 0 {\n            \
    \    current_beat_tonality = 0\n            } else {\n                current_beat_tonality\
    \ = 1\n            }\n        }\n\n        if note == nil || note_from_string(current_char)\
    \ == nil {\n            if current_beat_tonality == 1 {\n                chord.append(temp[current_beat])\n\
    \                temp.removeLast()\n                current_beat += 1\n      \
    \          current_beat_tonality = 0\n            } else {\n                chord.append(temp[current_beat])\n\
    \                temp.removeLast()\n                current_beat += 1\n      \
    \          current_beat_tonality = 1\n            }\n        }\n    }\n    \n\
    \    chord.append(temp[current_beat])\n    temp.removeLast()\n\n    return chord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpv79yroad.swift:18:20: error: cannot find 'note_from_string' in\
    \ scope\n        let note = note_from_string(current_char)\n                 \
    \  ^~~~~~~~~~~~~~~~\n/tmp/tmpv79yroad.swift:29:12: error: cannot find 'note_from_string'\
    \ in scope\n        if note_from_string(current_char) != nil {\n           ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpv79yroad.swift:30:25: error: cannot find 'note_from_string' in scope\n\
    \            temp.append(note_from_string(current_char)!)\n                  \
    \      ^~~~~~~~~~~~~~~~\n/tmp/tmpv79yroad.swift:31:16: error: cannot find 'note_from_string'\
    \ in scope\n            if note_from_string(current_char)!.tonality == 0 {\n \
    \              ^~~~~~~~~~~~~~~~\n/tmp/tmpv79yroad.swift:38:27: error: cannot find\
    \ 'note_from_string' in scope\n        if note == nil || note_from_string(current_char)\
    \ == nil {\n                          ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string\n \
    \       .split(separator: \"|\")\n        .flatMap{ $0.split(separator: \" \"\
    ).map({ Int($0) }) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpli4srvcl.swift:14:50: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        .flatMap{ $0.split(separator:\
    \ \" \").map({ Int($0) }) }\n                                                \
    \ ^\n/tmp/tmpli4srvcl.swift:14:50: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        .flatMap{ $0.split(separator:\
    \ \" \").map({ Int($0) }) }\n                                                \
    \ ^\n                                                         ?? <#default value#>\n\
    /tmp/tmpli4srvcl.swift:14:50: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        .flatMap{ $0.split(separator:\
    \ \" \").map({ Int($0) }) }\n                                                \
    \ ^\n                                                        !\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.scan(note_pattern,\
    \ matching: note_occurrences).map { $0.count }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpi_7ogtrp.swift:12:30: error: cannot find 'note_pattern' in scope\n\
    \    return music_string.scan(note_pattern, matching: note_occurrences).map {\
    \ $0.count }\n                             ^~~~~~~~~~~~\n/tmp/tmpi_7ogtrp.swift:12:54:\
    \ error: cannot find 'note_occurrences' in scope\n    return music_string.scan(note_pattern,\
    \ matching: note_occurrences).map { $0.count }\n                             \
    \                        ^~~~~~~~~~~~~~~~\n/tmp/tmpi_7ogtrp.swift:12:25: error:\
    \ value of type 'String' has no member 'scan'\n    return music_string.scan(note_pattern,\
    \ matching: note_occurrences).map { $0.count }\n           ~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Your code here\n   \
    \ let array = music_string.components(separatedBy: \" \")\n    var beats = [Int]()\n\
    \    beats.reserveCapacity(array.count)\n    for music_element in array {\n  \
    \      if music_element == \"o\" {\n            beats.append(4)\n        } else\
    \ if music_element == \"o|\" {\n            beats.append(2)\n        } else if\
    \ music_element == \".|\" {\n            beats.append(1)\n        } else {\n \
    \           let music_note_index = Int(music_element) - 1\n            beats.append(beats[music_note_index]\
    \ + 1)\n        }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpaakw763i.swift:13:30: error: value of type 'String' has no member\
    \ 'components'\n    let array = music_string.components(separatedBy: \" \")\n\
    \                ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Your code here\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: '/tmp/tmph6u5sabr.swift:13:1: error: missing return in global function expected
    to return ''[Int]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let regex = try! NSRegularExpression(pattern:\
    \ \"^([.o]|[.|o|])$\")\n    let results = regex.matches(in: music_string, range:\
    \ NSRange(location: 0, length: music_string.count))\n    return results.map({\
    \ result -> Int in\n        guard let range = result.range, let firstChar = music_string.substring(with:\
    \ range).first\n        else { return 0 }\n        switch firstChar {\n      \
    \  case \"o\": return 4\n        case \"|\": return 2\n        default: return\
    \ 1\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp6glsjwto.swift:12:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"^([.o]|[.|o|])$\"\
    )\n                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6glsjwto.swift:13:58: error:\
    \ cannot find 'NSRange' in scope\n    let results = regex.matches(in: music_string,\
    \ range: NSRange(location: 0, length: music_string.count))\n                 \
    \                                        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   let notes = music_string.split(separator: \" \").map(String.init)\n    for\
    \ note in notes {\n        if note.hasPrefix(\"o\") {\n            beats.append(4)\n\
    \        } else if note.hasPrefix(\"o|\") {\n            beats.append(2)\n   \
    \     } else if note.hasPrefix(\".|\") {\n            beats.append(1)\n      \
    \  } else {\n            beats.append(0)\n        }\n    }\n    return beats\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpjx8e0ft9/tmpjx8e0ft9.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2e43a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2e409fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2e409f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2e409e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjx8e0ft9                        0x000055e9a1e61cc1 <unavailable> + 7361

    5    libc.so.6                          0x00002ac2e4594460 __libc_start_main +
    245

    6    tmpjx8e0ft9                        0x000055e9a1e61579 <unavailable> + 5497

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard music_string.count\
    \ != 0 else {\n        return []\n    }\n\n    var notes = [Int]()\n\n    for\
    \ note in music_string.unicodeScalars {\n        switch note {\n        case \"\
    o\":\n            notes.append(4)\n        case \"o|\":\n            notes.append(2)\n\
    \        case \".|\":\n            notes.append(1)\n        default:\n       \
    \     break\n        }\n    }\n\n    return notes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpe8rk9cda.swift:22:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Unicode.Scalar'\n        case \"o|\":\n       \
    \      ^~~~\n/tmp/tmpe8rk9cda.swift:24:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Unicode.Scalar'\n        case \".|\":\n       \
    \      ^~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    music_string += \"|\"\n\
    \    music_string += \"|\"\n    music_string += \"|\"\n    music_string += \"\
    |\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string +=\
    \ \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n    music_string += \"|\"\n    music_string += \"|\"\n    music_string\
    \ += \"|\"\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmph_8feuh1.swift:12:18: error: left side of mutating operator isn't\
    \ mutable: 'music_string' is a 'let' constant\n    music_string += \"|\"\n   \
    \ ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:13:18: error: left side of mutating operator\
    \ isn't mutable: 'music_string' is a 'let' constant\n    music_string += \"|\"\
    \n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:14:18: error: left side of mutating\
    \ operator isn't mutable: 'music_string' is a 'let' constant\n    music_string\
    \ += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:15:18: error: left side\
    \ of mutating operator isn't mutable: 'music_string' is a 'let' constant\n   \
    \ music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:16:18: error:\
    \ left side of mutating operator isn't mutable: 'music_string' is a 'let' constant\n\
    \    music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:17:18:\
    \ error: left side of mutating operator isn't mutable: 'music_string' is a 'let'\
    \ constant\n    music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:18:18:\
    \ error: left side of mutating operator isn't mutable: 'music_string' is a 'let'\
    \ constant\n    music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:19:18:\
    \ error: left side of mutating operator isn't mutable: 'music_string' is a 'let'\
    \ constant\n    music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:20:18:\
    \ error: left side of mutating operator isn't mutable: 'music_string' is a 'let'\
    \ constant\n    music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:21:18:\
    \ error: left side of mutating operator isn't mutable: 'music_string' is a 'let'\
    \ constant\n    music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:22:18:\
    \ error: left side of mutating operator isn't mutable: 'music_string' is a 'let'\
    \ constant\n    music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:23:18:\
    \ error: left side of mutating operator isn't mutable: 'music_string' is a 'let'\
    \ constant\n    music_string += \"|\"\n    ~~~~~~~~~~~~ ^\n/tmp/tmph_8feuh1.swift:24:18:\
    \ error: left side of mutating operator isn't mutable: 'music_string' is a 'let'\
    \ constan"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    // write your code\
    \ here\n    let music_array = music_string.split(\" \").map{String($0)}\n    var\
    \ result = [Int]()\n    for i in 0..<music_array.count{\n        let char = String(music_array[i])\n\
    \        if char == \"o\" {\n            result.append(4)\n        }else if char\
    \ == \"o|\" {\n            result.append(2)\n        }else if char == \".|\" {\n\
    \            result.append(1)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmppjy_dmhd.swift:14:36: error: no exact matches in call to instance\
    \ method 'split'\n    let music_array = music_string.split(\" \").map{String($0)}\n\
    \                                   ^\nSwift.Sequence:2:40: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable public\
    \ __consuming func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result: [Int] = [0]\n\
    \    for i in 1...music_string.characters.count {\n        switch music_string.characters[i-1]\
    \ {\n        case \"o\":\n            result.append(4)\n        case \"|\":\n\
    \            result.append(2)\n        case \".\":\n            result.append(1)\n\
    \        default:\n            result.append(0)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp_pfvmfrv.swift:13:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 1...music_string.characters.count {\n    \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp_pfvmfrv.swift:14:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        switch\
    \ music_string.characters[i-1] {\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp_pfvmfrv.swift:14:29:\
    \ error: 'characters' is unavailable: Please use String directly\n        switch\
    \ music_string.characters[i-1] {\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard let music_notes =\
    \ music_string.characters.split(\" \").map(String.init) else { return [] }\n \
    \   return music_notes.filter { note in\n        note.characters.count == 1\n\
    \    }.map { note in\n        guard let index = note.index(of: \"|\") else {\n\
    \            throw Exception.music(reason: \"No | in note - \\(note)\")\n    \
    \    }\n        return Int(note[index + 1..<note.count])\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp69lduzma.swift:12:53: error: no exact matches in call to instance\
    \ method 'split'\n    guard let music_notes = music_string.characters.split(\"\
    \ \").map(String.init) else { return [] }\n                                  \
    \                  ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmp69lduzma.swift:17:19:\
    \ error: cannot find 'Exception' in scope\n            throw Exception.music(reason:\
    \ \"No | in note - \\(note)\")\n                  ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard music_string.count\
    \ > 0 else {\n        return []\n    }\n    \n    var beats: [Int] = [0, 0, 0,\
    \ 0, 0, 0, 0, 0]\n    \n    let notes = \"o|.\".components(separatedBy: \"|\"\
    )\n    \n    for (i, note) in notes.enumerated() {\n        \n        let splitted_note\
    \ = note.split(separator: \" \")\n        \n        var beats_counter = 0\n  \
    \      \n        for (_, char) in splitted_note.enumerated() {\n            let\
    \ index = splitted_note.index(of: char)\n            if index == splitted_note.count\
    \ - 1 {\n                beats_counter += 1\n                splitted_note.remove(at:\
    \ index)\n            } else {\n                beats_counter += index\n     \
    \       }\n        }\n        beats[i] += beats_counter\n    }\n    \n    return\
    \ beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpp_tv1xk7.swift:18:23: error: value of type 'String' has no member\
    \ 'components'\n    let notes = \"o|.\".components(separatedBy: \"|\")\n     \
    \           ~~~~~ ^~~~~~~~~~\n/tmp/tmpp_tv1xk7.swift:26:9: error: failed to produce\
    \ diagnostic for expression; please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n        for (_, char) in splitted_note.enumerated()\
    \ {\n        ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [Int] = []\n\
    \    var beats_counter: [Int] = [0]\n\n    let music_string = music_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    var music_notes: [String] = []\n\n\
    \    for music_note in music_string.components(separatedBy: \" \") {\n       \
    \ let music_note = music_note.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \        if music_note != \"\" {\n            music_notes.append(music_note)\n\
    \        }\n    }\n\n    for music_note in music_notes {\n        var music_note_index\
    \ = -1\n        var music_note_length = -1\n\n        for note_index in 0..<music_note.characters.count\
    \ {\n            guard note_index < music_note.characters.count - 1, music_note[note_index]\
    \ == \".\" else {\n                continue\n            }\n\n            music_note_index\
    \ += 1\n            music_note_length += 1\n\n            if music_note_index\
    \ < music_note.characters.count {\n                if music_note[music_note_index\
    \ + 1] == \"|\" {\n                    beats_counter[music_note_length] += 1\n\
    \                }\n            }\n        }\n\n        if beats_counter[music_note_length]\
    \ == 4 {\n            beats.append(4)\n            beats_counter[music_note_length]\
    \ = 0\n        } else {\n            beats.append(beats_counter[music_note_length])\n\
    \            beats_counter[music_note_length] = 0\n        }\n    }\n\n    return\
    \ beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp0kcsz2w8.swift:15:60: error: cannot find 'CharacterSet' in scope\n\
    \    let music_string = music_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                                           ^~~~~~~~~~~~\n/tmp/tmp0kcsz2w8.swift:15:37:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let music_string\
    \ = music_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp0kcsz2w8.swift:29:42:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ note_index in 0..<music_note.characters.count {\n                          \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp0kcsz2w8.swift:30:43: error: 'characters' is unavailable: Please\
    \ use String directly\n            guard note_index < music_note.characters.count\
    \ - 1, music_note[note_index] == \".\" else {\n                              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp0kcsz2w8.swift:30:65: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n            guard note_index\
    \ < music_note.characters.count - 1, music_note[note_index] == \".\" else {\n\
    \                                                                ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp0kcsz2w8.swift:37:46:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if music_note_index < music_note.characters.count {\n                      \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp0kcsz2w8.swift:38:20: error: 'subs"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    if music_string == \"\"\
    \ {\n        return [0]\n    }\n    var beats = [Int]()\n    var notes = [Int]()\n\
    \    var i = 0\n    var current_note = 0\n    var current_beat = 0\n    var notes_count\
    \ = 0\n    while i < music_string.count {\n        let letter = music_string[i]\n\
    \        if letter != \".\" {\n            notes.append(letter)\n            i\
    \ += 1\n        }\n        else if letter == \".\" {\n            notes_count\
    \ = 1\n            i += 1\n            current_note += 1\n            beats.append(current_beat)\n\
    \        }\n        else if letter == \"|\" {\n            notes_count += 1\n\
    \            current_note += 1\n            current_beat += 1\n            i +=\
    \ 1\n        }\n        else if letter == \"o\" {\n            notes_count = 1\n\
    \            i += 1\n            current_note += 1\n            beats.append(current_beat)\n\
    \        }\n        else if letter == \"|\" {\n            notes_count -= 1\n\
    \            current_note += 1\n            beats.append(current_beat)\n     \
    \   }\n        else {\n            notes_count += 1\n            beats.append(current_beat)\n\
    \        }\n    }\n    notes.append(notes_count) // end of note\n    if notes_count\
    \ > 0 {\n        print(\"ERROR: Unbalanced notes!\\n\")\n        return nil\n\
    \    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpwn7qfjcu.swift:22:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let letter\
    \ = music_string[i]\n                     ^~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwn7qfjcu.swift:24:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \            notes.append(letter)\n                         ^\n/tmp/tmpwn7qfjcu.swift:58:16:\
    \ error: 'nil' is incompatible with return type '[Int]'\n        return nil\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard music_string.count\
    \ > 0 else {\n        return []\n    }\n\n    // If string only contains dot or\
    \ space then return empty array as notes are not played anyway.\n    guard music_string[0]\
    \ != '.' || music_string[0] == ' ' else {\n        return []\n    }\n\n    //\
    \ If string contains more than 3 dots then return empty array as notes are not\
    \ played anyway.\n    guard music_string.count - 1 < 3 else {\n        return\
    \ []\n    }\n\n    // Get a copy of input string and remove first character.\n\
    \    var music_copy = music_string.copy(count: music_string.count - 1)\n\n   \
    \ // Parse string to determine if note is a whole note, half or quater.\n    if\
    \ let index = music_copy.firstIndex(of: \" \") {\n        // If first character\
    \ is a space then it is half note, otherwise it is whole note.\n        let note_is_half\
    \ = music_copy[index] == ' '\n        music_copy.removeFirst()\n        guard\
    \ note_is_half else { return [] }\n    }\n\n    // Remove dots at end of string.\n\
    \    if let index = music_copy.lastIndex(of: \".\") {\n        music_copy.removeLast()\n\
    \        music_copy.removeLast()\n    }\n\n    // If there are any more characters\
    \ after last space then return empty array as notes are not played anyway.\n \
    \   guard music_copy.count > 0 else {\n        return []\n    }\n\n    // If there\
    \ are no notes then return empty array.\n    var music_array = music_copy.split(separator:\
    \ \" \")\n\n    // Return empty array if note is single or double dotted or double\
    \ space\n    if music_array.count == 1 {\n        return [0]\n    } else if music_array.count\
    \ == 2 {\n        return [music_array[1]]\n    } else {\n        return [music_array[1],\
    \ music_array[4]]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp6fyr5lnk.swift:17:30: error: single-quoted string literal found,\
    \ use '\"'\n    guard music_string[0] != '.' || music_string[0] == ' ' else {\n\
    \                             ^~~\n                             \".\"\n/tmp/tmp6fyr5lnk.swift:17:56:\
    \ error: single-quoted string literal found, use '\"'\n    guard music_string[0]\
    \ != '.' || music_string[0] == ' ' else {\n                                  \
    \                     ^~~\n                                                  \
    \     \" \"\n/tmp/tmp6fyr5lnk.swift:32:49: error: single-quoted string literal\
    \ found, use '\"'\n        let note_is_half = music_copy[index] == ' '\n     \
    \                                           ^~~\n                            \
    \                    \" \"\n/tmp/tmp6fyr5lnk.swift:17:11: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    guard music_string[0] != '.' || music_string[0] == ' ' else {\n         \
    \ ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp6fyr5lnk.swift:17:37: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    guard\
    \ music_string[0] != '.' || music_string[0] == ' ' else {\n                  \
    \                  ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp6fyr5lnk.swift:27:35: error: value of type 'String'\
    \ has no member 'copy'\n    var music_copy = music_string.copy(count: music_string.count\
    \ - 1)\n                     ~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [0] * 12\n\
    \    var last_beat = [Int](repeating: 0, count: 4)\n    let notes: [[Int]] = [[\"\
    o\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"\
    o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"],\
    \ [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"\
    ], [\"o|\", \"o|\", \"|.|\"]]\n    \n    for note in notes {\n        if music_string.contains(note[0])\
    \ {\n            for index in 0..<note.count {\n                if index == note.count\
    \ - 1 {\n                    beats[note[index] - 48] += last_beat[index]\n   \
    \             } else {\n                    beats[note[index] - 48] += 1\n   \
    \             }\n                last_beat[index] += 1\n            }\n      \
    \  }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpz98aqjon.swift:12:21: error: binary operator '*' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n    var beats = [0] * 12\n          \
    \      ~~~ ^ ~~\n/tmp/tmpz98aqjon.swift:12:21: note: overloads for '*' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    var beats = [0] *\
    \ 12\n                    ^\n/tmp/tmpz98aqjon.swift:14:28: error: cannot convert\
    \ value of type 'String' to expected element type 'Int'\n    let notes: [[Int]]\
    \ = [[\"o\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"\
    |.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\"\
    , \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"\
    o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"]]\n                           ^\n/tmp/tmpz98aqjon.swift:14:33:\
    \ error: cannot convert value of type 'String' to expected element type 'Int'\n\
    \    let notes: [[Int]] = [[\"o\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"\
    ], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"\
    ], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"\
    ], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"]]\n                   \
    \             ^\n/tmp/tmpz98aqjon.swift:14:39: error: cannot convert value of\
    \ type 'String' to expected element type 'Int'\n    let notes: [[Int]] = [[\"\
    o\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"\
    o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"],\
    \ [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"\
    ], [\"o|\", \"o|\", \"|.|\"]]\n                                      ^\n/tmp/tmpz98aqjon.swift:14:48:\
    \ error: cannot convert value of type 'String' to expected element type 'Int'\n\
    \    let notes: [[Int]] = [[\"o\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"\
    ], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"\
    ], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"\
    ], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"]]\n                   \
    \                            ^\n/tmp/tmpz98aqjon.swift:14:54: error: cannot convert\
    \ value of type 'String' to expected element type 'Int'\n    let notes: [[Int]]\
    \ = [[\"o\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"|.|\"], [\"o|\", \"o|\", \"\
    |.|\"], [\"o|\", \"o|"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard music_string.characters.count\
    \ == 24 else { return [Int]() }\n    guard let music_string = music_string.substringToIndex(advance(music_string.startIndex,\
    \ 2)) else { return [Int]() }\n    let music_string = music_string.substringFromIndex(advance(music_string.startIndex,\
    \ 2))\n    let mut music_notes = music.split(music_string)\n    let mut result\
    \ = [Int]()\n    for note in music_notes {\n        guard let note = Int(note,\
    \ radix: 16) else { return [Int]() }\n        if note >= 1 && note <= 7 {\n  \
    \          result.append(note - 1)\n        }\n    }\n    result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp1dxklswd.swift:15:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut music_notes\
    \ = music.split(music_string)\n            ^\n/tmp/tmp1dxklswd.swift:15:13: note:\
    \ join the identifiers together\n    let mut music_notes = music.split(music_string)\n\
    \        ~~~~^~~~~~~~~~~\n        mutmusic_notes\n/tmp/tmp1dxklswd.swift:15:13:\
    \ note: join the identifiers together with camel-case\n    let mut music_notes\
    \ = music.split(music_string)\n        ~~~~^~~~~~~~~~~\n        mutMusic_notes\n\
    /tmp/tmp1dxklswd.swift:16:13: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n    let mut result = [Int]()\n\
    \            ^\n/tmp/tmp1dxklswd.swift:16:13: note: join the identifiers together\n\
    \    let mut result = [Int]()\n        ~~~~^~~~~~\n        mutresult\n/tmp/tmp1dxklswd.swift:16:13:\
    \ note: join the identifiers together with camel-case\n    let mut result = [Int]()\n\
    \        ~~~~^~~~~~\n        mutResult\n/tmp/tmp1dxklswd.swift:12:24: error: 'characters'\
    \ is unavailable: Please use String directly\n    guard music_string.characters.count\
    \ == 24 else { return [Int]() }\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp1dxklswd.swift:13:60: error: cannot find\
    \ 'advance' in scope\n    guard let music_string = music_string.substringToIndex(advance(music_string.startIndex,\
    \ 2)) else { return [Int]() }\n                                              \
    \             ^~~~~~~\n/tmp/tmp1dxklswd.swift:13:43: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    guard let music_string = music_string.substringToIndex(advance(music_string.startIndex,\
    \ 2)) else { return [Int]() }\n                             ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp1dxklswd.swift:14:56: error: cannot find 'advance' in scope\n    let music_string\
    \ = music_string.substringFromIndex(advance(music_string.startIndex, 2))\n   \
    \                                      "
  stdout: ''
  timestamp: 1660014141
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // TODO: replace with regex\
    \ or something better than a naive split\n    return music_string.split(separator:\
    \ \"o|.|\").map {\n        switch $0 {\n        case \"o\":\n            return\
    \ 4\n        case \"o|\":\n            return 2\n        default:\n          \
    \  return 1\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpvm0o04e7/tmpvm0o04e7.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af709cd5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7099ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7099cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7099cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm0o04e7                        0x000055c11101d7df <unavailable> + 6111

    5    libc.so.6                          0x00002af709ec1460 __libc_start_main +
    245

    6    tmpvm0o04e7                        0x000055c11101d319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var output: [Int] = []\n\
    \    music_string.split(separator: \"|\").forEach { note in\n        if note.contains(\"\
    o\") {\n            note = note.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \"o\"))\n            note = \"o\".distance(from: note)\n        }\n        switch\
    \ note.lowercased() {\n        case \"o\":\n            output.append(4)\n   \
    \     case \"o|\":\n            output.append(2)\n        case \".|\":\n     \
    \       output.append(1)\n        default:\n            fatalError(\"Unexpected\
    \ note \\($note)\")\n        }\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpg2n3zmou.swift:15:48: error: cannot find 'CharacterSet' in scope\n\
    \            note = note.trimmingCharacters(in: CharacterSet(charactersIn: \"\
    o\"))\n                                               ^~~~~~~~~~~~\n/tmp/tmpg2n3zmou.swift:26:43:\
    \ error: cannot find '$note' in scope\n            fatalError(\"Unexpected note\
    \ \\($note)\")\n                                          ^~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // TODO: return early\n\
    \    if music_string == \"\" {\n        return []\n    }\n\n    var beats_count\
    \ = [0] * 12\n\n    for char in music_string {\n        let note_beats = notes_to_beats[char]\n\
    \        beats_count[note_beats] += 1\n    }\n\n    return beats_count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpif_z0jqq.swift:17:27: error: binary operator '*' cannot be applied\
    \ to operands of type '[Int]' and 'Int'\n    var beats_count = [0] * 12\n    \
    \                  ~~~ ^ ~~\n/tmp/tmpif_z0jqq.swift:17:27: note: overloads for\
    \ '*' exist with these partially matching parameter lists: (Int, Int)\n    var\
    \ beats_count = [0] * 12\n                          ^\n/tmp/tmpif_z0jqq.swift:20:26:\
    \ error: cannot find 'notes_to_beats' in scope\n        let note_beats = notes_to_beats[char]\n\
    \                         ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // TODO: implement this\
    \ function\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpd6jnu5vj/tmpd6jnu5vj.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0aaacb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0aaa9adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0aaa9ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0aaa9ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd6jnu5vj                        0x000055df3bee551f <unavailable> + 5407

    5    libc.so.6                          0x00002b0aaaea2460 __libc_start_main +
    245

    6    tmpd6jnu5vj                        0x000055df3bee5059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   for note in music_string {\n        if note == \"o\" {\n            beats.append(4)\n\
    \        } else if note == \"o|\" {\n            beats.append(2)\n        } else\
    \ if note == \".|\" {\n            beats.append(1)\n        } else {\n       \
    \     let beats_in_note = note.characters.count\n            beats.append(beats_in_note)\n\
    \        }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp0joqrsq9.swift:16:24: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        } else if note == \"o|\"\
    \ {\n                  ~~~~ ^  ~~~~\n/tmp/tmp0joqrsq9.swift:16:24: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        } else if note == \"o|\" {\n                     \
    \  ^\n/tmp/tmp0joqrsq9.swift:18:24: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        } else if note == \".|\"\
    \ {\n                  ~~~~ ^  ~~~~\n/tmp/tmp0joqrsq9.swift:18:24: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        } else if note == \".|\" {\n                     \
    \  ^\n/tmp/tmp0joqrsq9.swift:21:38: error: value of type 'Character' has no member\
    \ 'characters'\n            let beats_in_note = note.characters.count\n      \
    \                          ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   var last = 0\n    for _ in 0..<(music_string.count - 1) {\n        let symbol\
    \ = music_string[last]\n        if symbol == \"o\" {\n            beats.append(4)\n\
    \            last = last + 1\n        } else if symbol == \"o|\" {\n         \
    \   beats.append(2)\n            last = last + 1\n        } else if symbol ==\
    \ \".|\" {\n            beats.append(1)\n            last = last + 1\n       \
    \ } else {\n            fatalError(\"unknown music symbol \\(symbol)\")\n    \
    \    }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp3wa0t_2r.swift:15:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let symbol\
    \ = music_string[last]\n                     ^~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3wa0t_2r.swift:19:26:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        } else if symbol == \"o|\" {\n                  ~~~~~~\
    \ ^  ~~~~\n/tmp/tmp3wa0t_2r.swift:19:26: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (String, String)\n\
    \        } else if symbol == \"o|\" {\n                         ^\n/tmp/tmp3wa0t_2r.swift:22:26:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        } else if symbol == \".|\" {\n                  ~~~~~~\
    \ ^  ~~~~\n/tmp/tmp3wa0t_2r.swift:22:26: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (String, String)\n\
    \        } else if symbol == \".|\" {\n                         ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.split(separator:\
    \ \" \").map{String($0)}\n\n    var sum = [Int]()\n\n    for note in notes {\n\
    \        let beats = note.count - note.count % 4\n        sum += [Int](repeating:\
    \ beats, count: note.count)\n    }\n\n    return sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpjs1yexdv/tmpjs1yexdv.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4e34f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4e31edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4e31ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4e31ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjs1yexdv                        0x000055c46f958b2f <unavailable> + 6959

    5    libc.so.6                          0x00002ab4e36e2460 __libc_start_main +
    245

    6    tmpjs1yexdv                        0x000055c46f958669 <unavailable> + 5737

    '
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var last = 0\n    var beats\
    \ = [0]\n    for c in music_string {\n        let note = c\n        if note ==\
    \ \".\" {\n            beats[last] = 1\n            last = 0\n        } else if\
    \ note == \"o\" {\n            beats[last] = 4\n            last = 1\n       \
    \ } else {\n            beats[last] += 1\n            last = 0\n        }\n  \
    \  }\n\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmp59oos1k0/tmp59oos1k0.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d94febc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d94ce2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d94ce2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d94ce17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp59oos1k0                        0x000055ccd11a260e <unavailable> + 5646

    5    libc.so.6                          0x00002b3d951d7460 __libc_start_main +
    245

    6    tmp59oos1k0                        0x000055ccd11a2259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_per_beats = [Int]()\n\
    \    var beats_played = 0\n    var notes = music_string.split(\" \")\n    for\
    \ note in notes {\n        var beats = note.countElements() - 1\n        if note.contains(\"\
    o|\") {\n            beats = 2\n        } else if note.contains(\".|\") {\n  \
    \          beats = 1\n        }\n        beats_per_beats.append(beats)\n     \
    \   beats_played += beats\n    }\n    return beats_per_beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpt1f29uhb.swift:14:30: error: no exact matches in call to instance\
    \ method 'split'\n    var notes = music_string.split(\" \")\n                \
    \             ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let note_strings = music_string.components(separatedBy:\
    \ \" \") // Separate string by space\n    var note_counts: [Int] = []\n    for\
    \ note_string in note_strings {\n        if note_string == \"o\" {\n         \
    \   note_counts.append(1)\n        } else if note_string == \"o|\" {\n       \
    \     note_counts.append(2)\n        } else if note_string == \".|\" {\n     \
    \       note_counts.append(1)\n        } else {\n            note_counts.append(0)\n\
    \        }\n    }\n    return note_counts\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp2175n68j.swift:12:37: error: value of type 'String' has no member\
    \ 'components'\n    let note_strings = music_string.components(separatedBy: \"\
    \ \") // Separate string by space\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [[Int]] = []\n\
    \n    for char in music_string {\n        var beat: Int = 0\n\n        switch\
    \ char {\n        case \"o\": beat = 4; break\n        case \"o|\": beat = 2;\
    \ break\n        case \".|\": beat = 1; break\n        default: continue\n   \
    \     }\n\n        beats.append(beat)\n    }\n\n    return beats\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpnjq0_cwh.swift:19:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\": beat = 2; break\n\
    \             ^~~~\n/tmp/tmpnjq0_cwh.swift:20:14: error: expression pattern of\
    \ type 'String' cannot match values of type 'Character'\n        case \".|\":\
    \ beat = 1; break\n             ^~~~\n/tmp/tmpnjq0_cwh.swift:24:22: error: cannot\
    \ convert value of type 'Int' to expected argument type '[Int]'\n        beats.append(beat)\n\
    \                     ^\n/tmp/tmpnjq0_cwh.swift:27:12: error: cannot convert return\
    \ expression of type '[[Int]]' to return type '[Int]'\n    return beats\n    \
    \       ^\n/tmp/tmpnjq0_cwh.swift:27:12: note: arguments to generic parameter\
    \ 'Element' ('[Int]' and 'Int') are expected to be equal\n    return beats\n \
    \          ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard let music_notes =\
    \ music_string.split(separator: \" \").map(String.init) else {\n        return\
    \ []\n    }\n    var beats = 0\n    var notes: [Int] = [0]\n\n    for music_note\
    \ in music_notes {\n        if music_note == \"o\" {\n            beats = 0\n\
    \            notes.append(1)\n        } else if music_note.count > 1 && (music_note[0]\
    \ != \"o\" || music_note[1] == \"|\") {\n            beats += (music_note.count\
    \ - 1) / 2\n            notes.append(beats)\n        } else {\n            beats\
    \ += 1\n            notes.append(beats)\n        }\n    }\n\n    return notes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp01fce2fc.swift:12:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String]'\n    guard let music_notes = music_string.split(separator:\
    \ \" \").map(String.init) else {\n          ^                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp01fce2fc.swift:22:44: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        } else if music_note.count\
    \ > 1 && (music_note[0] != \"o\" || music_note[1] == \"|\") {\n              \
    \                             ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp01fce2fc.swift:22:68: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if music_note.count > 1 && (music_note[0] != \"o\" || music_note[1]\
    \ == \"|\") {\n                                                              \
    \     ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.characters.split(separator:\
    \ \"|\")\n    var output = [Int]()\n\n    for note in notes {\n        if note\
    \ == \"o\" {\n            output.append(4)\n        } else if note == \"o|\" {\n\
    \            output.append(2)\n        } else if note == \".\" {\n           \
    \ output.append(1)\n        } else {\n            fatalError(\"Unknown note\"\
    )\n        }\n    }\n\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp5vlcs07i.swift:12:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let notes = music_string.characters.split(separator:\
    \ \"|\")\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // your code here\n   \
    \ \n    var beat = 0\n    var note = 0\n    var note_count = 0\n    var note_size\
    \ = 0\n    var note_last = 0\n    var music_notes = [Int]()\n    var music_notes_len\
    \ = 0\n    \n    if let music_note = music_string.unicodeScalars {\n        music_notes_len\
    \ = music_note.count\n        \n        if music_notes_len > 0 {\n           \
    \ note = music_note[0].value - 49\n            note_count = music_note[0].value\
    \ - 49\n            beat = 0\n            \n            while note_count > 0 {\n\
    \                if note % 4 == 0 {\n                    beat = beat + Int(note_count)\n\
    \                    note_count = 0\n                }\n                note =\
    \ note + 4\n                note_count = note_count - 1\n            }\n     \
    \       \n            if note != 0 {\n                music_notes.append(note)\n\
    \                music_notes_len = music_notes_len + 1\n            }\n      \
    \  }\n    }\n    \n    return music_notes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpugbrz02w.swift:26:40: error: cannot assign value of type 'UInt32'\
    \ to type 'Int'\n            note = music_note[0].value - 49\n               \
    \    ~~~~~~~~~~~~~~~~~~~~^~~~\n                   Int(                    )\n\
    /tmp/tmpugbrz02w.swift:26:31: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.UnicodeScalarView.Index' (aka 'String.Index')\n      \
    \      note = music_note[0].value - 49\n                              ^\n/tmp/tmpugbrz02w.swift:27:46:\
    \ error: cannot assign value of type 'UInt32' to type 'Int'\n            note_count\
    \ = music_note[0].value - 49\n                         ~~~~~~~~~~~~~~~~~~~~^~~~\n\
    \                         Int(                    )\n/tmp/tmpugbrz02w.swift:27:37:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.UnicodeScalarView.Index'\
    \ (aka 'String.Index')\n            note_count = music_note[0].value - 49\n  \
    \                                  ^\n/tmp/tmpugbrz02w.swift:22:8: error: initializer\
    \ for conditional binding must have Optional type, not 'String.UnicodeScalarView'\n\
    \    if let music_note = music_string.unicodeScalars {\n       ^             \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result: [Int] = []\n\
    \n    // TODO: write your code\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpjcbca7_0/tmpjcbca7_0.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97679f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97676e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97676e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97676e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjcbca7_0                        0x00005574f03da51f <unavailable> + 5407

    5    libc.so.6                          0x00002b9767bdd460 __libc_start_main +
    245

    6    tmpjcbca7_0                        0x00005574f03da059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.characters.split{$0\
    \ == \"o\"}.map(String.init)\n\n    var notes_beats = [Int]()\n    for note in\
    \ notes {\n        if note == \"o\" {\n            notes_beats += [4, 4]\n   \
    \     } else if note == \"o|\" {\n            notes_beats += [2, 2]\n        }\
    \ else if note == \".|\" {\n            notes_beats += [1]\n        } else {\n\
    \            fatalError(\"Unknown note\")\n        }\n    }\n\n    return notes_beats\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp8cs5di2o.swift:12:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let notes = music_string.characters.split{$0 == \"\
    o\"}.map(String.init)\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = 0\n    var\
    \ notes: [Int] = []\n    for c in music_string {\n        switch c {\n       \
    \ case \"o\":\n            notes.append(4)\n        case \"o|\":\n           \
    \ notes.append(2)\n        case \".|\":\n            notes.append(1)\n       \
    \ default:\n            notes.append(0)\n        }\n        beats += notes.last!\n\
    \        notes.remove(at: notes.count - 1)\n    }\n    return beats\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp0xl_vpsl.swift:18:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n/tmp/tmp0xl_vpsl.swift:20:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \".|\":\n            \
    \ ^~~~\n/tmp/tmp0xl_vpsl.swift:28:12: error: cannot convert return expression\
    \ of type 'Int' to return type '[Int]'\n    return beats\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_to_beat = [Int]()\n\
    \n    music_string = music_string.trim()\n    if music_string.isEmpty {\n    \
    \    return beats_to_beat\n    }\n\n    var i = 0\n    for character in music_string\
    \ {\n        if character == \"o\" {\n            beats_to_beat.append(i)\n  \
    \          i += 1\n        } else if character == \"o|\" {\n            i += 4\n\
    \        } else if character == \".|\" {\n            beats_to_beat.append(i)\n\
    \            i += 1\n        } else {\n            return beats_to_beat\n    \
    \    }\n    }\n    return beats_to_beat\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpbxhbeke2.swift:14:5: error: cannot assign to value: 'music_string'\
    \ is a 'let' constant\n    music_string = music_string.trim()\n    ^~~~~~~~~~~~\n\
    /tmp/tmpbxhbeke2.swift:14:33: error: value of type 'String' has no member 'trim'\n\
    \    music_string = music_string.trim()\n                   ~~~~~~~~~~~~ ^~~~\n\
    /tmp/tmpbxhbeke2.swift:24:29: error: binary operator '==' cannot be applied to\
    \ operands of type 'Character' and 'String'\n        } else if character == \"\
    o|\" {\n                  ~~~~~~~~~ ^  ~~~~\n/tmp/tmpbxhbeke2.swift:24:29: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        } else if character == \"o|\" {\n    \
    \                        ^\n/tmp/tmpbxhbeke2.swift:26:29: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'String'\n      \
    \  } else if character == \".|\" {\n                  ~~~~~~~~~ ^  ~~~~\n/tmp/tmpbxhbeke2.swift:26:29:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        } else if character == \"\
    .|\" {\n                            ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Split the string into\
    \ a list of single notes\n    let notes = music_string.components(separatedBy:\
    \ \" \")\n    // For each note in the music string, try to parse it\n    var beat_count:\
    \ [Int] = [0]\n    for note in notes {\n        // If the note is valid\n    \
    \    if let note_number = parse_note(note: note) {\n            // Add to the\
    \ beat_count array\n            beat_count[note_number] += 1;\n        }\n   \
    \ }\n    return beat_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpyy4mi1x9.swift:13:30: error: value of type 'String' has no member\
    \ 'components'\n    let notes = music_string.components(separatedBy: \" \")\n\
    \                ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpyy4mi1x9.swift:18:30: error:\
    \ cannot find 'parse_note' in scope\n        if let note_number = parse_note(note:\
    \ note) {\n                             ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.split(separator:\
    \ \" \").map({ Int($0) }).map { $0 / 4 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp76beixhy.swift:12:53: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return music_string.split(separator:\
    \ \" \").map({ Int($0) }).map { $0 / 4 }\n                                   \
    \                 ^\n/tmp/tmp76beixhy.swift:12:53: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    return music_string.split(separator:\
    \ \" \").map({ Int($0) }).map { $0 / 4 }\n                                   \
    \                 ^\n                                                        \
    \    ?? <#default value#>\n/tmp/tmp76beixhy.swift:12:53: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    return music_string.split(separator:\
    \ \" \").map({ Int($0) }).map { $0 / 4 }\n                                   \
    \                 ^\n                                                        \
    \   !\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_per_note = [Int]()\n\
    \    for note in music_string {\n        switch note {\n        case \"o\":\n\
    \            beats_per_note.append(4)\n        case \"o|\":\n            beats_per_note.append(2)\n\
    \        case \"o.|\":\n            beats_per_note.append(1)\n        default:\n\
    \            beats_per_note.append(1)\n        }\n    }\n    return beats_per_note\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpavf4pj1a.swift:17:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n/tmp/tmpavf4pj1a.swift:19:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o.|\":\n           \
    \  ^~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_per_note: [Int]\
    \ = [0]\n    for note in music_string {\n        var beats = 0\n        var note_index\
    \ = note.unicodeScalars.firstIndex(of: \"o\") + 1\n        for _ in 0..<note_index\
    \ {\n            beats += 4\n            note_index = note_index.distanceTo(note.unicodeScalars.firstIndex(of:\
    \ \"o\") + 1) + 1\n        }\n        beats_per_note.append(beats)\n    }\n  \
    \  return beats_per_note\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpzzz0j3ib.swift:15:46: error: cannot convert value of type 'String.UnicodeScalarView.Index?'\
    \ (aka 'Optional<String.Index>') to expected argument type 'Int'\n        var\
    \ note_index = note.unicodeScalars.firstIndex(of: \"o\") + 1\n               \
    \                              ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n  var result: [Int] = []\n\
    \  var previous_note = \"\"\n  var number_of_notes = 0\n  for c in music_string\
    \ {\n    if c == \"o\" {\n      if previous_note == \"\" {\n        number_of_notes\
    \ += 1\n        result.append(number_of_notes)\n        number_of_notes = 0\n\
    \      } else {\n        number_of_notes = 1\n      }\n      previous_note = \"\
    o\"\n    } else if c == \"|\" {\n      if number_of_notes == 1 {\n        number_of_notes\
    \ += 1\n        result.append(number_of_notes)\n      } else {\n        number_of_notes\
    \ += 1\n      }\n      previous_note = \"|\"\n    } else if c == \".\" {\n   \
    \   if number_of_notes == 1 {\n        number_of_notes += 1\n      } else {\n\
    \        number_of_notes += 1\n      }\n      previous_note = \".\"\n    }\n \
    \ }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpgr99_fji/tmpgr99_fji.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33f8998c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33f868fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33f868f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33f868e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgr99_fji                        0x000055c28d59277f <unavailable> + 6015

    5    libc.so.6                          0x00002b33f8b84460 __libc_start_main +
    245

    6    tmpgr99_fji                        0x000055c28d5922b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    music_string = music_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    music_string = music_string.replacingOccurrences(of:\
    \ \".\", with: \"|\")\n    let split_music_string = music_string.components(separatedBy:\
    \ \"|\")\n    var music_array = [Int]()\n    for note in split_music_string {\n\
    \        if note.first! == \"o\" {\n            music_array.append(4)\n      \
    \  }\n        else if note.first! == \"o\" {\n            music_array.append(2)\n\
    \        }\n        else if note.first! == \".\" {\n            music_array.append(1)\n\
    \        }\n        else {\n            fatalError(\"unknown music note\")\n \
    \       }\n    }\n    return music_array\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp0r49ymw9.swift:12:5: error: cannot assign to value: 'music_string'\
    \ is a 'let' constant\n    music_string = music_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    ^~~~~~~~~~~~\n/tmp/tmp0r49ymw9.swift:12:33: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n    music_string = music_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0r49ymw9.swift:13:5:\
    \ error: cannot assign to value: 'music_string' is a 'let' constant\n    music_string\
    \ = music_string.replacingOccurrences(of: \".\", with: \"|\")\n    ^~~~~~~~~~~~\n\
    /tmp/tmp0r49ymw9.swift:13:33: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \    music_string = music_string.replacingOccurrences(of: \".\", with: \"|\")\n\
    \                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0r49ymw9.swift:14:43:\
    \ error: value of type 'String' has no member 'components'\n    let split_music_string\
    \ = music_string.components(separatedBy: \"|\")\n                            \
    \ ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    // Your code here!\n\
    \    let notes = music_string.split(separator: \" \")\n    var beats = [Int]()\n\
    \    \n    for note in notes {\n        if note == \".\" {\n            beats.append(4)\n\
    \        }\n        else if note == \"o\" {\n            beats.append(1)\n   \
    \     }\n        else if note == \"o|\" {\n            beats.append(2)\n     \
    \   }\n        else {\n            beats.append(0)\n        }\n    }\n    \n \
    \   return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpfnpih5th/tmpfnpih5th.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0ad872c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0ad569b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0ad569988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0ad5687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfnpih5th                        0x00005630470a7a3f <unavailable> + 6719

    5    libc.so.6                          0x00002ba0ada5e460 __libc_start_main +
    245

    6    tmpfnpih5th                        0x00005630470a7579 <unavailable> + 5497

    '
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result = [Int]()\n\
    \    for s in music_string {\n        if s == '.' {\n            result.append(1)\n\
    \        } else {\n            if s == 'o' {\n                result.append(4)\n\
    \            } else if s == 'o|' {\n                result.append(2)\n       \
    \     } else {\n                fatalError(\"Wrong note symbol: \\(s)\")\n   \
    \         }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpl8v7slvo.swift:14:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '.' {\n                ^~~\n                \".\"\n\
    /tmp/tmpl8v7slvo.swift:17:21: error: single-quoted string literal found, use '\"\
    '\n            if s == 'o' {\n                    ^~~\n                    \"\
    o\"\n/tmp/tmpl8v7slvo.swift:19:28: error: single-quoted string literal found,\
    \ use '\"'\n            } else if s == 'o|' {\n                           ^~~~\n\
    \                           \"o|\"\n/tmp/tmpl8v7slvo.swift:19:25: error: binary\
    \ operator '==' cannot be applied to operands of type 'Character' and 'String'\n\
    \            } else if s == 'o|' {\n                      ~ ^  ~~~~\n/tmp/tmpl8v7slvo.swift:19:25:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            } else if s == 'o|' {\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return parse_music_recursive(music_string)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpa2y86r9w.swift:12:12: error: cannot find 'parse_music_recursive'\
    \ in scope\n    return parse_music_recursive(music_string)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.characters.split\
    \ {$0 == \"|\"} |> Array.map {\n        switch $0 {\n            case \"o\" |\
    \ \"o|\":\n                return 4\n            default:\n                return\
    \ 2\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp5sfqi21o.swift:12:54: error: cannot find operator '|>' in scope\n\
    \    return music_string.characters.split {$0 == \"|\"} |> Array.map {\n     \
    \                                                ^~\n/tmp/tmp5sfqi21o.swift:12:63:\
    \ error: no exact matches in call to instance method 'map'\n    return music_string.characters.split\
    \ {$0 == \"|\"} |> Array.map {\n                                             \
    \                 ^\n/tmp/tmp5sfqi21o.swift:12:63: note: found candidate with\
    \ type '((_) throws -> Int) throws -> Array<Int>'\n    return music_string.characters.split\
    \ {$0 == \"|\"} |> Array.map {\n                                             \
    \                 ^\n/tmp/tmp5sfqi21o.swift:12:67: error: unable to infer type\
    \ of a closure parameter '$0' in the current context\n    return music_string.characters.split\
    \ {$0 == \"|\"} |> Array.map {\n                                             \
    \                     ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes: [Int] = []\n\
    \    let beats_per_bar = 4\n    var temp = 0\n    var beats = 0\n    for index\
    \ in 0..<music_string.characters.count {\n        if music_string.characters.indexGreaterThanOrEqualTo(index,\
    \ by: (music_string.characters.count - 1)) {\n            temp += 1\n        }\
    \ else {\n            if music_string.characters.characters[index] == '|' {\n\
    \                temp = 0\n            }\n            if temp == beats_per_bar\
    \ {\n                notes.append(beats)\n                temp = 0\n         \
    \       beats = 0\n            } else {\n                temp += 1\n         \
    \       beats += 1\n            }\n        }\n    }\n    return notes\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpsc6c870a.swift:20:61: error: single-quoted string literal found,\
    \ use '\"'\n            if music_string.characters.characters[index] == '|' {\n\
    \                                                            ^~~\n           \
    \                                                 \"|\"\n/tmp/tmpsc6c870a.swift:16:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    for index\
    \ in 0..<music_string.characters.count {\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpsc6c870a.swift:17:36:\
    \ error: value of type 'String' has no member 'indexGreaterThanOrEqualTo'\n  \
    \      if music_string.characters.indexGreaterThanOrEqualTo(index, by: (music_string.characters.count\
    \ - 1)) {\n           ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsc6c870a.swift:20:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if music_string.characters.characters[index]\
    \ == '|' {\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpsc6c870a.swift:20:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if music_string.characters.characters[index] == '|' {\n                    \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsc6c870a.swift:20:40:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if music_string.characters.characters[index] == '|' {\n                    \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = 0\n    var\
    \ beats_of_note = []\n    for character in music_string {\n        switch character\
    \ {\n        case \"o\":\n            beats_of_note.append(beats)\n          \
    \  beats = 0\n        case \"|\":\n            beats_of_note.append(beats)\n \
    \           beats = 0\n        default:\n            beats++\n        }\n    }\n\
    \    beats_of_note.append(beats)\n    return beats_of_note\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpxej73le3.swift:13:25: error: empty collection literal requires\
    \ an explicit type\n    var beats_of_note = []\n                        ^~\n/tmp/tmpxej73le3.swift:23:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  beats++\n                 ^~\n/tmp/tmpxej73le3.swift:27:12: error: cannot convert\
    \ return expression of type '[Any]' to return type '[Int]'\n    return beats_of_note\n\
    \           ^\n/tmp/tmpxej73le3.swift:27:12: note: arguments to generic parameter\
    \ 'Element' ('Any' and 'Int') are expected to be equal\n    return beats_of_note\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    let music_string_array\
    \ = music_string.split(separator: \" \")\n    let music_string_array_without_dots\
    \ = music_string_array.filter{$0 != \".\"}\n    \n    let beats = music_string_array_without_dots.count\n\
    \n    var music_string_array_without_dots_with_beats = [Int]()\n    for i in 0..<music_string_array_without_dots.count\
    \ {\n        let string = music_string_array_without_dots[i]\n        var beats_count\
    \ = 0\n        if string[0] == 'o' {\n            beats_count = 4\n        }else\
    \ if string[0] == 'o|' {\n            beats_count = 4\n        }else if string[0]\
    \ == '.|' {\n            beats_count = 4\n        }\n        music_string_array_without_dots_with_beats.append(beats_count)\n\
    \    }\n\n    return music_string_array_without_dots_with_beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpvu5o2gkw.swift:22:25: error: single-quoted string literal found,\
    \ use '\"'\n        if string[0] == 'o' {\n                        ^~~\n     \
    \                   \"o\"\n/tmp/tmpvu5o2gkw.swift:24:31: error: single-quoted\
    \ string literal found, use '\"'\n        }else if string[0] == 'o|' {\n     \
    \                         ^~~~\n                              \"o|\"\n/tmp/tmpvu5o2gkw.swift:26:31:\
    \ error: single-quoted string literal found, use '\"'\n        }else if string[0]\
    \ == '.|' {\n                              ^~~~\n                            \
    \  \".|\"\n/tmp/tmpvu5o2gkw.swift:22:18: error: no exact matches in call to subscript\
    \ \n        if string[0] == 'o' {\n                 ^\nSwift.Substring:3:12: note:\
    \ candidate expects value of type 'Range<Substring.Index>' (aka 'Range<String.Index>')\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<Substring.Index>)\
    \ -> Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmpvu5o2gkw.swift:24:24: error: no exact matches\
    \ in call to subscript \n        }else if string[0] == 'o|' {\n              \
    \         ^\nSwift.Substring:3:12: note: candidate expects value of type 'Range<Substring.Index>'\
    \ (aka 'Range<String.Index>') for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<Substring.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpvu5o2gkw.swift:26:24:\
    \ error: no exact matches in call to subscript \n        }else if string[0] ==\
    \ '.|' {\n                       ^\nSwift.Substring:3:12: note: candidate expects\
    \ value of type 'Range<Substring.Index>' (aka 'Range<String.Index>') for parameter\
    \ #1 (got 'Int')\n    public subscript(r: Range<Substring.Index>) -> Substri"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    let note_length =\
    \ 60\n    \n    var beatCounts = [Int]()\n    \n    \n    for character in music_string\
    \ {\n        \n        let note_number = character as UInt32\n        \n     \
    \   beatCounts.append(Int(note_number) / 4)\n    }\n    \n    return beatCounts\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmph66dyqnw.swift:20:37: error: cannot convert value of type 'Character'\
    \ to type 'UInt32' in coercion\n        let note_number = character as UInt32\n\
    \                          ~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_arr = [Int]()\n\
    \    var note_arr = [String]()\n    \n    guard let music_arr = music_string.components(separatedBy:\
    \ \" \") else {\n        return beats_arr\n    }\n    \n    music_arr.forEach\
    \ { (element) in\n        \n        if element.contains(\"o\") {\n           \
    \ beats_arr.append(4)\n        } else if element.contains(\"o|\") {\n        \
    \    beats_arr.append(2)\n        } else if element.contains(\".|\") {\n     \
    \       beats_arr.append(1)\n        } else {\n            note_arr.append(element)\n\
    \        }\n    }\n    \n    beats_arr.forEach() { (element) in\n        \n  \
    \      if element > 4 {\n            beats_arr.remove(at: beats_arr.index(of:\
    \ element))\n        }\n    }\n    \n    return beats_arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpvwgv80tr.swift:15:40: error: value of type 'String' has no member\
    \ 'components'\n    guard let music_arr = music_string.components(separatedBy:\
    \ \" \") else {\n                          ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvwgv80tr.swift:35:44:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n           \
    \ beats_arr.remove(at: beats_arr.index(of: element))\n                       \
    \                    ^\n/tmp/tmpvwgv80tr.swift:35:44: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n            beats_arr.remove(at:\
    \ beats_arr.index(of: element))\n                                           ^\n\
    \                                                              ?? <#default value#>\n\
    /tmp/tmpvwgv80tr.swift:35:44: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            beats_arr.remove(at: beats_arr.index(of:\
    \ element))\n                                           ^\n                  \
    \                                           !\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.components(separatedBy:\
    \ \" \").flatMap { noteString -> [Int] in\n        if noteString == \"o\" {\n\
    \            return Array(0..<4)\n        } else if noteString == \"o|\" {\n \
    \           return Array(0..<2)\n        } else if noteString == \".|\" {\n  \
    \          return Array(0..<1)\n        } else {\n            preconditionFailure(\"\
    note should be one of 'o', 'o|', 'o|', or 'o|')\")\n        }\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpvb3flzsl.swift:12:25: error: value of type 'String' has no member\
    \ 'components'\n    return music_string.components(separatedBy: \" \").flatMap\
    \ { noteString -> [Int] in\n           ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var music_array: [Int]\
    \ = Array(repeating: 0, count: music_string.characters.count)\n\n    music_string.replacingOccurrences(of:\
    \ \"o\", with: \"0\")\n        .replacingOccurrences(of: \".\", with: \"|\")\n\
    \        .replacingOccurrences(of: \"|\", with: \"0\")\n\n    for i in 0..<music_string.characters.count\
    \ {\n        if music_string.characters[i] == \"0\" {\n            music_array[i]\
    \ = 1\n        } else {\n            let beat_count = Int(music_string[i])\n \
    \           music_array[i] = beat_count\n        }\n    }\n\n    return music_array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpeetve9hw.swift:12:70: error: 'characters' is unavailable: Please\
    \ use String directly\n    var music_array: [Int] = Array(repeating: 0, count:\
    \ music_string.characters.count)\n                                           \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpeetve9hw.swift:14:18: error: value of type 'String' has\
    \ no member 'replacingOccurrences'\n    music_string.replacingOccurrences(of:\
    \ \"o\", with: \"0\")\n    ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpeetve9hw.swift:18:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    for i in\
    \ 0..<music_string.characters.count {\n                              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpeetve9hw.swift:19:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if music_string.characters[i] == \"0\"\
    \ {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpeetve9hw.swift:19:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        if music_string.characters[i]\
    \ == \"0\" {\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpeetve9hw.swift:22:46: error: no exact matches in call\
    \ to subscript \n            let beat_count = Int(music_string[i])\n         \
    \                                    ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlin"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result: [Int] = [0,\
    \ 0]\n\n    music_string.split(separator: \" \").forEach { music_string in\n \
    \       music_string = music_string.replacingOccurrences(of: \"\\\\|\", with:\
    \ \"\")\n        music_string = music_string.replacingOccurrences(of: \"\\\\o\"\
    , with: \"\")\n\n        if music_string.count == 0 {\n            music_string\
    \ = \"o\"\n        }\n\n        if music_string.count == 1 {\n            result[0]\
    \ += 4\n        }\n\n        if music_string.count == 2 {\n            result[0]\
    \ += 2\n            result[1] += 2\n        }\n\n        if music_string.count\
    \ == 3 {\n            result[0] += 2\n            result[1] += 2\n           \
    \ result[2] += 1\n        }\n\n        if music_string.count == 4 {\n        \
    \    result[0] += 1\n            result[1] += 1\n            result[2] += 1\n\
    \            result[3] += 1\n        }\n\n        if music_string.count > 4 {\n\
    \            result[0] += 4\n            result[1] += 4\n            result[2]\
    \ += 4\n            result[3] += 4\n        }\n    }\n\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpfir7fvv2.swift:15:37: error: reference to member 'replacingOccurrences'\
    \ cannot be resolved without a contextual type\n        music_string = music_string.replacingOccurrences(of:\
    \ \"\\\\|\", with: \"\")\n                                    ^\n/tmp/tmpfir7fvv2.swift:15:9:\
    \ error: cannot assign to value: 'music_string' is a 'let' constant\n        music_string\
    \ = music_string.replacingOccurrences(of: \"\\\\|\", with: \"\")\n        ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let note_symbols = music_string.split(separator:\
    \ \" \")\n    var note_strings: [String] = []\n    for note_symbol in note_symbols\
    \ {\n        var note_string = \"\"\n        let note_length = note_symbol.characters.count\n\
    \        for index in 0..<note_length {\n            note_string += note_symbol.characters[index]\n\
    \        }\n        note_strings.append(note_string)\n    }\n\n    var beats =\
    \ [Int]()\n    for note in note_strings {\n        if note.characters.first ==\
    \ \"o\" {\n            beats.append(4)\n        }\n        else if note.characters.first\
    \ == \"o|\" {\n            beats.append(2)\n        }\n        else if note.characters.first\
    \ == \".\" {\n            beats.append(1)\n        }\n    }\n\n    return beats\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpgmo7r_9o.swift:16:39: error: 'characters' is unavailable: Please\
    \ use Substring directly\n        let note_length = note_symbol.characters.count\n\
    \                                      ^~~~~~~~~~\nSwift.Substring:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmpgmo7r_9o.swift:18:50: error: no exact\
    \ matches in call to subscript \n            note_string += note_symbol.characters[index]\n\
    \                                                 ^\nSwift.Substring:3:12: note:\
    \ candidate expects value of type 'Range<Substring.Index>' (aka 'Range<String.Index>')\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<Substring.Index>)\
    \ -> Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmpgmo7r_9o.swift:25:17: error: 'characters' is\
    \ unavailable: Please use String directly\n        if note.characters.first ==\
    \ \"o\" {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgmo7r_9o.swift:28:39: error: type '((String.Element) throws\
    \ -> Bool) throws -> String.Element?' (aka '((Character) throws -> Bool) throws\
    \ -> Optional<Character>') cannot conform to 'StringProtocol'\n        else if\
    \ note.characters.first == \"o|\" {\n                                      ^\n\
    /tmp/tmpgmo7r_9o.swift:28:39: note: only concrete types such as structs, enums\
    \ and classes can conform to protocols\n        else if note.characters.first\
    \ == \"o|\" {\n                                      ^\n/tmp/tmpgmo7r_9o.swift:28:39:\
    \ note: required by referencing operator function '==' on 'StringProtocol' where\
    \ 'Self' = '((String.Element) throws -> Bool) throws -> String.Element?' (aka\
    \ '((Character) throws -> Bool) throws -> Optional<Character>')\n        else\
    \ if note.characters.first == \"o"
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    let splitString =\
    \ music_string.split(separator: \"|\")\n    var beats = [Int]()\n    for i in\
    \ 0..<splitString.count {\n        let str = splitString[i]\n        if str.first\
    \ == \"o\" {\n            beats.append(4)\n        } else if str.first == \".\"\
    \ {\n            beats.append(1)\n        } else {\n            beats.append(0)\n\
    \        }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmp__oda416/tmp__oda416.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10580fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1057df4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1057df4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1057df37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp__oda416                        0x000055b94c6e6abf <unavailable> + 6847

    5    libc.so.6                          0x00002b10582e9460 __libc_start_main +
    245

    6    tmp__oda416                        0x000055b94c6e65f9 <unavailable> + 5625

    '
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Your code here\n   \
    \ if music_string == \"\" {\n        return []\n    }\n    music_string = music_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    music_string = music_string.replacingOccurrences(of:\
    \ \"|\", with: \"\")\n    var beats_array = [Int]()\n    var counter = 0\n   \
    \ guard let music_array = music_string.components(separatedBy: \"o|\") else {\n\
    \        return beats_array\n    }\n    for music_string_part in music_array {\n\
    \        guard let beats = Int(music_string_part) else {\n            return beats_array\n\
    \        }\n        counter += 1\n        if counter % 4 == 0 {\n            beats_array.append(beats)\n\
    \        } else {\n            beats_array.append(beats * 2)\n        }\n    }\n\
    \    return beats_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpawy1_pb1.swift:16:5: error: cannot assign to value: 'music_string'\
    \ is a 'let' constant\n    music_string = music_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    ^~~~~~~~~~~~\n/tmp/tmpawy1_pb1.swift:16:33: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n    music_string = music_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpawy1_pb1.swift:17:5:\
    \ error: cannot assign to value: 'music_string' is a 'let' constant\n    music_string\
    \ = music_string.replacingOccurrences(of: \"|\", with: \"\")\n    ^~~~~~~~~~~~\n\
    /tmp/tmpawy1_pb1.swift:17:33: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \    music_string = music_string.replacingOccurrences(of: \"|\", with: \"\")\n\
    \                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpawy1_pb1.swift:20:42:\
    \ error: value of type 'String' has no member 'components'\n    guard let music_array\
    \ = music_string.components(separatedBy: \"o|\") else {\n                    \
    \        ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.components(separatedBy:\
    \ \"\").enumerated().map({\n        switch $0 {\n        case .element(let note,\
    \ _):\n            return note == \"o\" ? 4 : note == \"o|\" ? 2 : note == \"\
    .|\" ? 1 : 0\n        }\n    }).reversed().compactMap { $0 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpmze96trj.swift:17:19: error: type of expression is ambiguous without\
    \ more context\n    }).reversed().compactMap { $0 }\n~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var counts: [Int] = []\n\
    \    var beat = 0\n    var length = 0\n    var index = 0\n\n    if music_string.count\
    \ > 36 {\n        beat = 0\n    } else {\n        if music_string[index] != \"\
    \ \" {\n            index += 1\n        }\n        if index < music_string.count\
    \ {\n            length = index - 2\n        } else {\n            length = 0\n\
    \        }\n    }\n    for _ in 0..<length {\n        if index + 2 < music_string.count\
    \ {\n            if music_string[index] != \" \" {\n                counts.append(0)\n\
    \            } else {\n                if music_string[index+1] == \"|\" {\n \
    \                   counts.append(4)\n                    beat += 4\n        \
    \            index += 1\n                } else if music_string[index+1] == \"\
    o\" {\n                    counts.append(2)\n                    beat += 2\n \
    \                   index += 1\n                } else {\n                   \
    \ counts.append(1)\n                    beat += 1\n                    index +=\
    \ 1\n                }\n            }\n            index += 1\n        }\n   \
    \ }\n    return counts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp2dlfx9w1.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if music_string[index]\
    \ != \" \" {\n           ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp2dlfx9w1.swift:31:16: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if music_string[index] != \" \" {\n               ^~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp2dlfx9w1.swift:34:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if music_string[index+1] == \"\
    |\" {\n                   ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp2dlfx9w1.swift:38:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                } else if music_string[index+1] == \"o\" {\n                \
    \          ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.characters.split(separator:\
    \ \"|\").map({ String($0).characters.split(separator: \"o\").map({ Int(String($0)).characters.split(separator:\
    \ \" \").map({ Int($0).characters.count })}) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp32ci4dxl.swift:12:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return music_string.characters.split(separator: \"|\").map({\
    \ String($0).characters.split(separator: \"o\").map({ Int(String($0)).characters.split(separator:\
    \ \" \").map({ Int($0).characters.count })}) })\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014174
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let notes_array = music_string.components(separatedBy:\
    \ \"|\")\n    let beats_array = notes_array.components(separatedBy: \"o\")\n \
    \   var counts: [Int] = [0]\n    beats_array.forEach {\n        let note_index\
    \ = notes_array.indexOf($0)\n        counts[note_index] = (counts[note_index]\
    \ ?? 0) + beats_array.count\n    }\n    return counts\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpu3c077il.swift:12:36: error: value of type 'String' has no member\
    \ 'components'\n    let notes_array = music_string.components(separatedBy: \"\
    |\")\n                      ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Convert string to array\
    \ of ASCII code points\n    var strArray = music_string.unicodeScalars\n\n   \
    \ // Initialize notes array to 0\n    var notes = [Int](repeating: 0, count: 100)\n\
    \n    // Define a function to search for the next note in the string\n    var\
    \ nextNote = strArray.startIndex.advanced(by: 1)\n    func searchForNextNote()\
    \ {\n        // If the string has reached the end\n        if nextNote == strArray.endIndex\
    \ {\n            // All notes have been found\n            return notes\n    \
    \    }\n\n        // If the string has found a note in the correct octave\n  \
    \      if let note = strArray[nextNote] as? UnicodeScalar {\n            // Check\
    \ if it is a note or not\n            switch note.value {\n            case UnicodeScalar(\"\
    o\"...\"o\"): break\n            case UnicodeScalar(\"o|\"...\".|\"): notes[1]\
    \ += 1\n            case UnicodeScalar(\".|\"): notes[4] += 1\n            default:\
    \ print(\"\\(note.value) is not a valid note\")\n            }\n        }\n\n\
    \        // Search for the next note\n        nextNote = nextNote.advanced(by:\
    \ 1)\n        return searchForNextNote()\n    }\n\n    return searchForNextNote()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpd91jqffz.swift:19:40: error: value of type 'String.UnicodeScalarView.Index'\
    \ (aka 'String.Index') has no member 'advanced'\n    var nextNote = strArray.startIndex.advanced(by:\
    \ 1)\n                   ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpd91jqffz.swift:24:20:\
    \ error: unexpected non-void return value in void function\n            return\
    \ notes\n                   ^\n/tmp/tmpd91jqffz.swift:24:20: note: did you mean\
    \ to add a return type?\n            return notes\n                   ^\n/tmp/tmpd91jqffz.swift:43:12:\
    \ error: cannot convert return expression of type '()' to return type '[Int]'\n\
    \    return searchForNextNote()\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_per_note = [Int]()\n\
    \    let split_string = music_string.components(separatedBy: \" \")\n    for note\
    \ in split_string {\n        if note.characters.last == \"|\" {\n            beats_per_note.append(4)\n\
    \        } else {\n            beats_per_note.append(1)\n        }\n    }\n  \
    \  return beats_per_note\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp5715xapu.swift:13:37: error: value of type 'String' has no member\
    \ 'components'\n    let split_string = music_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_numbers = [Int]()\n\
    \    guard let music_notes = music_string.split(separator: \"|\") else {\n   \
    \     return beats_numbers\n    }\n    for note in music_notes {\n        if note\
    \ == \"o\" {\n            beats_numbers.append(4)\n        } else if note == \"\
    o|\" {\n            beats_numbers.append(2)\n        } else if note == \".|\"\
    \ {\n            beats_numbers.append(1)\n        }\n    }\n    return beats_numbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmph5x_efeb.swift:13:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let music_notes = music_string.split(separator: \"|\") else {\n   \
    \       ^                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   var note_num = 0\n\n    for i in 0..<music_string.characters.count {\n   \
    \     guard let char = music_string.characters[i] else { return beats }\n\n  \
    \      switch char {\n        case 'o': // whole note, lasts four beats\n    \
    \        beats.append(4)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n            note_num += 1\n            beats.append(0)\n\
    \            note_num += 1\n            beats.append(0)\n            note_num\
    \ += 1\n            beats.append(0)\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpdje9ndy1.swift:19:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'o': // whole note, lasts four beats\n             ^~~\n\
    \             \"o\"\n/tmp/tmpdje9ndy1.swift:131:87: error: expected '}' at end\
    \ of brace statement\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\"\
    ) == [2, 1, 2, 1, 4, 2, 4, 2])\n                                             \
    \                                         ^\n/tmp/tmpdje9ndy1.swift:15:48: note:\
    \ to match this opening '{'\n    for i in 0..<music_string.characters.count {\n\
    \                                               ^\n/tmp/tmpdje9ndy1.swift:131:87:\
    \ error: expected '}' at end of brace statement\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])\n                  \
    \                                                                    ^\n/tmp/tmpdje9ndy1.swift:11:49:\
    \ note: to match this opening '{'\nfunc parse_music(music_string: String) -> [Int]\
    \ {\n                                                ^\n/tmp/tmpdje9ndy1.swift:15:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    for i in\
    \ 0..<music_string.characters.count {\n                              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdje9ndy1.swift:16:26:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        guard let char = music_string.characters[i]\
    \ else { return beats }\n                         ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpdje9ndy1.swift:16:39:\
    \ error: 'characters' is unavailable: Please use String directly\n        guard\
    \ let char = music_string.characters[i] else { return beats }\n              \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \       "
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.componentsSeparatedByString(\"\
    .\").map { note -> Int in\n        let note = note.substringToIndex(note.startIndex.advancedBy(1))\n\
    \        let beats = note.characters.count\n        var beat = 0\n        if note.hasPrefix(\"\
    o|\") {\n            beat = beats * 2\n        } else if note.hasPrefix(\"o\"\
    ) {\n            beat = 1\n        } else if note.hasPrefix(\".|\") {\n      \
    \      beat = 1\n        }\n        return beat\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpqjnjugr2.swift:12:25: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    return music_string.componentsSeparatedByString(\"\
    .\").map { note -> Int in\n           ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_array = music_string.characters.split(separator:\
    \ \"|\").map({ String($0) }).map({ String($0) }).reduce(into: [Int](), { $0.append($1)\
    \ })\n    let beats_per_note = music_array.count - 1\n    var beats_per_block\
    \ = beats_per_note\n    while beats_per_block > 0 {\n        beats_per_block -=\
    \ beats_per_note\n        beats_per_note += beats_per_note\n    }\n    return\
    \ music_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpg_v1r49l.swift:12:143: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n    let music_array = music_string.characters.split(separator:\
    \ \"|\").map({ String($0) }).map({ String($0) }).reduce(into: [Int](), { $0.append($1)\
    \ })\n                                                                       \
    \                                                                       ^\n"
  stdout: ''
  timestamp: 1660014150
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_tokens = music_string.characters.split(separator:\
    \ \" \")\n\n    var beats = [Int]()\n    for token in music_tokens {\n       \
    \ if token.characters.count > 0 {\n            let note = token.characters.first\
    \ ?? \"\"\n            let length = note.count\n            if note == \"o\" {\n\
    \                beats.append(4)\n            } else if note == \"o|\" {\n   \
    \             beats.append(2)\n            } else if note == \".|\" {\n      \
    \          beats.append(1)\n            } else if note == \".\" {\n          \
    \      beats.append(1)\n                beats.append(1)\n            } else {\n\
    \                beats.append(4)\n            }\n        }\n    }\n    return\
    \ beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmprzg97oez.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    let music_tokens = music_string.characters.split(separator:\
    \ \" \")\n                                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmprzg97oez.swift:16:18: error: 'characters'\
    \ is unavailable: Please use Substring directly\n        if token.characters.count\
    \ > 0 {\n                 ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmprzg97oez.swift:17:47: error: binary operator '??' cannot\
    \ be applied to operands of type 'Character?' and 'String'\n            let note\
    \ = token.characters.first ?? \"\"\n                       ~~~~~~~~~~~~~~~~~~~~~~\
    \ ^  ~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_string_to_beats:\
    \ [(String, Int)] = [\n        (\".\", 2),\n        (\"|\", 1),\n        (\"o\"\
    , 4)\n    ]\n\n    var music_notes: [Int] = []\n    for (note_string, beats) in\
    \ music_string_to_beats {\n        if note_string == \"\" {\n            music_notes.append(beats)\n\
    \        } else {\n            music_notes.append(beats + music_notes[music_notes.count\
    \ - 1])\n        }\n    }\n    return music_notes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b31be66ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31be361561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b31be361286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b31be36113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b31be360bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b31be160e83 <unavailable> + 188035

    6    tmpkx3gtl3a                        0x000055bc6d395f3e <unavailable> + 7998

    7    tmpkx3gtl3a                        0x000055bc6d395615 <unavailable> + 5653

    8    libc.so.6                          0x00002b31be856460 __libc_start_main +
    245

    9    tmpkx3gtl3a                        0x000055bc6d395319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_list = music_string.componentsSeparatedByString(\"\
    \ \")\n    var result = [Int]()\n    for music in music_list {\n        var beats\
    \ = 0\n        var last = UInt8(1)\n        let music_note = music.lowercaseString\n\
    \        for n in music_note.unicodeScalars {\n            switch n {\n      \
    \      case .O:\n                beats += 4\n            case .O:\n          \
    \      beats += 2\n            case .O:\n                beats += 1\n        \
    \    default:\n                break\n            }\n            last = UInt8(0)\n\
    \        }\n        result.append(beats)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp09y4lcib.swift:12:35: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let music_list = music_string.componentsSeparatedByString(\"\
    \ \")\n                     ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n\n\
    \    for music_char in music_string {\n        switch music_char {\n        case\
    \ \"o\":\n            beats.append(4)\n        case \"o|\":\n            beats.append(2)\n\
    \        case \"|\":\n            beats.append(1)\n        default:\n        \
    \    beats.append(0)\n        }\n    }\n    return beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpqi27zhpm.swift:18:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.unicodeScalars.filter({\
    \ $0.value > 0 })\n        .map({ Int($0.value - 65) })\n        .sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var note_strs = music_string.split(separator:\
    \ \"|\")\n    var beats_strs = note_strs.map { $0.split(separator: \" \") }\n\
    \    var beats = beats_strs.flatMap { $0.map { Int($0) } }\n    let notes = beats.map\
    \ { note in\n        switch note {\n        case 0: return 0\n        case 1:\
    \ return 1\n        case 2: return 2\n        case 3: return 3\n        case 4:\
    \ return 4\n        case 5: return 5\n        case 6: return 6\n        case 7:\
    \ return 7\n        case 8: return 8\n        case 9: return 9\n        case 10:\
    \ return 10\n        case 11: return 11\n        case 12: return 12\n        case\
    \ 13: return 13\n        case 14: return 14\n        case 15: return 15\n    \
    \    case 16: return 16\n        case 17: return 17\n        case 18: return 18\n\
    \        case 19: return 19\n        case 20: return 20\n        case 21: return\
    \ 21\n        case 22: return 22\n        case 23: return 23\n        case 24:\
    \ return 24\n        case 25: return 25\n        case 26: return 26\n        case\
    \ 27: return 27\n        case 28: return 28\n        case 29: return 29\n    \
    \    case 30: return 30\n        case 31: return 31\n        case 32: return 32\n\
    \        case 33: return 33\n        case 34: return 34\n        case 35: return\
    \ 35\n        case 36: return 36\n        case 37: return 37\n        case 38:\
    \ return 38\n        case 39: return 39\n        case 40: return 40\n        case\
    \ 41: return 41\n        case 42: return 42\n        case 43: return 43\n    \
    \    case 44: return 44\n        case 45: return 45\n        case 46: return 46\n\
    \        case 47: return 47\n        case 48: return 48\n        case 49: return\
    \ 49\n        case 50: return 50\n        case 51: return 51\n        case 52:\
    \ return 52\n        case 53: return 53\n        case 54: return 54\n        case\
    \ 55: return 55\n        case 56: return 56\n        case 57: return 57\n    \
    \    case 58: return 58\n        case 59: return 59\n        case 60: return 60\n\
    \        case 61: return 61\n        case 62: return 62\n        case 63: return\
    \ 63\n        case 64: return 64\n        case 65: return 65\n        case 66:\
    \ return 66\n        case 67: return 67\n        case 68: return 68\n        case\
    \ 69: return 69\n        case 70: return 70\n        case 71: return 71\n    \
    \    case 72: return 72\n        case 73: return 73\n        case 74: return 74\n\
    \        case 75: return 75\n        case 76: return 76\n        case 77: return\
    \ 77\n        case 78: return 78\n        case 79: return 79\n        case 80:\
    \ return 80\n        case 81: return 81\n        case 82: return 82\n        case\
    \ 83: return 83\n        case 84: return 84\n        case 85: return 85\n    \
    \    case 86: return 86\n        case 87: return 87\n        case 88: return \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp0yx8s_e6.swift:125:87: error: expected '}' at end of closure\n\
    assert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4,\
    \ 2, 4, 2])\n                                                                \
    \                      ^\n/tmp/tmp0yx8s_e6.swift:15:27: note: to match this opening\
    \ '{'\n    let notes = beats.map { note in\n                          ^\n/tmp/tmp0yx8s_e6.swift:125:87:\
    \ error: expected '}' at end of brace statement\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])\n                  \
    \                                                                    ^\n/tmp/tmp0yx8s_e6.swift:11:49:\
    \ note: to match this opening '{'\nfunc parse_music(music_string: String) -> [Int]\
    \ {\n                                                ^\n/tmp/tmp0yx8s_e6.swift:17:24:\
    \ error: unexpected non-void return value in void function\n        case 0: return\
    \ 0\n                       ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = Array(repeating:\
    \ 0, count: music_string.characters.count)\n    for note in music_string.characters\
    \ {\n        if note == \"o\" {\n            beats[note.offset(to: 0)] -= 1\n\
    \            beats[note.offset(to: 1)] -= 1\n        } else if note == \"o|\"\
    \ {\n            beats[note.offset(to: 0)] -= 1\n            beats[note.offset(to:\
    \ 1)] -= 1\n            beats[note.offset(to: 2)] -= 1\n        } else if note\
    \ == \".|\" {\n            beats[note.offset(to: 0)] -= 1\n            beats[note.offset(to:\
    \ 1)] -= 1\n            beats[note.offset(to: 2)] -= 1\n            beats[note.offset(to:\
    \ 3)] -= 1\n        } else {\n            beats[note.offset(to: 0)] += 1\n   \
    \     }\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp7vnzhtzq.swift:12:57: error: 'characters' is unavailable: Please\
    \ use String directly\n    var beats = Array(repeating: 0, count: music_string.characters.count)\n\
    \                                                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp7vnzhtzq.swift:13:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    for note in music_string.characters\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp7vnzhtzq.swift:15:24: error: value of type 'Character'\
    \ has no member 'offset'\n            beats[note.offset(to: 0)] -= 1\n       \
    \           ~~~~ ^~~~~~\n/tmp/tmp7vnzhtzq.swift:16:24: error: value of type 'Character'\
    \ has no member 'offset'\n            beats[note.offset(to: 1)] -= 1\n       \
    \           ~~~~ ^~~~~~\n/tmp/tmp7vnzhtzq.swift:17:24: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'String'\n      \
    \  } else if note == \"o|\" {\n                  ~~~~ ^  ~~~~\n/tmp/tmp7vnzhtzq.swift:17:24:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        } else if note == \"o|\" {\n\
    \                       ^\n/tmp/tmp7vnzhtzq.swift:18:24: error: value of type\
    \ 'Character' has no member 'offset'\n            beats[note.offset(to: 0)] -=\
    \ 1\n                  ~~~~ ^~~~~~\n/tmp/tmp7vnzhtzq.swift:19:24: error: value\
    \ of type 'Character' has no member 'offset'\n            beats[note.offset(to:\
    \ 1)] -= 1\n                  ~~~~ ^~~~~~\n/tmp/tmp7vnzhtzq.swift:20:24: error:\
    \ value of type 'Character' has no member 'offset'\n            beats[note.offset(to:\
    \ 2)] -= 1\n                  ~~~~ ^~~~~~\n/tmp/tmp7vnzhtzq.swift:21:24: error:\
    \ binary operator '==' cannot be applied to operands of type 'Character' and 'String'\n\
    \        } else if note == \".|\" {\n                  ~~~~ ^  ~~~~\n/tmp/tmp7vn"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    music_string = music_string.replace(\"\
    \ \", \"\") // Remove spaces\n\n    var note_beats = [Int]()\n\n    var current_note\
    \ = String()\n    var current_beats = Int()\n    var current_note_len = 0\n\n\
    \    for _ in music_string {\n        if let char = String(music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))).lowercased()\
    \ {\n            if char == \"o\" {\n                if current_note != \"\" {\n\
    \                    note_beats.append(current_beats)\n                    current_beats\
    \ = 0\n                }\n                current_note = String(music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))\
    \ + \"|\")\n                music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))\n\
    \                current_note_len = music_string.startIndex.advancedBy(current_note_len)\
    \ + 1\n            }\n            else if char == \"|\" {\n                if\
    \ current_note != \"\" {\n                    note_beats.append(current_beats)\n\
    \                    current_beats = 0\n                }\n                current_note\
    \ = String(music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))\
    \ + \"|\")\n                current_note_len = music_string.startIndex.advancedBy(current_note_len)\
    \ + 1\n            }\n            else if char == \".\" {\n                if\
    \ current_note != \"\" {\n                    note_beats.append(current_beats)\n\
    \                    current_beats = 0\n                }\n                current_note\
    \ = String(music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))\
    \ + \"|\")\n                music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))\n\
    \                current_note_len = music_string.startIndex.advancedBy(current_note_len)\
    \ + 1\n            }\n            else if char == \"!\" {\n                note_beats.append(current_beats)\n\
    \                note_beats.append(current_beats)\n                note_beats.append(current_beats)\n\
    \                note_beats.append(current_beats)\n                current_beats\
    \ = 0\n                current_note = \"\"\n            }\n            else {\n\
    \                if let note_len = Int(music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))\
    \ + String(music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))).lowercased())\
    \ {\n                    if note_bearers[note_len] == 0 {\n                  \
    \      current_beats = 0\n                    }\n                    else {\n\
    \                        current_beats = current_beats * bearers_scale + bearers_scale[note_len]\n\
    \                    }\n                }\n                else {\n          \
    \          if current_note != \"\" {\n                        note_beats.append(current_beats)\n\
    \                        current_beats = 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmptt4nzazq.swift:88:87: error: expected '}' at end of brace statement\n\
    assert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4,\
    \ 2, 4, 2])\n                                                                \
    \                      ^\n/tmp/tmptt4nzazq.swift:65:22: note: to match this opening\
    \ '{'\n                else {\n                     ^\n/tmp/tmptt4nzazq.swift:88:87:\
    \ error: expected '}' at end of brace statement\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])\n                  \
    \                                                                    ^\n/tmp/tmptt4nzazq.swift:56:18:\
    \ note: to match this opening '{'\n            else {\n                 ^\n/tmp/tmptt4nzazq.swift:88:87:\
    \ error: expected '}' at end of brace statement\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])\n                  \
    \                                                                    ^\n/tmp/tmptt4nzazq.swift:21:128:\
    \ note: to match this opening '{'\n        if let char = String(music_string.characterAtIndex(music_string.startIndex.advancedBy(current_note_len))).lowercased()\
    \ {\n                                                                        \
    \                                                       ^\n/tmp/tmptt4nzazq.swift:88:87:\
    \ error: expected '}' at end of brace statement\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])\n                  \
    \                                                                    ^\n/tmp/tmptt4nzazq.swift:20:27:\
    \ note: to match this opening '{'\n    for _ in music_string {\n             \
    \             ^\n/tmp/tmptt4nzazq.swift:88:87: error: expected '}' at end of brace\
    \ statement\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2,\
    \ 1, 2, 1, 4, 2, 4, 2])\n                                                    \
    \                                  ^\n/tmp/tmptt4nzazq.swift:11:49: note: to match\
    \ this opening '{'\nfunc parse_music(music_string: String) -> [Int] {\n      \
    \                            "
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var arr = [Int]()\n   \
    \ var notes = music_string.characters\n    for char in notes {\n        var beats\
    \ = 0\n        switch char {\n        case \"o\":\n            beats = 4\n   \
    \         break\n        case \"o|\":\n            beats = 2\n            break\n\
    \        case \".|\":\n            beats = 1\n            break\n        default:\n\
    \            break\n        }\n        arr.append(beats)\n    }\n    return arr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp9vghg4vi.swift:13:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    var notes = music_string.characters\n             \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp9vghg4vi.swift:20:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n/tmp/tmp9vghg4vi.swift:23:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \".|\":\n            \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return parse_music_aux(music_string,\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(parse_music(music_string: \"\"\
    ) == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4, 4, 4,\
    \ 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string:\
    \ \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpwdr1y64q.swift:12:12: error: cannot find 'parse_music_aux' in scope\n\
    \    return parse_music_aux(music_string, 0)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_per_note = [Int]()\n\
    \n    let string_array = music_string.components(separatedBy: \" \").map{String($0)}\n\
    \    let note_string = \".o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o\"\n    let note_string\
    \ = note_string.components(separatedBy: \"|\")\n    let note_count = note_string.count\n\
    \n    guard note_count == string_array.count else { return beats_per_note }\n\n\
    \    var beat = 0\n    for i in string_array {\n        if i == \"o\" {\n    \
    \        beats_per_note.append(beat)\n        }\n\n        beat = beat+4\n   \
    \ }\n\n    return beats_per_note\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpphv82qfw.swift:14:37: error: value of type 'String' has no member\
    \ 'components'\n    let string_array = music_string.components(separatedBy: \"\
    \ \").map{String($0)}\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpphv82qfw.swift:16:35:\
    \ error: value of type 'String' has no member 'components'\n    let note_string\
    \ = note_string.components(separatedBy: \"|\")\n                      ~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string.split(separator:\
    \ \" \").compactMap { Int($0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpys00j88p/tmpys00j88p.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2764a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af276198b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af276198988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2761977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpys00j88p                        0x00005634805528bf <unavailable> + 6335

    5    libc.so.6                          0x00002af27668d460 __libc_start_main +
    245

    6    tmpys00j88p                        0x00005634805523f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: [Int] = []\n\
    \    var current_beat = 0\n    for symbol in music_string {\n        if symbol\
    \ == \"o\" {\n            if current_beat < beats.count {\n                beats[current_beat]\
    \ += 1\n            }\n            current_beat += 1\n        } else if symbol\
    \ == \"o|\" {\n            if current_beat < beats.count {\n                beats[current_beat]\
    \ += 2\n            }\n            current_beat += 1\n        } else if symbol\
    \ == \".\" {\n            if current_beat < beats.count {\n                beats[current_beat]\
    \ += 1\n            }\n            current_beat += 1\n        } else {\n     \
    \       current_beat += 1\n        }\n    }\n    return beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpy19w8h7c.swift:20:26: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        } else if symbol == \"\
    o|\" {\n                  ~~~~~~ ^  ~~~~\n/tmp/tmpy19w8h7c.swift:20:26: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        } else if symbol == \"o|\" {\n       \
    \                  ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // TODO: Use regexp or\
    \ another tool to parse music string\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmp3_vcgxt4/tmp3_vcgxt4.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abdb62a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abdb5f9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abdb5f9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abdb5f997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3_vcgxt4                        0x000055681449051f <unavailable> + 5407

    5    libc.so.6                          0x00002abdb648f460 __libc_start_main +
    245

    6    tmp3_vcgxt4                        0x0000556814490059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return parse_music_helper(music_string,\
    \ 0, \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmplwldvx7y.swift:12:12: error: cannot find 'parse_music_helper' in\
    \ scope\n    return parse_music_helper(music_string, 0, \"\")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beatCounts = [Int]()\n\
    \    var lastNoteIndex = 0\n    for character in music_string {\n        if character\
    \ == \"o\" {\n            beatCounts.append(4)\n            lastNoteIndex = 0\n\
    \        } else if character == \"o|\" {\n            beatCounts.append(2)\n \
    \           lastNoteIndex = 0\n        } else if character == \".|\" {\n     \
    \       beatCounts.append(1)\n            lastNoteIndex = 0\n        } else {\n\
    \            if lastNoteIndex > 0 {\n                beatCounts[lastNoteIndex]\
    \ += character == \".|\" ? 1 : character == \"o|\" ? 2 : 3\n            }\n  \
    \          lastNoteIndex += 1\n        }\n    }\n    return beatCounts\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp6hxqg6i9.swift:18:29: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        } else if character ==\
    \ \"o|\" {\n                  ~~~~~~~~~ ^  ~~~~\n/tmp/tmp6hxqg6i9.swift:18:29:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        } else if character == \"\
    o|\" {\n                            ^\n/tmp/tmp6hxqg6i9.swift:21:29: error: binary\
    \ operator '==' cannot be applied to operands of type 'Character' and 'String'\n\
    \        } else if character == \".|\" {\n                  ~~~~~~~~~ ^  ~~~~\n\
    /tmp/tmp6hxqg6i9.swift:21:29: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \ } else if character == \".|\" {\n                            ^\n/tmp/tmp6hxqg6i9.swift:26:56:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n                beatCounts[lastNoteIndex] += character == \".|\"\
    \ ? 1 : character == \"o|\" ? 2 : 3\n                                        \
    \     ~~~~~~~~~ ^  ~~~~\n/tmp/tmp6hxqg6i9.swift:26:56: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n                beatCounts[lastNoteIndex] += character ==\
    \ \".|\" ? 1 : character == \"o|\" ? 2 : 3\n                                 \
    \                      ^\n/tmp/tmp6hxqg6i9.swift:26:80: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'String'\n      \
    \          beatCounts[lastNoteIndex] += character == \".|\" ? 1 : character ==\
    \ \"o|\" ? 2 : 3\n                                                           \
    \          ~~~~~~~~~ ^  ~~~~\n/tmp/tmp6hxqg6i9.swift:26:80: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n                beatCounts[lastNoteIndex] += character ==\
    \ \".|\" ? 1 : character == \"o|\" ? 2 : 3\n                                 \
    \                                              ^\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    return music_string\n \
    \       .split(\" \", maxSplit: music_string.count - 1)\n        .map { noteString\
    \ in\n            guard noteString != \".\" else { return 0 }\n            guard\
    \ noteString != \"o\" else { return 0 }\n            guard noteString != \"o|\"\
    \ else { return 0 }\n            guard noteString != \".|\" else { return 0 }\n\
    \            guard noteString != \"o|\" else { return 0 }\n            guard noteString\
    \ != \".|\" else { return 0 }\n            guard noteString != \"o|\" else { return\
    \ 0 }\n            return 4\n        }\n        .reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpyu8w89p_.swift:13:15: error: incorrect argument labels in call\
    \ (have '_:maxSplit:', expected 'separator:maxSplits:')\n        .split(\" \"\
    , maxSplit: music_string.count - 1)\n              ^     ~~~~~~~~\n          \
    \     separator:  maxSplits\n/tmp/tmpyu8w89p_.swift:24:10: error: cannot convert\
    \ return expression of type 'Int' to return type '[Int]'\n        .reduce(0, +)\n\
    ~~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard let music_notes =\
    \ music_string.components(separatedBy: \" \") else {\n        return []\n    }\n\
    \n    var beats_count = 0\n    var current_beat = 1\n\n    // Iterate through\
    \ each note and determine which type of note it is\n    for note in music_notes\
    \ {\n        if note == \"o\" {\n            beats_count = 1\n        } else if\
    \ note == \"o|\" {\n            beats_count = 2\n        } else if note == \"\
    .|\" {\n            beats_count += 1\n        }\n\n        current_beat += beats_count\n\
    \    }\n\n    // Return the beats count\n    return Array(repeating: beats_count,\
    \ count: music_notes.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp9pfw9juq.swift:12:42: error: value of type 'String' has no member\
    \ 'components'\n    guard let music_notes = music_string.components(separatedBy:\
    \ \" \") else {\n                            ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    // TODO: implement\
    \ parsing of notes\n    \n    // Okay, now comes the hardest part - parsing\n\
    \    // You will need to implement parsing of\n    // notes, each note have it's\
    \ own duration,\n    // as well as \"unparseable\" notes (notes that weren't parsed)\n\
    \    // and those notes are separated by space\n\n    // TODO: implement parsing\
    \ of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement\
    \ parsing of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO:\
    \ implement parsing of notes\n\n    // TODO: implement parsing of notes\n\n  \
    \  // TODO: implement parsing of notes\n\n    // TODO: implement parsing of notes\n\
    \n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing of\
    \ notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing\
    \ of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement\
    \ parsing of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO:\
    \ implement parsing of notes\n\n    // TODO: implement parsing of notes\n\n  \
    \  // TODO: implement parsing of notes\n\n    // TODO: implement parsing of notes\n\
    \n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing of\
    \ notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing\
    \ of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement\
    \ parsing of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO:\
    \ implement parsing of notes\n\n    // TODO: implement parsing of notes\n\n  \
    \  // TODO: implement parsing of notes\n\n    // TODO: implement parsing of notes\n\
    \n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing of\
    \ notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing\
    \ of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement\
    \ parsing of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO:\
    \ implement parsing of notes\n\n    // TODO: implement parsing of notes\n\n  \
    \  // TODO: implement parsing of notes\n\n    // TODO: implement parsing of notes\n\
    \n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing of\
    \ notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing\
    \ of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: implement\
    \ parsing of notes\n\n    // TODO: implement parsing of notes\n\n    // TODO:\
    \ implement parsing of notes\n\n    // TODO: implement parsing of notes\n\n  \
    \  // TODO: implement parsing of notes\n\n    // TODO: implement parsing of notes\n\
    \n    // TODO: implement parsing of notes\n\n    // TODO: implement parsing of\
    \ notes\n\n    // TODO: implement parsing of notes\n\n    // TODO: \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: '/tmp/tmp6cxned3e.swift:132:1: error: missing return in global function
    expected to return ''[Int]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard !music_string.isEmpty\
    \ else { return [] }\n    var beats_per_note = [Int]()\n    var beats_count =\
    \ [0]\n    var current_beat = 0\n    var current_note = 0\n    var last_note =\
    \ 0\n    var last_beat_count = 0\n    var last_beat_direction = .None\n\n    for\
    \ c in music_string {\n        if c == \"o\" {\n            beats_per_note.append(0)\n\
    \            beats_count[0] = current_beat + last_beat_count\n            current_beat\
    \ = 0\n            current_note = 1\n            last_note = last_beat_count +\
    \ last_beat_direction == .Left\n            last_beat_direction = .None\n    \
    \        last_beat_count = 0\n        } else if c == \"o|\" {\n            beats_per_note.append(1)\n\
    \            beats_count[0] = current_beat + last_beat_count\n            current_beat\
    \ = 0\n            current_note = 2\n            last_note = last_beat_count +\
    \ last_beat_direction == .Left\n            last_beat_direction = .Left\n    \
    \        last_beat_count = 0\n        } else if c == \".|\" {\n            beats_per_note.append(2)\n\
    \            beats_count[0] = current_beat + last_beat_count\n            current_beat\
    \ = 0\n            current_note = 3\n            last_note = last_beat_count +\
    \ last_beat_direction == .Left\n            last_beat_direction = .Right\n   \
    \         last_beat_count = 0\n        } else {\n            beats_per_note.append(0)\n\
    \            beats_count[0] = current_beat + last_beat_count\n            current_beat\
    \ = 0\n        }\n        current_beat += beats_count[current_note]\n    }\n \
    \   return beats_per_note\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpimacr21m.swift:19:32: error: reference to member 'None' cannot\
    \ be resolved without a contextual type\n    var last_beat_direction = .None\n\
    \                              ~^~~~\n/tmp/tmpimacr21m.swift:27:63: error: cannot\
    \ assign value of type 'Bool' to type 'Int'\n            last_note = last_beat_count\
    \ + last_beat_direction == .Left\n                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n\
    /tmp/tmpimacr21m.swift:30:21: error: binary operator '==' cannot be applied to\
    \ operands of type 'Character' and 'String'\n        } else if c == \"o|\" {\n\
    \                  ~ ^  ~~~~\n/tmp/tmpimacr21m.swift:30:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        } else if c == \"o|\" {\n                    ^\n/tmp/tmpimacr21m.swift:35:63:\
    \ error: cannot assign value of type 'Bool' to type 'Int'\n            last_note\
    \ = last_beat_count + last_beat_direction == .Left\n                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n\
    /tmp/tmpimacr21m.swift:38:21: error: binary operator '==' cannot be applied to\
    \ operands of type 'Character' and 'String'\n        } else if c == \".|\" {\n\
    \                  ~ ^  ~~~~\n/tmp/tmpimacr21m.swift:38:21: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        } else if c == \".|\" {\n                    ^\n/tmp/tmpimacr21m.swift:43:63:\
    \ error: cannot assign value of type 'Bool' to type 'Int'\n            last_note\
    \ = last_beat_count + last_beat_direction == .Left\n                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014144
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard let music_notes =\
    \ music_string.lowercased().components(separatedBy: \",.\") else {\n        return\
    \ []\n    }\n    var beats = 0\n    var notes: [Int] = []\n    for note in music_notes\
    \ {\n        switch note {\n        case \"o\":\n            notes.append(4)\n\
    \            beats += 4\n        case \"o|\":\n            notes.append(2)\n \
    \           beats += 2\n        case \".|\":\n            notes.append(1)\n  \
    \          beats += 1\n        default:\n            continue\n        }\n   \
    \ }\n    return notes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpdnw0p0tr.swift:12:55: error: value of type 'String' has no member\
    \ 'components'\n    guard let music_notes = music_string.lowercased().components(separatedBy:\
    \ \",.\") else {\n                            ~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music = music_string.components(separatedBy:\
    \ \" \")\n    guard music.count == 26 else {\n        return []\n    }\n\n   \
    \ var notes = [Int]()\n    guard let note_count = music[0] else { return notes\
    \ }\n    for i in 1...note_count {\n        guard let note = music[i] else { break\
    \ }\n        if note == \"o\" {\n            notes.append(4)\n        } else if\
    \ note == \"o|\" {\n            notes.append(2)\n        } else if note == \"\
    .|\" {\n            notes.append(1)\n        }\n    }\n\n    return notes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp7l1wjwg9.swift:12:30: error: value of type 'String' has no member\
    \ 'components'\n    let music = music_string.components(separatedBy: \" \")\n\
    \                ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let split_music = music_string.characters.split\
    \ { $0 == \"|\" || $0 == \"o\" }\n    let beats = split_music\n        .enumerated()\n\
    \        .map { $0.offset(by: 1).element + 1 }\n    return beats\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp_qn7gyos.swift:12:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let split_music = music_string.characters.split { $0\
    \ == \"|\" || $0 == \"o\" }\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp_qn7gyos.swift:15:19: error: cannot call\
    \ value of non-function type 'Int'\n        .map { $0.offset(by: 1).element +\
    \ 1 }\n                  ^\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes = [Int]()\n \
    \   var beats = 0\n    var last_beat = 0\n    var repeats = false\n    for character\
    \ in music_string {\n        switch character {\n        case \"o\":\n       \
    \     notes.append(last_beat)\n            last_beat = 0\n            break\n\
    \        case \"o|\":\n            notes.append(last_beat)\n            last_beat\
    \ = 0\n            repeats = true\n            break\n        case \".|\":\n \
    \           notes.append(beats)\n            beats = 0\n            break\n  \
    \      default:\n            beats = beats*5+Int(character)\n            last_beat\
    \ = beats\n        }\n    }\n    if repeats {\n        for i in 1..<notes.count\
    \ {\n            notes[i] += notes[i-1]\n        }\n    }\n    return notes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp1wu4uxp3.swift:22:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n/tmp/tmp1wu4uxp3.swift:27:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \".|\":\n            \
    \ ^~~~\n/tmp/tmp1wu4uxp3.swift:32:29: error: no exact matches in call to initializer\
    \ \n            beats = beats*5+Int(character)\n                            ^\n\
    Swift.Int:7:12: note: candidate expects value of type 'Float16' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float16)\n           ^\nSwift.Int:10:12:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects\
    \ value of type 'Float80' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value\
    \ of type 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_\
    \ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects\
    \ value of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public\
    \ init(_ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard let music = music_string.unicodeScalars\
    \ else {\n        return []\n    }\n    var beats: Int = 0\n    var beat: Int\
    \ = 0\n    var notes: [Int] = []\n\n    for note in music {\n        switch note\
    \ {\n        case \"o\":\n            beats += 4\n            beat = 0\n     \
    \       notes.append(beats)\n            break\n        case \"o|\":\n       \
    \     beats += 2\n            beat = 0\n            notes.append(beats)\n    \
    \        break\n        case \".|\":\n            beats += 1\n            beat\
    \ = 0\n            notes.append(beats)\n            break\n        default:\n\
    \            beat += 1\n            beats = 0\n            notes.append(beats)\n\
    \        }\n    }\n    return notes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp2abcx2cc.swift:12:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String.UnicodeScalarView'\n    guard let music\
    \ = music_string.unicodeScalars else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2abcx2cc.swift:26:14: error: expression pattern of type 'String' cannot\
    \ match values of type 'Unicode.Scalar'\n        case \"o|\":\n             ^~~~\n\
    /tmp/tmp2abcx2cc.swift:31:14: error: expression pattern of type 'String' cannot\
    \ match values of type 'Unicode.Scalar'\n        case \".|\":\n             ^~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard music_string != \"\
    \" else { return [] }\n    \n    var beats = [Int]()\n    for element in music_string.split(separator:\
    \ \"|\") {\n        beats.append(element == \"o\" ? 1 : element == \".\" ? 3 :\
    \ 4)\n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpc9s9u9uk/tmpc9s9u9uk.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acae4049c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acae3d40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acae3d40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acae3d3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9s9u9uk                        0x00005632f7f2da8f <unavailable> + 6799

    5    libc.so.6                          0x00002acae4235460 __libc_start_main +
    245

    6    tmpc9s9u9uk                        0x00005632f7f2d5c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var music = [Int]()\n \
    \   var current_beat = 0\n    var current_note = 0\n    let current_note_length:\
    \ Int = Int(music_string.characters.count))\n    for (index, char) in music_string.enumerated()\
    \ {\n        if char == \"o\" {\n            music[current_beat] = current_note\n\
    \            current_beat += 1\n            current_note = 0\n        } else if\
    \ char == \"o|\" {\n            music[current_beat] = current_note\n         \
    \   current_beat += 1\n            current_note += 1\n        } else if char ==\
    \ \".|\" {\n            music[current_beat] = current_note\n            current_beat\
    \ += 1\n            current_note += 2\n        } else {\n            current_note\
    \ = int(char)\n        }\n    }\n    music[current_beat] = current_note\n    return\
    \ music\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp0gbwgy4f.swift:15:70: error: consecutive statements on a line must\
    \ be separated by ';'\n    let current_note_length: Int = Int(music_string.characters.count))\n\
    \                                                                     ^\n    \
    \                                                                 ;\n/tmp/tmp0gbwgy4f.swift:15:70:\
    \ error: expected expression\n    let current_note_length: Int = Int(music_string.characters.count))\n\
    \                                                                     ^\n/tmp/tmp0gbwgy4f.swift:15:53:\
    \ error: 'characters' is unavailable: Please use String directly\n    let current_note_length:\
    \ Int = Int(music_string.characters.count))\n                                \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp0gbwgy4f.swift:21:24: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  } else if char == \"o|\" {\n                  ~~~~ ^  ~~~~\n/tmp/tmp0gbwgy4f.swift:21:24:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        } else if char == \"o|\" {\n\
    \                       ^\n/tmp/tmp0gbwgy4f.swift:25:24: error: binary operator\
    \ '==' cannot be applied to operands of type 'String.Element' (aka 'Character')\
    \ and 'String'\n        } else if char == \".|\" {\n                  ~~~~ ^ \
    \ ~~~~\n/tmp/tmp0gbwgy4f.swift:25:24: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (String, String)\n\
    \        } else if char == \".|\" {\n                       ^\n/tmp/tmp0gbwgy4f.swift:30:28:\
    \ error: cannot find 'int' in scope\n            current_note = int(char)\n  \
    \                         ^~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard music_string != \"\
    \" else {\n        return []\n    }\n    \n    guard let music_array = music_string.components(separatedBy:\
    \ \" \") else {\n        return []\n    }\n    \n    let music_array_size = music_array.count\n\
    \    \n    var beats = [Int]()\n    \n    for i in 0..<music_array_size {\n  \
    \      let note = music_array[i]\n        \n        if note.count == 1 {\n   \
    \         beats.append(1)\n        } else if note.count == 2 {\n            beats.append(4)\n\
    \        } else if note.count == 3 {\n            beats.append(4)\n          \
    \  beats.append(2)\n        } else if note.count == 4 {\n            beats.append(4)\n\
    \            beats.append(2)\n            beats.append(1)\n        } else if note.count\
    \ > 4 {\n            beats.append(4)\n            beats.append(2)\n          \
    \  beats.append(1)\n            beats.append(1)\n            beats.append(1)\n\
    \        }\n    }\n    \n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpt57sv3yy.swift:16:42: error: value of type 'String' has no member\
    \ 'components'\n    guard let music_array = music_string.components(separatedBy:\
    \ \" \") else {\n                            ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes: [Int] = []\n\
    \    var beat_counts: [Int] = []\n    var last_beat: [Int]\n    music_string =\
    \ music_string.lowercased()\n    \n    for note in music_string.characters {\n\
    \        switch note {\n        case \"o\":\n            last_beat = [0, 0, 0,\
    \ 0, 0]\n            beat_counts.append(0)\n        case \"o|\":\n           \
    \ last_beat = [0, 0, 0, 0, 0]\n            beat_counts.append(0)\n        case\
    \ \".|\":\n            last_beat = [0, 0, 0, 0, 0]\n            beat_counts.append(0)\n\
    \        default:\n            last_beat = [0, 0, 0, 0, 0]\n            beat_counts.append(0)\n\
    \        }\n    }\n    \n    for note in music_string.characters {\n        switch\
    \ note {\n        case \"o\":\n            last_beat[0] = last_beat[0] + 1\n \
    \           if last_beat[0] == 4 {\n                notes.append(1)\n        \
    \    } else {\n                notes.append(0)\n            }\n        case \"\
    o|\":\n            last_beat[1] = last_beat[1] + 1\n            if last_beat[1]\
    \ == 2 {\n                notes.append(2)\n            } else {\n            \
    \    notes.append(0)\n            }\n        case \".|\":\n            last_beat[2]\
    \ = last_beat[2] + 1\n            if last_beat[2] == 1 {\n                notes.append(3)\n\
    \            } else {\n                notes.append(0)\n            }\n      \
    \  default:\n            last_beat[3] = last_beat[3] + 1\n            if last_beat[3]\
    \ == 1 {\n                notes.append(4)\n            } else {\n            \
    \    notes.append(0)\n            }\n        }\n    }\n    \n    for note in music_string.characters\
    \ {\n        switch note {\n        case \"o\":\n            last_beat[0] = last_beat[0]\
    \ + 1\n            if last_beat[0] == 4 {\n                notes.append(1)\n \
    \           } else {\n                notes.append(0)\n            }\n       \
    \ case \"o|\":\n            last_beat[1] = last_beat[1] + 1\n            if last_beat[1]\
    \ == 2 {\n                notes.append(2)\n            } else {\n            \
    \    notes.append(0)\n            }\n        case \".|\":\n            last_beat[2]\
    \ = last_beat[2] + 1\n            if last_beat[2] == 1 {\n                notes.append(3)\n\
    \            } else {\n                notes.append(0)\n            }\n      \
    \  default:\n            last_beat[3] = last_beat[3] + 1\n            if last_beat[3]\
    \ == 1 {\n                notes.append(4)\n            } else {\n            \
    \    notes.append(0)\n            }\n        }\n    }\n    \n    for note in music_string.characters\
    \ {\n        switch note {\n        case \"o\":\n            last_beat[0] = last_beat[0]\
    \ + 1\n            if last_beat[0] == 4 {\n                notes.append(1)\n \
    \           } else {\n                notes.append(0)\n            }\n       \
    \ case \"o|\":\n            last_beat[1] = last_beat[1] + 1\n            if last_beat[1]\
    \ == 2 {\n                notes.append(2)\n            } else {\n            \
    \    notes.append(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpklkvc2g3.swift:115:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpklkvc2g3.swift:134:87: error: expected '}' at end of 'switch' statement\n\
    assert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4,\
    \ 2, 4, 2])\n                                                                \
    \                      ^\n/tmp/tmpklkvc2g3.swift:101:21: note: to match this opening\
    \ '{'\n        switch note {\n                    ^\n/tmp/tmpklkvc2g3.swift:134:87:\
    \ error: expected '}' at end of brace statement\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])\n                  \
    \                                                                    ^\n/tmp/tmpklkvc2g3.swift:100:41:\
    \ note: to match this opening '{'\n    for note in music_string.characters {\n\
    \                                        ^\n/tmp/tmpklkvc2g3.swift:134:87: error:\
    \ expected '}' at end of brace statement\nassert(parse_music(music_string: \"\
    o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])\n                      \
    \                                                                ^\n/tmp/tmpklkvc2g3.swift:11:49:\
    \ note: to match this opening '{'\nfunc parse_music(music_string: String) -> [Int]\
    \ {\n                                                ^\n/tmp/tmpklkvc2g3.swift:15:5:\
    \ error: cannot assign to value: 'music_string' is a 'let' constant\n    music_string\
    \ = music_string.lowercased()\n    ^~~~~~~~~~~~\n/tmp/tmpklkvc2g3.swift:17:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    for note\
    \ in music_string.characters {\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpklkvc2g3.swift:22:14: error: expression\
    \ pattern of type 'String' cannot match values of type 'Character'\n        case\
    \ \"o|\":\n             ^~~~\n/tmp/tmpklkvc2g3.swift:25:14: error: expression\
    \ pattern of type 'String' cannot match values of type 'Character'\n        case\
    \ \".|\":\n             ^~~~\n/tmp/tmpklkvc2g3.swift:34:30:"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: Int = 0\n  \
    \  var interval: Int = 0\n    var note = \"\"\n    var notes_number = 0\n    var\
    \ number_of_notes_number = 0\n    var number_of_notes = 0\n    var current_note\
    \ = \"\"\n    var is_last_note = false\n    var is_first_note = false\n    \n\
    \    for c in music_string {\n        switch c {\n        case \"o\":\n      \
    \      if current_note != \".\" {\n                if is_last_note {\n       \
    \             notes_number += interval\n                }\n                beats\
    \ += interval\n                interval = 0\n                number_of_notes_number\
    \ += 1\n                current_note = \".\"\n                is_last_note = false\n\
    \                is_first_note = false\n                note = \"\"\n        \
    \    } else {\n                notes_number += interval\n            }\n     \
    \   case \"o|\":\n            if current_note != \".\" {\n                if is_last_note\
    \ {\n                    notes_number += interval\n                }\n       \
    \         beats += interval\n                interval = 0\n                number_of_notes_number\
    \ += 1\n                current_note = \".\"\n                is_last_note = false\n\
    \                is_first_note = false\n                note = \"\"\n        \
    \    } else {\n                notes_number += interval\n            }\n     \
    \   case \".|\":\n            if current_note != \".\" {\n                if is_last_note\
    \ {\n                    notes_number += interval\n                }\n       \
    \         beats += interval\n                interval = 0\n                number_of_notes_number\
    \ += 1\n                current_note = \".\"\n                is_last_note = true\n\
    \                is_first_note = false\n                note = \"\"\n        \
    \    } else {\n                notes_number += interval\n            }\n     \
    \   default:\n            if note != \".\" {\n                if is_last_note\
    \ {\n                    notes_number += interval\n                }\n       \
    \         beats += interval\n                interval = 0\n                number_of_notes_number\
    \ += 1\n                note = \"\"\n                current_note = \"\"\n   \
    \         } else {\n                notes_number += interval\n            }\n\
    \        }\n        note += String(c)\n    }\n    return Array(repeating: beats,\
    \ count: number_of_notes_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpeh1awv4l.swift:39:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \"o|\":\n            \
    \ ^~~~\n/tmp/tmpeh1awv4l.swift:54:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \".|\":\n            \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Your code here\n   \
    \ var beatsArray: [Int] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    var last: Int =\
    \ 0\n    var first: Int = 0\n    var inBetween: Int = 0\n\n    beatsArray[first]\
    \ = last\n    beatsArray[last] = first\n\n    for char in music_string {\n   \
    \     if char == \"o\" {\n            last = first + 4\n            first += 4\n\
    \        }\n        else if char == \"o|\" {\n            last = first + 2\n \
    \           first += 2\n        }\n        else if char == \".|\" {\n        \
    \    last = first + 1\n            first += 1\n        }\n        else {\n   \
    \         first = last\n            last = first + 4\n            first += 4\n\
    \            inBetween = 1\n        }\n        beatsArray[last] = first\n\n  \
    \      if inBetween == 4 {\n            first += 4\n            inBetween = 0\n\
    \        }\n\n    }\n    return beatsArray\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp74ulcfth.swift:26:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        else if char == \"o|\"\
    \ {\n                ~~~~ ^  ~~~~\n/tmp/tmp74ulcfth.swift:26:22: note: overloads\
    \ for '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        else if char == \"o|\" {\n                     ^\n\
    /tmp/tmp74ulcfth.swift:30:22: error: binary operator '==' cannot be applied to\
    \ operands of type 'Character' and 'String'\n        else if char == \".|\" {\n\
    \                ~~~~ ^  ~~~~\n/tmp/tmp74ulcfth.swift:30:22: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        else if char == \".|\" {\n                     ^\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // TODO: Your code here\n\
    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmplx8ltk0c/tmplx8ltk0c.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8b956fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8b9266b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8b9266988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8b92657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplx8ltk0c                        0x00005643f3af351f <unavailable> + 5407

    5    libc.so.6                          0x00002ad8b975b460 __libc_start_main +
    245

    6    tmplx8ltk0c                        0x00005643f3af3059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014143
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var counter = [Int]()\n\
    \    for char in music_string {\n        counter[char == \"o\" ? 0 : 1] += 1\n\
    \    }\n    return counter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b57d0686c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57d037d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b57d037d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b57d037d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b57d037cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b57d017c7ec <unavailable> + 186348

    6    tmp2cb5eebb                        0x000055557426fce8 <unavailable> + 7400

    7    tmp2cb5eebb                        0x000055557426f687 <unavailable> + 5767

    8    libc.so.6                          0x00002b57d0872460 __libc_start_main +
    245

    9    tmp2cb5eebb                        0x000055557426f2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let notes = music_string.split(separator:\
    \ \" \")\n    let beats_per_note = Int32(notes.count / 4)\n    let beats_count\
    \ = Int32(notes.count % 4)\n    var notes_array = [Int]()\n    var index = 0\n\
    \    while index < notes.count {\n        var note = Int32(notes[index])\n   \
    \     var beats = 0\n        if note >= 48 && note <= 57 {\n            note =\
    \ note - 48\n            beats = Int(beats_per_note)\n        } else if note >=\
    \ 64 && note <= 73 {\n            note = note - 64\n            beats = Int(beats_per_note\
    \ * 2)\n        } else if note >= 76 && note <= 83 {\n            note = note\
    \ - 76\n            beats = Int(beats_per_note * 3)\n        } else if note >=\
    \ 86 && note <= 93 {\n            note = note - 86\n            beats = Int(beats_per_note\
    \ * 4)\n        } else {\n            note = note - 94\n            beats = Int(beats_count)\n\
    \        }\n        notes_array.append(beats)\n        index++\n    }\n    return\
    \ notes_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp3iqks4h6.swift:20:12: error: value of optional type 'Int32?' must\
    \ be unwrapped to a value of type 'Int32'\n        if note >= 48 && note <= 57\
    \ {\n           ^\n/tmp/tmp3iqks4h6.swift:20:12: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        if note >=\
    \ 48 && note <= 57 {\n           ^\n                ?? <#default value#>\n/tmp/tmp3iqks4h6.swift:20:12:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if note >= 48 && note <= 57 {\n           ^\n               !\n\
    /tmp/tmp3iqks4h6.swift:20:26: error: value of optional type 'Int32?' must be unwrapped\
    \ to a value of type 'Int32'\n        if note >= 48 && note <= 57 {\n        \
    \                 ^\n/tmp/tmp3iqks4h6.swift:20:26: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        if note >=\
    \ 48 && note <= 57 {\n                         ^\n                           \
    \   ?? <#default value#>\n/tmp/tmp3iqks4h6.swift:20:26: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        if note\
    \ >= 48 && note <= 57 {\n                         ^\n                        \
    \     !\n/tmp/tmp3iqks4h6.swift:21:20: error: value of optional type 'Int32?'\
    \ must be unwrapped to a value of type 'Int32'\n            note = note - 48\n\
    \                   ^\n/tmp/tmp3iqks4h6.swift:21:20: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n            note\
    \ = note - 48\n                   ^\n                   (    ?? <#default value#>)\n\
    /tmp/tmp3iqks4h6.swift:21:20: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            note = note - 48\n       \
    \            ^\n                       !\n/tmp/tmp3iqks4h6.swift:23:19: error:\
    \ value of optional type 'Int32?' must be unwrapped to a value of type 'Int32'\n\
    \        } else if note >= 64 && note <= 73 {\n                  ^\n/tmp/tmp3iqks4h6.swift:23:19:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        } els"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Add your code here\n\
    \    var beats = [Int]()\n    let length = music_string.characters.count\n   \
    \ for (_, position) in music_string.enumerated() {\n        let c = music_string[position]\n\
    \        if c == \"o\" {\n            beats.append(1)\n        }\n        else\
    \ if c == \"|\" {\n            beats.append(2)\n        }\n        else if c ==\
    \ \".\" {\n            beats.append(4)\n        }\n    }\n    return beats\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp7ih8ghgh.swift:14:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = music_string.characters.count\n      \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp7ih8ghgh.swift:16:29: error: no exact matches in call to\
    \ subscript \n        let c = music_string[position]\n                       \
    \     ^\nSwift.String:12:12: note: candidate expects value of type 'String.Index'\
    \ for parameter #1 (got 'String.Element' (aka 'Character'))\n    public subscript(i:\
    \ String.Index) -> Character { get }\n           ^\nSwift.String:3:12: note: candidate\
    \ expects value of type 'Range<String.Index>' for parameter #1 (got 'String.Element'\
    \ (aka 'Character'))\n    public subscript(r: Range<String.Index>) -> Substring\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'String.Element' (aka\
    \ 'Character'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var notes: [Int] = [0]\n\
    \    var current_beat = 0\n    for c in music_string {\n        switch c {\n \
    \       case \".\":\n            notes.append(current_beat)\n            current_beat\
    \ = 0\n        case \".|\":\n            current_beat = 1\n        case _:\n \
    \           current_beat++\n        default:\n            break\n        }\n \
    \   }\n    notes.append(current_beat)\n    return notes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp274b9b3r.swift:19:14: error: expression pattern of type 'String'\
    \ cannot match values of type 'Character'\n        case \".|\":\n            \
    \ ^~~~\n/tmp/tmp274b9b3r.swift:22:25: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            current_beat++\n                        ^~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats: Int = 0\n  \
    \  var notes: [Int] = []\n    var current: Int = 0\n    var last: Int = 0\n  \
    \  var notesLast: Int = 0\n    var lastNotes: [Int] = []\n    \n    // Convert\
    \ input string to array\n    var musicArray = music_string.components(separatedBy:\
    \ \"|\")\n    \n    // Initialize counters\n    for index in 0..<musicArray.count\
    \ {\n        notesLast = 0\n        last = 0\n        \n        // Get first note\
    \ of array\n        current = Int(musicArray[index]) ?? 0\n        \n        //\
    \ Add one to counter and save note to array until it changes note\n        lastNotes.append(last)\n\
    \        notes.append(current)\n        \n        // Set counter to next note\n\
    \        last = current\n        notesLast = last\n        \n        // Iterate\
    \ over next note\n        for index2 in 0..<(index + 1) {\n            \n    \
    \        // Change note depending on how many notes are in between current note\
    \ and last note\n            switch notes[index2] {\n            case 0 ..< 4:\n\
    \                if notesLast == 4 {\n                    last = 4\n         \
    \       } else if notesLast == 0 {\n                    last = 0\n           \
    \     } else {\n                    last = 1\n                }\n            case\
    \ 5:\n                last = lastNotes[index2 + 1]\n            default:\n   \
    \             last = 0\n            }\n            \n            // Save note\
    \ to array\n            lastNotes.append(last)\n            notes.append(current)\n\
    \            \n            // Set counter to next note\n            last = current\n\
    \            notesLast = last\n        }\n    }\n    \n    // Return array which\
    \ contains how many beats each note lasts\n    return notes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpysqvda4u.swift:20:35: error: value of type 'String' has no member\
    \ 'components'\n    var musicArray = music_string.components(separatedBy: \"|\"\
    )\n                     ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    if music_string == \"\"\
    \ {\n        return []\n    }\n\n    var num_beats = [Int]()\n    var notes: [String]\
    \ = String()\n    var num_beat = 1\n    var beat = 1\n\n    for c in music_string\
    \ {\n        if notes == nil {\n            notes = [c]\n            continue\n\
    \        }\n\n        if c == '.' {\n            num_beats[num_beat - beat] +=\
    \ 1\n            beat = 1\n            notes.removeLast()\n            num_beat\
    \ = 1\n            continue\n        }\n\n        if c == '|' {\n            num_beats[num_beat\
    \ - beat] += 1\n            beat = 1\n            notes.removeLast()\n       \
    \     num_beat = 1\n            notes.insert(0, '|')\n            continue\n \
    \       }\n\n        if c == 'o' {\n            num_beats[num_beat - beat] +=\
    \ 1\n            notes.removeLast()\n            num_beat = 1\n            beat\
    \ = 1\n            continue\n        }\n    }\n\n    return num_beats\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp8amjwhyb.swift:27:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '.' {\n                ^~~\n                \".\"\n\
    /tmp/tmp8amjwhyb.swift:35:17: error: single-quoted string literal found, use '\"\
    '\n        if c == '|' {\n                ^~~\n                \"|\"\n/tmp/tmp8amjwhyb.swift:40:29:\
    \ error: single-quoted string literal found, use '\"'\n            notes.insert(0,\
    \ '|')\n                            ^~~\n                            \"|\"\n/tmp/tmp8amjwhyb.swift:44:17:\
    \ error: single-quoted string literal found, use '\"'\n        if c == 'o' {\n\
    \                ^~~\n                \"o\"\n/tmp/tmp8amjwhyb.swift:17:27: error:\
    \ cannot convert value of type 'String' to specified type '[String]'\n    var\
    \ notes: [String] = String()\n                          ^~~~~~~~\n/tmp/tmp8amjwhyb.swift:22:18:\
    \ warning: comparing non-optional value of type '[String]' to 'nil' always returns\
    \ false\n        if notes == nil {\n           ~~~~~ ^  ~~~\n/tmp/tmp8amjwhyb.swift:23:22:\
    \ error: cannot convert value of type 'Character' to expected element type 'String'\n\
    \            notes = [c]\n                     ^\n/tmp/tmp8amjwhyb.swift:40:19:\
    \ error: no exact matches in call to instance method 'insert'\n            notes.insert(0,\
    \ '|')\n                  ^\n/tmp/tmp8amjwhyb.swift:40:19: note: candidate has\
    \ partially matching parameter list (__owned String, at: Int)\n            notes.insert(0,\
    \ '|')\n                  ^\n/tmp/tmp8amjwhyb.swift:40:19: note: candidate has\
    \ partially matching parameter list (__owned String, at: Array<String>.Index)\n\
    \            notes.insert(0, '|')\n                  ^\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var result: [Int] = Array(0..<100)\n\
    \    for i in 0..<music_string.characters.count {\n        let char_index = music_string.index(music_string.startIndex,\
    \ offsetBy: i)\n        let char = music_string[char_index]\n        switch char\
    \ {\n        case \"o\":\n            result[i] = 4\n        case \"o|\":\n  \
    \          result[i] = 2\n        case \".|\":\n            result[i] = 1\n  \
    \      default:\n            result[i] = 0\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpjol60yc4.swift:13:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<music_string.characters.count {\n    \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpjol60yc4.swift:19:14: error: expression pattern of type\
    \ 'String' cannot match values of type 'Character'\n        case \"o|\":\n   \
    \          ^~~~\n/tmp/tmpjol60yc4.swift:21:14: error: expression pattern of type\
    \ 'String' cannot match values of type 'Character'\n        case \".|\":\n   \
    \          ^~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats_per_note: [Int]\
    \ = []\n    for note in music_string {\n        switch note {\n        case \"\
    o\":\n            beats_per_note.append(4)\n        case \"|\":\n            beats_per_note.append(2)\n\
    \        default:\n            beats_per_note.append(1)\n        }\n    }\n  \
    \  return beats_per_note\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmp46729pvv/tmp46729pvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c4a5d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c4a2cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c4a2cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c4a2ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp46729pvv                        0x000056367b43371f <unavailable> + 5919

    5    libc.so.6                          0x00002b0c4a7c0460 __libc_start_main +
    245

    6    tmp46729pvv                        0x000056367b433259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beat_counts: [Int]\
    \ = [0, 0, 0, 0, 0, 0]\n    var beats_per_note = [0, 4, 2, 3, 2, 4, 3, 3]\n  \
    \  let music_chars = music_string.characters\n\n    for i in 0..<music_string.characters.count\
    \ {\n        let char = music_chars[i]\n        if char == \" \" {\n         \
    \   // skip the space\n        } else if char == \"o\" || char == \"O\" {\n  \
    \          // whole note\n            beats_per_note[beats_per_note.count - 4]\
    \ = beats_per_note[beats_per_note.count - 4] + 4\n            beat_counts[beat_counts.count\
    \ - 1] += 1\n        } else if char == \"|\" || char == \"|\" {\n            //\
    \ half note\n            beats_per_note[beats_per_note.count - 2] = beats_per_note[beats_per_note.count\
    \ - 2] + 2\n            beat_counts[beat_counts.count - 1] += 1\n        } else\
    \ if char == \".\" || char == \"|\" {\n            // quater note\n          \
    \  beats_per_note[beats_per_note.count - 1] = 1\n            beat_counts[beat_counts.count\
    \ - 1] += 1\n        } else {\n            fatalError(\"invalid music char: \\\
    (char)\")\n        }\n    }\n    return beat_counts\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp91_hc13q.swift:14:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let music_chars = music_string.characters\n       \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp91_hc13q.swift:16:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    for i in 0..<music_string.characters.count {\n\
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp91_hc13q.swift:17:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ char = music_chars[i]\n                   ^~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    music_string = music_string.replacingOccurrences(of:\
    \ \".\", with: \"|\")\n    music_string = music_string.replacingOccurrences(of:\
    \ \"o\", with: \"|\")\n\n    let note_strings = music_string.components(separatedBy:\
    \ \"|\")\n    var note_string = note_strings.first!\n    var notes: [Int] = []\n\
    \    var beats = 0\n    var lasts: Int = 0\n\n    while note_string != \"\" {\n\
    \        note_strings.remove(at: note_strings.first!.firstIndex(of: \"|\"))\n\
    \        note_string = note_strings.first!\n        lasts = 0\n        notes.append(0)\n\
    \    }\n    note_string = note_strings.first!\n\n    while note_string != \"\"\
    \ {\n        let note_length = note_string.split(separator: \"|\").count\n   \
    \     note_string = note_strings.first!\n        lasts = 0\n        notes.append(0)\n\
    \        for _ in 0..<note_length {\n            let index = note_string.index(note_string.startIndex,\
    \ offsetBy: 1)\n            let beat = note_string[index..<(index + 3)].count\n\
    \            lasts += beat\n            notes.append(lasts)\n        }\n    }\n\
    \    return notes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpxh2p537z.swift:12:5: error: cannot assign to value: 'music_string'\
    \ is a 'let' constant\n    music_string = music_string.replacingOccurrences(of:\
    \ \".\", with: \"|\")\n    ^~~~~~~~~~~~\n/tmp/tmpxh2p537z.swift:12:33: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    music_string\
    \ = music_string.replacingOccurrences(of: \".\", with: \"|\")\n              \
    \     ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxh2p537z.swift:13:5: error: cannot\
    \ assign to value: 'music_string' is a 'let' constant\n    music_string = music_string.replacingOccurrences(of:\
    \ \"o\", with: \"|\")\n    ^~~~~~~~~~~~\n/tmp/tmpxh2p537z.swift:13:33: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    music_string\
    \ = music_string.replacingOccurrences(of: \"o\", with: \"|\")\n              \
    \     ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxh2p537z.swift:15:37: error:\
    \ value of type 'String' has no member 'components'\n    let note_strings = music_string.components(separatedBy:\
    \ \"|\")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    guard let notes = music_string.components(separatedBy:\
    \ \" \") else {\n        return []\n    }\n    var result: [Int] = []\n    var\
    \ beats: [Int] = []\n    var currentBeats: [Int] = []\n    var lastNote = Int(notes[0])!\n\
    \    for note in notes {\n        guard let noteAsInt = Int(note) else {\n   \
    \         return result\n        }\n        let lastNoteIndex = notes.firstIndex(of:\
    \ note)\n        beats.append(noteAsInt)\n        if lastNoteIndex == 0 {\n  \
    \          currentBeats.append(noteAsInt)\n        } else {\n            for (idx,\
    \ noteInd) in notes.enumerated() {\n                if noteInd == note {\n   \
    \                 currentBeats.append(noteAsInt)\n                    break\n\
    \                }\n            }\n            guard noteAsInt - lastNote == 1\
    \ else {\n                result.append(0)\n                continue\n       \
    \     }\n            let beatsDifference = noteAsInt - lastNote\n            let\
    \ beatsDiffArray = [Int](repeating: beatsDifference, count: beats.count)\n   \
    \         let currentBeatsArray = [Int](repeating: currentBeats.last!, count:\
    \ beats.count)\n            let sumBeatsArray = currentBeatsArray.append(contentsOf:\
    \ beatsDiffArray)\n            result.append(sumBeatsArray.count)\n          \
    \  lastNote = noteAsInt\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp4j1gzpr4.swift:12:36: error: value of type 'String' has no member\
    \ 'components'\n    guard let notes = music_string.components(separatedBy: \"\
    \ \") else {\n                      ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp4j1gzpr4.swift:41:51:\
    \ error: no exact matches in call to instance method 'append'\n            let\
    \ sumBeatsArray = currentBeatsArray.append(contentsOf: beatsDiffArray)\n     \
    \                                             ^\n/tmp/tmp4j1gzpr4.swift:41:51:\
    \ note: found candidate with type '(__owned _) -> ()'\n            let sumBeatsArray\
    \ = currentBeatsArray.append(contentsOf: beatsDiffArray)\n                   \
    \                               ^\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    // Initialize an array\
    \ and add the first element in the array as 1\n    var beats = [Int](repeating:\
    \ 1, count: music_string.count)\n    // Iterate through each character and find\
    \ the index\n    for (_, element) in music_string.enumerated() {\n        if element\
    \ == \"o\" {\n            beats[music_string.index(before: element)! - 1] += 1\n\
    \        } else if element == \"o|\" {\n            beats[music_string.index(before:\
    \ element)! - 1] += 2\n        } else if element == \".|\" {\n            beats[music_string.index(before:\
    \ element)! - 1] += 1\n        }\n    }\n    return beats\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpr1q_f81t.swift:17:46: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String.Index'\n            beats[music_string.index(before:\
    \ element)! - 1] += 1\n                                             ^\n/tmp/tmpr1q_f81t.swift:17:54:\
    \ error: cannot force unwrap value of non-optional type 'String.Index'\n     \
    \       beats[music_string.index(before: element)! - 1] += 1\n               \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n                                   \
    \                  \n/tmp/tmpr1q_f81t.swift:17:54: error: cannot convert value\
    \ of type 'String.Index' to expected argument type 'Int'\n            beats[music_string.index(before:\
    \ element)! - 1] += 1\n                                                     ^\n\
    /tmp/tmpr1q_f81t.swift:18:27: error: binary operator '==' cannot be applied to\
    \ operands of type 'String.Element' (aka 'Character') and 'String'\n        }\
    \ else if element == \"o|\" {\n                  ~~~~~~~ ^  ~~~~\n/tmp/tmpr1q_f81t.swift:18:27:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        } else if element == \"o|\"\
    \ {\n                          ^\n/tmp/tmpr1q_f81t.swift:19:46: error: cannot\
    \ convert value of type 'String.Element' (aka 'Character') to expected argument\
    \ type 'String.Index'\n            beats[music_string.index(before: element)!\
    \ - 1] += 2\n                                             ^\n/tmp/tmpr1q_f81t.swift:19:54:\
    \ error: cannot force unwrap value of non-optional type 'String.Index'\n     \
    \       beats[music_string.index(before: element)! - 1] += 2\n               \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n                                   \
    \                  \n/tmp/tmpr1q_f81t.swift:19:54: error: cannot convert value\
    \ of type 'String.Index' to expected argument type 'Int'\n            beats[music_string.index(before:\
    \ element)! - 1] += 2\n                                                     ^\n\
    /tmp/tmpr1q_f81t.swift:20:27: error: binary operator '==' cannot be applied to\
    \ operands of type 'Stri"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var beats = [Int]()\n \
    \   var current_beat = 0\n    for character in music_string {\n        // Ignore\
    \ whitespace\n        if character == ' ' {\n            continue\n        }\n\
    \        \n        // Ignore note endings\n        if character == '|' {\n   \
    \         current_beat = 0\n            beats.append(current_beat)\n         \
    \   continue\n        }\n        \n        // Ignore rests\n        if character\
    \ == 'r' {\n            continue\n        }\n        \n        // Parse note\n\
    \        switch character {\n        case 'o':\n            current_beat += 4\n\
    \            break\n        case 'o|':\n            current_beat += 2\n      \
    \      break\n        case '.|':\n            current_beat += 1\n            break\n\
    \        }\n        \n        beats.append(current_beat)\n    }\n    \n    return\
    \ beats\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpxenogf50.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == ' ' {\n                        ^~~\n     \
    \                   \" \"\n/tmp/tmpxenogf50.swift:21:25: error: single-quoted\
    \ string literal found, use '\"'\n        if character == '|' {\n            \
    \            ^~~\n                        \"|\"\n/tmp/tmpxenogf50.swift:28:25:\
    \ error: single-quoted string literal found, use '\"'\n        if character ==\
    \ 'r' {\n                        ^~~\n                        \"r\"\n/tmp/tmpxenogf50.swift:34:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'o':\n   \
    \          ^~~\n             \"o\"\n/tmp/tmpxenogf50.swift:37:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o|':\n             ^~~~\n    \
    \         \"o|\"\n/tmp/tmpxenogf50.swift:40:14: error: single-quoted string literal\
    \ found, use '\"'\n        case '.|':\n             ^~~~\n             \".|\"\n\
    /tmp/tmpxenogf50.swift:37:14: error: expression pattern of type 'String' cannot\
    \ match values of type 'Character'\n        case 'o|':\n             ^~~~\n/tmp/tmpxenogf50.swift:40:14:\
    \ error: expression pattern of type 'String' cannot match values of type 'Character'\n\
    \        case '.|':\n             ^~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var temp = [Int]()\n  \
    \  for i in 1..<music_string.count {\n        if music_string[(i-1) % 8] != \"\
    .\" {\n            temp.append(4)\n        } else {\n            if music_string[(i-1)\
    \ % 8] == \".\" && music_string[(i+1) % 8] == \".\" {\n                temp.append(1)\n\
    \            } else {\n                temp.append(2)\n            }\n       \
    \ }\n    }\n    return temp\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp4opswenu.swift:14:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if music_string[(i-1)\
    \ % 8] != \".\" {\n           ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp4opswenu.swift:17:16: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            if music_string[(i-1) % 8] == \".\" && music_string[(i+1)\
    \ % 8] == \".\" {\n               ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4opswenu.swift:17:50:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if music_string[(i-1) % 8] == \".\"\
    \ && music_string[(i+1) % 8] == \".\" {\n                                    \
    \             ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    \n    let notes = [\n \
    \       \"o\",\n        \"o|\",\n        \".|\",\n    ]\n    var beats = [Int](repeating:\
    \ 0, count: notes.count)\n    \n    guard let notes_in_string = music_string.components(separatedBy:\
    \ \" \") else {\n        print(\"No notes in string\")\n        return beats\n\
    \    }\n    \n    var current_beat = 0\n    for note in notes_in_string {\n  \
    \      \n        let note_index = notes.index(of: note)\n        beats[note_index]\
    \ += current_beat\n        \n        if note_index + 1 < notes.count {\n     \
    \       current_beat = 0\n        } else {\n            current_beat = 1\n   \
    \     }\n        \n    }\n    return beats\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_music(music_string: \"\") == [] as [Int])\nassert(parse_music(music_string:\
    \ \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\"\
    ) == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o| .| .| o o o o\")\
    \ == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string: \"o| .| o| .|\
    \ o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: SyntaxError
  stderr: "/tmp/tmplzatr1bn.swift:20:46: error: value of type 'String' has no member\
    \ 'components'\n    guard let notes_in_string = music_string.components(separatedBy:\
    \ \" \") else {\n                                ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    let music_words = music_string.split(separator:\
    \ \" \")\n\n    var counts: [Int] = [0]\n    for i in 0 ..< music_words.count\
    \ {\n        if let last_char = music_words[i].last {\n            if last_char\
    \ == \"|\" {\n                counts[0] += 2\n            } else if last_char\
    \ == \"o\" {\n                counts[0] += 4\n            } else {\n         \
    \       counts[0] += 1\n            }\n        }\n    }\n\n    return counts\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_music(music_string: \"\") == [] as [Int])\n\
    assert(parse_music(music_string: \"o o o o\") == [4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \".| .| .| .|\") == [1, 1, 1, 1])\nassert(parse_music(music_string: \"o| o|\
    \ .| .| o o o o\") == [2, 2, 1, 1, 4, 4, 4, 4])\nassert(parse_music(music_string:\
    \ \"o| .| o| .| o o| o o|\") == [2, 1, 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmpoplzt1vz/tmpoplzt1vz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6312fb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6312caeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6312cae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6312cad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoplzt1vz                        0x000055e2440a894e <unavailable> + 6478

    5    libc.so.6                          0x00002b63131a3460 __libc_start_main +
    245

    6    tmpoplzt1vz                        0x000055e2440a8599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1660014143
- exit_code: -4
  program: "\n/// Input to this function is a string representing musical notes in\
    \ a special ASCII format.\n/// Your task is to parse this string and return array\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(music_string:\
    \ \"o o| .| o| o| .| .| .| .| o o\")\n/// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    func parse_music(music_string: String) -> [Int] {\n    var note_count = 0\n  \
    \  var notes_array = [Int]()\n    for c in music_string {\n        if c == \"\
    .\" {\n            note_count += 1\n            notes_array.append(note_count)\n\
    \        } else {\n            if c == \"o\" || c == \"|\" {\n               \
    \ note_count += 1\n            } else {\n                note_count = 1\n    \
    \            notes_array.append(note_count)\n            }\n        }\n    }\n\
    \    return notes_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_music(music_string:\
    \ \"\") == [] as [Int])\nassert(parse_music(music_string: \"o o o o\") == [4,\
    \ 4, 4, 4])\nassert(parse_music(music_string: \".| .| .| .|\") == [1, 1, 1, 1])\n\
    assert(parse_music(music_string: \"o| o| .| .| o o o o\") == [2, 2, 1, 1, 4, 4,\
    \ 4, 4])\nassert(parse_music(music_string: \"o| .| o| .| o o| o o|\") == [2, 1,\
    \ 2, 1, 4, 2, 4, 2])"
  status: Exception
  stderr: 'tmp1bkg8dnz/tmp1bkg8dnz.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada7feb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada7fba8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada7fba8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada7fba77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1bkg8dnz                        0x000055bbaec7176f <unavailable> + 5999

    5    libc.so.6                          0x00002ada8009d460 __libc_start_main +
    245

    6    tmp1bkg8dnz                        0x000055bbaec712a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660014143
