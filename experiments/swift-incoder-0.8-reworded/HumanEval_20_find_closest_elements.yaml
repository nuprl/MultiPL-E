name: HumanEval_20_find_closest_elements
language: swift
prompt: "\n/// From a supplied array of numbers (of length at least two) select and\
  \ return two that are the closest to each\n/// other and return them in order (smaller\
  \ number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0,\
  \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers:\
  \ [Double]) -> (Double, Double) {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0,\
  \ 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
  \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
  \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
  \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
completions: ["    // sort numbers from smallest to largest\n    let sortedNumbers\
    \ = numbers.sorted()\n\n    // iterate from sorted numbers to find the first number\
    \ greater than the number passed in\n    var currentMinNumber = sortedNumbers[0]\n\
    \n    // set variable to the index of the next number greater than the number\
    \ passed in (as long as the numbers are sorted)\n    var currentMaxIndex = 0\n\
    \n    // set variable to the number passed in so that we can check if a number\
    \ passed in is greater than the smallest number in the array\n    var currentMaxNumber\
    \ = numbers[0]\n\n    for index in sortedNumbers.indices {\n        if numbers[index]\
    \ > currentMaxNumber {\n            currentMaxNumber = numbers[index]\n      \
    \      currentMaxIndex = index\n        }\n    }\n\n    // return the two numbers\
    \ that are closest to each other\n    return (sortedNumbers[currentMaxIndex],\
    \ sortedNumbers[currentMaxIndex])", "    let min1 = numbers[0]\n    let max1 =\
    \ numbers[0]\n    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for n\
    \ in numbers {\n        let tmpMin = min1\n        let tmpMax = max1\n       \
    \ if n < min1 {\n            min2 = min1\n            min1 = n\n        }\n  \
    \      if n > max1 {\n            max2 = max1\n            max1 = n\n        }\n\
    \        if tmpMin < tmpMax {\n            min2 = min1\n            min1 = n\n\
    \        }\n        if tmpMin > tmpMax {\n            max2 = max1\n          \
    \  max1 = n\n        }\n    }\n    return (min1, min2)", "    // TODO: Optimize\
    \ with SIMD?\n    if numbers.count == 0 {\n        return (numbers[0], numbers[0])\n\
    \    }\n    guard let low = numbers.first,\n        let high = numbers.last else\
    \ {\n            return (numbers[0], numbers[0])\n    }\n    var lowFound = false\n\
    \    var highFound = false\n    var candidate = low\n\n    for x in numbers {\n\
    \        if x != candidate {\n            let diff = abs(x - candidate)\n    \
    \        if diff < abs(x - high) {\n                candidate = x\n          \
    \      lowFound = true\n            } else if diff < abs(x - low) {\n        \
    \        candidate = x\n                highFound = true\n            }\n    \
    \    }\n    }\n    return (candidate, lowFound ? low : high)", "    // Find the\
    \ closest two numbers from our two numbers.\n    var closest = (numbers[0], numbers[0])\n\
    \    var furthest = (numbers[0], numbers[0])\n    for i in 1..numbers.count {\n\
    \        if numbers[i] > closest[1] {\n            closest = (numbers[i], numbers[i])\n\
    \        }\n        if numbers[i] < furthest[1] {\n            furthest = (numbers[i],\
    \ numbers[i])\n        }\n    }\n    return (closest[1], furthest[1])", "    let\
    \ smallest = numbers[0]\n    let largest = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n \
    \       }\n        if numbers[i] > largest {\n            largest = numbers[i]\n\
    \        }\n    }\n    return (smallest, largest)", "    var minimum = Double()\n\
    \    var result = Double()\n    numbers.sort { $0 > $1 }\n    for i in 0..<numbers.count\
    \ {\n        if i == 0 {\n            result = numbers[i]\n        } else {\n\
    \            if abs(numbers[i] - result) < abs(minimum - numbers[i]) {\n     \
    \           minimum = numbers[i]\n                result = numbers[i]\n      \
    \      }\n        }\n    }\n    return (result, minimum)", "    if numbers.count\
    \ < 2 {\n        return numbers[0], numbers[0]\n    }\n\n    let first: Double\
    \ = numbers.sorted()[0]\n    let last: Double = numbers.sorted().last!\n\n   \
    \ let firstIndex: Int = numbers.index(of: first)!\n    let lastIndex: Int = numbers.index(of:\
    \ last)!\n    if lastIndex < firstIndex {\n        return numbers[firstIndex],\
    \ numbers[lastIndex]\n    }\n\n    let midIndex: Int = firstIndex + (lastIndex\
    \ - firstIndex) / 2\n\n    let midElement = numbers[midIndex]\n\n    let closest1\
    \ = numbers.sorted()[midIndex - 1]\n    let closest2 = numbers.sorted()[midIndex]\n\
    \n    if closest1 < closest2 {\n        return closest1, midElement\n    } else\
    \ {\n        return midElement, closest2\n    }", "    guard numbers.count >=\
    \ 2 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 1 else\
    \ { return (numbers[0], numbers[0]) }\n    var smallest = numbers[0]\n    var\
    \ largest = numbers[0]\n    var smallestIndex = -1\n    var largestIndex = -1\n\
    \    for index in 0..<numbers.count - 1 {\n        let item = numbers[index]\n\
    \        if item < smallest {\n            smallest = item\n            smallestIndex\
    \ = index\n        }\n        if item > largest {\n            largest = item\n\
    \            largestIndex = index\n        }\n    }\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])", "    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)", "    var closest1 = numbers[0]\n    var closest2 = numbers[0]\n\
    \    for number in numbers {\n        let distance1 = fabs(number - closest1)\n\
    \        let distance2 = fabs(number - closest2)\n        if distance1 <= distance2\
    \ {\n            closest1 = number\n        }\n        else {\n            closest2\
    \ = number\n        }\n    }\n    return (closest1, closest2)", "    if numbers.count\
    \ < 2 {\n        return (-1.0, -1.0)\n    }\n\n    let min_num = numbers[0]\n\
    \    var closest_nums = [Double]()\n    var min_dist = Float.greatestFiniteMagnitude\n\
    \n    for num in numbers {\n        var temp_dist = distance(min_num, num)\n \
    \       if min_dist > temp_dist {\n            min_dist = temp_dist\n        \
    \    closest_nums = [num]\n        } else {\n            closest_nums.append(num)\n\
    \        }\n    }\n\n    return (min_num, min_dist)", "    // Find the smallest\
    \ value\n    let minValue = min(numbers)\n    // Find the largest value\n    let\
    \ maxValue = max(numbers)\n    // Find the two closest to each other\n    var\
    \ closestToEachOther : Double? = nil\n    if maxValue - minValue < 1e-10 {\n \
    \       return (minValue, maxValue)\n    }\n    for number in numbers {\n    \
    \    let distance = (number - minValue).abs()\n        if closestToEachOther ==\
    \ nil || distance < closestToEachOther! {\n            closestToEachOther = number\n\
    \        }\n    }\n    return (closestToEachOther!, minValue)", "  guard numbers.count\
    \ >= 2 else { return (numbers[0], numbers[1]) }\n\n  var largest = numbers[0]\n\
    \  var smallest = numbers[0]\n  var largestIndex = -1\n  var smallestIndex = -1\n\
    \n  for index in 1..<numbers.count {\n    let value = numbers[index]\n\n    if\
    \ value > largest {\n      largest = value\n      largestIndex = index\n    }\n\
    \n    if value < smallest {\n      smallest = value\n      smallestIndex = index\n\
    \    }\n  }\n\n  return (largest, numbers[largestIndex])", "    guard numbers.count\
    \ >= 2 else {\n        fatalError(\"not enough numbers\")\n    }\n\n    var smallest:\
    \ Double = numbers.first!\n    var largest: Double = numbers.last!\n    for number\
    \ in numbers {\n        let delta = abs(number - largest)\n        if delta <\
    \ smallest {\n            smallest = delta\n        } else if delta > largest\
    \ {\n            largest = delta\n        }\n    }\n    return (largest, smallest)",
  "    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number in\
    \ numbers {\n        if smallest > number {\n            smallest = number\n \
    \       }\n        if largest < number {\n            largest = number\n     \
    \   }\n    }\n    return (smallest, largest)", "    var min1: Double = 0\n   \
    \ var min2: Double = 0\n    for number in numbers {\n        let diff1 = abs(number-number1)\n\
    \        let diff2 = abs(number-number2)\n        if diff1 < diff2 {\n       \
    \     min1 = number\n        } else {\n            min2 = number\n        }\n\
    \    }\n    return (min1, min2)", "    if numbers.isEmpty {\n        return (0.0,\
    \ 0.0)\n    }\n    let sortedNumbers = numbers.sorted()\n    let firstClosest\
    \ = sortedNumbers.first!\n    let secondClosest = sortedNumbers.last!\n    return\
    \ (firstClosest, secondClosest)", "    let sorted_numbers = numbers.sorted(by:\
    \ { $0 < $1 })\n    return (sorted_numbers[0], sorted_numbers[1])", "    var smallest\
    \ = Double.infinity\n    var largest = -Double.infinity\n\n    for n in numbers\
    \ {\n        if n < smallest {\n            smallest = n\n        }\n\n      \
    \  if n > largest {\n            largest = n\n        }\n    }\n\n    return (smallest\
    \ < largest ? smallest : largest)", "    if numbers.isEmpty {\n        return\
    \ (numbers[0], numbers[0])\n    }\n\n    var min: Double?\n    var max: Double?\n\
    \n    for number in numbers {\n        if min == nil {\n            min = number\n\
    \            max = number\n            continue\n        }\n        if number\
    \ < min! {\n            min = number\n        }\n        if number > max! {\n\
    \            max = number\n        }\n    }\n    return (min!, max!)", "    if\
    \ numbers.isEmpty {\n        return 0.0, 0.0\n    }\n    \n    if numbers.count\
    \ == 2 {\n        return numbers[0], numbers[1]\n    }\n    \n    let numberToClosest\
    \ = numbers[0]\n    var closestIndex = 1 // Index of first number closer to our\
    \ first number\n    var closestDist = Double(Double.max)\n    for i in 0 ..< numbers.count\
    \ - 1 {\n        let currentNumber = numbers[i + 1]\n        let currentDist =\
    \ distance(numberToClosest, currentNumber)\n        \n        if currentDist <\
    \ closestDist {\n            closestDist = currentDist\n            closestIndex\
    \ = i + 1\n        }\n    }\n    \n    return numbers[closestIndex], numberToClosest",
  "    if numbers.isEmpty {\n        return (nil, nil)\n    }\n\n    var smallestValue\
    \ = Double(numbers[0])\n    var smallestIndex = 0\n\n    var largestValue = Double(numbers[0])\n\
    \    var largestIndex = 0\n\n    for i in 0 ..< numbers.count {\n        if numbers[i]\
    \ > largestValue {\n            largestValue = numbers[i]\n            largestIndex\
    \ = i\n        }\n        if numbers[i] < smallestValue {\n            smallestValue\
    \ = numbers[i]\n            smallestIndex = i\n        }\n    }\n    return (largestValue,\
    \ numbers[largestIndex])", "  if numbers.count < 2 {\n    return numbers[0], numbers[0]\n\
    \  }\n  let min1 = numbers[0]\n  let min2 = numbers[0]\n  let index1 = 1\n  let\
    \ index2 = 1\n  for n in numbers {\n    if n > min1 {\n      min2 = min1\n   \
    \   min1 = n\n      index1 = index1 + 1\n    } else {\n      min2 = n\n    }\n\
    \  }\n  return (numbers[index1], min2)", "    func compare(_ aValue: Double, bValue:\
    \ Double) -> (Double, Double) {\n        var result = (aValue < bValue) ? -1 :\
    \ 1\n        let factor = (result == -1) ? -1 : 1\n        return (result * factor,\
    \ bValue * factor)\n    }\n\n    var smallestDifference = Double(FLT_MAX)\n  \
    \  var smallest = Double(FLT_MAX)\n    var largest = Double(FLT_MIN)\n    var\
    \ closest1 = Double(FLT_MAX)\n    var closest2 = Double(FLT_MAX)\n    for i in\
    \ 0..<numbers.count {\n        let (closestValue1, closestValue2) = compare(numbers[i],\
    \ numbers[i+1])\n        if (closestValue1 < smallestDifference) {\n         \
    \   smallestDifference = closestValue1\n            smallest = closestValue2\n\
    \            closest2 = closestValue1\n            closest1 = closestValue2\n\
    \        }\n        if (closestValue2 < smallestDifference) {\n            smallestDifference\
    \ = closestValue2\n            smallest = closestValue1\n            closest2\
    \ = closestValue2\n            closest1 = closestValue1\n        }\n    }\n  \
    \  return (closest1, closest2)", "    if numbers.isEmpty { return (0.0, 0.0) }\n\
    \n    var smallest1 = numbers[0]\n    var smallest2 = numbers[0]\n    var smallestDiff\
    \ = 1.0\n\n    var nextSmallestDiff = 1.000\n\n    for i in 1 ..< numbers.count\
    \ {\n        let currentDiff = abs(numbers[i] - numbers[smallest1])\n        if\
    \ currentDiff < smallestDiff {\n            smallest1 = numbers[i]\n         \
    \   smallestDiff = currentDiff\n        } else {\n            smallest2 = numbers[i]\n\
    \            nextSmallestDiff = currentDiff\n        }\n    }\n\n    return (smallest1,\
    \ smallest2)", "    let n1 = Double(numbers.first!)\n    let n2 = Double(numbers.last!)\n\
    \    var closest1 = n1\n    var closest2 = n2\n    var closestDifference = Double.max\n\
    \n    for (index, number) in\n            numbers.enumerated() {\n        let\
    \ distance = abs(n1 - number)\n        if (closestDifference > distance) {\n \
    \           closestDifference = distance\n            closest1 = number\n    \
    \        closest2 = numbers[index + 1]\n        }\n    }\n\n    return (closest1,\
    \ closest2)", "    let sortedNumbers = numbers.sorted(by: <)\n    return (sortedNumbers[0],\
    \ sortedNumbers[1])", "    guard numbers.count >= 2 else { return (0.0, 0.0) }\n\
    \n    var smallest = Double(numbers.first!)\n    var largest = Double(numbers.last!)\n\
    \    for number in numbers.dropFirst() {\n        if number < smallest { smallest\
    \ = number }\n        if number > largest { largest = number }\n    }\n\n    return\
    \ (smallest, largest)", "    guard numbers.count >= 2 else {\n        print(\"\
    Must have at least two numbers to find the closest ones.\")\n        return (0.0,0.0)\n\
    \    }\n    // Select the first two numbers and find the closest to them\n   \
    \ let closestNumber = closestToNumbers(numbers: numbers)\n    return (closestNumber,\
    \ numbers[numbers.index(closestNumber)])", '    return find_closest_elements(numbers,
    offset: 0, count: numbers.count)', "    if numbers.count == 2 {\n        return\
    \ (numbers[0], numbers[1])\n    }\n    if numbers.count == 0 {\n        return\
    \ (0.0, 0.0)\n    }\n    numbers.sort()\n    \n    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ < smallest {\n            smallest = numbers[i]\n        }\n        if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n        }\n    }\n    return\
    \ (smallest, largest)", "    let n = numbers.count\n    let mut smaller = Double.leastNormalMagnitude\n\
    \    let mut larger = Double.greatestNormalMagnitude\n    for i in 0..<n {\n \
    \       let smaller_diff = numbers[i].abs().flatMap { $0 }.min()\n        smaller\
    \ = min(smaller, smaller_diff)\n        let larger_diff = numbers[i].abs().flatMap\
    \ { $0 }.max()\n        larger = max(larger, larger_diff)\n    }\n    return (smaller,\
    \ larger)", "    let min = Float.greatestFiniteMagnitude\n    let max = Float.leastFiniteMagnitude\n\
    \    var minElement = Double.nan\n    var maxElement = Double.nan\n    for number\
    \ in numbers {\n        if number < min {\n            min = number\n        \
    \    minElement = number\n        } else if number > max {\n            max =\
    \ number\n            maxElement = number\n        }\n    }\n    return (minElement,\
    \ maxElement)", "    var closest = Double.leastNormalMagnitude\n    var close\
    \ = Double.leastNormalMagnitude\n    for n in numbers {\n        let d = abs(n\
    \ - closest)\n        if d < close {\n            close = closest\n          \
    \  closest = d\n        }\n    }\n    return (closest, closest)", "    let min_val:\
    \ Double = numbers[0]\n    let max_val: Double = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] < min_val {\n            min_val = numbers[i]\n   \
    \     } else if numbers[i] > max_val {\n            max_val = numbers[i]\n   \
    \     }\n    }\n    return (min_val, max_val)", "    // Get our min and max values\n\
    \    var minValue: Double = -1.0\n    var maxValue: Double = 1.0\n    // Go through\
    \ our numbers and update our min and max values\n    for i in 0..<numbers.count\
    \ {\n        let value = numbers[i]\n        if value < minValue {\n         \
    \   minValue = value\n        } else if value > maxValue {\n            maxValue\
    \ = value\n        }\n    }\n    // If we have no numbers, return an empty tuple\n\
    \    if numbers.count == 0 {\n        return (0.0,0.0)\n    }\n    // Get our\
    \ range\n    let range: Double = maxValue - minValue\n    // If our range is too\
    \ small, make our range bigger\n    if range < MIN_RANGE {\n        range = MIN_RANGE\n\
    \    }\n    // Return our values sorted\n    return (0.0 + ((minValue - maxValue)\
    \ / Double(numbers.count)), 0.0 + ((maxValue - minValue) / Double(numbers.count)))",
  "    if numbers.isEmpty {\n        return (0.5, 0.5)\n    }\n    if numbers.count\
    \ == 2 {\n        return (numbers[0], numbers[1])\n    }\n    guard let number1\
    \ = numbers.first else { return (0.0, 0.0) }\n    guard let number2 = numbers.last\
    \ else { return (number1, number1) }\n    let difference1 = number1 - number2\n\
    \    let difference2 = number2 - number1\n    let differenceABS = difference1\
    \ * difference1 + difference2 * difference2\n    let distanceABS = differenceABS\
    \ * -0.5\n    let distanceSqrt = sqrt(distanceABS)\n    let number3 = number1\
    \ + distanceSqrt\n    let number4 = number2 + distanceSqrt\n    return (number3,\
    \ number4)", "    // Your code here\n    if numbers.count < 2 {\n        fatalError(\"\
    not enough numbers\")\n    }\n    var smallest = numbers[0]\n    var largest =\
    \ numbers[0]\n    var index = 0\n\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n        if number < numbers[index]\
    \ {\n            index = index + 1\n        }\n        if number > numbers[index]\
    \ {\n            index = index - 1\n        }\n    }\n    return (smallest, largest)",
  "    var smallest: Double = Double(Int.max) {}\n    var largest: Double = Double(Int.min)\
    \ {}\n\n    numbers.forEach { (number) in\n        smallest = (number < smallest\
    \ ? number : smallest)\n        largest = (number > largest ? number : largest)\n\
    \    }\n\n    return (smallest, largest)", "    let numberArray = numbers.sorted()\n\
    \    return (numberArray[0], numberArray[numberArray.count - 1])", "    guard\
    \ numbers.count >= 2 else { return (numbers[0], numbers[0]) }\n\n    let diff\
    \ = numbers[0].distance(to: numbers[1])\n    let result = (numbers[0], numbers[1])\n\
    \    for i in 1 ..< numbers.count {\n        let newDiff = numbers[i].distance(to:\
    \ numbers[i - 1])\n        if diff == 0.0 {\n            diff = newDiff\n    \
    \        result = (numbers[i], numbers[i - 1])\n        } else {\n           \
    \ if diff > newDiff {\n                diff = newDiff\n                result\
    \ = (numbers[i], numbers[i - 1])\n            } else {\n                diff =\
    \ 0\n            }\n        }\n    }\n    return result", "    precondition(numbers.count\
    \ >= 2)\n\n    // find two closest numbers\n    let smallest = numbers[0]\n  \
    \  let largest = numbers[0]\n    for (number, index) in numbers.enumerated() {\n\
    \        if index == 0 {\n            continue\n        }\n\n        let candidate\
    \ = numbers[index - 1]\n\n        if candidate < smallest {\n            smallest\
    \ = candidate\n        }\n\n        if candidate > largest {\n            largest\
    \ = candidate\n        }\n    }\n\n    return (smallest, largest)", "  // Create\
    \ a list of indexes of the two closest elements\n  let indexes = find_indexes(numbers:\
    \ numbers)\n  // Select two numbers from the list of indexes\n  let (smaller,\
    \ bigger) = select_numbers(indexes: indexes)\n  // Return both values as tuple\n\
    \  return (smaller, bigger)", "    guard numbers.count >= 2 else {\n        return\
    \ (0, 0)\n    }\n    let low = numbers.min()\n    let high = numbers.max()\n \
    \   if low == high {\n        return (low, low)\n    }\n\n    var smallest = low\n\
    \    var largest = high\n\n    if numbers.count == 3 {\n        if numbers[0]\
    \ == numbers[1] {\n            if numbers[0] == numbers[2] {\n               \
    \ return (low, high)\n            } else {\n                if numbers[1] == numbers[2]\
    \ {\n                    return (numbers[0], high)\n                } else {\n\
    \                    if numbers[1] < numbers[2] {\n                        smallest\
    \ = numbers[0]\n                        largest = numbers[1]\n               \
    \     } else {\n                        smallest = numbers[1]\n              \
    \          largest = numbers[2]\n                    }\n                }\n  \
    \          }\n        } else {\n            if numbers[1] == numbers[2] {\n  \
    \              return (numbers[0], high)\n            } else {\n             \
    \   if numbers[0] < numbers[1] {\n                    smallest = numbers[0]\n\
    \                    largest = numbers[1]\n                } else {\n        \
    \            smallest = numbers[1]\n                    largest = numbers[2]\n\
    \                }\n            }\n        }\n    } else {\n        if numbers[0]\
    \ < numbers[1] {\n            smallest = numbers[0]\n            largest = numbers[1]\n\
    \        } else {\n            smallest = numbers[1]\n            largest = numbers[2]\n\
    \        }\n    }\n    return (smallest, largest)", "    var a = numbers[0]\n\
    \    var b = numbers[0]\n    for value in numbers {\n        if value < a {\n\
    \            a = value\n        } else if value > b {\n            b = value\n\
    \        }\n    }\n    return (a, b)", "    let smaller = numbers.min()\n    let\
    \ bigger = numbers.max()\n    if smaller < bigger {\n        return (smaller,\
    \ bigger)\n    }\n    else {\n        return (smaller, bigger * 2.0)\n    }",
  "    let smallest = min(numbers)\n    let largest = max(numbers)\n    return (largest,\
    \ smallest)", '    return find_closest_elements(numbers, from: numbers.startIndex,
    to: numbers.endIndex)', "    guard numbers.count > 2 else {\n        return numbers[1],\
    \ numbers[1]\n    }\n    let arrayOne = numbers[0]\n    let arrayTwo = numbers[1]\n\
    \    var smallestDifference = Double.infinity\n    var largestDifference = -Double.infinity\n\
    \    for i in 0..<numbers.count {\n        if abs(arrayOne - numbers[i]) < smallestDifference\
    \ {\n            smallestDifference = abs(arrayOne - numbers[i])\n        }\n\
    \        if abs(arrayTwo - numbers[i]) < largestDifference {\n            largestDifference\
    \ = abs(arrayTwo - numbers[i])\n        }\n    }\n    return (arrayOne, arrayTwo)",
  "  guard numbers.count >= 2 else {\n    return (nil, nil)\n  }\n\n  var min: Double\
    \ = Double(FLT_MAX)\n  var max: Double = Double(-FLT_MAX)\n\n  for number in numbers\
    \ {\n    guard number >= min && number <= max else {\n      return (nil, nil)\n\
    \    }\n\n    if number < min {\n      min = number\n    } else if number > max\
    \ {\n      max = number\n    }\n  }\n\n  return (min: min, max: max)", "\tlet\
    \ smallest = numbers[0]\n\tlet largest = numbers[0]\n\tnumbers.forEach { smallest\
    \ = min(smallest, $0) }\n\tnumbers.forEach { largest = max(largest, $0) }\n\t\
    return (largest, smallest)", "    if numbers.isEmpty { return (numbers[0], numbers[0])\
    \ }\n    var smallestDiff = numbers[0].signum() - numbers[1].signum()\n    var\
    \ closest1 = numbers[0]\n    var closest2 = numbers[0]\n    if numbers[1].signum()\
    \ > numbers[0].signum() {\n        closest1 = numbers[1]\n        closest2 = numbers[0]\n\
    \    }\n    for number in numbers[2..<numbers.count] {\n        var diff: Double\n\
    \        if smallestDiff == numbers[smallestDiff].signum() {\n            diff\
    \ = smallestDiff\n        } else {\n            diff = number.signum() - numbers[smallestDiff].signum()\n\
    \        }\n        if diff < 0 {\n            smallestDiff = diff\n         \
    \   closest1 = number\n            closest2 = number\n        } else {\n     \
    \       smallestDiff = -diff\n            closest2 = number\n            closest1\
    \ = number\n        }\n    }\n    return (closest1, closest2)", "    \n    let\
    \ min1 = min(numbers)\n    let max1 = max(numbers)\n    \n    return min1, max1",
  '    return find_closest_elements(numbers: numbers, threshold: 1.0)', "    guard\
    \ numbers.count > 1 else { return (numbers[0], numbers[0]) }\n    var bestDistance\
    \ = abs(numbers[0] - numbers[1])\n    var bestElement = (numbers[0], numbers[1])\n\
    \n    for i in 1..numbers.count {\n        let currentDistance = abs(numbers[i]\
    \ - numbers[i - 1]) + bestDistance\n        if currentDistance < bestDistance\
    \ {\n            bestDistance = currentDistance\n            bestElement = (numbers[i],\
    \ numbers[i - 1])\n        }\n    }\n\n    return (bestElement.0, bestElement.1)",
  "    if numbers.isEmpty { return (numbers[0], numbers[0]) }\n    var smallestDifference\
    \ = Double.infinity\n    var smallestDifferenceNumber = numbers[0]\n    var smallestDifferenceIndex\
    \ = 0\n    for i in 0..<numbers.count {\n        var difference = abs(numbers[i]\
    \ - numbers[smallestDifferenceIndex])\n        if difference < smallestDifference\
    \ {\n            smallestDifference = difference\n            smallestDifferenceNumber\
    \ = numbers[i]\n            smallestDifferenceIndex = i\n        }\n    }\n  \
    \  return (smallestDifferenceNumber, numbers[smallestDifferenceIndex])", "   \
    \ var smallest: Double = Double.max\n    var largest: Double = Double.min\n  \
    \  for i in numbers.indices {\n        let current: Double = numbers[i]\n    \
    \    if current < smallest {\n            smallest = current\n        }\n    \
    \    if current > largest {\n            largest = current\n        }\n    }\n\
    \    return (numbers[numbers.index(of: smallest)], numbers[numbers.index(of: largest)])",
  "    let minDistance = Double.max\n    let minIndex = -1\n    for i in 1..<numbers.count\
    \ {\n        let distance = (numbers[i] - numbers[minIndex])\n        if distance\
    \ < minDistance {\n            minDistance = distance\n            minIndex =\
    \ i\n        }\n    }\n    return (numbers[minIndex], numbers[minIndex])", " \
    \ let min = _minimum(numbers)\n  let max = _maximum(numbers)\n  return (min!,\
    \ max!)", "    guard numbers.count >= 2 else { return (numbers[0], numbers[0])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)", "    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    for number in numbers {\n  \
    \      if number < smallest {\n            smallest = number\n        }\n    \
    \    if number > largest {\n            largest = number\n        }\n    }\n \
    \   return (smallest, largest)", "  if numbers.isEmpty {\n    return (0, 0)\n\
    \  }\n  numbers.sort { $0 < $1 }\n  return numbers[0..<numbers.count - 1], numbers[numbers.count\
    \ - 1]", "    let sorted = numbers.sorted()\n    if numbers.count <= 1 {\n   \
    \     return (sorted[0], sorted[0])\n    }\n    var closest1 = sorted[0]\n   \
    \ var closest2 = sorted[0]\n    for i in 1 ..< numbers.count {\n        let distance\
    \ = abs(sorted[i] - closest1)\n        if distance < abs(sorted[i] - closest2)\
    \ {\n            closest2 = closest1\n            closest1 = sorted[i]\n     \
    \   } else {\n            closest2 = sorted[i]\n        }\n    }\n    return (closest1,\
    \ closest2)", "    var smallest = Double.max\n    var largest = Double.min\n\n\
    \    for i in 0..<numbers.count {\n        var thisNumber = numbers[i]\n     \
    \   if thisNumber < smallest {\n            smallest = thisNumber\n        }\n\
    \n        if thisNumber > largest {\n            largest = thisNumber\n      \
    \  }\n    }\n\n    return (smallest, largest)", "    let smallest_diff = Double.infinity\n\
    \    let smallest_distance = Double.infinity\n    var biggest_diff = Double.infinity\n\
    \    var biggest_distance = Double.infinity\n\n    var smallest_number = numbers[0]\n\
    \    var biggest_number = numbers[0]\n\n    for i in 1..<numbers.count {\n   \
    \     let current_number = numbers[i]\n        let current_diff = abs(current_number\
    \ - biggest_number)\n        let current_distance = abs(current_number - smallest_number)\n\
    \        if current_diff < smallest_diff {\n            smallest_diff = current_diff\n\
    \            smallest_number = current_number\n        }\n\n        if current_distance\
    \ < biggest_distance {\n            biggest_diff = current_diff\n            biggest_number\
    \ = current_number\n        }\n    }\n\n    return (smallest_number, biggest_number)",
  "    if numbers.count < 2 {\n        return (numbers[0], numbers[0])\n    }\n  \
    \  let minValueIndex = 0\n    let maxValueIndex = numbers.count - 1\n\n    var\
    \ smallestDifference = numbers[0]\n    let smallestElement = numbers[0]\n    for\
    \ i in 1..<numbers.count {\n        if numbers[i] - numbers[minValueIndex] > smallestDifference\
    \ {\n            smallestDifference = numbers[i] - numbers[minValueIndex]\n  \
    \          smallestElement = numbers[i]\n        }\n        if numbers[i] - numbers[maxValueIndex]\
    \ < smallestDifference {\n            smallestDifference = numbers[i] - numbers[maxValueIndex]\n\
    \            smallestElement = numbers[i]\n        }\n    }\n    return (smallestElement,\
    \ numbers[minValueIndex])", "    if numbers.isEmpty() {\n        return (numbers[0],\
    \ numbers[0])\n    }\n\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \n    for number in numbers {\n        if number > largest {\n            largest\
    \ = number\n        } else if number < smallest {\n            smallest = number\n\
    \        }\n    }\n\n    return (smallest, largest)", '    return find_closest_elements(numbers,
    numbers, 0)', "    let smallest = numbers[0]\n    let largest = numbers[0]\n\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        } else if numbers[i] > largest {\n     \
    \       largest = numbers[i]\n        }\n    }\n    return (smallest, largest)",
  "  let sortedArray = numbers.sorted()\n  var smallestNumber: Double = 0\n  var largestNumber:\
    \ Double = Double.greatestFiniteMagnitude\n  for element in sortedArray {\n  \
    \  if element < smallestNumber {\n      smallestNumber = element\n    } else if\
    \ element > largestNumber {\n      largestNumber = element\n    }\n  }\n  return\
    \ smallestNumber, largestNumber", "    let smallestIndex = numbers.index(of: numbers.min())\n\
    \    let largestIndex = numbers.index(of: numbers.max())\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])", "    var smallest = Double.min\n    var largest = Double.max\n\
    \n    guard numbers.count > 0 else {\n        return (0, 0)\n    }\n\n    numbers.forEach\
    \ {\n        if $0 < smallest {\n            smallest = $0\n        }\n      \
    \  if $0 > largest {\n            largest = $0\n        }\n    }\n\n    return\
    \ (largest, smallest)", '    return find_closest_elements(numbers, 0.0, numbers[0],
    numbers[1])', "    if numbers.isEmpty {\n        return (0.0, 0.0)\n    }\n\n\
    \    var smallest_diff : Double\n    var biggest_diff : Double\n\n    for number\
    \ in numbers {\n        let diff = abs(number - numbers[0])\n        if smallest_diff\
    \ == 0.0 || diff < smallest_diff {\n            smallest_diff = diff\n       \
    \ }\n        if biggest_diff == 0.0 || diff > biggest_diff {\n            biggest_diff\
    \ = diff\n        }\n    }\n\n    return (numbers[biggest_diff > smallest_diff\
    \ ? biggest_diff - smallest_diff : 0], numbers[biggest_diff > smallest_diff ?\
    \ 0 : biggest_diff - smallest_diff])", '    return find_closest_elements(numbers,
    nil)', "    if numbers.isEmpty() {\n        return (0, 0)\n    }\n\n    let sortedNumbers\
    \ = numbers.sorted()\n    var biggestNumber = sortedNumbers[0]\n    var smallestNumber\
    \ = sortedNumbers[0]\n    let largestIndex = sortedNumbers.count - 1\n\n    for\
    \ (index, number) in sortedNumbers.enumerated() {\n        if number < smallestNumber\
    \ {\n            smallestNumber = number\n        } else if number > biggestNumber\
    \ {\n            biggestNumber = number\n        }\n    }\n\n    let closestResult\
    \ = (smallestNumber, biggestNumber)\n    let closestResultIndex = sortedNumbers.index(of:\
    \ closestResult.0!)!\n    return (sortedNumbers[closestResultIndex], sortedNumbers[closestResultIndex\
    \ + 1])", "    if numbers.isEmpty { return (0.0, 0.0) }\n    guard numbers.count\
    \ > 1 else { return (numbers[0], numbers[0]) }\n    var closest = numbers[0]\n\
    \    var minDist = abs(numbers[0])\n    var minIndex = numbers.startIndex\n  \
    \  numbers.enumerated().forEach { (i, n) in\n        let dist = abs(n - closest)\n\
    \        if dist < minDist {\n            minDist = dist\n            minIndex\
    \ = i\n        }\n    }\n    return (numbers[minIndex], closest)", "    \n   \
    \ let min1 = numbers[0]\n    let min2 = numbers[0]\n    \n    for (index, value)\
    \ in numbers.enumerated() {\n        \n        if value < min1 {\n           \
    \ min2 = min1\n            min1 = value\n        }\n        \n        else if\
    \ value > min2 {\n            min2 = value\n        }\n        \n        else\
    \ {\n            min1 = value\n        }\n    }\n    \n    return (min1, min2)",
  "    if numbers.isEmpty() {\n        return (0, 0)\n    }\n    let min = numbers.min()\n\
    \    let max = numbers.max()\n    if min == max {\n        return (0, 0)\n   \
    \ }\n    \n    let closestIndex = numbers.firstIndex({ abs($0 - min) < abs($0\
    \ - max) })\n    let closest = (numbers[closestIndex], numbers[closestIndex])\n\
    \    if closestIndex < numbers.count - 1 {\n        let nextClosestIndex = numbers.firstIndex({\
    \ abs($0 - closest) < abs($0 - max) })\n        let nextClosest = (numbers[nextClosestIndex],\
    \ numbers[nextClosestIndex])\n        if nextClosestIndex < numbers.count - 1\
    \ {\n            closest = (nextClosest[0], nextClosest[1])\n        }\n    }\n\
    \    return (closest[0], closest[1])", "    let (smallestIndex: Int, smallest:\
    \ Double, largestIndex: Int, largest: Double) = find_closest_indexes(numbers)\n\
    \    return (numbers[smallestIndex], numbers[largestIndex])", "    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    for number in numbers {\n  \
    \      if number < smallest {\n            largest = smallest\n            smallest\
    \ = number\n        } else if number > largest {\n            smallest = number\n\
    \        }\n    }\n    return (smallest, largest)", "  let sortedNumbers = numbers.sorted()\n\
    \  return (sortedNumbers.first, sortedNumbers.last)", "    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n    var index = 0.0\n    \n    for var i = 0; i\
    \ < numbers.count; i++ {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n            index = i\n        }\n        else if numbers[i] >\
    \ largest {\n            largest = numbers[i]\n        }\n    }\n\n    return\
    \ (numbers[index], numbers[index+1])", "    precondition(numbers.count > 1, \"\
    find_closest_elements requires at least two numbers\")\n    var smallestDifference\
    \ = Double.nan\n    var smallestDifferenceIndex = -1\n    var secondSmallestDifference\
    \ = Double.nan\n    var secondSmallestDifferenceIndex = -1\n    for i in 0..<numbers.count\
    \ {\n        if numbers[i] > numbers[smallestDifferenceIndex] {\n            smallestDifference\
    \ = numbers[i]\n            smallestDifferenceIndex = i\n        }\n        if\
    \ numbers[i] > numbers[secondSmallestDifferenceIndex] {\n            secondSmallestDifference\
    \ = numbers[i]\n            secondSmallestDifferenceIndex = i\n        }\n   \
    \ }\n    return (numbers[smallestDifferenceIndex], numbers[secondSmallestDifferenceIndex])",
  "    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n    }\n    let distances\
    \ = [(0.0, 0.0)]\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        let distance = (number - smallest).squareRoot()\n\
    \        distances.append((distance, number))\n        if number > largest {\n\
    \            largest = number\n        }\n        if number < smallest {\n   \
    \         smallest = number\n        }\n    }\n    var smallestIndex = distances.startIndex.advancedBy(0)\n\
    \    var largestIndex = distances.endIndex.advancedBy(-1)\n    var smallestDistance\
    \ = distances[smallestIndex]\n    var largestDistance = distances[largestIndex]\n\
    \    while largestIndex < distances.endIndex {\n        smallestDistance = distances[smallestIndex]\n\
    \        largestDistance = distances[largestIndex]\n        if largestDistance\
    \ < smallestDistance {\n            smallestIndex = largestIndex\n        }\n\
    \        else {\n            largestIndex = largestIndex.advancedBy(1)\n     \
    \   }\n    }\n    return (largest, smallest)", "  let min = min(numbers)\n  let\
    \ max = max(numbers)\n  return (min.next, max)", "    let min = numbers[0]\n \
    \   let max = numbers[0]\n\n    for number in numbers {\n        if number < min\
    \ {\n            min = number\n        } else if number > max {\n            max\
    \ = number\n        }\n    }\n\n    return (min, max)", "    let smallestDifference\
    \ = Double.infinity\n    var largestDifference = Double.infinity\n    var smallestDiff\
    \ = Double(numbers[0])\n    var largestDiff = Double(numbers[0])\n    for number\
    \ in numbers {\n        let diff = Double(number) - smallestDiff\n        if diff\
    \ < smallestDifference {\n            smallestDifference = diff\n            smallestDiff\
    \ = number\n        } else {\n            largestDifference = diff\n         \
    \   largestDiff = number\n        }\n    }\n    return (smallestDiff, largestDiff)",
  "    var min1 = math.MaxFloat64\n    var min2 = math.MaxFloat64\n    var minIndex\
    \ = -1\n    var maxIndex = -1\n    for index in stride(from: numbers.count-1,\
    \ through: 0, by: 1) {\n        let candidate = numbers[index]\n        let distance\
    \ = hypot(candidate-min1, candidate-min2)\n        if distance < min1 {\n    \
    \        min1 = distance\n            minIndex = index\n        }\n        else\
    \ if distance < min2 {\n            min2 = distance\n            minIndex = index\n\
    \        }\n    }\n    return (min2, numbers[minIndex])", "    var smallest =\
    \ numbers[0]\n    var largest = numbers[0]\n    for i in 1..<numbers.count {\n\
    \        if numbers[i] < smallest {\n            smallest = numbers[i]\n     \
    \   }\n        if numbers[i] > largest {\n            largest = numbers[i]\n \
    \       }\n    }\n    return (smallest, largest)", "    if numbers.isEmpty {\n\
    \        return (Double(0), Double(0))\n    }\n    var result: (Double, Double)\n\
    \    let largest = numbers.max()\n    let smallest = numbers.min()\n    for i\
    \ in numbers.indices {\n        if abs(numbers[i] - largest) < abs(numbers[i]\
    \ - smallest) {\n            result = numbers[i], largest\n        } else if abs(numbers[i]\
    \ - smallest) < abs(numbers[i] - largest) {\n            result = numbers[i],\
    \ smallest\n        } else {\n            result = (numbers[i], numbers[i])\n\
    \        }\n    }\n    return result", "  var smallest = numbers[0]\n  var largest\
    \ = numbers[0]\n  for number in numbers {\n    if smallest > number {\n      smallest\
    \ = number\n    }\n    if largest < number {\n      largest = number\n    }\n\
    \  }\n\n  return smallest, largest", "  let min = min(numbers)\n  let max = max(numbers)\n\
    \  var closest = (min, max)\n  for (index, value) in numbers.enumerated() {\n\
    \    if value == closest {\n      return (index, value)\n    }\n    if value >\
    \ closest {\n      closest = (index, value)\n    }\n  }\n  return closest", " \
    \   guard numbers.count >= 2 else {\n        return (0.0,0.0)\n    }\n    var\
    \ smallest = numbers[0]\n    var largest = numbers[0]\n    for number in numbers\
    \ {\n        if number < smallest {\n            smallest = number\n        }\n\
    \        if number > largest {\n            largest = number\n        }\n    }\n\
    \    return (smallest, largest)", "    guard numbers.count >= 2 else { return\
    \ (0.0, 0.0) }\n    guard numbers.count <= 6 else { return (0.0, 0.0) }\n    guard\
    \ numbers.count % 2 == 0 else { return (0.0, 0.0) }\n\n    // find the two closest\
    \ elements by moving away from both sides\n    let sortedArray = numbers.sorted()\n\
    \n    let closestLeft = sortedArray[1]\n    let closestRight = sortedArray[numbers.count\
    \ - 2]\n\n    return (closestLeft, closestRight)", "    let min = minElementIndexFrom(numbers)\n\
    \    let max = maxElementIndexFrom(numbers)\n    return (numbers[min], numbers[max])",
  "    let smallest = numbers.min()\n    let largest = numbers.max()\n    return (numbers.min(by:\
    \ &smallest), numbers.max(by: &largest))", "    assert(numbers.count > 2)\n  \
    \  var smallestNum = Double(numbers.first!)\n    var largestNum = Double(numbers.last!)\n\
    \    for (index, number) in numbers.enumerated() {\n        if (number < smallestNum)\
    \ {\n            smallestNum = number\n        }\n        if number > largestNum\
    \ {\n            largestNum = number\n        }\n    }\n    return (smallestNum,\
    \ largestNum)", "    let largest = numbers.max()\n    var smallest = largest\n\
    \    var minIndex = 0\n    for number in numbers {\n        if number < smallest\
    \ {\n            smallest = number\n            minIndex = 1\n        }\n    \
    \    if number > largest {\n            largest = number\n        }\n    }\n \
    \   return (numbers[minIndex], largest)", "    var closestDistance = numbers[0]\n\
    \    var closestIndex = 0\n    var index = 1\n    var closest = numbers[0]\n\n\
    \    for number in numbers {\n        if number < closest {\n            closestIndex\
    \ = index\n            closest = number\n        }\n        index += 1\n     \
    \   if closestDistance > abs(closestIndex - index) {\n            closestDistance\
    \ = abs(closestIndex - index)\n            closestIndex = index\n            closest\
    \ = number\n        }\n    }\n    return (closest, closest)", '    return find_closest_elements(numbers:
    numbers, epsilon: Double.epsilon)', "    guard numbers.count >= 2 else { return\
    \ (Double(numbers.first), Double(numbers.first)) }\n\n    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n    let numbers = numbers.dropFirst()\n    for\
    \ i in 1..numbers.count {\n        let a = numbers[i]\n        if a < smallest\
    \ {\n            smallest = a\n        }\n        if a > largest {\n         \
    \   largest = a\n        }\n    }\n\n    return (smallest, largest)", "    precondition(numbers.count\
    \ > 1, \"Need at least two values to find closest to.\")\n\n    var minDistance\
    \ = Double.infinity\n    var minIndex = -1\n    var minValue = numbers[0]\n\n\
    \    for index in 1..numbers.count {\n        let value = numbers[index]\n\n \
    \       let distance = abs(value - minValue)\n        if distance < minDistance\
    \ {\n            minDistance = distance\n            minIndex = index\n      \
    \      minValue = value\n        }\n    }\n\n    return (minValue, numbers[minIndex])",
  "    let minValue = min(numbers)\n    let maxValue = max(numbers)\n    return (minValue,\
    \ maxValue)", "  let mut min_value = Double(Int.max)\n  let mut max_value = Double(-Int.max)\n\
    \  for i in 0..<numbers.count {\n    if numbers[i] < min_value {\n      min_value\
    \ = numbers[i]\n    }\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n\
    \    }\n  }\n  return min_value, max_value", "    guard numbers.count >= 2 else\
    \ {\n        print(\"find_closest_elements expects at least two numbers\")\n \
    \       return (numbers[0], numbers[0])\n    }\n\n    var smallest = Double(numbers[0])\n\
    \    var largest = Double(numbers[0])\n\n    for i in 1..<numbers.count {\n  \
    \      let current = numbers[i]\n        let currentDistance = current - largest\n\
    \        let currentDistanceAbs = abs(currentDistance)\n        if currentDistanceAbs\
    \ > largest.absValue {\n            largest = current\n        }\n        if currentDistanceAbs\
    \ < smallest.absValue {\n            smallest = current\n        }\n    }\n\n\
    \    return (smallest, largest)", "    // Check that the input array has at least\
    \ 2 elements.\n    guard numbers.count >= 2 else {\n        return (Double(0.0),\
    \ Double(0.0)) }\n\n    // Check that the input array has at least 2 elements.\n\
    \    guard numbers.count > 1 else {\n        return (numbers[0], numbers[0]) }\n\
    \n    // Find the two closest numbers to the two elements at the head of the input\
    \ array.\n    var smallestDistance = Double(Double.greatestFiniteMagnitude)\n\
    \    var secondSmallestDistance = Double(Double.greatestFiniteMagnitude)\n   \
    \ var smallestIndex = -1\n    var secondSmallestIndex = -1\n    for (i in 0..<numbers.count)\
    \ {\n        let distance = abs(numbers[i] - numbers[smallestIndex])\n       \
    \ if smallestIndex == -1 || distance < smallestDistance {\n            smallestIndex\
    \ = i\n            smallestDistance = distance }\n        distance = abs(numbers[i]\
    \ - numbers[secondSmallestIndex])\n        if secondSmallestIndex == -1 || distance\
    \ < secondSmallestDistance {\n            secondSmallestIndex = i\n          \
    \  secondSmallestDistance = distance }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[secondSmallestIndex])", "    if numbers.isEmpty {\n        fatalError(\"\
    Cannot find closest element for an empty array\")\n    }\n\n    if numbers.count\
    \ < 2 {\n        fatalError(\"Must have at least two numbers to find closest elements\"\
    )\n    }\n\n    var min = numbers[0]\n    var max = numbers[0]\n    for element\
    \ in numbers {\n        if element < min {\n            min = element\n      \
    \  }\n        if element > max {\n            max = element\n        }\n    }\n\
    \    return (min, max)", "    let min = Double(numbers.first!)\n    let max =\
    \ Double(numbers.last!)\n    return (min, max)", "    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n\n    for i in 1..numbers.count {\n        let\
    \ currentNumber = numbers[i]\n        let delta = (largest - smallest).abs()\n\
    \        if delta > currentNumber {\n            largest = currentNumber\n   \
    \     } else {\n            smallest = currentNumber\n        }\n    }\n    return\
    \ smallest, largest", "    // If one or both of the array elements is NaN, return\
    \ them in order (smaller number, larger number).\n    if numbers[0].isNaN || numbers[1].isNaN\
    \ {\n        if numbers[0].isNaN {\n            return numbers[1], numbers[1]\n\
    \        } else {\n            return numbers[0], numbers[0]\n        }\n    }\n\
    \n    // Store the difference between the two array elements.\n    var difference\
    \ = numbers[0] - numbers[1]\n\n    // If difference is greater than or equal to\
    \ 0.5, return them as they are.\n    if difference >= 0.5 {\n        return numbers[0],\
    \ numbers[0]\n    }\n\n    // Otherwise find the smallest distance and swap the\
    \ elements. Return that one in order (smaller number,\n    // larger number).\n\
    \    var minDistance = Double.infinity\n    var minNumber = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        if numbers[i] != numbers[0] {\n          \
    \  let distance = abs(numbers[i] - numbers[1])\n            if distance < minDistance\
    \ {\n                minDistance = distance\n                minNumber = numbers[i]\n\
    \            }\n        }\n    }\n\n    return minNumber, minNumber", "    assert(numbers.count\
    \ > 2)\n    let min = numbers[0]\n    let max = numbers[0]\n    for num in numbers\
    \ {\n        if num < min {\n            min = num\n        }\n        if num\
    \ > max {\n            max = num\n        }\n    }\n\n    return (min, max)",
  "    guard numbers.count > 1 else { return (0.0, 0.0) }\n\n    let smallest = numbers.min()\n\
    \    let largest = numbers.max()\n\n    if smallest == largest {\n        return\
    \ smallest, smallest\n    }\n\n    var smallestDifference = largest\n    var largestDifference\
    \ = smallest\n\n    for number in numbers {\n        let difference = abs(number\
    \ - smallest)\n        if smallestDifference > difference {\n            smallestDifference\
    \ = difference\n            smallest = number\n        }\n\n        if largestDifference\
    \ < difference {\n            largestDifference = difference\n            largest\
    \ = number\n        }\n    }\n\n    return (smallest, largest)", "    guard numbers.count\
    \ > 1 else {\n        return (0.0,0.0)\n    }\n    guard numbers.count <= 2 else\
    \ { return (0.0, 0.0) }\n    guard numbers.count >= numbers.indices.count else\
    \ { return (0.0, 0.0) }\n    let max1 = numbers[numbers.indices.last!]\n    let\
    \ min1 = numbers[numbers.indices.first!]\n    let max2 = numbers[numbers.indices.last!]\n\
    \    let min2 = numbers[numbers.indices.first!]\n\n    let index1 = numbers.indices.index(of:\
    \ max1)\n    let index2 = numbers.indices.index(of: min2)\n\n    let x = max2\
    \ - min2\n    let y = max1 - min1\n\n    return (x: x, y: y)", "    if numbers.isEmpty()\
    \ {\n        return (numbers[0], numbers[0])\n    }\n    if numbers.count == 2\
    \ {\n        return numbers[0], numbers[1]\n    }\n    numbers.sort()\n    if\
    \ numbers[0] < numbers[1] {\n        return (numbers[0], numbers[1])\n    }\n\
    \    return (numbers[1], numbers[0])", "    let minDiff = Double.greatestFiniteMagnitude\n\
    \    var minValue = numbers[0]\n    var maxValue = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let diff: Double = abs(numbers[i] - minValue)\n        if diff <\
    \ minDiff {\n            minDiff = diff\n            minValue = numbers[i]\n \
    \       } else {\n            maxValue = numbers[i]\n        }\n    }\n    return\
    \ minValue, maxValue", "    let largest = numbers.reduce(maxElement)\n    let\
    \ smallest = numbers.reduce(minElement)\n    let smallerNumber = largest - smallest\
    \ + 1.0\n    if smallerNumber > 1.0 {\n        return (numbers[0], numbers[0])\n\
    \    }\n    if smallerNumber < 1.0 {\n        return (numbers[-1], numbers[-1])\n\
    \    }\n    for (i, number) in enumerate(numbers) {\n        if number - largest\
    \ < smallest - number {\n            return (numbers[i], numbers[i])\n       \
    \ }\n    }\n    return (numbers[-1], numbers[-1])", "    let smallestNum = numbers.min()!\n\
    \    let largestNum = numbers.max()!\n\n    var smallest = largestNum\n    var\
    \ largest = smallestNum\n\n    for (index, value) in numbers.enumerated() {\n\
    \        if value < smallest {\n            smallest = value\n        }\n    \
    \    if value > largest {\n            largest = value\n        }\n    }\n\n \
    \   return (smallest, largest)", '    return find_closest_elements(numbers: numbers,
    min: Double(Double.infinity), max: Double(-Double.infinity))', "    let max =\
    \ numbers.max()\n    let min = numbers.min()\n    return (min < max ? min : max,\
    \ max)", "    if numbers.isEmpty { return (0.0, 0.0) }\n    let closestIndex =\
    \ numbers.index(of: numbers.min)!\n    let lowValue = numbers[closestIndex]\n\
    \    let highValue = numbers[closestIndex + 1]\n    return (lowValue, highValue)",
  "    var largest = numbers[0]\n    var smallest = numbers[0]\n    for number in\
    \ numbers {\n        if number > largest {\n            largest = number\n   \
    \     }\n        if number < smallest {\n            smallest = number\n     \
    \   }\n    }\n    return (largest, smallest)", "    \n    let min = numbers.min()\n\
    \    let max = numbers.max()\n    \n    return min < max ? (min, max) : ((max+min)/2,\
    \ max)", "    var minNum = numbers[0]\n    var maxNum = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < minNum {\n            minNum\
    \ = numbers[i]\n        } else if numbers[i] > maxNum {\n            maxNum =\
    \ numbers[i]\n        }\n    }\n    return (minNum, maxNum)", "  assert(numbers.count\
    \ > 1, \"There must be at least two numbers to compare\")\n  return find_closest_elements(numbers:\
    \ numbers, results: [], min: Float64(numbers.first!), max: Float64(numbers.last!))",
  "    if numbers.isEmpty { return }\n    let minA = numbers.min()\n    let minB =\
    \ numbers.min()\n    var min: Double?\n    var minIndex: Int?\n    for n in numbers\
    \ {\n        let d = n - minA\n        if d < min {\n            min = d\n   \
    \         minIndex = 0\n        } else if d > min-B {\n            min = d\n \
    \           minIndex = 1\n        }\n    }\n    if minIndex == 0 { return (numbers[0],\
    \ numbers[0]) }\n    if minIndex == 1 { return (numbers[0], numbers[1]) }\n  \
    \  if minIndex == 2 {\n        return numbers[minIndex]\n    }\n    return (numbers[minIndex],\
    \ numbers[minIndex+1])", "    var smallest: Double = -Float.infinity\n    var\
    \ largest: Double = Float.infinity\n    for i in numbers.indices {\n        if\
    \ numbers[i] < smallest {\n            smallest = numbers[i]\n        } else if\
    \ numbers[i] > largest {\n            largest = numbers[i]\n        }\n    }\n\
    \    return (smallest, largest)", '    return find_closest_elements(numbers: numbers,
    epsilon: 0.001)', "    let min: Double\n    let max: Double\n    if numbers.count\
    \ <= 2 {\n        return (numbers[0], numbers[0])\n    }\n    let smallest = numbers[0]\n\
    \    let largest = numbers[0]\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    if smallest ==\
    \ largest {\n        return (smallest, smallest)\n    }\n    for (index, number)\
    \ in numbers.enumerated() {\n        let difference = abs(number - largest)\n\
    \        if difference < abs(number - smallest) {\n            min = number\n\
    \            max = numbers[index + 1]\n        }\n    }\n    return (min, max)",
  "    var min1 = numbers[0]\n    var min2 = numbers[0]\n    var result = numbers[0]\n\
    \    for number in numbers {\n        let abs1 = abs(number)\n        if abs1\
    \ < abs(min1) {\n            min1 = number\n        }\n        let abs2 = abs(number)\n\
    \        if abs2 < abs(min2) {\n            min2 = number\n        }\n       \
    \ if abs1 > abs2 {\n            result = number\n        }\n    }\n    return\
    \ (result, result)", "  let numbers_min = min(numbers)\n  let numbers_max = max(numbers)\n\
    \  let difference = numbers_max - numbers_min\n  let differenceInt = Int(difference)\n\
    \  var closest = (numbers_min, numbers_max)\n  for number in numbers {\n    let\
    \ diffInt = Int(number) - Int(numbers_min)\n    let diff = diffInt / differenceInt\n\
    \    if diff < 0 {\n      closest = (number, numbers_max)\n    } else if diff\
    \ > 0 {\n      closest = (numbers_min, number)\n    } else {\n      break\n  \
    \  }\n  }\n  return closest", "  if numbers.count < 2 {\n    return (numbers[0],\
    \ numbers[1])\n  }\n  \n  var smallestDifference = Double.max\n  var smallestIndex\
    \ = -1\n  var largestDifference = Double.min\n  var largestIndex = -1\n  \n  for\
    \ index in 0 ..< numbers.count - 1 {\n    let difference = numbers[index] - numbers[smallestIndex]\n\
    \    if difference < smallestDifference {\n      smallestDifference = difference\n\
    \      smallestIndex = index\n    }\n    \n    if difference > largestDifference\
    \ {\n      largestDifference = difference\n      largestIndex = index\n    }\n\
    \  }\n  \n  return (numbers[smallestIndex], numbers[largestIndex])", "    let\
    \ sorted = numbers.sorted()\n    return (sorted[0], sorted[sorted.count-1])",
  "    let n = numbers.count\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    for i in 1..<n {\n        let min2 = numbers[i]\n        let max2 = numbers[i]\n\
    \        if min1 < min2 {\n            min1 = min2\n        }\n        if max1\
    \ > max2 {\n            max1 = max2\n        }\n    }\n    if min1 == max1 {\n\
    \        return (min1, max1)\n    }\n    let min2 = numbers[0]\n    let max2 =\
    \ numbers[0]\n    for i in 1..<n {\n        let min3 = numbers[i]\n        let\
    \ max3 = numbers[i]\n        if min2 > min3 {\n            min2 = min3\n     \
    \   }\n        if max2 > max3 {\n            max2 = max3\n        }\n    }\n \
    \   return (min2, max2)", "    switch numbers.count {\n    case 2:\n        let\
    \ min1 = numbers[0]\n        let min2 = numbers[1]\n        let max1 = numbers[0]\n\
    \        let max2 = numbers[1]\n        return find_closest_elements(min1, max1,\
    \ min2, max2)\n    case 3:\n        let min1 = numbers[0]\n        let min2 =\
    \ numbers[1]\n        let min3 = numbers[2]\n        let max1 = numbers[0]\n \
    \       let max2 = numbers[1]\n        let max3 = numbers[2]\n        return find_closest_elements(min1,\
    \ max1, min2, max2, min3, max3)\n    case 4:\n        let min1 = numbers[0]\n\
    \        let min2 = numbers[1]\n        let min3 = numbers[2]\n        let min4\
    \ = numbers[3]\n        let max1 = numbers[0]\n        let max2 = numbers[1]\n\
    \        let max3 = numbers[2]\n        let max4 = numbers[3]\n        return\
    \ find_closest_elements(min1, max1, min2, max2, min3, max3, min4, max4)\n    default:\n\
    \        return (0.5, 0.5)\n    }", "    // TODO: This can be optimized more and\
    \ we could get rid of some checks\n    if numbers.count < 2 {\n        return\
    \ numbers[0], numbers[1]\n    }\n\n    // TODO: This can be optimized more and\
    \ we could get rid of some checks\n    let sorted_numbers = numbers.sorted()\n\
    \    let first_number = sorted_numbers[0]\n    let second_number = sorted_numbers[1]\n\
    \    if abs(first_number - second_number) < abs(first_number + second_number)\
    \ {\n        return (first_number, second_number)\n    }\n\n    return (second_number,\
    \ first_number)", "    func smallest(_ numbers: Set<Double>) -> Double {\n   \
    \     var smallest = numbers[0]\n        for number in numbers {\n           \
    \ if number < smallest {\n                smallest = number\n            }\n \
    \       }\n        return smallest\n    }\n\n    func largest(_ numbers: Set<Double>)\
    \ -> Double {\n        var largest = numbers[0]\n        for number in numbers\
    \ {\n            if number > largest {\n                largest = number\n   \
    \         }\n        }\n        return largest\n    }\n\n    var smallest_2 =\
    \ smallest(numbers)\n    var smallest_1 = smallest(Set(numbers))\n    var smallest_3\
    \ = smallest(numbers.sorted())\n    var smallest_4 = smallest(numbers)\n\n   \
    \ var largest_2 = largest(numbers)\n    var largest_1 = largest(Set(numbers))\n\
    \    var largest_3 = largest(numbers.sorted())\n    var largest_4 = largest(numbers)\n\
    \n    let smallest_elements = Set<Double>(numbers).sorted()\n    let largest_elements\
    \ = Set<Double>(numbers).sorted(by: { $0 > $1 })\n\n    return smallest_1, smallest_2,\
    \ smallest_3, smallest_4, smallest_5, smallest_elements", "    let smallestDifference\
    \ = Double.infinity\n    var smallestDifferenceIndex = -1\n    var smallestDifferenceIndex2\
    \ = -1\n    for (index, value) in numbers.enumerated() {\n        let currentDifference\
    \ = abs(value - numbers[index])\n        if currentDifference < smallestDifference\
    \ {\n            smallestDifference = currentDifference\n            smallestDifferenceIndex\
    \ = index\n        }\n        if currentDifference < smallestDifference {\n  \
    \          smallestDifference = currentDifference\n            smallestDifferenceIndex2\
    \ = index\n        }\n    }\n    return (numbers[smallestDifferenceIndex], numbers[smallestDifferenceIndex2])",
  '    return find_closest_elements(numbers: numbers, index: 0, count: 1, sort: true)',
  "    guard numbers.count > 2 else { return (numbers[0], numbers[0]) }\n    let sortedNumbers\
    \ = numbers.sorted { $0 < $1 }\n    return (sortedNumbers[0], sortedNumbers[1])",
  "    let minIndex = numbers.reduce(0, {$0 + $1.distance($2)})\n    return numbers[minIndex],\
    \ numbers[minIndex + 1]", "    let minimum = numbers.min()\n    let maximum =\
    \ numbers.max()\n    let midpoint = 0.5 * (minimum + maximum)\n    var closest1\
    \ = closestElements(numbers, midpoint)\n    var closest2 = closestElements(numbers,\
    \ midpoint, false)\n    return (closest1, closest2)", '    return find_closest_elements(numbers,
    .ordered)', "    let sortedNumbers = numbers.sorted()\n    if numbers.count <\
    \ 2 {\n        return sortedNumbers[0], sortedNumbers[0]\n    }\n    let closestTo1\
    \ = sortedNumbers.first!\n    let closestTo2 = sortedNumbers[1]\n    let closestTo3\
    \ = sortedNumbers[2]\n    if closestTo1 <= closestTo2 {\n        return closestTo1,\
    \ closestTo2\n    }\n    if closestTo2 <= closestTo3 {\n        return closestTo2,\
    \ closestTo3\n    }\n    if closestTo3 <= closestTo1 {\n        return closestTo3,\
    \ closestTo1\n    }\n    return (sortedNumbers[0], sortedNumbers[1])", '  return
    find_closest_elements1(numbers)', "    var best1 = best2 = Double(numbers[0])\n\
    \    for i in 1..<numbers.count {\n        let candidate = numbers[i]\n      \
    \  if candidate > best1 {\n            best2 = best1\n            best1 = candidate\n\
    \        } else if candidate > best2 {\n            best2 = candidate\n      \
    \  }\n    }\n    return (best1, best2)", "  let min: Double = Float64(numbers[0])\n\
    \  let max: Double = Float64(numbers[1])\n  let mid: Double = min + ((max - min)\
    \ / 2)\n\n  var result: Double?\n  var minIndex: Int?\n  var maxIndex: Int?\n\n\
    \  for index in 0..<numbers.count {\n    let number: Double = numbers[index]\n\
    \n    if number < mid {\n      if let minIndex = minIndex, number < numbers[minIndex]\
    \ {\n        if result = nil, number < mid {\n          result = number\n    \
    \      minIndex = index\n        }\n      }\n    } else {\n      if let maxIndex\
    \ = maxIndex, number > numbers[maxIndex] {\n        if result = nil, number >\
    \ mid {\n          result = number\n          maxIndex = index\n        }\n  \
    \    }\n    }\n  }\n  guard result != nil else { return (nil, nil) }\n\n  return\
    \ (result ?? maxIndex, result ?? minIndex)", "    var smallestIndex = -1\n   \
    \ var largestIndex = numbers.count - 1\n\n    var smallestDistance = Double.infinity\n\
    \    var largestDistance = -Double.infinity\n    for i in 0..<numbers.count {\n\
    \        let distance = hypot(numbers[i], numbers[largestIndex])\n        if distance\
    \ < smallestDistance {\n            smallestDistance = distance\n            smallestIndex\
    \ = i\n        }\n        if distance > largestDistance {\n            largestDistance\
    \ = distance\n            largestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])", "    guard numbers.count > 2 else {\n        return\
    \ (0.0)\n    }\n    let smallestIndex = numbers.index(of: numbers.min())!\n  \
    \  let largestIndex = numbers.index(of: numbers.max())!\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])", "    let smallest: Double = numbers.min()!\n    let\
    \ largest: Double = numbers.max()!\n    return (smallest, largest)", "    if numbers.isEmpty()\
    \ {\n        return (numbers[0], numbers[0])\n    }\n    if numbers.count == 2\
    \ {\n        return (numbers[0], numbers[1])\n    }\n    if numbers.count == 3\
    \ {\n        if numbers[1] == numbers[0] {\n            return (numbers[0], numbers[1])\n\
    \        }\n        if numbers[0] == numbers[1] {\n            return (numbers[0],\
    \ numbers[1])\n        }\n    }\n    if numbers.count == 4 {\n        let a =\
    \ numbers[0]\n        let b = numbers[1]\n        let c = numbers[2]\n       \
    \ let d = numbers[3]\n        var x: Double\n        var y: Double\n        let\
    \ d = math.sqrt((b - a) * (b - a) + (c - d) * (c - d))\n        if d < math.sqrt((b\
    \ - c) * (b - c) + (d - a) * (d - a) + (d - b) * (d - b)) {\n            x = (b\
    \ + c) / 2.0\n            y = (d - a) / 2.0\n        } else {\n            x =\
    \ (b - a) / 2.0\n            y = (d - b) / 2.0\n        }\n        return (x,\
    \ y)\n    }\n    if numbers.count > 4 {\n        let a = numbers[0]\n        let\
    \ b = numbers[1]\n        let c = numbers[2]\n        let d = numbers[3]\n   \
    \     let e = numbers[4]\n        var x: Double\n        var y: Double\n     \
    \   let d = math.sqrt((b - a) * (b - a) + (c - d) * (c - d))\n        let e =\
    \ math.sqrt((e - d) * (e - d) + (e - b) * (e - b))\n        if d < math.sqrt((b\
    \ - c) * (b - c) + (d - a) * (d - a) + (d - b) * (d - b) + (e - c) * (e - c))\
    \ {\n            x = (b + c) / 2.0\n            y = (d - a) / 2.0\n        } else\
    \ {\n            x = (b - a) / 2.0\n            y = (d - b) / 2.0\n        }\n\
    \        return (x, y)\n    }\n    return (numbers[0], numbers[0])", "    let\
    \ smallest = min(numbers)\n    let largest = max(numbers)\n    if smallest ==\
    \ largest {\n        return (smallest, smallest)\n    }\n\n    var closest = (Double(largest),\
    \ largest)\n    var closestIndex = 0\n\n    for i in 0..<numbers.count {\n   \
    \     if numbers[i] != smallest {\n            continue\n        }\n\n       \
    \ let distance = (numbers[i] - closest[0]).squareRoot()\n        if distance <\
    \ closest[0].squareRoot() {\n            closest = (numbers[i], numbers[i])\n\
    \            closestIndex = i\n        }\n    }\n\n    return (closest[0], closest[1])",
  "    if numbers.count == 0 {\n        return (0.5, 0.5)\n    }\n\n    let minDistance\
    \ = numbers[0]\n    let maxDistance = numbers[0]\n\n    for i in 1..<numbers.count\
    \ {\n        let distance = abs(numbers[i] - minDistance)\n        if distance\
    \ < maxDistance {\n            minDistance = numbers[i]\n        } else {\n  \
    \          maxDistance = numbers[i]\n        }\n    }\n\n    return (minDistance,\
    \ maxDistance)", "    \n    // TODO: Should this return an error if numbers is\
    \ of length 0?\n    \n    if numbers.count < 2 {\n        return (numbers[0],\
    \ numbers[0])\n    }\n    \n    let arrayCount = numbers.count\n    \n    // Initialize\
    \ an array to hold all elements with the same index as the first element\n   \
    \ var array: [Double] = [0]\n    \n    for i in 0..<arrayCount {\n        array[i]\
    \ = numbers[0]\n    }\n    \n    // Now loop through each element in numbers array\
    \ starting with the second element\n    for i in 1..<arrayCount {\n        //\
    \ See if each number is less than the last number in the array\n        if array[i]\
    \ < array[i-1] {\n            // If so then just append the number\n         \
    \   array.append(numbers[i])\n        } else {\n            // If not then keep\
    \ a running total and check to see if the total is greater than the new number\
    \ and\n            // then append if so\n            \n            // The running\
    \ total\n            let runningTotal = array[i]\n            \n            //\
    \ The new number\n            let newNumber = numbers[i]\n            \n     \
    \       // If the total is greater than the new number then update it\n      \
    \      if runningTotal > newNumber {\n                array[i] = newNumber\n \
    \           } else {\n                // If the total is less than the new number\
    \ then check to see if the new number is greater than the previous\n         \
    \       // number in the array and if it is, then just append the new number\n\
    \                if array[i] > array[i-1] {\n                    array.append(newNumber)\n\
    \                }\n            }\n        }\n    }\n    \n    // Return the two\
    \ elements\n    return (array[0], array[1])", "  guard numbers.count > 1 else\
    \ { return (numbers[0], numbers[0]) }\n  let smallest = numbers[0]\n  let largest\
    \ = numbers[0]\n  for number in numbers {\n    if number < smallest { smallest\
    \ = number }\n    if number > largest { largest = number }\n  }\n  return (smallest,\
    \ largest)", "    var smallest = Double.greatestFiniteMagnitude\n    var largest\
    \ = Double.leastNormalMagnitude\n    var smallestIndex = 0\n    var largestIndex\
    \ = 0\n\n    for i in 0 ..< numbers.count {\n        let num = numbers[i]\n\n\
    \        if smallest > num {\n            largest = num\n            largestIndex\
    \ = i\n        } else {\n            smallest = num\n            smallestIndex\
    \ = i\n        }\n    }\n\n    return (numbers[smallestIndex], numbers[largestIndex])",
  "    // Find the nearest numbers\n    let nearestNumbers = numbers.sorted { $0 <\
    \ $1 }\n    // Return them in order\n    return (nearestNumbers[0], nearestNumbers[1])",
  '    return find_closest_elements(numbers, fromIndex: 0)', "    var min1 = numbers[0]\n\
    \    var min2 = numbers[0]\n    var minDiff = math.MaxFloat64\n\n    for i in\
    \ 1..numbers.count {\n        var d = abs(numbers[i] - numbers[i - 1])\n     \
    \   if d < minDiff {\n            minDiff = d\n            min1 = numbers[i]\n\
    \            min2 = numbers[i - 1]\n        } else {\n            if d > minDiff\
    \ {\n                return (min1, min2)\n            }\n        }\n    }\n  \
    \  return (min1, min2)", "    guard numbers.count > 1 else {\n        return numbers[0],\
    \ numbers[0]\n    }\n\n    var closest: Double!\n    var nextClosest: Double!\n\
    \    for _ in 0 ..< numbers.count - 1 {\n        nextClosest = closest\n     \
    \   let closestInArray = numbers.firstIndex(where: { number in\n            return\
    \ number < nextClosest\n        })\n\n        closest = (nextClosest: numbers[closestInArray],\
    \ closest: numbers[closestInArray + 1], closestInArray: closestInArray)\n    }\n\
    \n    return (closest, nextClosest)", "    if numbers.isEmpty {\n        return\
    \ (numbers[0], numbers[0])\n    }\n    var sortedNumbers = numbers.sorted()\n\
    \    if sortedNumbers.first != numbers[0] {\n        sortedNumbers = sortedNumbers.prefix(2)\n\
    \    }\n    return sortedNumbers.last!, sortedNumbers.first!", "    let min =\
    \ numbers[0]\n    let max = numbers[0]\n    for number in numbers {\n        if\
    \ number < min {\n            min = number\n        } else if number > max {\n\
    \            max = number\n        }\n    }\n    return (min, max)", "    guard\
    \ numbers.count >= 2 else {\n        return (0.0,0.0)\n    }\n    \n    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    \n    for i in 1..numbers.count\
    \ {\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n \
    \       } else if numbers[i] > largest {\n            largest = numbers[i]\n \
    \       }\n    }\n    \n    return (smallest, largest)", "    var smallest = Double.max\n\
    \    var largest = Double.min\n    for i in 0..numbers.count - 1 {\n        smallest\
    \ =< numbers[i]\n        largest =< numbers[i]\n        if smallest > largest\
    \ {\n            (smallest, largest) = (largest, smallest)\n        }\n    }\n\
    \    return (numbers[numbers.count - 1], numbers[numbers.count - 2])", "    let\
    \ sortedNumber = numbers.sorted()\n    return sortedNumber.first(where: {$0 >\
    \ sortedNumber.last()}), sortedNumber.last(where: {$0 < sortedNumber.first()})",
  "\tlet min1 = numbers.first!\n\tlet min2 = numbers.last!\n\tlet minDiff = abs(min1\
    \ - min2)\n\tlet minIndex1 = numbers.firstIndex(of: min1)!\n\tlet minIndex2 =\
    \ numbers.firstIndex(of: min2)!\n\n\treturn (min1, min2)", "    assert(numbers.count\
    \ >= 2)\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for\
    \ number in numbers {\n        if smallest > number {\n            smallest =\
    \ number\n        }\n        if largest < number {\n            largest = number\n\
    \        }\n    }\n    return smallest, largest", "    var min1 = Double.MaxValue\n\
    \    var min2 = Double.MaxValue\n    var max1 = Double.MinValue\n    var max2\
    \ = Double.MinValue\n\n    for number in numbers {\n        if number < min1 {\n\
    \            min2 = min1\n            min1 = number\n        }\n        if number\
    \ > max2 {\n            max2 = max1\n            max1 = number\n        }\n  \
    \  }\n\n    return (min1, max1)", "    // Create a lookup table of distances from\
    \ the first number to the others\n    var lookup: [Double: Double] = [:]\n   \
    \ for num in numbers {\n        let key = (num as AnyObject).description\n   \
    \     lookup[key] = lookup[key]?.lt(num) ? num : lookup[key]!\n    }\n\n    //\
    \ Return the first two that were not None\n    for (key, value) in lookup {\n\
    \        if (value == nil) { continue }\n        return (key, value)!\n    }\n\
    \n    // We should never get here since we checked all numbers in the lookup table\n\
    \    fatalError(\"find_closest_elements ran out of numbers to find\")", "    //\
    \ We are going to be working with two numbers so let's create a tuple\n    //\
    \ that we can return\n    var result = ((numbers[0]), numbers[1])\n    // Now\
    \ let's sort it\n    var sortedNumbers = numbers.sorted(by: <)\n    // Now let's\
    \ loop through it making sure we keep track of the smallest and largest\n    for\
    \ i in 2..<sortedNumbers.count {\n        if abs(sortedNumbers[i-1] - sortedNumbers[i])\
    \ < abs(result[1..<2].first - result[1..<2].last) {\n            result = (sortedNumbers[i-1],\
    \ sortedNumbers[i])\n        }\n    }\n    // If we made the loop we found something\n\
    \    return result", "    // Find smallest number in list\n    let smallest =\
    \ numbers.min()\n    // Find biggest number in list\n    let largest = numbers.max()\n\
    \    // Find differences between smallest and biggest number\n    let smallestDiff\
    \ = smallest - largest\n    // Iterate through list to find two closest number\n\
    \    // Return them in order\n    var closest = (smallest, largest)\n    for x\
    \ in numbers {\n        if abs(x - smallestDiff) < abs(x - closest.0) {\n    \
    \        closest = (x, smallest)\n        }\n        else if abs(x - smallestDiff)\
    \ < abs(x - closest.1) {\n            closest = (smallest, x)\n        }\n   \
    \ }\n    return (closest.0, closest.1)", "    guard numbers.count > 1 else {\n\
    \        return (0.0,0.0)\n    }\n    if numbers.count > 2 {\n        var bestDistance\
    \ = Double.max\n        var bestIndex = -1\n        for idx in 0..<numbers.count\
    \ {\n            let distance = distanceFrom(numbers[idx], numbers[bestIndex])\n\
    \            if bestDistance > distance {\n                bestDistance = distance\n\
    \                bestIndex = idx\n            }\n        }\n        return (numbers[bestIndex],\
    \ numbers[bestIndex])\n    }\n    return (numbers[0], numbers[0])", '    return
    find_closest_elements(numbers: numbers, offset: 0, distanceSquared: 0)', "  //\
    \ Sort the array\n  var sortedNumbers = numbers.sorted()\n  // Return the closest\
    \ two numbers\n  if sortedNumbers.count == 2 {\n    return sortedNumbers[0], sortedNumbers[1]\n\
    \  }\n  return sortedNumbers[0], sortedNumbers[1]", "    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n    for number in numbers {\n        if number\
    \ < smallest {\n            largest = smallest\n            smallest = number\n\
    \        } else if number > largest {\n            largest = number\n        }\n\
    \    }\n    return (smallest, largest)", '    return (numbers[0], numbers[1])',
  "    \n    let smallestDifference = numbers[0] - numbers[1]\n    var closestDifference\
    \ = smallestDifference\n    var closestIndex = 0\n    \n    for index in 1 ..<\
    \ numbers.count {\n        let difference = numbers[index] - numbers[index-1]\n\
    \        if difference < closestDifference {\n            closestDifference =\
    \ difference\n            closestIndex = index\n        }\n    }\n    return (numbers[closestIndex],\
    \ numbers[closestIndex])", "    var lowestDifference = Double(Int.max)\n    var\
    \ highestDifference = Double(0)\n    var highestDifferenceIndex: Int = 0\n   \
    \ for index in 0..<numbers.count {\n        let difference = numbers[index] -\
    \ numbers[highestDifferenceIndex]\n        if difference < lowestDifference {\n\
    \            lowestDifference = difference\n            highestDifferenceIndex\
    \ = index\n        } else if difference > highestDifference {\n            highestDifference\
    \ = difference\n            highestDifferenceIndex = index\n        }\n    }\n\
    \    return (numbers[highestDifferenceIndex], numbers[highestDifferenceIndex +\
    \ 1])", "    // TODO: Check if there are any elements that are equally close.\n\
    \    let index1 = 0\n    let index2 = numbers.count - 1\n    let smallest1 = numbers[index1]\n\
    \    let smallest2 = numbers[index2]\n\n    if numbers[index2] < numbers[index1]\
    \ {\n        index2--\n    }\n\n    if numbers[index2] < smallest1 {\n       \
    \ index1++\n    }\n\n    return (numbers[index1], numbers[index2])", "    let\
    \ smallest = min(numbers)\n    let largest = max(numbers)\n    if smallest ==\
    \ largest {\n        return (smallest, largest)\n    }\n    let midpoint = numbers.map(Float.init).reduce(Float.init(),\
    \ combine: min)\n    let smallestClosest = numbers.filter({\n        abs($0 -\
    \ midpoint) < abs($1 - midpoint)\n    })\n    let largestClosest = numbers.filter({\n\
    \        abs($0 - midpoint) > abs($1 - midpoint)\n    })\n    return (smallestClosest[0],\
    \ largestClosest[0])", "    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n\n    let smallestDiff = math.min(numbers.first, numbers.last)\n\
    \n    let smallestIndex = numbers.index(of: smallestDiff)\n    let largestIndex\
    \ = numbers.index(of: numbers[numbers.count-1])\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])", "    let maxIndex = numbers.count\n    let maxValue\
    \ = numbers[0]\n    var minIndex = maxIndex - 1\n    var minValue = numbers[0]\n\
    \    for i in 0..<maxIndex {\n        let value = numbers[i]\n        if value\
    \ > maxValue {\n            maxValue = value\n            maxIndex = i\n     \
    \   }\n        if value < minValue {\n            minValue = value\n         \
    \   minIndex = i\n        }\n    }\n    return (minValue, maxValue)", "    if\
    \ numbers.count < 2 {\n        return (0.0,0.0)\n    }\n\n    var lowest_value\
    \ = numbers[0]\n    var second_lowest_value = numbers[0]\n\n    for number in\
    \ numbers {\n        if number < lowest_value {\n            lowest_value = number\n\
    \        } else if number > lowest_value {\n            if second_lowest_value\
    \ < number {\n                second_lowest_value = number\n            }\n  \
    \      }\n    }\n\n    return (lowest_value, second_lowest_value)", "    guard\
    \ numbers.count >= 2 else {\n        fatalError(\"Not enough numbers to find\"\
    )\n    }\n    var closest = numbers[0]\n    var closestDiff = numbers[0]\n   \
    \ for x in numbers {\n        let absX = abs(x)\n        if absX < closestDiff\
    \ {\n            closestDiff = absX\n            closest = x\n        }\n    }\n\
    \    return (closest, closest)", "    \n    if numbers.count < 2 {\n        return\
    \ (numbers[0], numbers[0])\n    }\n    \n    let sortedNumbers = numbers.sorted()\n\
    \    \n    guard numbers.count > 2 else {\n        return (sortedNumbers[0], sortedNumbers[1])\n\
    \    }\n    \n    guard sortedNumbers[1] - sortedNumbers[0] > .MachineEpsilon\
    \ else {\n        return (sortedNumbers[0], sortedNumbers[1])\n    }\n    \n \
    \   let closestOne = sortedNumbers[numbers.count - 2]\n    let secondClosestOne\
    \ = sortedNumbers[numbers.count - 1]\n    \n    return (closestOne, secondClosestOne)",
  "    var smallest_diff : Double = -(1.0 / Double(numbers.count))\n    var smallest_x\
    \ : Double = 0\n    var largest_x : Double = 0\n    var largest_diff : Double\
    \ = -(1.0 / Double(numbers.count))\n\n    if numbers.count > 0 {\n        var\
    \ x : Double\n\n        for x in numbers {\n            var diff : Double\n  \
    \          var diff : Double\n\n            if x == numbers[0] {\n           \
    \     diff = abs(x - numbers[1])\n            } else {\n                diff =\
    \ abs(x - numbers[0])\n            }\n\n            if diff < smallest_diff {\n\
    \                smallest_diff = diff\n                smallest_x = x\n      \
    \      }\n\n            if diff > largest_diff {\n                largest_diff\
    \ = diff\n                largest_x = x\n            }\n        }\n\n        return\
    \ (smallest_x, largest_x)\n    } else {\n        return (0.0, 0.0)\n    }", " \
    \   let min = min(numbers, key: .init)\n    let max = max(numbers, key: .init)\n\
    \    return min < max ? min : max", "    let firstIndex = find_closest_index(numbers:\
    \ numbers, first: numbers[0], second: numbers[1])\n    let secondIndex = find_closest_index(numbers:\
    \ numbers, first: numbers[1], second: numbers[0])\n    return (numbers[firstIndex],\
    \ numbers[secondIndex])", "    // TODO: use sorting\n    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        } else if number > largest\
    \ {\n            largest = number\n        }\n    }\n    return (smallest, largest)",
  "    var closest1 = Float.leastNormalMagnitude\n    var closest2 = Float.leastNormalMagnitude\n\
    \    for i in 0..<numbers.count {\n        if abs(numbers[i] - closest1) < abs(numbers[i]\
    \ - closest2) {\n            closest1 = numbers[i]\n        } else if abs(numbers[i]\
    \ - closest2) < abs(numbers[i] - closest1) {\n            closest2 = numbers[i]\n\
    \        } else {\n            return numbers[i], numbers[i]\n        }\n    }\n\
    \    return closest1, closest2", '    return select_closest_elements(numbers:
    numbers)', "    // Sort numbers in increasing order\n    let sorted = numbers.sorted\
    \ { $0 < $1 }\n\n    // If sorted is empty return nil\n    if sorted.isEmpty {\n\
    \        return (nil, nil)\n    }\n\n    // Find two closest elements\n    let\
    \ closestOne = sorted[0]\n    let closestTwo = sorted[1]\n\n    // Return them\
    \ as pairs\n    return (closestOne, closestTwo)", "  if numbers.isEmpty {\n  \
    \  return (0.0, Double(0.0))\n  }\n\n  let min = numbers[0]\n  let max = numbers[0]\n\
    \  var min_d = 0.0\n  var max_d = Double(Double.greatestFiniteMagnitude)\n  for\
    \ d in numbers {\n    if d < min {\n      min_d = d\n      min = d\n    } else\
    \ if d > max {\n      max_d = d\n      max = d\n    }\n  }\n  return (min, max)",
  "    guard numbers.count > 1 else {\n        fatalError(\"An array of numbers of\
    \ length at least two must be supplied\")\n    }\n    guard numbers.count >= 2\
    \ else {\n        fatalError(\"An array of numbers of length at least two must\
    \ be supplied\")\n    }\n\n    let sorted = numbers.sorted()\n    guard numbers.count\
    \ == 2 else {\n        fatalError(\"An array of numbers of length at least two\
    \ must be supplied\")\n    }\n\n    var closest1 = sorted[0]\n    var closest2\
    \ = sorted[1]\n    guard let index1 = sorted.index(of: closest1) else {\n    \
    \    fatalError(\"The array must have a number at the zero index\")\n    }\n\n\
    \    guard let index2 = sorted.index(of: closest2) else {\n        fatalError(\"\
    The array must have a number at the one index\")\n    }\n\n    if abs(sorted[0]\
    \ - sorted[1]) < abs(sorted[index2] - sorted[index1]) {\n        closest1 = sorted[1]\n\
    \        closest2 = sorted[0]\n    }\n\n    return (closest1, closest2)", "  \
    \  var min_val: Double = 0.0\n    var max_val: Double = 0.0\n\n    for i in 0\
    \ ..< numbers.count {\n        min_val = numbers[i]\n        max_val = numbers[i]\n\
    \n        for j in 0 ..< numbers.count {\n            if j == i { continue }\n\
    \            if numbers[j] < min_val {\n                min_val = numbers[j]\n\
    \            }\n            if numbers[j] > max_val {\n                max_val\
    \ = numbers[j]\n            }\n        }\n\n        return (min_val, max_val)\n\
    \    }\n\n    return (numbers[0], numbers[0])", "    var smallest_diff: Double\
    \ = Double.infinity\n    var closest_to_smallest = Double.nan\n    for i in 0..<numbers.count\
    \ {\n        let current_diff = (numbers[i] - numbers[(i - 1) as Int]) * (numbers[(i\
    \ - 1) as Int])\n        if current_diff < smallest_diff {\n            smallest_diff\
    \ = current_diff\n            closest_to_smallest = numbers[i]\n        }\n  \
    \  }\n    return (closest_to_smallest, smallest_diff)", "    let min = numbers.min()\n\
    \    let max = numbers.max()\n    if min == max {\n        return (min, min)\n\
    \    }\n    // Find the smallest difference between the min and max values\n \
    \   let diff = abs(min - max)\n    if diff == 0 {\n        return (min, min)\n\
    \    }\n    // Find the two numbers in which they differ, the middle number\n\
    \    let mid = min + ((max - min) / 2)\n    // Return the two numbers in order\n\
    \    return (mid, mid)", "    var smallest: Double\n    var largest: Double\n\
    \    for i in 0..<numbers.count {\n        let distance = numbers[i] - numbers[0]\n\
    \        if smallest == 0.0 || distance < smallest {\n            smallest = distance\n\
    \        }\n        if largest == 0.0 || distance > largest {\n            largest\
    \ = distance\n        }\n    }\n    return (numbers[numbers.count - 1], largest)",
  "    let sortedNumbers = numbers.sorted()\n    return (sortedNumbers.first, sortedNumbers.last)",
  '    return find_closest_elements(numbers, numbers: numbers)']
stop_tokens:
- "\n}"
