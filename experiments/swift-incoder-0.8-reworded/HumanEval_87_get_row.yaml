name: HumanEval_87_get_row
language: swift
prompt: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
  \ is similar to matrix, however, unlike matrices,\n/// each row may contain a different\
  \ number of columns.\n/// Given lst, and integer x, find integers x in the array,\n\
  /// and return array of tuples, [(x1, y1), (x2, y2) ...] such that\n/// each tuple\
  \ is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates initially\
  \ by rows in ascending order.\n/// Also, sort coordinates of the row by columns\
  \ in descending order.\n/// Examples:\n/// >>> get_row(lst: [[1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0, 0), (1, 4), (1, 0), (2,\
  \ 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x: 1)\n/// [] as [(Int, Int)]\n\
  /// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3)\n/// [(2, 2)]\nfunc get_row(lst:\
  \ [[Int]], x: Int) -> [(Int, Int)] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
  \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
  \ 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
  \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0,\
  \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
  \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1,\
  \ 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2,\
  \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
  assert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
  \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1,\
  \ 2, 3]], x: 3) == [(2, 2)])"
completions: ["    return lst.sort { (first, second) -> Bool in\n        if let firstRow\
    \ = first[0], secondRow = second[0] {\n            return firstRow > secondRow\n\
    \        } else {\n            return false\n        }\n    }\n        .sorted(by:\
    \ >)", "    var coords: [((Int, Int), Int)] = [((), 0)]\n    var i: ((Int, Int),\
    \ Int)\n    var j: Int = 0\n    for row in lst {\n        if i == ((), 0) {\n\
    \            coords.append((row, j))\n        } else {\n            for _ in row\
    \ {\n                i += 1\n                coords.append((i, j))\n         \
    \   }\n        }\n        j += row.count\n    }\n    coords.sortInPlaceByValueForKey(Int.self,\
    \ by: { $0.1.0 < $0.1.0 })\n    coords.sortInPlaceByValueForKey(Int.self, by:\
    \ { $0.1.0 < $0.1.0 })\n    return coords.map { x in\n        (x.1, x.2)\n   \
    \ }", "  var ret = [Int]()\n  for row in lst {\n    for col in row.indices {\n\
    \      if row[col] == x {\n        ret.append(col)\n        break\n      }\n \
    \   }\n  }\n  ret.sort { $0 > $1 }\n  ret.reverse()\n  return ret", "    var coords\
    \ = make([][(Int, Int)], 0, len(lst))\n    var res = [][(Int, Int)]()\n    for\
    \ (i, row) in lst.enumerated() {\n        coords = coords + make([][(Int, Int)],\
    \ 0, len(row))\n        for (i, val) in row.enumerated() {\n            if val\
    \ == x {\n                coords[i] = coords[i] + make([][(Int, Int)], 1, 2)\n\
    \                break\n            }\n        }\n    }\n    for coord in coords\
    \ {\n        var row = coord[0]\n        var col = coord[1]\n        for (i, val)\
    \ in row.enumerated() {\n            if val < col {\n                row = i\n\
    \                col = val\n            }\n        }\n        res += make([][(Int,\
    \ Int)], 1, 2)\n        res += make([][(Int, Int)], 0, row)\n        res += make([][(Int,\
    \ Int)], row, col)\n    }\n    return res", "    if lst == [] as [[Int]]  {\n\
    \        return [] as [(Int, Int)]\n    }\n    var row = [Int]()\n    for i in\
    \ lst {\n        row.append(i)\n    }\n    row.sort()\n    for i in row {\n  \
    \      row.sort()\n        row.sort()\n        if row[i] != x {\n            return\
    \ nil\n        }\n    }\n    return row.reverse()", "    let mut rows = [[(Int,\
    \ Int)]]()\n    for row in lst {\n        for (i, v) in row.enumerated() {\n \
    \           if v == x {\n                rows.append((i, v))\n               \
    \ break\n            }\n        }\n    }\n    rows.sortInPlace()\n    rows.sortInPlace{\
    \ $0.0 < $1.0 }\n    return rows", "    return lst.sort({ $0[$1] < $1[$1] })\n\
    \            .sort({ $0[$1] < $1[$1] }, {$0[$1] == $1[$1]})\n            .filter({\
    \ $0[$1] == x })\n            .sorted({ $0[$1] > $1[$1] })\n            .map({\
    \ $0 })\n            .map{ [$0, x] }", "    if lst == nil || lst.isEmpty {\n \
    \       return nil\n    }\n\n    let maxRow = max(lst.map({ $0.count }))\n   \
    \ var indexes: [Int] = [0]\n    var tmpIndex = 0\n    for i in 0..<maxRow {\n\
    \        if lst[i].contains(x) {\n            tmpIndex++\n            indexes.append(tmpIndex)\n\
    \        }\n    }\n    indexes.sort(by: { $0 < $1 })\n\n    var result = [(x:\
    \ x, y: 0)]\n    for i in 0..<maxRow {\n        if lst[i].contains(x) {\n    \
    \        if result.count >= 2 {\n                break\n            }\n      \
    \      result.append(result[indexes[i]])\n        }\n    }\n    return result\
    \ as [[(Int, Int)]]", "    if lst.isEmpty {\n        return nil\n    }\n    \n\
    \    if x < 0 || x >= lst[0][0].count {\n        return nil\n    }\n    \n   \
    \ let cols = lst[0][0].count\n    var coordinates = [(Int, Int)]()\n    var row\
    \ = 0\n    while row < lst.count {\n        var column = 0\n        while column\
    \ < cols {\n            coordinates.append((row, column))\n            column\
    \ += 1\n        }\n        row += 1\n    }\n    coordinates.sortInPlace({ $0.1\
    \ < $1.1 })\n    coordinates.sortInPlace({ $0.0 < $1.0 })\n    \n    var ret:\
    \ [(Int, Int)] = []\n    for coord in coordinates {\n        var retRow = lst[coord.0]\n\
    \        var retColumns = lst[coord.0].suffix(1)\n        var result: [[(Int,\
    \ Int)]] = []\n        for retCol in retColumns {\n            if retCol == x\
    \ {\n                result.append(retRow)\n            }\n        }\n       \
    \ if result.count == 0 {\n            ret = nil\n            break\n        }\n\
    \        ret = result + ret\n    }\n    return ret as! [(Int, Int)]", "\tvar tmp\
    \ = [(x, x)]\n\tfor _, row := range lst {\n\t\ttmp := []\n\t\tfor _, col := range\
    \ row {\n\t\t\tif col == x {\n\t\t\t\ttmp = append(tmp, (x, col))\n\t\t\t}\n\t\
    \t}\n\t\tsort.SliceStable(tmp, func(i, j int) bool {\n\t\t\treturn tmp[i].0 >\
    \ tmp[j].0\n\t\t})\n\t\ttmp = tmp[:len(tmp)-1]\n\t}\n\treturn tmp", "    if lst.isEmpty\
    \ {\n        return [] as [(Int, Int)]\n    }\n\n    var result = [(Int, Int)]()\n\
    \    var rowIdx = -1\n    var colIdx = -1\n    var r = 0\n    for _list in lst\
    \ {\n        r++\n        if r > x {\n            break\n        }\n        colIdx\
    \ = -1\n        for _element in _list {\n            colIdx++\n            if\
    \ colIdx > x {\n                break\n            }\n            result.append(((rowIdx,\
    \ colIdx), (_element)))\n        }\n        rowIdx = r\n    }\n\n    return sorted(result,\
    \ byRowsDescending)", "    var coords = Array(0..<(lst[0].count)).sorted()\n \
    \   for row in lst {\n        coords.sortInPlace()\n        coords.sortInPlace{\
    \ $0.1 < $1.1 }\n        for (row, c) in coords.enumerated() {\n            if\
    \ c == x {\n                return coords + [(row, 0)]\n            }\n      \
    \  }\n    }\n    return []", "    return lst.sorted().map {\n        $0.enumerate().filter({$0.element\
    \ == x})\n    }.sorted().reversed()", "    var result = lst[0]\n    if result.isEmpty\
    \ {\n        return lst\n    }\n    let rowCount = result.count\n    if rowCount\
    \ == 0 {\n        return lst\n    }\n    var coordinates = [(0, 0), (0, rowCount\
    \ - 1)]\n    for j in 1..rowCount {\n        if result[j - 1] < x {\n        \
    \    coordinates.append((j, result[j - 1]))\n        } else {\n            coordinates.append((j,\
    \ result[j - 1] - x))\n        }\n    }\n    coordinates.sort{ $0.0 < $1.0 }\n\
    \    coordinates.sort{ $0.1 < $1.0 }\n    return result[coordinates[0][0]]..result[coordinates[coordinates.count-1][1]]",
  "  if lst.count == 0 {\n    return []\n  }\n  var result = [(0, 0)]\n  for row in\
    \ lst {\n    for j in 0..row.count {\n      if row[j] == x {\n        result.append((j,\
    \ 0))\n        break\n      }\n    }\n  }\n  result.sort(by: {\n    $0[0] > $1[0]\n\
    \  })\n  return result.sort(by: {\n    $0[1] > $1[1]\n  })", "    guard lst.count\
    \ > 0 else {\n        return []\n    }\n    \n    var row = [Int]()\n    var coords\
    \ = [(Int, Int)]()\n    \n    for row in lst {\n        coords.append((row, row.count-1))\n\
    \    }\n    \n    return coords.sorted(by: { $0.0 < $1.0 }).sorted(by: { $1.0\
    \ > $0.0 }).flatMap { (row, _) in\n        return row.map { (_, idx) -> (Int,\
    \ Int) in\n            return (row, idx)\n        }\n    }.filter({ (row, _) in\
    \ row == x }).sorted { ($0.0 < $1.0) }.sorted { ($0.1 < $1.1) }.flatMap { (row,\
    \ _) in\n        return row.map { (_, idx) -> (Int, Int) in\n            return\
    \ (row, idx)\n        }\n    }", "    return lst.map{ row -> [(Int, Int)] in\n\
    \        guard row != nil else { return [] }\n        var tuples: [Int:Int] =\
    \ [:]\n        for row in row {\n            tuples[row] = row\n        }\n  \
    \      tuples[x] = x\n        return tuples\n    }.sorted(by: { $0.0 < $1.0 })",
  "    var lst_ = lst\n    var i = 0\n    var j = lst_.count\n\n    while i < j {\n\
    \        if lst_[i] == x {\n            return lst_.subarrayWithRange(NSMakeRange(i,\
    \ 1)).map { tuple -> [Int] in\n                return (tuple.0, 1)\n         \
    \   }\n        }\n        i += 1\n    }\n    return []", "    if lst.isEmpty {\n\
    \        return []\n    }\n    let sorted = lst.sorted { $0.0 < $1.0 }\n    return\
    \ sorted.enumerate().flatMap { row, in\n        return sorted[row - 1].enumerate().flatMap\
    \ { column, in\n            if row == sorted[0].startIndex && column == sorted[0].endIndex\
    \ {\n                return []\n            }\n            let (x, y) = sorted[row].enumerated().first\n\
    \            let (x2, y2) = sorted[row - 1].enumerated().first\n            let\
    \ r = row + 1\n            if x < x {\n                return [(row, x), (row,\
    \ x2)]\n            } else if x > x {\n                return [(row, y), (row,\
    \ y2)]\n            } else if y < y {\n                return [(r, y), (r, y2)]\n\
    \            } else {\n                return [(r, x), (r, x2)]\n            }\n\
    \        }\n    }", "    if lst.isEmpty {\n        return []\n    }\n    \n  \
    \  var rows = lst\n    var cols: [[Int]]\n    if rows.count != 1 {\n        cols\
    \ = rows\n    }\n    else {\n        cols = rows[0]\n    }\n    \n    var ret:\
    \ [[(Int, Int)]] = []\n    for i in 0..<cols.count {\n        col = cols[i]\n\
    \        if col.contains(x) {\n            var ret: [[(Int, Int)]] = []\n    \
    \        for j in 0..<row.count {\n                row = rows[j]\n           \
    \     let rowCoord = make_coordinate(i, j)\n                var ret2 = []\n  \
    \              for k in 0..<row.count {\n                    let coord = make_coordinate(i,\
    \ k)\n                    ret2.append((rowCoord, coord))\n                }\n\
    \                ret.extend(ret2)\n            }\n            ret.sortInPlaceBy({\
    \ (tuple1, tuple2) -> Bool in\n                return tuple1[0].1 > tuple2[0].1\n\
    \            })\n            ret.sortInPlaceBy({ (tuple1, tuple2) -> Bool in\n\
    \                return tuple1[0].2 > tuple2[0].2\n            })\n          \
    \  ret.sortInPlaceBy({ (tuple1, tuple2) -> Bool in\n                return tuple1[0].2\
    \ > tuple2[0].2\n            })\n            ret.sortInPlaceBy({ (tuple1, tuple2)\
    \ -> Bool in\n                return tuple1[0].1 > tuple2[0].1\n            })\n\
    \            \n            ret.sort(by: { (tuple1, tuple2) -> Bool in\n      \
    \          return tuple1[0].1 < tuple2[0].1\n            })\n            \n  \
    \          ret.sortInPlaceBy({ (tuple1, tuple2) -> Bool in\n                return\
    \ tuple1[0].1 < tuple2[0].1\n            })\n            ret.sortInPlaceBy({ (tuple1,\
    \ tuple2) -> Bool in\n                return tuple1[0].2 < tuple2[0].2\n     \
    \       })\n            ret.sortInPlaceBy({ (tuple1, tuple2) -> Bool in\n    \
    \            return tuple1[0].2 < tuple2[0].2\n            })\n            ret.sortInPlaceBy({\
    \ (tuple1, tuple2) -> Bool in\n                return tuple1[0].1 < tuple2[0].1\n\
    \            })\n            \n            ret.append(rowCoord)\n        }\n \
    \   }\n    \n    return ret", "    var sortedRow = lst.sorted()\n    if sortedRow.isEmpty()\
    \ {\n        return []\n    }\n\n    var row: [Int] = []\n    var col: [Int] =\
    \ []\n\n    for element in sortedRow {\n        if element.contains(x) {\n   \
    \         row.append(element.index)\n            col.append(element.count)\n \
    \       }\n    }\n\n    row.sort()\n    col.sort()\n\n    return row.reverse().map\
    \ { (r, c) -> (Int, Int) in\n        return (r, c) }", "    if lst.isEmpty() {\n\
    \        return [] // nothing to do\n    }\n    if lst.count < 1 {\n        return\
    \ []\n    }\n\n    \n    var rs = lst[0]\n    for r in lst {\n        if r.contains(x)\
    \ {\n            rs = (rs, r) // swap rows\n        }\n    }\n\n    var result\
    \ = [(Int, Int)]()\n    var r = 0\n    for c in rs.enumerate() {\n        if r.contains(x)\
    \ {\n            result.append((c[1], c[0]))\n        }\n        r++\n    }\n\
    \    \n    // sort by rows\n    var i = 0\n    for r in result {\n        for\
    \ _ in 0...i {\n            r = r.sorted()\n        }\n        i--\n    }\n  \
    \  // sort by columns\n    for r in result {\n        for _ in 0...i {\n     \
    \       r = r.sorted()\n        }\n        i--\n    }\n    return result", '    return
    lst.sort(by: { (r, _) in r <= x}).reverse().sort(by: { (_, d) in -d <= x }).map
    { (c, r) in (c, (r, r))}', "    if lst.is_empty() {\n        return []\n    }\n\
    \    var row_with_x = []\n    for row in lst {\n        let row_with_x_i = row\n\
    \        for (i, v) in row_with_x_i.enumerated() {\n            if v == x {\n\
    \                row_with_x.append((i, v))\n            }\n        }\n    }\n\
    \    sort_row_in_descending_order(row_with_x)\n    sort_column_of_row(row_with_x,\
    \ 0)\n    return row_with_x", "    if lst.is_empty() {\n        return [] as [(Int,\
    \ Int)]\n    }\n\n    // find x\n    let row = lst.firstIndex(where: { $0[0] ==\
    \ x })\n    if row < 0 {\n        return [] as [(Int, Int)]\n    }\n\n    // find\
    \ y by row\n    let index = lst.index(before: row)\n    let row = lst[row]\n\n\
    \    // find x by y\n    let y = row.firstIndex(where: { $0[0] == x })\n    if\
    \ y < 0 {\n        return [] as [(Int, Int)]\n    }\n\n    // get coordinates\n\
    \    let coords = [(row - index, y)]\n    coords.sort{ $0.1 < $1.1 }\n    coords.sort{\
    \ $0.1 < $1.1 }\n    return coords", "    var xs = x\n    var res = make([], (len(lst)+1)/2)\n\
    \    var i = 0\n    for row in lst {\n        if i > 0 {\n            res[i] =\
    \ (xs, xs)\n        }\n        xs = xs % row[0]\n        if xs == 0 {\n      \
    \      xs = row[0]\n        }\n        i = i + 1\n    }\n    res[i] = (xs, xs)\n\
    \    res.sort()\n    res[i].sort()\n    return res", "    // Write your code here.\n\
    \    if lst.isEmpty || x <= 0 {\n        return lst.isEmpty ? [] : []\n    }\n\
    \    var ret = [(Int, Int)]()\n    var i = 0\n    for row in lst {\n        if\
    \ i > 0 {\n            for column in row {\n                if column == x {\n\
    \                    ret.append((i, row[0]))\n                }\n            }\n\
    \        }\n        i += 1\n    }\n    ret.sort{ $0.0 < $1.0 }\n    ret.sort{\
    \ $1.0 > $0.1 }\n    return ret", "    if lst.count == 0 {\n        return []\
    \ as [(Int, Int)]\n    }\n    // Sort row coordinates by columns in descending\
    \ order.\n    var lst = lst as! [[Int]]\n    for row in lst {\n        row.sort()\n\
    \    }\n    for row in lst {\n        row.sort()\n    }\n    if lst[0].count <=\
    \ x {\n        return [] as [(Int, Int)]\n    }\n    var index = 0\n    var res\
    \ = lst[index] as [(Int, Int)]\n    while index != lst.count-1 {\n        index++\n\
    \        index %= lst.count\n        res[(index, 0)] = lst[index]\n    }\n   \
    \ res.sort()\n    return res", "    guard let lst = lst as? [[Int]] else { return\
    \ [] }\n    var rows = [[(Int, Int)]]()\n    var i = 0\n    while i < lst.count\
    \ {\n        var row = [(Int, Int)]()\n        for row in rows {\n           \
    \ var found = 0\n            for element in row[0] {\n                if element\
    \ == x {\n                    row.append((i, element))\n                    found\
    \ = 1\n                    break\n                }\n            }\n         \
    \   if found == 0 {\n                row.append((i, x))\n            }\n     \
    \   }\n        if rows.count < i {\n            rows.append(row)\n        } else\
    \ {\n            rows.sort() { $0[1] < $1[1] }\n            rows.sort() { $0[0]\
    \ < $1[0] }\n        }\n        i += 1\n    }\n    return rows", "    var ret\
    \ = lst as [[(Int, Int)]]\n    if lst == nil {\n        return []\n    }\n\n \
    \   for i in 0..<lst.count {\n        for j in 0..<lst[i].count {\n          \
    \  if lst[i][j] == x {\n                ret = ret + ([(i, j), (i + 1, j + 1)])\n\
    \            }\n        }\n    }\n\n    ret = ret.sort { $0.0 < $1.0 }.map { $0.1\
    \ }.reverse()\n    return ret", "    if lst.isEmpty { return [] }\n    var result\
    \ = [(0, x)]\n    for row in lst {\n        var newRow = row\n        row.sort()\n\
    \        row.sort({ $0.1 < $1.1 })\n        for column in row.filter({ $0 != x\
    \ }) {\n            let columnIndex = row.firstIndex(where: { $0 == column })\n\
    \            newRow = row[(columnIndex + 1)..<row.count]\n        }\n        result.append(newRow)\n\
    \    }\n    result.sort(by: { $0.1 < $1.1 })\n    result.sort(by: { $0.1 < $1.1\
    \ })\n    return result", "    return lst.map{ [i, j] in (i, j) }\n        .filter{\
    \ [i, j] in\n            i == x || j == x\n        }\n        .sort{ $0.0 > $0.1\
    \ }", "    if lst.isEmpty {\n        return []\n    }\n    var result = [0]\n\
    \    for row in lst {\n        var coord = []\n        for row in result {\n \
    \           for column in row {\n                coord.append((row, column))\n\
    \            }\n        }\n        coord = coord.sorted(by: {$0.0 < $1.0})\n \
    \       coord = coord.sorted(by: {$0.1 < $1.0})\n        coord = coord.sorted(by:\
    \ {$0.2 < $1.0})\n        coord = coord.sorted(by: {$0.3 < $1.0})\n        coord\
    \ = coord.sorted(by: {$0.4 < $1.0})\n        coord = coord.sorted(by: {$0.5 <\
    \ $1.0})\n        coord = coord.sorted(by: {$0.6 < $1.0})\n        coord = coord.sorted(by:\
    \ {$0.7 < $1.0})\n        coord = coord.sorted(by: {$0.0 < $1.0})\n        coord\
    \ = coord.sorted(by: {$0.1 < $1.0})\n        coord = coord.sorted(by: {$0.2 <\
    \ $1.0})\n        coord = coord.sorted(by: {$0.3 < $1.0})\n        coord = coord.sorted(by:\
    \ {$0.4 < $1.0})\n        coord = coord.sorted(by: {$0.5 < $1.0})\n        coord\
    \ = coord.sorted(by: {$0.6 < $1.0})\n        coord = coord.sorted(by: {$0.7 <\
    \ $1.0})\n        coord = coord.sorted(by: {$0.0 < $1.0})\n        coord = coord.sorted(by:\
    \ {$0.1 < $1.0})\n        coord = coord.sorted(by: {$0.2 < $1.0})\n        coord\
    \ = coord.sorted(by: {$0.3 < $1.0})\n        coord = coord.sorted(by: {$0.4 <\
    \ $1.0})\n        coord = coord.sorted(by: {$0.5 < $1.0})\n        coord = coord.sorted(by:\
    \ {$0.6 < $1.0})\n        coord = coord.sorted(by: {$0.7 < $1.0})\n        coord\
    \ = coord.sorted(by: {$0.0 < $1.0})\n        coord = coord.sorted(by: {$0.1 <\
    \ $1.0})\n        coord = coord.sorted(by: {$0.2 < $1.0})\n        coord = coord.sorted(by:\
    \ {$0.3 < $1.0})\n        coord = coord.sorted(by: {$0.4 < $1.0})\n        coord\
    \ = coord.sorted(by: {$0.5 < $1.0})\n        coord = coord.sorted(by: {$0.6 <\
    \ $", "    guard lst.count > 0 else {\n        return []\n    }\n    \n    let\
    \ rowCount = lst.count\n    var rowCoordinates = [(0, 0)]\n    \n    for row in\
    \ lst {\n        var rowCoordinatesTuples = [(Int, Int)]()\n        for column\
    \ in row {\n            var rowCoordinatesTuple = (row, column)\n            guard\
    \ let rowIndex = rowCoordinates.index(where: { $0.row == row }) else {\n     \
    \           rowCoordinates.append(rowCoordinate)\n                continue\n \
    \           }\n            let rowCoordinatesTupleIndex = rowCoordinatesTuples.index(where:\
    \ { $0.column == column })\n            guard let rowCoordinatesTupleIndex = rowCoordinatesTuples.index(where:\
    \ { $0.column >= column }) else {\n                rowCoordinatesTuples.append(rowCoordinatesTuple)\n\
    \                continue\n            }\n            rowCoordinatesTuples.remove(at:\
    \ rowCoordinatesTupleIndex)\n            rowCoordinatesTuples.append((rowCoordinatesTuple.row\
    \ + 1, rowCoordinatesTuple.column - 1))\n        }\n        rowCoordinates = rowCoordinatesTuples\n\
    \    }\n    \n    return rowCoordinates", "    if lst.isEmpty {\n        return\
    \ []\n    }\n\n    var r: [(Int, Int)]\n    var c: [(Int, Int)]\n\n    r = lst[0]\n\
    \    c = r\n    for _ in 1...lst[0][0].count {\n        if c[0].1 < x {\n    \
    \        c = (c[0].1, c[0].2)\n        }\n\n        if c[1].2 < x {\n        \
    \    c = (c[1].2, c[1].1)\n        }\n\n        r = append(r, c)\n        c =\
    \ r\n    }\n\n    return r", "    if lst.isEmpty() {\n        return nil\n   \
    \ }\n\n    var row = [Int]()\n    var lastCol = lst[0].count\n\n    var currentRow\
    \ = 0\n    var currentCol = 0\n    for _ in 0..<lst.count {\n        let newRow\
    \ = lastCol - currentCol\n        row.insert(newRow, at: 0)\n        currentRow++\n\
    \        currentCol = 0\n    }\n\n    row.insert(x, at: row.endIndex)\n    row.sortInPlace()\n\
    \n    var coords = Array(0..<row.count)\n    for j in 0..<row.count {\n      \
    \  coords[j] = (row[j], j)\n    }\n\n    return coords.reversed() as [(Int, Int)]",
  "    \n    var result = [(Int, Int)]()\n    var row = [Int]()\n    \n    for row\
    \ in lst {\n        \n        for column in row {\n            \n            if\
    \ column == x {\n                \n                for ix in 0..<row.count {\n\
    \                    \n                    result.append( ((row - 1)*row.count\
    \ + ix, column) )\n                    \n                }\n            }\n  \
    \      }\n    }\n    \n    result.sort()\n    result.sort(by: {$0.0 < $1.0})\n\
    \    \n    return result", "    var result = lst\n    var row = 1\n    var col\
    \ = 1\n    while row < lst.count {\n        let len = lst[row].count\n       \
    \ row += 1\n        col = 1\n        while col < len {\n            if lst[row][col]\
    \ == x {\n                col += 1\n            } else {\n                break\n\
    \            }\n        }\n        if col == len {\n            if row == lst.count\
    \ {\n                return [] as [(Int, Int)]\n            }\n            let\
    \ start = lst[row]\n            row += 1\n            col = 1\n            while\
    \ col < start.count {\n                if lst[row][col] == x {\n             \
    \       col += 1\n                } else {\n                    break\n      \
    \          }\n            }\n            result.append((row, col)) // start\n\
    \        }\n    }\n    return result", "    if lst.isEmpty() {\n        return\
    \ []\n    }\n\n    if lst.first().isEmpty() {\n        if lst.contains(at: x)\
    \ == false {\n            return []\n        }\n        return [(x - 1, 0)]\n\
    \    }\n\n    if x != lst.first().first {\n        return []\n    }\n\n    var\
    \ tmp: [(Int, Int)] = [(lst.first().first - 1, 0)]\n    for x in lst.indices {\n\
    \        let row: [[Int]] = lst[x]\n        row.sort { x, y -> Bool in\n     \
    \       return x > y\n        }\n        row.sort { x, y -> Bool in\n        \
    \    return y > x\n        }\n        row.sort { x, y -> Bool in\n           \
    \ return y > x\n        }\n        tmp.append((x - 1, row.last!.last!))\n    }\n\
    \n    return tmp", "    if lst.isEmpty() {\n        return []\n    }\n    var\
    \ result = [(Int, Int)]()\n    var i = 0\n    while i < lst.count {\n        let\
    \ lstI = lst[i]\n        var j = 0\n        while j < lstI.count {\n         \
    \   if lstI[j] == x {\n                result.append((i, j))\n            }\n\
    \            j += 1\n        }\n        i += 1\n    }\n    return result", " \
    \   if lst.isEmpty {\n        return [] as [(Int, Int)]\n    }\n\n    var cols\
    \ = [Int]()\n    var results = [(0, 0)]\n    for row in lst {\n        var resultRow\
    \ = (0, 0)\n        for column in row {\n            if column == x {\n      \
    \          resultRow = (resultRow + 1, cols.count)\n            }\n          \
    \  cols.append(column)\n        }\n        results.append(resultRow)\n    }\n\n\
    \    return results", "    let rows = lst.map({ $0.count }).max()!\n    let cols\
    \ = lst[0].count\n    \n    var coords = [(i, j) for i in 0...rows-1 ... 0]\n\
    \    for i in (0..rows).sorted() {\n        coords.append( (i, lst[i].count-1,\
    \ j) in (0..cols).sorted() \n            ? coords.map { $0.0 < $1.0 ? $0.0 : $1.0\
    \ }\n            : [(0, 0), (0, 0)])\n    }\n    return coords.map { coord ->\
    \ (Int, Int) in\n        let (row, col) = coord\n        let index = col - x\n\
    \        return (row, index)\n    }", "    guard lst.isEmpty == false else { return\
    \ [] }\n    var rows = [[(Int, Int)]]()\n    let maxRow = lst[0].count\n    var\
    \ row = lst[0][x] // get row from matrix\n    var c = 0\n    for row in lst {\n\
    \        var lastRow = rows[rows.index(row)!]\n        if lastRow.count == maxRow\
    \ { // in last row, all rows except last column are equal\n            rows[rows.index(row)!]\
    \ = [(row[0] - c, row.length - c)]\n        } else {\n            rows.append(lastRow.map({\
    \ (r: (Int, Int)) -> Int in\n                var r = row\n                r[0]\
    \ -= c\n                r[1] -= c\n                return r\n            }))\n\
    \            rows.append((row[0] - c, row.length - c))\n        }\n        c +=\
    \ lastRow.count\n    }\n    return rows", "    var result = [(Int, Int)]()\n \
    \   var index = 0\n    if lst == nil {\n        return result\n    }\n    for\
    \ row in lst {\n        for col in row {\n            if col == x {\n        \
    \        result.append((index, col))\n                break\n            }\n \
    \           index++\n        }\n    }\n    if index < 0 {\n        return result\n\
    \    }\n    return result.sort{ $0.0 > $1.0 }.sort{ $0.1 > $1.0 }", "    if lst\
    \ == nil || len(lst) == 0 {\n        return []\n    }\n\n    let rows = lst.count\n\
    \    var ans = [(0, 0)]\n    for row in lst {\n        let columns = row.count\n\
    \        if columns > 0 {\n            for i in 0..<rows {\n                for\
    \ (j, c) in row.enumerated() {\n                    if c == x {\n            \
    \            ans = append(ans, (i, j))\n                        break\n      \
    \              }\n                }\n            }\n        }\n    }\n    ans\
    \ = ans.sorted { $0.0 < $1.0 }\n    return ans", "    precondition(is_sorted(lst),\
    \ \"Sorted lst is required.\")\n    precondition(x >= 0, \"Indexing out of bounds.\"\
    )\n\n    var row = lst.slice()\n    var coords = [(Int, Int)]()\n    let (lo,\
    \ hi) = row.count\n    var i = lo\n    for col in 0..<hi {\n        coords.append((i,\
    \ col))\n        i += 1\n    }\n\n    coords.sort{$0.0 < $1.0}\n    coords.sort{$1.0\
    \ > $1.0}\n    return coords.map {\n        let (row, col) = coords[$0.0].1 //\
    \ the index is wrong, fix\n        return ((row, col), lst[$0.0].subarray(row+1,\
    \ row+col+1))\n    }", "    if lst.isEmpty {\n        return asArrayOfTuples([])\n\
    \    }\n\n    var results = [((0, 0), (0, 0))]\n    var y = 0\n\n    for r in\
    \ range(len(lst)) {\n        var r = r\n        var x = lst[r]\n        var cols\
    \ = 0\n\n        while x < x {\n            x++\n            cols++\n        }\n\
    \n        for c in range(cols) {\n            var c = c\n            var y = r\n\
    \n            while y < y {\n                y++\n            }\n\n          \
    \  results.append((r, c))\n        }\n    }\n\n    results.sort()\n    results.sort(byColumnsInReverse)\n\
    \n    return results", "    var rows = [[(Int, Int)]]()\n    let n = lst.count\n\
    \    var i = 0\n    for row in lst {\n        let len = row.count\n        var\
    \ found = false\n        for (j, col) in row.enumerated() {\n            if j\
    \ == 0 || i == n || col == x {\n                found = true\n               \
    \ break\n            }\n        }\n        if found {\n            row.sortInPlace()\n\
    \            for (j, col) in row.enumerated() {\n                rows.insert(rows[rows.index(row,\
    \ equalTo: j)], at: i)\n            }\n        }\n        i += 1\n    }\n    return\
    \ rows[rows.index(rows, equalTo: 0)]", "    if lst.isEmpty {\n        return nil\n\
    \    }\n    var row: [(Int, Int)] = [(Int, Int)]()\n    row.sortInPlaceBy({ $0.0\
    \ < $1.0 })\n    if row.count <= 0 {\n        return nil\n    }\n    row.sortInPlaceBy({\
    \ $1.0 > $0.0 })\n    var rowIndex = 0\n    var columnIndex = 0\n    var currentRow:\
    \ [[Int]] = lst\n    let rowSize = row.count\n    let rowElements = row[0].count\n\
    \    for columnIndex < rowSize {\n        for row in currentRow {\n          \
    \  if row[columnIndex] == x {\n                var coord = (rowIndex, columnIndex)\n\
    \                if columnIndex < rowElements {\n                    coord +=\
    \ (-rowIndex, columnIndex)\n                }\n                row.insert(coord,\
    \ 0)\n            }\n        }\n        rowIndex++\n        currentRow = row\n\
    \    }\n    return row", "    var coordinates = [(Int, Int)]()\n    for i in 0..<lst.count\
    \ {\n        let xs = lst[i]\n        var xs_sorted = [Int]()\n        for j in\
    \ 0..<xs.count {\n            xs_sorted.append(xs[j])\n        }\n        xs_sorted.sort()\n\
    \        xs_sorted.reverse()\n        coordinates.append((i, xs_sorted[0]))\n\
    \        for j in 1..<xs_sorted.count {\n            coordinates.append((i, xs_sorted[j]))\n\
    \        }\n    }\n    coordinates.sortBy{($1, $2)}\n    coordinates.sort{$0.1\
    \ < $1.1}\n    return coordinates", "    var tuples = []\n    for rowId in 0..<lst.count\
    \ {\n        for row in lst[rowId] {\n            let column = 0\n           \
    \ if columnId < row.count {\n                while columnId < row.count {\n  \
    \                  if row[columnId] == x {\n                        tuples.append((rowId,\
    \ columnId))\n                        break\n                    } else {\n  \
    \                      columnId++\n                    }\n                }\n\
    \            }\n        }\n    }\n    return tuples.sorted(by: { (l, _) in\n \
    \       l.0 < l\n    })", "    var coords = [(0, 0)]\n    coords.reserveCapacity(lst.count)\n\
    \    for row in lst {\n        if row[0] == x {\n            coords.reserveCapacity(coords.count\
    \ + 1)\n            for (i, _) in coords.enumerate() {\n                coords.append((i,\
    \ row.length - 1))\n            }\n            break\n        }\n        coords.reserveCapacity(coords.count\
    \ + 1)\n    }\n    coords.sortInPlace((<)({ (lhs, rhs) -> Bool in\n        return\
    \ (lhs.0 < rhs)\n    }))\n    coords.reverseInPlace()\n    return coords", " \
    \   if lst == nil || len(lst) == 0 {\n        return nil as [(Int, Int)]\n   \
    \ }\n    var lst2 = lst\n    var result = [(0, 0)]\n    for rowIdx in 0 ..< lst2.count\
    \ {\n        var rowArr = lst2[rowIdx]\n        if rowArr[lst2.count - 1] >= x\
    \ {\n            for colIdx in 0 ..< rowArr.count {\n                if colIdx\
    \ < lst2.count - 1 && rowArr[colIdx] >= x {\n                    rowArr = rowArr[1\
    \ ..< colIdx]\n                    if rowArr.count > 0 {\n                   \
    \     result.append((rowIdx, colIdx))\n                    }\n               \
    \ }\n            }\n        }\n    }\n    if result.count > 0 {\n        result\
    \ = result.sorted { (a, b) -> Bool in\n            let aRowIdx = a[0]\n      \
    \      let aColIdx = a[1]\n            let bRowIdx = b[0]\n            let bColIdx\
    \ = b[1]\n            return aColIdx < bColIdx || (aColIdx == bColIdx && aRowIdx\
    \ < bRowIdx)\n        }\n        result = result.sorted { (a, b) -> Bool in\n\
    \            let aRowIdx = a[0]\n            let aColIdx = a[1]\n            let\
    \ bRowIdx = b[0]\n            let bColIdx = b[1]\n            return aRowIdx <\
    \ bRowIdx || (aRowIdx == bRowIdx && aColIdx < bColIdx)\n        }\n        result\
    \ = result.reversed()\n    }\n    return result as [(Int, Int)]", "  if lst ==\
    \ [] || len(lst) <= 0 {\n    return []\n  }\n  var coord = [(0, 0)]\n  for row\
    \ in lst {\n    if row[x] != x {\n      break\n    }\n    var currCol = 0\n  \
    \  var xCurr = 0\n    var yCurr = 1\n    for col in row {\n      if col == x {\n\
    \        currCol = col\n        xCurr = col\n      } else if currCol != col {\n\
    \        break\n      } else {\n        yCurr = col\n      }\n    }\n    coord.append((xCurr,\
    \ yCurr))\n  }\n  return coord.sort().reverse()", "    var result: [(Int, Int)]\
    \ = [(Int, Int)]()\n    var row_len = lst.count\n    for index in 0..<row_len\
    \ {\n        let curr_row = lst[index]\n        if curr_row.contains(x) {\n  \
    \          if row_len > 1 {\n                result.append(curr_row[0] - 1, curr_row.count\
    \ - 1)\n            }\n            return result\n        }\n    }\n    return\
    \ result", "    var arr: [(Int, Int)] = []\n    for i in 0..<lst.count {\n   \
    \     let row: [[Int]] = lst[i]\n        if row.count <= x {\n            arr\
    \ = arr + [row]\n            continue\n        }\n        arr = arr + [[x]..<row.count].reversed()].map\
    \ { row[$0] }\n    }\n    arr.sort(by: { (row1, row2) -> Bool in\n        row1.0\
    \ < row2.0\n    })\n    arr.sort(by: { (row1, row2) -> Bool in\n        if row1.1\
    \ < row2.1 {\n            return true\n        }\n        return false\n    })\n\
    \    return arr", "    if lst.isEmpty {\n        return []\n    }\n    var result\
    \ = [(0, IntMax)]\n    var rows = [Int]()\n    var currentRow = 0\n    for row\
    \ in lst {\n        for column in row {\n            if column == x {\n      \
    \          result[(currentRow, 0)] = (currentRow, column)\n                currentRow\
    \ += 1\n            }\n        }\n        rows.append(currentRow)\n        currentRow\
    \ = 0\n    }\n    let sortedRows = rows.sorted()\n    let sortedRowsDesc = rows.reversed()\n\
    \    for row in sortedRowsDesc {\n        let sortedColumns = rows.map { sortedRows.contains($0)\
    \ ? sortedRows[$0] : Int.max }\n        result.append(sortedColumns.map { result[$0]\
    \ })\n    }\n    return result", "    var coordinates = [(Int, Int)]()\n\n   \
    \ for row in\n        lst\n    {\n        for row in row\n        {\n        \
    \    if row == x {\n                coordinates.append((row, 0))\n           \
    \ }\n        }\n    }\n\n    return coordinates", "    guard lst != nil else {\
    \ return [] }\n    var result = [(Int, Int)]()\n    if lst.count > 0 {\n     \
    \   guard let lst0 = lst[0] else { return [] }\n        for (i, elem) in lst0.enumerated()\
    \ {\n            guard let elem = elem else { continue }\n            if i ==\
    \ x { result = result + [(0, 0)] }\n            if i == x - 1 {\n            \
    \    for j in elem.reversed().enumerated() {\n                    guard let j\
    \ = j._1 else { continue }\n                    result = result + [(i, j)]\n \
    \               }\n            }\n        }\n    }\n    return result", "    return\
    \ lst.map{ row -> (Int, Int) in\n        var tuple = (x, -1)\n        for rowIndex,\
    \ item in enumerate(row) {\n            if item == x {\n                return\
    \ tuple\n            }\n            tuple = (rowIndex, item)\n        }\n    \
    \    return tuple\n    }.sorted(by: { $0.0 < $1.0 }).sorted(by: { $1.0 < $0.0\
    \ }).reversed()", "    if lst.is_empty {\n        return lst as [(Int, Int)]\n\
    \    }\n    let y = 0\n    var coords = [(Int, Int)]()\n    for r in lst {\n \
    \       let l = r.count\n        if l < x {\n            continue\n        }\n\
    \        if l > x {\n            y += 1\n            continue\n        }\n   \
    \     for (col, i) in (0..<x).enumerated() {\n            let row = y - 1\n  \
    \          coords.append((row, col))\n        }\n        y += 1\n    }\n    coords.sort{\
    \ $0.0 < $1.0 }\n    coords.sort{ $1.0 > $0.0 }\n    return coords", "    if lst.isEmpty\
    \ {\n        return []\n    }\n\n    let cols = lst[0].count\n\n    var result\
    \ = [(Int, Int)]()\n    for row in lst {\n        let rowSorted = row.sorted()\n\
    \        let rIndex = rowSorted.firstIndex({ $0 >= x })\n        let rPos = rIndex\
    \ == -1 ? 0 : rIndex\n        let rowTuple = (rowSorted[rPos - 1], rPos)\n\n \
    \       if rPos == rowSorted.count - 1 {\n            result.append((rowTuple.0,\
    \ rowTuple.1))\n        } else {\n            let cIndex = rowSorted[rPos + 1]\n\
    \            let cPos = cIndex == -1 ? 0 : cIndex\n            result.append((rowTuple.0,\
    \ rowSorted[cPos - 1]), rowTuple.1)\n        }\n    }\n\n    result.sortInPlace{\
    \ $0.0 < $1.0 }\n\n    return result as [(Int, Int)]", "    if lst == nil {\n\
    \        return []\n    }\n    var result = [(0, 0)]\n    for row in lst {\n \
    \       if x < row.count {\n            if x == row.count {\n                return\
    \ result\n            }\n            for index in 0 ..< row.count {\n        \
    \        if index == x {\n                    return result\n                }\n\
    \            }\n        }\n        for index in 0 ..< row.count {\n          \
    \  if index == row.count {\n                if index == x {\n                \
    \    return result\n                }\n            }\n        }\n    }\n    return\
    \ result", "    var coords = Array(lst.indices) + [x] // [(Int, Int)]\n    coords.sort()\n\
    \    coords.sortInPlace({ $0 < $1 })\n    return coords.map({\n        (coords[$0]\
    \ + Int($1), coords[$1] - Int($0))\n    })", "    guard !lst.isEmpty else {\n\
    \        return []\n    }\n\n    var result = [(0, lst[0].count)]\n    for i in\
    \ 1..lst.count {\n        for j in 0..result[result.count-1].1 {\n           \
    \ if lst[i][j] == x {\n                result.append( (i, j) )\n            }\n\
    \        }\n    }\n    return result.sorted { $0[0] < $1[0] }", "    if lst.isEmpty\
    \ {\n        return [] // TODO: maybe this case can be improved\n    }\n\n   \
    \ let rowLen = lst.count\n    var coords = [(Int, Int)]()\n    var currentRow\
    \ = [0]\n    var currentRowIndex = -1\n\n    for row in lst {\n        if currentRow\
    \ != row {\n            if currentRowIndex != -1 && currentRowIndex < row.count\
    \ {\n                currentRow.append(row.count)\n                currentRowIndex\
    \ -= 1\n                coords.append((currentRowIndex, currentRow.count - 1))\n\
    \            }\n            currentRow = row\n            currentRowIndex = row.count\n\
    \        }\n    }\n\n    let firstInRow = coords.first!\n    if currentRowIndex\
    \ < row.count {\n        currentRow.append(row.count)\n        currentRowIndex\
    \ -= 1\n        coords.append((currentRowIndex, currentRow.count - 1))\n    }\n\
    \n    let rows = coords.reversed().map { $0 }\n    var coordsInRow = [Int]()\n\
    \    var coordsInRowIndex = -1\n    var currentColumnIndex = 0\n\n    for (row,\
    \ rowLen) in rows {\n        if coordsInRowIndex != -1 && coordsInRowIndex < row.count\
    \ {\n            coordsInRow.append(row.count)\n            coordsInRowIndex +=\
    \ 1\n            currentColumnIndex += 1\n            continue\n        }\n\n\
    \        let columns = row.map { _ in 0 }\n        if currentColumnIndex < columns.count\
    \ {\n            coordsInRow = columns\n            coordsInRowIndex += 1\n  \
    \          currentColumnIndex += 1\n            continue\n        }\n\n      \
    \  if coordsInRowIndex < row.count {\n            coordsInRow.append(row.count)\n\
    \            coordsInRowIndex += 1\n            currentColumnIndex += 1\n    \
    \        continue\n        }\n\n        if currentRowIndex != rowLen {\n     \
    \       if currentRowIndex != rowLen {\n                currentRow.append(rowLen\
    \ - 1)\n                currentRowIndex -= 1\n            }\n\n            currentRow\
    \ = [0]\n            currentRowIndex = 0\n        }\n\n        if coordsInRowIndex\
    \ == rowLen {\n            coordsInRow = columns\n            coordsInRowIndex\
    \ = 0\n            currentColumnIndex = 0\n        }\n\n        if currentColumnIndex\
    \ == columns.count {\n            coordsInRow = columns\n            coordsInRowIndex\
    \ = 0\n            currentColumnIndex = 0\n        }\n    }\n\n    var finalCoords\
    \ = [(Int, Int)]()\n    finalCoords.append(firstInRow)\n\n    for row in coords.reversed().map\
    \ { $0 } {\n        let columns = row.map { _ in 0 }\n        finalCoords.append(columns)\n\
    \    }\n    return finalCoords", "    if lst.isEmpty() {\n        return [] as\
    \ [(Int, Int)]\n    }\n    let sortedRows = lst.sorted()\n    return sortedRows.map({\
    \ row in row.reversed().map{ column in (column, row) == x ? row : nil }})", " \
    \   var result = [(Int, Int)]()\n    for row in lst {\n        let rowSize = row.count\n\
    \        let col = row[rowSize - 1]\n        if col == x {\n            result.append(\
    \ (row, rowSize) )\n        }\n    }\n    let sortResult = result.sorted { $0.0\
    \ < $1.0 }\n    return sortResult.map { $0.1 }", "    let m = lst?.count\n   \
    \ if m < 1 {\n        return []\n    }\n    var result = []\n    for i in 0..<m!\
    \ {\n        let row = lst[i]\n        let len = row!.count\n        var found\
    \ = 0\n        for j in 0..<len {\n            if row![j] == x {\n           \
    \     found = 1\n                break\n            }\n        }\n        if found\
    \ == 0 {\n            result.append( (-1, -1) )\n        } else {\n          \
    \  let k = len\n            for j in 0..<k {\n                let min1 = j\n \
    \               let max1 = j\n                for j in k..<len {\n           \
    \         if row![j] < row![min1] {\n                        min1 = j\n      \
    \              } else if row![j] > row![max1] {\n                        max1\
    \ = j\n                    }\n                }\n                if max1 > j {\n\
    \                    let min2 = j\n                    let max2 = j\n        \
    \            for j in k..<len {\n                        if row![j] >= row![min2]\
    \ {\n                            min2 = j\n                        }\n       \
    \                 else if row![j] < row![max2] {\n                           \
    \ max2 = j\n                        }\n                    }\n               \
    \     result.append( (min1, max1) )\n                }\n            }\n      \
    \  }\n    }\n    return result", "    check(lst.count != 0)\n\n    if lst.count\
    \ == 1 {\n        return []\n    }\n\n    check(x >= 0 && x <= lst[0].count -\
    \ 1)\n    var row = [(x, 0)]\n    var rowCount = [Int]()\n    var lstCount = lst.count\n\
    \n    while lstCount != 0 {\n        let (currentRow, currentRowCount) = row[0]\n\
    \        rowCount.append(currentRowCount)\n\n        if currentRowCount == 0 {\n\
    \            lstCount -= 1\n        } else {\n            let nextRow = lst[currentRow]\n\
    \            if nextRow.count == 0 {\n                lstCount -= 1\n        \
    \    } else {\n                let nextRowLength = nextRow.count\n           \
    \     let lastRow = rowCount[currentRowCount - 1]\n                if lastRow\
    \ == nextRowLength {\n                    lstCount -= 1\n                } else\
    \ {\n                    if x <= lastRow {\n                        row.insert(0,\
    \ (nextRow[lastRow - 1], currentRowCount))\n                    } else {\n   \
    \                     row.insert(0, (nextRow[0], currentRowCount))\n         \
    \           }\n                }\n            }\n        }\n    }\n\n    check(row[0].1\
    \ < row[0].2)\n    check(row[0].2 < row[0].3)\n    check(row[0].3 < row[0].4)\n\
    \    check(row[0].4 < row[0].5)\n    check(row[0].5 < row[0].6)\n    check(row[0].6\
    \ < rowCount.count)\n    check(rowCount.count <= 6)\n    return row", "    var\
    \ result = [(Int, Int)]()\n    sort_rows(lst, &result)\n    return getColumn(lst,\
    \ &result, x)", "    var r: [(Int, Int)] = []\n    for row in lst {\n        for\
    \ _ in 0..<row.count {\n            r.append((row, x))\n        }\n    }\n   \
    \ r.sortInPlace(((_, v) -> Bool {\n        if v < 0 {\n            return true\n\
    \        }\n        return false\n    }))\n    r.sortInPlace(((_, v) -> Bool {\n\
    \        if v > 0 {\n            return true\n        }\n        return false\n\
    \    }))\n    return r", "    if lst.isEmpty() {\n        return []\n    }\n \
    \   if lst.count != 2 {\n        panic(\"not two dimensional list\")\n    }\n\n\
    \    var result = lst\n    result.sort(byRow)\n\n    if x != result[0][0] + 1\
    \ {\n        return []\n    }\n\n    var newTuple = (result[0][0], result[1][0])\n\
    \    var newTuples = [newTuple]\n    for x in result[1] {\n        if x == x {\n\
    \            newTuple.1 = x\n            newTuples.append(newTuple)\n        \
    \    newTuple = (result[0][0], x)\n            newTuples = [newTuple]\n      \
    \  } else {\n            newTuple.1 = x\n            newTuples.append(newTuple)\n\
    \        }\n    }\n\n    return newTuples", "    var res = lst\n    if !lst.isEmpty\
    \ {\n        if lst.count > 1 {\n            if lst.last!.count <= x {\n     \
    \           res = lst.last!.slice(x: x, y: lst.last!.count - 1)\n            \
    \    res.reverse()\n            } else {\n                res = lst.last!.slice(x:\
    \ x, y: x)\n            }\n        }\n    }\n    return res as [(Int, Int)]",
  "    return lst\n        .map{ r in\n            return r.map{ x, _ in\n       \
    \         (x, x - 1)\n            }\n        }\n        .sorted(by: { a, b in\n\
    \            let rA = a.1\n            let rB = b.1\n            return rA! >\
    \ rB!\n        })\n        .sorted(by: { b, a in\n            let rB = b.1\n \
    \           let rA = a.1\n            return rA! > rB!\n        })", "    if lst.isEmpty\
    \ {\n        return [] // return empty array when array is empty\n    }\n\n  \
    \  // sort the list by rows in ascending order\n    let sortedRows = lst.sorted(by:\
    \ { (row1, row2) in\n        // sort by columns in descending order\n        return\
    \ row2.count > row1.count\n    })\n\n    // go through each row from top to bottom\n\
    \    // and keep only the (x, y) coordinates that\n    // are present in every\
    \ row\n    var coordinates = [(0, 0) ]\n    for row in sortedRows {\n        for\
    \ row in row.reversed() {\n            if row.contains(x) {\n                coordinates.append((row.first!,\
    \ row.last!))\n            }\n        }\n    }\n\n    return coordinates", " \
    \   if lst == nil || lst[0] == nil {\n        return []\n    }\n    \n    // sort\
    \ in ascending order\n    var tuples = [(Int, Int)]()\n    for (i, item) in lst.enumerate()\
    \ {\n        tuples = tuples + get_row(item, x)\n    }\n    \n    // sort in descending\
    \ order\n    tuples = tuples.sorted { $0.0 < $1.0 }\n    \n    return tuples",
  "    var result = [(Int, Int)]()\n    if lst.isEmpty {\n        return result as\
    \ [(Int, Int)]\n    }\n    if lst[0].isEmpty {\n        return result as [(Int,\
    \ Int)]\n    }\n    for row in lst {\n        for (i, x) in row.enumerated() {\n\
    \            if x == x {\n                result.append((i, x))\n            \
    \    lst.removeAtIndex(i)\n                row.insert(i, x)\n            }\n \
    \       }\n    }\n    return result.reverse()", "    var res: [(Int, Int)] = [(Int,\
    \ Int)]()\n    var res2 = [[(Int, Int)]]()\n    for i in lst {\n        for j\
    \ in i {\n            if j == x {\n                res2 = append(res2, [(i,j)],\
    \ sorting: -1)\n            } else {\n                res2 = append(res2, [(i,j)],\
    \ sorting: 1)\n            }\n        }\n    }\n    res = []\n    for j in res2\
    \ {\n        res.append(j[0])\n        res.append(j[1])\n    }\n    res.sort(sorting:\
    \ -1, by: ({ $0.0 < $1.0 }))\n    res.sort(sorting: -1, by: ({ $0.1 < $1.0 }))\n\
    \    return res", "    var index = 0\n    var row = 0\n    var result = [ (Int,\
    \ Int) ]()\n    for row in lst {\n        var col = 0\n        for (index, value)\
    \ in row.enumerated() {\n            if value == x {\n                result.append(\
    \ (row, index) )\n                break\n            }\n            col++\n  \
    \      }\n    }\n    return result", "    var row = 0\n    var column = 0\n  \
    \  while row < lst.count {\n        if lst[row][column] == x {\n            return\
    \ [(row, column)]\n        }\n        row += 1\n        if row < lst.count {\n\
    \            column += 1\n            if column >= lst[row].count {\n        \
    \        row -= 1\n                column = 0\n            }\n        }\n    }\n\
    \    return []", "    if lst.isEmpty() {\n        return []\n    }\n    \n   \
    \ var row = Int()\n    var col = 0\n    var rowOrder = Int()\n    var colOrder\
    \ = Int()\n    \n    for rowOrder < lst.count {\n        colOrder = lst.count\n\
    \        while col < colOrder {\n            if lst[rowOrder][col] > x {\n   \
    \             rowOrder = rowOrder + 1\n                col = colOrder - 1\n  \
    \              continue\n            }\n            if lst[rowOrder][col] == x\
    \ {\n                var tuple: ((Int, Int)) = (row, col)\n                row\
    \ = row + 1\n                col = col + 1\n                return [tuple]\n \
    \           }\n            col = col + 1\n        }\n    }\n    \n    return []",
  "    if lst == [] || lst[0] == [] {\n        return [] as [(Int, Int)]\n    }\n\n\
    \    let maxRow = lst[0].count\n    let maxCol = lst[0].first!.count\n\n    let\
    \ rowsArr = lst.map({ $0.map({ $0 }) })\n    let rowsSorted = rowsArr.sorted(by:\
    \ { $0.count > $1.count })\n    let colsArr = rowsSorted[0].map({ $0.map({ $0\
    \ }) })\n    let colsSorted = colsArr.sorted(by: { $0.count > $1.count })\n\n\
    \    var tuples = rowsSorted.flatMap { sortedRows -> [(Int, Int)] in\n       \
    \ let rows = sortedRows.map{ $0.map({ $0 }) }\n        let cols = colsSorted.map{\
    \ $0.map({ $0 }) }\n        for row in rows {\n            for col in cols {\n\
    \                if col.contains(x) {\n                    return (row, col)\n\
    \                }\n            }\n        }\n        return []\n    }\n    return\
    \ tuples.sorted(by: { $0.0 < $1.0 })", "    var result = [(Int, Int)]()\n    for\
    \ (_, row) in lst.enumerated() {\n        let column = -1\n        for (index,\
    \ _) in row.enumerated() {\n            if index < x {\n                if column\
    \ < 0 {\n                    column = index\n                } else {\n      \
    \              break\n                }\n            } else {\n              \
    \  break\n            }\n        }\n        if column >= 0 {\n            result.append((column,\
    \ row - 1))\n        }\n    }\n    result.sort{$0.1 < $1.1}\n    return result\
    \ as [(Int, Int)]", "    var ret = [0]\n    for i in lst {\n        for j in i\
    \ {\n            if j == x {\n                ret += [(0, j)]\n            }\n\
    \        }\n    }\n    return ret", "    if lst.isEmpty() {\n        return ([(0,\
    \ x), (0, 0)] as [(Int, Int)])\n    }\n    var retVal = [(0, 0)] as [(Int, Int)]\n\
    \    var row = lst[0]\n    for i in 0 ..< row.count {\n        if x&1 == 0 {\n\
    \            retVal.append( (row.count - 1 - i, row.count) ) // Descending order.\n\
    \        } else {\n            retVal.append( (i, row.count) ) // Ascending order.\n\
    \        }\n    }\n    retVal.sort()\n    retVal.reverse()\n    return retVal",
  "    var row = 0\n    var col = 0\n    var lst2 = [[Int]]()\n    while row < lst.count\
    \ {\n        if lst[row][col] == x {\n            if lst2.count == 0 { lst2 =\
    \ []\n            } else {\n                for i in 0 ..< lst2.count {\n    \
    \                if lst2[row] < lst2[i] {\n                        lst2.append(lst2[row])\n\
    \                        lst2.append(lst2[i])\n                    } else {\n\
    \                        lst2.append(lst2[i])\n                        lst2.append(lst2[row])\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ lst[row][col] >= x { col++\n        } else {\n            if lst[row][col] <\
    \ x {\n                col++\n                row++\n            }\n        }\n\
    \    }\n    if lst2.count == 0 { return [] as [(Int, Int)]\n    } else {\n   \
    \     return lst2 as [(Int, Int)]\n    }", "    var xRow = [0]\n    var xCol =\
    \ [0]\n    var yRow = [0]\n    var yCol = [0]\n\n    for row in lst {\n      \
    \  guard row.count > 0 else {\n            continue\n        }\n        var xCount\
    \ = 0\n        var yCount = 0\n        for row in row {\n            guard xCount\
    \ <= xRow[0] else {\n                continue\n            }\n            guard\
    \ yCount <= yRow[0] else {\n                continue\n            }\n        \
    \    if row == x {\n                return [(yCount, xCount)]\n            }\n\
    \            if row > x {\n                break\n            }\n            guard\
    \ xCount == xRow[0] else {\n                continue\n            }\n        \
    \    guard yCount == yRow[0] else {\n                continue\n            }\n\
    \            guard row>x else {\n                continue\n            }\n   \
    \         xCount++\n            yCount++\n        }\n        xRow[0] = xCount\n\
    \        xCol[0] = row.count\n        yRow[0] = yCount\n        yCol[0] = row.count\n\
    \    }\n    return []", "    if lst.isEmpty() {\n        return lst\n    }\n \
    \   if lst.count < 2 {\n        return []\n    }\n    \n    let lst = lst.sorted(by:\
    \ {$0[0] > $1[0]})\n    if lst.count == 1 {\n        return [(0, 0)]\n    }\n\
    \    \n    let y = lst[0]\n    let maxRow = lst[lst.count-1][0]\n    \n    var\
    \ rows = Array<(Int, Int)>(repeating: (0, 0), (lst.count-1))\n    for r in range(lst.count-1)\
    \ {\n        let columns = [Int](repeating: 0, count: y[0][r])\n        for c\
    \ in range(y[0][r]) {\n            columns[c] = r\n        }\n        rows[r]\
    \ = (maxRow, columns.sorted(by: {$0 > $1}).last!)\n    }\n    \n    return rows",
  "    var ret = [[Int]]()\n    if lst == [] {\n        return ret\n    }\n    if\
    \ lst.count <= 1 {\n        return lst\n    }\n    var row = lst[0]\n    for _i\
    \ in 1...lst.count {\n        if row[_i] == x {\n            var tmp = ret\n \
    \           ret = append(ret, row)\n            ret.append(tmp)\n            return\
    \ ret\n        }\n    }\n    return ret", "    if lst.isEmpty {\n        return\
    \ [] // nothing to do\n    }\n\n    var rows = lst.map { $0.count }\n    rows.sort\
    \ in reverse()\n    rows = rows.map { $0.sorted { $0 > $1 } }\n    var columns:\
    \ [(Int, Int)] = []\n    var current: Int = 0\n    for row in rows {\n       \
    \ current = current + 1\n        columns.append((row, current))\n    }\n\n   \
    \ var result = columns.map { i -> (Int, Int) in\n        let (row, col) = i\n\
    \        return (row, col - x)\n    }\n\n    return result", "    var result:\
    \ [[(Int, Int)]] = []\n    var i = 0\n    for row in lst {\n        var l = 0\n\
    \        var r = row.count - 1\n        while l < r {\n            if row[l] <\
    \ x {\n                result.append((i, l + 1))\n                l++\n      \
    \      } else {\n                result.append((i, r))\n                r--\n\
    \            }\n        }\n        i += 1\n    }\n    result.sortInPlace()\n \
    \   return result.map({ $0.reversed() })", "    \n    if lst == nil || len(lst)\
    \ == 0 || x == 0 || x <= 0 || x > len(lst[0]) {\n        return []\n    }\n  \
    \  \n    let rows = lst\n    var coords = [(Int, Int)]()\n    coords.sortInPlace{\
    \ $0.0 < $1.0 }\n    coords.sortInPlace{ $0.1 < $1.1 }\n    coords.reverse()\n\
    \    var y = 0\n    var yMax = y\n    for i in 0..<coords[y].0 {\n        y =\
    \ coords.firstIndex(where: { $0.1 < $1.0 })!\n        if y > y && y > y {\n  \
    \          coords.remove(at: y)\n        }\n        coords.remove(at: y)\n   \
    \ }\n    coords.reverse()\n    var xMax = x\n    for j in 0..<coords[y].1 {\n\
    \        xMax = coords.firstIndex(where: { $0.1 > $1.0 })!\n        if xMax <\
    \ xMax && xMax < xMax {\n            coords.remove(at: xMax)\n        }\n    \
    \    coords.remove(at: xMax)\n    }\n    var coords2 = [(Int, Int)]()\n    for\
    \ i in 0..<rows.count {\n        var y = 0\n        var x = 0\n        for j in\
    \ 0..<rows[i].count {\n            x = coords.firstIndex(where: { $0.1 > $1.0\
    \ })!\n            if x > x && x > x {\n                coords.remove(at: x)\n\
    \            }\n            coords.remove(at: x)\n        }\n        var coord\
    \ = (i, j)\n        for coord in coords {\n            coords2.append(coord)\n\
    \        }\n    }\n    return coords2", "    var rows = lst\n    var row = [(0,\
    \ 0)]\n    for _ in 0..<x {\n        if let (first, second) = row.removeLast()\
    \ {\n            row.insert(first+1, second)\n            rows.append(row)\n \
    \       }\n    }\n    rows = rows.sorted(by: { $0[0] as! Int < $1[0] as! Int })\n\
    \    for row in rows.sorted(by: { $0[1] as! Int > $1[1] as! Int }) {\n       \
    \ return row\n    }\n    return []", "    \n    var result = [(0, 1)]\n    for\
    \ i in lst {\n        if i == x {\n            result.append(tuple2(i, 0))\n \
    \       }\n    }\n    for i in\n        result\n    {\n        result.remove(at:\
    \ 0)\n        if i.0 != i.1 {\n            result.append(tuple2(i, i.1))\n   \
    \     }\n    }\n    result.sort { ($0.0 < $1.0) }\n    return result as [[(Int,\
    \ Int)]]", "    if lst.isEmpty {\n        return []\n    }\n\n    let rows = lst.count\n\
    \    if rows == 0 {\n        return []\n    }\n\n    if rows == 1 {\n        return\
    \ [(lst.first?.indexOf(x) != nil) ? lst.first?.indexOf(x) : 0, lst.first?.indexOf(x)]\n\
    \    }\n\n    func compare(i: Int, j: Int) -> Bool {\n        return j > i ? true\
    \ : lst[j].sorted().contains(x) || lst[i].sorted().contains(x)\n    }\n\n    return\
    \ lst.enumerated().filter { itr in\n        let (i, j) = itr.next()\n        return\
    \ j > i\n    }.sorted(by: { (i, j) -> Bool in\n        return compare(i, j)\n\
    \    })", "    if lst.isEmpty {\n        return [] as [(Int, Int)]\n    }\n  \
    \  var row = lst[0] as [Int]\n    if lst[0] is [Int] {\n        if row == nil\
    \ {\n            return [] as [(Int, Int)]\n        }\n        row = row.last\
    \ as [Int]\n        if row.isEmpty {\n            return [] as [(Int, Int)]\n\
    \        }\n    }\n    if x > row.first {\n        row = row.dropFirst()\n   \
    \ }\n    var result = [(0, row.first)]\n    for idx in row.indices {\n       \
    \ let (col, _) = get_row(lst: lst, x: idx * -1)\n        result.append(col)\n\
    \    }\n    return result.sorted { $0.0 < $1.0 }", "    return lst.flatMap { row\
    \ in\n        row.enumerated().sorted().reversed()\n    }.filter{ $0.1 <= x }",
  "    \n    return lst.sort { $0[0] < $1[0] }\n        .map { ($0[0], $0.dropFirst())\
    \ }\n        .sorted { $0[0] > $0[1] }\n        .map { ($0[0] + x, $0[1] - x)\
    \ }", "    if lst.isEmpty() {\n        return []\n    }\n    var rows = lst.map\
    \ { $0.count }\n    rows.sort()\n    for row in rows.reverse() {\n        if row\
    \ == 0 {\n            continue\n        }\n        break\n    }\n    \n    var\
    \ cols = lst[row].count\n    var maxCols = cols\n    for row in lst.dropLast()\
    \ {\n        if row == 0 {\n            continue\n        }\n        maxCols =\
    \ max(maxCols, row.count)\n    }\n    \n    var ret = [(0, 0)]\n    for row in\
    \ rows {\n        if row == 0 {\n            continue\n        }\n        var\
    \ col = 0\n        while col < row {\n            col += 1\n            \n   \
    \         if col >= maxCols {\n                col %= row\n                row--\n\
    \                break\n            }\n            \n            if lst[row][col]\
    \ == x {\n                ret.insert(0, (row, col))\n                row -= 1\n\
    \                break\n            }\n        }\n    }\n    \n    if ret.count\
    \ == 0 {\n        return ret\n    }\n    ret.sort()\n    \n    return ret", " \
    \   var result = [[Int]]()\n    var row = 0\n    var col = 0\n    for row in 0\
    \ ..< lst.count {\n        var column = 0\n        for (column in 0 ..< lst[row].count)\
    \ {\n            if (lst[row][column] == x) {\n                result.append(\
    \ (row, column) )\n            }\n        }\n    }\n    result.sort(by: {\n  \
    \      $0[0] < $1[0] || (($0[0] == $1[0]) && ($0[1] < $1[1]))\n    })\n    result.sort(by:\
    \ {\n        $0[1] < $1[1] || (($0[1] == $1[1]) && ($0[0] < $1[0]))\n    })\n\
    \    return result", "    if lst.isEmpty {\n        return []\n    }\n\n    var\
    \ coords = [(Int, Int)]()\n\n    // sort coords by row in ascending order\n  \
    \  for idx in 0..<lst.count {\n        if idx < lst.count {\n            if let\
    \ row = lst[idx].sorted(by: { $0.0 < $1.0 }) {\n                coords.append(\
    \ (0, idx) )\n            }\n        }\n    }\n\n    coords.sort(by: { $0.0 <\
    \ $1.0 })\n\n    // sort coordinates in descending order of the column index\n\
    \    for col in coords.reverse() {\n        coords.sort(by: { $0.0 > $1.0 })\n\
    \    }\n\n    return coords\n        .filter { $0.1 == x }\n        .map { coord:\
    \ $0.0 }", "    if lst.isEmpty() {\n        return [] as [(Int, Int)]\n    }\n\
    \    var coords = [(0, 0) as (Int, Int)]\n    for row in lst {\n        if row.count\
    \ < x {\n            coords.append((0, 0))\n            continue\n        }\n\
    \        let (minRow, maxRow) = row.minIndex()\n        if maxRow - minRow > x\
    \ {\n            coords.append((0, x))\n            continue\n        }\n    \
    \    var minCol = (0, 0)\n        for (col, row) in row.enumerated() {\n     \
    \       if col == x {\n                coords.append((minRow, minCol))\n     \
    \           continue\n            }\n            if col > x {\n              \
    \  break\n            }\n            minCol = (col, col)\n        }\n    }\n \
    \   coords.sortInPlace()\n    coords.sortInPlace(|a, b| b[1].0 < a[1].0)\n   \
    \ return coords", "    guard lst.count > 0 else { return [] }\n    guard let l\
    \ = lst.first else { return [] }\n    let first = l[0]\n    let first = first[x..<x.advance(by:\
    \ 1)]\n    let second: [Int] = l[1]\n    return first.enumerated().map { i, j\
    \ in\n        return ((i + 1, j + 1), (second[i], second[j]))\n    }.sorted {\
    \ $0.0 < $1.0 }", "    if lst == [] || lst.count == 0 {\n        return [] as\
    \ [(Int, Int)]\n    }\n    if lst.count == 1 {\n        return [(lst.first, x)]\n\
    \    }\n    var ret = [(Int, Int)]()\n    var row = 0\n    var col = 0\n    var\
    \ cur = lst[0]\n    for _ in lst[1..<lst.count] {\n        row += 1\n        for\
    \ col in 1...col {\n            if cur.first == x {\n                ret.append((row,\
    \ col))\n            }\n            cur = cur.next\n        }\n        col = 0\n\
    \    }\n    return ret", "    // Check input\n    if lst.count < 1 {\n       \
    \ return lst\n    }\n    if lst.count > 1 {\n        print(\"Error: multiple rows,\
    \ not allowed\")\n        return lst\n    }\n    if lst.count <= 1 {\n       \
    \ return lst\n    }\n\n    // Sorting row by columns\n    var lstSort: [[Int]]\
    \ = []\n    for _0 in range(0, lst.count) {\n        var lstColumn = [Int]()\n\
    \        for _1 in range(0, lst[0].count) {\n            lstColumn.append(lst[_0][_1])\n\
    \        }\n        lstSort.append(lstColumn)\n    }\n    lstSort.sort()\n   \
    \ lstSort.reverse()\n\n    // Getting x and column coordinates\n    var xCoord\
    \ = -1\n    for _0 in range(0, lstSort.count) {\n        if lstSort[_0][0] ==\
    \ x {\n            xCoord = _0\n            break\n        }\n    }\n    if xCoord\
    \ == -1 {\n        print(\"Error: x is not in lst\")\n        return lst\n   \
    \ }\n    var yCoord = -1\n    for _0 in range(0, lstSort[xCoord].count) {\n  \
    \      if lstSort[xCoord][_0] == x {\n            yCoord = _0\n            break\n\
    \        }\n    }\n    if yCoord == -1 {\n        print(\"Error: y is not in lst\"\
    )\n        return lst\n    }\n\n    return [(yCoord + xCoord, x, yCoord, xCoord,\
    \ yCoord)]", "    if lst.isEmpty {\n        return []\n    }\n\n    var result:\
    \ [(Int, Int)] = []\n\n    for (_, row) in lst {\n        let sorted = row.sorted()\n\
    \        var currentRow = sorted.reversed()\n\n        if x < sorted[0] {\n  \
    \          return result\n        }\n\n        if x == sorted[0] {\n         \
    \   result.append((0, 0))\n        }\n\n        var currentCol = 0\n        var\
    \ rowIdx = 0\n\n        while currentCol < sorted[0].count && rowIdx < sorted[0].count\
    \ - 1 {\n            if sorted[rowIdx][currentCol] < x {\n                currentCol\
    \ += 1\n                continue\n            }\n\n            if sorted[rowIdx][currentCol]\
    \ == x {\n                result.append((rowIdx, currentCol))\n              \
    \  currentCol += 1\n            } else {\n                currentCol = 0\n   \
    \             rowIdx += 1\n            }\n        }\n    }\n\n    return result.sorted()",
  "    return lst.sorted() { l1, l2 in\n        if let l1 = l1, l2 = l2 {\n      \
    \      return l1.index(l1.startIndex, offsetBy: x) > l2.index(l2.startIndex, offsetBy:\
    \ x)\n        }\n        return false\n    }", "    var ret = Array([[Int]]())\n\
    \    for _, b in lst {\n        if b.contains(x) {\n            ret.append([0,\
    \ 0])\n            break\n        }\n        if x == 0 {\n            ret.append([0,\
    \ 0])\n            continue\n        }\n        for (i, j) in b.enumerated() {\n\
    \            if j == 0 {\n                ret.append([i, j])\n               \
    \ break\n            }\n            if i == b.length - 1 {\n                ret.append([i,\
    \ j])\n            }\n            if x%b[j] == 0 {\n                ret.append([i,\
    \ j])\n            }\n        }\n    }\n    return ret.reversed()", "    if lst.count\
    \ == 0 {\n        return []\n    }\n    var rows = Array(lst.enumerated())\n \
    \   rows = rows.sorted(by: {\n        var lhs = $0.offset\n        var rhs = $1.offset\n\
    \        if lhs < rhs {\n            return true\n        } else if lhs > rhs\
    \ {\n            return false\n        } else {\n            return $0.element\
    \ > $1.element\n        }\n    })\n    var out = [((Int, Int), 0)]\n    for (r,\
    \ _) in rows {\n        out.append((r[0], r[1] - x)) // y\n    }\n    return out",
  "    var rows = [[(Int, Int)]]()\n    if lst == nil || len(lst) == 0 {\n       \
    \ return rows\n    }\n    if lst[0].count < x {\n        return rows\n    }\n\
    \    var idx = 0\n    var y = 0\n    while idx < lst[0].count {\n        let maxIdx\
    \ = idx\n        while idx < lst[0].count && lst[0][idx] >= x {\n            idx\
    \ += 1\n        }\n        if idx >= lst[0].count {\n            break\n     \
    \   }\n        let row = (maxIdx, idx)\n        idx -= 1\n        if y > 0 {\n\
    \            rows.append((row, y))\n        }\n        y = lst[0][idx]\n    }\n\
    \    if y == 0 {\n        return rows\n    }\n    lst = lst.dropFirst()\n    rows.sortInPlaceBy\
    \ { a, b in\n        var aR = a.0\n        var aC = a\n        var bR = b.0\n\
    \        var bC = b.1\n        if aC < bC {\n            return true\n       \
    \ } else if aC > bC {\n            return false\n        }\n        if aR < bR\
    \ {\n            return true\n        } else if aR > bR {\n            return\
    \ false\n        }\n        return false\n    }\n    return rows", "    if lst\
    \ == nil {\n        return nil\n    }\n    var tuples = [(Int, Int)]()\n    for\
    \ rowNum in 0 ..< lst.count {\n        for row in 0 ..< lst[rowNum].count {\n\
    \            if lst[rowNum][row] == x {\n                tuples.append((rowNum,\
    \ row))\n            }\n        }\n    }\n    tuples.sort{ lhs, rhs in\n     \
    \   return lhs.0 > rhs.0\n    }\n    return tuples", "    var result = [[(0, 0)]]\n\
    \    for row in lst {\n        var rowResult = [(0, 0)]\n        for idx in row\
    \ {\n            if idx == x {\n                rowResult = rowResult + (idx,\
    \ idx)\n            }\n        }\n        result = result + rowResult\n    }\n\
    \    result.sortInPlaceInDescendingOrder(by: {$0.0})\n    return result as [(Int,\
    \ Int)]", "    var coords = []\n\n    for i in 0 ..< lst.count {\n        coords.append((i,\
    \ lst[i].count))\n    }\n\n    coords.sortInPlaceBy { $0 }\n    coords.sortInPlaceBy\
    \ { $1 }\n\n    var result = [(Int, Int)]()\n\n    for i in 0 ..< coords.count\
    \ {\n        if coords.first!.0 < i {\n            result.append((coords.first!.0,\
    \ i))\n        }\n\n        if coords.last!.0 > i {\n            result.append((i,\
    \ coords.last!.0 - i))\n        }\n    }\n\n    return result", "    // The idea\
    \ here is that each row is sorted by their number of columns.\n    // The algorithm\
    \ works as follows:\n    // * Traverse the given matrix from left to right, left\
    \ to right, top to bottom\n    // * Compare number of columns with the given x,\
    \ find the row,\n    //   and insert coordinates of each found row into result\
    \ array.\n    \n    // Sort the given row by the number of columns\n    let sorted_rows:\
    \ [[Int]] = [[]] as [[Int]]\n    var result = [(Int, Int)]()\n    for row in lst\
    \ {\n        // Sort each row by the number of columns\n        let row1 = row.sorted()\n\
    \        // Find the row that has given number of columns\n        var row2 =\
    \ sorted_rows.first(where: { $0.count == row1.count })\n        // Insert coordinates\
    \ of each found row into result array\n        while row2 == nil && row != nil\
    \ {\n            sorted_rows.append(row!)\n            row2 = sorted_rows.first(where:\
    \ { $0.count == row1.count })\n        }\n        // If row is found\n       \
    \ if row2 != nil {\n            // Insert coordinates of each found row into result\
    \ array\n            for (col, col1) in row2 {\n                // Insert coordinates\
    \ into result array\n                result.append((x, col))\n               \
    \ // Insert coordinates of next row into result array\n                result.append((x,\
    \ col1))\n            }\n        }\n    }\n    \n    // Sort result array by first\
    \ element in each tuple\n    result = result.sorted(by: { $0.0 < $1.0 })\n   \
    \ \n    return result", "    var row = Int()\n    var col = Int()\n    var tuple\
    \ = Int()\n    var count = 0\n\n    for r in lst {\n        for c in r {\n   \
    \         count += 1\n\n            if c == x {\n                row = count\n\
    \            }\n\n            if c > x {\n                break\n            }\n\
    \n            tuple = col\n            col += Int((c - x) / Int((c - x) % Int((c\
    \ - x) / Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) %\
    \ Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c\
    \ - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) %\
    \ Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c\
    \ - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) %\
    \ Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c\
    \ - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) %\
    \ Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c\
    \ - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) %\
    \ Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c\
    \ - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) %\
    \ Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c\
    \ - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) %\
    \ Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c\
    \ - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) %\
    \ Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int((c - x) % Int",
  "    guard lst != nil else { return [] }\n    \n    let n = lst!.count\n    \n \
    \   var rows = [(0, n)]\n    for r in 0..<n {\n        var cols = [(0, -1)]\n\
    \        for c in 0..<rows[0][1] {\n            for _ in 0..<x {\n           \
    \     if cols[0][0] != c {\n                    cols.prepend((c, 0))\n       \
    \         } else {\n                    if cols.last != (1, 0) {\n           \
    \             cols.prepend((c, cols.last!.1))\n                    } else {\n\
    \                        break\n                    }\n                }\n   \
    \         }\n        }\n        if cols.last == (1, 0) { continue }\n        rows.append((r\
    \ + 1, cols.reversed().map{$0.1}))\n    }\n    \n    rows.sort{ ($0.1 < $1.1)\
    \ || ($0.1 == $1.1 && $0.1 < $1.1) -> Bool in\n        if $0.1 < $1.1 {\n    \
    \        return true\n        } else {\n            return false\n        }\n\
    \    }\n    \n    return rows", "    if lst.isEmpty {\n        return []\n   \
    \ }\n    var result = [(0, -1)]\n    for row in lst {\n        for row in row\
    \ {\n            if x == row {\n                result.append((row, (row.count)))\n\
    \                break\n            }\n            if x > row {\n            \
    \    break\n            }\n        }\n    }\n    result.sort(by: { $0.0 < $1.0\
    \ })\n    return result.sorted(by: { $0.0 > $1.0 })", "    guard let lst = lst\
    \ else {\n        return []\n    }\n\n    var coordinates = [(Int, Int)]()\n \
    \   var row = [Int]()\n    var columns = [Int]()\n\n    for row in lst {\n   \
    \     guard row.count > 0 else {\n            continue\n        }\n\n        columns.append(row.count)\n\
    \n        if x < row.first {\n            coordinates.append((row.first, 0))\n\
    \        }\n\n        if row == lst {\n            coordinates.append((row.first,\
    \ row.count))\n        }\n    }\n\n    columns.reverse()\n    for row in lst {\n\
    \        guard row.count > 0 else {\n            continue\n        }\n\n     \
    \   if row == lst {\n            coordinates.append((row.first, row.count))\n\
    \        }\n    }\n\n    coordinates.sort{$0.0 < $1.0}\n\n    var results = [((Int,\
    \ Int))] * coordinates.count\n    for ((row, column), i) in zip(coordinates, 0..<coordinates.count)\
    \ {\n        results[column][i] = (row, column)\n    }\n\n    return results",
  "    if lst.count == 0 {\n        return []\n    }\n    var row = 0\n    var column\
    \ = 0\n    var res = make([], (lst.count) as (Int, Int), -1)\n    for _ in lst\
    \ {\n        if row == lst.count - 1 {\n            column++\n            row\
    \ = 0\n        }\n        res[row] = ((row, column))\n        if res[row] == (x,\
    \ 0) {\n            break\n        }\n        row++\n    }\n    return res", " \
    \   if lst.isEmpty {\n        return [] // early exit\n    }\n    var col = 0\n\
    \    var row = 0\n    var coords = []\n    coords.reserveCapacity(lst.count)\n\
    \    for row in lst {\n        coords.reserveCapacity(row.count) // reserve space\
    \ for coordinates\n        for col in row {\n            if col == x {\n     \
    \           coords.append((row, col))\n                break\n            }\n\
    \        }\n    }\n    coords.sort(by: {\n        a, b in\n        let c = a[0]\n\
    \        let d = b[0]\n        return c > d\n    })\n    coords.sort(by: {\n \
    \       (a, b) in\n        let c = a[1]\n        let d = b[1]\n        return\
    \ c > d\n    })\n    return coords", "    var result = [(0, 0), (len(lst) - 1,\
    \ len(lst)-1)]\n    for i in 0 ..< len(lst)-1 {\n        for j in 0 ..< len(lst)-1\
    \ {\n            if lst[i][j] == x {\n                result = (i, j)\n      \
    \          break\n            }\n        }\n    }\n    return result", "    if\
    \ lst.isEmpty {\n        return []\n    }\n    if x > lst[0][0].count {\n    \
    \    return []\n    }\n\n    var ans = [(0, 0)]\n    for row in lst {\n      \
    \  for j in 0 ..< row.count {\n            if row[j] == x {\n                ans.append((j,\
    \ j))\n            }\n        }\n    }\n\n    ans.sortInPlaceBy{ lhs, rhs in\n\
    \        if lhs > rhs {\n            return true\n        }\n        if lhs <\
    \ rhs {\n            return false\n        }\n    }\n\n    ans.sortInPlaceBy{\
    \ lhs, rhs in\n        if lhs[0] > rhs[0] {\n            return true\n       \
    \ }\n        if lhs[0] < rhs[0] {\n            return false\n        }\n     \
    \   return true\n    }\n\n    return ans", "    if lst.isEmpty() {\n        return\
    \ []\n    }\n    let cols = lst[0].count\n    let rows = lst.count\n    var res\
    \ = RowRows(rows: rows, cols: cols)\n    for row in lst {\n        for (i, v)\
    \ in row.enumerated() {\n            if v == x {\n                res.insert(Row(i,\
    \ 0))\n                break\n            }\n        }\n    }\n    res", "   \
    \ let rowCount = lst.count\n    var rowCoords = (0..<rowCount).map { i in\n  \
    \      let colCount = lst[i].count\n        return (0..<colCount).map { j in\n\
    \            (i * colCount + j)\n        }\n    }\n\n    rowCoords = rowCoords.sorted(by:\
    \ { row1, row2 -> Bool in\n        return row1 > row2\n    })\n\n    // reverse\
    \ sort the columns in descending order\n    var reversedCoords = [Int]()\n   \
    \ for (i, coord) in rowCoords.enumerated() {\n        reversedCoords.append(coord.reversed())\n\
    \    }\n\n    // find the row that contains `x` index\n    var rowIndex = reversedCoords.firstIndex(of:\
    \ x)\n\n    if rowIndex == -1 {\n        return [] // not found\n    }\n\n   \
    \ // return all column coordinates that contains the `x` index\n    let result\
    \ = rowCoords[rowIndex].reversed()\n\n    if rowIndex == 0 {\n        result =\
    \ result.sorted(by: { column1, column2 -> Bool in\n            return column1\
    \ > column2\n        })\n    }\n\n    return result", "    var coords = [(0, 0)]\n\
    \    var rows = [(x: x, y: 0)]\n    for arr in lst {\n        for row in arr {\n\
    \            coords.append((row, col: col(arr, row)))\n            rows.append((x:\
    \ row, y: col(arr, row)))\n        }\n    }\n    coords.sort { $0.row < $1.row\
    \ }\n    rows.sort { $0.x > $1.x }\n    return coords", "    if lst.isEmpty {\
    \ return [] as [(Int, Int)]}\n\n    var row = [Int]()\n    for rowIndex in 0 ..<\
    \ lst.count {\n        for colIndex in 0 ..< row[index(rowIndex)].count {\n  \
    \          if row[index(rowIndex)][colIndex] == x {\n                let colIndex\
    \ = colIndex.predecessor()\n                row.insert(colIndex, row[index(rowIndex)])\n\
    \                row.insert(colIndex.successor(), 0)\n                return [\
    \ (Int, Int)](row: row, col: colIndex.successor())\n            }\n        }\n\
    \    }\n    return [] as [(Int, Int)]", "    if lst == nil {\n        return nil\n\
    \    }\n    if lst.isEmpty {\n        return []\n    }\n    var row = lst[0]\n\
    \    var result: [(Int, Int)] = []\n    for _row in lst {\n        if _row.isEmpty\
    \ {\n            continue\n        }\n        if row == nil {\n            row\
    \ = Array(repeating: nil, count: 0)\n        }\n        if _row[x] == nil {\n\
    \            return nil\n        }\n        if row[x] == nil {\n            let\
    \ coord = Coord(x: _row[x].0, y: _row[x].1)\n            result.append(coord)\n\
    \        } else {\n            if row[x].1 > _row[x].1 {\n                return\
    \ nil\n            }\n        }\n    }\n    result.sort { $0.0 < $1.0 }\n    result.sort\
    \ { $0.1 > $1.0 }\n    return result", "    let rows = lst.count\n    var coordinates\
    \ = [(Int, Int)]()\n    var rowCoordinate = [(Int, Int)]()\n    var rowOrder:\
    \ [[Int]]\n    if rows > 0 {\n        rowOrder = lst[0].sorted()\n    } else {\n\
    \        rowOrder = Array(repeating: (Int, Int), count: 0)\n    }\n    for row\
    \ in 0..<rows {\n        rowCoordinate = rowOrder[row]\n        let columns =\
    \ rows[row].count\n        for column in 0..<columns {\n            coordinates.append((row,\
    \ column))\n        }\n    }\n    rowOrder = rowOrder.sorted()\n    if x > rowOrder.count\
    \ {\n        return []\n    }\n    return coordinates[x..<x+x]", "    if lst.isEmpty()\
    \ { return [] }\n    if lst.count == 0 || lst.first!.isEmpty() { return [] }\n\
    \    var rows = [Int]()\n    var result = [(0, 0)]\n    for elem in lst {\n  \
    \      for elem2 in elem {\n            if elem2 == x {\n                result.append(\
    \ (elem2.row, elem2.column) )\n            }\n        }\n    }\n    rows = rows\n\
    \    rows = rows.sorted()\n    rows = rows.reversed()\n    rows = rows.map { (index,\
    \ element) -> Int in\n        return (element, index)\n    }\n    \n    result\
    \ = [(0, 0)] + result\n    \n    result = result.sorted()\n    result = result.map\
    \ { (element, index) -> [(Int, Int)] in\n        return (index + 1, element)\n\
    \    }\n    return result as [[(Int, Int)]]", "    // TODO: implement this\n \
    \   return []", "    if lst == [] as [[Int]] {\n        return [] as! [(Int, Int)]\n\
    \    }\n\n    var result = [(Int, Int)]()\n    if lst == nil || len(lst) == 0\
    \ {\n        return result\n    }\n\n    let rowNum = len(lst)\n    let colNum\
    \ = lst[0]!.count\n\n    // sort by rows\n    for i in 0..<rowNum {\n        var\
    \ row = [Int]()\n        for j in 0..<colNum {\n            let index = rowNum\
    \ * j + i\n            if lst[index] != nil {\n                row.append(lst[index]![j])\n\
    \            }\n        }\n        row.sortInPlace()\n        result.append((i,\
    \ row.max()))\n    }\n\n    // sort by columns\n    for i in 0..<rowNum {\n  \
    \      var col = [Int]()\n        for j in 0..<colNum {\n            col.append(i)\n\
    \        }\n        col.sortInPlace()\n        result.append((col[colNum - 1],\
    \ i)) // swap last col\n        for j in 0..<colNum {\n            row.insert(j,\
    \ col[j])\n        }\n    }\n\n    return result", "    func ind(i: Int) -> Int\
    \ {\n        return i + (x * i)\n    }\n    \n    let rows = lst.count\n    let\
    \ cols = lst[0].count\n    \n    var ans = [(0, 0)]\n    for i in 0..<rows {\n\
    \        var row = [(0, 0)]\n        for (j, val) in lst[i].enumerated() {\n \
    \           row[ind(j)] = (ind(j), val)\n        }\n        \n        ans = ans\
    \ + row\n    }\n    \n    var tmp = [(0, 0)]\n    for i in 0..<rows {\n      \
    \  tmp = tmp.sorted(by: { a, b in b[0] as! Int > a[0] as! Int })\n        ans[i]\
    \ = tmp[0]\n    }\n    \n    ans = ans.sorted(by: { a, b in b[1]! > a[1]! })\n\
    \    ans = ans.map { $0.0 }\n    return ans", "    var row: [(Int, Int)]\n   \
    \ for row in lst {\n        var r = 0\n        var c = 0\n        for d in row\
    \ {\n            if d == x {\n                return [(row[0], c), (x, row[1])]\n\
    \            }\n            r += d.0\n            c += d.1\n        }\n    }\n\
    \    return []", "    if lst.isEmpty() {\n        return empty\n    }\n    var\
    \ row = 0\n    var col = 0\n    var coordinates = [(row, col)]\n    var rows =\
    \ [[(Int, Int)]]()\n    for i in\n    0 ..< lst.count {\n        var column =\
    \ 0\n        for j in\n        0 ..< lst[i].count {\n            if lst[i][j]\
    \ == x {\n                column++\n            }\n        }\n        if column\
    \ == 0 {\n            return empty\n        }\n        coordinates.append((row,\
    \ column))\n        if row == 0 {\n            rows = []\n            rows.append(coordinates)\n\
    \            rows.sort(by: { $0.1 < $1.1 })\n        } else {\n            rows.append((coordinates))\n\
    \            rows.sort(by: { $0.1 < $1.1 })\n            rows.sort(by: { $0.2\
    \ < $1.2 })\n        }\n        row = 0\n        col = 0\n    }\n    return rows[0]",
  "    if lst == [] as [[Int]] {\n        return [] as [(Int, Int)]\n    }\n    var\
    \ row = [Int]()\n    let numCols = lst[0].count\n    var maxRow = 0\n    for row\
    \ in lst {\n        if row.count == numCols {\n            maxRow = row.count\n\
    \        } else {\n            break\n        }\n    }\n    if maxRow == 0 {\n\
    \        return [] as [(Int, Int)]\n    }\n\n    let rows = lst.sorted()\n   \
    \ var result = rows.map { [Int]() }\n    var cols = [Int]()\n    var col = 0\n\
    \    for row in rows {\n        let newCol = row[col]\n        if newCol == x\
    \ {\n            col += 1\n            continue\n        }\n        var coord\
    \ = (maxRow, col)\n        while result.contains(coord) {\n            coord +=\
    \ 1\n        }\n        result[coord] = (coord)\n        col += 1\n        cols.append(col)\n\
    \    }\n    return result.map { coord -> (Int, Int) in\n        var coord = (maxRow,\
    \ cols[coord.0] - 1)\n        while result.contains(coord) {\n            coord\
    \ -= 1\n        }\n        return (coord.1, coord.0)\n    }", "    if lst.isEmpty()\
    \ { return [] as [(Int, Int)]; }\n    var results = [Int]()\n    let m = lst.count\n\
    \    var row = [Int](repeating: 0, count: m)\n    var col = [0]\n    for idx in\
    \ 0..<m {\n        if let item = lst.first(where: { $0[idx] == x }) {\n      \
    \      let row = idx / col[0]\n            let col = idx % col[0]\n          \
    \  results.append((row, col))\n            for idx in 0..<item.count {\n     \
    \           row[col] = item[idx]\n                col[0] = col[0] + 1\n      \
    \      }\n            row = [Int](repeating: 0, count: m)\n        }\n    }\n\
    \    return results", "    if lst == [] {\n        return [] as [(Int, Int)]\n\
    \    }\n    if lst.count == 0 {\n        return [] as [(Int, Int)]\n    }\n  \
    \  if x == lst[0][0].0 {\n        var result = [0] as [(Int, Int)]\n        for\
    \ col in lst[0].1...lst[0].0 {\n            result.append((col, x))\n        }\n\
    \        return result\n    }\n    if x == lst[0][0].1 {\n        var result =\
    \ [0] as [(Int, Int)]\n        for row in lst[0].0...lst[lst[0].0].count-1 {\n\
    \            result.append((row, x))\n        }\n        return result\n    }\n\
    \    if x < lst[0][0].1 {\n        var result = get_row(lst: lst, x: lst[0][0].1)\
    \ as [(Int, Int)]\n        var lastCol = lst[0].1\n        for col in lst[0].0...lst[lst[0].0].count-1\
    \ {\n            if col > lastCol {\n                break\n            }\n  \
    \          result.append((col, x))\n            lastCol = col\n        }\n   \
    \     return result\n    }\n    if lst[0].0.0 < x {\n        var result = get_row(lst:\
    \ lst, x: lst[0].0.1) as [(Int, Int)]\n        var lastRow = lst[0].0\n      \
    \  for row in lst[0].1...lst[lst[0].0].count-1 {\n            if row > lastRow\
    \ {\n                break\n            }\n            result.append((row, x))\n\
    \            lastRow = row\n        }\n        return result\n    }\n    if x\
    \ == lst[0].0.1 {\n        var result = [0] as [(Int, Int)]\n        for row in\
    \ lst[0].1...lst[lst[0].0].count-1 {\n            if row < lst[0].1 {\n      \
    \          break\n            }\n            result.append((row, x))\n       \
    \ }\n        return result\n    }\n    if lst[0].0.1 == x {\n        var result\
    \ = [0] as [(Int, Int)]\n        for row in lst[0].0...lst[lst[0].0].count-1 {\n\
    \            if row < lst[0].1 {\n                break\n            }\n     \
    \       result.append((row, x))\n        }\n        return result\n    }\n   \
    \ if x == lst[0].1 {\n        var result = [0] as [(Int, Int)]\n        for row\
    \ in lst[0].0...lst[lst[0].0].count-1 {\n            if row < lst[0].1 {\n   \
    \             break\n            }\n            result.append((row, x))\n    \
    \    }\n        return result\n    }\n    if x == lst[lst[0].0].count-1 {\n  \
    \      var result = [0] as [(Int, Int)]\n        for row in lst[0].0...lst[lst[0].0].count-1\
    \ {\n            if row < lst[0].1 {\n                break\n            }\n \
    \           result.append((row, x))\n        }\n        return result\n    }\n\
    \    if x < lst[0].1 {\n        var result = get_row(lst: lst, x: lst[0].1) as\
    \ [(Int, Int)]\n        var lastRow = lst[0].1\n        for row in lst[0].0...",
  "    if lst.isEmpty() {\n        return []\n    }\n    var rows = lst[0]\n    for\
    \ row in rows {\n        row.sortInPlace()\n        row.sortInPlaceInReverse()\n\
    \    }\n    return rows.prefix(1).map({ r in\n        r.prefix(2).map { cols in\n\
    \            r.zip(cols).map({ r in\n                (r[0], r[1] + x)\n      \
    \      })\n        }\n    })", "    if lst.isEmpty() {\n        return nil\n \
    \   }\n    var result = [[(0, 0)]]\n    var rows = [0]\n    var cols = [0]\n \
    \   for row in lst {\n        if rows.isEmpty {\n            cols = [0]\n    \
    \    } else {\n            for (i, v) in row.enumerated() {\n                cols[i].increment()\n\
    \                if cols[i].value == x {\n                    result.append([(rows[i].index,\
    \ cols[i].value)])\n                }\n                if cols[i].value == x {\n\
    \                    cols[i].decrement()\n                }\n            }\n \
    \       }\n        rows.append(row.count)\n    }\n    if rows.contains(0) {\n\
    \        return result\n    } else {\n        return nil\n    }", "    if lst\
    \ == nil {\n        return make([][(Int, Int)], 0)\n    }\n    var result = make([][(Int,\
    \ Int)], 0)\n    if lst.isEmpty {\n        return result\n    }\n    if x != 0\
    \ {\n        for (col, row) in\n            enumerate(lst.map({ $0.map { $0 +\
    \ x } })) {\n            if row != 0 {\n                for row in reverse(sortDescend(row))\
    \ {\n                    let rowTuple = row + (col, row)\n                   \
    \ let rowTupleIndex = result.count\n                    result.insert(rowTuple,\
    \ rowTupleIndex)\n                }\n            }\n        }\n    }\n    return\
    \ result", "    if lst.isEmpty() {\n        return lst as [(Int, Int)]\n    }\n\
    \    let (rows, cols) = lst.transpose().unzip()\n    return rows.enumerated().flatMap\
    \ { (idx, _) in\n        return cols.enumerated().flatMap { (idx2, _) in\n   \
    \         return (idx, idx2)\n        }\n    }\n        .filter { $0.0 == x }\n\
    \        .sorted(by: { $0.0 < $1.0 })\n        .sorted { $0.0 < $1.0 }\n     \
    \   .map { $0.0 }", "    if lst == nil {\n        return []\n    }\n    if lst[0][x]\
    \ != x {\n        return []\n    }\n    \n    var coordinates = [(0, x)]\n   \
    \ \n    for ix in 1...lst[0][x] {\n        if lst[ix][x] == x {\n            coordinates.append((ix,\
    \ x))\n        }\n    }\n    \n    return coordinates", "    if lst == nil {\n\
    \        return []\n    }\n\n    func getRow(_ x: Int, _ lst: [[Int]], _ row:\
    \ [(Int, Int)]) -> [(Int, Int)] {\n        if row == nil {\n            return\
    \ []\n        }\n        guard let _ = lst as? [[Int]] else {\n            return\
    \ []\n        }\n        var out: [(Int, Int)]\n        for row in lst {\n   \
    \         if row[0] == x {\n                out = row\n                break\n\
    \            }\n        }\n        return out\n    }\n\n    var row = [(x, x)]\n\
    \    return getRow(x, lst, row)", "    let lenRow = lst.count\n    if lenRow ==\
    \ 0 {\n        return [] as [(Int, Int)]\n    }\n    let lenCol = lst[0].count\n\
    \    if lenCol == 0 {\n        return [] as [(Int, Int)]\n    }\n    var result\
    \ = Array(repeating: (Int, Int), count: lenRow)\n    for (idx, row) in lst.enumerated()\
    \ {\n        let rowLen = row.count\n        if rowLen > lenCol {\n          \
    \  continue\n        }\n        for (_, col) in row.enumerated() {\n         \
    \   if col == x {\n                result[idx] = (idx, col)\n                break\n\
    \            }\n        }\n    }\n    result.sort { $0.0 < $1.0 }\n    return\
    \ result", "    let rows = lst[0]\n    \n    if rows.count == 0 { return [] }\n\
    \    \n    if rows.count < 1 { return [] }\n    \n    var result = [(Int, Int)]()\n\
    \    \n    for row in rows {\n        if row.contains(x) { result = result + [(row.count,\
    \ row.count)] }\n    }\n    \n    result.sort{$0.0 < 1.0}\n    \n    result.sort{$1.0\
    \ == $1.0 ? $0.0 < $1.0 : (-1.0 * $1.0 > $0.0)}\n    \n    return result", " \
    \   var res = lst[0]\n    for row in lst.rest(dropFirst: true) {\n        if row[x]\
    \ == x {\n            res = row\n            break\n        }\n    }\n    return\
    \ res.isEmpty ? res : res.map { $1 }", "    if lst.count > 0 {\n        // find\
    \ row\n        let row_idx = lst.index(where: { lst in\n            return lst[0]\
    \ == x\n        })\n\n        // sort coordinates\n        let (row_idx, row_len)\
    \ = get_row_idx_and_len(lst, row_idx)\n        let (col_max, col_len) = row_len\n\
    \        var coords: [(0, Int)]\n        var idx: Int = 0\n        var coord:\
    \ (Int, Int) = (0, 0)\n\n        for i in 0 ..< row_len {\n            coords\
    \ = lst[row_idx][i] // get coordinates of a single row\n            for j in 0\
    \ ..< col_len {\n                if coords.0 < col_max {\n                   \
    \ coord = (i, j)\n                    break\n                } else {\n      \
    \              coord = coords[0]\n                    idx += 1\n             \
    \   }\n            }\n            if coords.0 > col_max { // new coordinate\n\
    \                coords = (idx, j)\n            }\n        }\n        return coords.sorted(by:\
    \ {\n            $0.1 < $1.1\n        }).sorted(by: {\n            ($0.2, $1.2)\
    \ > ($1.2, $0.2)\n        })\n    } else {\n        return [] as [(Int, Int)]\n\
    \    }", "    guard lst != [] else {\n        return []\n    }\n    var result:\
    \ [(Int, Int)] = [(Int, Int)]()\n    for i in 0 ..< lst.count {\n        var row:\
    \ [(Int, Int)] = [(Int, Int)]()\n        for row in lst {\n            for j in\
    \ 0 ..< row.count {\n                if row[j] == x {\n                    row.insert(j,\
    \ 0)\n                    row.insert(j, 0)\n                    break\n      \
    \          }\n            }\n        }\n        if result.count == lst.count {\n\
    \            result.append(row)\n        } else {\n            if row.count ==\
    \ lst.count {\n                for index in 0 ..< row.count {\n              \
    \      if row[index] > 0 {\n                        result.insert((lst.count,\
    \ index), (row[index], 0))\n                        break\n                  \
    \  }\n                }\n            } else {\n                result.append(row)\n\
    \            }\n        }\n    }\n    return result", "    if lst.isEmpty() {\n\
    \        return ()\n    }\n    var rows = [((Int, Int), Int)]()\n    for row in\
    \ lst {\n        let len = row.count\n        if len > 1 {\n            let row_min\
    \ = (row[0] as (Int, Int), row[1] as Int)\n            var new_row = ((Int, Int),\
    \ Int)()\n            for col in 0..<len {\n                if col == x {\n  \
    \                  new_row = (row_min, col + 1)\n                }\n         \
    \       else {\n                    new_row.0 = (row_min.0, col)\n           \
    \         new_row.1 = (row_min.1, col + 1)\n                    rows.append(new_row)\n\
    \                }\n            }\n        }\n        else {\n            let\
    \ row_min = (row[0] as (Int, Int), row[0] as Int)\n            var new_row = ((Int,\
    \ Int), Int)()\n            for col in 0..<len {\n                if col == x\
    \ {\n                    new_row = (row_min, col + 1)\n                }\n   \
    \             else {\n                    new_row.0 = (row_min.0, col)\n     \
    \               new_row.1 = (row_min.1, col + 1)\n                    rows.append(new_row)\n\
    \                }\n            }\n        }\n    }\n    rows.sort { $0.0 < $1.0\
    \ }\n    rows.sort { $0.1 < $1.1 }\n    return rows", "    if lst.isEmpty {\n\
    \        return []\n    }\n    var ret = [(Int, Int)]()\n    if let v = lst[0][x]\
    \ {\n        for (row, v) in lst {\n            if v == v {\n                ret.insert(Int((row).roundedToInt(),\
    \ 0), at: 0)\n            }\n        }\n    }\n    return ret.sorted(by: { lhs,\
    \ rhs in\n        (lhs).roundedToInt() == (rhs).roundedToInt()\n    }).sorted(by:\
    \ { lhs, rhs in\n        (lhs[1]).roundedToInt() == (rhs[1]).roundedToInt()\n\
    \    }).map({ $0.0 })", "    // Write your code here.\n    var rows = [[(Int,\
    \ Int)]]()\n    for i in 0..<lst.count {\n        var row = lst[i]\n        for\
    \ j in 0..<row.count {\n            var coord = (i, j)\n            if coord !=\
    \ (x, 0) {\n                row.append(coord)\n            }\n        }\n    \
    \    rows.append(row)\n    }\n    \n    func sort_row(row: [(Int, Int)])->[(Int,\
    \ Int)]{\n        var coords = row.sorted{$0.1 < $1.1} // sort in ascending order\
    \ on rows.\n        coords.sort{$0.0 < $1.0} // sort in descending order on columns.\n\
    \        return coords\n    }\n    \n    rows.sort{$0.0 < $1.0}\n    var coords\
    \ = sort_row(rows[0])\n    for row in rows {\n        coords = coords.sorted{$0.1\
    \ < $1.1} // sort in ascending order on rows.\n        coords = coords.sorted{$0.0\
    \ < $1.0} // sort in descending order on columns.\n        rows.append(coords)\n\
    \    }\n    return rows", "    let rows = lst\n    var coordinates = [(Int, Int)]()\n\
    \    var row: [Int] = []\n    var row_index: Int = 0\n\n    for i in 0..<rows.count\
    \ {\n        row = rows[row_index]\n        row_index += 1\n\n        if row ==\
    \ x {\n            coordinates.append((row_index, row.count))\n        }\n   \
    \ }\n\n    return coordinates", "    if lst == nil {\n        return lst\n   \
    \ }\n    if lst[0] != nil {\n        return get_row(lst[0].sorted(), x).sorted()\n\
    \    }\n    return lst[0].sorted().sorted() // sorted by rows, then columns in\
    \ descending order", "    if lst.isEmpty {\n        return [[(0, 0)]]\n    }\n\
    \    let lst = lst\n    guard let rowLen = lst[0].count else { return [] }\n \
    \   let yLen = lst[0].count\n    var lst1 = lst\n    if lst1[0].count == rowLen\
    \ {\n        lst1 = lst1.map { $0.map { $0 - x } }\n    }\n    guard lst1.count\
    \ == lst[0].count else { return [] }\n    let minX = lst1[0].min() ?? 0\n    let\
    \ maxX = lst1[0].max() ?? rowLen - 1\n    var result = lst1.map {\n        (x,\
    \ y) -> (x, y) }\n        .sort { $0.0 < $1.0 }\n        .map {\n            (minX,\
    \ $0.0..<$0.1) }\n    return result.map {\n        (_) -> (Int, Int) }", "   \
    \ func helper(row: [[Int]], rowIndex: Int, xIndex: Int) -> [(Int, Int)] {\n  \
    \      if rowIndex >= row.count {\n            return []\n        }\n        var\
    \ ans = [(0, 0) as (Int, Int)]\n        for x in row[xIndex] {\n            ans.append((rowIndex\
    \ + 1, xIndex + 1))\n        }\n        return ans\n    }\n\n    if lst.isEmpty()\
    \ {\n        return nil\n    }\n    if lst.count > 1 {\n        func firstRowIndx(_\
    \ row: [Int], _ rowIndex: Int) -> Int {\n            return rowIndex\n       \
    \ }\n        func firstColIndx(_ row: [Int], _ xIndex: Int) -> Int {\n       \
    \     return xIndex\n        }\n        let row = lst[0]\n        let sortedByRow\
    \ = lst.sorted(by: { (row1, row2) in\n            return row1[0] < row2[0]\n \
    \       })\n        return sortedByRow.map { row in\n            let sortedByCol\
    \ = row.sorted(by: { (col1, col2) in\n                return col1 > col2\n   \
    \         })\n            return sortedByCol.map(firstRowIndx).map(firstColIndx)\n\
    \        }.flatMap { row in\n            return helper(row, rowIndex: 0, xIndex:\
    \ 0)\n        }\n    }\n\n    return helper(lst[0], rowIndex: 0, xIndex: 0)",
  "    if lst.isEmpty() {\n        return []\n    }\n    var coords = [(Int, Int)]()\n\
    \    for row in lst {\n        let size = row.count\n        if size == 0 {\n\
    \            continue\n        }\n        let lastElement = row.last ?? 0\n  \
    \      if lastElement == x {\n            for i in 0..<size {\n              \
    \  coords.append((i, lastElement))\n            }\n        }\n    }\n    coords.sortInPlace()\n\
    \    coords.reverse()\n    return coords", "    if !lst.count {\n        return\
    \ lst\n    }\n    \n    // Iterate over rows of input matrix\n    var rows = [(Int,\
    \ Int)]()\n    for rowIdx, row in\n        enumerate(lst) {\n        // Sort the\
    \ row by rowIdx in ascending order\n        let sortedIdx = lst[rowIdx].sorted\
    \ { $0.0 < $1.0 }\n        \n        // Sort the column indices by sortedIdx in\
    \ descending order\n        let sortedIdx = sortedIdx.sorted { $0.0 < $1.0 }\n\
    \        \n        // For each column index, get the row index\n        for row\
    \ in sortedIdx {\n            let (xPos, yPos) = rows[row]\n            if xPos\
    \ == x {\n                rows.append((xPos, yPos))\n                break\n \
    \           }\n        }\n    }\n    \n    // return the coordinates\n    return\
    \ rows", "    var coors = Array(zip(lst, Array(lst.indices)))\n    coors = coors.sorted{\
    \ $0.0 < $1.0 }\n    coors = coors.sorted{ $0.0 < $1.0 }.map{ $0.0 }\n    if coors.isEmpty()\
    \ { return [] }\n    var rows = Array(lst.indices)\n    var cols = [Int]()\n \
    \   for coord in coors {\n        if rows.contains(coord) { cols.append(coord)\
    \ }\n        else { rows.append(coord) }\n    }\n    return Array(zip(rows, cols))",
  "    if lst.isEmpty() {\n        return []\n    }\n\n    if let head = lst[0] {\n\
    \        let rows = lst.reduce(into: [Int]()) { $0 + $1.count }\n        let cols\
    \ = head.count\n        var coords = [(0, 0)]\n        for row in 0 ..< rows {\n\
    \            for col in 0 ..< cols {\n                let coord = (row + 0, col\
    \ + 1)\n                if coord == coord && coord < head.count {\n          \
    \          coords.append(coord)\n                }\n            }\n        }\n\
    \n        coords.sortInPlace(by: { $0[0] <= $1[0] })\n        coords.sortInPlace(by:\
    \ { $0[1] > $1[1] })\n\n        return coords.map({ coord -> (Int, Int) in\n \
    \           return coord\n        })\n    } else {\n        return []\n    }",
  "    var res = [(0, 0)]\n    var minRow = -1, maxRow = -1, minCol = -1, maxCol =\
    \ -1\n\n    for i in 0..<lst.count {\n        var row = lst[i]\n        var rowLen\
    \ = row.count\n\n        if rowLen <= 1 {\n            continue\n        }\n\n\
    \        var minRow = i, maxRow = i, minCol = -1, maxCol = -1\n\n        for j\
    \ in 0..<rowLen {\n            var cell = row[j]\n            minCol = j\n   \
    \         if cell == x {\n                if minRow == -1 || j < minRow {\n  \
    \                  minRow = i\n                }\n                if maxCol ==\
    \ -1 || maxCol > j {\n                    maxCol = j\n                }\n    \
    \        }\n        }\n        if minRow > maxRow {\n            res.append((0,\
    \ 0))\n        } else if minCol > maxCol {\n            res.append(((minRow, minCol)))\n\
    \        } else {\n            res.append(((minRow, minCol)))\n        }\n   \
    \ }\n    return res", "    var row = [Int]()\n    var coordinates = [Int]()\n\
    \    var i = 0\n    while i < lst.count {\n        row.clear()\n        coordinates.clear()\n\
    \        let rowLength = lst[i].count\n        for (j, innerArray) in lst[i].enumerated()\
    \ {\n            if j != 0 {\n                row.insert(innerArray[j], at: 0)\n\
    \            } else {\n                coordinates.append(j)\n            }\n\
    \        }\n        if coordinates.contains(x) {\n            return row.map {\
    \ (_, j) -> Int in\n                return j\n            }\n        } else {\n\
    \            return row.map { (_, j) -> Int in\n                return j\n   \
    \         }\n        }\n        i += 1\n    }\n    return row.map { (_, j) ->\
    \ Int in\n        return j\n    }", "    if lst.isEmpty {\n        return []\n\
    \    }\n    let m = lst.count\n    var result = [(Int, Int)]()\n    if x > m {\n\
    \        return nil\n    }\n    for i in 0..<x {\n        let tmp = lst[i]\n \
    \       let row = i\n        var coord = tmp[row]\n        coord.reverse()\n \
    \       for (j, xj) in coord.enumerated() {\n            let yj = m - 1 - j\n\
    \            result.append( (row, yj) )\n        }\n    }\n    result.sort()\n\
    \    result.sort{ $0.1 < $1.1 }\n    return result", "    guard lst.count > 0,\
    \ x > 0, lst[0].count > 0 else {\n        return []\n    }\n    let row_len =\
    \ lst[0].count\n    \n    // Get all coordinates of row with index x\n    var\
    \ coord_list = [][(Int, Int)]()\n    for row in lst {\n        let row_coord =\
    \ get_coord_from_row(row, x)\n        coord_list.append(row_coord)\n    }\n  \
    \  \n    // Sort coordinates of row by column\n    coord_list.sort(by: {\n   \
    \     ($0.row, $0.col) < ($1.row, $1.col)\n    })\n    \n    // Sort coordinates\
    \ by row\n    coord_list.sort(by: {\n        ($0.row, $0.col) < ($1.row, $1.col)\n\
    \    })\n    \n    // Return coordinates of row with index x\n    return coord_list.map\
    \ {\n        $0.row\n    }", "    if lst.isEmpty() {\n        return []\n    }\n\
    \    if lst.count == 0 {\n        return [(0, 0)]\n    }\n    var rows: [((Int,\
    \ Int), Int)] = [((0, 0): 0, 1): 0, ((0, 0): 1, 1): 0, ((0, 0): 2, 1): 0, ((0,\
    \ 0): 3, 1): 0, ((0, 0): 4, 1): 0, ((0, 0): 5, 1): 0)]\n    for (i, row) in lst.enumerated()\
    \ {\n        for j in 0..<row.count {\n            let (row, col) = row\n    \
    \        if j == x {\n                return [(row, col)]\n            }\n   \
    \         if row > j {\n                continue\n            }\n            if\
    \ col > j {\n                continue\n            }\n            if row > col\
    \ {\n                continue\n            }\n            if row != (j - 1) {\n\
    \                if rows[(j, row)] != (j - 1, row - 1) {\n                   \
    \ rows[(j, row)] = (j - 1, row - 1)\n                }\n            }\n      \
    \  }\n    }\n    return []", "    var rows = lst.count\n    var cols = 0\n   \
    \ var coords: [((Int, Int), Int)] = [((0, 0), 0)]\n    coords.sort { (lhs, rhs)\
    \ in\n        let (row1_idx, row1_index) = lhs\n        let (row2_idx, row2_index)\
    \ = rhs\n        if row1_index > row2_index {\n            return true\n     \
    \   } else if row1_index < row2_index {\n            return false\n        } else\
    \ {\n            return row2_idx > row1_idx\n        }\n    }\n    let (row_idx,\
    \ row_idx) = coords.first\n    while row_idx != rows {\n        if coords.contains(((row_idx,\
    \ 0), x)) {\n            break\n        }\n        row_idx++\n        cols++\n\
    \    }\n    var result = [(Int, Int)]()\n    var idx = 0\n    while idx < rows\
    \ {\n        var coord = (row_idx, 0)\n        if let (coord, _) = coords.remove(at:\
    \ row_idx) {\n            result.append(coord)\n        }\n        idx++\n   \
    \ }\n    return result", "    if lst.isEmpty {\n        return [] as [(Int, Int)]\n\
    \    }\n    var rows = [Int]()\n    var coords = [Int]()\n    for row in lst {\n\
    \        rows.append(row.count)\n        coords.append(row.startIndex)\n    }\n\
    \    coords.sort()\n    coords.reverse()\n    coords.sort()\n    var result =\
    \ [(Int, Int)]()\n    var lastX = x\n    for (_, idx) in coords {\n        let\
    \ column = rows[idx]\n        if column > lastX {\n            lastX = column\n\
    \            result.append((lastX, idx))\n        }\n    }\n    return result",
  "    var row: [[Int]]\n    for row in lst {\n        for row in row {\n        \
    \    if row == x {\n                return row\n            }\n        }\n   \
    \ }\n    return []", "    let lstRows = lst.map { row in row.map { Int64(row).intValue()\
    \ } }\n    var xFound = False\n    var yFound = False\n    var xIdx = 0\n    var\
    \ yIdx = 0\n    var xRows = Array(0..<lst.count).sorted()\n    var yCols = Array(0..<lst[0].count).sorted()\n\
    \    var yRows = Array(0..<lst.count).sorted()\n    while xFound == False && yFound\
    \ == False {\n        if xRows.contains(xIdx) {\n            if lstRows.contains(xIdx)\
    \ {\n                yRows = Array(0..<lst.count).sorted()\n                yCols\
    \ = Array(0..<lst[0].count).sorted()\n                yFound = True\n        \
    \    }\n            xRows = xRows.filter { (idx) -> Bool in\n                let\
    \ row = lstRows[idx]\n                return row[xIdx] != x\n            }\n \
    \           if xRows.count > 0 {\n                xFound = True\n            }\
    \ else {\n                xIdx++\n            }\n        } else {\n          \
    \  if yCols.contains(yIdx) {\n                xRows = Array(0..<lst.count).sorted()\n\
    \                xCols = Array(0..<lst[0].count).sorted()\n                xFound\
    \ = True\n            }\n            yCols = yCols.filter { (idx) -> Bool in\n\
    \                let row = lstRows[idx]\n                return row[yIdx] != x\n\
    \            }\n            if yCols.count > 0 {\n                yFound = True\n\
    \            } else {\n                yIdx++\n            }\n        }\n    }\n\
    \    if xFound == False && yFound == False {\n        return [] as [(Int, Int)]\n\
    \    }\n    return lstRows.map { (rowIdx, row) -> [(Int, Int)] in\n        let\
    \ row = lstRows[rowIdx]\n        return (xIdx, row[yIdx])\n    }", "    if lst.isEmpty\
    \ {\n        return [] as [(Int, Int)]\n    }\n    \n    var row = [Int]()\n \
    \   row.sortInPlace() // sort the row initially in ascending order\n    row.reverse()\
    \ // sort the row in descending order\n    \n    var result = [(Int, Int)]()\n\
    \    \n    for (index, rowData) in lst.enumerated() {\n        if rowData.contains(x)\
    \ {\n            var column = 0\n            for (column, data) in row.enumerated()\
    \ {\n                if data < x {\n                    break\n              \
    \  }\n            }\n            result.append((index, column))\n        }\n \
    \   }\n    \n    return result", "    if lst.isEmpty() {\n        return []\n\
    \    }\n    var tuples = zip(range(lst[0].count, to: lst[0].count), lst[0].dropFirst())\n\
    \    for (_, row) in tuples.enumerate() {\n        tuples = tuples.enumerated().map({\n\
    \            (x, y) in (x + row[0], y + row[1])\n        }).sorted()\n    }\n\
    \    return tuples.reversed().map({(x, y) in (x, y)})", "    var coors: [[(Int,\
    \ Int)]] = []\n    for row in lst {\n        var coors_tmp: [(Int, Int)] = [(Int,\
    \ Int)]()\n        for col in row {\n            if col == x {\n             \
    \   coors_tmp.append((row, col))\n            }\n        }\n        coors.append(coors_tmp)\n\
    \    }\n    coors = coors.sorted(by: { $0.0 < $1.0 })\n    coors = coors.sorted(by:\
    \ { $0.0 > $1.0 })\n    return coors", "    if lst.isEmpty() {\n        return\
    \ []\n    }\n    // Sort coordinates initially by rows in ascending order.\n \
    \   // This guarantees that we will find x when searching row by row.\n    var\
    \ lst = lst.sorted(by: { rowA, rowB in\n        return rowA[0] < rowB[0]\n   \
    \ })\n    var result = [(0, 0)]\n    for (_, row) in lst {\n        var tmpX =\
    \ x - row[0]\n        if tmpX < 0 {\n            // This row doesn't contain x.\
    \ Search next row.\n            row = lst.sorted(by: { rowA, rowB in\n       \
    \         return rowA[0] < rowB[0]\n            })[0]\n            tmpX = x -\
    \ row[0]\n        }\n        // This row contains x.\n        row = row.sorted(by:\
    \ { columnA, columnB in\n            return columnB < tmpX\n        })\n     \
    \   result = result + [(*row, tmpX)]\n    }\n    return result", "    return sorted(lst).sorted(by:\
    \ {$0[$1] > $1}, ascending: false).sorted(by: {$0[$1] > $1}, ascending: true)\n\
    \        .filter { $0[$0] == x }\n        .map { $0.enumerated() }\n        .sorted(by:\
    \ {$0.0 < $1.0})\n        .map { $0.map {$1.1, $1.1} }.sorted()", "    if lst.isEmpty\
    \ {\n        return lst\n    }\n\n    var result = lst\n    var xs: [(Int, Int)]\n\
    \    var ys: [(Int, Int)]\n\n    for i in 0..<lst.count {\n        let row = result[i]\n\
    \        xs = row.map { (x, i) in (x, i) }\n        ys = xs.reversed()\n\n   \
    \     if xs.contains(where: { x == x }) {\n            xs.remove(at: xs.firstIndex(of:\
    \ { $0 == x })!)\n        }\n\n        if xs.contains(where: { x == -x }) {\n\
    \            xs.remove(at: xs.firstIndex(of: { $0 == -x })!)\n        }\n\n  \
    \      if ys.contains(where: { $0.0 < y }) {\n            ys.remove(at: ys.firstIndex(of:\
    \ { $0.0 < y })!)\n        }\n\n        if ys.contains(where: { $0.0 < -y }) {\n\
    \            ys.remove(at: ys.firstIndex(of: { $0.0 < -y })!)\n        }\n   \
    \ }\n\n    if let row = result.first {\n        xs = row.map { (x, i) in (x, i)\
    \ }\n        ys = xs.reversed()\n\n        if xs.contains(where: { x == x }) {\n\
    \            xs.remove(at: xs.firstIndex(of: { $0 == x })!)\n        }\n\n   \
    \     if xs.contains(where: { x == -x }) {\n            xs.remove(at: xs.firstIndex(of:\
    \ { $0 == -x })!)\n        }\n\n        if ys.contains(where: { $0.0 < y }) {\n\
    \            ys.remove(at: ys.firstIndex(of: { $0.0 < y })!)\n        }\n\n  \
    \      if ys.contains(where: { $0.0 < -y }) {\n            ys.remove(at: ys.firstIndex(of:\
    \ { $0.0 < -y })!)\n        }\n    }\n\n    if ys.contains(where: { $0.0 < y })\
    \ {\n        ys.remove(at: ys.firstIndex(of: { $0.0 < y })!)\n    }\n\n    if\
    \ ys.contains(where: { $0.0 < -y }) {\n        ys.remove(at: ys.firstIndex(of:\
    \ { $0.0 < -y })!)\n    }\n\n    return ys.map { (x, y) in\n        (x, y) - (0,\
    \ 0) }", "    guard lst.count > 0 else { return []}\n    var coordinates = [(0,\
    \ 0)]\n    var row = [Int]()\n    for row in lst {\n        for column in row\
    \ {\n            if column == x {\n                coordinates.append((row, column))\n\
    \                break\n            }\n        }\n    }\n    coordinates = coordinates.sorted{\
    \ $0.1 < $1.1 }.sorted{ $0.2 < $1.2 }\n    return (coordinates.reversed())", " \
    \   if lst.isEmpty {\n        return asTuple([])\n    }\n    var coords = asTuple([],\
    \ [Int](x)) as [(Int, Int)]\n    for row in lst {\n        if x > row[0] {\n \
    \           for col in row.dropFirst() {\n                coords = (coords.0,\
    \ (coords.0 + 1, col))\n            }\n            coords.0 = x\n            break\n\
    \        }\n        coords.0 += 1\n    }\n    return coords.1", "    if lst.isEmpty()\
    \ {\n        return lst\n    }\n    if lst[0] != nil {\n        let row = len(lst[0])\
    \ + 1 - lst[0].firstIndex(of: x)\n        let row1 = lst[0].firstIndex(of: x)\n\
    \        let row2 = lst[0].firstIndex(of: x, offsetBy: 1)\n        return (row,\
    \ row1, row2)\n    } else {\n        let row = len(lst) + 1 - lst.firstIndex(of:\
    \ x)\n        let row1 = lst.firstIndex(of: x)\n        let row2 = lst.firstIndex(of:\
    \ x, offsetBy: 1)\n        return (row, row1, row2)\n    }", "    if lst == nil\
    \ {\n        return [] as [(Int, Int)]\n    }\n    // sort the column coordinates\
    \ in descending order\n    var row = [Int]()\n    for col in lst {\n        row.insert(col,\
    \ col.count)\n    }\n    var result = [(Int, Int)]()\n    result.sortInPlace((l1,\
    \ l2) => {\n        if l1.1 < l2.1 {\n            return true\n        } else\
    \ {\n            return false\n        }\n    })\n    // sort by the row coordinates\
    \ in ascending order\n    result.sortInPlace((l1, l2) => {\n        if l1.0 <\
    \ l2.0 {\n            return true\n        } else {\n            return false\n\
    \        }\n    })\n    var i = 0\n    for col in result {\n        if col[0]\
    \ == x {\n            result = get_row(lst: lst[i..<lst.count], x: x) as [(Int,\
    \ Int)]\n            break\n        }\n        i += 1\n    }\n    return result",
  "    lst = lst.sorted(by: >)\n    lst = lst.sorted(by: >)\n    let rowLen = min(lst.count,\
    \ x)\n    guard rowLen >= 1 else {\n        return lst as! [(Int, Int)]\n    }\n\
    \    \n    var ret: [(Int, Int)] = [(Int, Int)]()\n    var columns = [Int]()\n\
    \    var rows = [Int]()\n    \n    var row: Int = 0\n    var col: Int = 0\n  \
    \  \n    for row in 0 ..< rowLen {\n        columns.removeAll(keepingCapacity:\
    \ false)\n        columns.insert(x, at: 0)\n        \n        if col == 0 {\n\
    \            for col in columns.reverse() {\n                ret.insert( (row,\
    \ col), at: 0)\n            }\n            columns.removeAll(keepingCapacity:\
    \ false)\n        } else {\n            for col in columns.reverse() {\n     \
    \           let nextRow = row + 1\n                let nextCol = col - 1\n   \
    \             let nextColLen = min(nextRow, lst[nextRow].count)\n            \
    \    if nextColLen <= 0 {\n                    continue\n                }\n \
    \               \n                for (i, v) in lst[nextRow].enumerated() {\n\
    \                    if i < nextColLen {\n                        columns.insert(v,\
    \ at: i)\n                    } else {\n                        break\n      \
    \              }\n                }\n            }\n        }\n        \n    \
    \    rows.removeAll(keepingCapacity: false)\n        rows.append(row)\n    }\n\
    \    \n    return ret as! [(Int, Int)]", "    if lst.isEmpty() {\n        return\
    \ asSortedRows([] as [Int], [])\n    }\n    let rows = asSortedRows(lst, [])\n\
    \    let rowNums = rows.map { $0.row }\n    \n    let (row, col) = findRow(rowNums,\
    \ x)\n    return rows.map { coordinate -> [(Int, Int)] in\n        let (row, col)\
    \ = coordinate\n        return ((row + 0), (col + cols.count))\n    }", "    let\
    \ len = lst.count\n    var ans = [(0, 0)]\n    if len < 1 {\n        return ans\n\
    \    }\n    \n    for i in 0..<len {\n        let row = get_row_from(lst, i)\n\
    \        \n        var row_len = 0\n        for r in row {\n            if r ==\
    \ x {\n                row_len++\n            }\n        }\n        \n       \
    \ ans.append((i, row_len))\n    }\n    \n    ans = sort(ans)\n    ans = reverse(ans)\n\
    \    return ans", "    var ret = [[(0, 0)]]\n    for row in lst {\n        if\
    \ row.contains(x) {\n            ret.append(getIndex(row, x))\n        }\n   \
    \ }\n    return ret.sorted(byDescendingKey: { (lhs, rhs) -> Bool in\n        return\
    \ lhs.0 < rhs\n    })", "    var ret = [(Int, Int)]()\n    for (_, row) in lst.enumerated()\
    \ {\n        row.sortInPlace()\n        row.sortInPlace{ $1 < $0 }\n        ret.append(row.prefix(x).suffix(1))\n\
    \    }\n    return ret", "    let rows: [[Int]] = lst\n    if rows.isEmpty {\n\
    \        return []\n    }\n    // sort each row by columns in descending order\n\
    \    let reversedRows = rows.map { Array($0).sorted() }\n    // sort each row\
    \ by columns in ascending order\n    let sortedRows = reversedRows.map { Array($0).sorted()\
    \ }\n    // sort each row by columns in ascending order\n    let sortedRowsRowCols\
    \ = sortedRows.map {\n        let sortedRowsRowCols = sortedRows.map({ Array($0)\
    \ }).sorted(by: { $0.1 < $1.1 })\n        // sort each row by columns in descending\
    \ order\n        let sortedRowsRowColsRowCols = sortedRowsRowCols.map {\n    \
    \        sortedRowsRowCols.map({ Array($0).sorted(by: { $0.1 > $1.1 }) })\n  \
    \      }\n        return Array(sortedRowsRowColsRowCols)\n    }\n    // sort each\
    \ row by columns in descending order\n    let sortedRowsRowColsRowColsRowCols\
    \ = sortedRowsRowColsRowCols.map {\n        sortedRowsRowColsRowCols.map({ Array($0).sorted(by:\
    \ { $0.1 > $1.1 }) })\n    }\n    // sort each row by columns in descending order\n\
    \    let sortedRowsRowColsRowColsRowColsRowCols = sortedRowsRowColsRowColsRowColsRowCols.map\
    \ {\n        sortedRowsRowColsRowColsRowCols.map({ Array($0).sorted(by: { $0.1\
    \ > $1.1 }) })\n    }\n    // sort each row by columns in descending order\n \
    \   let sortedRowsRowColsRowColsRowColsRowColsRowCols = sortedRowsRowColsRowColsRowColsRowColsRowCols.map\
    \ {\n        sortedRowsRowColsRowColsRowColsRowCols.map({ Array($0).sorted(by:\
    \ { $0.1 > $1.1 }) })\n    }\n    // sort each row by columns in descending order\n\
    \    let sortedRowsRowColsRowColsRowColsRowColsRowColsRowCols = sortedRowsRowColsRowColsRowColsRowColsRowColsRowCols.map\
    \ {\n        sortedRowsRowColsRowColsRowColsRowColsRowCols.map({ Array($0).sorted(by:\
    \ { $0.1 > $1.1 }) })\n    }\n    // sort ", "    return lst.enumerated().filter({\
    \ (index, element) -> Bool in\n        return element == x\n    }).sorted { (a,\
    \ b) -> Bool in\n        if a.element < b.element { return true }\n        if\
    \ a.element > b.element { return false }\n        return a.element.hashValue <\
    \ b.element.hashValue\n    }.sorted { (a, b) -> Bool in\n        return a.element.hashValue\
    \ > b.element.hashValue\n    }.map { (index, element) -> (Int, Int) in\n     \
    \   return (index + 1, element)\n    }.sorted()", "    if lst.isEmpty {\n    \
    \    return []\n    }\n\n    // sort coordinates by rows in ascending order\n\
    \    let (row0, col0) = lst.first!.enumerated().minByElement { $0.element < $1.element\
    \ }\n    let row1 = lst[row0].count\n    let col1 = lst[row0][col0].count\n\n\
    \    var coords = [(Int, Int)]()\n    for i in stride(from: row0, through: row1,\
    \ by: 1) {\n        let (row2, col2) = lst[i ..< row1].enumerated().minByElement\
    \ { $0.element < $1.element }\n        for j in stride(from: col0, through: col1,\
    \ by: 1) {\n            coords.append((i, j))\n        }\n    }\n    coords.sort\
    \ { $0.0 < $1.0 }\n\n    // sort coordinates of each row by columns in descending\
    \ order\n    var coordsReversed = [((Int, Int), (Int, Int))]()\n    for (i, j)\
    \ in coords {\n        coordsReversed.append(\n            ((i, j)...))\n    }\n\
    \    coordsReversed.sort { $0.1 < $1.0 }\n    return coordsReversed[(x - col0)\
    \ ..< x]", "    var tupleArray = [[(Int, Int)]]()\n\n    for rows in lst {\n \
    \       var tupleList = [Int]()\n\n        for v in rows {\n            if v ==\
    \ x {\n                tupleList.append(1)\n            } else {\n           \
    \     tupleList.append(0)\n            }\n        }\n\n        var tuple = (rows.last!,\
    \ tupleList)\n\n        if tuple == tuple.first {\n            tupleArray.append(tuple)\n\
    \        }\n    }\n\n    return tupleArray", "    if lst.isEmpty {\n        return\
    \ []\n    }\n    var result = [(Int, Int)]()\n    let maxRow = lst.count\n   \
    \ let maxColumn = lst[0].count\n    for row in 0..<maxRow {\n        var column\
    \ = 0\n        for col in 0..<maxColumn {\n            if col == x {\n       \
    \         result.append( Tuple(row: row, column: column) )\n            }\n  \
    \          column++\n        }\n    }\n    result.sortInPlace()\n    return result",
  "    if lst.isEmpty() {\n        return []\n    }\n\n    let rows = lst.map({ $0.count\
    \ })\n    let columnsPerRow = rows.max()!\n\n    var coordinates = [(0, 0)]\n\n\
    \    for row in lst {\n        let rowIndex = row as [Int]\n        let rowSize\
    \ = rowIndex.count\n        var columnIndex = 0\n        for _ in 0..<rowSize\
    \ {\n            coordinates.append((rowIndex, columnIndex))\n            columnIndex\
    \ += rows![rowIndex.first]!\n        }\n    }\n\n    coordinates.sort { $0.0 <\
    \ $1.0 }\n    coordinates.sort { $1.0 > $0.0 }\n    coordinates.sort { $0.1 <\
    \ $1.0 }\n    coordinates.sort { $0.1 < $0.2 }\n\n    return coordinates\n   \
    \     .filter { (rowIndex, _) in rowIndex.first == x }\n        .map { (rowIndex,\
    \ _) in (rowIndex.first, rowIndex.last) }", "    let rowCount = lst.count\n  \
    \  if rowCount == 0 {\n        return []\n    }\n    var row = [Int]()\n    var\
    \ column = [Int]()\n    var i = 0\n    var j = 0\n    for row in lst {\n     \
    \   if j >= row.count {\n            break\n        }\n        if row[i] == x\
    \ {\n            let coord = (i + 1, j + 1)\n            column.append(coord)\n\
    \            j++\n        }\n        if j >= row.count {\n            break\n\
    \        }\n        i += 1\n        if i >= row.count {\n            break\n \
    \       }\n    }\n    column.reverse()\n    return column", "    if lst.isEmpty()\
    \ {\n        return [] // no elements in array -> no coordinates in array\n  \
    \  }\n    if lst.count > 1 {\n        var i = 0\n        for (rowIndex, row) in\
    \ lst.enumerated() {\n            for (colIndex, element) in row.enumerated()\
    \ {\n                if element == x {\n                    return [(rowIndex,\
    \ colIndex)]\n                }\n                i += 1\n            }\n     \
    \   }\n    }\n    return []", "    if lst.isEmpty() {\n        return []\n   \
    \ }\n    var result = [(Int, Int)]()\n    for row in lst {\n        for col in\
    \ row {\n            if col == x {\n                result = append(result, (row,\
    \ col))\n            }\n        }\n    }\n    result.sortInPlaceByKey(ascending:\
    \ false)\n    result.sortInPlaceByKey(ascending: true, reverse: true)\n    return\
    \ result", "    var row = [(0, 0)]\n    var columns = [(0, 0)]\n    for row in\
    \ lst {\n        var rowIndex = 0\n        for column in row {\n            if\
    \ column == x {\n                let rowTuple = (rowIndex, columns[rowIndex])\n\
    \                for (index, column) in columns.enumerated() where columns[index]\
    \ > column {\n                    columns[index], column = column, columns[index]\n\
    \                }\n                let columnTuple = (rowIndex, columns[rowIndex])\n\
    \                return rowTuple.predecessor().successor()\n            }\n  \
    \          rowIndex += 1\n        }\n    }\n    return [] as [(Int, Int)]", " \
    \   if lst.isEmpty {\n        return [] as [(Int, Int)]\n    }\n\n    var result\
    \ = lst[0]\n\n    // sort initially by rows ascending\n    for index in 0..<lst.count\
    \ {\n        if index < result.count {\n            if index == 0 {\n        \
    \        result[index] = (0, result[index])\n            } else {\n          \
    \      let rowA = result[index][0]\n                let rowB = result[index][1]\n\
    \                let colA = index\n                let colB = index - 1\n\n  \
    \              if colA < colB {\n                    result[index] = (rowA, colA)\n\
    \                    result[index + 1] = (rowB, colB)\n                } else\
    \ {\n                    result[index] = (rowB, colB)\n                    result[index\
    \ + 1] = (rowA, colA)\n                }\n            }\n        }\n    }\n\n\
    \    // sort initially by columns descending\n    for index in 0..<lst.count {\n\
    \        if index < result.count {\n            if index == 0 {\n            \
    \    result[index] = (0, result[index])\n            } else {\n              \
    \  let rowA = result[index][0]\n                let rowB = result[index][1]\n\
    \                let colA = index\n                let colB = index - 1\n\n  \
    \              if colA < colB {\n                    result[index] = (rowB, colB)\n\
    \                    result[index + 1] = (rowA, colA)\n                } else\
    \ {\n                    result[index] = (rowA, colA)\n                    result[index\
    \ + 1] = (rowB, colB)\n                }\n            }\n        }\n    }\n\n\
    \    return result", "    lst = lst.reversed()\n    var result = lst.filter {\
    \ row in\n        let maxIndex = row.index{ row in\n            return row[x]\
    \ <= x\n        }\n        return (maxIndex.item < row.count) && maxIndex.item\
    \ != 0\n    }.sorted(by: { $0.0 < $1.0 }).flatMap { row in\n        let maxIndex\
    \ = row.index{ row in\n            return row[x] <= x\n        }\n        if maxIndex.item\
    \ == 0 {\n            return []\n        }\n        let row = row.reverse { $0.item\
    \ > $1.item }\n        return row.indices.map({ i in (row.first, i) })\n    }\n\
    \    return result.reversed()", "    var i = 0\n    var y = 0\n    var result\
    \ = [(Int, Int)]()\n    while i < lst.count {\n        // if current row is empty\n\
    \        if lst[i] == nil {\n            i += 1\n            continue\n      \
    \  }\n        // if current row contains x\n        if lst[i][0] == x {\n    \
    \        // get next row\n            var y = 0\n            i += 1\n        \
    \    while (i < lst.count) && (lst[i] == nil) {\n                i += 1\n    \
    \        }\n            if i < lst.count {\n                // if next row contains\
    \ x, append result\n                let (row, _) = lst[i]\n                result.append(Tuple2(row,\
    \ y))\n                // get next column\n                i += 1\n          \
    \      while (i < lst.count) && (lst[i] == nil) {\n                    i += 1\n\
    \                }\n                if i < lst.count {\n                    //\
    \ if next column contains x, append result\n                    let (_, col) =\
    \ lst[i]\n                    result.append(Tuple2(col, x))\n                }\n\
    \            }\n        }\n        // if current row does not contain x\n    \
    \    else {\n            i += 1\n        }\n    }\n    result.sortInPlace()\n\
    \    return result", "    if lst.isEmpty() {\n        return makeEmpty()\n   \
    \ }\n    var i = 0\n    var j = 0\n    var result = [(i, j)] as [(Int, Int)]\n\
    \    while i < lst.count && j < lst[i].count {\n        if lst[i][j] == x {\n\
    \            result.append((i, j))\n            j++\n        } else {\n      \
    \      j++\n        }\n        i++\n    }\n    if i == lst.count {\n        return\
    \ makeEmpty()\n    }\n    for _ in 0..<lst.count {\n        result.append((i,\
    \ j))\n        i++\n        j = 0\n    }\n    return result", "    guard !lst.isEmpty()\
    \ else { return [] }\n\n    // sort coordinates initially by rows in ascending\
    \ order\n    var rowIdxs = lst.map{ $0.index(of: x) }.sorted().map { $0 - x }\n\
    \    rowIdxs.reverse()\n\n    // sort coordinates of the row by columns in descending\
    \ order\n    var colIdxs = rowIdxs.map{ lst[$0].index(of: x) }.sorted().map {\
    \ $0 - x }\n\n    return rowIdxs.map { idx in\n        (idx, colIdxs[idx])\n \
    \   }", "    if lst.isEmpty() {\n        return make([] as [(Int, Int)])\n   \
    \ }\n    let rowLen = lst[0].count\n    let (rows, cols) = (0..<rowLen).map {\
    \ i in\n        (lst[0][i], lst[1][i])\n    }\n    let rows = rows.sorted(by:\
    \ { $0.0 < $1.0 }).map({ $0.0 })\n    let cols = cols.sorted(by: { $0.0 < $1.0\
    \ }).map({ $0.0 })\n    var result = [(0, 0)] as [(Int, Int)]\n    for i in 0..<rowLen-1\
    \ {\n        if cols.contains(i) && rows.contains(i) {\n            result.append(\
    \ ((rows[i], i), ((rows[i+1], i+1))) )\n        }\n    }\n    result.append( ((rows[rowLen-1],\
    \ rowLen-1), ((rows[0], 0)), ) )\n    return result"]
stop_tokens:
- "\n}"
