name: HumanEval_133_sum_squares
language: swift
prompt: "\n/// You are given an array of numbers.\n/// You need to return the sum\
  \ of squared numbers in the given array,\n/// round each element in the array to\
  \ the upper int(Ceiling) first.\n/// Examples:\n/// >>> sum_squares(lst: [1.0, 2.0,\
  \ 3.0])\n/// 14\n/// >>> sum_squares(lst: [1.0, 4.0, 9.0])\n/// 98\n/// >>> sum_squares(lst:\
  \ [1.0, 3.0, 5.0, 7.0])\n/// 84\n/// >>> sum_squares(lst: [1.4, 4.2, 0.0])\n///\
  \ 29\n/// >>> sum_squares(lst: [-2.4, 1.0, 1.0])\n/// 6\nfunc sum_squares(lst: [Double])\
  \ -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\n\
  assert(sum_squares(lst: [1.0, 2.0, 3.0]) == 14)\nassert(sum_squares(lst: [1.0, 3.0,\
  \ 5.0, 7.0]) == 84)\nassert(sum_squares(lst: [1.4, 4.2, 0.0]) == 29)\nassert(sum_squares(lst:\
  \ [-2.4, 1.0, 1.0]) == 6)\nassert(sum_squares(lst: [100.0, 1.0, 15.0, 2.0]) == 10230)\n\
  assert(sum_squares(lst: [10000.0, 10000.0]) == 200000000)\nassert(sum_squares(lst:\
  \ [-1.4, 4.6, 6.3]) == 75)\nassert(sum_squares(lst: [-1.4, 17.9, 18.9, 19.9]) ==\
  \ 1086)\nassert(sum_squares(lst: [0.0]) == 0)\nassert(sum_squares(lst: [-1.0]) ==\
  \ 1)\nassert(sum_squares(lst: [-1.0, 1.0, 0.0]) == 2)"
completions: ["  var res = 0.0\n  for num in lst {\n    res += pow(num, 2)\n  }\n\
    \  return Int(ceil(res))", "    let squareSum = lst.flatMap { $0 * $0 }.reduce(0.0,\
    \ +)\n    return Int(round(squareSum))", "  var sum = 0\n  for num in lst {\n\
    \    sum += pow(num, 2.0)\n  }\n  return Int(ceilf(Double(sum)))", "    let n\
    \ = lst.count\n    let sum = 0\n    let sq = 0\n    for i in 0..<n {\n       \
    \ sq += Double(i) * Double(i)\n        sum += sq\n    }\n    return round(sum)",
  "    var sum = 0.0\n    for value in lst {\n        sum += value * value\n    }\n\
    \    return Int(ceil(sum))", '    return lst.map { $0.roundToInt().squared().roundToInt().value
    }.sum()', "    var result = 0.0\n    for i in lst {\n        let tmp = (Int(ceil(i))).squared()\
    \ + i * i\n        result -= tmp\n    }\n    return result", "    var sum = 0.0\n\
    \    for num in lst {\n        sum += num * num\n    }\n    return Int(round(Double(sum)\
    \ * 0.5))", "    var sum = 0\n    var i = 0\n    for n in lst {\n        sum +=\
    \ ((n - Int(n)) * Int(n))\n        i = i + 1\n    }\n    return sum", '    return
    lst.map{ Int($0 * $0) }.reduce(0)', "    var sum = 0\n    for num in lst {\n \
    \       sum += num * num\n    }\n    return Int(ceil(Double(sum))) // TODO: consider\
    \ return Int(ceil(sum))", "  var sum = 0\n  for i in lst {\n    sum += i * i\n\
    \  }\n  return Int(ceil(sum))", "    if lst.count <= 0 {\n        return -1\n\
    \    }\n    \n    let sqrtSum = lst.map { $0.pow $0 * $0 }.reduce(0, +)\n    \n\
    \    return lst.map { Int($0.pow $0 * $0) }.max() ?? -1 * sqrtSum", '    return
    lst.map { $0.roundingMode(.ceiling) }.reduce(0.0, +)', '    return lst.reduce(0,
    combine: +)', "    var result: Int = 0\n    for i in lst {\n        result = result\
    \ + Int(i * i)\n    }\n    return result", "  // sum squared numbers in the array\n\
    \  var sum_squares = 0.0\n  for i in lst {\n    sum_squares += pow(i.square(),\
    \ 2.0)\n  }\n  \n  // round each element in the array to the upper int(Ceiling)\
    \ first\n  var round_to_ceiling  = 0.0\n  var round_to_ceiling_2 = 0.0\n  for\
    \ i in lst {\n    round_to_ceiling += pow(round(i.square(), 2), 2.0)\n    round_to_ceiling_2\
    \ += pow(round(i.square(), 2), 2.0)\n  }\n  \n  return sum_squares + round_to_ceiling\
    \ + round_to_ceiling_2", "    if lst.count < 1 {\n        return 0\n    }\n  \
    \  let max = lst[0]\n    var sum = 0\n    for x in lst{\n        if x > max {\n\
    \            max = x\n        }\n    }\n    for x in lst{\n        sum += pow(x,\
    \ 2)\n    }\n    return round(sum / max)", "    var sum = 0.0\n    for num in\
    \ lst {\n        sum += (num * num)\n    }\n    return Int(ceil(Double(sum)))",
  "  let max = ceil(max(lst))\n  return lst.map { $0 * $0 }.compactMap { ($0 * ($0\
    \ - max)) }.reduce(0, combine: +)", "    var total = 0\n    for x in lst {\n \
    \       total += x.pow(2)\n    }\n    return Int(ceil(total))", "    var sum =\
    \ 0\n    for x in lst {\n        sum += pow(x, 2)\n    }\n    return Int(round(Double(sum)))",
  "    if lst.isEmpty {\n        return 0\n    }\n    var sum = 0\n    var prev: Double\
    \ = lst[0]\n    for x in lst {\n        sum += x * x\n        prev = x\n    }\n\
    \    if abs(prev) > 1E-4 {\n        sum += prev * prev\n    }\n    return Int(ceiling(sum))",
  "    var sum: Int = 0\n    for d in lst {\n        sum += (d * d)\n    }\n    return\
    \ sum", "    \n    var sum: Double = 0.0\n    \n    for n in lst {\n        sum\
    \ += n * n\n    }\n    \n    return Int(ceil(lst.map(Float64).reduce(0.0, +)))",
  '    return lst.map { $0 * $0 }.reduce(0, +)', "    var sum_sq = 0\n    for num\
    \ in lst {\n        sum_sq += (Int(num) * Int(num))\n    }\n    return sum_sq",
  "  var sum = 0\n  for var i = 0; i < lst.count; i++ {\n    let v = lst[i]\n    sum\
    \ += v * v\n  }\n  return sum", '    return round(lst.map(&pow(2.0, Double(0.))).reduce(0,
    +))', "    if lst.count == 0 {\n        return 0\n    }\n    var sum: Double =\
    \ 0.0\n    for i in 0..<lst.count {\n        sum += lst[i] * lst[i]\n    }\n \
    \   return Int(round(Double(sum) * 1000))", "    func getSquares(_ arr: [Double])\
    \ -> [Double] {\n        var retArr: [Double] = (0..<arr.count).map { i in\n \
    \           arr[i] * arr[i]\n        }\n        return retArr\n    }\n    func\
    \ ceil(_ x: Double) -> Double {\n        return (x + x).truncatingRemainder(dividingBy:\
    \ 1.0)\n    }\n    var sqArr = getSquares(lst)\n    sqArr.forEach({\n        $0\
    \ = ceil($0)\n    })\n    let sum = sqArr.reduce(0.0, +)\n    return sum", '    return
    lst.flatMap { $0 * $0 }.sum() // O(n)', "    let len = lst.count\n    if len ==\
    \ 0 {\n        return 0\n    }\n    var total = 0.0\n    var sum1 = 0.0\n    for\
    \ n in lst {\n        total += n * n\n        sum1 += n\n    }\n    let sum2 =\
    \ pow(total, .5)\n    return sum1 / pow(sum2, 0.5)", '    return lst.map{ $0 *
    $0 }.reduce(0,+)', "    let nums = lst.map(Float.init)\n    return sum_squared(nums)",
  '    return lst.map{ $0 * $0 }.sum()', "    var sum: Double = 0\n    for _ in lst\
    \ {\n        sum += .squared() // round each element to upper int(Ceiling) first\n\
    \    }\n    return Int(sum)", "    if lst.isEmpty {\n        return 0\n    }\n\
    \    var sum = 0\n    for i in lst {\n        sum += i * i\n    }\n    let roundedSum\
    \ = Int(sum)\n    return roundedSum", "    var result = 0.0\n    for element in\
    \ lst {\n        if element > 0.0 {\n            result = (result + element) *\
    \ (element + 1.0)\n        } else {\n            result = result + element\n \
    \       }\n    }\n    return Int(round(result))", "    var sum = lst.reduce(0,\
    \ +) * lst.reduce(0, +) * lst.reduce(0, +)\n    return Int(ceil(sum / Double(lst.reduce(0,\
    \ +) * lst.reduce(0, +) * lst.reduce(0, +))))", "    if lst.count == 0 {\n   \
    \     return 0\n    }\n\n    // Sum squares\n    var sum: Double = 0.0\n    for\
    \ i in 0..<lst.count {\n        sum += pow((lst[i] - floor(lst[i])), 2)\n    }\n\
    \n    // Round up\n    var res = floor(sum) + 0.5\n    var sign = -1\n\n    if\
    \ res < 0.0 {\n        res = res * sign\n    }\n\n    return Int(round(res))",
  '  return lst.map { Int(ceil(Double($0)))*Int(ceil(Double($0))) }.sum()', "  let\
    \ len = lst.count\n  if len == 0 {\n    return 0\n  }\n\n  // round the numbers\
    \ to ceiling first\n  var sum = 0\n  var count = 0\n  for item in lst {\n    if\
    \ item > 0 {\n      sum += item\n      count++\n    }\n  }\n  guard count != len\
    \ else {\n    fatalError(\"List cannot be empty.\")\n  }\n\n  // square each number\
    \ after rounding\n  var square = pow(Double(sum), 2)\n\n  for item in lst {\n\
    \    square += pow(item, 2)\n  }\n  return square", "    let n = lst.count\n \
    \   if n < 2 {\n        return lst[0]\n    }\n    var sum = 0\n    for v in lst\
    \ {\n        sum += v * v\n    }\n    return Int(ceil(sum / Double(n)))", "  \
    \  var sum: Double = 0.0\n    for i in lst {\n        sum += i * i\n    }\n  \
    \  return Int(ceil(sum))", "    \n    for i in 0..<lst.count{\n        let x =\
    \ lst[i]\n        lst[i] = Int(ceil(x))\n    }\n    \n    var sum = 0.0\n    for\
    \ i in 0..<lst.count{\n        sum = sum + lst[i]\n    }\n    \n    return sum\
    \ * sum", '    return lst.map({$0.roundToInt()}).reduce(0, +)', "    var sum:\
    \ Double = 0\n    for i in lst {\n        sum += i * i\n    }\n    return Int(ceil(sum))",
  "    return lst.map(Int).reduce(0) { total, current in\n        return total + (current\
    \ * current)\n    }", "    var sum : Int = 0\n    for number in lst {\n      \
    \  sum += Int(ceil(number * number))\n    }\n    return sum", "    var sum = 0\n\
    \    for i in lst {\n        sum += i * i\n    }\n    return Int(ceil(sum))",
  "  if lst.isEmpty {\n    return 0\n  }\n  var sum: Double = 0\n  var cur: Double\
    \ = 0\n  for v in lst {\n    cur = cur * (v + v)\n    sum += cur\n  }\n  return\
    \ Int(round(Double(sum)))", "  var sum = 0\n  for v in lst {\n    sum += v * v\n\
    \  }\n  return sum", "    let sum = 0\n    for (index, value) in lst.enumerated()\
    \ {\n        sum += pow(value, 2.0)\n    }\n    return Int(ceil(sum))", '    return
    Int(ceil(sum((lst)) * pow(_stdlib_Math_sqrt(sum((lst))) + 1.0, 2.0)))', '    return
    sum_squares(lst: lst, rounding: RoundingMode.up)', '    return sum(lst).squared()
    + Int(ceil(sum.squared() * 0.5))', "    var sum: Int = 0\n    for elt in lst {\n\
    \        sum += Int(elt) * Int(elt)\n    }\n    return sum", "    var res = 0.0\n\
    \    for v in lst {\n        res += (v * v)\n    }\n    return Int(ceil(res))",
  "    return Int(map({ (x) -> Int in\n        let i = Int(ceil(Double(x)))\n    \
    \    return x*x\n    })(lst))", '  return lst.map(.ceiling).fold(0, +)', '    return
    lst.map(sqrt).reduce(0, +)', "    let result = 0.0\n    for x in lst {\n     \
    \   result += x.toInt() * x.toInt()\n    }\n    return result", "    let result:\
    \ Int = lst.count\n    for number in lst {\n        result += pow(number, 2)\n\
    \    }\n    return result", "    let sum = lst.map { $0 * $0 }.reduce(0, +)\n\
    \    return sum", "    var sum = 0\n    for i in lst {\n        sum += i * i\n\
    \    }\n    return Int(ceil(sum))", "  var res = 0.0\n  for elem in lst {\n  \
    \  res = res + pow(Double(elem), 2)\n  }\n  return Int(round(Double(res)))", " \
    \ // your code here\n  var i = 0\n  var sum = 0\n  while i < lst.count {\n   \
    \ sum += Int(ceil(lst[i]))\n    i += 1\n  }\n  return sum", '    return (lst.reduce(0,
    +) * lst.reduce(0.0, +)) / (lst.reduce(0.0, +) * lst.reduce(0.0, -))', "    if\
    \ lst.count < 1 {\n        return 0\n    }\n    var sum: Int = 0\n    for i in\
    \ 0 ..< lst.count {\n        let tmp = i * i\n        sum += Int(tmp)\n    }\n\
    \    return sum", '    return sum_squares(lst: lst, length: lst.count)', "   \
    \ var sum : Int = 0\n    for v in lst {\n        sum += Int(pow(v, 2))\n    }\n\
    \    return sum", "    let max: Double = lst.maxElement()!\n    var sum: Double\
    \ = 0\n    lst.map { sum += pow(Double($0) * $0, 2) }\n    return Int(max * sum)",
  "    var sum = 0.0\n    var square = 0.0\n    for i in lst {\n        sum += i *\
    \ i\n        square += i\n    }\n    return Int(ceil(Double(square) / Double(sum)))",
  '    return sum_squares(lst: lst, roundToInt: true)', "    var squareSum = 0\n \
    \   for i in lst {\n        squareSum += Int(pow(i, 2.0))\n    }\n    return squareSum",
  "  var result = 0\n  var prevSum = Double(0) // for calculating rounding error of\
    \ previous number\n  for number in lst {\n    if number > 0 {\n      // square\
    \ of current number rounded up\n      let newSum = ceil(pow(number, 2) / prevSum)\n\
    \      result += newSum\n      prevSum = newSum\n    }\n  }\n  return result",
  "    if lst.isEmpty {\n        return 0\n    }\n    var sq = 0.0\n    for i in 0..<lst.count\
    \ {\n        sq += pow(lst[i], 2)\n    }\n    return Int(ceil(sq))", "    let\
    \ res = 0\n    for i in lst {\n        guard i > 0, let int = Int(ceil(i)) else\
    \ { return res }\n        res += int * int\n    }\n    return res", "  if lst.count\
    \ <= 0 {\n    return 0\n  }\n  var sum = 0\n  var squareSum = lst[0]\n  for element\
    \ in lst {\n    sum += squareSum\n    squareSum += element * element\n  }\n  return\
    \ sum", '    return sum_squares(lst: lst, round_num: Math.ceil)', "    var result\
    \ = 0\n    for i in lst {\n        result += pow(i, 2)\n    }\n    return Int(ceil(result\
    \ + 0.5))", '    return lst.reduce(0, +)', '    return sum(lst, sq)', '    return
    sum_squares(ArrayOfDouble(lst))', "    var sum_sq = 0.0\n    for v in lst {\n\
    \        sum_sq += v * v\n    }\n    return Int(ceil(sum_sq))", "    var sum:\
    \ Double = 0\n    var n: Int = 0\n    \n    for number in lst {\n        sum +=\
    \ pow(number, 2)\n        n++\n    }\n    \n    return sum", "    let mut sum\
    \ = 0.0\n\n    for v in lst {\n        sum += v * v\n    }\n\n    return round(sum)",
  "    var sum = 0.0\n    var i = 0\n    for _ in lst {\n        sum += pow(Double(i),\
    \ 2.0)\n        i += 1\n    }\n    return Int(ceil(Ceil(sum)))", "    \n    func\
    \ round(a: Double) -> Double {\n        \n        var rounded = Double()\n   \
    \     \n        if a > 0 {\n            rounded = Int(round(Double(a)))\n    \
    \    }\n        \n        return rounded\n    }\n    \n    var sum = 0\n    \n\
    \    for a in lst {\n        let roundA = round(a)\n        let roundedA = Int(roundA)\n\
    \        sum += roundedA * a\n    }\n    \n    return sum", "    var sum = 0\n\
    \    for x in lst {\n        sum += x * x\n    }\n    return Int(ceilf(sum))",
  "    return reduce((accumulator, value) -> (Int, Double) -> Double in\n    {\n \
    \       var accumulator_value = accumulator\n        if accumulator_value == nil\
    \ {\n            accumulator_value = 0\n        }\n        return $0 + accumulator_value\
    \ * $1, accumulator_value\n    }, $0, lst)", '    return lst.map { $0 * $0 }.reduce(0,
    +)', "  var sum = 0\n  for number in lst {\n    sum += pow(Double(number), 2)\n\
    \  }\n  return Int(round(Double(sum)))", "  let sum: Int = lst.map{ $0.squared\
    \ }.sum()\n  return Int(ceil(sum))", "  var sum: Int = 0\n  for num in lst {\n\
    \    sum += num * num\n  }\n  return sum", "    let length = lst.count\n    var\
    \ sum = 0.0\n    for index in 0...length {\n        sum += pow(lst.index(index,\
    \ offsetBy: index).squared() - pow(index, 2.0), 0.5)\n    }\n    return Int(ceil(sum))",
  '  return lst.reduce(0) { $0 + $1 * $1 }', "    guard !lst.isEmpty else {\n    \
    \    return 0\n    }\n    var total = 0\n    for num in lst {\n        total +=\
    \ Int(ceil(num * num))\n    }\n    return total", "    var sum = 0.0\n\n    for\
    \ i in lst {\n        sum += i * i\n    }\n\n    return Int(ceilf(Double(sum)))",
  "    var sum: Int = 0\n    for i in lst {\n        sum += math.pow(i.rounded(),\
    \ 2)\n    }\n    return sum", "    let size = lst.count\n    var sum = 0.0\n \
    \   for i in 0..<size {\n        sum += (lst[i] - Int(lst[i])) ** 2\n    }\n \
    \   return sum", "    var res = 0.0\n    for v in lst {\n        res += (v * v)\n\
    \    }\n    return Int(ceil(res))", '    return lst.map({ $0 * $0 }).reduce(+)',
  "  var sum = 0\n  for number in lst {\n    sum += pow(number, 2)\n  }\n  return\
    \ Int(round(Float(sum)))", '    return lst.map { Double($0).squareRoot().round()
    }.reduce(0, +)', "    var sum = lst.reduce(0, combine: { (sum, item) -> Int in\n\
    \        let rounded = Int(ceil(item * 1000))\n        return sum + rounded\n\
    \    })\n    return sum", "  var sum = 0\n  var lastIdx = 0\n  for idx in lst.indices\
    \ {\n    if idx > lastIdx {\n      sum += (Float(lst.list[lastIdx]) - Float(lst.list[idx])\
    \ * Float(lst.list[idx])) / Float(lst.list[idx])\n    }\n    lastIdx = idx\n \
    \ }\n  return sum", "    var res = 0.0\n    for d in lst {\n        res += d *\
    \ d\n    }\n    return Int(round(res))", "    let sum = lst.map { return $0 *\
    \ $0 }.reduce(0, +)\n    return Int(floor(sum))", "    var sum = 0\n    for v\
    \ in lst {\n        sum += v * v\n    }\n    return Int(roundf(sqrt(Double(sum))))",
  '  return lst.map{ pow(Double($0), 2) }.reduce(0, +)', "    // add sum of square\
    \ of elements to result\n    var result = 0.0\n\n    // add each element to result\n\
    \    for i in lst {\n        result += i * i\n    }\n\n    // round the result\
    \ to nearest integer\n    let rounded = Int(ceil(result))\n\n    // return rounded\
    \ result\n    return rounded", '    return lst.map{ $0.roundingModeToUp() }.reduce(0.0,
    +) + 0', "  var sum: Double = 0\n  for i in lst {\n    let square = i * i\n  \
    \  sum += Int(square)\n  }\n  return Int(sum)", "  var sum: Double = 0\n  for\
    \ i in lst {\n    sum += i * i\n  }\n  return round(sum)", "    let sum = (lst.reduce(0,\
    \ +))\n    let sqrt = sqrt(Double(sum))\n    return (sqrt * sqrt).rounded(.towardZero)",
  "    var sum: Double = 0.0\n    var sqsum: Double = 0.0\n\n    for x in lst {\n\
    \        sum += x\n        sqsum += x * (x * x)\n    }\n\n    if sqsum > 0.0 {\n\
    \        return (sum + sqsum).round()\n    }\n\n    return 0", "    var sum =\
    \ 0.0\n    var square_sum = 0.0\n    for x in lst {\n        sum += x\n      \
    \  square_sum += x * x\n    }\n\n    return Int((sum - square_sum) / Double(Double(lst).count))",
  "    var squares: Int = 0\n    for number in lst {\n        squares  += number *\
    \ number\n    }\n    return Int(ceil(squares))", "    var result: Int = 0\n  \
    \  for i in lst {\n        result *= i\n    }\n    return result", "    guard\
    \ lst.count > 0 else { return 0 }\n    var sum = 0.0\n    \n    for i in 0..<lst.count\
    \ {\n        sum += Math.pow(lst[i], 2.0)\n    }\n    \n    return sum", "  var\
    \ squares = 0.0\n  for num in lst {\n    squares += Double(num) * Double(num)\n\
    \  }\n  return round(squares).rounded()", "    var sum: Double = 0.0\n    for\
    \ i in lst {\n        sum += i * i\n    }\n    return Int(ceil(sum))", "    let\
    \ sum: Double = 0.0;\n    for x in lst {\n        sum += (Double(x) * x);\n  \
    \  }\n    return Int(ceil(sum))", "    let sum: Double = 0.0\n    for val in lst\
    \ {\n        sum += val * val\n    }\n    return Int(ceil(sum))", '    return
    Int((lst.map({ $0.round() })).reduce({ $0 + $1 }).round())', '    return lst.map
    { $0.round().toInt() }.map { $0 * $0 }.sum()', "    var sum = 0.0\n    for num\
    \ in lst {\n        sum += num * num\n    }\n    return Int((sum).round())", '    return
    lst.map { ($0 as? Double)?.rounded(.towardZero) ?? 0 }.sum()', "    guard lst.count\
    \ > 0 else { return 0 }\n    var sumSquares = 0\n    for i in 0 ..< lst.count\
    \ {\n        let v = ceil(Float(lst[i]))\n        sumSquares += v * v\n    }\n\
    \    return sumSquares", "  guard lst.count > 0 else { return 0 }\n  guard lst.count\
    \ <= Int.max else { return Int.max }\n\n  // sort by ceiling\n  let sortedArray\
    \ = lst.sorted(by: { $0.ceil > $1.ceil })\n  var sum: Double = 0\n\n  for value\
    \ in sortedArray {\n    sum += pow(value, 2.0)\n  }\n\n  return Int(round(sum))",
  "    var res = 0.0\n    var idx = 1\n    for n in lst {\n        res = res + n *\
    \ n\n        idx = idx + (n >= 0)\n    }\n    return Int(res)", "  let size =\
    \ lst.count\n  let min = lst.minElement()\n  let max = lst.maxElement()\n  var\
    \ result = 0.0\n  for i in 0..<size {\n    let num1 = Int(floor(Double(lst[i])))\n\
    \    let num2 = Int(ceil(Double(lst[i])))\n    result += pow(num1 - num2, 2)\n\
    \  }\n  return Int(floor(result + min))", '    return lst.reduce(0, combine: {
    $0 + $1 * $1 })', "    var res = 0.0\n    for e in lst {\n        res = res +\
    \ pow(abs(e), 2.0)\n    }\n    return Int(round(res))", '    return reduce(0)
    { $0 + $1 * $1 }', '  return lst.map({ sqrt($0) }).reduce(0.0, +)', "    var sum\
    \ = 0\n    for i in lst {\n        sum += Int(i * i)\n    }\n    return sum",
  '    return lst.map { $0 * $0 }.sum() // Slower than O(n^2)', '    return Int(lst.map
    { Int($0 * $0) }.sum())', "    var sqSum = 0\n    for i in 0..<lst.count {\n \
    \       sqSum += i * i\n    }\n    return Int(sqSum)", "    guard lst.count >\
    \ 0 else { return 0 }\n    var res = 0.0\n    for number in lst {\n        res\
    \ += number * number\n    }\n    return Int(ceil(res / 2.0))", '    return lst.map
    { Int($0) }.fold(0, +)', "    var sum = 0\n    for el in lst {\n        sum +=\
    \ (el * el)\n    }\n    return Int(math.Ceil(sum / Double(lstCount))) + sum",
  "    if lst.isEmpty {\n        return 0\n    }\n\n    let upper = lst.max()!\n \
    \   var sum = 0.0\n    for i in lst {\n        sum += i * i\n    }\n    return\
    \ round(sum * pow(2.0, Double(upper)))", "    if lst.isEmpty() {\n        return\
    \ 0\n    }\n\n    let max = lst.max()!\n    var sum: Int = 0\n\n    for d in lst\
    \ {\n        sum += d * d\n    }\n\n    sum = Int(round(sum / max))\n    return\
    \ sum", "    return lst.map { (value) -> Double in\n        let result = value\
    \ * value\n        return Int(ceil(Double(result)))\n    }.sum() ?? 0", '    return
    lst.map { $0 * $0 }.sum()', "    var sum = lst[0]\n    for _ in 1...lst.count\
    \ {\n        sum += lst[_]\n    }\n    return Int(round(pow(sum, 2.0)))", '    return
    lst.reduce(0, { $0 + pow(Double($1), 2) })', "    let len = lst.count\n    if\
    \ len == 0 {\n        return 0\n    }\n    let sq = lst[0] * lst[0]\n    for i\
    \ in 1..<len {\n        sq += lst[i] * lst[i]\n    }\n    return Int(ceil(Double(sq)))",
  "    guard lst.count != 0 else { return 0 }\n    var result = 0.0\n    for x in\
    \ lst {\n        result = result + (x) * (x)\n    }\n    return (Int(result))",
  '    return lst.map(Int.init).reduce(0) { $0 + $1 * $0 }', "    var sum = 0\n  \
    \  for i in lst {\n        sum += i * i\n    }\n    return Int(ceil(CGFloat(sum)))\
    \ + Int(ceil(CGFloat(sum))) + Int(ceil(CGFloat(sum)))", "    if lst.count < 2\
    \ {\n        return 0.0\n    }\n    var sqsum = 0\n    for i in lst {\n      \
    \  sqsum += i * i\n    }\n    return Int(floor(Double(sqsum) + 0.5))", '    return
    lst.filter { $0 > 0 }.map { pow($0, 2.0) }.sum', '    return lst.flatMap({ Double($0).roundToInt()*Double($0).roundToInt()
    }).reduce(0, combine: +)', "    var res = 0.0\n    for val in lst {\n        let\
    \ d = ceil(val * val)\n        res += d\n    }\n    return res", "    var sum\
    \ = 0.0;\n\n    for num in lst {\n        sum += num * num;\n    }\n\n    return\
    \ Int(round(Double(sum)));", "    \n    if lst.count > 0 {\n        return Int(ceil(sum_squares(lst:\
    \ lst.0)))\n    }\n    \n    return 0", "    var sum = 0\n    var squares: Int\
    \ = 0\n    for i in 0..<lst.count {\n        sum += lst[i] * lst[i]\n        squares\
    \ += lst[i] * lst[i]\n    }\n    return Int(round(Float(squares)/Double(sum)))",
  "    var sum = 0\n    for v in lst {\n        sum += (v * v)\n    }\n    return\
    \ Int(ceilf(Double(sum)))", "    if lst.count == 0 {\n        return 0\n    }\n\
    \n    var sum = 0.0\n    for num in lst {\n        let f = num.truncatingRemainder(dividingBy:\
    \ 1.0)\n        sum += f * f\n    }\n\n    return sum", "    let sum = lst.reduce(0,\
    \ +)\n    let sqsum = lst.map{ $0 * $0 }.reduce(0, +)\n    return sum + sqsum",
  "    let sortedLst = lst.sorted(by: <)\n    return sortedLst.reduce(0, combine:\
    \ +)", "    var sum = 0\n    for d in lst {\n        sum += d*d\n    }\n    return\
    \ Int(ceil(sum))", "    var sum : Int = 0\n    var n = lst.count\n    for i in\
    \ 0..<n {\n        sum = sum + pow(lst[i], 2.0)\n    }\n    return Int(ceil(sum))",
  "    // write your code in Swift 4.2 or later\n    let maxIndex:Int? = lst.max()\
    \ ?? 0\n    var sum:Double = 0.0\n    for (index, element) in lst.enumerated()\
    \ {\n        sum += pow(element, Double(index))\n    }\n    return sum + pow(maxIndex,\
    \ Double(lst.count))", "    return lst.sum { (num) -> Double in\n        let ceiling\
    \ = num.ceiling()\n        return ceiling * ceiling\n    }", '    return sum_squares(lst:
    lst, roundToUpper: true)', "    var sum_ = 0\n    for x in lst {\n        sum_\
    \ += x * x\n    }\n    return Int(ceil(sum_))", "    var sum: Int = 0\n    for\
    \ d in lst {\n        sum += d * d\n    }\n    return sum", "  var sum = 0\n \
    \ var sumSq = 0\n  for v in lst {\n    sum += v\n    sumSq += v * v\n  }\n  return\
    \ Int(round(sumSq / Float(countElements(lst))))", "  var result = 0.0\n  for value\
    \ in lst {\n    result += value * value\n  }\n  return Int(result)", "    var\
    \ sum = 0\n    for i in lst {\n        sum += i * i\n    }\n    return Int(ceil(sum))",
  "    var result = 0\n    for i in 0..<lst.count {\n        result = (result + pow(Double(i),\
    \ 2.0)).round()\n    }\n    return result", "    var total = 0\n    for num in\
    \ lst {\n        total += num * num\n    }\n    return Int(ceil(total))", '  return
    sum_squares(lst: lst, length: lst.count)', "    var sum = 0\n    for num in lst\
    \ {\n        sum += num * num\n    }\n    return Int(ceil(sum))", '    return
    lst.map { $0.powi(2) }.sum()', "    guard lst.count > 0 else { return 0 }\n  \
    \  var sum = 0\n    for i in 0..<lst.count {\n        sum += pow(Double(lst.i)!,\
    \ 2)\n    }\n    return Int(ceil(sum))", "  if lst.count == 0 {\n    return 0\n\
    \  }\n  return Int(sqrt(Double(sum(lst.map { $0 * $0 }))))", '    return sum_squares(lst:
    lst, rounding: ceil)', "    guard lst.count > 0 else { return 0 }\n    var sum\
    \ = 0\n    lst.sortInPlace()\n    for i in 0..<lst.count {\n        let x = round(Double(lst[i]))\n\
    \        sum += x * (x * x)\n    }\n    return sum", "  let sum = lst.reduce(0,\
    \ {$0 + $1})\n  return Int(round(sum * sum))", '    return lst.map { $0 * $0 }.sum()',
  '    return (lst.map { Int(pow(Double($0), 2)) }).reduce(0, +)', "  var sum = 0.0\n\
    \  for num in lst {\n    sum += num * num\n  }\n  return Int(ceil(sum))", '    return
    lst.map(Float64).reduce(0.0).rounded(.up).map(Float64).reduce(0, +)', "    var\
    \ sum = 0\n    for i in lst {\n        sum += i * i\n    }\n    return Int(round(sum))",
  "  var sum: Double = 0.0\n  for num in lst {\n    sum += pow(num, 2)\n  }\n  return\
    \ Int(ceil(sum))", "    let sum = lst.map { $0 * $0 }\n    return sum.reduce(0,\
    \ +)", "    // Write your code here\n    let sum = 0\n    for n in lst {\n   \
    \     sum += n * n\n    }\n    return sum", '    return lst.map({$0 * $0}).reduce(0,
    +)', '    return lst.filter { $0 * $0 }.map { $0.roundToInt().pow(2) }.sum()',
  "    var sum = 0.0\n    for x in lst {\n        sum += (x + x) / 2.0\n    }\n  \
    \  return Int(Double(sum))", "    var sum = 0\n    for i in lst {\n        sum\
    \ += pow(i, 2)\n    }\n    return Int(ceil(sum))", "    \n    let sum = lst.reduce(0,\
    \ {$0 + $1})\n    return sum * sum", "    var sum: Double = 0\n    for i in lst\
    \ {\n        sum += pow(i, 2)\n    }\n    return Int(ceil(sum))"]
stop_tokens:
- "\n}"
