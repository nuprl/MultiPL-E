name: HumanEval_112_reverse_delete
language: swift
prompt: "\n/// Task\n/// We are given two strings s and c, you have to deleted all\
  \ the characters in s that are equal to any character in c\n/// then check if the\
  \ result string is palindrome.\n/// A string is called palindrome if it reads the\
  \ same backward as forward.\n/// You should return a tuple containing the result\
  \ string and true/false for the check.\n/// Example\n/// >>> reverse_delete(s: \"\
  abcde\", c: \"ae\")\n/// (\"bcd\", false)\n/// >>> reverse_delete(s: \"abcdef\"\
  , c: \"b\")\n/// (\"acdef\", false)\n/// >>> reverse_delete(s: \"abcdedcba\", c:\
  \ \"ab\")\n/// (\"cdedc\", true)\nfunc reverse_delete(s: String, c: String) -> (String,\
  \ Bool) {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(reverse_delete(s: \"abcde\", c: \"ae\")\
  \ == (\"bcd\", false))\nassert(reverse_delete(s: \"abcdef\", c: \"b\") == (\"acdef\"\
  , false))\nassert(reverse_delete(s: \"abcdedcba\", c: \"ab\") == (\"cdedc\", true))\n\
  assert(reverse_delete(s: \"dwik\", c: \"w\") == (\"dik\", false))\nassert(reverse_delete(s:\
  \ \"a\", c: \"a\") == (\"\", true))\nassert(reverse_delete(s: \"abcdedcba\", c:\
  \ \"\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"abcdedcba\", c: \"\
  v\") == (\"abcdedcba\", true))\nassert(reverse_delete(s: \"vabba\", c: \"v\") ==\
  \ (\"abba\", true))\nassert(reverse_delete(s: \"mamma\", c: \"mia\") == (\"\", true))"
completions: ["    var result = \"\"\n    var flag = true\n    for index in range(len(s)\
    \ - 1) {\n        if s[index] != c[index] {\n            flag = false\n      \
    \      break\n        } else {\n            result = result + s[index]\n     \
    \   }\n    }\n    if flag == true {\n        return (result, true)\n    } else\
    \ {\n        return (result, false)\n    }", "    var r = s\n    var isPalindrome\
    \ = true\n    for index in stride(from: s.characters.count-1, to: 0, by: -1) {\n\
    \        if r[index] != c[index] {\n            r = String(c)\n            isPalindrome\
    \ = false\n            break\n        }\n    }\n    return (String(r), isPalindrome)",
  "    if c != \"\" && s == \"\" {\n        return (\"\", false)\n    }\n    \n  \
    \  var count = 0\n    \n    for char in s.characters {\n        if char == c.characters[count]\
    \ {\n            count += 1\n        } else if count == c.characters.count {\n\
    \            return (s.characters.reverse(), true)\n        }\n    }\n    \n \
    \   return (\"\", false)", "\t\n\t// Write your code here\n\t\n\treturn (s, true)",
  "\tvar ret String = \"\"\n\tvar check Bool = true\n\tvar idx int\n\tvar c Character\n\
    \tvar i int\n\tvar prev Character\n\tvar j int\n\tvar n int\n\tvar len int\n\t\
    var k int\n\tfor i = 0, n = len(s); i < n; i++ {\n\t\tc = s[i]\n\t\tfor j = 0,\
    \ len = (n - i - 1); j < len; j++ {\n\t\t\tif c == s[j] {\n\t\t\t\tprev = s[j\
    \ + 1]\n\t\t\t\ts[j + 1] = \"\"\n\t\t\t\tcheck = false\n\t\t\t}\n\t\t\tif prev\
    \ == c {\n\t\t\t\ts[j + 1 ] = \"\"\n\t\t\t\tcheck = false\n\t\t\t}\n\t\t}\n\t\t\
    if check == true {\n\t\t\tret += s[i]\n\t\t}\n\t}\n\tif s == ret {\n\t\treturn\
    \ (ret, true)\n\t} else {\n\t\treturn (ret, false)\n\t}", "    var rev = String()\n\
    \    var bIsPalindrome = false\n    for i := 0; i < len(s); i++ {\n        if\
    \ s[i] != c{\n            rev += s[i]\n        } else {\n            i -= 1\n\
    \            bIsPalindrome = true\n        }\n    }\n    return (String(rev),\
    \ bIsPalindrome)", "    if s == c {\n        return (s, true)\n    }\n    \n \
    \   var i = 0\n    var j = 0\n    var k = s.count - 1\n    \n    while i < k &&\
    \ j < c.count {\n        if s[i] == c[j] {\n            i += 1\n            j\
    \ += 1\n        } else {\n            i += 1\n        }\n    }\n    \n    if i\
    \ == k {\n        return (s, false)\n    }\n    \n    var newS = String()\n  \
    \  var newC = String()\n    \n    for index in 0..<s.count {\n        if index\
    \ > i {\n            newS += String(s[index])\n        } else {\n            newC\
    \ += String(s[index])\n        }\n    }\n    \n    return (reverse_delete(newS,\
    \ newC), true)", "\treturn revDelete(s, c)", "    var sLen: Int = 0\n    var cLen:\
    \ Int = 0\n    var newS: String = \"\"\n    var newC: String = String(c)\n\n \
    \   for _ in 0..<s.count {\n        sLen += 1\n        newS = String(s.suffix(with:\
    \ sLen))\n        cLen += newS.count\n        newC = String(c.suffix(with: cLen))\n\
    \n        if newS != newC {\n            return (newS, false)\n        }\n   \
    \ }\n\n    return (s, true)", "    // Your code goes here\n    // let str = \"\
    \"\n    // for s in str\n    //     if s == c\n    // return (s, True)\n    //\
    \ else\n    // return (s, False)\n    var str = \"\"\n    var rev = \"\"\n   \
    \ for char in s {\n        str = str + char\n    }\n    for char in c {\n    \
    \    rev = rev + char\n    }\n    if str == rev {\n        return (str, true)\n\
    \    }\n    return (str, false)", "    var a = s\n    var b = s\n    for i in\
    \ 0 ..< len(s) {\n        if s[i] == c {\n            a = a.replacingOccurrences(of:\
    \ String(s[i]), with: \"\")\n        } else {\n            b = b.replacingOccurrences(of:\
    \ String(s[i]), with: \"\")\n        }\n    }\n    return (a, b)", "\tvar result\
    \ String = \"\"\n\tvar flag Bool = false\n\tfor i := 0; i < len(s); i++ {\n\t\t\
    if s[i] == c[0] {\n\t\t\tresult = result + s[i]\n\t\t\ti++\n\t\t}\n\t\tif i ==\
    \ len(s) {\n\t\t\tbreak\n\t\t}\n\t\tresult = result + s[i]\n\t}\n\tif strings.ToLower(result)\
    \ == strings.ToLower(s) {\n\t\tflag = true\n\t}\n\treturn (result, flag)", "\t\
    var s = s\n\tvar c = c\n\tlet n = s.characters.count\n\tvar r = String()\n\tvar\
    \ reversed = false\n\tfor i in  s.characters.indices{\n\t\tif s[i] != c{\n\t\t\
    \ts.append(c[i-1])\n\t\t} else {\n\t\t\tif i == 0 {\n\t\t\t\treversed = true\n\
    \t\t\t} else {\n\t\t\t\ts.append(c[i])\n\t\t\t}\n\t\t}\n\t}\n\tif s.characters.count\
    \ == 0 {\n\t\treturn (String(), false)\n\t} else {\n\t\tif reversed == true {\n\
    \t\t\tr = reverse(r)\n\t\t}\n\t\treturn (s, true)\n\t}", "    let reverseString\
    \ = s.reversed()\n    if reverseString == c {\n        return (s, true)\n    }\
    \ else {\n        if reverseString.first == c.first {\n            if reverseString.last\
    \ == c.last {\n                return (reverseString.dropFirst(), true)\n    \
    \        } else {\n                return (reverseString.dropFirst().first + reverseString.dropFirst().last,\
    \ reverseString.dropFirst().last == c.last)\n            }\n        } else {\n\
    \            return (reverseString.first + reverseString.last, reverseString.last\
    \ == c.last)\n        }\n    }", "\tvar i int\n\tvar j int\n\tvar s []int\n\t\
    var c []int\n\tvar result String\n\tfor i = 0; i < len(s); i++ {\n\t\ts[i] = s[i]\n\
    \t}\n\tfor j = 0; j < len(c); j++ {\n\t\tc[j] = c[j]\n\t}\n\tfor i = len(s) -\
    \ 1; i >= 0; i-- {\n\t\tfor j = len(c) - 1; j >= 0; j-- {\n\t\t\tif s[j] == c[j]\
    \ {\n\t\t\t\ts[i] = s[i] + s[j]\n\t\t\t\tj = j - 1\n\t\t\t\tif j == -1 {\n\t\t\
    \t\t\tresult = result + s[i]\n\t\t\t\t\ts = s[i+1:]\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\tif s == nil || result == nil {\n\t\treturn\n\t}\n\treturn", "    var\
    \ result = \"\"\n    var inString = false\n    for letter in s {\n        if letter\
    \ == c {\n            if inString {\n                result = result + letter\n\
    \            }\n            inString = true\n        } else {\n            if\
    \ inString {\n                result = result + letter\n            } else {\n\
    \                result = result + letter\n            }\n            inString\
    \ = false\n        }\n    }\n    return (result, inString == false)", "    var\
    \ resultString = String()\n    var resultIsPalindrome = Bool()\n    for i := 0;\
    \ i < len(s); i++ {\n        if s[i] == c[0] {\n            deleteCharacter(s,\
    \ i, c)\n            if s == resultString {\n                resultIsPalindrome\
    \ = true\n            } else {\n                resultIsPalindrome = false\n \
    \           }\n        }\n    }\n    return (resultString, resultIsPalindrome)",
  "    let newS = deleteChar(s: s, c: c)\n    let rev = String(newS.reversed())\n\
    \    return (String(rev), newS.isPalindrome())", "    let newS = delete(s, c:\
    \ c)\n    let newS2 = reverse_delete(newS, c: c)\n    return (newS2, newS2 ==\
    \ newS)", "    // Write your solution here\n    if s == \"\" || c == \"\" {\n\
    \        return (s, true)\n    }\n    var r = 0\n    var r2 = 1\n    var flag\
    \ = false\n    for i = 3; i > 0; i-- {\n        if s[i] == c[r] {\n          \
    \  r++\n            if i == 3 {\n                flag = true\n            }\n\
    \        } else {\n            r = 0\n            flag = false\n        }\n  \
    \      if r2 == len(c) {\n            if flag == true {\n                return\
    \ (s, false)\n            }\n        } else {\n            r2++\n        }\n \
    \   }\n    return (s, true)", "    // Write your code here\n    \n    let newStr\
    \ = s.filter{ c != $0 }.map { String($0) }\n    if s == newStr {\n        return\
    \ (c, true)\n    } else {\n        return (c, false)\n    }", "    if s == \"\"\
    \ {\n        return (s, true)\n    }\n    if c == \"\" {\n        return (s, false)\n\
    \    }\n\n    // delete all the characters in s that are equal to any character\
    \ in c\n    // we do this by iterating from right to left\n    // the first character\
    \ of the string is the last character of the string, therefore we iterate from\
    \ right to left\n    var i = s.characters.count - 1\n    var j = c.characters.count\
    \ - 1\n\n    var result = \"\"\n    var isPalindrome = false\n\n    while i >=\
    \ 0 || j >= 0 {\n        if i == 0 {\n            result = result + s.characters[j]\n\
    \            j = j - 1\n        } else if j == 0 {\n            result = result\
    \ + s.characters[i]\n            i = i - 1\n        } else {\n            if s.characters[i]\
    \ == c.characters[j] {\n                result = result + s.characters[i]\n  \
    \              i = i - 1\n                j = j - 1\n            } else {\n  \
    \              isPalindrome = false\n            }\n        }\n    }\n\n    return\
    \ (result, isPalindrome)", "    var i = 0\n    var resultString = \"\"\n    var\
    \ isPalindrome = true\n    for ; i < s.characters.count; i++ {\n        if s[i].unicodeScalars.contains(c)\
    \ {\n            resultString.append(s[i])\n        }\n    }\n    if isPalindrome\
    \ {\n        return (resultString, isPalindrome)\n    } else {\n        return\
    \ (resultString, isPalindrome)\n    }", "    \n    // Write your code here.\n\
    \    \n    let chars = s.characters.map{ String($0) }\n    let charc = c.characters.map{\
    \ String($0) }\n    var str1 = \"\"\n    var str2 = \"\"\n    var result: String\
    \ = s\n    for (_, ch) in chars.enumerated() {\n        str1 += String(ch)\n \
    \   }\n    for (_, ch) in charc.enumerated() {\n        str2 += String(ch)\n \
    \   }\n    if str1 == str2 {\n        return (result, true)\n    }\n    if str2.isEmpty\
    \ {\n        return (result, false)\n    }\n    if str1.isEmpty {\n        return\
    \ (result, false)\n    }\n    if str1.characters.first == str2.characters.last\
    \ {\n        return (result, true)\n    }\n    if str1.characters.last == str2.characters.first\
    \ {\n        return (result, true)\n    }\n    if str1.characters.first == str2.characters.last+1\
    \ {\n        return (result, false)\n    }\n    if str1.characters.last-1 > str2.characters.first\
    \ {\n        return (result, false)\n    }\n    if str1.characters.last-1 < str2.characters.last\
    \ {\n        return (result, true)\n    }\n    if str1.characters.first-1 > str2.characters.first\
    \ {\n        return (result, true)\n    }\n    if str1.characters.first-1 < str2.characters.last\
    \ {\n        return (result, false)\n    }\n    \n    return (false, false)",
  "    var resultString = s\n    var isDeleted = false\n    for i in s.reverse() {\n\
    \        if i != c {\n            resultString = resultString+i\n        }\n \
    \       else {\n            isDeleted = true\n        }\n    }\n    return (resultString,\
    \ isDeleted)", "    var p = 0\n    var q = s.characters.count\n    var rev = String()\n\
    \    for _ in 0..<q {\n        rev.append(s[p])\n        p++\n    }\n    if c\
    \ == rev {\n        return (rev, true)\n    } else {\n        var ans = String()\n\
    \        var k = q\n        for _ in 0..<q {\n            if s[p] != c[q] {\n\
    \                ans.append(s[p])\n                k--\n                p++\n\
    \            } else {\n                p++\n            }\n        }\n       \
    \ if (k == q) {\n            ans.append(s[p])\n        }\n        return (rev,\
    \ false)\n    }", "    var rs = \"\"\n    var rc = 0\n    for s in s.unicodeScalars\
    \ {\n        if s == c {\n            rs = rs.appendingString(String(s.value)!)\n\
    \            rc++\n        }\n    }\n    if rc > 0 {\n        rs = rs.reversed()\n\
    \    }\n    return (rs, rc == s.count)", "    if c == \"\" {\n        return (s,\
    \ true)\n    }\n\n    var reverseString = String()\n\n    for _ in 0..<(s.count\
    \ + c.count - 1) {\n        var i = 0\n        var j = s.count\n\n        while\
    \ j > 0 {\n            let tmpStr = s[(j - 1) - i]\n            let tmpBool =\
    \ tmpStr == c\n            reverseString = reverseString! + tmpStr\n         \
    \   i = i + 1\n            j = j - 1\n            if tmpBool == false {\n    \
    \            break\n            }\n        }\n\n        if j < s.count {\n   \
    \         var tmpStr = s[(j - 1) - i]\n            var tmpBool = tmpStr == c\n\
    \            while tmpBool == false {\n                reverseString = reverseString\
    \ + tmpStr\n                i = i + 1\n                j = j - 1\n           \
    \     if j > s.count {\n                    break\n                }\n       \
    \         tmpStr = s[(j - 1) - i]\n                tmpBool = tmpStr == c\n   \
    \         }\n        }\n\n        if i == s.count {\n            return (s.reversed(),\
    \ true)\n        }\n    }\n\n    return (s.reversed(), false)", "    var i = s.characters.count\n\
    \    var j = c.characters.count\n    var rev = \"\"\n    var rev_c = \"\"\n  \
    \  \n    while i < j {\n        rev += String(s.characters[i])\n        rev_c\
    \ += String(c[i])\n        i += 1\n        j -= 1\n    }\n    \n    if rev.characters\
    \ != rev_c.characters {\n        return (\"\", false)\n    }\n    \n    return\
    \ (String(rev), true)", "    var stringResult = \"\"\n    var resultBool = false\n\
    \n    var length = s.characters.count\n    var i = 0\n    while i < length {\n\
    \        stringResult.append(s.characters[i])\n        i += 1\n\n        i -=\
    \ 1\n        i %= length\n\n        if stringResult.characters.last == c.characters.last\
    \ {\n            resultBool = true\n        } else {\n            resultBool =\
    \ false\n            break\n        }\n    }\n\n    return (stringResult, resultBool)",
  "    if s != c && s.isEmpty || c.isEmpty {\n        return (\"\", false)\n    }\n\
    \    if s == c {\n        return (\"\", true)\n    }\n    var slen = s.length\n\
    \    var clen = c.length\n    var i, j, temp : Int\n    var flag = true // flag\
    \ for check\n    for (i = 0; i < slen; i = i + 1) {\n        temp = s[i]\n   \
    \     for (j = 0; j < clen; j = j + 1) {\n            if s[i] != c[j] {\n    \
    \            flag = false\n                break\n            }\n        }\n \
    \       if flag {\n            s = s.dropLast()\n            slen = s.length\n\
    \        }\n        flag = true\n    }\n    if slen == clen {\n        return\
    \ (s, true)\n    }\n    return (\"\", false)", "\tvar rs = \"\"\n\tvar res = \
    \ s.characters.reverse()\n\tfor i in res {\n\t\tif i == c.characters.first {\n\
    \t\t\trs = rs+i\n\t\t}\n\t}\n\t\n\tif rs == s {\n\t\treturn (res, true)\n\t}\n\
    \telse {\n\t\treturn (res, false)\n\t}", "\tvar result String = \"\"\n\tvar reverse\
    \ bool = false\n\tlet size = s.count\n\t\n\t// create new string for each character\
    \ in s\n\tfor letter in s.characters {\n\t\tresult += letter\n\t}\n\t\n\t// looping\
    \ through the characters in the string and deleting all characters equal to the\
    \ letter from c\n\tfor index in 0...(size-1) {\n\t\tif s[index] == c[size-1-index]\
    \ {\n\t\t\treverse = true\n\t\t} else {\n\t\t\treverse = false\n\t\t}\n\t\tresult\
    \ = String(String(result).characters.dropLast())\n\t}\n\t\n\t// check if result\
    \ string is palindrome\n\tif reverse {\n\t\treturn (result.reverse(), true)\n\t\
    } else {\n\t\treturn (result.reverse(), false)\n\t}", "    var reversed: String\
    \ = s\n    var result: String = reversed\n    var i: Int = 0\n    for let ch in\
    \ c.characters {\n        while i < s.characters.count {\n            if reversed.characters.count\
    \ != s.characters.count {\n                break\n            }\n            if\
    \ reversed.characters.first != s.characters.first {\n                break\n \
    \           }\n            let i = reversed.index(s.characters.first!, offsetBy:\
    \ 1)\n            reversed.remove(at: i)\n        }\n        result.removeSubrange(i,\
    \ length: 1)\n        i += 1\n    }\n    return (result, reversed == s)", "  \
    \  // Write your code here.\n    \n    return s.reversed().filter({ !$0.characters.contains(c)\
    \ }).first == s, true", "    // Write your code here.\n    if s == \"\" {\n  \
    \      return (c, false)\n    }\n    var rev = s.reverse()\n    for index in 0..<s.count\
    \ {\n        if rev[index] != c[index] {\n            return (rev, false)\n  \
    \      }\n    }\n    return (rev, true)", "    var r = \"\"\n    var rev = \"\
    ^\"\n    var deleted: Bool = false\n    for i := 0; i < len(s); i++ {\n      \
    \  if s[i] == c[i] {\n            r += s[i]\n            deleted = true\n    \
    \    } else {\n            r += rev + s[i]\n        }\n        rev = rev + rev\
    \ + s[i]\n    }\n    if s == r {\n        return (s, deleted)\n    }\n    return\
    \ (s, false)", "    // Your code here\n    guard let first = s.firstIndex(of:\
    \ c) else {\n        return (s, false)\n    }\n    guard let last = s.lastIndex(of:\
    \ c) else {\n        return (s, false)\n    }\n    var result = \"\"\n    \n \
    \   for i in s.characters.reversed() {\n        if i != s.firstIndex(of: c) &&\
    \ i != s.lastIndex(of: c) {\n            result += \"\\(i)\"\n        }\n    }\n\
    \    return (result, true)", "    \n    var ans = \"\"\n    var flag = false\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] == c[0] {\n            ans\
    \ = ans + s[i+1 : i+1]\n            flag = true\n        } else {\n          \
    \  ans = ans + s[i]\n        }\n    }\n    if flag == true {\n        return (ans,\
    \ true)\n    } else {\n        return (ans, false)\n    }", "    \n    // TODO:\
    \ Your code here!\n    \n    return (\"NOT IMPLEMENTED YET\", false)", "    var\
    \ rs = s\n    var rc = 0\n    for i in rs {\n        if i != c {\n           \
    \ rs = rs.delete(i)\n        }\n    }\n    return (rs, rs.isPalindrome())", " \
    \   let result = s.reverseDelete(c)\n    return (c, result == s)", "  var result:\
    \ String = String()\n  var isPalindrome = true\n\n  for currentChar in s.characters\
    \ {\n    if c.characters.contains(currentChar) == false {\n      result += String(currentChar)\n\
    \    }\n  }\n\n  for currentChar in result.characters {\n    if s.characters.contains(currentChar)\
    \ == false {\n      isPalindrome = false\n    }\n  }\n\n  return (result.reversed(),\
    \ isPalindrome)", "    var resultString = \"\"\n    var isPalindrome = true //\
    \ We assume that the string is palindrome to start\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] != c[len(s)-i-1] {\n            isPalindrome = false\n\
    \            break\n        }\n    }\n    if isPalindrome {\n        return resultString,\
    \ isPalindrome\n    } else {\n        return s, false\n    }", "    var rs = s.reverse()\n\
    \    var rc = c.reverse()\n    var pal = true\n    for index in rs {\n       \
    \ if rc != rs[index] {\n            pal = false\n            break\n        }\n\
    \    }\n    return (rs.reverse(), pal)", "    var result = s\n    for _, b :=\
    \ range c {\n        result = result[s.index(b) : s.index(b) + 1]\n    }\n   \
    \ if result != s {\n        return (\"false\", false)\n    }\n    return (\"true\"\
    , true)", "  var rev = 0\n  var str = \"\"\n  var n = s.characters.count\n  \n\
    \  for index in 0..<n {\n    str = String(str) + String(s.characters.reverse())\n\
    \    \n    if s.characters.count == 0 {\n      break\n    }\n    \n    if s[index]\
    \ == c[index] {\n      rev -= 1\n      \n      if rev < 0 {\n        rev = str.characters.count\n\
    \        str = \"\"\n      }\n    }\n  }\n\n  return (str, rev == 0)", "    var\
    \ result = \"\"\n    var isDeleted = false\n\n    for index, _ := range s {\n\
    \        if s[index] == c {\n            isDeleted = true\n        } else {\n\
    \            result = result + s[index]\n        }\n    }\n    if isDeleted {\n\
    \        return result, true\n    } else {\n        return result, false\n   \
    \ }", "    let resultString = (reverseDeleteHelper(s.chars, c.chars, \"\"))\n\
    \    return (resultString.chars, resultString.isPalindrome)", "    var res: String\
    \ = s\n    for _, i in s.characters.enumerated() {\n        if s.characters.contains(c)\
    \ {\n            res = res[s.index(after: i) : s.index(before: i)] + res[s.index(before:\
    \ i) : s.index(after: i)]\n        }\n    }\n    return (res, true)", "    var\
    \ result = \"\"\n    var resultIsPalindrome = true\n    for char in s.characters.reversed()\
    \ {\n        if char == c.characters.first {\n            result = result + char\n\
    \        } else {\n            resultIsPalindrome = false\n            break\n\
    \        }\n    }\n\n    return (result, resultIsPalindrome)", "    var rev =\
    \ String()\n    for x in s.characters {\n        if x == c {\n            debugPrint(x.description)\n\
    \            continue\n        }\n        rev = rev + String(repeating:x, count:\
    \ 1)\n    }\n\n    return (s.reversed, s.characters == rev.characters)", "   \
    \ let resultString = s\n    for i in s.characters.reverse() {\n        if s.substringWithRange(i)\
    \ == c {\n            resultString.deleteCharactersInRange(Range<String.Index>(start:\
    \ i, end: i+1))\n        }\n    }\n\n    return (resultString, resultString ==\
    \ s)", "    guard s.count > 0 && c.count > 0 else {\n        return (s, true)\n\
    \    }\n    var left = s.startIndex\n    var right = s.startIndex\n    var i =\
    \ left\n    var j = right\n    var k = 0\n    var reversed = false\n    while\
    \ i < s.count && j < c.count {\n        if s[i] == c[j] {\n            i += 1\n\
    \            j += 1\n            k += 1\n        } else {\n            i += 1\n\
    \        }\n    }\n    while i < s.count {\n        reversed = !reversed\n   \
    \     i += 1\n    }\n    while j < c.count {\n        reversed = !reversed\n \
    \       j += 1\n    }\n    if k == 0 {\n        return (s, false)\n    } else\
    \ {\n        if k > 0 {\n            right = s.startIndex + k - 1\n        }\n\
    \        if reversed {\n            return (s[s.startIndex..<right], true)\n \
    \       } else {\n            return (s[left..<s.startIndex], true)\n        }\n\
    \    }", "    var index = 0\n    var result = \"\"\n    var first = true\n\n \
    \   for i = s.characters.count - 1; i >= 0; i-- {\n        if s.characters[i]\
    \ == c.characters[index].unicodeScalars.first {\n            if first {\n    \
    \            result = s.characters.suffix(s.characters.count - i)\n          \
    \  } else {\n                result = s.characters.prefix(s.characters.count -\
    \ i)\n            }\n\n            first = false\n            index++\n      \
    \  }\n    }\n\n    return (result, first == true)", "    var (result, check) =\
    \ reverseDelete(s, c)\n    return (result, check)", "    var result = \"\"\n \
    \   for ch in s {\n        if ch == c {\n            result = result + ch\n  \
    \      } else {\n            result = result + ch\n        }\n    }\n    return\
    \ (reverseString(result), true)", "    var result = s\n    var isPalindrome =\
    \ true //assume it is palindrome\n    let len = s.characters.count\n    \n   \
    \ for i in 0..<(len - c.characters.count) {\n        if s[i] != c[len-(i+1)] {\n\
    \            isPalindrome = false\n        }\n    }\n    return (result, isPalindrome)",
  "    \n    // Your code here\n    \n    return (s, true)", "\tresult = \"\"\n\t\
    isPalindrome = true\n\n\tfor i in s.characters {\n\t\tif i == c.characters[0]\
    \ {\n\t\t\tresult += \"\\(c.characters[0])\"\n\t\t\tisPalindrome = false\n\t\t\
    } else {\n\t\t\tresult += String(i)\n\t\t}\n\t}\n\n\treturn (result, (isPalindrome\
    \ == true))", "    var leftIndex = 0\n    var rightIndex = s.count - 1\n    \n\
    \    while leftIndex < rightIndex {\n        if s[leftIndex] != c[rightIndex]\
    \ {\n            leftIndex++\n            rightIndex--\n        }\n        else\
    \ if rightIndex == leftIndex {\n            let palindromeIndex = rightIndex\n\
    \            let result = s[palindromeIndex..<s.count]\n            return (result,\
    \ true)\n        }\n    }\n    \n    return (s, false)", "    var result = s\n\
    \    var forward = true\n    var backward = true\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] != c[i] {\n            if backward {\n              \
    \  result = s[:i] + s[i+1:]\n            } else {\n                result = s[:i]\
    \ + s[i:]\n            }\n            if forward {\n                if result\
    \ != s {\n                    backward = false\n                } else {\n   \
    \                 backward = true\n                }\n            }\n        \
    \    forward = true\n        } else {\n            backward = true\n        }\n\
    \    }\n    return (result, backward)", "    var resultString = s\n    for _character\
    \ in c {\n        if resultString.hasSuffix(_character) {\n            resultString\
    \ = resultString.suffix(whileMaxLength: 1)\n        }\n    }\n    return (resultString,\
    \ resultString.hasSuffix(c))", "    if c == \"\" { // nothing to delete\n    \
    \    return (s, true)\n    }\n    \n    // we start from the end of s\n    //\
    \ first delete the characters in s\n    // then check if it equals to c\n    \n\
    \    // check first character of s\n    if let s1 = s.substringWithRange( NSMakeRange(0,\
    \ 1) ),\n       let r1 = s1.rangeOfCharacterFromSet(NSCharacterSet.letterCharacterSet())\
    \ {\n        // delete that character\n        let s1 = s.removeCharactersInRange(\
    \ r1 )\n        \n        // check first character of c\n        if let s2 = c.substringWithRange(\
    \ NSMakeRange(0, 1) ),\n            let r2 = s2.rangeOfCharacterFromSet(NSCharacterSet.letterCharacterSet())\
    \ {\n            \n            // delete that character\n            let s2 =\
    \ c.removeCharactersInRange( r2 )\n            \n            // check first character\
    \ of c\n            if let s3 = s2.substringWithRange( NSMakeRange(0, 1) ),\n\
    \                let r3 = s3.rangeOfCharacterFromSet(NSCharacterSet.letterCharacterSet())\
    \ {\n                // delete that character\n                let s3 = s2.removeCharactersInRange(\
    \ r3 )\n                \n                // check first character of c\n    \
    \            if let s4 = s3.substringWithRange( NSMakeRange(0, 1) ),\n       \
    \             let r4 = s4.rangeOfCharacterFromSet(NSCharacterSet.letterCharacterSet())\
    \ {\n                    // delete that character\n                    let s4\
    \ = s3.removeCharactersInRange( r4 )\n                    \n                 \
    \   // check first character of c\n                    if let s5 = s4.substringWithRange(\
    \ NSMakeRange(0, 1) ),\n                        let r5 = s5.rangeOfCharacterFromSet(NSCharacterSet.letterCharacterSet())\
    \ {\n                        // delete that character\n                      \
    \  let s5 = s4.removeCharactersInRange( r5 )\n                        \n     \
    \                   // check first character of c\n                        if\
    \ let s6 = s5.substringWithRange( NSMakeRange(0, 1) ),\n                     \
    \       let r6 = s6.rangeOfCharacterFromSet(NSCharacterSet.letterCharacterSet())\
    \ {\n                            // delete that character\n                  \
    \          let s6 = s5.removeCharactersInRange( r6 )\n                       \
    \     \n                            // check first character of c\n          \
    \                  if let s7 = s6.substringWithRange( NSMakeRange(0, 1) ),\n \
    \                               let r7 = s7.rangeOfCharacterFromSet(NSCharacterSet.letterCharacterSet())\
    \ {\n                                // delete that character\n              \
    \                  let s7 = s6.removeCharactersInRange( r7 )\n               \
    \                 \n                                // check first character of\
    \ c\n                                if let s8 = s7.substringWithRange( NSMakeRange(0,\
    \ 1) ", "    var rString = \"\"\n    var isCheck = false\n    var cIndex = 0\n\
    \    var rIndex = 0\n    for rIndex < s.count {\n        cIndex = s.index(c, rIndex)\n\
    \        if cIndex == -1 {\n            rString = rString + s[rIndex]\n      \
    \  } else {\n            rString = rString + s[cIndex] + s[rIndex]\n        }\n\
    \        rIndex += 1\n    }\n    return (rString, isCheck)", "    if s.isEmpty\
    \ || c.isEmpty { return (s, false) }\n    var i = 0\n    var r = \"\"\n    while\
    \ i < s.count {\n        if s[i] == c[i] { i += 1 } else {\n            i += 1\n\
    \            r += s[i]\n        }\n    }\n    return (s, r == s)", "\tlength :=\
    \ len(s)\n\tcount := 0\n\ti := 0\n\tvar result String = \"\"\n\tvar isPalindrome\
    \ Bool = false\n\tfor i < length {\n\t\tif s[i] == c[i] {\n\t\t\tcount += 1\n\t\
    \t} else {\n\t\t\tcount = 0\n\t\t}\n\t\tif count == length-1 {\n\t\t\tresult +=\
    \ (s[count : count+i])\n\t\t\tisPalindrome = true\n\t\t}\n\t\ti += 1\n\t}\n\t\
    return (result, isPalindrome)", "    var string: String = s\n    var bool: Bool\
    \ = false\n    var index = 0\n    \n    while index < string.count {\n       \
    \ if string[index] != c {\n            string = string[index..<string.count]\n\
    \        } else {\n            bool = true\n            string[index..<string.count]\
    \ = \"\"\n        }\n        index += 1\n    }\n    return (string, bool)", " \
    \   if s == \"\" {\n        return (\"\", false)\n    }\n\n    if c == \"\" {\n\
    \        return (s, true)\n    }\n\n    var result = []rune(\"\")\n    \n    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] == c[len(c)-1] {\n            result[len(result)-1]\
    \ = s[i]\n        }\n    }\n    \n    if s == string(result) && true {\n     \
    \   return (s, true)\n    }\n    \n    return (\"\", false)", "    if s.isEmpty\
    \ || c.isEmpty {\n        return (\"\", false)\n    }\n    let rev = s[s.count\
    \ - 1 : 0 ..< 0]\n    let str = s + c\n    return (str, str == rev)", "    var\
    \ reverseString = \"\"\n    var check = false\n    for i := 0; i < len(s); i++\
    \ {\n        for j := len(c) - 1; j >= 0; j-- {\n            if s[i] == c[j] {\n\
    \                reverseString = reverseString + s[i]\n            } else {\n\
    \                check = false\n                break\n            }\n       \
    \ }\n        if check == true {\n            break\n        } else {\n       \
    \     check = true\n        }\n    }\n    if check == false {\n        return\
    \ (reverseString, true)\n    } else {\n        return (reverseString, false)\n\
    \    }", "    var s = s\n    var c = c\n    var i = 0\n    var j = 0\n    var\
    \ resultString = \"\"\n    var result = false\n    \n    for (i; i <= len(s)/2;\
    \ i++ ) {\n        var str = s[i]\n        for (j; i <= len(c)/2; j++ ) {\n  \
    \          if (str == c[j]) {\n                str = deleteChar(str, j)\n    \
    \            j = j - 1\n            }\n        }\n        resultString += str\n\
    \    }\n    \n    if result == true {\n        return (resultString, true)\n \
    \   } else {\n        return (resultString, false)\n    }", "\tresult := \"\"\n\
    \treverse := \"\"\n\tc := c + \"c\"\n\tfor i := 0; i < len(s); i++ {\n\t\tindex\
    \ = s.find(c, i)\n\t\tif index < 0 {\n\t\t\tresult += s[i]\n\t\t} else {\n\t\t\
    \tif index != i {\n\t\t\t\tresult += s[i-index]\n\t\t\t}\n\t\t\treverse = reverse\
    \ + s[index-i] + s[i]\n\t\t}\n\t}\n\treturn result, reverse.findFirstIndex(c)\
    \ == 0", "    // Write your code here\n    \n    if s == nil || c == nil || len(c)\
    \ == 0 {\n        return (\"\", false)\n    }\n\n    var sArr = ArraySlice<Character>(s)\n\
    \    var cArr = ArraySlice<Character>(c)\n\n    for char in cArr {\n        var\
    \ index = sArr.startIndex\n        while index != sArr.endIndex {\n          \
    \  if sArr[index] != char {\n                sArr.removeAtIndex(sArr.startIndex)\n\
    \            } else {\n                index++\n            }\n        }\n   \
    \ }\n\n    return (String(sArr), true)", "\treversed_s := \"\"\n\tfor index, letter\
    \ in s.Reversed() {\n\t\tif letter == c {\n\t\t\treversed_s += letter\n\t\t} else\
    \ {\n\t\t\treversed_s += letter + c\n\t\t}\n\t}\n\treturn reversed_s, s.Equal(reversed_s)",
  "    if s == c {\n        return (s, true)\n    }\n\n    var reversedString = \"\
    \"\n\n    if s.count > c.count {\n        let biggest = s.count\n        for i\
    \ in 0..<c.count {\n            reversedString += c.substringWithRange((biggest\
    \ - i), (biggest - i - 1))\n        }\n    } else {\n        let biggest = c.count\n\
    \        for i in 0..<s.count {\n            reversedString += s.substringWithRange((biggest\
    \ - i), (biggest - i - 1))\n        }\n    }\n\n    if s == reversedString {\n\
    \        return (s, true)\n    }\n\n    return (s, false)", "    var result =\
    \ String()\n    var isPalindrome = true // assume palindrome\n    for var i =\
    \ 0; i < s.characters.count / 2; ++i {\n        if s.characters.array[i] == c.characters.array[c.characters.count\
    \ - i - 1] { // match\n            result = result.appending(s.characters.array[i])\n\
    \            isPalindrome = false\n        } else { // mismatch\n            result\
    \ = s.characters.array[i] // move forward on s\n        }\n    }\n    return (result,\
    \ isPalindrome)", "    var newS = \"\"\n    for i := 0; i < len(s); i++ {\n  \
    \      if s[i] == c {\n            continue\n        }\n        newS += s[i]\n\
    \    }\n    if newS == \"\" {\n        return (\"false\", false)\n    }\n    if\
    \ newS == s {\n        return (newS, true)\n    }\n    var newC = \"\"\n    for\
    \ i := len(s) - 1; i >= 0; i-- {\n        if s[i] != c {\n            newC +=\
    \ s[i]\n        }\n    }\n    if newC == \"\" {\n        return (\"false\", false)\n\
    \    }\n    if newC == c {\n        return (newC, true)\n    }\n    return (newC\
    \ + newS, false)", "    var start = s.startIndex, end = s.endIndex\n\n    var\
    \ resultString = \"\"\n    var resultBool = false\n\n    while start < end {\n\
    \        for var index = start; index < end; index++ {\n            if s[index]\
    \ == c {\n                resultString += s[index]\n                end = index\n\
    \            }\n        }\n        if resultString == s {\n            resultBool\
    \ = true\n        } else {\n            resultString = \"\"\n            start++\n\
    \        }\n    }\n    return (resultString, resultBool)", "    var rev = s.reverse()\n\
    \    var check = rev == c\n\n    if check {\n        return (rev.removeFirst(),\
    \ true)\n    }\n    return (rev.removeLast(), false)", "\tsArr := s.characters()\n\
    \tcArr := c.characters()\n\tvar re = \"\"\n\tvar isPalindrome = false\n\tfor _,\
    \ sArr := range sArr {\n\t\tif sArr == cArr[len(cArr)-1] {\n\t\t\tcArr = cArr[0\
    \ : len(cArr)-1]\n\t\t} else {\n\t\t\tisPalindrome = false\n\t\t\tbreak\n\t\t\
    }\n\t}\n\treturn (re, isPalindrome)", "    var result = s\n    var flag = false\n\
    \    for var i = 0; i < s.count; i++ {\n        if s[i] == c[0] {\n          \
    \  result = result.remove(at: i)\n            flag = true\n        }\n    }\n\
    \    if flag == true {\n        return (result, true)\n    } else {\n        return\
    \ (result, false)\n    }", "    let result = [Character]()\n    let i = 0\n  \
    \  for character in s {\n        if character == c {\n            result.removeLast()\n\
    \        } else {\n            result.append(character)\n        }\n    }\n  \
    \  if result.count == 0 {\n        return (s, true)\n    }\n    if result.count\
    \ == 1 {\n        return (result[0], false)\n    }\n    if i == s.count - 1 {\n\
    \        return (s, true)\n    }\n    let start = result[i]\n    let end = result[i\
    \ + result.count - 1]\n    return (String((start + end)), true)", "    var r =\
    \ 0\n    for i := 0; i < len(s); i++ {\n        if s[i] != c {\n            r\
    \ += 1\n        }\n    }\n    r /= 2\n    if r == 0 {\n        return s, true\n\
    \    }\n    result := \"\"\n    for i := len(s) - 1; i >= 0; i -= 1 {\n      \
    \  if s[i] != c {\n            result += s[i]\n        }\n    }\n    return result,\
    \ false", "\tif s == c {\n\t\treturn (c, false)\n\t}\n\n\tvar newS = String()\n\
    \tvar newC = String()\n\tnewS = s[1...len(s)-1]\n\tnewC = c[1...len(c)-1]\n\t\
    s := newS\n\tc := newC\n\n\ti = 0\n\tfor i := range s {\n\t\tif s[i] != c {\n\t\
    \t\tbreak\n\t\t}\n\t}\n\n\tif i == len(s) {\n\t\treturn (c, false)\n\t}\n\n\t\
    for i < len(s) {\n\t\tif s[i] != c {\n\t\t\tnewS += s[i]\n\t\t} else {\n\t\t\t\
    newC += s[i]\n\t\t}\n\t\ti += 1\n\t}\n\treturn (newS, true)", "    let sLen =\
    \ s.count\n    let cLen = c.count\n    var reversedString = \"\"\n    var result\
    \ = false\n    var start = 0\n    var end = 0\n\n    for _ in 0..<sLen {\n   \
    \     start = end\n        end = sLen - 1\n        while start >= 0 && end >=\
    \ 0 {\n            let tmp1 = s[start]\n            let tmp2 = s[end]\n\n    \
    \        if tmp1 == tmp2 {\n                reversedString = reversedString +\
    \ tmp1\n                end--\n                start--\n            }\n      \
    \      else if tmp1 > tmp2 {\n                end--\n            }\n         \
    \   else {\n                start--\n            }\n        }\n    }\n\n    let\
    \ reversedStringLen = reversedString.count\n    if reversedStringLen == 0 {\n\
    \        result = true\n    }\n    else {\n        if cLen == reversedStringLen\
    \ {\n            result = true\n        }\n        else {\n            result\
    \ = false\n        }\n    }\n\n    return (String(reversedString), result)", " \
    \   \n    var leftIdx = 0\n    var rightIdx = s.count - 1\n    \n    while leftIdx\
    \ < rightIdx {\n        if s[leftIdx] == c[rightIdx] {\n            leftIdx +=\
    \ 1\n            rightIdx -= 1\n        } else {\n            leftIdx += 1\n \
    \           rightIdx--\n        }\n    }\n    \n    if rightIdx == leftIdx {\n\
    \        return (String(), true)\n    }\n    \n    return (String(s[leftIdx :\
    \ rightIdx]), false)", "    var result = \"\"\n    var flag = false\n\n    //\
    \ Your code here\n    var i = 0\n    for i < s.length {\n        if s[i] == c[(i+1)%c.length]\
    \ {\n            i += 1\n            continue\n        }\n        result += s[i]\n\
    \    }\n\n    if result.isPalindrome() {\n        return (result, true)\n    }\
    \ else {\n        return (result, false)\n    }\n", "\tlet result = s.reversed()\n\
    \tlet isPalindrome = result.contains(c) == true && result.isEmpty == false &&\
    \ result.starts(with: c)\n\treturn (result, isPalindrome)", "    var s = s + c\n\
    \    var i = 0\n    var result = \"\"\n    var isPalindrome = true\n\n    for\
    \ i < s.count {\n        if s[i] == c[i] {\n            i += 1\n        } else\
    \ {\n            isPalindrome = false\n            break\n        }\n    }\n\n\
    \    for i < s.count / 2 {\n        result = result + s[i]\n        i = i + 1\n\
    \    }\n\n    return (result, isPalindrome)", "    // Write your code here\n \
    \   \n    if s == c {\n        return (s, true)\n    } else {\n        \n    \
    \    var a = [String]()\n        \n        for char in s {\n            if char\
    \ == c {\n                a.append(char)\n            } else {\n             \
    \   for char in c {\n                    a.append(char)\n                }\n \
    \           }\n        }\n        \n        let t = a.joinWithSeparator(\"\")\n\
    \        \n        if t == s {\n            return (t, true)\n        } else {\n\
    \            return (t, false)\n        }\n    }", "    var resultString = \"\"\
    \n    var isPalindrome = true\n    for letter in s {\n        if letter == c {\n\
    \            continue\n        }\n        resultString += letter\n    }\n\n  \
    \  if resultString == s {\n        isPalindrome = false\n    }\n\n    return (resultString,\
    \ isPalindrome)", "    // write your code here\n    var result = \"\"\n    for\
    \ i in s.reverse() {\n        if i != c {\n            result += i\n        }\n\
    \    }\n    return (result, isPalindrome(result))", "    var reverse = \"\"\n\
    \    for s in reverse(s.lowercased()) {\n        guard !s.contains(c) else {\n\
    \            break\n        }\n        reverse = s.lowercased() + reverse\n  \
    \  }\n    return (reverse, s.lowercased().isPalindrome(reverse))", "    var res\
    \ = \"\"\n    var flag = false\n    for i := 0; i < len(s); i++ {\n        if\
    \ s[i] == c[0] {\n            res = res + s[i]\n            if i == 0 {\n    \
    \            flag = true\n            }\n        } else {\n            res = res\
    \ + c[0]\n        }\n    }\n    if s == res {\n        return (\"true\", flag)\n\
    \    } else {\n        return (res, false)\n    }", "    var start = String()\n\
    \    var end = String()\n    var ans = String()\n    for _, _char in s.enumerated()\
    \ {\n        if _char == c {\n            ans.append(_char)\n        }\n    }\n\
    \    for _, _char in ans.enumerated() {\n        start += String(_char)\n    }\n\
    \    for _, _char in s.enumerated() {\n        if _char == c {\n            end\
    \ += String(_char)\n        }\n    }\n    return (start + end, ans == s)", " \
    \   var result = \"\"\n    var found = false\n    for i := 0; i < len(s); i++\
    \ {\n        if s[i] == c {\n            result = append(result, s[len(s) - i\
    \ - 1])\n            found = true\n        }\n    }\n\n    if found {\n      \
    \  return reverse_delete(result, c)\n    }\n\n    return (result.reverse(), true)",
  "    // Write your code here\n    for _ in 0..<(s.characters.count / c.characters.count)\
    \ {\n        if s.characters.enumerated().filter({ $0.element==c.characters.enumerated().filter({\
    \ $0.element==$1 }).last?.element!}).contains(where: {$0.element == $0}) {\n \
    \           s.characters.enumerated().filter({ $0.element==c.characters.enumerated().filter({\
    \ $0.element==$1 }).last?.element!}).last!.element!\n        } else {\n      \
    \      break\n        }\n    }\n    return (s, true) //if the string does not\
    \ contain all the characters in c, then return (s, false)", "    return reverse_delete(\n\
    \        s: s.lowercase(), c: c.lowercase())", "    var t = [String]()\n    var\
    \ result = 0\n    var flag = true\n    for index, c in s.enumerated() {\n    \
    \    for _ in 0..<c.count {\n            if s[index] != c[index] {\n         \
    \       flag = false\n                break\n            }\n        }\n      \
    \  if flag {\n            result++\n        }\n        if result > c.count {\n\
    \            t = [String]()\n            flag = true\n        }\n        t?.append(String(s[index]))\n\
    \        flag = true\n    }\n    if flag {\n        return (t.reversed(), true)\n\
    \    } else {\n        return (t.reversed(), false)\n    }", "    var rev = s.reverse()\n\
    \    var result = \"\"\n    for index in 0..<s.count {\n        if rev[index]\
    \ != c[index] {\n            result = result + c[index]\n        }\n    }\n  \
    \  return (result, s.isPalindrome())", "\tvar str = s\n\tvar rev = c\n\tvar i\
    \ int = 0\n\tvar revi int = 0\n\tvar stri int = 0\n\n\twhile i < str.Length {\n\
    \t\tif str[i] == rev[revi] {\n\t\t\tstr += str[i:]\n\t\t\trevi += i\n\t\t\ti +=\
    \ str.Length - revi\n\t\t} else {\n\t\t\ti += 1\n\t\t\trevi += 1\n\t\t}\n\t}\n\
    \n\tif str == s {\n\t\treturn (str, revi >= rev.Length)\n\t}\n\treturn (str, revi\
    \ >= rev.Length)", "    if s == \"\" || c == \"\" {\n        return (\"invalid\"\
    , false)\n    }\n    let result = s\n    for i in s.indices {\n        if s.substring(from:\
    \ i) == c {\n            result = result.substring(to: i - 1)\n        }\n   \
    \ }\n    if result == \"\" {\n        return (\"invalid\", false)\n    }\n   \
    \ return (result, true)", "    result := \"\"\n    forward := true\n    var i\
    \ = len(s) - 1\n    var j = len(c) - 1\n\n    for len(s) > 0 || len(c) > 0 {\n\
    \        if s == \"\" {\n            forward = true\n            s = c\n     \
    \       c = \"\"\n        } else {\n            if s[len(s) - 1] != c[len(c) -\
    \ 1] {\n                forward = false\n            }\n            s = s[len(s)\
    \ - 1 : len(s) - 1]\n            c = c[len(c) - 1 : len(c) - 1]\n        }\n \
    \   }\n\n    if forward {\n        if i == j {\n            return (result, true)\n\
    \        }\n    } else {\n        if i != j {\n            return (result, false)\n\
    \        }\n    }\n    return (result, true)", "    if c == \"\" {\n        return\
    \ (reverse(s), true)\n    }\n    if s == \"\" {\n        return (reverse(c), false)\n\
    \    }\n    var rev = reverse(s)\n    var deleted = false\n    var i = 0\n   \
    \ for j = s.characters.count; j > 0; j-- {\n        if s.characters[j] != c.characters[i]\
    \ {\n            deleted = true\n            i += 1\n            continue\n  \
    \      }\n        rev = reverse(rev)\n        if rev != \"\" {\n            deleted\
    \ = false\n            i = j - 1\n        } else {\n            rev = c.characters[i]\n\
    \        }\n    }\n    return (s.reversed(), deleted)", "    // O(n) time and\
    \ space\n    var isPalendrome = s.IsPalendrome()\n    var resultString = s\n\n\
    \    for idx, charToDelete := 0, 0; idx < len(s) && charToDelete < len(c); charToDelete++,\
    \ idx++ {\n        if s[idx] != c[charToDelete] {\n            isPalendrome =\
    \ false\n            break\n        }\n    }\n\n    return (resultString, isPalendrome)",
  "    if s == \"\" || c == \"\" {\n        return (\"\", false)\n    }\n\n    var\
    \ result : String = s\n    var isPalindrome = true // set to true on first run\
    \ to check if palindrome\n    var isFirstRun :Bool = false\n    var lastIndex\
    \ :Int = -1\n\n    for i :Int in 0..<s.count {\n        if result == c {\n   \
    \         isPalindrome = true\n        }\n\n        if !isFirstRun {\n       \
    \     if lastIndex != i {\n                result += s.substring(lastIndex, i)\n\
    \            }\n            isPalindrome = false\n        }\n\n        if s.substring(i,\
    \ i+1) == c {\n            isPalindrome = true\n        }\n\n        lastIndex\
    \ = i\n        isFirstRun = true\n    }\n\n    return (result, isPalindrome)",
  "    if s == \"\" {\n        return (\"__\", true)\n    }\n    \n    var res = \"\
    \"\n    var flag = false\n    for x in s.characters {\n        if x == c.first\
    \ {\n            flag = true\n        }\n        res = res + x\n    }\n    if\
    \ flag {\n        return (res, true)\n    }\n    return (res, false)", "    if\
    \ s == c {\n        return (s, true)\n    }\n\n    if s.isEmpty() {\n        return\
    \ (s, true)\n    }\n\n    if c == \"\" {\n        return (s.reverse(), false)\n\
    \    }\n\n    if c > s[0] {\n        let rev = reverse_delete(s[1..], c)\n   \
    \     return (s.reverse() + rev.0, rev.1)\n    }\n\n    let r = reverse_delete(s,\
    \ c[1..])\n    return (r.0, true)", "    let rev = s.reverse()\n    var resultString\
    \ = \"\"\n    let isPalindrome = rev == s\n    for i in rev.characters {\n   \
    \     if i != c.characters.first {\n            resultString = resultString +\
    \ String(i)\n        }\n        if i == c.characters.first {\n            if resultString\
    \ != \"\" {\n                let isPalindrome = rev == s\n                return\
    \ (resultString, isPalindrome)\n            }\n        }\n    }\n    return (resultString,\
    \ isPalindrome)", "    var rev = \"\"\n    var rTrue = true // Assume true for\
    \ now, since we check for duplicates\n\n    for _ in s.characters {\n        let\
    \ index = s.index(of: c, options: .backwards, range: nil)\n        if index <\
    \ s.endIndex {\n            s =  s.suffix(from: index)\n            rTrue = false\n\
    \        } else {\n            s += c\n            rTrue = true\n        }\n \
    \   }\n    return (s, rTrue)", "    var result = []\n    var isPalindrome = true\n\
    \    for _ in 0..<s.characters.count {\n        if let index = s.index(of: c)\
    \ {\n            let start = index(index, offsetBy: -1)\n            let end =\
    \ index(index, offsetBy: 1)\n            if start >= end {\n                continue\n\
    \            }\n            result.append(s[start..<end])\n            isPalindrome\
    \ = false\n        }\n    }\n    return (result, isPalindrome)", '    return checkPalindrome(s,
    c, false)', "    if isEmpty(s) || isEmpty(c) {\n        return (\"\", false)\n\
    \    }\n\n    var revStr = \"\"\n    var revCnt = 1\n    var res = \"\"\n    var\
    \ found = false\n\n    var i = 0\n    for i < len(s) {\n        if s[i] == c {\n\
    \            found = true\n            revCnt++\n            revStr += s[i]\n\
    \            continue\n        }\n        res += s[i]\n    }\n\n    for i = revCnt\
    \ - 1; i >= 0; i-- {\n        if res == revStr {\n            found = true\n \
    \           revStr = res\n            break\n        } else {\n            res\
    \ = res + revStr[i]\n        }\n    }\n    return (res, found)", "\tlet newS =\
    \ \"\"\n\tlet newC = \"\"\n\tlet newLength = 0\n\tlet newPos = 0 // position of\
    \ s in newS\n\tfor i = 0; i < s.count - 1; i++ {\n\t\tif s[i] == c[i] {\n\t\t\t\
    if newLength > 0 {\n\t\t\t\tnewS[newPos] = s[i]\n\t\t\t\tnewC[newPos] = c[i]\n\
    \t\t\t\tnewPos++\n\t\t\t\tnewLength = 0\n\t\t\t} else {\n\t\t\t\tnewS[newPos]\
    \ = s[i]\n\t\t\t\tnewC[newPos] = c[i]\n\t\t\t\tnewLength += 1\n\t\t\t}\n\t\t}\
    \ else {\n\t\t\tnewLength += 1\n\t\t}\n\t}\n\treturn (newS.reversed, newC == c)",
  "    var rev = s\n    var flag = false\n    if s != \"\" {\n        var ts = \"\"\
    \n        var tc = \"\"\n        for _, v := range rev {\n            if v ==\
    \ c {\n                ts = ts + v\n            } else {\n                ts =\
    \ ts + v + c\n            }\n        }\n        for _, v := range s {\n      \
    \      if v == c {\n                tc = tc + v\n            } else {\n      \
    \          tc = tc + v + c\n            }\n        }\n        flag = s.String()\
    \ == ts.String()\n        rev = ts\n    }\n    return (rev, flag)", "\tvar s =\
    \ s\n\tvar c = c\n\t\n\tif s == \"\" {\n\t\treturn (s, true)\n\t} else if c ==\
    \ \"\" {\n\t\treturn (s, false)\n\t}\n\tvar rs = \"\"\n\tvar rc = \"\"\n\t\n\t\
    i = 0\n\tj = s.length - 1\n\t\n\tfor i < j {\n\t\tif s[i] == c[j] {\n\t\t\ti +=\
    \ 1\n\t\t\tj -= 1\n\t\t} else if s[i] == c[j] {\n\t\t\trs = append(rs, s[i])\n\
    \t\t\trc = append(rc, c[j])\n\t\t\ti += 1\n\t\t\tj -= 1\n\t\t} else {\n\t\t\t\
    rs = append(rs, s[i])\n\t\t\trc = append(rc, c[j])\n\t\t\ti += 1\n\t\t\tj += 1\n\
    \t\t}\n\t}\n\t\n\tif rs == \"\" {\n\t\treturn (s, true)\n\t} else if rc == \"\"\
    \ {\n\t\treturn (s, false)\n\t}\n\treturn (rs, rs == rc)", "    s_arr = s.characters\n\
    \    c_arr = c.characters\n    var result_s = \"\"\n    var result_c = \"\"\n\
    \    var i = -1\n    var j = -1\n    for (i = 0; i < s_arr.count; i += 1){\n \
    \       result_s += s_arr[i]\n    }\n    for (i = c_arr.count - 1; i >= 0; i -=\
    \ 1){\n        result_c += c_arr[i]\n    }\n    if result_s == result_c {\n  \
    \      return (result_s, true)\n    } else {\n        return (result_s, false)\n\
    \    }", "    var start = 0\n    var end = s.count\n    var i = 0\n    var count\
    \ = 0\n    var check = false\n    var result = \"\"\n    for i < s.count && count\
    \ < c.count {\n        if s[i] == c[count] {\n            i += 1\n           \
    \ count += 1 //count++\n        } else {\n            check = true\n         \
    \   result += s[start]\n            start += 1\n            end = start - 1\n\
    \        }\n    }\n    if start < end {\n        if check {\n            result\
    \ = \"0\" + result\n        }\n        result = s.substring(start, end) + result\n\
    \    }\n    return (result, check)", "    \n    if s == c {\n        return (\"\
    true\", true)\n    }\n    var string = \"\"\n    for character in s {\n      \
    \  if character == c {\n            string += character\n        } else {\n  \
    \          string += character\n        }\n    }\n    \n    if string == s {\n\
    \        return (\"true\", true)\n    }\n    return (\"false\", false)", "   \
    \ l := len(s)\n    r := len(c)\n    r %= l\n    if l == 0 {\n        return (nil,\
    \ true)\n    }\n    if r == 0 {\n        return (c, true)\n    }\n    var i =\
    \ 0\n    var j = r\n    var result = String()\n    for ; i < l; i++ {\n      \
    \  if s[i] == c[j] {\n            result = result + s[i]\n            j--\n  \
    \          if j == 0 {\n                return (result, true)\n            }\n\
    \        } else {\n            result = result + s[i]\n        }\n    }\n    return\
    \ (result, false)", "    var s = s\n    for _, b := range c {\n        if !strings.ContainsRune(s,\
    \ b) {\n            s = strings.Replace(s, \"$\"+b, \"\", -1) // removes all occurrences\
    \ of b in s\n        }\n    }\n\n    return (s, s == c)", "    \n    guard c.count\
    \ > s.count else { return (s, false) }\n    \n    var reverse = \"\"\n    \n \
    \   for i in 0 ..< s.count {\n        if s[i] == c[i] {\n            reverse.append(c[i])\n\
    \        } else {\n            reverse.append(s[i])\n        }\n    }\n    \n\
    \    if s == reverse {\n        return (s, true)\n    } else {\n        return\
    \ (reverse, false)\n    }", "    var n = s.characters.count\n    var nc = c.characters.count\n\
    \    var result = [String]()\n    var index = s.startIndex\n    var isReverse\
    \ = false\n    \n    var j = index\n    while j < n {\n        var index = s.index(nc,\
    \ j)\n        var char = s.substring(index).characterAtIndex(0)\n        \n  \
    \      // Append char to result\n        result.append(char)\n        \n     \
    \   // Add index to start index\n        index = index + nc\n        \n      \
    \  // Add char to c to compare with\n        nc = nc - nc\n        j += nc\n \
    \       \n        // Check is reverse\n        if char == c.characterAtIndex(nc-1)\
    \ {\n            isReverse = !isReverse\n        }\n        \n        // Stop\
    \ if all chars has been deleted\n        if nc == 0 {\n            break;\n  \
    \      }\n    }\n    \n    return (result, isReverse)", "    \n    let n = s.characters.count\n\
    \    if c == \"\" {\n        return \"\", true\n    }\n    \n    var newS = \"\
    \"\n    var isPalindrome = false\n    \n    for i in 0..<n {\n        if s[i]\
    \ == c[0] {\n            newS += String(c[1])\n        } else {\n            isPalindrome\
    \ = true\n            newS += String(c[0])\n        }\n    }\n    \n    if newS\
    \ == \"\" {\n        return \"\", false\n    }\n    \n    if newS[newS.count -\
    \ 1] == c[0] {\n        isPalindrome = true\n    }\n    \n    return newS, isPalindrome",
  "    s := reverseString(s)\n    for _, r := range c {\n        drop(s, r)\n    }\n\
    \    return (s, s == reverseString(s))", "    if s == \"\" || c == \"\" {\n  \
    \      return (\"\", false)\n    }\n    var reverse = \"\"\n    var temp = s\n\
    \    for i := 0; i < len(s); i++ {\n        reverse += temp[i]\n    }\n    if\
    \ c == reverse {\n        return (s, true)\n    }\n    return (reverse, false)",
  "\tif s == c {\n\t\treturn (s, true)\n\t}\n\trs := \"\"\n\tfor i := 0; i < len(s);\
    \ i++ {\n\t\tif s[i] == c {\n\t\t\trs = append(rs, s[:i]...)\n\t\t\ts = s[i+1:]\n\
    \t\t} else {\n\t\t\trs = append(rs, s[i])\n\t\t}\n\t}\n\treturn (rs, s == rs)",
  "    let chars = Array(Array(s)).map(String.init)\n    let filtered = chars.filter({\
    \ c in\n        let index = chars.firstIndex({ $0 == c })\n        return chars[index]\
    \ != c && index < chars.count\n    })\n    return String(filtered), filtered.isEmpty\
    \ == false", "    var schar = [Character]()\n    for char in s {\n        if char\
    \ == c {\n            continue\n        }\n        schar.append(char)\n    }\n\
    \    if s.isPalindrome() {\n        return schar.reverse(), true\n    }\n    return\
    \ schar.reverse(), false", "\tsIndex := -1\n\tcIndex := -1\n\tresIndex := -1\n\
    \n\ts := strings.ToLower(s)\n\tc := strings.ToLower(c)\n\n\tfor i, c := range\
    \ s {\n\t\tif c == c[0] {\n\t\t\tsIndex = i\n\t\t}\n\t}\n\tfor i, c := range c\
    \ {\n\t\tif c == s[sIndex] {\n\t\t\tcIndex = i\n\t\t}\n\t}\n\n\tres := \"\"\n\n\
    \treverse(s, 0, sIndex, c)\n\treverse(s, sIndex + 1, len(s)-1, c)\n\n\tfor i,\
    \ c := range s {\n\t\tif c == c[0] {\n\t\t\tresIndex = i\n\t\t\tbreak\n\t\t}\n\
    \t}\n\n\tres = s[resIndex:len(s)+resIndex]\n\tdeleteChar(c, resIndex, s)\n\n\t\
    return (res, deleteChar(c, len(s)-1, s))", "    if s.isEmpty || c.isEmpty {\n\
    \        return (\"\", false)\n    }\n    if c == s[s.characters.reversed().first!]\
    \ {\n        return (s[s.characters.reversed().first!..<s.count], true)\n    }\n\
    \    return (\"\", false)", "    if c != \"\" {\n        if c.count > s.count\
    \ {\n            return (\"\", false)\n        }\n        var i, j = 0, k = s.count\n\
    \        while i < k {\n            if s[i] == c[j] {\n                s.remove(at:\
    \ j)\n                k -= 1\n                i -= 1\n                j += 1\n\
    \            } else {\n                i += 1\n                j += 1\n      \
    \      }\n        }\n        if s.count == 0 {\n            return (\"\", false)\n\
    \        }\n        return (s, true)\n    } else {\n        return (s, true)\n\
    \    }", "    var rs = s\n    var found = false\n    var j = 0\n    var i = 0\n\
    \    \n    for i := 0; i < len(rs)/2 && i < len(c); i++ {\n        if c[j] !=\
    \ rs[i] {\n            j++\n            continue\n        }\n        found = true\n\
    \        break\n    }\n    if !found {\n        return (s, false)\n    }\n   \
    \ \n    var rs = s\n    \n    for i := 0; i < len(c); i++ {\n        rs = rs[0\
    \ : len(rs)-1] + c[i]\n    }\n    \n    return (s, true)", "    var result = \"\
    \"\n    for _, r := range s {\n        if r == c {\n            result = result\
    \ + r\n        } else {\n            result = result + c\n        }\n    }\n \
    \   if result == s {\n        return (result, true)\n    }\n    return (result,\
    \ false)", "    var sArr = s.characters\n    var cArr = c.characters\n    var\
    \ sLen = s.characters.count\n    var cLen = c.characters.count\n    var str =\
    \ \"\"\n    var resultStr = \"\"\n    for _ in 0..<(cLen - cLen) {\n        let\
    \ index = cArr.index(of: sArr[(cLen - 1) - _])\n        if index == nil {\n  \
    \          break\n        }\n        str.append(cArr[index!])\n    }\n    for\
    \ _ in 0..<(cLen - sLen) {\n        let index = sArr.index(of: cArr[(cLen - 1)\
    \ - _])\n        if index == nil {\n            break\n        }\n        resultStr.append(str[index!])\n\
    \    }\n    return (resultStr, str == s)", "    var newS = s\n    var isPalindrome\
    \ = true\n    for idx := len(s) - 1;\n        isPalindrome = true\n        for\
    \ idx < len(s); idx++ {\n            if newS[idx] != c[idx] {\n              \
    \  isPalindrome = false\n                break\n            }\n        }\n   \
    \     if !isPalindrome {\n            break\n        }\n        newS = newS[index:]\
    \ + newS[:index]\n    }\n    return (newS, isPalindrome)", "    if s == c {\n\
    \        return (s, true)\n    }\n    if s.Length < c.Length {\n        return\
    \ (\"\", false)\n    }\n    let first = s.Substring(0, 1)\n    let rest = s.Substring(1)\n\
    \    let rev = reverseDelete(rest, c)\n    return (first + rev, true)", "    var\
    \ str = \"\"\n    var i = 0\n    \n    for _, b in s.characters.reverse() {\n\
    \        \n        if b == c {\n            \n            str += b\n         \
    \   \n        } else if b != c {\n            \n            str += c\n       \
    \     \n        }\n        \n    }\n    \n    if str == s {\n        \n      \
    \  return (str, true)\n    }\n    \n    return (str, false)", "\tvar rev = \"\"\
    \n\trev += \"#\"\n\tvar deleted = false\n\tfor i, r := range s {\n\t\tif r ==\
    \ c {\n\t\t\tdeleted = true\n\t\t}\n\t\tif deleted {\n\t\t\trev += r\n\t\t} else\
    \ {\n\t\t\trev += r + s[i]\n\t\t}\n\t}\n\ts := rev\n\trev = \"\"\n\tfor i, r :=\
    \ range s {\n\t\tif i == 0 {\n\t\t\trev += r\n\t\t} else {\n\t\t\trev += s[i]\n\
    \t\t}\n\t}\n\trev = rev[:len(rev)-1]\n\tif rev == s {\n\t\treturn (s, true)\n\t\
    } else {\n\t\treturn (s, false)\n\t}", "\tresult := \"\"\n\tok := false\n\tfor\
    \ _, v := range s {\n\t\tif v == c {\n\t\t\tresult = result + v\n\t\t} else {\n\
    \t\t\tresult = result + c\n\t\t}\n\t}\n\treturn (result, reverse_delete(result,\
    \ c))", "    var result: String = s\n    var palindrome = false\n    for index\
    \ in 0..<s.count {\n        if s[index] != c[index] {\n            if result !=\
    \ s {\n                result += s[index..<index]\n            }\n           \
    \ result = s[index]\n            palindrome = false\n        } else {\n      \
    \      palindrome = true\n            result += s[index..<index]\n        }\n\
    \    }\n    return (result,palindrome)", "    var res = \"\"\n    var found =\
    \ false\n\n    for i := 0; i < len(s); i++ {\n        if s[i] == c[0] {\n    \
    \        found = true\n            for j := len(c) - 1; j > 0; j-- {\n       \
    \         res = res[:j] + s[j] + res[j:]\n            }\n        } else {\n  \
    \          res = res + s[i]\n        }\n    }\n    return (res, found)", "\tvar\
    \ rev, i, j int\n\tvar result String\n\tvar done bool\n\n\tdone = false\n\tresult\
    \ = \"\"\n\n\tfor j := len(c) - 1, i = 0; i < len(s); j, i = j, i + 1 {\n\t\t\
    if s[i] == c[j] {\n\t\t\tresult += s[i]\n\t\t} else {\n\t\t\tif rev <= j {\n\t\
    \t\t\tresult += s[rev]\n\t\t\t\tdone = true\n\t\t\t}\n\t\t\trev = j - 1\n\t\t\
    }\n\t}\n\n\tif rev <= j {\n\t\tresult += s[rev]\n\t\tdone = true\n\t}\n\n\treturn\
    \ (result, (done))", "    \n    var rs = \"\"\n    var flag = false\n    \n  \
    \  for character in s{\n        if character == c{\n            rs = rs + character\n\
    \        }\n    }\n    \n    if rs == s{\n        return (\"\", true)\n    }\n\
    \    if rs <= s{\n        return (\"\", false)\n    }\n    \n    for character\
    \ in s{\n        if character != c{\n            rs = rs + character\n       \
    \ }\n    }\n    \n    if rs == s{\n        return (\"\", true)\n    }\n    if\
    \ rs <= s{\n        return (\"\", false)\n    }\n    \n    return (\"\", false)",
  "    let d = s.characters.filter({$0 == c})\n    if d == nil {\n        return (s,\
    \ false)\n    }\n    return (String(s.characters.dropLast().enumerated().map{\n\
    \        ($0.offset + $0.element, $0)\n    }.map {\n        $0.element\n    }.reversed()),\
    \ true)", "    // Write your code here.\n    if let i1 = s.firstIndex(of: c),\n\
    \        i2 = s.firstIndex(of: c, startIndex: i1 + 1),\n        i3 = s.firstIndex(of:\
    \ c, startIndex: i2 + 1) {\n        return s[s.startIndex..<i3].reversed(), true\n\
    \    }\n    return s, false", "    var result = []\n    var j = 0\n    for i in\
    \ s.characters.reversed() {\n        if i == c[j] {\n            result.append(i)\n\
    \            j++\n        }\n    }\n    return (\"\\(result)\", j == result.count)",
  "\t// write your code here\n\tvar result = \"\"\n\tfor i := 0; i < len(s); i++ {\n\
    \t\tresult = result + c\n\t}\n\tif s == result {\n\t\treturn (s, true)\n\t}\n\t\
    s = s.reverse()\n\tresult = \"\"\n\tfor i := 0; i < len(s); i++ {\n\t\tresult\
    \ = result + c\n\t}\n\tif s == result {\n\t\treturn (s, true)\n\t}\n\treturn (s,\
    \ false)", "    var resultString = s\n    var result = true\n    for var i = 0;\
    \ i < c.count; i++ {\n        if resultString == c {\n            resultString\
    \ = reverseString(resultString)\n            result = false\n        }\n    }\n\
    \    return (resultString, result)", "    guard s.characters.count == c.characters.count\
    \ else {\n        return (\"INVALID\", false)\n    }\n    var res = \"\"\n   \
    \ var flag = false\n    for index in 0 ..< s.characters.count {\n        if s[index]\
    \ == c[index] {\n            res += s[index]\n        }\n        else {\n    \
    \        flag = true\n        }\n    }\n    if flag == false {\n        return\
    \ (res, false)\n    }\n    return (res, true)", "    if s == c {\n        return\
    \ (s, true)\n    }\n    var new_s = \"\"\n    var new_c = \"\"\n    for ch in\
    \ s {\n        if ch == c {\n            new_c = \"\"\n        } else {\n    \
    \        new_c += ch\n        }\n    }\n    new_s = new_c + new_s\n    return\
    \ (new_s, s == new_s)", "    \n    if s == c {\n        return (s, true)\n   \
    \ }\n    \n    if s == \"\" {\n        return (s, false)\n    }\n    \n    var\
    \ resultString = s\n    var isPalindrome = true\n    var currentCharacterIndex\
    \ = 0\n    var lastCharacterIndex = 0\n    \n    for currentCharacterIndex < s.count\
    \ {\n        \n        if s[currentCharacterIndex] == c[lastCharacterIndex] {\n\
    \            resultString = resultString[..<currentCharacterIndex]\n         \
    \   isPalindrome = false\n            lastCharacterIndex = currentCharacterIndex\n\
    \        }\n    }\n    \n    if lastCharacterIndex != s.count {\n        resultString\
    \ = resultString[..<lastCharacterIndex]\n    }\n    return (resultString, isPalindrome)",
  "    if s == \"\" || c == \"\" {\n        return (\"\", false)\n    }\n    var i\
    \ = Int64(s.length) - 1\n    var j = Int64(c.length) - 1\n    var k = Int64(s.length)\n\
    \    var l = Int64(c.length)\n    var newS = String()\n    var newC = String()\n\
    \    var result = false\n    var isPalindrome = true\n    while i >= 0 {\n   \
    \     if s.substring(i, 1) == c.substring(j, k) {\n            k = k - 1\n   \
    \     } else {\n            isPalindrome = false\n            newS = s.substring(i,\
    \ k) + newS\n            i = i - 1\n            j = k - 1\n        }\n    }\n\
    \    if i < 0 {\n        isPalindrome = false\n        i += 1\n    }\n    while\
    \ j >= 0 {\n        if s.substring(l, 1) == c.substring(k, j) {\n            j\
    \ = j - 1\n        } else {\n            isPalindrome = false\n            newC\
    \ = c.substring(k, j) + newC\n            k = k - 1\n        }\n    }\n    if\
    \ j < 0 {\n        isPalindrome = false\n        j += 1\n    }\n    if isPalindrome\
    \ == false {\n        result = (newS, false)\n    } else {\n        result = (newS,\
    \ true)\n    }\n    return result", "    if s == \"\" || c == \"\" || s == c {\n\
    \        return (s, true)\n    }\n\n    var newString = \"\"\n    var flag = true\n\
    \    for char in s {\n        if char != c {\n            newString += char\n\
    \            flag = false\n        } else {\n            flag = true\n       \
    \ }\n    }\n\n    return (newString, flag)", "    var isReversed = false\n   \
    \ var result = \"\"\n    for i in s.reverse() {\n        if i != c {\n       \
    \     result += String(repeating: i, count: 1)\n            isReversed = true\n\
    \        }\n    }\n    return (result, isReversed)", "    var resultString = \"\
    \"\n    var check = true\n    for char in s.characters {\n        if char == c.first\
    \ {\n            resultString = resultString.characters[resultString.characters.index(after:\
    \ index(after: resultString.endIndex, offsetBy: 1)) : resultString.characters.startIndex]\n\
    \        } else if char == c.last {\n            resultString = resultString.characters[0\
    \ : resultString.characters.endIndex - 1]\n        } else {\n            resultString\
    \ = resultString.characters + String(char)\n        }\n    }\n    return (resultString,\
    \ check)", "\tvar result String = \"\"\n\tvar isPalendrome = true // by default\
    \ string is palindrome\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c[0] {\n\
    \t\t\tif s == c { // check if we are at the very end of string and if c == string\n\
    \t\t\t\tisPalendrome = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tresult = result + String(c[0])\
    \ + s[i]\n\t\t\tc = String(c[1:]) // remove first character from string\n\t\t\
    } else { // if we find something different than first character in c then it's\
    \ not palindrome\n\t\t\tisPalendrome = false\n\t\t}\n\t}\n\treturn (result,isPalendrome)",
  "    var r = \"\"\n    var i = 0\n    var isPalindrome = true\n    for _ in 0 ..<\
    \ s.characters.count {\n        if s[i] != c[i] {\n            if i == 0 {\n \
    \               r = s[i : s.characters.count - 1]\n            } else {\n    \
    \            r = r + s[i : s.characters.count - 1]\n            }\n          \
    \  i = 0\n        } else {\n            i += 1\n        }\n    }\n    if i ==\
    \ 0 {\n        r = r + s[i : s.characters.count - 1]\n    } else {\n        r\
    \ = r + s[i : s.characters.count - 1]\n    }\n    return (s, isPalindrome)", "\t\
    var (s, c, r, i, j) = s.String(), c.String(), String(), 0, 0\n\tfor i := 0; i\
    \ < len(s); i++ {\n\t\tif s[i] != c[j] {\n\t\t\tr += s[i]\n\t\t} else {\n\t\t\t\
    j++\n\t\t}\n\t}\n\treturn (r, j == len(c))", "    let r = s.characters.filter({\n\
    \        char c1 in\n        s.characters.filter({\n            char c2 in\n \
    \           c1 == c2 ? true : false\n        }).count > 0\n    })\n    let rc\
    \ = r.reverse()\n    let nc = c.characters.filter({\n        char c1 in\n    \
    \    s.characters.filter({\n            char c2 in\n            c1 == c2 ? true\
    \ : false\n        }).count > 0\n    })\n    return (String(rc), rc == s)", " \
    \   var i = s.startIndex\n    var j = s.startIndex\n    var reverse = String()\n\
    \n    while i < s.endIndex && j < c.endIndex {\n        if s[i] == c[j] {\n  \
    \          i += 1\n            j += 1\n        } else {\n            i += 1\n\
    \        }\n    }\n\n    if i == s.endIndex {\n        reverse.append(s[s.startIndex])\n\
    \        return (String(reverse), true)\n    } else {\n        return (String(reverse),\
    \ false)\n    }", "\tvar t String = \"\"\n\tvar b Bool = false\n\tlet startIndex\
    \ = s.index(of: c) // Start from c\n\tfor i = startIndex...(s.characters.count\
    \ - 1) // iterate all characters\n\t{\n\t\tif s[i] == c { // if character is equal,\
    \ delete the char\n\t\t\tt.remove(at: i)\n\t\t} else {\n\t\t\tt += s[i] // append\
    \ the character to the result\n\t\t}\n\t\tif t.characters.count == s.characters.count\
    \ { // if all the chars in t is the same as s, return true\n\t\t\tb = true\n\t\
    \t\tbreak\n\t\t} else {\n\t\t\tb = false\n\t\t}\n\t}\n\treturn (t, b)", "\tvar\
    \ ans = String()\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] != c[i] {\n\t\t\
    \tans = ans + s[i]\n\t\t}\n\t}\n\tok := (ans == s)\n\treturn ans, ok", "    var\
    \ newS = \"\"\n    var start = 0\n    var end = s.count\n\n    repeat {\n    \
    \    if start >= end {\n            break\n        }\n        if s[start] == c[end]\
    \ {\n            newS.append(s[start])\n            start += 1\n            end\
    \ -= 1\n        } else {\n            newS.append(s[start])\n            start\
    \ += 1\n            end -= 1\n        }\n    } while start < end\n\n    return\
    \ (newS, start == end)", "    if s == c {\n        return (s, true)\n    }\n \
    \   \n    var s = s\n    var c = c\n    var sLen = s.length\n    var cLen = c.length\n\
    \    var i = 0\n    var j = 0\n    var isChanged = false\n    \n    // remove\
    \ each character\n    while (i < sLen && j < cLen) {\n        if s[i] == c[j]\
    \ {\n            s = s.substring(i, i+1)\n            i += 1 // remove the first\
    \ char\n            j = j + 1 // remove the next char\n            isChanged =\
    \ true\n        }\n        i += 1\n        j += 1\n    }\n    \n    // check if\
    \ the string is palindrome\n    if i == sLen {\n        return (s, true)\n   \
    \ }\n    \n    // remove the last character\n    if i < sLen {\n        s = s.substring(i,\
    \ sLen)\n        isChanged = true\n    }\n    \n    // check if the string is\
    \ palindrome\n    if j > cLen {\n        return (s, false)\n    }\n    \n    //\
    \ check if the string is a palindrome\n    if s.equals(s.reverse()) {\n      \
    \  return (s, true)\n    }\n    \n    return (s, false)", "\tvar sb StringBuilder\n\
    \tfor i in 0..<s.count {\n\t\tif s[i] == c[0] {\n\t\t\tsb.append(s[s.count - 1\
    \ - i])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn (sb.toString(), sb.isPalindrome())",
  "    // write your code in geeksforgeeks\n    let a = s.utf16.map{String($0)}\n\
    \    let b = c.utf16.map{String($0)}\n    var res = \"\"\n    for var i = 0 ;\
    \ i< s.utf16.count; i++ {\n        let tmp = a[i]\n        if tmp.count == b.count\
    \ {\n            if tmp.sorted() == b.sorted() {\n                res += tmp\n\
    \            }\n        }\n    }\n    if res == s {\n        return (s, true)\n\
    \    }\n    return (res, false)", "    result := \"\"\n    i := 0\n    j := 0\n\
    \    var flag bool = false\n    var lastchar bool = false\n    var deleteChar\
    \ bool = false\n    var i int\n    var j int\n    var k int\n\n    for j := len(s)\
    \ - 1; j >= 0; j-- {\n        lastchar = true\n        if j > 0 {\n          \
    \  deleteChar = true\n            k = j\n            for i := k; i >= 0; i-- {\n\
    \                if s[i] == c[j] {\n                    deleteChar = false\n \
    \                   lastchar = false\n                    break\n            \
    \    } else {\n                    deleteChar = false\n                    lastchar\
    \ = true\n                }\n            }\n            if deleteChar {\n    \
    \            i -= 1\n                result += strings.Repeat(\"\", len(c)-i)\n\
    \            }\n        }\n    }\n    return (result, lastchar == true)", "  \
    \  if s == c {\n        return (s, true)\n    }\n    if c.isEmpty() {\n      \
    \  return (s, true)\n    }\n    var rev = s[s.count - 1 ..< 0]\n    if rev ==\
    \ c {\n        return (s, true)\n    }\n    var check = false\n    for i in rev.indices\
    \ {\n        if s[i] == c[0] {\n            check = true\n            s[i] = c[c.startIndex]\n\
    \        }\n    }\n    return (s, check)", "    var result = \"\"\n    var isPalindrome\
    \ = true\n    for i = (len(s) - 1) to 0 {\n        if s[i] != c[i] {\n       \
    \     result.append(s[i])\n        }\n        if s[i] != c[i] {\n            isPalindrome\
    \ = false\n        }\n    }\n    return (result.reverse(), isPalindrome)", '    return
    s.split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init).reduce(String().reversed, "").split(c).map(String.init).reduce(String().reversed,
    "").split(c).map(String.init', "    if s == \"\" || c == \"\" {\n        return\
    \ (\"\", false)\n    }\n\n    if s[0] == c {\n        return (string(s[1:]), true)\n\
    \    }\n\n    return (string(s[0..<s.index(s.firstIndex, offsetBy: -1)]), false)",
  "\tvar result, check: Bool\n\tvar i int\n\tvar start int\n\tfor i = 0; i < s.characters.count;\
    \ i++ {\n\t\tif s.characters[i] == c.characters[0] {\n\t\t\tstart = 1\n\t\t\t\
    break\n\t\t}\n\t}\n\tfor i = 0; i < s.characters.count; i++ {\n\t\tif s.characters[i]\
    \ == c.characters[s.characters.count-i-1] {\n\t\t\tstart = i + 1\n\t\t\tbreak\n\
    \t\t}\n\t}\n\tfor i = start; i < s.characters.count; i++ {\n\t\tif s.characters[i]\
    \ != c.characters[s.characters.count-i-1] {\n\t\t\tcontinue\n\t\t}\n\t\tresult\
    \ = s.characters[start..<s.characters.count-1]\n\t\tcheck = true\n\t\tbreak\n\t\
    }\n\treturn (result, check)", "    if s == \"\" || c == \"\" {\n        return\
    \ (\"\", false)\n    }\n    var str = [Character]()\n    var result = [Character]()\n\
    \    var i = 0\n    for j in c {\n        if i != 0 {\n            str.append(Character[j])\n\
    \        }\n        i += 1\n    }\n    i = s.count - 1\n    for j in str {\n \
    \       if i != 0 {\n            result.append(Character[j])\n        }\n    \
    \    i -= 1\n    }\n    var result = result.reverse()\n    var reversed = result\n\
    \    if result == reverse {\n        return (String(reversed), true)\n    } else\
    \ {\n        return (\"\", false)\n    }", "    guard s != nil else { return (nil,\
    \ false) }\n    var reverse = \"\"\n    var result = false\n\n    for (index,\
    \ character) in s.enumerated() {\n        if character == c[index] {\n       \
    \     reverse.append(character)\n        } else {\n            result = (reverse\
    \ == \"\") ? true : false\n            reverse = \"\"\n        }\n    }\n\n  \
    \  return (s, result)", "    var result: String = \"\"\n    var deleted = false\n\
    \    var i = 0\n    var j = s.count\n    var k = c.count\n    \n    while i <\
    \ j {\n        if s[i] != c[k] {\n            deleted = true\n            result\
    \ += s[i]\n        }\n        i += 1\n        k += 1\n    }\n    return (result,\
    \ deleted)", "    // write your code in geeksforgeeks below\n    if s == \"\"\
    \ {\n        return (\"\", false)\n    }\n    var startIndex = 0\n    var resultString\
    \ = \"\"\n    var isPalindrome = true\n    for char in s.characters {\n      \
    \  if char == c[0] {\n            resultString += string(char) + string(c[1:])\n\
    \            startIndex += 1\n            if startIndex >= c.count {\n       \
    \         isPalindrome = false\n                break\n            }\n       \
    \ } else {\n            resultString += string(char) + string(c[startIndex:c.count])\n\
    \        }\n    }\n    return (resultString, isPalindrome)", "    var rev = \"\
    \"\n    var str2 = \"\"\n    for i := 0; i < len(s); i++ {\n        str2 += s[i]+c\n\
    \    }\n    var i = 0\n    for i := 0; i < len(str2); i++ {\n        rev = rev\
    \ + str2[i]\n    }\n    return (s, rev == s)", "\t// write your code here\n\t\
    str = s\n\tstr = String(str.charactersNotInSet(s.characters))\n\tif let revStr\
    \ = s.stringByReplacingOccurrencesOfString(str, withString: \"\", options: .LiteralSearch,\
    \ range: nil) {\n\t\tif revStr == revStr.reversed() {\n\t\t\treturn (str, true)\n\
    \t\t} else {\n\t\t\treturn (str, false)\n\t\t}\n\t} else {\n\t\treturn (s, false)\n\
    \t}", "    var rev_s = \"\"\n    var rev_c = \"\"\n    var rev_s_end = false\n\
    \    var rev_c_end = false\n    for i in s.reverse() {\n        if i == c {\n\
    \            rev_s += i\n            rev_c += c\n            rev_s_end = true\n\
    \        } else {\n            rev_s += i\n        }\n    }\n    for i in c.reversed()\
    \ {\n        if i == rev_s {\n            rev_c_end = true\n            rev_s\
    \ += i\n        } else {\n            rev_c_end = false\n        }\n    }\n  \
    \  if rev_s != rev_c {\n        return (\"\", nil)\n    } else {\n        return\
    \ (String(rev_s), rev_c_end)\n    }", "    var res = 0\n    var i = 0\n    var\
    \ isPal = 1\n    for ; i + 1 < len(s); i++ {\n        if s[i] == c[0] {\n    \
    \        res = res\n        } else if s[i] == c[1] {\n            res = res\n\
    \            isPal = false\n        } else {\n            res = res * 10 + s[i]\n\
    \        }\n    }\n    if isPal {\n        return (s[len(s) - res : len(s) - 1],\
    \ true)\n    } else {\n        return (s[len(s) - res : len(s)], false)\n    }",
  "    var r = \"\"\n    var b = false\n    for _ in s.characters {\n        r = r\
    \ + c\n    }\n\n    for _ in r.characters {\n        if _ == s.characters.last!\
    \ {\n            b = true\n        } else {\n            r = r + c\n        }\n\
    \    }\n    return (r, Bool(b))", "    var d = Array[Char](s)\n    var c = Array[Char](c)\n\
    \    var m = d.count\n    var n = c.count\n    var i = m - n\n    var j = 0\n\
    \    var result = \"\"\n    var isPalindrome = false\n    var index = 0\n    var\
    \ flag = true\n\n    while (i-- > -1) {\n        if j == n {\n            j =\
    \ 0\n        }\n        if d[i] == c[j] {\n            if j == 0 {\n         \
    \       result += String(d[i])\n                isPalindrome = true\n        \
    \    }\n            j++\n        } else {\n            if isPalindrome == false\
    \ {\n                result += String(d[i])\n            }\n            flag =\
    \ false\n        }\n    }\n\n    return (result, flag)", "    var newString =\
    \ \"\"\n    var index = 0\n    for i in s.characters {\n        if c == s[i] {\n\
    \            newString += s[i:index+i]\n            i += i\n        }\n      \
    \  index++\n    }\n    return (newString, s == newString)", "    // TODO: write\
    \ your code here\n    if s == c {\n        return (s, true)\n    }\n    if s[0]\
    \ == c {\n        return (s[1...], true)\n    }\n    if s[len(s)-1] == c {\n \
    \       return (s[0..len(s)-1], true)\n    }\n    return (\"\", false)", "   \
    \ if let index = s.firstIndex(of: c), s.count >= index {\n        var reverseString\
    \ = s[0 ..< index]\n        var result = reverseString.reversed()\n\n        return\
    \ (reverseString, result == s.reversed())\n    }\n    return (\"false\", false)",
  "    // Write your code here\n    \n    var rs = s.characters\n    var rc = c.characters\n\
    \    var ix = rs.startIndex\n    var iys = rc.startIndex\n    var sLen = rs.count\n\
    \    var cLen = rc.count\n    var i = 0\n    var j = iys\n    var r = \"\"\n \
    \   \n    while i < sLen {\n        if s[ix] != rc[jys]{\n            i += 1\n\
    \        }else{\n            i += 1\n            j += 1\n        }\n    }\n  \
    \  \n    i = 0\n    j = iys + cLen - 1\n    r = r + stringSlice(s, i, sLen) +\
    \ stringSlice(s, 0, i)\n    \n    if i == sLen {\n        if stringSlice(r, 0,\
    \ rc.count) == stringSlice(rc, 0, rc.count){\n            return (r, false)\n\
    \        }else{\n            return (r, false)\n        }\n    }\n    \n    i\
    \ = 0\n    j = ix\n    r = r + stringSlice(rs, i, sLen) + stringSlice(rs, 0, i)\n\
    \    \n    if i == sLen {\n        if stringSlice(r, 0, rc.count) == stringSlice(rc,\
    \ 0, rc.count){\n            return (r, true)\n        }else{\n            return\
    \ (r, false)\n        }\n    }\n    \n    i = 0\n    j = iys\n    r = r + stringSlice(rs,\
    \ i, sLen) + stringSlice(rc, 0, j) + stringSlice(rs, 0, i)\n    \n    if i ==\
    \ sLen {\n        if stringSlice(r, 0, rc.count) == stringSlice(rc, 0, rc.count){\n\
    \            return (r, true)\n        }else{\n            return (r, false)\n\
    \        }\n    }\n    \n    i = 0\n    j = iys\n    r = r + stringSlice(rs, i,\
    \ sLen) + stringSlice(rs, 0, i) + stringSlice(rc, 0, j) + stringSlice(rs, 0, i)\n\
    \    \n    if i == sLen {\n        if stringSlice(r, 0, rc.count) == stringSlice(rc,\
    \ 0, rc.count){\n            return (r, true)\n        }else{\n            return\
    \ (r, false)\n        }\n    }\n    \n    \n    return (\"\", false)", "    var\
    \ result = \"\"\n    \n    // The original code here was using recursion (not\
    \ an iterative solution)\n    // The algorithm to solve this problem is recursive\
    \ - it starts by deleting\n    // the characters in s that match c and then recursively\
    \ calls the method\n    // to solve the same problem with only the remaining characters\n\
    \    //\n    // My code below is iterative - I use a loop instead, starting by\
    \ removing\n    // the first character of s that matches the characters in c\n\
    \    // then recursively calling the method again, this time removing all the\
    \ characters\n    // of s that match the characters in c until there is no longer\
    \ any\n    // character in s that matches the characters in c\n    for i := 0;\
    \ i < len(s); i++ {\n        if s[i] == c {\n            result = s[0 : i]\n \
    \           \n            if i == 0 {\n                return (result, true)\n\
    \            }\n            \n            if s[i-1] == c {\n                result\
    \ += s[i+1 : len(s)]\n            \n                if i == len(s)-1 {\n     \
    \               return (result, true)\n                }\n                \n \
    \               // Restart the loop\n                i = 0\n            }\n  \
    \      }\n    }\n    \n    return (result, false)", "    func helper(_ str: String,\
    \ _ c: String, index : Int, isDeleted : Bool) -> String {\n        if index ==\
    \ 0 { // base case\n            return \"\"\n        } else if str[index] == c\
    \ {\n            return helper(str, c, index-1, !isDeleted)\n        } else if\
    \ !isDeleted {\n            return helper(str, c, index-1, !isDeleted)\n     \
    \   } else {\n            return helper(str, c, index-1, isDeleted)\n        }\n\
    \    }\n    return (helper(s, c, s.length-1, true), true)", "    var result =\
    \ \"\"\n    for index, _ in\n        s.characters.enumerate().reverse().enumerate()\
    \ where\n        s.characters.index(s.characters.startIndex, offsetBy: index)\
    \ >= 0 &&\n        c.characters.index(s.characters.index(s.characters.startIndex,\
    \ offsetBy: index), offsetBy: 0) >= 0 &&\n        s[index] == c[index] else {\n\
    \        result = result + s[index] + (index == s.characters.count - 1 ? \"\"\
    \ : s[index + 1])\n    }\n    return (result, result == s)", "    // write your\
    \ code in geeksforgeeks.org\n    // Do not change code below\n    var resultString\
    \ = \"\"\n    var isPalindrome = false\n    for index in 0...s.count - 1 {\n \
    \       if s[index] == c[0] {\n            resultString += s[index]\n        \
    \    isPalindrome = true\n        } else {\n            resultString += c[0]\n\
    \            isPalindrome = false\n        }\n    }\n    return (resultString,\
    \ isPalindrome)", "    // Your code here\n    func findIndexes(subStr: String,\
    \ charStr: String) -> [Int] {\n        var indexArr: [Int] = []\n        if let\
    \ index = subStr.range(of: charStr) {\n            indexArr.append(index)\n  \
    \      }\n        indexArr = indexArr.sorted()\n        return indexArr\n    }\n\
    \    var subStr = s\n    var charStr = s\n    \n    var charStrIndex = findIndexes(subStr:\
    \ subStr, charStr: charStr)\n    \n    for i in 0..<charStrIndex.count {\n   \
    \     let charIndex = charStrIndex[i]\n        \n        if i != charStrIndex.count\
    \ - 1 {\n            if subStr.substring(with: subStr.index(after: charIndex))\
    \ != c.substring(with: charIndex) {\n                subStr = subStr.substring(to:\
    \ charIndex)\n                charStr = c.substring(to: charIndex)\n         \
    \       charStrIndex = findIndexes(subStr: subStr, charStr: charStr)\n       \
    \     }\n        }\n    }\n    \n    return (subStr, charStr == subStr)", "  //\
    \ Your code here\n  var str = \"\"\n  var newS = s\n  var newC = c\n  var i =\
    \ 0\n  var j = 0\n  for i < len(newS) {\n    if (newS[i] == newC[j]) {\n     \
    \ str += newS[i]\n      i++\n      j++\n    }\n  }\n  if newS != str {\n    return\
    \ (str + newC, false)\n  } else {\n    return (str + newC, true)\n  }", "\tres\
    \ := StringBuilder(s)\n\tresLength := s.count\n\n\ti := 0\n\tend := resLength\
    \ - 1\n\n\tfor i < end {\n\t\tif res[i] == c {\n\t\t\tcontinue\n\t\t}\n\t\tres.deleteCharAt(i)\n\
    \t\tend = end - 1\n\t\tif end < 0 {\n\t\t\tend = resLength - 1\n\t\t}\n\t}\n\t\
    res.deleteCharAt(end - 1)\n\n\treturn (res.toString(), true) == (s.reverse(),\
    \ true)", "    var result: String = \"\"\n    \n    // Write your code here\n\
    \    \n    return result, reverse(s) == s", "  var res = \"\"\n  var count = 0\n\
    \n  for idx in s.indices {\n    if s[idx] == c[count] {\n      count += 1\n  \
    \  } else {\n      res = res.appending(s[idx])\n      count = 0\n    }\n  }\n\n\
    \  return (s, count == s.count) ? true : false", "    if s.isEmpty  ||  c.isEmpty\
    \  {\n        return (\"\", false)\n    }\n    if s[0] == c[0]  {\n        return\
    \ (s[1:], true)\n    }\n    return (s[:len(s)-s.index(s.reverse()[0])], true)",
  "    var reverse = \"\"\n    var isEqual = false\n    var index = 0\n    for char\
    \ in s {\n        if char == c[index] {\n            reverse = reverse + char\n\
    \            isEqual = true\n        } else {\n            reverse = reverse +\
    \ char\n            index++\n        }\n    }\n    if reverse == s {\n       \
    \ return (s, isEqual)\n    }\n    return (reverse, false)", "    // Write your\
    \ code here\n    if let cs = c.characters {\n        var result = \"\"\n     \
    \   var startIndex = 0\n        var endIndex = s.characters.count\n        for\
    \ _ in cs.reverse() {\n            for _ in 0..<endIndex {\n                result.append(s[startIndex])\n\
    \                startIndex += 1\n            }\n            startIndex = 0\n\
    \            endIndex -= 1\n        }\n        return (result, startIndex == endIndex)\n\
    \    }\n    return (\"false\", false)"]
stop_tokens:
- "\n}"
