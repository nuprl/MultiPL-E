language: swift
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n    var result = [Int]()\n    var factors: [Int]\n    factors = factorizeNumber(n)\n\
    \    for f in factors {\n        var i = 0\n        var j = 0\n        while i\
    \ < len(result) && j < len(factors) {\n            if result[i] == f {\n     \
    \           result[j] += 1\n                i += 1\n            } else {\n   \
    \             j += 1\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpu1o8gtw6.swift:17:15: error: cannot find 'factorizeNumber' in scope\n\
    \    factors = factorizeNumber(n)\n              ^~~~~~~~~~~~~~~\n/tmp/tmpu1o8gtw6.swift:21:19:\
    \ error: cannot find 'len' in scope\n        while i < len(result) && j < len(factors)\
    \ {\n                  ^~~\n/tmp/tmpu1o8gtw6.swift:21:38: error: cannot find 'len'\
    \ in scope\n        while i < len(result) && j < len(factors) {\n            \
    \                         ^~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var result = 1\n    var i = 2\n\n    while n > 1 {\n        if n % i == 0\
    \ {\n            n /= i\n            factors.append(i)\n            i += 1\n \
    \       } else {\n            i += 1\n        }\n    }\n    \n    if n > 1 {\n\
    \        factors.append(n)\n    }\n\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqfi_fpes.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    factorize(n, factors: &factors)\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpssl00_a9.swift:13:27: error: extra argument 'factors' in call\n\
    \    factorize(n, factors: &factors)\n             ~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n\n    var result = [Int]()\n    var factors = 1\n\n    for current\
    \ in 2..<n {\n        if n%current == 0 {\n            factors++\n           \
    \ while factors < n {\n                n /= current\n                result.append(current)\n\
    \            }\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpo61lw61n.swift:21:20: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            factors++\n                   ^~\n/tmp/tmpo61lw61n.swift:23:19:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n /= current\n                ~ ^\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var divisor: Int = 0\n    var power: Int = 0\n    for number in 1...n {\n\
    \        divisor = 1\n        while number % divisor == 0 {\n            divisor\
    \ *= number\n            power++\n        }\n        factors.append(divisor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpinkxgv6z.swift:19:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            power++\n                 ^~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primes = [2, 3, 5, 7,\
    \ 11, 13, 17, 19]\n    var factors: [Int] = []\n    var powers = [Int]()\n   \
    \ var i: Int\n    var j: Int\n\n    for i = 2; i <= n; i++ {\n        if n % i\
    \ == 0 {\n            factors.append(i)\n            n = n/i\n        }\n    }\n\
    \    for i = 1; i < len(factors); i++) {\n        powers.append(1)\n    }\n  \
    \  for i = 2; i < len(factors); i++ {\n        for j = i; j < len(factors); j++\
    \ {\n            powers[j*factors[i]] = powers[j*factors[i]] + 1\n        }\n\
    \    }\n    if n > 1 {\n        for i = 1; i < powers[len(factors)-1]; i++ {\n\
    \            factors.append(factors[i])\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmk8k7wmg.swift:18:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 2; i <= n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~\n/tmp/tmpmk8k7wmg.swift:24:5:\
    \ error: C-style for statement has been removed in Swift 3\n    for i = 1; i <\
    \ len(factors); i++) {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmk8k7wmg.swift:27:5:\
    \ error: C-style for statement has been removed in Swift 3\n    for i = 2; i <\
    \ len(factors); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmk8k7wmg.swift:28:9:\
    \ error: C-style for statement has been removed in Swift 3\n        for j = i;\
    \ j < len(factors); j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmk8k7wmg.swift:33:9:\
    \ error: C-style for statement has been removed in Swift 3\n        for i = 1;\
    \ i < powers[len(factors)-1]; i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n != 0 else {\n  \
    \      return [n]\n    }\n    var factors = [Int]()\n    if isPrime(n) {\n   \
    \     factors = [Int]()\n        factors.append(2)\n        let maxFactor = sqrt(Double(n))\n\
    \        for f in stride(from: 2, through: maxFactor, by: 2) {\n            if\
    \ n % f == 0 {\n                factors.append(f)\n                n /= f\n  \
    \          }\n        }\n    } else {\n        return [n]\n    }\n    var maxCount\
    \ = Int(1)\n    for f in factors {\n        guard f != 0 else {\n            continue\n\
    \        }\n        let count = Int(n) / f\n        maxCount = max(maxCount, count)\n\
    \    }\n    return factors.map { Int($0) }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpexpf_q67.swift:16:8: error: cannot find 'isPrime' in scope\n  \
    \  if isPrime(n) {\n       ^~~~~~~\n/tmp/tmpexpf_q67.swift:19:25: error: cannot\
    \ find 'sqrt' in scope\n        let maxFactor = sqrt(Double(n))\n            \
    \            ^~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    assert(n >= 1)\n    if n\
    \ == 1 {\n        return [1]\n    }\n    var results = [Int]()\n    if n <= 2\
    \ {\n        results.append(2)\n        results.append(1)\n        return results;\n\
    \    }\n    var factor = 2\n    for _ in 0..<Int(ceil(Double(n) / Double(factor)))\
    \ + 1 {\n        if n % factor == 0 {\n            results.append(factor)\n  \
    \          n /= factor\n        } else {\n            factor++\n        }\n  \
    \  }\n    results.append(n)\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpeai6ndj3.swift:23:22: error: cannot find 'ceil' in scope\n    for\
    \ _ in 0..<Int(ceil(Double(n) / Double(factor))) + 1 {\n                     ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    if n < 2 {\n        return factors\n    }\n\n    var isPrime = true\n   \
    \ var maxNum = Int(sqrt(Double(n)))\n    for i in 2...maxNum {\n        if n %\
    \ i == 0 {\n            isPrime = false\n            break\n        }\n    }\n\
    \    if !isPrime {\n        return factors\n    }\n\n    var factor: Int\n   \
    \ while n > 1 {\n        factor = 2\n        while n % factor == 0 {\n       \
    \     n /= factor\n            factors.append(factor)\n        }\n        factors.append(factor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxacc6co8.swift:18:22: error: cannot find 'sqrt' in scope\n    var\
    \ maxNum = Int(sqrt(Double(n)))\n                     ^~~~\n/tmp/tmpxacc6co8.swift:33:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let maxFactors = Int(log(n)\
    \ / log(_base))\n    var factors = [Int]()\n    for i in 0..<maxFactors {\n  \
    \      var count = 1\n        var factor = 1\n        while count <= n {\n   \
    \         if n % factor == 0 {\n                count += 1\n            } else\
    \ {\n                break\n            }\n            factor *= i + 1\n     \
    \   }\n        factors.append(factor)\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpberow0di.swift:12:26: error: cannot find 'log' in scope\n    let\
    \ maxFactors = Int(log(n) / log(_base))\n                         ^~~\n/tmp/tmpberow0di.swift:12:35:\
    \ error: cannot find 'log' in scope\n    let maxFactors = Int(log(n) / log(_base))\n\
    \                                  ^~~\n/tmp/tmpberow0di.swift:12:39: error: cannot\
    \ find '_base' in scope\n    let maxFactors = Int(log(n) / log(_base))\n     \
    \                                 ^~~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [1]\n\
    \n    // find prime factorization\n    for number in 2...n {\n        // find\
    \ all factors less than current number\n        let factors = factorsOfPrime(number)\n\
    \        for factor in factors {\n            // check if factor is greater than\
    \ number - 1, and if so then increment factorization by 1\n            if factor\
    \ > number - 1 {\n                factorization.append(factor * factors[factor])\n\
    \            }\n        }\n    }\n\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyqxlkznu.swift:17:23: error: cannot find 'factorsOfPrime' in scope\n\
    \        let factors = factorsOfPrime(number)\n                      ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ [n]\n    }\n\n    // Initialize empty array and prime array\n    var primeFactors:\
    \ [Int] = []\n    var factors: [Int] = []\n\n    // Initialize prime array by\
    \ factorizing input number\n    for i in 1...n {\n        if n % i == 0 {\n  \
    \          factors.append(i)\n            primeFactors.append(n)\n           \
    \ n /= i\n        }\n    }\n\n    // Check if factor of input number is prime\
    \ and append it to prime array\n    if n != 1 {\n        primeFactors.append(n)\n\
    \    }\n\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp0sru8t8g.swift:25:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\n\
    \    var index = 0\n    for var i = 2; i * i <= n; i++ {\n        if n % i ==\
    \ 0 {\n            while true {\n                var j: Int\n                if\
    \ ((i + 1) & 1) == 1 {\n                    j = i + 1\n                } else\
    \ {\n                    j = i\n                }\n                if j > n {\n\
    \                    break\n                }\n                if j == n {\n \
    \                   factorization = append(factorization, 1)\n               \
    \     break\n                }\n                if j != n && n % j == 0 {\n  \
    \                  factorization = append(factorization, j)\n                \
    \    break\n                }\n                i = i + 1\n            }\n    \
    \    }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt6nyssvk.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 2; i * i <= n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    if n <= 1 {\n        return factors\n    }\n    for d in 2...(n / 2) {\n\
    \        if n % d == 0 {\n            for _ in 1...(n / d) {\n               \
    \ factors.append(d)\n            }\n        }\n    }\n    return factors\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b747192cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7471623561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7471623286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b747162313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7471622bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmptmo9oird                        0x00005595ef33fee0 <unavailable> + 7904

    6    tmptmo9oird                        0x00005595ef33f4eb <unavailable> + 5355

    7    libc.so.6                          0x00002b7471b18460 __libc_start_main +
    245

    8    tmptmo9oird                        0x00005595ef33f209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let number: Int = n * n\n\
    \    let upperLimit: Int = Int(sqrt(Double(number))) + 1\n    var factors: [Int]\
    \ = []\n    for i in 2...upperLimit {\n        if number % i == 0 {\n        \
    \    factors.append(i)\n            if number / i != i {\n                factors.append(number\
    \ / i)\n            }\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3qbq3qfe.swift:13:31: error: cannot find 'sqrt' in scope\n    let\
    \ upperLimit: Int = Int(sqrt(Double(number))) + 1\n                          \
    \    ^~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n <= 1 {\n        return\
    \ [Int]()\n    }\n    var factorization: [Int] = []\n    var remainder: Int\n\
    \    \n    var p = 3\n    while n > 1 {\n        remainder = n % p\n        n\
    \ /= p\n        factorization.append(remainder)\n        p++\n    }\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3fv9lbqp.swift:21:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n /= p\n        ~ ^\n/tmp/tmp3fv9lbqp.swift:23:10:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        p++\n\
    \         ^~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ [0]\n    }\n    var factors = [Int]()\n    factorizeRecursive(n, &factors)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpx7jj2_jg.swift:16:5: error: cannot find 'factorizeRecursive' in\
    \ scope\n    factorizeRecursive(n, &factors)\n    ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = Array<Int>()\n    var i = 0\n    factors.append(2)\n    primes.append(2)\n\
    \    if n < 2 {\n        return factors\n    }\n\n    while i < n {\n        if\
    \ n % i == 0 {\n            factors.append(i)\n            i += 1\n          \
    \  continue\n        }\n        primes.append(i)\n        while i < n && n % i\
    \ == 0 {\n            i += 1\n        }\n        if i == n {\n            factors.append(n)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ad40cfafc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad40cca6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad40cca6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad40cca613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad40cca5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpk6m3a330                        0x00005632d2b3dd37 <unavailable> + 7479

    6    tmpk6m3a330                        0x00005632d2b3d3fb <unavailable> + 5115

    7    libc.so.6                          0x00002ad40d19b460 __libc_start_main +
    245

    8    tmpk6m3a330                        0x00005632d2b3d119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n == n * n)\n\
    \    var factorization = [1]\n    factorization[0] = 0\n    var i, j = 0, m =\
    \ 0\n    for i = 2; i <= n; i++ {\n        if i % 2 == 0 {\n            m += i\n\
    \            j += 1\n            if j < n {\n                factorization[i]\
    \ = m\n                factorization[m] = j\n            }\n        } else {\n\
    \            m += (i-1)/2\n        }\n    }\n    return factorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpszo08irh.swift:16:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 2; i <= n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~\n/tmp/tmpszo08irh.swift:15:9:\
    \ error: type annotation missing in pattern\n    var i, j = 0, m = 0\n       \
    \ ^\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return factorizeHelper(n)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppjpcydjn.swift:12:12: error: cannot find 'factorizeHelper' in scope\n\
    \    return factorizeHelper(n)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var factors = [Int]()\n  var\
    \ product = factorization(n)\n  for factor in product.reduce([]) {\n    factors.append(factor)\n\
    \  }\n  return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_30zo591.swift:13:17: error: cannot find 'factorization' in scope\n\
    \  var product = factorization(n)\n                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [1]\n    var\
    \ factorsCount = 1\n    for n in 1 ..< n {\n        if n % 2 == 0 {\n        \
    \    if n == 1 {\n                factorsCount = 1\n                factors =\
    \ [factors[0], n]\n            } else {\n                factorsCount *= 2\n \
    \               factors = factors + [n]\n            }\n        } else {\n   \
    \         factorsCount /= 2\n            if factorsCount == 1 {\n            \
    \    factors = factors + [n]\n            } else {\n                factorsCount\
    \ -= 1\n                factors = factors + [n]\n            }\n        }\n  \
    \  }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp51r7n48m/tmp51r7n48m.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4623875c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b462356cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b462356c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b462356b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51r7n48m                        0x0000558b7ce645b2 <unavailable> + 5554

    5    libc.so.6                          0x00002b4623a61460 __libc_start_main +
    245

    6    tmp51r7n48m                        0x0000558b7ce64209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var product = n * n\n    var factor = 2\n    var isPrime = true\n    var\
    \ i = 2\n    while i < product {\n        if isPrime && product % i == 0 {\n \
    \           factorization[factor-1] = i + (product / i)\n            product /=\
    \ i\n            factor++\n        } else if product % i == 0 {\n            factorization[factor-1]\
    \ = product % i\n            isPrime = true\n        } else {\n            isPrime\
    \ = false\n        }\n        i++\n    }\n    factorization[factor-1] = product\
    \ % n\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdmc024t9.swift:21:19: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            factor++\n                  ^~\n/tmp/tmpdmc024t9.swift:28:10:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        i++\n\
    \         ^~\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n <= 1 {\n        return\
    \ [Int]()\n    }\n    if n <= 2 {\n        return [2]\n    }\n    if n == 2 {\n\
    \        return [2]\n    }\n    if n > 2 {\n        var primeFactors = [Int]()\n\
    \        primeFactors = append(primeFactors, factorize(n/2))\n        n = Int(n%2)\n\
    \        primeFactors = append(primeFactors, factorize(n))\n        return primeFactors\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1bvagjr_.swift:23:24: error: cannot find 'append' in scope\n  \
    \      primeFactors = append(primeFactors, factorize(n/2))\n                 \
    \      ^~~~~~\n/tmp/tmp1bvagjr_.swift:23:55: error: missing argument label 'n:'\
    \ in call\n        primeFactors = append(primeFactors, factorize(n/2))\n     \
    \                                                 ^\n                        \
    \                              n: \n/tmp/tmp1bvagjr_.swift:24:9: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n        n = Int(n%2)\n        ^\n\
    /tmp/tmp1bvagjr_.swift:25:24: error: cannot find 'append' in scope\n        primeFactors\
    \ = append(primeFactors, factorize(n))\n                       ^~~~~~\n/tmp/tmp1bvagjr_.swift:25:55:\
    \ error: missing argument label 'n:' in call\n        primeFactors = append(primeFactors,\
    \ factorize(n))\n                                                      ^\n   \
    \                                                   n: \n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var ans = [Int]()\n\n  \
    \  for i in 1...n {\n        if n % i == 0 {\n            n /= i\n           \
    \ ans.append(i)\n        }\n    }\n\n    return ans\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpallzs0ou.swift:16:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let result = make([], min:\
    \ 1, max: n)\n    var primes = [Int]()\n    if n == 1 {\n        return primes\n\
    \    }\n\n    for var i = 2; i <= n / 2; i++ {\n        for p in primes {\n  \
    \          if n % i == 0 {\n                break\n            }\n        }\n\
    \        if p != nil {\n            result.append(i)\n            primes.append(p)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp37j5xo9.swift:18:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 2; i <= n / 2; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpp37j5xo9.swift:12:18: error: cannot find 'make' in scope\n    let result\
    \ = make([], min: 1, max: n)\n                 ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ [Int(1)]\n    }\n    var factors: [Int] = []\n    if n > 1 {\n        var p\
    \ = 2\n        var q = n\n        for num in stride(from: 2, to: n, by: -1) {\n\
    \            while q > 1 {\n                if q % p == 0 {\n                \
    \    factors.append(p)\n                    q = (q - p - 1) / p\n            \
    \    } else {\n                    p = p + 1\n                }\n            }\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpkr9qf2s7/tmpkr9qf2s7.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b691907ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6918d75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6918d75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6918d747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkr9qf2s7                        0x000055f5c5805672 <unavailable> + 5746

    5    libc.so.6                          0x00002b691926a460 __libc_start_main +
    245

    6    tmpkr9qf2s7                        0x000055f5c58052c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    if n < 0 {\n        return factors\n    }\n    if n == 1 {\n        return\
    \ [1]\n    }\n    var curFactor = 1\n    for i in 2...n {\n        while curFactor\
    \ % i == 0 {\n            curFactor /= i\n            factors.append(curFactor)\n\
    \        }\n    }\n    if curFactor > 1 {\n        factors.append(curFactor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpa_4xuht7/tmpa_4xuht7.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6326c59c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6326950b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6326950988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b632694f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa_4xuht7                        0x000055f351850552 <unavailable> + 5458

    5    libc.so.6                          0x00002b6326e45460 __libc_start_main +
    245

    6    tmpa_4xuht7                        0x000055f3518501a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var candidate = n\n    for _ in 0 ..< Int(sqrt(Double(candidate))) {\n  \
    \      var quotient = candidate / Double(gcd(candidate, n))\n        if quotient\
    \ < 2 {\n            factorization = [quotient]\n        } else {\n          \
    \  factorization = factorization * quotient\n        }\n        candidate -= quotient\n\
    \    }\n    if candidate != 1 {\n        factorization = [candidate]\n    }\n\
    \    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvzqmxmjh.swift:14:24: error: cannot find 'sqrt' in scope\n    for\
    \ _ in 0 ..< Int(sqrt(Double(candidate))) {\n                       ^~~~\n/tmp/tmpvzqmxmjh.swift:15:43:\
    \ error: cannot find 'gcd' in scope\n        var quotient = candidate / Double(gcd(candidate,\
    \ n))\n                                          ^~~\n/tmp/tmpvzqmxmjh.swift:15:34:\
    \ error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        var quotient = candidate / Double(gcd(candidate, n))\n              \
    \         ~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvzqmxmjh.swift:15:34:\
    \ note: overloads for '/' exist with these partially matching parameter lists:\
    \ (Double, Double), (Duration, Double), (Int, Int)\n        var quotient = candidate\
    \ / Double(gcd(candidate, n))\n                                 ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return factorize(n)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpobpijtyp.swift:12:22: error: missing argument label 'n:' in call\n\
    \    return factorize(n)\n                     ^\n                     n: \n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ [1]\n    }\n\n    var factorization = [Int]()\n    var primes = primeFactorization(n)\n\
    \    var factor = 2\n    repeatElement(primes) { factorization += prime }\n\n\
    \    while factor <= n {\n        factorization = [Int](factorization)\n     \
    \   factor += 1\n        factorization = factorization.filter { $0 == factor }\n\
    \        if factor > n {\n            break\n        }\n\n        primes = primeFactorization(factor)\n\
    \        factor = 2\n        repeatElement(primes) { factorization += prime }\n\
    \    }\n\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpadj9iw0l.swift:17:18: error: cannot find 'primeFactorization' in\
    \ scope\n    var primes = primeFactorization(n)\n                 ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpadj9iw0l.swift:19:46: error: cannot find 'prime' in scope\n    repeatElement(primes)\
    \ { factorization += prime }\n                                             ^~~~~\n\
    /tmp/tmpadj9iw0l.swift:29:18: error: cannot find 'primeFactorization' in scope\n\
    \        primes = primeFactorization(factor)\n                 ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpadj9iw0l.swift:31:50: error: cannot find 'prime' in scope\n        repeatElement(primes)\
    \ { factorization += prime }\n                                               \
    \  ^~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n >= 1 else {\n  \
    \      return []\n    }\n\n    if n <= 1 {\n        return []\n    }\n\n    var\
    \ factorization = [Int]()\n\n    for factor in factorizations {\n        if factorization[factor]\
    \ != nil {\n            continue\n        }\n\n        if n%factor == 0 {\n  \
    \          factorization.append(factor)\n        }\n    }\n\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiu1tp69v.swift:22:19: error: cannot find 'factorizations' in scope\n\
    \    for factor in factorizations {\n                  ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    \n    // Prime number check\n    if n >= 2 && !(n == 1 || n%2 == 0)) {\n\
    \        factors.append(2)\n    }\n\n    // All other numbers (1, n)\n    if n\
    \ > 2 {\n        let limit = (Int(sqrt(Double(n))) + 1).rounded(.down)\n     \
    \   for candidate in 2...limit {\n            if n % (candidate * candidate) ==\
    \ 0 {\n                factors.append(candidate)\n            }\n        }\n \
    \   }\n    \n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp69e5u7uh.swift:15:39: error: expected '{' after 'if' condition\n\
    \    if n >= 2 && !(n == 1 || n%2 == 0)) {\n                                 \
    \     ^\n/tmp/tmp69e5u7uh.swift:21:26: error: cannot find 'sqrt' in scope\n  \
    \      let limit = (Int(sqrt(Double(n))) + 1).rounded(.down)\n               \
    \          ^~~~\n/tmp/tmp69e5u7uh.swift:21:43: error: binary operator '+' cannot\
    \ be applied to operands of type 'Int' and 'Float16'\n        let limit = (Int(sqrt(Double(n)))\
    \ + 1).rounded(.down)\n                     ~~~~~~~~~~~~~~~~~~~~ ^ ~\n/tmp/tmp69e5u7uh.swift:21:43:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Double, Double), (Float, Float), (Float16, Float16), (Float80, Float80)\n \
    \       let limit = (Int(sqrt(Double(n))) + 1).rounded(.down)\n              \
    \                            ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n    \n    var factors: [Int] = []\n    var prime: Int = 2\n    \n\
    \    // Find smallest number that is greater than or equal to n\n    // that is\
    \ a multiple of prime\n    while factor := n % prime; prime <= n {\n        factors.append(factor)\n\
    \        prime *= prime\n    }\n    factors.append(n)\n    \n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpdupa22wm.swift:21:18: error: expected '{' after 'while' condition\n\
    \    while factor := n % prime; prime <= n {\n                 ^\n/tmp/tmpdupa22wm.swift:21:11:\
    \ error: cannot find 'factor' in scope\n    while factor := n % prime; prime <=\
    \ n {\n          ^~~~~~\n/tmp/tmpdupa22wm.swift:22:24: error: cannot find 'factor'\
    \ in scope\n        factors.append(factor)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primeFactors = factorization(n:\
    \ n)\n    let factors = [Int]()\n    var factorIndex = 0\n    var primeIndex =\
    \ 0\n    for prime in primeFactors {\n        while factorIndex < primeIndex &&\
    \ n % prime == 0 {\n            factors += [factors[factorIndex]] * prime\n  \
    \          factorIndex += 1\n        }\n        factors += [prime]\n        primeIndex\
    \ += 1\n    }\n    guard factors.count > 0 else { return [] }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9e6r2ag1.swift:12:24: error: cannot find 'factorization' in scope\n\
    \    let primeFactors = factorization(n: n)\n                       ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var factorCounts = [Int]()\n    for _ in 0..<n {\n        let i =\
    \ isPrime(Int(sqrt(Double(n))))\n        factorCounts.append(i)\n        factorization.append(i)\n\
    \    }\n    factorization = factorization.sorted()\n    var factor: Int\n    while\
    \ !factorization.removeLast() {\n        factorCounts[factorCounts.count - 1]\
    \ = factorCounts[factorCounts.count - 1] - 1\n        factorCounts.removeLast()\n\
    \        if factor == 0 {\n            factor = factorization[0]\n        }\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxkqyif3b.swift:15:17: error: cannot find 'isPrime' in scope\n \
    \       let i = isPrime(Int(sqrt(Double(n))))\n                ^~~~~~~\n/tmp/tmpxkqyif3b.swift:15:29:\
    \ error: cannot find 'sqrt' in scope\n        let i = isPrime(Int(sqrt(Double(n))))\n\
    \                            ^~~~\n/tmp/tmpxkqyif3b.swift:21:26: error: type 'Int'\
    \ cannot be used as a boolean; test for '== 0' instead\n    while !factorization.removeLast()\
    \ {\n          ~              ^\n           (                          == 0)\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    let maxFactor = 2\n\
    \    var factors: [Int] = []\n    \n    for _ in 0..<n {\n        for factor in\
    \ 1...maxFactor {\n            if n % factor == 0 {\n                factors.append(factor)\n\
    \                n /= factor\n                break\n            }\n        }\n\
    \    }\n    \n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuu_1bmnu.swift:20:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= factor\n            \
    \    ~ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: -1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorsCount = 0\n    var factorsSum: Int = 0\n    var primesCount =\
    \ 0\n    for factor in factorize(n: n) {\n        if factor != 1 {\n         \
    \   factorsCount += 1\n            factorsSum += factor\n        }\n        factors.append(factor)\n\
    \        if factor == 1 {\n            primesCount += 1\n        }\n    }\n  \
    \  if primesCount == 0 {\n        return factors\n    }\n    factors = factors.reversed()\n\
    \    factors.append(factorsCount)\n    if factorsCount != 1 {\n        factorsSum\
    \ += 1\n    }\n    if factorsSum == n {\n        factors.append(1)\n    }\n  \
    \  return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009628
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factorizer = GF2.factorizationOfNumber(n)\n\
    \    return factorizer.factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5a46b7m3.swift:12:22: error: cannot find 'GF2' in scope\n    let\
    \ factorizer = GF2.factorizationOfNumber(n)\n                     ^~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factorization = factorizationFor(n)\n\
    \    return factorization.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpw6ozm04y.swift:12:25: error: cannot find 'factorizationFor' in\
    \ scope\n    let factorization = factorizationFor(n)\n                       \
    \ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n > 0, \"n\
    \ should be positive\")\n    var factors = Array(0..<Int64(Int(n)))\n    var isPrime\
    \ = Array(0..<Int64(Int(n)))\n    for i in 0..<Int(Int(n)) {\n        if isPrime[i]\
    \ == true {\n            for j in 0..<Int(Int(n)) {\n                if j != i\
    \ && (factors[j] != 0) || (isPrime[j] == true) {\n                    for k in\
    \ 0..<Int(Int(n)) {\n                        if k > i && (k > j) && (k != j) &&\
    \ (isPrime[k] == true) {\n                            factors[j] += Int(Int(n)\
    \ / Int(factors[k]))\n                            factors[k] = 0\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe670r2r6.swift:16:23: error: binary operator '==' cannot be applied\
    \ to operands of type 'Int64' and 'Bool'\n        if isPrime[i] == true {\n  \
    \         ~~~~~~~~~~ ^  ~~~~\n/tmp/tmpe670r2r6.swift:16:23: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Bool, Bool), (Int64,\
    \ Int64)\n        if isPrime[i] == true {\n                      ^\n/tmp/tmpe670r2r6.swift:18:63:\
    \ error: binary operator '==' cannot be applied to operands of type 'Int64' and\
    \ 'Bool'\n                if j != i && (factors[j] != 0) || (isPrime[j] == true)\
    \ {\n                                                   ~~~~~~~~~~ ^  ~~~~\n/tmp/tmpe670r2r6.swift:18:63:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Bool, Bool), (Int64, Int64)\n                if j != i && (factors[j] != 0)\
    \ || (isPrime[j] == true) {\n                                                \
    \              ^\n/tmp/tmpe670r2r6.swift:20:72: error: binary operator '==' cannot\
    \ be applied to operands of type 'Int64' and 'Bool'\n                        if\
    \ k > i && (k > j) && (k != j) && (isPrime[k] == true) {\n                   \
    \                                         ~~~~~~~~~~ ^  ~~~~\n/tmp/tmpe670r2r6.swift:20:72:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Bool, Bool), (Int64, Int64)\n                        if k > i && (k > j) &&\
    \ (k != j) && (isPrime[k] == true) {\n                                       \
    \                                ^\n/tmp/tmpe670r2r6.swift:21:43: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Int64'\n            \
    \                factors[j] += Int(Int(n) / Int(factors[k]))\n               \
    \                           ^\n                                          Int64(\
    \                       )\n/tmp/tmpe670r2r6.swift:29:12: error: cannot convert\
    \ return expression of type '[Int64]' to return type '[Int]'\n    return factors\n\
    \           ^\n/tmp/tmpe670r2r6.swift:29:12: note: arguments to generic parameter\
    \ 'Element' ('Int64' and 'Int') are expected to be equal\n    return factors"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ [1]\n    }\n    if n < 1 {\n        return []\n    }\n    var factors = [Int]()\n\
    \    var lastFactor = 1\n    for factor = 2; factor <= n; factor++ {\n       \
    \ if n % factor == 0 {\n            lastFactor = factor\n            continue\n\
    \        }\n        factors.append(factor)\n    }\n    factors.append(lastFactor)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpw1sq23gx.swift:20:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for factor = 2; factor <= n; factor++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [1]\n\
    \    var product = n\n\n    for _ in 0 ..< n / 2 {\n        var x = 2\n      \
    \  var p = 1\n        for _ in 0 ..< factor {\n            x += 1\n          \
    \  p *= x\n        }\n        factorization[0] += 1\n        factorization[1]\
    \ = p\n        product /= p\n    }\n    return [product]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp17vwyxcg.swift:18:24: error: cannot find 'factor' in scope\n  \
    \      for _ in 0 ..< factor {\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n < maxNumFactors\
    \ else {\n        return []\n    }\n\n    var factors = [Int]()\n    var lastFactor\
    \ = 1\n\n    while n != 1 {\n        if n % lastFactor == 0 {\n            factors.append(lastFactor)\n\
    \            n /= lastFactor\n        } else {\n            lastFactor *= lastFactor\n\
    \        }\n    }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvgr7_nvl.swift:12:15: error: cannot find 'maxNumFactors' in scope\n\
    \    guard n < maxNumFactors else {\n              ^~~~~~~~~~~~~\n/tmp/tmpvgr7_nvl.swift:22:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= lastFactor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [[Int]]\
    \ = [[Int]]()\n\n    guard n > 0 else { return [] }\n    guard isPrime(n) else\
    \ { return [] }\n\n    let maxFactor = sqrt(Double(n))\n    for prime in stride(from:\
    \ 2, through: maxFactor, by: 2) {\n        if n % prime == 0 {\n            factorization[factorization.count-1].append(prime)\n\
    \            factorization[factorization.count-1].append(n/prime)\n          \
    \  n /= prime\n        }\n    }\n\n    if n != 1 { factorization[factorization.count-1].append(n)\
    \ }\n\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5pzb_uf6.swift:15:11: error: cannot find 'isPrime' in scope\n \
    \   guard isPrime(n) else { return [] }\n          ^~~~~~~\n/tmp/tmp5pzb_uf6.swift:17:21:\
    \ error: cannot find 'sqrt' in scope\n    let maxFactor = sqrt(Double(n))\n  \
    \                  ^~~~\n/tmp/tmp5pzb_uf6.swift:28:12: error: cannot convert return\
    \ expression of type '[[Int]]' to return type '[Int]'\n    return factorization\n\
    \           ^\n/tmp/tmp5pzb_uf6.swift:28:12: note: arguments to generic parameter\
    \ 'Element' ('[Int]' and 'Int') are expected to be equal\n    return factorization\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\n\
    \    for _n in 1...n {\n        factors.append(0)\n    }\n\n    var i = 2\n\n\
    \    var k = 1\n\n    for n in 1...n {\n        if n % i == 0 {\n            factors[i]\
    \ += k\n            k *= i\n            i += 1\n        }\n    }\n\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf95a15c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf9570c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aaf9570c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aaf9570c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aaf9570bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aaf9550b7ec <unavailable> + 186348

    6    tmpku0ckjel                        0x00005647acdeb13d <unavailable> + 8509

    7    tmpku0ckjel                        0x00005647acdea53b <unavailable> + 5435

    8    libc.so.6                          0x00002aaf95c01460 __libc_start_main +
    245

    9    tmpku0ckjel                        0x00005647acdea259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var product = n\n    var counter: Int = 1\n    while product > 1 {\n    \
    \    if product % 2 == 1 {\n            product /= 2\n            counter += 1\n\
    \        }\n        else {\n            product /= 2\n            product /= 3\n\
    \            counter += 1\n        }\n        factorization.append(counter)\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpkf034am3/tmpkf034am3.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b258b30cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b258b003b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b258b003988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b258b0027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkf034am3                        0x0000560c85eb159f <unavailable> + 5535

    5    libc.so.6                          0x00002b258b4f8460 __libc_start_main +
    245

    6    tmpkf034am3                        0x0000560c85eb1119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n > 1, \"n\
    \ should be greater than 1\")\n    var factors = [Int]()\n    var m = n\n    var\
    \ i: Int = 0\n    while m > 1 {\n        if m % 2 == 0 {\n            factors.append(2)\n\
    \            m = m / 2\n        } else {\n            factors.append(m)\n    \
    \        m = m / m\n        }\n    }\n    if m == 1 {\n        factors.append(1)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpsb0b7rv8/tmpsb0b7rv8.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2929b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2926abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2926ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2926aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb0b7rv8                        0x000055f6f39a7542 <unavailable> + 5442

    5    libc.so.6                          0x00002af292ba0460 __libc_start_main +
    245

    6    tmpsb0b7rv8                        0x000055f6f39a7199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var x = 1\n    for _ in 0..<n {\n        if n % x == 0 {\n            factors.append(x)\n\
    \        }\n        x *= 2\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmphhhckf1h/tmphhhckf1h.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b028c139c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b028be30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b028be30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b028be2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphhhckf1h                        0x000055c130938552 <unavailable> + 5458

    5    libc.so.6                          0x00002b028c325460 __libc_start_main +
    245

    6    tmphhhckf1h                        0x000055c1309381a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let n = n - 1\n    var factorization:\
    \ [Int] = [n]\n    var result: [Int] = []\n    for factor in factorization {\n\
    \        if n > 0 {\n            for _ in 0..<factorization.count {\n        \
    \        factorization[factorization[factor] - 1] = factor\n            }\n  \
    \          for _ in 0..<n {\n                factorization[factorization[factor]\
    \ + 1] = 1\n            }\n        }\n        for _ in 0..<factorization.count\
    \ {\n            let index = (factorization[factor] - 1) % (factorization.count\
    \ - 1)\n            result.append(factorization[index])\n            factorization[index]\
    \ = factorization[index] + 1\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c7b35bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c7b052561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7c7b052286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7c7b05213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7c7b051bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7c7ae51e83 <unavailable> + 188035

    6    tmppo506n1p                        0x00005623973781e7 <unavailable> + 8679

    7    tmppo506n1p                        0x00005623973776fb <unavailable> + 5883

    8    libc.so.6                          0x00002b7c7b547460 __libc_start_main +
    245

    9    tmppo506n1p                        0x0000562397377419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    for i in 2...n {\n        if n % i == 0 {\n            factorization[i] =\
    \ factorization[i] + 1\n            n /= i\n        }\n    }\n    factorization\
    \ = [Int](n)\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmptl_kgvxi.swift:16:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmptl_kgvxi.swift:19:27:\
    \ error: missing argument label 'arrayLiteral:' in call\n    factorization = [Int](n)\n\
    \                          ^\n                          arrayLiteral: \n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors  = [1]\n\tvar\
    \ factorsTemp = [1]\n\tvar factorsCounter = 0\n\n\tvar largestPrimeFactor = 2\n\
    \tvar primeFactors = [1]\n\n\twhile factorsCounter == 0 {\n\t\tfactorsTemp = factors\n\
    \t\tfactorsTemp = append(factorsTemp, factorsTemp[0])\n\t\tfactorsTemp = append(factorsTemp,\
    \ factorsTemp[0])\n\t\tfactorsTemp = append(factorsTemp, factorsTemp[0])\n\t\t\
    factorsTemp = append(factorsTemp, factorsTemp[0])\n\t\tfactorsTemp = append(factorsTemp,\
    \ factorsTemp[0])\n\t\tfactorsTemp = append(factorsTemp, factorsTemp[0])\n\t\t\
    factorsTemp = append(factorsTemp, factorsTemp[0])\n\t\tfactorsTemp = append(factorsTemp,\
    \ factorsTemp[0])\n\t\tfactorsTemp = append(factorsTemp, factorsTemp[0])\n\t\t\
    factorsTemp = append(factorsTemp, factorsTemp[0])\n\t\tfactorsTemp = append(factorsTemp,\
    \ factorsTemp[0])\n\t\tfactorsTemp = append(factorsTemp, factorsTemp[0])\n\n\t\
    \tfor index2 = 0; index2 < factorsTemp.count; index2++ {\n\t\t\tif factorsTemp[index2]\
    \ != 0 {\n\t\t\t\tfactorsTemp[index2] = largestPrimeFactor\n\t\t\t\tfactorsTemp[index2]\
    \ = factorsTemp[index2] * factorsTemp[index2]\n\t\t\t\tfactorsTemp[index2] = factorsTemp[index2]\
    \ + factorsTemp[index2]\n\t\t\t\tlargestPrimeFactor = factorsTemp[index2]\n\t\t\
    \t\tfactorsCounter++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tlargestPrimeFactor++\n\
    \tfor index = 0; index < factorsTemp.count; index++ {\n\t\tif factorsTemp[index]\
    \ != 0 {\n\t\t\tfactorsTemp[index] = largestPrimeFactor\n\t\t\tfactorsTemp[index]\
    \ = factorsTemp[index] * factorsTemp[index]\n\t\t\tfactorsTemp[index] = factorsTemp[index]\
    \ + factorsTemp[index]\n\t\t\tlargestPrimeFactor = factorsTemp[index] + 1\n\t\t\
    \tfactorsCounter++\n\t\t}\n\t}\n\n\tprimeFactors = factorsTemp\n\n\treturn primeFactors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp01qjum3t.swift:34:3: error: C-style for statement has been removed\
    \ in Swift 3\n                for index2 = 0; index2 < factorsTemp.count; index2++\
    \ {\n                ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp01qjum3t.swift:47:2:\
    \ error: C-style for statement has been removed in Swift 3\n        for index\
    \ = 0; index < factorsTemp.count; index++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp01qjum3t.swift:21:17: error: cannot find 'append' in scope\n         \
    \       factorsTemp = append(factorsTemp, factorsTemp[0])\n                  \
    \            ^~~~~~\n/tmp/tmp01qjum3t.swift:22:17: error: cannot find 'append'\
    \ in scope\n                factorsTemp = append(factorsTemp, factorsTemp[0])\n\
    \                              ^~~~~~\n/tmp/tmp01qjum3t.swift:23:17: error: cannot\
    \ find 'append' in scope\n                factorsTemp = append(factorsTemp, factorsTemp[0])\n\
    \                              ^~~~~~\n/tmp/tmp01qjum3t.swift:24:17: error: cannot\
    \ find 'append' in scope\n                factorsTemp = append(factorsTemp, factorsTemp[0])\n\
    \                              ^~~~~~\n/tmp/tmp01qjum3t.swift:25:17: error: cannot\
    \ find 'append' in scope\n                factorsTemp = append(factorsTemp, factorsTemp[0])\n\
    \                              ^~~~~~\n/tmp/tmp01qjum3t.swift:26:17: error: cannot\
    \ find 'append' in scope\n                factorsTemp = append(factorsTemp, factorsTemp[0])\n\
    \                              ^~~~~~\n/tmp/tmp01qjum3t.swift:27:17: error: cannot\
    \ find 'append' in scope\n                factorsTemp = append(factorsTemp, factorsTemp[0])\n\
    \                              ^~~~~~\n/tmp/tmp01qjum3t.swift:28:17: error: cannot\
    \ find 'append' in scope\n                factorsTemp = append(factorsTemp, factorsTemp[0])\n\
    \                              ^~~~~~\n/tmp/tmp01qjum3t.swift:29:17: error: cannot\
    \ find 'append' in scope\n                factorsTemp = append(factorsTemp, factorsTemp[0])\n\
    \                              ^~~~~~\n/tmp/tmp01qjum3t.swift:30:17: error: cannot\
    \ find 'append' in scope\n                facto"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [[Int]] = [[]]\n\
    \n    for currentNum in 2..<n+1 {\n        if n % currentNum == 0 {\n        \
    \    var factors: [[Int]] = result\n            for factor in result {\n     \
    \           if factor.contains(currentNum) {\n                    factors.remove(factor)\n\
    \                    break\n                } else {\n                    factor.append([currentNum])\n\
    \                }\n            }\n            result = factors\n        }\n \
    \   }\n\n    return result.map { $0.reduce(1, *+) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpaxag4twr.swift:19:29: error: no exact matches in call to instance\
    \ method 'remove'\n                    factors.remove(factor)\n              \
    \              ^\n/tmp/tmpaxag4twr.swift:19:29: note: candidate expects value\
    \ of type 'Int' for parameter #1 (got '[Int]')\n                    factors.remove(factor)\n\
    \                            ^\n/tmp/tmpaxag4twr.swift:19:29: note: candidate\
    \ expects value of type 'Array<[Int]>.Index' (aka 'Int') for parameter #1 (got\
    \ '[Int]')\n                    factors.remove(factor)\n                     \
    \       ^\n/tmp/tmpaxag4twr.swift:22:28: error: no exact matches in call to instance\
    \ method 'append'\n                    factor.append([currentNum])\n         \
    \                  ^\n/tmp/tmpaxag4twr.swift:22:28: note: found candidate with\
    \ type '(__owned [Int]) -> ()'\n                    factor.append([currentNum])\n\
    \                           ^\n/tmp/tmpaxag4twr.swift:29:39: error: unary operators\
    \ must not be juxtaposed; parenthesize inner expression\n    return result.map\
    \ { $0.reduce(1, *+) }\n                                      ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primes = Array(0..<Int(sqrt(Double(n))))\n\
    \    \n    var factorization = [Int]()\n    \n    for i in 0..<primes.count {\n\
    \        if n%primes[i] == 0 {\n            for j in primes[i..<primes.count]\
    \ {\n                if n%primes[j] == 0 {\n                    factorization.append(primes[j])\n\
    \                }\n            }\n            factorization.append(primes[i])\n\
    \        }\n    }\n    \n    return factorization\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9vek00mq.swift:12:32: error: cannot find 'sqrt' in scope\n    let\
    \ primes = Array(0..<Int(sqrt(Double(n))))\n                               ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 0 else { return\
    \ [] }\n    let maxCount = Double(n) / Int(sqrt(Double(n)))\n    var factors =\
    \ [Int]()\n    for count in stride(from: 2, through: Int(sqrt(Double(n))) + 1,\
    \ by: 1) {\n        if Double(n) / count < maxCount {\n            let factorsCount\
    \ = Int(sqrt(Double(n)) / count)\n            for i in stride(from: 1, through:\
    \ factorsCount, by: 1) {\n                factors.append(count*i)\n          \
    \  }\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppnhupop7.swift:13:36: error: cannot find 'sqrt' in scope\n    let\
    \ maxCount = Double(n) / Int(sqrt(Double(n)))\n                              \
    \     ^~~~\n/tmp/tmppnhupop7.swift:13:30: error: binary operator '/' cannot be\
    \ applied to operands of type 'Double' and 'Int'\n    let maxCount = Double(n)\
    \ / Int(sqrt(Double(n)))\n                   ~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmppnhupop7.swift:13:30: note: overloads for '/' exist with these partially\
    \ matching parameter lists: (Double, Double), (Int, Int)\n    let maxCount = Double(n)\
    \ / Int(sqrt(Double(n)))\n                             ^\n/tmp/tmppnhupop7.swift:15:47:\
    \ error: cannot find 'sqrt' in scope\n    for count in stride(from: 2, through:\
    \ Int(sqrt(Double(n))) + 1, by: 1) {\n                                       \
    \       ^~~~\n/tmp/tmppnhupop7.swift:17:36: error: cannot find 'sqrt' in scope\n\
    \            let factorsCount = Int(sqrt(Double(n)) / count)\n               \
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [1]\n    var\
    \ max = sqrt(n)\n    for x in\n        2 ..< max {\n        let s = result[x]\
    \ * x\n        if n % s == 0 { // if number is not prime - make it prime\n   \
    \         n /= s\n            result[x] += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprmqyv8dd.swift:13:15: error: cannot find 'sqrt' in scope\n    var\
    \ max = sqrt(n)\n              ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    factorize(n: n, factors: &factors)\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnkki5hyy.swift:13:30: error: extra argument 'factors' in call\n\
    \    factorize(n: n, factors: &factors)\n             ~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    \n    for factor in factorizationsOfN(n) {\n        factorization.append(factor)\n\
    \    }\n    \n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8j987g8d.swift:14:19: error: cannot find 'factorizationsOfN' in\
    \ scope\n    for factor in factorizationsOfN(n) {\n                  ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factorizer = PrimeFactorizer()\n\
    \    var factors = [Int]()\n    var temp = n\n    var isPrime = true\n    while\
    \ temp > 1 {\n        isPrime = true\n        for _ in 1...factorizer.count {\n\
    \            if temp % factorizer.isPrimes[Int(arc4random_uniform(UInt32(n)))]\
    \ == 0 {\n                isPrime = false\n                break\n           \
    \ }\n        }\n        if isPrime {\n            factors.append(temp)\n     \
    \       temp /= Int(arc4random_uniform(UInt32(factorizer.count)))\n        }\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7m3_xfca.swift:12:22: error: cannot find 'PrimeFactorizer' in scope\n\
    \    let factorizer = PrimeFactorizer()\n                     ^~~~~~~~~~~~~~~\n\
    /tmp/tmp7m3_xfca.swift:26:25: error: cannot find 'arc4random_uniform' in scope\n\
    \            temp /= Int(arc4random_uniform(UInt32(factorizer.count)))\n     \
    \                   ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = [n]\n    let factorizationIsPrime: () -> Bool = {\n        for i in factorization(where:\
    \ {x in x in 0}) {\n            if n % i == 0 {\n                return false\n\
    \            }\n        }\n        return true\n    }\n    for num in factorization\
    \ {\n        if isPrime(num) {\n            factorization.removeAll()\n      \
    \      return factorization\n        }\n    }\n    while true {\n        let nextFactorizationIsPrime\
    \ = factorizationIsPrime\n        if nextFactorizationIsPrime() {\n          \
    \  factorization.append(1)\n            return factorization\n        }\n    \
    \    factorization.append(nextFactorizationIsPrime() + 1)\n        factorization.removeFirst()\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6larcbyf.swift:14:46: error: consecutive statements on a line must\
    \ be separated by ';'\n        for i in factorization(where: {x in x in 0}) {\n\
    \                                             ^\n                            \
    \                 ;\n/tmp/tmp6larcbyf.swift:14:47: error: expected expression\n\
    \        for i in factorization(where: {x in x in 0}) {\n                    \
    \                          ^\n/tmp/tmp6larcbyf.swift:14:18: error: cannot call\
    \ value of non-function type '[Int]'\n        for i in factorization(where: {x\
    \ in x in 0}) {\n                 ^\n/tmp/tmp6larcbyf.swift:22:12: error: cannot\
    \ find 'isPrime' in scope\n        if isPrime(num) {\n           ^~~~~~~\n/tmp/tmp6larcbyf.swift:33:30:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'Int'\n\
    \        factorization.append(nextFactorizationIsPrime() + 1)\n              \
    \               ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorsArray: [Int]\
    \ = []\n    factorsArray.append(1)\n    var maxFactors = n\n    for factor in\
    \ 1...maxFactors {\n        if n % factor == 0 {\n            if factor > 1 {\n\
    \                factorsArray.append(factor)\n                n /= factor\n  \
    \          } else {\n                factorsArray.append(factor)\n           \
    \ }\n            if n > 1 {\n                factorsArray.append(n)\n        \
    \        maxFactors /= factor\n            }\n        }\n    }\n    factorsArray.append(n)\n\
    \    return factorsArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9vi_y45l.swift:19:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= factor\n            \
    \    ~ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [1]\n    var\
    \ primeFactorsCount = 0\n    var maxCount = 1\n    var factorization = factorizationFor(n)\n\
    \    for p in factorization {\n        if p == 1 {\n            result.append(2)\n\
    \            continue\n        }\n        var pFactorization = factorizationFor(p)\n\
    \        primeFactorsCount = pFactorization.count\n        for pf in pFactorization\
    \ {\n            if result[pf] == 0 {\n                result[pf] = maxCount\n\
    \                maxCount += 1\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuo350m4_.swift:15:25: error: cannot find 'factorizationFor' in\
    \ scope\n    var factorization = factorizationFor(n)\n                       \
    \ ^~~~~~~~~~~~~~~~\n/tmp/tmpuo350m4_.swift:21:30: error: cannot find 'factorizationFor'\
    \ in scope\n        var pFactorization = factorizationFor(p)\n               \
    \              ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 0 else { return\
    \ [] }\n    var factors = [1]\n    var divisor = [1]\n    var remainder = -1\n\
    \n    while remainder != 0 {\n        remainder = n % divisor\n        divisor\
    \ = factors[divisor]\n        factors = append(factors, divisor)\n        n =\
    \ remainder\n    }\n\n    return factors.reverse()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2c_ytz04.swift:18:25: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        remainder = n % divisor\n         \
    \               ^\n/tmp/tmp2c_ytz04.swift:19:26: error: no exact matches in call\
    \ to subscript \n        divisor = factors[divisor]\n                        \
    \ ^\n/tmp/tmp2c_ytz04.swift:19:26: note: found candidate with type '(Int) -> @lvalue\
    \ Int'\n        divisor = factors[divisor]\n                         ^\n/tmp/tmp2c_ytz04.swift:19:26:\
    \ note: found candidate with type '(Range<Int>) -> @lvalue ArraySlice<Int>'\n\
    \        divisor = factors[divisor]\n                         ^\n/tmp/tmp2c_ytz04.swift:19:26:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> ArraySlice<Int>'\n\
    \        divisor = factors[divisor]\n                         ^\n/tmp/tmp2c_ytz04.swift:19:26:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> @lvalue ArraySlice<Int>'\n\
    \        divisor = factors[divisor]\n                         ^\n/tmp/tmp2c_ytz04.swift:19:26:\
    \ error: no 'subscript' candidates produce the expected contextual result type\
    \ '[Int]'\n        divisor = factors[divisor]\n                         ^\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' produces 'Int', not the expected contextual result type\
    \ '[Int]'\n    @inlinable public subscript(index: Int) -> Element { get set }\n\
    \                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public subscript(bounds:\
    \ Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:3:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript(x: (UnboundedRange_) ->\
    \ ()) -> Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript(x: (UnboundedRange_) ->\
    \ ()) -> Self.SubSequence { get set }\n                      ^\n/tmp/"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    var primes: [Int] = []\n    var isPrime: [Bool] = []\n\n    // Calculating\
    \ factors\n    for i in 1..<n {\n        if n % i == 0 {\n            n /= i\n\
    \            factorization.append(i)\n            primes.append(i)\n         \
    \   isPrime.append(true)\n        } else {\n            factorization.append(i)\n\
    \            if isPrime[len(primes)-1] == true {\n                primes.append(i)\n\
    \                isPrime.append(true)\n            } else {\n                isPrime[len(primes)-1]\
    \ = false\n            }\n        }\n    }\n\n    return factorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppr279of8.swift:19:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmppr279of8.swift:25:24:\
    \ error: cannot find 'len' in scope\n            if isPrime[len(primes)-1] ==\
    \ true {\n                       ^~~\n/tmp/tmppr279of8.swift:29:25: error: cannot\
    \ find 'len' in scope\n                isPrime[len(primes)-1] = false\n      \
    \                  ^~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factor: Int\n    var factorCounter: Int = 0\n\n    var smallestPrime:\
    \ Int\n\n    if n >= 2 {\n        for factor in 2...n {\n            if n % factor\
    \ == 0 {\n                if factor == 1 {\n                    factors.append(factor)\n\
    \                } else {\n                    for i from 0...factors.count {\n\
    \                        if factors[i] == 1 {\n                            continue\n\
    \                        }\n\n                        factors.append(factor)\n\
    \                        factorCounter += factors[i]\n                       \
    \ break\n                    }\n                }\n                factorCounter\
    \ += factor\n                break\n            }\n        }\n    }\n\n    if\
    \ n == 1 {\n        factors.append(n)\n        return factors\n    }\n\n    for\
    \ factor in 2...n {\n        if n % factor == 0 {\n            if factor == 1\
    \ {\n                factors.append(factor)\n            } else {\n          \
    \      for i from 0...factors.count {\n                    if factors[i] == 1\
    \ {\n                        continue\n                    }\n               \
    \     factors.append(factor)\n                    factorCounter += factors[i]\n\
    \                    break\n                }\n            }\n            factorCounter\
    \ += factor\n            break\n        }\n    }\n\n    if factorCounter == 1\
    \ {\n        return factors\n    }\n\n    if factorCounter > 1 {\n        smallestPrime\
    \ = Int((n / 2) - 1) / 2\n    } else {\n        smallestPrime = 2\n    }\n\n \
    \   for factor in 2...smallestPrime {\n        if n % factor == 0 {\n        \
    \    if factor == 1 {\n                factors.append(factor)\n            } else\
    \ {\n                for i from 0...factors.count {\n                    if factors[i]\
    \ == 1 {\n                        continue\n                    }\n          \
    \          factors.append(factor)\n                    factorCounter += factors[i]\n\
    \                    break\n                }\n            }\n            factorCounter\
    \ += factor\n            break\n        }\n    }\n\n    if factorCounter == 1\
    \ {\n        return factors\n    }\n\n    if factorCounter > 1 {\n        for\
    \ factor in 2...smallestPrime {\n            if n % factor == 0 {\n          \
    \      if factor == 1 {\n                    factors.append(factor)\n        \
    \        } else {\n                    for i from 0...factors.count {\n      \
    \                  if factors[i] == 1 {\n                            continue\n\
    \                        }\n                        factors.append(factor)\n \
    \                       factorCounter += factors[i]\n                        break\n\
    \                    }\n                }\n                factorCounter += factor\n\
    \                break\n            }\n        }\n    }\n\n    if factorCounter\
    \ == 1 {\n        return factors\n    }\n\n    if factorCounter > 1 {\n      \
    \  factors.append(n)\n        for factor in 2...smallestPrime {\n            if\
    \ n % factor == 0 {\n                if factor == 1 {\n                    factors.append(factor)\n\
    \                } else {\n                    for i from 0...factors.count {\n\
    \                        if factors[i] == 1 {\n                            continue\n\
    \                        }\n                        factors.append(factor)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmpq5dji2.swift:24:27: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n                   \
    \ for i from 0...factors.count {\n                          ^\n/tmp/tmpmpq5dji2.swift:24:27:\
    \ note: join the identifiers together\n                    for i from 0...factors.count\
    \ {\n                        ~~^~~~\n                        ifrom\n/tmp/tmpmpq5dji2.swift:24:27:\
    \ note: join the identifiers together with camel-case\n                    for\
    \ i from 0...factors.count {\n                        ~~^~~~\n               \
    \         iFrom\n/tmp/tmpmpq5dji2.swift:24:32: error: expected 'in' after for-each\
    \ pattern\n                    for i from 0...factors.count {\n              \
    \                 ^\n/tmp/tmpmpq5dji2.swift:50:23: error: found an unexpected\
    \ second identifier in constant declaration; is there an accidental break?\n \
    \               for i from 0...factors.count {\n                      ^\n/tmp/tmpmpq5dji2.swift:50:23:\
    \ note: join the identifiers together\n                for i from 0...factors.count\
    \ {\n                    ~~^~~~\n                    ifrom\n/tmp/tmpmpq5dji2.swift:50:23:\
    \ note: join the identifiers together with camel-case\n                for i from\
    \ 0...factors.count {\n                    ~~^~~~\n                    iFrom\n\
    /tmp/tmpmpq5dji2.swift:50:28: error: expected 'in' after for-each pattern\n  \
    \              for i from 0...factors.count {\n                           ^\n\
    /tmp/tmpmpq5dji2.swift:79:23: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n                for i from\
    \ 0...factors.count {\n                      ^\n/tmp/tmpmpq5dji2.swift:79:23:\
    \ note: join the identifiers together\n                for i from 0...factors.count\
    \ {\n                    ~~^~~~\n                    ifrom\n/tmp/tmpmpq5dji2.swift:79:23:\
    \ note: join the identifiers together with camel-case\n                for i from\
    \ 0...factors.count {\n                    ~~^~~~\n                    iFrom\n\
    /tmp/tmpmpq5dji2.swift:79:28: error: expected 'in' after for-"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [0]\n    let\
    \ max = (n / 2) + (n % 2)\n    for _ in 0..<max {\n        var isFound = false\n\
    \        for j in 1..<n {\n            if n % j == 0 {\n                result[0]\
    \ += j\n                n /= j\n                isFound = true\n             \
    \   break\n            }\n        }\n        if !isFound {\n            result.append(n)\n\
    \        }\n    }\n    return Array(result[1..<result.count])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpolh8i56s.swift:19:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= j\n                ~\
    \ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 0 else {\n   \
    \     return []\n    }\n    let factorization: Set<Int> = factorization(n)\n \
    \   return factorization.map { _ in 1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1dk9ublv.swift:15:35: error: use of local variable 'factorization'\
    \ before its declaration\n    let factorization: Set<Int> = factorization(n)\n\
    \                                  ^\n/tmp/tmp1dk9ublv.swift:15:9: note: 'factorization'\
    \ declared here\n    let factorization: Set<Int> = factorization(n)\n        ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // check if all factors\
    \ are non-prime\n    var factorization = [Int]()\n    for factor in factorizationOfInt(n)\
    \ {\n        if factorization[factor] == 1 {\n            continue\n        }\n\
    \        let currentCount: Int = factorization[factor] + 1\n        if currentCount\
    \ > factorization.count {\n            factorization.reserveCapacity(currentCount)\n\
    \        }\n        factorization.append(currentCount)\n    }\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprz9z34sz.swift:14:19: error: cannot find 'factorizationOfInt' in\
    \ scope\n    for factor in factorizationOfInt(n) {\n                  ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let result = factorizeArray(n)\n\
    \    return result.map { Int($0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmph8n9vwlo.swift:12:18: error: cannot find 'factorizeArray' in scope\n\
    \    let result = factorizeArray(n)\n                 ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let max = UIntMax\n    if\
    \ n == max {\n        return factorize(n: max)\n    }\n    var product = 1\n \
    \   var factors = [Int]()\n    var factorization = [Int]()\n    factorization[0]\
    \ = n\n    for _ in 1...n {\n        product = product * factorization[factors.count\
    \ - 1]\n        factors.append(1)\n        for _ in 1...factors.count {\n    \
    \        if product % factorization[_] == 0 {\n                factors[_] = factors[_]\
    \ * factorization[_]\n                product /= factorization[_]\n          \
    \  } else {\n                factors[_] = factors[_] * factorization[_]\n    \
    \            break\n            }\n        }\n    }\n    return factors\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpeow67jx0.swift:12:15: error: cannot find 'UIntMax' in scope\n \
    \   let max = UIntMax\n              ^~~~~~~\n/tmp/tmpeow67jx0.swift:24:40: error:\
    \ '_' can only appear in a pattern or on the left side of an assignment\n    \
    \        if product % factorization[_] == 0 {\n                              \
    \         ^\n/tmp/tmpeow67jx0.swift:25:25: error: '_' can only appear in a pattern\
    \ or on the left side of an assignment\n                factors[_] = factors[_]\
    \ * factorization[_]\n                        ^\n/tmp/tmpeow67jx0.swift:26:42:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                product /= factorization[_]\n                               \
    \          ^\n/tmp/tmpeow67jx0.swift:28:25: error: '_' can only appear in a pattern\
    \ or on the left side of an assignment\n                factors[_] = factors[_]\
    \ * factorization[_]\n                        ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n    var factors: [Int] = []\n    for factor in factorization(n) {\n\
    \        if !contains(factors, factor) {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppex1h2ig.swift:16:19: error: cannot find 'factorization' in scope\n\
    \    for factor in factorization(n) {\n                  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return factorization(n:\
    \ n).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpiw1p6tuw.swift:12:12: error: cannot find 'factorization' in scope\n\
    \    return factorization(n: n).sorted()\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primes: [Int] = []\n\
    \    for i in 1..n {\n        for f in 2...i {\n            if n % f == 0 {\n\
    \                primes.append(f)\n                n /= f\n                break\n\
    \            }\n        }\n    }\n    return primes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppki9a6ff.swift:13:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..n {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // write your code in geeksforgeeks\
    \ IDE console\n    \n    let factor = BigInt(1) // factor to calculate power of\n\
    \    \n    var arr: [Int] = []\n    \n    for x in 2...n {\n        \n       \
    \ let power: BigInt = pow(BigInt(x), BigInt(n))\n        \n        let remainder:\
    \ BigInt = BigInt(n) - BigInt(x)\n        \n        if BigInt(power) < BigInt(remainder)\
    \ {\n            \n            arr.append(x)\n            \n            if BigInt(x)\
    \ == BigInt(n) {\n                break\n            }\n        }\n    }\n   \
    \ \n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp809g5bfh.swift:14:18: error: cannot find 'BigInt' in scope\n  \
    \  let factor = BigInt(1) // factor to calculate power of\n                 ^~~~~~\n\
    /tmp/tmp809g5bfh.swift:20:20: error: cannot find type 'BigInt' in scope\n    \
    \    let power: BigInt = pow(BigInt(x), BigInt(n))\n                   ^~~~~~\n\
    /tmp/tmp809g5bfh.swift:22:24: error: cannot find type 'BigInt' in scope\n    \
    \    let remainder: BigInt = BigInt(n) - BigInt(x)\n                       ^~~~~~\n\
    /tmp/tmp809g5bfh.swift:24:12: error: cannot find 'BigInt' in scope\n        if\
    \ BigInt(power) < BigInt(remainder) {\n           ^~~~~~\n/tmp/tmp809g5bfh.swift:24:28:\
    \ error: cannot find 'BigInt' in scope\n        if BigInt(power) < BigInt(remainder)\
    \ {\n                           ^~~~~~\n/tmp/tmp809g5bfh.swift:28:16: error: cannot\
    \ find 'BigInt' in scope\n            if BigInt(x) == BigInt(n) {\n          \
    \     ^~~~~~\n/tmp/tmp809g5bfh.swift:28:29: error: cannot find 'BigInt' in scope\n\
    \            if BigInt(x) == BigInt(n) {\n                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorization = factorize(n)\n    if factorization == nil {\n       \
    \ return factors\n    }\n\n    // Find prime factors\n    var primeFactorization:\
    \ [Int: Int] = [:]\n    for factor in factorization {\n        if primeFactorization[factor]\
    \ == nil {\n            primeFactorization[factor] = 1\n        } else {\n   \
    \         primeFactorization[factor] *= factor\n        }\n    }\n\n    // Reverse\
    \ factorization with reversed prime factors\n    var reversedFactorization: [Int:\
    \ Int] = [:]\n    for key in primeFactorization.keys {\n        reversedFactorization[primeFactorization[key]!]\
    \ = key\n    }\n\n    // Sort factors by number of multiplications\n    let sortedFactorization:\
    \ [Int: Int] = reversedFactorization.sorted {\n        ($0.key, $1.key) -> Bool\
    \ in\n        if $0.value <= $1.value {\n            return true\n        }\n\
    \        return false\n    }\n\n    // Update factor array\n    var factorIndex\
    \ = 0\n    for factorIndex in 0..<sortedFactorization.count {\n        let factor\
    \ = sortedFactorization[factorIndex]\n        factors += [factor]\n    }\n   \
    \ return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpzyzau0qq.swift:36:10: error: expected parameter name followed by\
    \ ':'\n        ($0.key, $1.key) -> Bool in\n         ^\n/tmp/tmpzyzau0qq.swift:36:18:\
    \ error: expected parameter name followed by ':'\n        ($0.key, $1.key) ->\
    \ Bool in\n                 ^\n/tmp/tmpzyzau0qq.swift:37:12: error: anonymous\
    \ closure arguments cannot be used inside a closure that has explicit arguments\n\
    \        if $0.value <= $1.value {\n           ^\n/tmp/tmpzyzau0qq.swift:37:24:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments\n        if $0.value <= $1.value {\n                    \
    \   ^\n/tmp/tmpzyzau0qq.swift:13:35: error: missing argument label 'n:' in call\n\
    \    var factorization = factorize(n)\n                                  ^\n \
    \                                 n: \n/tmp/tmpzyzau0qq.swift:47:21: error: cannot\
    \ convert value of type 'Int?' to expected element type 'Int'\n        factors\
    \ += [factor]\n                    ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar factors: [Int] = []\n\t\
    var currentFactor = Int(1)\n\tfor currentFactor * currentFactor <= n {\n\t\tif\
    \ n%currentFactor == 0 {\n\t\t\tfactors.append(currentFactor)\n\t\t\tn /= currentFactor\n\
    \t\t} else {\n\t\t\tcurrentFactor++\n\t\t}\n\t}\n\tfactors.append(n)\n\treturn\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpzdnsbkld.swift:14:20: error: expected 'in' after for-each pattern\n\
    \        for currentFactor * currentFactor <= n {\n                          ^\n\
    /tmp/tmpzdnsbkld.swift:14:20: error: unary operator cannot be separated from its\
    \ operand\n        for currentFactor * currentFactor <= n {\n                \
    \          ^~\n                           \n/tmp/tmpzdnsbkld.swift:14:20: error:\
    \ '*' is not a prefix unary operator\n        for currentFactor * currentFactor\
    \ <= n {\n                          ^\n/tmp/tmpzdnsbkld.swift:14:36: error: for-in\
    \ loop requires 'Bool' to conform to 'Sequence'\n        for currentFactor * currentFactor\
    \ <= n {\n                          ~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 1 else { return\
    \ [Int]() }\n\n    var factorization = [1]\n    var result = [1]\n    var n =\
    \ n\n\n    while n != 1 {\n        if n % 2 == 1 {\n            factorization[0]\
    \ += 1\n            n /= 2\n        } else {\n            n -= 1\n           \
    \ var factor: Int\n            var count = 1\n\n            for i in 0..<factorization[0]\
    \ {\n                if factorization[i] > count {\n                    factor\
    \ = i\n                    count = factorization[i]\n                }\n     \
    \       }\n\n            result[0] = factor * result[0]\n            factorization[0]\
    \ -= 1\n            n /= factor\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnlgwtjxz.swift:34:25: error: variable 'factor' used before being\
    \ initialized\n            result[0] = factor * result[0]\n                  \
    \      ^\n/tmp/tmpnlgwtjxz.swift:24:17: note: variable defined here\n        \
    \    var factor: Int\n                ^\n/tmp/tmpnlgwtjxz.swift:36:18: error:\
    \ variable 'factor' used before being initialized\n            n /= factor\n \
    \                ^\n/tmp/tmpnlgwtjxz.swift:24:17: note: variable defined here\n\
    \            var factor: Int\n                ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = []\n    let maxFactorization = Int(ceil(sqrt(Double(n))))\n    \n    for factor\
    \ in 1...maxFactorization {\n        if n / factor > 1 {\n            factorization\
    \ = [Int]()\n            var factorIndex = 0\n            for number in 1...n\
    \ / factor {\n                if factor % number == 0 {\n                    factorization.append(factor)\n\
    \                    factorIndex = factorIndex + 1\n                }\n      \
    \      }\n            for _ in 0..<abs(Int(factorIndex) - factorization.count)\
    \ {\n                factorization.append(0)\n            }\n            if n\
    \ == (factorization[0]! * factorization[factorization.count-1]!) {\n         \
    \       return factorization\n            }\n        }\n    }\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpoikv11ws.swift:13:32: error: cannot find 'ceil' in scope\n    let\
    \ maxFactorization = Int(ceil(sqrt(Double(n))))\n                            \
    \   ^~~~\n/tmp/tmpoikv11ws.swift:13:37: error: cannot find 'sqrt' in scope\n \
    \   let maxFactorization = Int(ceil(sqrt(Double(n))))\n                      \
    \              ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primes = [2, 3, 5, 7]\n\
    \    var factors = [Int]()\n    var primeFactors = Int(1)\n    var multiple =\
    \ 2\n    let max = (sqrt(Double(n)) / Double(primes.last!)).toInt()\n\n    for\
    \ _ in 0..<max {\n        if n % prime == 0 {\n            primeFactors *= primes.last!\n\
    \            factors.append(primeFactors)\n            n /= prime\n        } else\
    \ {\n            primeFactors *= multiple\n            factors.append(multiple)\n\
    \        }\n        multiple += 2\n    }\n    factors.append(n)\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpzy4_s0vt.swift:16:16: error: cannot find 'sqrt' in scope\n    let\
    \ max = (sqrt(Double(n)) / Double(primes.last!)).toInt()\n               ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: -1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primes = factorize(n:\
    \ n)\n    var result = [Int]()\n    var sum = 0\n    for x in primes {\n     \
    \   sum += x\n        result.append(x)\n    }\n    result.append((sum / result.count)\
    \ - 2)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    if n <= 1 {\n        return factors\n    }\n    var n = n\n    var primeFactorsFound\
    \ = false\n    var primeFactors: Set<Int> = []\n    for i := 2; i <= Int(sqrt(Double(n)));\
    \ i++ {\n        if isPrime(i) {\n            for _ in  primeFactors  {\n    \
    \            if i == _ {\n                    primeFactorsFound = true\n     \
    \               break\n                }\n            }\n            if primeFactorsFound\
    \ == false {\n                primeFactorsFound = true\n                primeFactors.append(i)\n\
    \                factors.append(i)\n            }\n        }\n    }\n    guard\
    \ primeFactorsFound == true else {\n        return factors\n    }\n    for i in\
    \  primeFactors {\n        factors.append(n)\n        n = n / i\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxua8dq95.swift:19:12: error: expected type\n    for i := 2; i <=\
    \ Int(sqrt(Double(n))); i++ {\n           ^\n            <#type#>\n/tmp/tmpxua8dq95.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 2; i <= Int(sqrt(Double(n)));\
    \ i++ {\n           ^\n/tmp/tmpxua8dq95.swift:19:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 2; i <= Int(sqrt(Double(n))); i++\
    \ {\n           ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var x = 1\n    while x <= n {\n        if n % x == 0 {\n            x = x\
    \ * 2\n            if x > n {\n                while x > n {\n               \
    \     x = x / 2\n                }\n                factorization.append(x)\n\
    \            } else {\n                while x < n {\n                    x =\
    \ x * 2\n                }\n                factorization.append(x)\n        \
    \    }\n        }\n        x++\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8qdgrtp4.swift:29:10: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        x++\n         ^~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var prime = 1\n    for _ in 1...n {\n        if n % (prime * prime) == 0\
    \ {\n            factors.append(prime)\n        }\n        prime += 1\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpfpr8eej0/tmpfpr8eej0.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af98d7d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af98d4cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af98d4cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af98d4ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfpr8eej0                        0x000055f15e2cd5b2 <unavailable> + 5554

    5    libc.so.6                          0x00002af98d9c0460 __libc_start_main +
    245

    6    tmpfpr8eej0                        0x000055f15e2cd209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n >= 2, \"\
    Number must be greater than 2\")\n    var factors = [1]\n    for factor in 2...n\
    \ {\n        var newFactor = factor\n        for i in  factors.indices{\n    \
    \        newFactor *= factors[i]\n        }\n        factors.append(newFactor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp3qy3wfmw/tmp3qy3wfmw.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b18c59eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b18c56e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b18c56e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b18c56e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3qy3wfmw                        0x000056359b6d97b2 <unavailable> + 6066

    5    libc.so.6                          0x00002b18c5bd6460 __libc_start_main +
    245

    6    tmp3qy3wfmw                        0x000056359b6d9409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    for factor: Int in 2..<n {\n        var product = 1\n        for i: Int in\
    \ 2..<factor {\n            product *= i\n        }\n        if product == n {\n\
    \            factors.append(factor)\n        }\n    }\n    return factors\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp6e29m3ou/tmp6e29m3ou.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4baefdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4babf4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4babf4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4babf37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6e29m3ou                        0x0000558bbae7e5b2 <unavailable> + 5554

    5    libc.so.6                          0x00002ac4bb0e9460 __libc_start_main +
    245

    6    tmp6e29m3ou                        0x0000558bbae7e209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var x = 1\n    while x > 1 {\n        if x % n == 0 {\n            x /= n\n\
    \            factorization[factorization.count] = x\n            factorization\
    \ = factorization.sorted{$0 < $1}\n        }\n        else {\n            x /=\
    \ n\n        }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmp0ttkps1e/tmp0ttkps1e.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab074fd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab074cc8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab074cc8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab074cc77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0ttkps1e                        0x000055b859702582 <unavailable> + 5506

    5    libc.so.6                          0x00002ab0751bd460 __libc_start_main +
    245

    6    tmp0ttkps1e                        0x000055b8597021d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let digits = [Int](1...n)\n\
    \    \n    let result = factorization(digits)\n    \n    var factors: [Int] =\
    \ []\n    for index in 0...result.count {\n        if result[index] != 1 {\n \
    \           factors.append(result[index])\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpem0b004n.swift:14:18: error: cannot find 'factorization' in scope\n\
    \    let result = factorization(digits)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\n\
    \    for prime in 2..<n {\n        if n % prime == 0 {\n            factors.append(prime)\n\
    \            n /= prime\n        }\n    }\n\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp9wcks1u9.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= prime\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n\n    var factors = [Int]()\n    var isDivisor = false\n\n    for\
    \ currentFactor = 2; currentFactor <= n; currentFactor *= 2 {\n        if n%currentFactor\
    \ == 0 {\n            factors.append(currentFactor)\n            n /= currentFactor\n\
    \        } else {\n            if isDivisor {\n                factors.append(currentFactor)\n\
    \            } else {\n                factors.append(1)\n                isDivisor\
    \ = true\n            }\n        }\n    }\n\n    if n > 1 {\n        factors.append(n)\n\
    \    }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsz2gni7o.swift:19:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for currentFactor = 2; currentFactor <= n; currentFactor *=\
    \ 2 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 0 else {\n   \
    \     return []\n    }\n\n    var result = [Int]()\n\n    var i = 0\n    for n\
    \ in 2..<n {\n        if n % i == 0 {\n            result.append(i)\n        \
    \    while n % i == 0 {\n                n /= i\n                i += 1\n    \
    \        }\n        } else {\n            result.append(n)\n        }\n    }\n\
    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpatlfi26w.swift:23:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= i\n                ~\
    \ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var arr = Array<Int>()\n\
    \    for d in 2...n {\n        for f in 2...d {\n            if n % f == 0 {\n\
    \                arr.append(f)\n                n /= f\n            }\n      \
    \  }\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt6wqcj25.swift:17:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= f\n                ~\
    \ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var product = n\n\
    \    var factors = []\n    var primes = []\n    var factorsIndex = 0\n    \n \
    \   while product % 2 != 0 {\n        factorsIndex = 0\n        if product % 2\
    \ != 0 {\n            factors.append(2)\n            product /= 2\n          \
    \  factorsIndex += 1\n        }\n        \n        while product % 3 != 0 {\n\
    \            factorsIndex += 1\n            factors.append(3)\n            product\
    \ /= 3\n        }\n        \n        for var i = 4; i <= Int(sqrt(Double(product)));\
    \ i++ {\n            \n            var isPrime = true\n            var isDivisible\
    \ = false\n            \n            while i * i <= product && !isPrime {\n  \
    \              if product % i == 0 {\n                    isPrime = false\n  \
    \                  break\n                }\n                \n              \
    \  i += 1\n            }\n            \n            if isPrime {\n           \
    \     primes.append(i)\n                \n                if isDivisible {\n \
    \                   factors.append(i)\n                    factorsIndex += 1\n\
    \                }\n                \n                product /= i\n         \
    \   }\n        }\n    }\n    \n    if product > 1 {\n        primes.append(product)\n\
    \    }\n    \n    if factorsIndex != factors.count {\n        factors.append(product)\n\
    \    }\n    \n    return primes.reverse().map {\n        Int($0)\n    }.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1_aolzbv.swift:32:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for var i = 4; i <= Int(sqrt(Double(product))); i++ {\n\
    \        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1_aolzbv.swift:14:19:\
    \ error: empty collection literal requires an explicit type\n    var factors =\
    \ []\n                  ^~\n/tmp/tmp1_aolzbv.swift:15:18: error: empty collection\
    \ literal requires an explicit type\n    var primes = []\n                 ^~\n\
    /tmp/tmp1_aolzbv.swift:67:29: error: value of tuple type '()' has no member 'map'\n\
    \    return primes.reverse().map {\n           ~~~~~~~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n\n    var factors = [1]\n    var remainder: Int\n    var temp: Int\n\
    \    var factorization: [Int]\n\n    for factor in 2...n {\n        if n % factor\
    \ == 0 {\n            temp = 1\n            for _ in 2...factor {\n          \
    \      temp *= factor\n            }\n            factors.append(temp)\n     \
    \       remainder = n / temp\n            n = temp\n        }\n    }\n\n    factorization\
    \ = factors.reverse()\n\n    if remainder == 0 {\n        factorization.append(n)\n\
    \    }\n\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbu0q6o_a.swift:29:13: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n            n = temp\n            ^\n/tmp/tmpbu0q6o_a.swift:33:29:\
    \ error: cannot assign value of type '()' to type '[Int]'\n    factorization =\
    \ factors.reverse()\n                    ~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n    var num: Int = n\n    var result: [Int] = []\n    var factor\
    \ = 2\n\n    while factor <= num {\n        while num % factor == 0 {\n      \
    \      result.append(factor)\n            num /= factor\n        }\n        factor++\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpu6h1b8fk.swift:24:15: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        factor++\n              ^~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \n    for factor in factorize(n) {\n        result.append(factor)\n    }\n\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcwiof25r.swift:14:29: error: missing argument label 'n:' in call\n\
    \    for factor in factorize(n) {\n                            ^\n           \
    \                 n: \n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n != 0 else { return\
    \ [] }\n    var factors = [1]\n    for d in 2...n {\n        if n > d { return\
    \ factors }\n        if n % d == 0 {\n            factors[factors.count-1] *=\
    \ d\n            n /= d\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyvarg0_t.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= d\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n\tvar prime: PrimeFactors =\
    \ PrimeFactors()\n\tprime.isPrime(n)\n\tvar factors = [Int]()\n\tvar k = prime.factors.count\n\
    \tvar j = 0\n\tvar i = 2\n\twhile i < k {\n\t\tj = i*i\n\t\ti = i + 2\n\t\tif\
    \ j > n {\n\t\t\tbreak\n\t\t}\n\t\tif j < n {\n\t\t\tfactors.append(j)\n\t\t}\n\
    \t}\n\treturn factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppi_nrq3o.swift:12:13: error: cannot find type 'PrimeFactors' in\
    \ scope\n        var prime: PrimeFactors = PrimeFactors()\n                  \
    \ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n <= 1 {\n        return\
    \ [1]\n    }\n    var factorsDict: [Int: Int] = [:]\n    for factor in factorize(n:\
    \ n) {\n        factorsDict[factor] = factorsDict[factor] + 1\n    }\n    var\
    \ result = [Int]()\n    for k in factorsDict {\n        result.append(k)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp34plibqx.swift:17:42: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        factorsDict[factor] = factorsDict[factor]\
    \ + 1\n                                         ^\n/tmp/tmp34plibqx.swift:17:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        factorsDict[factor] = factorsDict[factor] + 1\n             \
    \                            ^\n                              (              \
    \     ?? <#default value#>)\n/tmp/tmp34plibqx.swift:17:42: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        factorsDict[factor]\
    \ = factorsDict[factor] + 1\n                                         ^\n    \
    \                                             !\n/tmp/tmp34plibqx.swift:21:23:\
    \ error: cannot convert value of type '(key: Int, value: Int)' to expected argument\
    \ type 'Int'\n        result.append(k)\n                      ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var factorization = [Int]()\n\
    \  factorization[0] = n\n  var primes = [Int]()\n  var maxp = 2\n  factorize(factorization,\
    \ primes, maxp)\n  return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd97paxb5.swift:16:12: error: extra arguments at positions #2, #3\
    \ in call\n  factorize(factorization, primes, maxp)\n           ^\n/tmp/tmpd97paxb5.swift:11:6:\
    \ note: 'factorize(n:)' declared here\nfunc factorize(n: Int) -> [Int] {\n   \
    \  ^\n/tmp/tmpd97paxb5.swift:16:13: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n  factorize(factorization, primes, maxp)\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var primes = [Int]()\n    var result = 1\n    let maxFactorization = Int(sqrt(Double(n)))\n\
    \n    primes = primeFactors(n)\n\n    for i in 2...maxFactorization {\n      \
    \  if !contains(primes, i) {\n            for j in 2...i {\n                if\
    \ n % i == 0 {\n                    result *= i\n                    result /=\
    \ j\n                    factorization = append(factorization, j)\n          \
    \          factorization = append(factorization, result)\n                   \
    \ break\n                }\n            }\n        }\n    }\n\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgpa9rit7.swift:15:32: error: cannot find 'sqrt' in scope\n    let\
    \ maxFactorization = Int(sqrt(Double(n)))\n                               ^~~~\n\
    /tmp/tmpgpa9rit7.swift:17:14: error: cannot find 'primeFactors' in scope\n   \
    \ primes = primeFactors(n)\n             ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factorizer = Factorizer()\n\
    \    return factorizer.factorize(n: n)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1qizptak.swift:12:22: error: cannot find 'Factorizer' in scope\n\
    \    let factorizer = Factorizer()\n                     ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n > 0, \"The\
    \ given number should be positive\")\n    var factorsCount: [Int] = []\n    var\
    \ factorization: [Int] = [Int]()\n\n    for num in factorizeNumber(n) {\n    \
    \    factorization = [Int](repeatElement(0, count: num))\n        for (i, j) in\
    \ factorization.enumerated() {\n            if num % i == 0 {\n              \
    \  factorization[j] = i\n                factorsCount = [Int](repeatElement(0,\
    \ count: j + 1))\n                factorsCount[j] = factorsCount.count + 1\n \
    \               num -= 1\n            }\n        }\n    }\n\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq_ttgfk7.swift:16:16: error: cannot find 'factorizeNumber' in scope\n\
    \    for num in factorizeNumber(n) {\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n\n    var factors = [Int]()\n    for d in 2...n {\n        if n %\
    \ d == 0 {\n            for _ in 1...n / d {\n                factors.append(d)\n\
    \            }\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpdgzodu3d/tmpdgzodu3d.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0070d8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0070a85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0070a85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0070a847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdgzodu3d                        0x000055581764568f <unavailable> + 5775

    5    libc.so.6                          0x00002b0070f7a460 __libc_start_main +
    245

    6    tmpdgzodu3d                        0x0000555817645209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let limit = sqrt(Double(n))\n\
    \    var factors = [Int]()\n    var current: Int = 0\n    for number in 1...limit\
    \ {\n        if n % number == 0 {\n            current += 1\n            while\
    \ current < number {\n                factors += [number]\n                current\
    \ *= number\n            }\n        }\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqvcwpkk3.swift:12:17: error: cannot find 'sqrt' in scope\n    let\
    \ limit = sqrt(Double(n))\n                ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let maxFact = Int(sqrt(Double(n)))\n\
    \    var factorization = [Int]()\n    for i in 0..<maxFact {\n        var product\
    \ = n * i \n        for j in 0..<i {\n            product /= i\n        }\n  \
    \      for j in 0..<maxFact {\n            let jFactor = product % j\n       \
    \     if jFactor != 0 {\n                factorization[j] += 1\n            }\n\
    \        }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpybwubppi.swift:12:23: error: cannot find 'sqrt' in scope\n    let\
    \ maxFact = Int(sqrt(Double(n)))\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ [1]\n    }\n    var factorization = [Int]()\n    var factor = 1\n    for n in\
    \ 2...n {\n        if n % 2 == 0 {\n            factor *= n\n            continue\n\
    \        }\n        for _ in 0..n / 2 {\n            if n % factor == 0 {\n  \
    \              factorization.append(factor)\n                factor *= n\n   \
    \             factor += 1\n                break\n            }\n            factor\
    \ += 1\n        }\n    }\n    if factor > 1 {\n        factorization.append(factor)\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfwcabm7w.swift:22:19: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n        for _ in 0..n / 2 {\n                  ^~\n   \
    \               ...\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    for i in 2..<n {\n        for j in 2..<n {\n            if j != i {\n   \
    \             for k in 2..<n {\n                    if k > i {\n             \
    \           if k%i == 0 {\n                            factorization.append(i)\n\
    \                            factorization.append(j)\n                       \
    \     factorization.append(k)\n                        }\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp895ms6jf/tmp895ms6jf.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae86d5dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae86d2d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae86d2d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae86d2d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp895ms6jf                        0x00005651782525b2 <unavailable> + 5554

    5    libc.so.6                          0x00002ae86d7c6460 __libc_start_main +
    245

    6    tmp895ms6jf                        0x0000565178252209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n <= 1 {\n        return\
    \ [Int(1)]\n    }\n\n    var factorization: [Int]\n    if isPrime(n) {\n     \
    \   factorization = factorizationOfPrime(n)\n    }\n    else {\n        factorization\
    \ = factorizationOfNotPrime(n)\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp42i7rzzo.swift:17:8: error: cannot find 'isPrime' in scope\n  \
    \  if isPrime(n) {\n       ^~~~~~~\n/tmp/tmp42i7rzzo.swift:18:25: error: cannot\
    \ find 'factorizationOfPrime' in scope\n        factorization = factorizationOfPrime(n)\n\
    \                        ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp42i7rzzo.swift:21:25: error:\
    \ cannot find 'factorizationOfNotPrime' in scope\n        factorization = factorizationOfNotPrime(n)\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    func find(n: Int, max: Int)\
    \ -> Int {\n        if n == max { return n }\n        if max % n == 0 {\n    \
    \        return n\n        }\n        return find(n + (max % n), 1)\n    }\n \
    \   let n = n\n    var res: [Int] = []\n    var max = n\n    var cur = 1\n   \
    \ repeat {\n        res.append(cur)\n        cur = find(cur, max)\n        max\
    \ = cur\n    } while cur != 1\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnn0fwswi.swift:17:20: error: missing argument labels 'n:max:' in\
    \ call\n        return find(n + (max % n), 1)\n                   ^\n        \
    \            n:             max: \n/tmp/tmpnn0fwswi.swift:25:19: error: missing\
    \ argument labels 'n:max:' in call\n        cur = find(cur, max)\n           \
    \       ^\n                   n:   max: \n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factorization = factorizationOfNumbers(n: n)\n    for number in factorization\
    \ {\n        guard number != 0 else { return factors }\n        let factor = number\
    \ > 1 ? number : n\n        var currentFactors = [Int]()\n        for _ in 0..<number\
    \ {\n            guard let factor = factorization.firstIndex(of: factor) else\
    \ {\n                return factors\n            }\n            currentFactors.append(factor)\n\
    \            factorization.remove(at: factor)\n        }\n        factors.append(currentFactors)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2mm27wwv.swift:13:25: error: cannot find 'factorizationOfNumbers'\
    \ in scope\n    var factorization = factorizationOfNumbers(n: n)\n           \
    \             ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var result = [1]\n  for factor\
    \ in factorize(n) {\n    result.append(factor * result[result.count - 1])\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpno5_8iex.swift:13:27: error: missing argument label 'n:' in call\n\
    \  for factor in factorize(n) {\n                          ^\n               \
    \           n: \n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var primes = [Int]()\n    var factorization: [Int] = [0]\n    var maxFactorization\
    \ = 0\n\n    // Scan factorization array from end\n    for indexToRemove in stride(from:\
    \ factorization.count - 1, through: 0, by: -1) {\n        let value = factorization[indexToRemove]\n\
    \n        // Move element one to the left\n        factorization.removeAtIndex(indexToRemove)\n\
    \        factorization.removeLast()\n\n        // Check prime number\n       \
    \ if value > 1 {\n            factors.append(value)\n            primes.append(Int(sqrt(Double(value))))\n\
    \        }\n\n        // Check factor count\n        if value > maxFactorization\
    \ {\n            maxFactorization = value\n        }\n    }\n\n    // Sort array\n\
    \    factorization = factorization.sorted()\n\n    // Add remaining values from\
    \ factorization array\n    factors.appendContentsOf(factorization)\n\n    // Reverse\
    \ factorization array\n    factorization.reverse()\n\n    // Convert arrays to\
    \ array of prime factors\n    return primes.map { $0 * Int($1) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpix4dhg41.swift:22:23: error: value of type '[Int]' has no member\
    \ 'removeAtIndex'\n        factorization.removeAtIndex(indexToRemove)\n      \
    \  ~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpix4dhg41.swift:28:31: error: cannot find\
    \ 'sqrt' in scope\n            primes.append(Int(sqrt(Double(value))))\n     \
    \                         ^~~~\n/tmp/tmpix4dhg41.swift:41:13: error: value of\
    \ type '[Int]' has no member 'appendContentsOf'\n    factors.appendContentsOf(factorization)\n\
    \    ~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpix4dhg41.swift:47:23: error: contextual\
    \ closure type '(Int) throws -> Int' expects 1 argument, but 2 were used in closure\
    \ body\n    return primes.map { $0 * Int($1) }\n                      ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [1]\n    let\
    \ factorizationsCount = factorizationCount(n)\n    var max = 0\n    for i in 0..<factorizationsCount\
    \ {\n        result[i * 2] = i\n        if max < result[i * 2] * n {\n       \
    \     max = result[i * 2] * n\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpsx90h0rn.swift:13:31: error: cannot find 'factorizationCount' in\
    \ scope\n    let factorizationsCount = factorizationCount(n)\n               \
    \               ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    switch factorization(n)\
    \ {\n    case .Empty:\n        return []\n    case .Some(factorization(n)):\n\
    \        return factorization(n).factors\n    }\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8o8p1cjm.swift:12:12: error: cannot find 'factorization' in scope\n\
    \    switch factorization(n) {\n           ^~~~~~~~~~~~~\n/tmp/tmp8o8p1cjm.swift:16:16:\
    \ error: cannot find 'factorization' in scope\n        return factorization(n).factors\n\
    \               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n >= 1, \"\
    n must be greater than or equal to 1\")\n    let array = [Int]()\n    var lastIndex\
    \ = n - 1\n    var factor = 2\n    while lastIndex ~= 0 {\n        if n > lastIndex\
    \ {\n            n -= lastIndex\n            array.append(factor)\n          \
    \  lastIndex -= 1\n            factor = 2\n        }\n        if n % factor ==\
    \ 0 {\n            n /= factor\n            array.append(factor)\n           \
    \ factor++\n        } else {\n            factor++\n        }\n    }\n    array.append(n)\n\
    \    return array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3e4gunxu.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n -= lastIndex\n            ~\
    \ ^\n/tmp/tmp3e4gunxu.swift:19:19: error: cannot use mutating member on immutable\
    \ value: 'array' is a 'let' constant\n            array.append(factor)\n     \
    \       ~~~~~ ^\n/tmp/tmp3e4gunxu.swift:13:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let array = [Int]()\n    ^~~\n    var\n/tmp/tmp3e4gunxu.swift:24:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= factor\n            ~ ^\n/tmp/tmp3e4gunxu.swift:25:19: error:\
    \ cannot use mutating member on immutable value: 'array' is a 'let' constant\n\
    \            array.append(factor)\n            ~~~~~ ^\n/tmp/tmp3e4gunxu.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let array = [Int]()\n  \
    \  ^~~\n    var\n/tmp/tmp3e4gunxu.swift:26:19: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n            factor++\n                  ^~\n\
    /tmp/tmp3e4gunxu.swift:28:19: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n            factor++\n                  ^~\n/tmp/tmp3e4gunxu.swift:31:11:\
    \ error: cannot use mutating member on immutable value: 'array' is a 'let' constant\n\
    \    array.append(n)\n    ~~~~~ ^\n/tmp/tmp3e4gunxu.swift:13:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let array = [Int]()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var isPrime: [Bool] = Array<Bool>(repeating: false, count: n)\n\n    for\
    \ i in 0..<n {\n        isPrime[i] = true\n    }\n\n    for i in 2..<n {\n   \
    \     if isPrime[i] == true {\n            for j in 2..<n {\n                if\
    \ j % i == 0 {\n                    isPrime[j] = false\n                    break\n\
    \                }\n            }\n        }\n    }\n\n    for i in 2..<n {\n\
    \        if isPrime[i] == true {\n            factors.append(i)\n        }\n \
    \   }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp3cjvrl0o/tmp3cjvrl0o.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8fa574fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fa5446b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fa5446988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fa54457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3cjvrl0o                        0x000055c273d65692 <unavailable> + 5778

    5    libc.so.6                          0x00002b8fa593b460 __libc_start_main +
    245

    6    tmp3cjvrl0o                        0x000055c273d652e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return factorization(n).map\
    \ { $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe4ooa70y.swift:12:12: error: cannot find 'factorization' in scope\n\
    \    return factorization(n).map { $0 }\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return factorize(n: n, primes:\
    \ primeFactors(n))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz0zw0qc0.swift:12:36: error: cannot find 'primeFactors' in scope\n\
    \    return factorize(n: n, primes: primeFactors(n))\n                       \
    \            ^~~~~~~~~~~~\n/tmp/tmpz0zw0qc0.swift:12:36: error: extra argument\
    \ 'primes' in call\n    return factorize(n: n, primes: primeFactors(n))\n    \
    \                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factorsCount = [Int]()\n    \n    for number in factorsCount {\n    \
    \    \n        for _ in 0...number {\n            factors.append(0)\n        }\n\
    \        factorsCount[number] = 1\n        \n        var isPrime = true\n    \
    \    \n        for i in 2...number {\n            if number % i == 0 {\n     \
    \           isPrime = false\n                break\n            }\n        }\n\
    \        if isPrime {\n            for j in 2...number {\n                if number\
    \ % j == 0 {\n                    factors[number] += j\n                    break\n\
    \                }\n            }\n        }\n    }\n    \n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpxwpouawr/tmpxwpouawr.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b96666dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b96663d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b96663d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b96663d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxwpouawr                        0x000055f6209c1772 <unavailable> + 6002

    5    libc.so.6                          0x00002b96668c7460 __libc_start_main +
    245

    6    tmpxwpouawr                        0x000055f6209c13c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var p = Int(n)\n    var\
    \ f = [Int]()\n    var i = 0\n    var factor = 2\n\n    while p > 1 {\n      \
    \  while p % factor == 0 {\n            p /= factor\n            i += 1\n    \
    \    }\n\n        factor += 2\n        p.isMultiple(factor) && f.append(factor)\n\
    \    }\n\n    f.reverse()\n    return f\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbhtr0fdy.swift:24:22: error: missing argument label 'of:' in call\n\
    \        p.isMultiple(factor) && f.append(factor)\n                     ^\n  \
    \                   of: \n/tmp/tmpbhtr0fdy.swift:24:35: error: cannot convert\
    \ value of type '()' to expected argument type 'Bool'\n        p.isMultiple(factor)\
    \ && f.append(factor)\n                                  ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var remainder = n\n\n    // find factors until remainder becomes 0\n    while\
    \ remainder > 1 {\n        var factor = 1\n\n        // find smallest factor using\
    \ Euclid's formula\n        while remainder % factor == 0 {\n            factor\
    \ += 1\n        }\n\n        // if remainder was even, increment factor\n    \
    \    remainder = remainder / factor\n        factors.append(factor)\n    }\n\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp290f_yqz/tmp290f_yqz.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2be7810c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2be7507b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2be7507988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2be75067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp290f_yqz                        0x000055f542a814c2 <unavailable> + 5314

    5    libc.so.6                          0x00002b2be79fc460 __libc_start_main +
    245

    6    tmp290f_yqz                        0x000055f542a81119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let result = [1]\n    let\
    \ factorization = factorizeNumber(n)\n    for currentNumber in factorization {\n\
    \        if result.contains(currentNumber) {\n            continue\n        }\n\
    \        result.append(currentNumber)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4f82gn28.swift:13:25: error: cannot find 'factorizeNumber' in scope\n\
    \    let factorization = factorizeNumber(n)\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    factorize1(&n, &factors)\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplb36ameg.swift:13:5: error: cannot find 'factorize1' in scope\n\
    \    factorize1(&n, &factors)\n    ^~~~~~~~~~\n/tmp/tmplb36ameg.swift:13:16: error:\
    \ cannot pass immutable value as inout argument: 'n' is a 'let' constant\n   \
    \ factorize1(&n, &factors)\n               ^~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \n    for factor in factorization(toInt64(n)) {\n        factors.append(factor)\n\
    \    }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2ujkklv3.swift:14:19: error: cannot find 'factorization' in scope\n\
    \    for factor in factorization(toInt64(n)) {\n                  ^~~~~~~~~~~~~\n\
    /tmp/tmp2ujkklv3.swift:14:33: error: cannot find 'toInt64' in scope\n    for factor\
    \ in factorization(toInt64(n)) {\n                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n == n)\n \
    \   if n < 2 {\n        return []\n    }\n    var primeFactors = [1]\n    var\
    \ primeFactorsCount = [Int]()\n    for factor in primeFactors {\n        primeFactorsCount[factor]\
    \ += 1 // count[factor]++\n    }\n    for factor in primeFactors {\n        primeFactorsCount[factor]\
    \ /= 2 // count[factor] /= 2\n        for multiplier in 2...n {\n            if\
    \ primeFactorsCount[factor] > 0 && n % multiplier == 0 {\n                primeFactorsCount[factor]\
    \ -= 1 // count[factor]--\n                break\n            }\n        }\n \
    \       if primeFactorsCount[factor] == 0 {\n            primeFactors.append(factor)\n\
    \        }\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2627e20c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2627b17561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2627b17286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2627b1713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2627b16bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b26279167ec <unavailable> + 186348

    6    tmp4t5b7555                        0x00005557b5d4414d <unavailable> + 8525

    7    tmp4t5b7555                        0x00005557b5d436fb <unavailable> + 5883

    8    libc.so.6                          0x00002b262800c460 __libc_start_main +
    245

    9    tmp4t5b7555                        0x00005557b5d43419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ [1]\n    }\n\n    var result = [Int]()\n    var factors = [1]\n\n    while n\
    \ != 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = [1,\
    \ Int](factors.prefix(2))\n        } else if n % 3 == 0 {\n            n /= 3\n\
    \            factors = [Int](factors.prefix(3))\n        } else {\n          \
    \  n /= 2\n            factors = [Int](factors.prefix(2))\n            factors.append(3)\n\
    \        }\n    }\n\n    for factor in factors {\n        if factor > 2 {\n  \
    \          result.extend(factorize(n: factor))\n        } else {\n           \
    \ result.append(factor)\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpf1lw9kn3.swift:21:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpf1lw9kn3.swift:22:23:\
    \ error: cannot call value of non-function type '[Int.Type]'\n            factors\
    \ = [1, Int](factors.prefix(2))\n                      ^\n/tmp/tmpf1lw9kn3.swift:24:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n /= 3\n            ~ ^\n/tmp/tmpf1lw9kn3.swift:27:15: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n         \
    \   n /= 2\n            ~ ^\n/tmp/tmpf1lw9kn3.swift:35:20: error: value of type\
    \ '[Int]' has no member 'extend'\n            result.extend(factorize(n: factor))\n\
    \            ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 1 else {\n   \
    \     return []\n    }\n\n    var primeFactors: [Int] = []\n\n    for factor in\
    \ 2...n {\n        if n == factor {\n            primeFactors.append(factor)\n\
    \        }\n\n        var i = 0\n        while factor * primeFactors[i] <= n {\n\
    \            i++\n        }\n\n        if i == primeFactors.count {\n        \
    \    primeFactors.append(factor)\n        }\n    }\n\n    return primeFactors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqwavnc0d.swift:25:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            i++\n             ^~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 1 {\n        return\
    \ []\n    }\n    if n == 1 {\n        return [1]\n    }\n    var fac: [Int] =\
    \ []\n    var factorization: [Int] = []\n    var primes: Set<Int> = []\n    var\
    \ largestPrimeIndex: Int = 0\n    for prime in 2..<Int(sqrt(Double(n))) + 1 {\n\
    \        for index in 0..<n / prime {\n            if prime % index == 0 {\n \
    \               factorization.append(index)\n            }\n        }\n      \
    \  for index in factorization {\n            if !primes.contains(index) {\n  \
    \              primes.insert(index)\n                if index > largestPrimeIndex\
    \ {\n                    largestPrimeIndex = index\n                }\n      \
    \      }\n        }\n        fac = []\n        for index in 0..<largestPrimeIndex\
    \ {\n            fac = fac + [index]\n        }\n    }\n    return fac\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpg8h7ehf5.swift:22:26: error: cannot find 'sqrt' in scope\n    for\
    \ prime in 2..<Int(sqrt(Double(n))) + 1 {\n                         ^~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n%2 == 0 { return [Int]()\
    \ }\n    \n    var ps = [Int]()\n    \n    for i = 2; i < Int(n/2); i++ {\n  \
    \      var j = Int(n/2)\n        while j > 0 && n % j == 0 {\n            ps.append(j)\n\
    \            n /= j\n            j--\n        }\n    }\n    \n    if n > 1 {\n\
    \        ps.append(n)\n    }\n    \n    return ps\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplhb1libt.swift:16:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 2; i < Int(n/2); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 0 else { return\
    \ [] }\n    \n    var factors = [Int]()\n    var m = 1\n    var d = 2\n    var\
    \ k = n\n    var t = 0\n    while m <= k {\n        while k%m == 0 {\n       \
    \     factors.append(m)\n            k /= m\n        }\n        m += d\n     \
    \   d = 2\n        while k%d == 0 {\n            factors.append(d)\n         \
    \   k /= d\n            d *= 2\n        }\n        m += d\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    for _ in 0..<n {\n        var num = 1\n        var factor = 1\n        while\
    \ num * factor <= n {\n            num *= factor\n            factor *= 2\n  \
    \      }\n        if num > n {\n            factors.insert(factors.end(), num)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpo6c8wky8.swift:21:21: error: no exact matches in call to instance\
    \ method 'insert'\n            factors.insert(factors.end(), num)\n          \
    \          ^\n/tmp/tmpo6c8wky8.swift:21:21: note: found candidate with type '(__owned\
    \ Int, Int) -> ()'\n            factors.insert(factors.end(), num)\n         \
    \           ^\n/tmp/tmpo6c8wky8.swift:21:36: error: value of type '[Int]' has\
    \ no member 'end'\n            factors.insert(factors.end(), num)\n          \
    \                 ~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n >= 1 else {\n  \
    \      return []\n    }\n    var ans = [1]\n    var f = 1\n    var fp = 2\n  \
    \  for _ in 0..<n {\n        while fp != n && ans[fp] != 1 {\n            ans[fp]\
    \ = ans[fp] * f\n            fp++\n        }\n        f++\n        ans[f] = f\n\
    \    }\n    return ans.reverse()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp39bz9pin.swift:21:15: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            fp++\n              ^~\n/tmp/tmp39bz9pin.swift:23:10:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        f++\n\
    \         ^~\n/tmp/tmp39bz9pin.swift:26:16: error: cannot convert return expression\
    \ of type '()' to return type '[Int]'\n    return ans.reverse()\n           ~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors: [Int]\
    \ = []\n    var factors: [[Int]] = [[]]\n\n    var div = 2\n\n    for var i =\
    \ 1; i <= n / div; i++ {\n        for var j = i; j <= n / div; j++ {\n       \
    \     if i == j {\n                continue\n            }\n            if isPrime(j)\
    \ {\n                for var k = 0; k < factors.count; k++ {\n               \
    \     if factors[k].contains(j) {\n                        primeFactors.append(j)\n\
    \                        break\n                    }\n                }\n   \
    \             factors.append([j])\n            }\n        }\n\n        div *=\
    \ i\n    }\n\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmu3f4g7a.swift:17:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 1; i <= n / div; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmu3f4g7a.swift:18:9: error: C-style for statement has been removed in\
    \ Swift 3\n        for var j = i; j <= n / div; j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmu3f4g7a.swift:23:17: error: C-style for statement has been removed in\
    \ Swift 3\n                for var k = 0; k < factors.count; k++ {\n         \
    \       ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ [1]\n    }\n    let number: Int = Int(n) * Int(sqrt(Double(n)))\n    var factors\
    \ = [Int]()\n    factorize1(&n, &number) { (n: Int, factor: Int, remainder: Int)\
    \ -> Void in\n        factors.append(factor)\n    }\n    return factors\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpo84pn61z.swift:15:36: error: cannot find 'sqrt' in scope\n    let\
    \ number: Int = Int(n) * Int(sqrt(Double(n)))\n                              \
    \     ^~~~\n/tmp/tmpo84pn61z.swift:17:5: error: cannot find 'factorize1' in scope\n\
    \    factorize1(&n, &number) { (n: Int, factor: Int, remainder: Int) -> Void in\n\
    \    ^~~~~~~~~~\n/tmp/tmpo84pn61z.swift:17:16: error: cannot pass immutable value\
    \ as inout argument: 'n' is a 'let' constant\n    factorize1(&n, &number) { (n:\
    \ Int, factor: Int, remainder: Int) -> Void in\n               ^~\n/tmp/tmpo84pn61z.swift:17:20:\
    \ error: cannot pass immutable value as inout argument: 'number' is a 'let' constant\n\
    \    factorize1(&n, &number) { (n: Int, factor: Int, remainder: Int) -> Void in\n\
    \                   ^~~~~~~\n/tmp/tmpo84pn61z.swift:15:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let number: Int = Int(n) * Int(sqrt(Double(n)))\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    switch n % 4 {\n    case\
    \ 1, 3: // prime\n        if n != 1 {\n            return [3]\n        }\n   \
    \     return [2]\n    case 2:\n        return [3]\n    default:\n        return\
    \ [2]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpb0tpbn67/tmpb0tpbn67.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b6da8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b6a9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19b6a9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19b6a9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb0tpbn67                        0x000055c52adba412 <unavailable> + 5138

    5    libc.so.6                          0x00002b19b6f94460 __libc_start_main +
    245

    6    tmpb0tpbn67                        0x000055c52adba069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return sieve(n).map { 2\
    \ * $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvfab4gn2.swift:12:12: error: cannot find 'sieve' in scope\n   \
    \ return sieve(n).map { 2 * $0 }\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var resultIndex = 0\n    var current = 0\n    for factor in factors(n) {\n\
    \        if n % factor == 0 {\n            for _ in 0..<factor {\n           \
    \     result.insert(current, factor)\n                resultIndex += 1\n     \
    \           current += 1\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_sqtgeby.swift:15:19: error: cannot find 'factors' in scope\n \
    \   for factor in factors(n) {\n                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [1]\n    var\
    \ factors = []\n    var div = 1\n    var primeFactors = [1]\n    var checker =\
    \ 2\n    var max = 2\n    var index = 0\n    var temp: Int = 0\n    var maxIndex\
    \ = 0\n    var current = 0\n    for _ in 0..<n {\n        if maxIndex == 0 {\n\
    \            if current > 2 {\n                maxIndex = 1\n            }\n \
    \           if max > 2 {\n                maxIndex = 2\n            }\n      \
    \  }\n        if max > 2 {\n            div *= max\n            if checker % max\
    \ == 0 {\n                max += 2\n            }\n            current = 1\n \
    \           index++\n        }\n        for _ in 1..<max {\n            current\
    \ = current * 2\n            if n % current == 0 {\n                result.append(current)\n\
    \                temp = 1\n                maxIndex++\n                if maxIndex\
    \ == checker {\n                    factors.append(temp)\n                }\n\
    \            }\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuonada9k.swift:13:19: error: empty collection literal requires\
    \ an explicit type\n    var factors = []\n                  ^~\n/tmp/tmpuonada9k.swift:37:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  index++\n                 ^~\n/tmp/tmpuonada9k.swift:44:25: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                maxIndex++\n \
    \                       ^~\n/tmp/tmpuonada9k.swift:51:12: error: cannot convert\
    \ return expression of type '[Any]' to return type '[Int]'\n    return factors\n\
    \           ^\n/tmp/tmpuonada9k.swift:51:12: note: arguments to generic parameter\
    \ 'Element' ('Any' and 'Int') are expected to be equal\n    return factors\n \
    \          ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\
    \ = [n]\n    var factors = [Int]()\n    for i = 2; i < factorization[0]; i++ {\n\
    \        if n == i {\n            factors.append(i)\n        } else {\n      \
    \      var ii = i\n            while (n%i == 0) {\n                i *= i\n  \
    \              n /= i\n            }\n            if n > 1 {\n               \
    \ factors.append(i)\n                factors.append(n) //append n before adding\
    \ i so that if n is prime and it is divided by i, \n                factors.append(ii)\
    \ //it will also be factored in next iteration\n            }\n        }\n   \
    \ }\n    factorization.remove(at: 0)\n    factorization.insert(factorization[0],\
    \ factors[0])\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwdaxahrf.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 2; i < factorization[0]; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwdaxahrf.swift:18:22: error: cannot find 'i' in scope\n            var\
    \ ii = i\n                     ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n <= 1 {\n        return\
    \ []\n    }\n    var factorization = [Int]()\n    var factors: Int = Int(log2(Double(n)))\n\
    \n    for _ in 0..<(factors + 1) {\n        if n % 2 == 0 {\n            factorization\
    \ += [2]\n        }\n        factorization = [Int]()\n    }\n    for _ in 0..<factors\
    \ {\n        var p = 2\n        while p <= n / p {\n            if n % p == 0\
    \ {\n                factorization += [p]\n                if n % p == 0 {\n \
    \                   factors += p\n                }\n            }\n         \
    \   p += 2\n        }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2uw6r7gp.swift:16:28: error: cannot find 'log2' in scope\n    var\
    \ factors: Int = Int(log2(Double(n)))\n                           ^~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n\n    var factors = [Int]()\n    var primes = [Int]()\n\n    for\
    \ _ in 0 ..< n / 2 {\n        if n % 2 == 0 {\n            factors.append(2)\n\
    \            n /= 2\n            continue\n        }\n\n        if primes.contains(&n)\
    \ {\n            factors.append(n)\n            continue\n        }\n\n      \
    \  let prime = Int(SieveOfAtkin(n, &primes, factors).prime)\n        factors.append(prime)\n\
    \    }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpqplj15hd.swift:22:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpqplj15hd.swift:26:28:\
    \ error: '&' used with non-inout argument of type 'Int'\n        if primes.contains(&n)\
    \ {\n                           ^~\n                           \n/tmp/tmpqplj15hd.swift:26:28:\
    \ error: cannot pass immutable value as inout argument: 'n' is a 'let' constant\n\
    \        if primes.contains(&n) {\n                           ^~\n/tmp/tmpqplj15hd.swift:31:25:\
    \ error: cannot find 'SieveOfAtkin' in scope\n        let prime = Int(SieveOfAtkin(n,\
    \ &primes, factors).prime)\n                        ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return factorization(n:\
    \ n, memo: nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpra6ssnm8.swift:12:12: error: cannot find 'factorization' in scope\n\
    \    return factorization(n: n, memo: nil)\n           ^~~~~~~~~~~~~\n/tmp/tmpra6ssnm8.swift:12:38:\
    \ error: 'nil' requires a contextual type\n    return factorization(n: n, memo:\
    \ nil)\n                                     ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n >= 0 else {\n  \
    \      return []\n    }\n\n    var factors = [1]\n    for num in 2...n {\n   \
    \     if factors.contains(num) {\n            continue\n        }\n        for\
    \ f in factors {\n            if f % num == 0 {\n                factors.append(num)\n\
    \                break\n            }\n        }\n    }\n    guard factors.count\
    \ > 0 else {\n        return []\n    }\n\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp1u379_of/tmp1u379_of.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab694685c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab69437cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab69437c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab69437b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1u379_of                        0x000055caeeac1782 <unavailable> + 6018

    5    libc.so.6                          0x00002ab694871460 __libc_start_main +
    245

    6    tmp1u379_of                        0x000055caeeac13d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factorization = [Int](repeating:\
    \ 1, count: n)\n    for i in 2..<n {\n        if n % i == 0 {\n            factorization[i]\
    \ = factorization[i/2] * 2\n        }\n    }\n    return factorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpeygxb2ks.swift:15:26: error: cannot assign through subscript: 'factorization'\
    \ is a 'let' constant\n            factorization[i] = factorization[i/2] * 2\n\
    \            ~~~~~~~~~~~~~^\n/tmp/tmpeygxb2ks.swift:12:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let factorization = [Int](repeating: 1, count:\
    \ n)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // TODO: Check for valid\
    \ input\n    var factorization = [Int]()\n    var factorizationCount = 0\n   \
    \ if n == 1 {\n        factorization = [n]\n        factorizationCount = 1\n \
    \   } else {\n        factorizationCount = 2\n        factorization = [0]\n  \
    \      for curFactorizationCount in 2...n {\n            if n % curFactorizationCount\
    \ == 0 {\n                let newFactorizationCount = factorizationCount + curFactorizationCount\n\
    \                factorization = [Int](repeating: curFactorizationCount, count:\
    \ newFactorizationCount)\n                factorizationCount = newFactorizationCount\n\
    \            } else {\n                factorizationCount += 1\n            }\n\
    \        }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpoou9z5gl/tmpoou9z5gl.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e112d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e10fc9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e10fc9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e10fc87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoou9z5gl                        0x000055644ad585c2 <unavailable> + 5570

    5    libc.so.6                          0x00002b3e114be460 __libc_start_main +
    245

    6    tmpoou9z5gl                        0x000055644ad58219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\n\
    \    var maxFactors = 2\n\n    for factor in factorization(of: n) where factor\
    \ != 1 {\n        if n > 1 {\n            factors.append(factor)\n           \
    \ n *= factor\n        } else {\n            maxFactors = factor\n        }\n\
    \    }\n\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp495nwfld.swift:16:19: error: cannot find 'factorization' in scope\n\
    \    for factor in factorization(of: n) where factor != 1 {\n                \
    \  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ [1]\n    }\n    let result = [Int]()\n    let prime = Set([2])\n    while n\
    \ >= 2 {\n        if prime.contains(n) {\n            break\n        }\n     \
    \   let f = findFactors(n)\n        result.appendContentsOf(f)\n        n /= f[0]\n\
    \        if n > 1 {\n            prime.insert(f[0])\n        }\n    }\n    result.reverse()\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6t0563ir.swift:21:17: error: cannot find 'findFactors' in scope\n\
    \        let f = findFactors(n)\n                ^~~~~~~~~~~\n/tmp/tmp6t0563ir.swift:22:16:\
    \ error: value of type '[Int]' has no member 'appendContentsOf'\n        result.appendContentsOf(f)\n\
    \        ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp6t0563ir.swift:25:19: error: cannot\
    \ use mutating member on immutable value: 'prime' is a 'let' constant\n      \
    \      prime.insert(f[0])\n            ~~~~~ ^\n/tmp/tmp6t0563ir.swift:16:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let prime = Set([2])\n    ^~~\n\
    \    var\n/tmp/tmp6t0563ir.swift:28:12: error: cannot use mutating member on immutable\
    \ value: 'result' is a 'let' constant\n    result.reverse()\n    ~~~~~~ ^\n/tmp/tmp6t0563ir.swift:15:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = [Int]()\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 0 {\n        return\
    \ []\n    }\n    var factorization = [Int]()\n    var k = Int(sqrt(Double(n)))\
    \ + 1\n    for i in 0 ..< k {\n        while n % i == 0 {\n            factorization[i]\
    \ = factorization[i] ?? [i]\n            n /= i\n        }\n    }\n    if n !=\
    \ 1 {\n        factorization[0] = factorization[0] ?? [1]\n        factorization[1]\
    \ = factorization[1] ?? [2]\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq1nw78al.swift:16:17: error: cannot find 'sqrt' in scope\n    var\
    \ k = Int(sqrt(Double(n))) + 1\n                ^~~~\n/tmp/tmpq1nw78al.swift:24:48:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \        factorization[0] = factorization[0] ?? [1]\n                        \
    \                       ^\n/tmp/tmpq1nw78al.swift:25:48: error: cannot convert\
    \ value of type '[Int]' to expected argument type 'Int'\n        factorization[1]\
    \ = factorization[1] ?? [2]\n                                               ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var product = n * n // n!\n\
    \    var factorization = [Int]()\n    factorization[0] = n\n    var factor = 2\n\
    \    while factor <= product {\n        while factor <= product && product % factor\
    \ == 0 {\n            product /= factor\n            factorization.append(factor)\n\
    \            factor += 1\n        }\n    }\n    return factorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b97c9799c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97c9490561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b97c9490286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b97c949013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b97c948fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b97c928f7ec <unavailable> + 186348

    6    tmpfwtdgw4j                        0x00005578ab415cb2 <unavailable> + 7346

    7    tmpfwtdgw4j                        0x00005578ab41544b <unavailable> + 5195

    8    libc.so.6                          0x00002b97c9985460 __libc_start_main +
    245

    9    tmpfwtdgw4j                        0x00005578ab415169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ [0]\n    }\n\n    var factors = [Int]()\n    var div = 2\n\n    while div <=\
    \ n {\n        if n%div == 0 {\n            factors.append(div)\n            n\
    \ /= div\n        } else {\n            div *= 2\n        }\n    }\n\n    if n\
    \ != 1 {\n        factors.append(n)\n    }\n\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp94virtjb.swift:22:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= div\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var ans = [1]\n    for factor\
    \ in factorizationOf(n) {\n        ans[0] *= factor\n        ans.append(ans[0]\
    \ / factor)\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwztag1ml.swift:13:19: error: cannot find 'factorizationOf' in scope\n\
    \    for factor in factorizationOf(n) {\n                  ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization: [Int]\n\
    \    var highest = 0\n    var lowest = n\n\n    while highest < lowest {\n   \
    \     if n % lowest == 0 {\n            factorization = append(factorization,\
    \ lowest)\n            highest = lowest\n        }\n        highest++\n    }\n\
    \n    var result = [Int]()\n    for factor in factorization {\n        let count\
    \ = factorization.reduce(0) { (sum, elem) -> Int in\n            return sum +\
    \ elem\n        }\n        result.append(count)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6bed2il9.swift:18:29: error: cannot find 'append' in scope\n  \
    \          factorization = append(factorization, lowest)\n                   \
    \         ^~~~~~\n/tmp/tmp6bed2il9.swift:21:16: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n        highest++\n               ^~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors = Array(0..<n)\n\
    \    \n    for var i = 2; i < Int(sqrt(Double(n))); i++ {\n        if primeFactors.contains(&i)\
    \ {\n            continue\n        }\n        \n        var isPrime = true\n \
    \       for var j = 0 ; j < primeFactors.count ; j++ {\n            if i*primeFactors[j]\
    \ == n {\n                isPrime = false\n                break\n           \
    \ }\n        }\n        if isPrime {\n            primeFactors.append(i)\n   \
    \     }\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpojrcjj_l.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 2; i < Int(sqrt(Double(n))); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpojrcjj_l.swift:20:9: error: C-style for statement has been removed in\
    \ Swift 3\n        for var j = 0 ; j < primeFactors.count ; j++ {\n        ^ \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let maxNum = Int(ceil(sqrt(Double(n))))\n\
    \    var factors = [Int]()\n    for factor in stride(from: 2, through: maxNum,\
    \ by: 2) {\n        if n % factor == 0 {\n            factors.append(factor)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpbq79k_c5.swift:12:22: error: cannot find 'ceil' in scope\n    let\
    \ maxNum = Int(ceil(sqrt(Double(n))))\n                     ^~~~\n/tmp/tmpbq79k_c5.swift:12:27:\
    \ error: cannot find 'sqrt' in scope\n    let maxNum = Int(ceil(sqrt(Double(n))))\n\
    \                          ^~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n != 0, n > 1 else\
    \ {\n        return []\n    }\n    var factorization = [1]\n    for currentNumber\
    \ in 2...n {\n        while factorization[currentNumber] > 0 {\n            if\
    \ n % currentNumber == 0 {\n                factorization[currentNumber] = factorization[currentNumber]\
    \ + 1\n                n /= currentNumber\n            }\n        }\n        factorization[currentNumber]\
    \ = 1\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd435g4xp.swift:20:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= currentNumber\n     \
    \           ~ ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var factorization\
    \ = [Int]()\n    let maxFactorization = Int(ceil(Double(n) / Double(factorizationCount)))\n\
    \    \n    for number in stride(from: 2, through: Int(ceil(Double(n) / Double(factorizationCount))),\
    \ by: 1) {\n        \n        if number > maxFactorization {\n            break\n\
    \        }\n        \n        for factor in stride(from: 1, through: Int(ceil(Double(n)\
    \ / Double(factorizationCount))), by: 1) {\n            \n            if number\
    \ % factor == 0 {\n                factorization.append(factor)\n            \
    \    n /= factor\n                break\n            }\n        }\n    }\n   \
    \ \n    if n != 1 {\n        factorization.append(n)\n    }\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp8jcabnw.swift:14:32: error: cannot find 'ceil' in scope\n    let\
    \ maxFactorization = Int(ceil(Double(n) / Double(factorizationCount)))\n     \
    \                          ^~~~\n/tmp/tmpp8jcabnw.swift:14:56: error: cannot find\
    \ 'factorizationCount' in scope\n    let maxFactorization = Int(ceil(Double(n)\
    \ / Double(factorizationCount)))\n                                           \
    \            ^~~~~~~~~~~~~~~~~~\n/tmp/tmpp8jcabnw.swift:16:48: error: cannot find\
    \ 'ceil' in scope\n    for number in stride(from: 2, through: Int(ceil(Double(n)\
    \ / Double(factorizationCount))), by: 1) {\n                                 \
    \              ^~~~\n/tmp/tmpp8jcabnw.swift:16:72: error: cannot find 'factorizationCount'\
    \ in scope\n    for number in stride(from: 2, through: Int(ceil(Double(n) / Double(factorizationCount))),\
    \ by: 1) {\n                                                                 \
    \      ^~~~~~~~~~~~~~~~~~\n/tmp/tmpp8jcabnw.swift:22:52: error: cannot find 'ceil'\
    \ in scope\n        for factor in stride(from: 1, through: Int(ceil(Double(n)\
    \ / Double(factorizationCount))), by: 1) {\n                                 \
    \                  ^~~~\n/tmp/tmpp8jcabnw.swift:22:76: error: cannot find 'factorizationCount'\
    \ in scope\n        for factor in stride(from: 1, through: Int(ceil(Double(n)\
    \ / Double(factorizationCount))), by: 1) {\n                                 \
    \                                          ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factor: Int = 0\n    while n != 1 {\n        if n % factor == 0 {\n \
    \           factors.append(factor)\n            n /= factor\n        } else {\n\
    \            factor = 1\n        }\n    }\n    factors.append(n)\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpaf4bvsvz.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   factorize(n: n, result: &result)\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgd_7c6gf.swift:13:29: error: extra argument 'result' in call\n\
    \    factorize(n: n, result: &result)\n             ~~~~~~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n > 0, \"Cannot\
    \ factorize less than or equal to 0\")\n    precondition(n % 1 == 0, \"Factorization\
    \ does not work for numbers that don't have an even prime factor\")\n    var result\
    \ = [Int]()\n    for factor in 2..(n / 2) {\n        if n / factor == 2 {\n  \
    \          result.append(factor)\n        } else {\n            result.append(factor)\n\
    \            result.append(n / factor)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjx0rbjwu.swift:15:20: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for factor in 2..(n / 2) {\n                   ^~\n\
    \                   ...\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ [Int]()\n    }\n    if n == 2 {\n        return [2]\n    }\n    var factors\
    \ = [1]\n    var divisor = 2\n    var primes = 1\n\n    while divisor * divisor\
    \ <= n {\n        for _ in 1...(divisor * divisor) {\n            primes += 1\n\
    \            divisor *= primes\n        }\n        factors.append(primes)\n  \
    \      divisor = 2\n        primes = 1\n    }\n    factors.append(Int(log2(n)\
    \ * primes))\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprev2w8os.swift:31:24: error: cannot find 'log2' in scope\n    factors.append(Int(log2(n)\
    \ * primes))\n                       ^~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    switch {\n    case n < 2:\n\
    \        return []\n    case n == 2:\n        return [2]\n    case n % 2 == 0:\n\
    \        return [2]\n    case n % 3 == 0 or n % 5 == 0 or n % 7 == 0:\n      \
    \  return [2, 3, 5]\n    }\n\n    factors := []int{}\n    for i := 2; i <= n;\
    \ i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n \
    \           if i /= 2 {\n                for j := 3; j >= i; j++ {\n         \
    \           if j % i == 0 {\n                        factors = append(factors,\
    \ i)\n                        i /= j\n                        break\n        \
    \            }\n                }\n            }\n        }\n    }\n    sort.Ints(factors)\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpm18z2pj0.swift:12:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmpm18z2pj0.swift:19:21: error: expected ':'\
    \ after 'case'\n    case n % 3 == 0 or n % 5 == 0 or n % 7 == 0:\n           \
    \         ^\n/tmp/tmpm18z2pj0.swift:19:23: error: consecutive statements on a\
    \ line must be separated by ';'\n    case n % 3 == 0 or n % 5 == 0 or n % 7 ==\
    \ 0:\n                      ^\n                      ;\n/tmp/tmpm18z2pj0.swift:19:34:\
    \ error: consecutive statements on a line must be separated by ';'\n    case n\
    \ % 3 == 0 or n % 5 == 0 or n % 7 == 0:\n                                 ^\n\
    \                                 ;\n/tmp/tmpm18z2pj0.swift:19:37: error: consecutive\
    \ statements on a line must be separated by ';'\n    case n % 3 == 0 or n % 5\
    \ == 0 or n % 7 == 0:\n                                    ^\n               \
    \                     ;\n/tmp/tmpm18z2pj0.swift:19:48: error: consecutive statements\
    \ on a line must be separated by ';'\n    case n % 3 == 0 or n % 5 == 0 or n %\
    \ 7 == 0:\n                                               ^\n                \
    \                               ;\n/tmp/tmpm18z2pj0.swift:19:48: error: expected\
    \ expression\n    case n % 3 == 0 or n % 5 == 0 or n % 7 == 0:\n             \
    \                                  ^\n/tmp/tmpm18z2pj0.swift:24:12: error: expected\
    \ type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpm18z2pj0.swift:24:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n\
    \           ^\n/tmp/tmpm18z2pj0.swift:24:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpm18z2pj0.swift:28:24:\
    \ error: expected type\n                for j := 3; j >= i; j++ {\n          \
    \             ^\n                        <#type#>\n/tmp/tmpm18z2pj0.swift:28:24:\
    \ error: expected 'in' after for-each pattern\n                for j := 3; j >=\
    \ i; j++ {\n                       ^\n/tmp/tmpm18z2pj0.swift:28:24: error: expected\
    \ Sequence expression for for-each loop\n                for j := 3; j >= i; j++\
    \ {\n         "
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n % 2 == 0,\
    \ \"n should be even number\")\n    precondition(n == 2 * 3 * 5 * 7, \"n should\
    \ be equal to the product of all factors\")\n    var p = 2\n    var factors =\
    \ [Int]()\n    var last = 2\n    var found = 0\n    var tmp = 2\n    while found\
    \ == 0 {\n        for _ in 0..<n {\n            if p % tmp == 0 {\n          \
    \      factors.append(tmp)\n                found = 1\n                tmp = tmp\
    \ * 2\n            } else {\n                tmp = p\n            }\n        }\n\
    \        if found == 0 {\n            last = tmp\n            p = p + 1\n    \
    \    }\n    }\n    for _ in 0..<n {\n        factors.append(last)\n    }\n   \
    \ return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpzvzb8c2e/tmpzvzb8c2e.swift:13: Precondition failed: n should be equal
    to the product of all factors

    Current stack trace:

    0    libswiftCore.so                    0x00002b17def7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17dec75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17dec75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17dec747b0 _assertionFailure(_:_:file:line:flags:)
    + 365

    4    tmpzvzb8c2e                        0x0000564bd6f98fd9 <unavailable> + 8153

    5    tmpzvzb8c2e                        0x0000564bd6f9857b <unavailable> + 5499

    6    libc.so.6                          0x00002b17df16a460 __libc_start_main +
    245

    7    tmpzvzb8c2e                        0x0000564bd6f98299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primesCount = count(forPrimes:\
    \ primesOf(n))\n    var factorization: [Int] = Array(repeating: 0, count: primesCount)\n\
    \    \n    var i = 2\n    \n    while i <= n {\n        var remainder = n % i\n\
    \        var isPrime = false\n        \n        for (j, primesCount) in factorization.enumerated()\
    \ {\n            if primesCount > 0 {\n                isPrime = true\n      \
    \          break\n            }\n        }\n        \n        if !isPrime {\n\
    \            factorization[i : i + 1] = Array(repeating: i, count: count(forPrimes:\
    \ primesOf(i)))\n        }\n        \n        i = i + 1\n    }\n    \n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_23jb5_0.swift:12:23: error: cannot find 'count' in scope\n   \
    \ let primesCount = count(forPrimes: primesOf(n))\n                      ^~~~~\n\
    /tmp/tmp_23jb5_0.swift:12:40: error: cannot find 'primesOf' in scope\n    let\
    \ primesCount = count(forPrimes: primesOf(n))\n                              \
    \         ^~~~~~~~\n/tmp/tmp_23jb5_0.swift:29:67: error: cannot find 'count' in\
    \ scope\n            factorization[i : i + 1] = Array(repeating: i, count: count(forPrimes:\
    \ primesOf(i)))\n                                                            \
    \      ^~~~~\n/tmp/tmp_23jb5_0.swift:29:84: error: cannot find 'primesOf' in scope\n\
    \            factorization[i : i + 1] = Array(repeating: i, count: count(forPrimes:\
    \ primesOf(i)))\n                                                            \
    \                       ^~~~~~~~\n/tmp/tmp_23jb5_0.swift:29:26: error: extraneous\
    \ argument label 'i:' in subscript\n            factorization[i : i + 1] = Array(repeating:\
    \ i, count: count(forPrimes: primesOf(i)))\n                         ^~~~~\n \
    \                         \n/tmp/tmp_23jb5_0.swift:29:40: error: cannot assign\
    \ value of type 'Array<Int>' to subscript of type 'Int'\n            factorization[i\
    \ : i + 1] = Array(repeating: i, count: count(forPrimes: primesOf(i)))\n     \
    \                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var product = n * n\n    if product % 1 == 0 {\n        factors.append(2)\n\
    \    }\n    for _ in 0..<n {\n        if product % 1 == 0 {\n            factors.append(2)\n\
    \        }\n        product /= n\n    }\n    if product % 1 != 0 {\n        factors.append(product)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpb7x7d0vn/tmpb7x7d0vn.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac14f609c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac14f300b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac14f300988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac14f2ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb7x7d0vn                        0x00005617dfa5d5b2 <unavailable> + 5554

    5    libc.so.6                          0x00002ac14f7f5460 __libc_start_main +
    245

    6    tmpb7x7d0vn                        0x00005617dfa5d209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    for prime in 2..<n {\n        if n % prime == 0 {\n            var factor\
    \ = 1\n            for _ in 0..<n / prime {\n                factor *= prime\n\
    \            }\n            factors.append(factor)\n        }\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpdt24t6cs/tmpdt24t6cs.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc72f8cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc72c83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc72c83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc72c827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdt24t6cs                        0x0000561ca70e35b2 <unavailable> + 5554

    5    libc.so.6                          0x00002abc73178460 __libc_start_main +
    245

    6    tmpdt24t6cs                        0x0000561ca70e3209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return factorizeWithNumbersArray(n,\
    \ numbers)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpw54s5xy7.swift:12:12: error: cannot find 'factorizeWithNumbersArray'\
    \ in scope\n    return factorizeWithNumbersArray(n, numbers)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpw54s5xy7.swift:12:41: error: cannot find 'numbers' in scope\n    return\
    \ factorizeWithNumbersArray(n, numbers)\n                                    \
    \    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 1 {\n        return\
    \ []\n    }\n    if n == 1 {\n        return [1]\n    }\n\n    var factors = [Int]()\n\
    \    factorizationHelper(n, &factors, 0)\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp_vboyeto.swift:20:5: error: cannot find 'factorizationHelper' in\
    \ scope\n    factorizationHelper(n, &factors, 0)\n    ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    if n < 2 {\n        factors.append(1)\n    } else {\n        for factor in\
    \ 2...n {\n            factors.append(factor)\n            for _ in 2...factor\
    \ {\n                factors.removeLast()\n            }\n        }\n    }\n \
    \   return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpq0boct3r/tmpq0boct3r.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb2163bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb21332b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb21332988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb213317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq0boct3r                        0x000055617c6d0692 <unavailable> + 5778

    5    libc.so.6                          0x00002afb21827460 __libc_start_main +
    245

    6    tmpq0boct3r                        0x000055617c6d02e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660009624
- exit_code: -1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ [1]\n    }\n    var factors = [Int]()\n    factors.append(2)\n    if n >= 4\
    \ {\n        if n % 2 == 0 {\n            factors.append(2)\n            factors.append(n\
    \ / 2)\n        }\n    }\n    var factor = 2\n    var last = 1\n    var lastFactor\
    \ = 2\n    for number in stride(from: 1, to: n, by: 1) {\n        while factor\
    \ != 1 {\n            if number % factor == 0 {\n                factors.append(factor)\n\
    \                lastFactor = factor\n                last = 1\n            }\n\
    \            factor += 2\n        }\n        if lastFactor != 2 {\n          \
    \  factors.append(lastFactor)\n            last = 1\n        }\n        lastFactor\
    \ += 2\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var m = 1\n    var count = 1\n    while n > 1 {\n        m *= 2\n       \
    \ if m > n {\n            break\n        }\n        count += 1\n        if n %\
    \ m == 0 {\n            m /= 2\n            n /= m\n            count += 1\n \
    \       }\n        result.append(m)\n    }\n    if count == 0 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq70y0r7v.swift:23:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= m\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primeFactors = PrimeFactorization(n)\n\
    \    return primeFactors.map { Int64($0).pow(Int64($1)) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpj4gaxwlp.swift:12:24: error: cannot find 'PrimeFactorization' in\
    \ scope\n    let primeFactors = PrimeFactorization(n)\n                      \
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpj4gaxwlp.swift:13:41: error: reference to member\
    \ 'pow' cannot be resolved without a contextual type\n    return primeFactors.map\
    \ { Int64($0).pow(Int64($1)) }\n                                        ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n <= 1 {\n        return\
    \ [Int]()\n    }\n    var factorization: [Int] = [n]\n    factorization[0] = n\n\
    \n    var primes: [Int] = [Int]()\n    var newPrimes: [Int] = [Int]()\n    var\
    \ remain: Int = n - 1\n    while remain > 0 {\n        if remain%2 == 0 {\n  \
    \          newPrimes.append(2)\n            remain /= 2\n        }\n        else\
    \ {\n            let i = 3\n            repeat (newPrimes.count - 1) {\n     \
    \           if remain % i == 0 {\n                    newPrimes.append(i)\n  \
    \                  remain = remain / i\n                    break\n          \
    \      }\n                i += 1\n            }\n        }\n    }\n    primes\
    \ = newPrimes + primes\n    var result = [Int]()\n    for i in 1...primes.count\
    \ {\n        if primes[i] != 0 {\n            if i == 1 {\n                result.append(primes[i])\n\
    \            } else {\n                for j in 1...i {\n                    if\
    \ j >= primes[i] {\n                        break\n                    }\n   \
    \                 result.append(j)\n                }\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp98tuyo8u.swift:28:20: error: expected '{' after 'repeat'\n    \
    \        repeat (newPrimes.count - 1) {\n                   ^\n/tmp/tmp98tuyo8u.swift:35:13:\
    \ error: expected 'while' after body of 'repeat' statement\n            }\n  \
    \          ^\n/tmp/tmp98tuyo8u.swift:34:19: error: left side of mutating operator\
    \ isn't mutable: 'i' is a 'let' constant\n                i += 1\n           \
    \     ~ ^\n/tmp/tmp98tuyo8u.swift:27:13: note: change 'let' to 'var' to make it\
    \ mutable\n            let i = 3\n            ^~~\n            var\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factors = [1]\n    while n != 1 {\n        for f in factors {\n     \
    \       while n / f != 0 {\n                factorization[factors.count] = f\n\
    \                n /= f\n            }\n        }\n        factors = [1]\n   \
    \     for f in factors {\n            while n > 1 {\n                factors =\
    \ factors + [f]\n                n -= 1\n            }\n        }\n    }\n   \
    \ \n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppr8saydk.swift:18:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= f\n                ~\
    \ ^\n/tmp/tmppr8saydk.swift:25:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n -= 1\n                ~\
    \ ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n != 0 else {\n  \
    \      return []\n    }\n    if n == 1 {\n        return []\n    }\n    var factorization:\
    \ [Int] = []\n    var primeFactorization: [Int] = []\n    var isPrime = true //\
    \ Is current prime number true\n    var i: Int = 0\n    var j: Int = 0\n    \n\
    \    for prime in primes {\n        if prime > n {\n            break\n      \
    \  }\n        if n % prime == 0 {\n            isPrime = false\n            break\n\
    \        }\n    }\n    if isPrime == false {\n        return factorization\n \
    \   }\n    \n    \n    \n    while i < n {\n        primeFactorization = []\n\
    \        j = 0\n        \n        for prime in primes {\n            if prime\
    \ > n {\n                break\n            }\n            if n % prime == 0 {\n\
    \                isPrime = false\n                break\n            }\n     \
    \   }\n        if isPrime == true {\n            factorization.append(prime)\n\
    \            primeFactorization.append(j)\n        }\n        i += 1\n    }\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1ssjm1x6.swift:24:18: error: cannot find 'primes' in scope\n  \
    \  for prime in primes {\n                 ^~~~~~\n/tmp/tmp1ssjm1x6.swift:43:22:\
    \ error: cannot find 'primes' in scope\n        for prime in primes {\n      \
    \               ^~~~~~\n/tmp/tmp1ssjm1x6.swift:53:34: error: cannot find 'prime'\
    \ in scope\n            factorization.append(prime)\n                        \
    \         ^~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // check if number is positive\n\
    \    if n < 0 {\n        print(\"Warning: negative number\")\n        return []\n\
    \    }\n    // if number is already factorized then return the array of factors\n\
    \    if isPrime(n) {\n        return [n]\n    }\n    // factorize n\n    var factors\
    \ = factorize2(n: n)\n    // check if n is divisible by any factor of n\n    //\
    \ if yes, recursively calculate with product of all factors\n    if factors.contains(where:\
    \ { $0 != 0 }) {\n        var p = n\n        for p in factors {\n            p\
    \ = p * n\n        }\n        return factorize2(n: p)\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8eh6xlxc.swift:18:8: error: cannot find 'isPrime' in scope\n  \
    \  if isPrime(n) {\n       ^~~~~~~\n/tmp/tmp8eh6xlxc.swift:22:19: error: cannot\
    \ find 'factorize2' in scope\n    var factors = factorize2(n: n)\n           \
    \       ^~~~~~~~~~\n/tmp/tmp8eh6xlxc.swift:30:16: error: cannot find 'factorize2'\
    \ in scope\n        return factorize2(n: p)\n               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let mut factors = [Int]()\n\
    \    var temp: Int\n    for num in 2..(n * 10) {\n        temp = num\n       \
    \ while temp % num == 0 {\n            temp /= num\n            factors.append(num)\n\
    \        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd0rfqrz6.swift:12:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut factors\
    \ = [Int]()\n            ^\n/tmp/tmpd0rfqrz6.swift:12:13: note: join the identifiers\
    \ together\n    let mut factors = [Int]()\n        ~~~~^~~~~~~\n        mutfactors\n\
    /tmp/tmpd0rfqrz6.swift:12:13: note: join the identifiers together with camel-case\n\
    \    let mut factors = [Int]()\n        ~~~~^~~~~~~\n        mutFactors\n/tmp/tmpd0rfqrz6.swift:14:17:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n    for num\
    \ in 2..(n * 10) {\n                ^~\n                ...\n/tmp/tmpd0rfqrz6.swift:21:12:\
    \ error: cannot find 'factors' in scope\n    return factors\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primeFactors = factors(n)\n\
    \    var factorization = [Int]()\n    for var i = 2; i <= primeFactors.count;\
    \ i++ {\n        if i == primeFactors.count {\n            factorization[factorization.count]\
    \ = i\n        }\n        else {\n            for var j = 1; j < i; j++ {\n  \
    \              if primeFactors.contains(j) {\n                    factorization[factorization.count]\
    \ = j\n                    break\n                }\n            }\n        }\n\
    \    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4xhlasg2.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 2; i <= primeFactors.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4xhlasg2.swift:19:13: error: C-style for statement has been removed in\
    \ Swift 3\n            for var j = 1; j < i; j++ {\n            ^   ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4xhlasg2.swift:12:24: error: cannot find 'factors' in scope\n    let primeFactors\
    \ = factors(n)\n                       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n >= 1 else { return\
    \ [] }\n    var factors = [Int]()\n    var primeFactors = primeFactorization(n:\
    \ n)\n    for i in 1..<primeFactors.count {\n        if primeFactors[i] == i {\n\
    \            factors.append(i)\n            continue\n        }\n        let primeFactorsIndex\
    \ = i - 1\n        for j in primeFactorsIndex..<primeFactors.count {\n       \
    \     let product = primeFactors[primeFactorsIndex] * primeFactors[j]\n      \
    \      if product > n {\n                break\n            }\n            if\
    \ product % i == 0 {\n                factors.append(i)\n                factors.append(j)\n\
    \                break\n            }\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnndxp7mj.swift:14:24: error: cannot find 'primeFactorization' in\
    \ scope\n    var primeFactors = primeFactorization(n: n)\n                   \
    \    ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 1 {\n        return\
    \ []\n    }\n\n    var factors: [Int] = []\n    var current = 1\n\n    // TODO:\
    \ find better way to calculate `product` of `factors` and `n`.\n    var product\
    \ = n\n\n    repeat {\n        var factorizations = [current]\n\n        for factor\
    \ in factors {\n            factorizations.append(factor * factor)\n        }\n\
    \n        product = product / factor\n        current = Int(factorizations[factorizations.endIndex])\n\
    \n        factors.append(current)\n    } while (product > 1)\n\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpnov25rbo.swift:29:29: error: cannot find 'factor' in scope\n  \
    \      product = product / factor\n                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factorization: [Int]\n\
    \    if n <= 1 {\n        return []\n    }\n    factorization = factorization(n:\
    \ n)\n    let factorizationMax = factorization.max()\n    var factorizationMaxIndex\
    \ = 0\n    var factorizationIndex = 0\n    var factorizationSubIndex = 0\n   \
    \ var factorizationSubMax = 0\n    var factorizationSubMaxIndex = 0\n    for i\
    \ in 0 ..< factorization.count {\n        if factorization[i] > factorizationMax\
    \ {\n            if factorization[factorizationMaxIndex] > i {\n             \
    \   factorizationSubMax = factorization[factorizationMaxIndex]\n             \
    \   factorizationSubMaxIndex = factorizationMaxIndex\n            }\n        \
    \    factorizationMaxIndex = i\n            factorizationMax = factorization[i]\n\
    \        }\n    }\n    if factorization[factorizationMaxIndex] > n {\n       \
    \ factorizationSubMax = factorization[factorizationMaxIndex]\n        factorizationSubMaxIndex\
    \ = factorizationMaxIndex\n    }\n    var factorizationMaxSub = 0\n    var factorizationMaxSubIndex\
    \ = 0\n    for i in 0 ..< factorization.count {\n        if factorization[i] >\
    \ factorizationMaxSub {\n            if factorization[factorizationMaxSubIndex]\
    \ == factorization[i] {\n                factorizationMaxSub = factorization[i]\n\
    \                factorizationMaxSubIndex = i\n            }\n        }\n    }\n\
    \    if factorizationMaxSubIndex < factorizationMaxIndex {\n        factorizationMaxSubIndex\
    \ = factorizationMaxIndex\n    }\n    if factorizationMaxSubIndex == 0 {\n   \
    \     factorizationMaxSub = 1\n    }\n    factorization = [factorizationSubMax]\
    \ * factorizationMaxSubIndex + factorization\n    return factorization\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpccp2vqy6.swift:16:21: error: cannot call value of non-function\
    \ type '[Int]'\n    factorization = factorization(n: n)\n                    ^\n\
    /tmp/tmpccp2vqy6.swift:24:31: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n        if factorization[i] > factorizationMax {\n\
    \                              ^\n/tmp/tmpccp2vqy6.swift:24:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if factorization[i] > factorizationMax {\n                             \
    \ ^\n                                               ?? <#default value#>\n/tmp/tmpccp2vqy6.swift:24:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if factorization[i] > factorizationMax {\n                  \
    \            ^\n                                              !\n/tmp/tmpccp2vqy6.swift:30:13:\
    \ error: cannot assign to value: 'factorizationMax' is a 'let' constant\n    \
    \        factorizationMax = factorization[i]\n            ^~~~~~~~~~~~~~~~\n/tmp/tmpccp2vqy6.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let factorizationMax = factorization.max()\n\
    \    ^~~\n    var\n/tmp/tmpccp2vqy6.swift:53:70: error: binary operator '+' cannot\
    \ be applied to operands of type 'Int' and '[Int]'\n    factorization = [factorizationSubMax]\
    \ * factorizationMaxSubIndex + factorization\n                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpccp2vqy6.swift:53:43: error: binary operator '*' cannot\
    \ be applied to operands of type '[Int]' and 'Int'\n    factorization = [factorizationSubMax]\
    \ * factorizationMaxSubIndex + factorization\n                    ~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpccp2vqy6.swift:53:43: note: overloads for\
    \ '*' exist with these partially matching parameter lists: (Int, Int)\n    factorization\
    \ = [factorizationSubMax] * factorizationMaxSubIndex + factorization\n       \
    \                                   ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var factors: [Int] = []\n    var primes: [Int] = []\n\n    let maxPrime:\
    \ Int = Int(sqrt(Double(n)))\n\n    for i in stride(from: 2, to: Int(maxPrime),\
    \ by: 1) {\n        for j in stride(from: i, to: Int(maxPrime), by: 1) {\n   \
    \         if n % i == 0 {\n                factors.append(i)\n               \
    \ factors.append(j)\n                factors.append(n / i)\n                factorization\
    \ = [Int](repeating:i, count: factors.count)\n                break\n        \
    \    }\n        }\n    }\n\n    for i in stride(from: 2, to: Int(maxPrime), by:\
    \ 1) {\n        if factorization[i] == nil {\n            primes.append(i)\n \
    \       }\n    }\n\n    return primes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpo6d_35d9.swift:16:29: error: cannot find 'sqrt' in scope\n    let\
    \ maxPrime: Int = Int(sqrt(Double(n)))\n                            ^~~~\n/tmp/tmpo6d_35d9.swift:31:29:\
    \ warning: comparing non-optional value of type 'Int' to 'nil' always returns\
    \ false\n        if factorization[i] == nil {\n           ~~~~~~~~~~~~~~~~ ^ \
    \ ~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factorization: [Int]\
    \ = [1]\n    var maxIterations: Int = 0\n    var max: Int = 0\n    var counter:\
    \ Int = 0\n    while max < n {\n        for factor in factorization {\n      \
    \      if n % factor == 0 {\n                max += factor\n                factorization[counter]\
    \ = (factor * factorization[counter])\n                counter += 1\n        \
    \    }\n        }\n        if maxIterations < counter {\n            maxIterations\
    \ = counter\n        }\n    }\n    var factors: [Int] = []\n    factorization.reverse()\n\
    \    for factor in factorization {\n        if factor > max {\n            break\n\
    \        }\n        factors.append(factor)\n        max /= factor\n    }\n   \
    \ return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpgzqydr2_.swift:20:30: error: cannot assign through subscript: 'factorization'\
    \ is a 'let' constant\n                factorization[counter] = (factor * factorization[counter])\n\
    \                ~~~~~~~~~~~~~^\n/tmp/tmpgzqydr2_.swift:12:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let factorization: [Int] = [1]\n    ^~~\n \
    \   var\n/tmp/tmpgzqydr2_.swift:29:19: error: cannot use mutating member on immutable\
    \ value: 'factorization' is a 'let' constant\n    factorization.reverse()\n  \
    \  ~~~~~~~~~~~~~ ^\n/tmp/tmpgzqydr2_.swift:12:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let factorization: [Int] = [1]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var factors = [Int]()\n\n\
    \  for factor in 2...n {\n    if n % factor == 0 {\n      factors.append(factor)\n\
    \      n /= factor\n    }\n  }\n\n  return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjlqgk1wx.swift:17:9: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n      n /= factor\n      ~ ^\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = [0]\n\
    \    for f in  factorize(n) {\n        factors.append(factors.last + f)\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjpwn9yd6.swift:13:25: error: missing argument label 'n:' in call\n\
    \    for f in  factorize(n) {\n                        ^\n                   \
    \     n: \n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    precondition(n != 0, \"\
    Factorizing number should have a positive number\")\n    precondition(n >= 2,\
    \ \"Factorizing number should have a number greater than or equal to 2\")\n  \
    \  \n    var factorization: [Int] = []\n    \n    for f in 2...n {\n        for\
    \ _ in 0..Int(Int(f) / 2) {\n            factorization.append(f)\n        }\n\
    \    }\n    \n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3bgdekas.swift:18:19: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n        for _ in 0..Int(Int(f) / 2) {\n               \
    \   ^~\n                  ...\n"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    switch n {\n    case 1:\n\
    \        return [n]\n    case 2:\n        return [1, n]\n    default:\n      \
    \  if isPrime(n) {\n            return [2] + factorize(n - 1)\n        }\n   \
    \     var result: [Int] = [n]\n        var lastFactor = 2 // first two prime factors\n\
    \        var currentFactor = 2 // current factor being checked while iterating\
    \ through prime factors\n        for currentFactor = 3; currentFactor <= n; currentFactor\
    \ += 1 {\n            if n % currentFactor == 0 {\n                for factor\
    \ in result {\n                    factor += lastFactor\n                }\n \
    \               result[result.count-1] = currentFactor\n                lastFactor\
    \ = currentFactor\n            } else {\n                if lastFactor == 2 {\n\
    \                    lastFactor = 3\n                } else {\n              \
    \      lastFactor = currentFactor\n                }\n            }\n        }\n\
    \        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpxkj7ns0s.swift:24:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for currentFactor = 3; currentFactor <= n; currentFactor\
    \ += 1 {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxkj7ns0s.swift:18:12: error: cannot find 'isPrime' in scope\n        if\
    \ isPrime(n) {\n           ^~~~~~~\n/tmp/tmpxkj7ns0s.swift:19:36: error: missing\
    \ argument label 'n:' in call\n            return [2] + factorize(n - 1)\n   \
    \                                ^\n                                   n: \n"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 0 else { return\
    \ [] }\n    \n    let factors = factorization(n: n)\n    var factorizationArray\
    \ = [Int]()\n    \n    for factor in factors {\n        factorizationArray.append(factor)\n\
    \    }\n    \n    return factorizationArray\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp04hvkzac.swift:14:19: error: cannot find 'factorization' in scope\n\
    \    let factors = factorization(n: n)\n                  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    // Initialize result\
    \ array\n    var factors = [Int]()\n    \n    // Iterate over all prime numbers\n\
    \    for i in 2...Int(sqrt(Double(n))) + 1 {\n        // Iterate over all numbers\
    \ from 2 to sqrt(n) where n is not divisible by i\n        for j in 2...Int(n/(Double(i)))\
    \ + 1 {\n            // If n is not divisible by i, j is also not a prime\n  \
    \          if i % j == 0 {\n                break\n            }\n           \
    \ \n            // If j is not divisible by i, n is not divisible by j\n     \
    \       if j % i == 0 {\n                break\n            }\n        }\n   \
    \     \n        // If j reaches sqrt(n) without finding factor\n        if j ==\
    \ Int(sqrt(Double(n)))) {\n            // If i is prime factor\n            if\
    \ i == 1 {\n                // Add i to factors\n                factors.append(i)\n\
    \            } else {\n                // Add i*j to factors\n               \
    \ factors.append(i * j)\n            }\n        }\n    }\n    \n    // Return\
    \ factors\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpcr7qvgwo.swift:32:37: error: expected '{' after 'if' condition\n\
    \        if j == Int(sqrt(Double(n)))) {\n                                   \
    \ ^\n/tmp/tmpcr7qvgwo.swift:17:22: error: cannot find 'sqrt' in scope\n    for\
    \ i in 2...Int(sqrt(Double(n))) + 1 {\n                     ^~~~\n/tmp/tmpcr7qvgwo.swift:19:27:\
    \ error: binary operator '/' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        for j in 2...Int(n/(Double(i))) + 1 {\n                         ~^~~~~~~~~~~~\n\
    /tmp/tmpcr7qvgwo.swift:19:27: note: overloads for '/' exist with these partially\
    \ matching parameter lists: (Double, Double), (Int, Int)\n        for j in 2...Int(n/(Double(i)))\
    \ + 1 {\n                          ^\n"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    for prime in 2..<n+1 {\n        if n % prime == 0 {\n            if let count\
    \ = factorization.filter{$0 % prime == 0}.count {\n                factorization.append(count\
    \ * prime)\n            } else {\n                factorization.append(prime)\n\
    \            }\n        }\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps1l905mf.swift:15:48: warning: trailing closure in this context\
    \ is confusable with the body of the statement; pass as a parenthesized argument\
    \ to silence this warning\n            if let count = factorization.filter{$0\
    \ % prime == 0}.count {\n                                               ^\n  \
    \                                             (                )\n/tmp/tmps1l905mf.swift:15:16:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \            if let count = factorization.filter{$0 % prime == 0}.count {\n  \
    \             ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primes = Array(0..<n).filter({\
    \ n in divisors(n).isEmpty })\n    return primes.map { n in primeFactors(n) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpupgxufhu.swift:12:45: error: cannot find 'divisors' in scope\n\
    \    let primes = Array(0..<n).filter({ n in divisors(n).isEmpty })\n        \
    \                                    ^~~~~~~~\n/tmp/tmpupgxufhu.swift:13:30: error:\
    \ cannot find 'primeFactors' in scope\n    return primes.map { n in primeFactors(n)\
    \ }\n                             ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009625
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var isPrime = true\n    var factor = 1\n\n    for prime in 2..<(n / 2) {\n\
    \        if n == prime { break }\n        for factor in 2..<n / prime {\n    \
    \        isPrime = false\n            for candidate in factors {\n           \
    \     if candidate % prime == 0 {\n                    isPrime = true\n      \
    \              break\n                }\n            }\n            if isPrime\
    \ { factors.append(prime) }\n        }\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b1d90e49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1d90b40561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1d90b40286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1d90b4013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1d90b3fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmprxpxtv7b                        0x0000561552fbc045 <unavailable> + 8261

    6    tmprxpxtv7b                        0x0000561552fbb64b <unavailable> + 5707

    7    libc.so.6                          0x00002b1d91035460 __libc_start_main +
    245

    8    tmprxpxtv7b                        0x0000561552fbb369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660009625
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ [n]\n    }\n    if n > 2 {\n        var factors = [1]\n        var factorization\
    \ = [1]\n        var product = 1\n        while product != 0 {\n            product\
    \ *= n\n            if product > 2 {\n                factors.append(product)\n\
    \                factorization.append(1)\n            }\n            for index\
    \ in 0..<factors.count {\n                if factors[index] * factors[index] ==\
    \ n {\n                    factors[index] += 1\n                    break\n  \
    \              }\n            }\n        }\n        return factors\n    } else\
    \ {\n        return [n]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factorizations = factorizes(n)\n\
    \    var factors = [Int]()\n    for factorization in factorizations {\n      \
    \  let factorCount = count(factorization, in: n)\n        factors.append(factorCount)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6k_a7w8u.swift:12:26: error: cannot find 'factorizes' in scope\n\
    \    let factorizations = factorizes(n)\n                         ^~~~~~~~~~\n\
    /tmp/tmp6k_a7w8u.swift:15:27: error: cannot find 'count' in scope\n        let\
    \ factorCount = count(factorization, in: n)\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    func factorize(n: Int, result:\
    \ [Int] = []) -> [Int] {\n        if n%2 == 0 {\n            let remaining = n/2\n\
    \            result.append(remaining)\n            factorize(remaining, result:\
    \ result)\n        }\n        if n%3 != 0 {\n            let remaining = n/3\n\
    \            result.append(remaining)\n            factorize(remaining, result:\
    \ result)\n        }\n        return result\n    }\n\n    return factorize(n,\
    \ result: [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpziw_xmaj.swift:15:20: error: cannot use mutating member on immutable\
    \ value: 'result' is a 'let' constant\n            result.append(remaining)\n\
    \            ~~~~~~ ^\n/tmp/tmpziw_xmaj.swift:16:22: error: missing argument label\
    \ 'n:' in call\n            factorize(remaining, result: result)\n           \
    \          ^\n                      n: \n/tmp/tmpziw_xmaj.swift:20:20: error:\
    \ cannot use mutating member on immutable value: 'result' is a 'let' constant\n\
    \            result.append(remaining)\n            ~~~~~~ ^\n/tmp/tmpziw_xmaj.swift:21:22:\
    \ error: missing argument label 'n:' in call\n            factorize(remaining,\
    \ result: result)\n                     ^\n                      n: \n/tmp/tmpziw_xmaj.swift:26:21:\
    \ error: missing argument label 'n:' in call\n    return factorize(n, result:\
    \ [])\n                    ^\n                     n: \n"
  stdout: ''
  timestamp: 1660009625
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ [n]\n    }\n    var factors = [1]\n    var primes = [1]\n    var pows = [1]\n\
    \n    for i in 2...n {\n        if n % i == 0 {\n            factors[i] += 1\n\
    \            primes[i] += 1\n            pows[i] = pows[i-1] * i\n        } else\
    \ {\n            factors[i] = 1\n            primes[i] = 1\n            pows[i]\
    \ = 1\n        }\n    }\n\n    var factorization = [Int]()\n\n    for j in 2...n\
    \ {\n        if factors[j] == 1 {\n            if pows[j] == 1 {\n           \
    \     factorization.append(j)\n            } else {\n                factorization.append(j)\n\
    \                factors.append(pows[j])\n                primes.append(1)\n \
    \               pows.append(1)\n            }\n        }\n    }\n\n    return\
    \ factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6063945c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b606363c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b606363c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b606363c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b606363bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b606343b7ec <unavailable> + 186348

    6    tmp4dm627h7                        0x00005562efda510a <unavailable> + 8458

    7    tmp4dm627h7                        0x00005562efda458b <unavailable> + 5515

    8    libc.so.6                          0x00002b6063b31460 __libc_start_main +
    245

    9    tmp4dm627h7                        0x00005562efda42a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660009625
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    for prime in 2...n {\n        if n / prime == 1 {\n            factorization.append(prime)\n\
    \        } else {\n            var sum = 0\n            for number in 2...n /\
    \ prime {\n                sum += number\n                factorization.append(prime)\n\
    \            }\n            factorization.append(sum)\n            factorization.append(sum)\n\
    \        }\n    }\n    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmph6xuizvz/tmph6xuizvz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8b61691c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8b61388b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8b61388988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8b613877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph6xuizvz                        0x000055dc4aec168f <unavailable> + 5775

    5    libc.so.6                          0x00002b8b6187d460 __libc_start_main +
    245

    6    tmph6xuizvz                        0x000055dc4aec1209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009625
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n\n    var n = n\n    var factorization: [[Int]] = [[]]\n    var factors\
    \ = [Int]()\n    var sum = 0\n\n    while n > 1 {\n        if n % 2 == 0 {\n \
    \           factors.append(2)\n            n /= 2\n        } else {\n        \
    \    factors.append(1)\n            sum += factors.count\n            n /= 2\n\
    \        }\n\n        if n > 1 {\n            factorization[sum].append(n)\n \
    \       }\n    }\n\n    factorization[sum].append(n)\n    return factors\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4814d44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4814a3b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4814a3b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4814a3b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4814a3abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b4814a2410e <unavailable> + 1339662

    6    libswiftCore.so                    0x00002b4814a24490 Array.subscript.modify
    + 41

    7    tmp7djlg_5x                        0x00005600e07520c8 <unavailable> + 8392

    8    tmp7djlg_5x                        0x00005600e0751732 <unavailable> + 5938

    9    libc.so.6                          0x00002b4814f30460 __libc_start_main +
    245

    10   tmp7djlg_5x                        0x00005600e07511b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factors = factorization(n)\n\
    \n    var factorsSorted = [Int]()\n\n    for factor in factors {\n        factorsSorted.append(factors[factor])\n\
    \    }\n\n    return factorsSorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpemp6gi1a.swift:12:19: error: cannot find 'factorization' in scope\n\
    \    let factors = factorization(n)\n                  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var i = 2\n    repeat{\n        if n%i == 0 {\n            factors.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    } while\
    \ n != 0\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpt9w040h1.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009625
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactorization:\
    \ [Int] = []\n    for i in 2...n {\n        for j in 2...n {\n            if (i\
    \ / j) == n {\n                primeFactorization[i] = primeFactorization[i] +\
    \ 1\n                primeFactorization[j] = primeFactorization[j] + 1\n     \
    \       }\n        }\n    }\n    return primeFactorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpyquo5re1/tmpyquo5re1.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad6cbcfbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad6cb9f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad6cb9f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6cb9f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyquo5re1                        0x00005591996555a2 <unavailable> + 5538

    5    libc.so.6                          0x00002ad6cbee7460 __libc_start_main +
    245

    6    tmpyquo5re1                        0x00005591996551f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660009625
