name: HumanEval_30_get_positive
language: swift
prompt: "\n/// Return only positive numbers in the array.\n/// >>> get_positive(l:\
  \ [-1, 2, -4, 5, 6])\n/// [2, 5, 6]\n/// >>> get_positive(l: [5, 3, -5, 2, -3, 3,\
  \ 9, 0, 123, 1, -10])\n/// [5, 3, 2, 3, 9, 123, 1]\nfunc get_positive(l: [Int])\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(get_positive(l: [-1, -2, 4, 5, 6]) == [4,\
  \ 5, 6])\nassert(get_positive(l: [5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5,\
  \ 3, 2, 3, 3, 9, 123, 1])\nassert(get_positive(l: [-1, -2]) == [] as [Int])\nassert(get_positive(l:\
  \ [] as [Int]) == [] as [Int])"
completions: ["    return l.filter{(a :Int) -> Bool in\n        a > 0 && a\n    }",
  '    return l.filter{ $0 > 0 }', '    return l.filter {$0 >= 0}', '    return l.filter{
    $0 > 0 }', "    var i = 0\n    var j = 0\n    var result = [Int](count: l.count,\
    \ repeatedValue: 0)\n    while i < l.count {\n        if l[i] > 0 {\n        \
    \    result[j] = l[i]\n            j++\n        }\n        i++\n    }\n    return\
    \ result", "    var res = [Int]()\n    var inv = true\n    for elem in l {\n \
    \       if inv {\n            if elem < 0 {\n                inv = false\n   \
    \         } else {\n                res.append(elem)\n            }\n        }\
    \ else {\n            if elem < 0 {\n                inv = true\n            }\
    \ else {\n                res.append(elem)\n            }\n        }\n    }\n\
    \    return res", "    var res: [Int] = []\n    for n in l {\n        if n > 0\
    \ {\n            res += [n]\n        }\n    }\n    return res", '    return filter(_
    > 0, l)', "    var r = [Int]()\n    for x in l {\n        if x >= 0 {\n      \
    \      r.append(x)\n        }\n    }\n    return r", '    return l.filter({ $0
    >= 0 })', "    var ret: [Int] = []\n    for v in l {\n        if v > 0 {\n   \
    \         ret.append(v)\n        }\n    }\n    return ret", "    if l.count <\
    \ 1 {\n        return []\n    }\n    var result = [Int]()\n    for value in l\
    \ {\n        if value >= 0 {\n            result.append(value)\n        }\n  \
    \  }\n    return result", '    return filter(l, { $0 >= 0 })', "    var _l = l\n\
    \    var result = [Int]()\n    for x in _l {\n        if x > 0{\n            result.append(x)\n\
    \        }\n    }\n    return result", "    guard l.count > 0 else {\n       \
    \ return []\n    }\n\n    var positives = [Int]()\n    var lastPositive = Int.max\n\
    \    for i in 0..<l.count {\n        let current = l[i]\n        if current >\
    \ 0 && current > lastPositive {\n            positives.append(lastPositive)\n\
    \            lastPositive = current\n        } else {\n            lastPositive\
    \ = current\n        }\n    }\n    positives.append(lastPositive)\n\n    return\
    \ positives", "    var result: [Int] = []\n    for element in l {\n        if\
    \ element > 0 {\n            result.append(element)\n        }\n    }\n    return\
    \ result", "    var result = [Int]()\n    for el in l {\n        if el > 0 {\n\
    \            result.append(el)\n        }\n    }\n    return result", "    var\
    \ res: [Int] = []\n    for k in l {\n        if k < 0 {\n            continue\n\
    \        }\n        res.append(k)\n    }\n    return res", "    let res = [Int](l)\n\
    \    for x in res {\n        if x < 0 {\n            res.remove(x)\n        }\n\
    \    }\n    return res", '    return l.filter { $0 > 0 }', "    var result = [Int]()\n\
    \    for i in l {\n        if i > 0 {\n            result.append(i)\n        }\n\
    \    }\n    return result", "    var result = Array(repeating: 0, count: l.count)\n\
    \    for i in 0..<l.count {\n        if l[i] > 0 {\n            result[i] = l[i]\n\
    \        }\n    }\n    return result", '    return l.filter({ $0 > 0 })', "  \
    \  var r = [Int]()\n    for i in l {\n        if i < 0 {\n            return nil\n\
    \        }\n        r.append(i)\n    }\n    return r", '    return l.filter{ it
    > 0 }', "    var result: [Int] = []\n    for x in l {\n        if x > 0 {\n  \
    \          result.append(x)\n        }\n    }\n    return result", '    return
    l.filter { $0 > 0 }', '    return l.filter{ $0 >= 0 }', '    return l.filter(|x|
    x >= 0).sorted()', "    let m = l.count\n    var r = [Int](repeating: 0, count:\
    \ m)\n    for i in 0 ..< m {\n        if l[i] > 0 {\n            r[i] = l[i]\n\
    \        }\n    }\n    return r", "    var result = ArraySlice(l)\n    for i in\
    \ l.indices {\n        if result[i] < 0 {\n            result.removeAtIndex(i)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for x in\
    \ l {\n        if x >= 0 {\n            result.append(x)\n        }\n    }\n \
    \   return result", "    var res = [Int]()\n    for x in l {\n        if x > 0\
    \ {\n            res.append(x)\n        }\n    }\n    return res", "    let p\
    \ = Array(l)\n    var ret = [Int]()\n    for val in p {\n        if val >= 0 {\n\
    \            ret.append(val)\n        }\n    }\n    return ret", "    var result:\
    \ [Int] = []\n    for elem in l {\n        if elem >= 0 {\n            result.append(elem)\n\
    \        }\n    }\n    return result", "    var result: [Int] = []\n    for el\
    \ in l {\n        if el > 0 {\n            result.append(el)\n        }\n    }\n\
    \    return result", "    var res: [Int] = []\n    for i in l {\n        if i\
    \ > 0 {\n            res += [i]\n        }\n    }\n    return res", "    var positive\
    \ = [Int]()\n    for ele in l {\n        if ele > 0 {\n            positive.append(ele)\n\
    \        }\n    }\n    return positive", '    return filter(x: l, { x >= 0 })',
  "    if l == nil || l.count == 0 {\n        return nil\n    }\n\n    var result\
    \ = l\n    for i in 0..<l.count {\n        if l[i] < 0 {\n            result.removeAtIndex(i)\n\
    \        }\n    }\n    return result", "    if l == nil { return [] }\n    var\
    \ positives = [Int]()\n    for element in l {\n        if element > 0 {\n    \
    \        positives.append(element)\n        }\n    }\n    return positives", " \
    \   var positive = [Int]()\n    for i in l {\n        if i > 0 {\n           \
    \ positive.append(i)\n        }\n    }\n    return positive", '    return filter(l,
    func(x) -> x >= 0)', "    return l.filter {\n        switch $0 {\n        case\
    \ let x where x > 0: return true\n        case _: break\n        }\n        return\
    \ false\n    }", '    return l.filter{ $0 > 0 }', "    let s = l.sorted(by: {\
    \ (_, _) in 0 })\n    return Array(s[s.count - 1 : s.startIndex])", "    let r\
    \ = l\n    for x in l {\n        if x > 0  {\n            return r\n        }\
    \ else {\n            return []\n        }\n    }\n    return r", "    var result\
    \ = [Int]()\n    for element in l {\n        if element > 0 {\n            result.append(element)\n\
    \        }\n    }\n    return result", "    var i = 0\n    var result = [Int]()\n\
    \    for element in l {\n        if element > 0 {\n            result.append(element)\n\
    \        }\n        i += 1\n    }\n    return result", "    l = l.filter{($0 >=\
    \ 0)}\n    return l", "    var copy = l\n    for i in l {\n        if i < 0 {\n\
    \            copy.insert(i, 0)\n        }\n    }\n    return copy", "    let n\
    \ = l.count\n    var result = [Int]()\n    for var i = 0; i < n; i++ {\n     \
    \   let v = l[i]\n        if v >= 0 {\n            result.append(v)\n        }\n\
    \    }\n    return result", "    \n    if l.isEmpty() {\n        return l\n  \
    \  }\n    \n    var l = l\n    var result = [Int]()\n    \n    for i in 0..<l.count\
    \ {\n        if l[i] > 0 {\n            result.append(l[i])\n        }\n    }\n\
    \    \n    return result", '    l.filter { $0 >= 0 }', "    var res: [Int] = []\n\
    \    for x in l {\n        if x > 0 {\n            res.append(x)\n        }\n\
    \    }\n    return res", "    var result = [Int]()\n    for x in l {\n       \
    \ if x < 0 {\n            result.append(x)\n        }\n    }\n    return result",
  "    let s = l.filter({$0 > 0})\n    return s", "    var ret: [Int] = []\n    for\
    \ elt in l {\n        if elt >= 0 {\n            ret.append(elt)\n        }\n\
    \    }\n    return ret", '    l.filter{ $0 > 0 }', '    return l.filter { $0 >
    0 }', "    var result: [Int] = []\n    for i in l {\n        if i < 0 {\n    \
    \        result.append(i)\n        }\n    }\n    return result", "    var a =\
    \ [Int]()\n    for x in l {\n        if x >= 0 {\n            a.append(x)\n  \
    \      }\n    }\n    return a", '    return l.filter({ return $0 > 0 })', "  \
    \  var result = [Int](repeating: 0, count: l.count)\n    for i in 0 ..< l.count\
    \ {\n        if l[i] > 0 {\n            result[i] = l[i]\n        }\n    }\n \
    \   return result", "    var positive = l\n    for pos in l.indices {\n      \
    \  if l[pos] > 0 {\n            positive.remove(at: pos)\n        }\n    }\n \
    \   return positive", '    return l.filter{ $0 > 0 }', "    let sorted = l.sorted()\n\
    \    var positive = [Int]()\n    for i in sorted {\n        if i >= 0 {\n    \
    \        positive.append(i)\n        }\n    }\n    return positive", "    \n \
    \   let min = min(l)\n    return l.filter{ $0 < min }", "    var _retVal: [Int]\
    \ = [:]\n    for elem in l {\n        if elem > 0 {\n            _retVal.append(elem)\n\
    \        }\n    }\n    return _retVal", "    var result = [Int]()\n    for number\
    \ in l {\n        if number > 0 {\n            result.append(number)\n       \
    \ }\n    }\n    return result", '    return l.filter { $0 >= 0 }', "    var result\
    \ = [Int](repeating: 0, count: l.count)\n    for val in l {\n        if val >\
    \ 0 {\n            result[result.index] = val\n        }\n    }\n    return result",
  "    var ans = [Int](repeating: 0, count: l.count)\n    for x in l {\n        guard\
    \ x > 0 else {\n            return ans\n        }\n        ans[x] = x\n    }\n\
    \    return ans", "    var result = [Int]()\n    for x in l {\n        if x >\
    \ 0 {\n            result.append(x)\n        }\n    }\n    return result", '    return
    filter(l, |n| n > 0)', '    return l.filter{ $0 > 0 }', "    var result = [Int]()\n\
    \    var negated = true\n    for element in l {\n        if element < 0 {\n  \
    \          if negated {\n                result.removeAll(keepCapacity: false)\n\
    \            }\n            negated = false\n        } else {\n            result.append(element)\n\
    \        }\n    }\n    if negated {\n        result.removeAll(keepCapacity: false)\n\
    \    }\n    return result", '    return l.filter({$0 >= 0})', "    var positives\
    \ = [Int]()\n    for x in l {\n        if x > 0 {\n            positives.append(x)\n\
    \        }\n    }\n    return positives", "    var newArray: [Int] = []\n    var\
    \ negativeCount = 0\n    for val in l {\n        if val >= 0 {\n            newArray.append(val)\n\
    \        } else {\n            negativeCount += 1\n        }\n    }\n    if negativeCount\
    \ > 0 {\n        newArray = newArray[newArray.count-negativeCount:]\n    }\n \
    \   return newArray", "    let n = l.count\n    let positives = [Int](repeating:\
    \ 0, count: n)\n    for i in 0..<n {\n        positives[i] = max(0, l[i])\n  \
    \  }\n    return positives", "    if l.count == 0 { return l }\n    var result\
    \ = [Int]()\n    for i in 0 ..< l.count {\n        if l[i] > 0 { result.append(l[i])\
    \ }\n    }\n    return result", "    var ret = l\n    for index in stride(from:\
    \ 0, to: l.count, by: 1) {\n        if index < 0 {\n            ret = ret[index..<0]\n\
    \        }\n    }\n    return ret", "    if l.isEmpty() {\n        return l\n\
    \    }\n    var result = [Int]()\n    for item in l {\n        if item > 0 {\n\
    \            result.append(item)\n        }\n    }\n    return result", "    if\
    \ l.isEmpty {\n        return []\n    }\n    var newL = l\n    for i in newL.indices\
    \ {\n        if newL[i] < 0 {\n            newL[i] = 0\n        }\n    }\n   \
    \ return newL", "    var r = l\n    for idx in l.indices {\n        if l[idx]\
    \ > 0 {\n            r = r[..idx]\n        }\n    }\n    return r", "    let s\
    \ = l.sorted()\n    if s.count < 1 {\n        return s\n    }\n    let mut last\
    \ = Int()\n    for val in s {\n        if val < 0 {\n            break\n     \
    \   }\n        last = val\n    }\n    return last..<s.end().unwrap_or(s.last().unwrap_or(l.last()))",
  '    l.filter() { $0 <= 0 }', "    return l.filter {\n        $0 > 0\n    }", " \
    \   var r = [Int]()\n    for x in l {\n        if x >= 0 {\n            r.append(x)\n\
    \        }\n    }\n    return r", "    var positive = [Int]()\n    for var i =\
    \ 0; i < l.count; i++ {\n        if l[i] > 0 {\n            positive.append(l[i])\n\
    \        }\n    }\n    return positive", '    return filter(l, |x| x > 0)', '    return
    l.filter({ $0 >= 0 })', '    return l.filter{ $0 > 0 }', '    return filter(_
    < 0, l)', "    var positives = [Int]()\n    for number in l {\n        if number\
    \ > 0 {\n            positives.append(number)\n        }\n    }\n    return positives",
  '    return l.reduce([]) { $0 + [$1] }', '    return filter(l, isPositive)', '    return
    filter(l) { $0 > 0 }', "    var result = [Int]()\n    for element in l {\n   \
    \     if element > 0 {\n            result.append(element)\n        }\n    }\n\
    \    return result", '  return l.filter{ $0 > 0 }', "    var p = l\n    var r\
    \ = [Int](repeating: 0, count: l.count)\n    for k in 0 ..< p.count {\n      \
    \  if p[k] >= 0 {\n            r[k] = 1\n        }\n    }\n    return r", "  \
    \  var ret = [Int]()\n    for i in l {\n        if i > 0 {\n            ret.append(i)\n\
    \        }\n    }\n    return ret", '    return filter(l, isPositive)', '    return
    l.filter({ $0 > 0 })', "    var result = [Int]()\n    for i in l {\n        if\
    \ i > 0 {\n            result.append(i)\n        }\n    }\n    return result",
  "    var l = l.filter() { $0 > 0 }\n    return l", "    if l == nil { return []\
    \ }\n    var result = Array(repeating: 0, count: l.count)\n    for el in l {\n\
    \        if el < 0 { continue }\n        result[result.index(of: el)] += 1\n \
    \   }\n    return result", "    var positive: [Int] = []\n    for v in l {\n \
    \       if v >= 0 {\n            positive.append(v)\n        }\n    }\n    return\
    \ positive", "    if l == nil {\n        return nil\n    }\n    var r = l\n  \
    \  for &i in &l {\n        if i < 0 {\n            return nil\n        }\n   \
    \ }\n    return r", "    if l.count < 1 {\n        return []\n    }\n\n    var\
    \ newArray: [Int] = []\n    for elem in l {\n        if elem > 0 {\n         \
    \   newArray.append(elem)\n        }\n    }\n    return newArray", "    var positiveArray\
    \ = [Int]()\n    for x in l {\n        if x >= 0 {\n            positiveArray.append(x)\n\
    \        }\n    }\n    return positiveArray", "    if l == nil { return [] }\n\
    \    var result = [Int]()\n    for el in l {\n        if el > 0 {\n          \
    \  result.append(el)\n        }\n    }\n    return result", '    return l.filter{
    $0 >= 0 }', '  return l.filter({ $0 >= 0 })', "    var result = [Int]()\n    for\
    \ n in l {\n        if n > 0 {\n            result.append(n)\n        }\n    }\n\
    \    return result", "    guard l.count > 0 else { return [] }\n    var res: [Int]\
    \ = []\n    for idx in 0..<l.count {\n        if l[idx] >= 0 { res[idx] = l[idx]\
    \ }\n    }\n    return res", "    if l.count == 0 {\n        return l\n    }\n\
    \    let positive = [Int](l.map { $0 > 0 ? $0 : nil })\n    return positive",
  "    var out: [Int] = []\n    for i in l {\n        if i >= 0 {\n            out.append(i)\n\
    \        }\n    }\n    return out", "    var copy = l\n    for i : Int in 0..<copy.count\
    \ {\n        if copy[i] < 0 {\n            copy.removeAtIndex(i)\n        }\n\
    \    }\n    return copy", '    return l.filter({ $0 > 0 })', '    return l.filter{
    $0 > 0 }', "    let l = l.filter({ $0 >= 0 })\n    return l", "    let m = l.count\n\
    \    \n    var result = [Int](repeating: 0, count: m)\n    \n    for i in 0 ..<\
    \ m {\n        if l[i] > 0 {\n            result[i] = l[i]\n        }\n    }\n\
    \    \n    return result", "    var result = [Int]()\n    for x in l {\n     \
    \   if x > 0 {\n            result.append(x)\n        }\n    }\n    return result",
  '    return l.filter{ $0 >= 0 }', "    var result = [Int]()\n    for x in l {\n\
    \        if x < 0 {\n            continue\n        }\n        result.append(x)\n\
    \    }\n    return result", "    var new_l = [Int]()\n    for num in l {\n   \
    \     if num > 0 {\n            new_l.append(num)\n        }\n    }\n    return\
    \ new_l", '    return l.filter({$0 >= 0})', "    var result = [Int]()\n    for\
    \ e in l {\n        if e > 0 {\n            result.append(e)\n        }\n    }\n\
    \    return result", "    var result = [Int]()\n    for a in l {\n        if a\
    \ >= 0 {\n            result.append(a)\n        }\n    }\n    return result",
  "    var result: [Int] = []\n    for x in l {\n        if x >= 0 {\n           \
    \ result.append(x)\n        }\n    }\n    return result", '    return l.filter
    { $0 > 0 }', "    var result = [Int]()\n    for x in l {\n        if x > 0 {\n\
    \            result.append(x)\n        }\n    }\n    return result", "    var\
    \ result = [Int]()\n    for x in l {\n        if x < 0 {\n            continue\
    \ // skip negative number\n        }\n        result.append(x)\n    }\n    return\
    \ result", "    var result = Array(l)\n    for i in 0..<result.count {\n     \
    \   if result[i] < 0 {\n            result.removeAtIndex(i)\n        }\n    }\n\
    \    return result", "    return l.reduce([Int]()) { result, value in\n      \
    \  let negative = value < 0\n        guard negative == result.last else { return\
    \ result }\n        result.append(value).append(negative)\n        return result\n\
    \    }.dropLast()", '    return filter(l, isPositive)', '    return l.filter({
    $0 > 0 })', '    return l.filter {$0 >= 0}', "    let len = l.count\n    if len\
    \ < 1 {\n        return l\n    }\n    var res: [Int] = []\n    for i in 0 ..<\
    \ len {\n        if l[i] > 0 {\n            res += [Int](repeating: l[i], count:\
    \ len-i)\n        }\n    }\n    return res", "    \n    var p = [0]\n    for i\
    \ in l {\n        if i >= 0 {\n            p[0]++\n        } else {\n        \
    \    return nil\n        }\n    }\n    \n    var r = make([]Int, 0)\n    for i\
    \ = 1; i < p[0]; i++ {\n        r = append(r, 0)\n    }\n    \n    for i = 1;\
    \ i < len(l); i++ {\n        if l[i] > 0 {\n            if l[i] != 0 {\n     \
    \           r = append(r, l[i])\n            }\n        }\n    }\n    \n    return\
    \ r", "    var result = [Int]()\n    for el in l {\n        if el > 0 {\n    \
    \        result.append(el)\n        }\n    }\n    return result", '    return
    filter(l, func(x -> x > 0, true))', "    let positive = l.filter {$0 > 0}\n  \
    \  return positive", "    \n    if l.isEmpty {\n        return []\n    }\n   \
    \ var positive: [Int] = []\n    for number in l {\n        if number > 0 {\n \
    \           positive.append(number)\n        }\n    }\n    return positive", " \
    \   let result = Array(l)\n    if result.isEmpty {\n        return l\n    }\n\
    \    var i = 0\n    while i < result.count {\n        if result[i] < 0 {\n   \
    \         result.removeAtIndex(i)\n        } else {\n            i += 1\n    \
    \    }\n    }\n    return result", "    if l == nil || l.isEmpty {\n        return\
    \ l\n    }\n    var r = l\n    var result = [Int]()\n    for value in l {\n  \
    \      if value > 0 {\n            result.append(value)\n        } else {\n  \
    \          return result\n        }\n    }\n    return result", "    var result\
    \ = l\n    if !is_sorted(l) {\n        result = l.sorted()\n    }\n    var i =\
    \ result.startIndex\n    while i < result.endIndex {\n        if result[i] > 0\
    \ {\n            result.remove(at: i)\n        }\n        i += 1\n    }\n    return\
    \ result", "    return l.filter {\n        it > 0 && it != 0\n    }", "    var\
    \ result = [Int]()\n    for x in l {\n        if x > 0 {\n            result.append(x)\n\
    \        }\n    }\n    return result", '    l.filter{ $0 > 0 }', "    var result\
    \ = l\n    for idx in 0 ..< l.count {\n        if l[idx] < 0 {\n            result.removeAtIndex(idx)\n\
    \        }\n    }\n    return result", "    return l.filter{\n        $0 > 0\n\
    \    }", "    var positive = l\n    for index, _ in\n        enumerate(l) {\n\
    \        if index == 0 || l[index] > 0 {\n            positive = l[index:]\n \
    \       }\n    }\n    return positive", '    return l.filter{$0 > 0}.sorted()',
  "    let result = [Int]()\n    for x in l {\n        if x >= 0 {\n            result.append(x)\n\
    \        }\n    }\n    return result", "    var copy = l\n    var positive: [Int]\
    \ = []\n    while copy.count > 0 {\n        if copy[0] < 0 {\n            copy.removeFirst()\n\
    \        }\n        positive.append(copy[0])\n    }\n    return positive", '    return
    l.filter { $0 > 0 }', "    if l == nil {\n        return nil\n    }\n    var res:\
    \ [Int] = []\n    for x in l {\n        if x > 0  {\n            res.append(x)\n\
    \        }\n    }\n    return res", "    var result = [Int](repeating: 0, count:\
    \ l.count)\n    var j = 0\n    for i in 0..<l.count {\n        if l[i] > 0 {\n\
    \            result[j] = l[i]\n            j += 1\n        }\n    }\n    return\
    \ result", "    var l = l as! [Int]\n    for i in 0 ..< l.count {\n        if\
    \ l[i] > 0 {\n            return l\n        }\n    }\n    return l", '    return
    l.filter({ $0 > 0 })', '    return l.filter(is_positive)', "    var n = l.count\n\
    \    var i = 0\n    var positive: Int?\n    while i < n {\n        if l[i] < 0\
    \ {\n            negative = true\n        } else {\n            if !positive {\n\
    \                positive = l[i]\n            } else {\n                if l[i]\
    \ > positive {\n                    positive = l[i]\n                }\n     \
    \       }\n        }\n        i += 1\n    }\n    if positive == nil {\n      \
    \  positive = 0\n    }\n    if !negative {\n        l.removeAll(keep: {$0 >= positive})\n\
    \    } else {\n        l.removeAll(keep: {$0 <= 0})\n    }\n    return l", " \
    \   var result = [Int]()\n    for x in l {\n        if x >= 0 {\n            result.append(x)\n\
    \        }\n    }\n    return result", "    var res = l\n    for idx in 0 ..<\
    \ l.count {\n        if res[idx] >= 0 {\n            res = res[idx ..< l.count]\n\
    \        }\n    }\n    return res", "    var a = l\n    var result = [Int]()\n\
    \    for i in 0..<a.count {\n        if a[i] > 0 {\n            result.append(a[i])\n\
    \        }\n    }\n    return result", '    return filterPositive(l)', "    var\
    \ positive = [Int]()\n    for x in l {\n        if x > 0 {\n            positive.append(x)\n\
    \        }\n    }\n    return positive", '    return l.filter { $0 >= 0 }', " \
    \   let positive = l.filter{ $0 > 0 }\n    return positive", "    if l.count <=\
    \ 0 {\n        return nil\n    }\n    var result = Array()\n    for i in l {\n\
    \        if i < 0 {\n            return nil\n        }\n        result.append(i)\n\
    \    }\n    return result", '    return l.filter({ $0 >= 0 })', "    var l2 =\
    \ l.filter {$0 > 0}\n    if l2.count < l.count {\n        l2 = l.filter {$0 <\
    \ 0}\n    }\n    return l2", "    var r: [Int] = []\n    for x in l {\n      \
    \  if x > 0 {\n            r.append(x)\n        }\n    }\n    return r", '    return
    filter(l, { $0 >= 0 })', "    var result = [Int](repeating: 0, count: l.count)\n\
    \    if !l.isEmpty {\n        result.append (l[0])\n        for n in 1..<l.count\
    \ {\n            if l[n] >= 0 {\n                result[n] = l[n]\n          \
    \  }\n        }\n    }\n    return result", '    return l.filter({ $0 > 0 })',
  "    let result = Array(l.filter { $0 > 0 })\n    return result", '    return l.filter({
    $0 >= 0 })', "    var result = [Int]()\n    var i = 0\n    for n in l {\n    \
    \    if n >= 0 {\n            result.append(n)\n        }\n    }\n    return result",
  "    var result = [Int](repeating: 0, count: l.count)\n    for i in 0..<l.count\
    \ {\n        result[i] = l[i] > 0 ? l[i] : 0\n    }\n    return result", "   \
    \ var result = [Int]()\n    for x in l {\n        if x > 0 {\n            result.append(x)\n\
    \        }\n    }\n    return result", "    return l.filter {\n        guard $0\
    \ >= 0 else false\n        return true\n    }", "    let a = l.sorted()\n    var\
    \ i = 0\n    var j = 0\n    var r = [Int]()\n    while i < a.count {\n       \
    \ if a[i] > 0 {\n            if j != 0 {\n                r.insert(a[j], atIndex:\
    \ j)\n                j++\n            }\n        }\n        else {\n        \
    \    r.insert(a[i], atIndex: i)\n            i += 1\n        }\n    }\n    return\
    \ r", "    l = l + [0]\n    l = l + [0]\n    var r = [Int]()\n    var i = 0\n\
    \    while i < l.count {\n        if l[i] > 0 {\n            r.append(l[i])\n\
    \        }\n        i += 1\n    }\n    return r", "    var result = [Int]()\n\
    \    for x in l {\n        if x >= 0 { result.append(x) }\n    }\n    return result",
  "    var out = [Int]()\n    for i in l {\n        if i >= 0 {\n            out.append(i)\n\
    \        }\n    }\n    return out", "    switch l.count {\n    case 0: return\
    \ []\n    case 1: return [l[0]]\n    case 2: return [l[0], l[1]]\n    case 3:\
    \ return [l[0], l[1], l[2]]\n    case 4: return [l[0], l[1], l[2], l[3]]\n   \
    \ case 5: return [l[0], l[1], l[2], l[3], l[4]]\n    case 6: return [l[0], l[1],\
    \ l[2], l[3], l[4], l[5]]\n    case 7: return [l[0], l[1], l[2], l[3], l[4], l[5],\
    \ l[6]]\n    case 8: return [l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7]]\n\
    \    case 9: return [l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8]]\n \
    \   case 10: return [l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9]]\n\
    \    case 11: return [l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9],\
    \ l[10]]\n    case 12: return [l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7],\
    \ l[8], l[9], l[10], l[11]]\n    case 13: return [l[0], l[1], l[2], l[3], l[4],\
    \ l[5], l[6], l[7], l[8], l[9], l[10], l[11], l[12]]\n    case 14: return [l[0],\
    \ l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9], l[10], l[11], l[12], l[13]]\n\
    \    case 15: return [l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9],\
    \ l[10], l[11], l[12], l[13], l[14]]\n    case 16: return [l[0], l[1], l[2], l[3],\
    \ l[4], l[5], l[6], l[7], l[8], l[9], l[10], l[11], l[12], l[13], l[14], l[15]]\n\
    \    case 17: return [l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9],\
    \ l[10], l[11], l[12], l[13], l[14], l[15], l[16]]\n    case 18: return [l[0],\
    \ l[1], l[2], l[3], l[4], l[5], l", '    return l.filter({ $0 > 0 })', "    var\
    \ result = [Int]()\n    for i in l {\n        if i < 0 {\n            continue\n\
    \        }\n        result.append(i)\n    }\n    return result", '    return l.filter({
    $0 >= 0 })', "    var l = l as! [Int]\n    for i in 0..<l.count {\n        if\
    \ l[i] < 0 {\n            l.removeAtIndex(i)\n        }\n    }\n    return l",
  '    return l.filter({ $0 > 0 })', "    var result: [Int] = []\n    for x in l {\n\
    \        if x >= 0 {\n            result.append(x)\n        }\n    }\n    return\
    \ result", "    var r = [Int]()\n    for x in l {\n        if x > 0 {\n      \
    \      r.append(x)\n        }\n    }\n    return r", "    var result = [Int]()\n\
    \    for i in l {\n        if i >= 0 {\n            result.append(i)\n       \
    \ }\n    }\n    return result", "    if l == nil {\n        return nil\n    }\n\
    \    var result = Array(count: l.count, repeatedValue: 0)\n    for elem in l {\n\
    \        if elem > 0 {\n            result[result.index(for: elem)!] = elem\n\
    \        }\n    }\n    return result", "    let s = l.map { Int($0) }\n    if\
    \ s.count < l.count {\n        l.sort()\n    }\n    return l"]
stop_tokens:
- "\n}"
