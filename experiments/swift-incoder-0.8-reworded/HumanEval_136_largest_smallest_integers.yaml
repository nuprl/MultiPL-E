name: HumanEval_136_largest_smallest_integers
language: swift
prompt: "\n/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in an array.\n/// If there is no negative or positive integers, return them as\
  \ nil.\n/// Examples:\n/// >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])\n\
  /// (nil, 1)\n/// >>> largest_smallest_integers(lst: [] as [Int])\n/// (nil, nil)\n\
  /// >>> largest_smallest_integers(lst: [0])\n/// (nil, nil)\nfunc largest_smallest_integers(lst:\
  \ [Int]) -> (Int?, Int?) {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(largest_smallest_integers(lst: [2, 4, 1,\
  \ 3, 5, 7]) == (nil, 1))\nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5,\
  \ 7, 0]) == (nil, 1))\nassert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6,\
  \ -2]) == (-2, 1))\nassert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7])\
  \ == (-7, 2))\nassert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9])\
  \ == (-9, 2))\nassert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))\n\
  assert(largest_smallest_integers(lst: [0]) == (nil, nil))\nassert(largest_smallest_integers(lst:\
  \ [-1, -3, -5, -6]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-1, -3,\
  \ -5, -6, 0]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-6, -4, -4,\
  \ -3, 1]) == (-3, 1))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100,\
  \ 1]) == (-3, 1))"
completions: ["  // Find the largest and smallest numbers\n  var largest: Int?\n \
    \ var smallest: Int?\n  for v in lst {\n    if v > largest {\n      largest =\
    \ v\n    } else if v < smallest {\n      smallest = v\n    }\n  }\n\n  return\
    \ (largest, smallest)", "    if lst.isEmpty {\n        return (Nil, Nil)\n   \
    \ }\n\n    var largest: Int?\n    var smallest: Int?\n    for num in lst {\n \
    \       switch num {\n        case 0...255:\n            largest = num\n     \
    \   case -256...-1:\n            smallest = num\n        default:\n          \
    \  if largest == nil {\n                largest = num\n            } else {\n\
    \                if smallest == nil {\n                    smallest = num\n  \
    \              } else {\n                    if num > largest! {\n           \
    \             largest = num\n                    } else if num < smallest! {\n\
    \                        smallest = num\n                    }\n             \
    \   }\n            }\n        }\n    }\n\n    return (largest, smallest)", " \
    \   var a = Int?(nil)\n    var b = Int?(nil)\n    for number in lst {\n      \
    \  if number > 0 {\n            b = number\n        } else {\n            a =\
    \ number\n        }\n    }\n    return (a, b)", "  guard lst.count > 0 else {\
    \ return (nil, nil) }\n\n  var min = lst[0]\n  var max = lst[0]\n  var idx = 1\n\
    \  for item in lst {\n    if item < min {\n      min = item\n      idx = idx\n\
    \    } else if item > max {\n      max = item\n    }\n  }\n\n  switch lst.count\
    \ {\n  case 2:\n    return (idx, max)\n  case 3:\n    return (idx, min, max)\n\
    \  case 4:\n    return (idx, min, max, lst[3])\n  default:\n    return (idx, min,\
    \ max, lst[0])\n  }", "    var max: Int?\n    var min: Int?\n    for number in\
    \ lst {\n        if number < min {\n            min = number\n        } else if\
    \ number > max {\n            max = number\n        }\n    }\n    return (max,\
    \ min)", "    // find the first non-negative number\n    var biggest = nil\n \
    \   var smallest = nil\n    for i in lst {\n        if i > 0 {\n            if\
    \ biggest! > i {\n                biggest = i\n            }\n            else\
    \ {\n                smallest = i\n            }\n        }\n    }\n    return\
    \ (biggest, smallest)", "  let n = lst.count\n  if n == 0 {\n    return (nil,\
    \ nil)\n  }\n  var max: Int?\n  var min: Int?\n  var largest = nil\n  var smallest\
    \ = nil\n  for idx in 0..<n {\n    let num = lst[idx]\n    if num > max {\n  \
    \    largest = num\n    } else if num < min {\n      min = num\n    } else {\n\
    \      continue\n    }\n    if max < 0 {\n      max = -max\n    }\n    if min\
    \ > 0 {\n      min = -min\n    }\n  }\n  if max < min {\n    return (min, largest)\n\
    \  }\n  return (largest, min)", "    guard lst.count > 0 else {\n        return\
    \ (nil, nil)\n    }\n    var smallest = Int.max\n    var largest = Int.min\n\n\
    \    for x in lst {\n        if x < smallest {\n            smallest = x\n   \
    \     }\n        if x > largest {\n            largest = x\n        }\n    }\n\
    \    return (smallest, largest)", "    func largest(a : Int?, b : Int?) -> Int?\
    \ {\n        return a > b ? a : b\n    }\n    func smallest(a: Int?, b: Int?)\
    \ -> Int? {\n        return a < b ? a : b\n    }\n    var a = nil, b = nil\n \
    \   if lst.count > 0 {\n        a = largest(lst[0], lst[0])\n        for i : Int\
    \ in 1..<lst.count {\n            if largest(a, lst[i]) == nil {\n           \
    \     a = largest(a, lst[i])\n            } else if smallest(a, lst[i]) == nil\
    \ {\n                a = smallest(a, lst[i])\n            } else {\n         \
    \       break\n            }\n        }\n        if a != nil && b != nil && largest(a,\
    \ b) == nil {\n            b = smallest(a, b!)\n        }\n    }\n    return (a,\
    \ b)", "    if lst.isEmpty() {\n        return (nil, nil)\n    }\n    if lst.count\
    \ == 1 {\n        return (nil, lst.first!)\n    }\n    var largest = lst.first!\n\
    \    var smallest = lst.first!\n    for i in lst {\n        if i < smallest {\n\
    \            smallest = i\n        }\n        if i > largest {\n            largest\
    \ = i\n        }\n    }\n    return (largest, smallest)", "    guard lst.count\
    \ > 0 else {\n        return (nil, nil)\n    }\n\n    guard let first = lst[0],\
    \ last = lst[lst.count-1] else {\n        return (nil, nil)\n    }\n\n    if first\
    \ > last {\n        return (nil, nil)\n    }\n\n    func smallest(lst: [Int])\
    \ -> (Int?, Int?) {\n        guard let first = lst[0], last = lst[lst.count-1]\
    \ else {\n            return (nil, nil)\n        }\n\n        if first < last\
    \ {\n            return (lst.firstIndex(of: first), lst.firstIndex(of: last))\n\
    \        } else {\n            return (nil, nil)\n        }\n    }\n\n    func\
    \ largest(lst: [Int]) -> (Int?, Int?) {\n        guard let first = lst[0], last\
    \ = lst[lst.count-1] else {\n            return (nil, nil)\n        }\n\n    \
    \    if first > last {\n            return (lst.firstIndex(of: first), lst.firstIndex(of:\
    \ last))\n        } else {\n            return (nil, nil)\n        }\n    }\n\n\
    \    guard let first = smallest(lst: lst), last = largest(lst: lst) else {\n \
    \       return (nil, nil)\n    }\n\n    return (first..<last, first..<last)",
  "    var max_i: Int? = nil\n    var min_i: Int? = nil\n    for i in lst {\n    \
    \    if i == 0 {\n            continue\n        }\n        if min_i == nil ||\
    \ i > min_i {\n            min_i = i\n        }\n        if max_i == nil || i\
    \ < max_i {\n            max_i = i\n        }\n    }\n    return (max_i, min_i)",
  "  var min_num = Int()\n  var max_num = Int()\n  for number in lst {\n    if number\
    \ > max_num {\n      max_num = number\n    } else if number < min_num {\n    \
    \  min_num = number\n    }\n  }\n  if min_num > max_num {\n    return (min_num,\
    \ max_num)\n  }\n  return (nil, nil)", "\tdefer func() {\n\t\tlst = nil\n\t}()\n\
    \tif lst.isEmpty {\n\t\treturn (nil, nil)\n\t}\n\n\tsmallest := Int.MinValue\n\
    \tvar smallest Int?\n\tvar largest Int?\n\n\tfor _, n := range lst {\n\t\tif n\
    \ >= 0 {\n\t\t\tlargest = maxInt(largest, n)\n\t\t} else {\n\t\t\tsmallest = minInt(smallest,\
    \ n)\n\t\t}\n\t}\n\n\treturn (largest, smallest)", "    // Sort and find the first\
    \ and last non-NaN values\n    var firstNonNan : Int? = nil\n    var lastNonNan\
    \ : Int? = nil\n    for x in lst {\n        if !Float64(x).isNaN && firstNonNan\
    \ == nil {\n            firstNonNan = x\n        } else if !Float64(x).isNaN &&\
    \ lastNonNan == nil {\n            lastNonNan = x\n        }\n    }\n\n    var\
    \ smallest = firstNonNan\n    var largest = lastNonNan\n    if firstNonNan ==\
    \ nil && lastNonNan == nil {\n        return (nil, nil)\n    }\n\n    if firstNonNan\
    \ == nil {\n        return (firstNonNan, nil)\n    }\n\n    if lastNonNan == nil\
    \ {\n        return (lastNonNan, nil)\n    }\n\n    // If there are no negative\
    \ numbers in `lst`, then the smallest\n    // number must also be the first one.\n\
    \    if firstNonNan.value < 0 {\n        smallest = firstNonNan\n    }\n\n   \
    \ // If there are no positive numbers in `lst`, then the largest\n    // number\
    \ must also be the last one.\n    if lastNonNan.value > 0 {\n        largest =\
    \ lastNonNan\n    }\n\n    return (largest, smallest)", "    var a: Int? = nil\n\
    \    var b: Int? = nil\n    for el in lst {\n        if el < 0 {\n           \
    \ if a == nil {\n                a = el\n            } else {\n              \
    \  b = el\n            }\n        } else {\n            if b == nil {\n      \
    \          b = el\n            } else {\n                a = el\n            }\n\
    \        }\n    }\n    return (\n        a,\n        b,\n    )", "  var smallest\
    \ = Int?()\n  var largest = Int?()\n  for value in lst {\n    if value < 0 {\n\
    \      largest = value\n    } else {\n      smallest = value\n    }\n  }\n  return\
    \ (smallest, largest)", "    if lst.count == 0 {\n        return (Int?(Int64.min),\
    \ Int?(Int64.max))\n    }\n\n    let minPositive = lst.filter({ $0 < Int64.max\
    \ }).min()\n    let minNegative = lst.filter({ $0 > Int64.min }).max()\n    return\
    \ (Int?(minPositive), Int?(minNegative))", "    var max: Int? = nil\n    var min:\
    \ Int? = nil\n    for x in lst {\n        if x >= 0 {\n            if max < x\
    \ {\n                max = x\n            }\n        } else {\n            if\
    \ min > x {\n                min = x\n            }\n        }\n    }\n    return\
    \ (min, max)", "    var smallest: Int?\n    var largest: Int?\n    smallest =\
    \ nil\n    largest = nil\n    for el in lst {\n        if smallest == nil || el\
    \ < smallest {\n            smallest = el\n        }\n        if largest == nil\
    \ || el > largest {\n            largest = el\n        }\n    }\n    return (largest,\
    \ smallest)", "  if lst.isEmpty {\n    return (nil, nil)\n  }\n\n  var largest:\
    \ Int?\n  var smallest: Int?\n  var largestInd: Int = 0\n  var smallestInd: Int\
    \ = 0\n  for i := 0; i < lst.count; i++ {\n    if lst[i] < 0 {\n      if largest\
    \ == nil {\n        largest = lst[i]\n      } else {\n        smallest = largest\n\
    \        largest = lst[i]\n      }\n      largestInd = i\n    } else if lst[i]\
    \ > 0 {\n      if smallest == nil {\n        smallest = lst[i]\n      } else {\n\
    \        largest = smallest\n        smallest = lst[i]\n      }\n      smallestInd\
    \ = i\n    }\n  }\n\n  return (largest, smallest)", "    var min: Int? = nil\n\
    \    var max: Int? = nil\n    for num in lst {\n        if num < min {\n     \
    \       min = num\n        } else if num > max {\n            max = num\n    \
    \    }\n    }\n    return (min, max)", "    guard lst.count > 0 else {\n     \
    \   return (nil, nil)\n    }\n\n    guard lst.count <= 2 else {\n        // O(N)\
    \ search for the largest and smallest elements\n        var smallest = Int?(lst.min())\n\
    \        var largest = Int?(lst.max())\n        if smallest == nil && largest\
    \ == nil {\n            return (nil, nil)\n        }\n        return (largest!,\
    \ smallest!)\n    }\n\n    var smallest = Int?(lst.min())\n    var largest = Int?(lst.max())\n\
    \    if smallest == nil && largest == nil {\n        return (nil, nil)\n    }\n\
    \    if smallest == nil {\n        return (nil, largest!)\n    }\n    if largest\
    \ == nil {\n        return (smallest!, nil)\n    }\n\n    var smallestIndex =\
    \ lst.startIndex\n    var largestIndex = lst.startIndex\n    for i in lst.indices\
    \ {\n        let number = lst[i]\n        if number < smallest {\n           \
    \ smallestIndex = i\n            smallest = number\n        }\n        if number\
    \ > largest {\n            largestIndex = i\n            largest = number\n  \
    \      }\n    }\n    return (lst[smallestIndex], lst[largestIndex])", "    guard\
    \ !lst.isEmpty else { return (nil, nil) }\n    var largest: Int? = nil\n    var\
    \ smallest: Int? = nil\n    for value in lst {\n        if value >= 0 {\n    \
    \        if smallest == nil {\n                smallest = value\n            }\
    \ else {\n                if value < smallest {\n                    smallest\
    \ = value\n                }\n            }\n        } else {\n            if\
    \ largest == nil {\n                largest = value\n            } else {\n  \
    \              if value > largest {\n                    largest = value\n   \
    \             }\n            }\n        }\n    }\n    return (largest, smallest)",
  "    if lst.isEmpty() {\n        return (nil, nil)\n    }\n    var min: Int? = nil\n\
    \    var max: Int? = nil\n    for e in lst {\n        if e > max {\n         \
    \   max = e\n        } else if e < min {\n            min = e\n        }\n   \
    \ }\n    return (min, max)", "    var largest = Int?(0)\n    var smallest = Int?(0)\n\
    \    for number in lst {\n        if number > largest! {\n            largest\
    \ = number\n        }\n        if number < smallest! {\n            smallest =\
    \ number\n        }\n    }\n    return (largest, smallest)", "\t\n\tvar min: Int?\
    \ = nil\n\tvar max: Int? = nil\n\t\n\tguard lst.count > 0 else {\n\t\treturn (nil,\
    \ nil)\n\t}\n\t\n\tfor idx in 0 ..< lst.count {\n\t\tlet v = lst[idx]\n\t\tif\
    \ v < 0 {\n\t\t\tif min == nil {\n\t\t\t\tmin = v\n\t\t\t} else {\n\t\t\t\tmax\
    \ = v\n\t\t\t}\n\t\t} else {\n\t\t\tif max == nil {\n\t\t\t\tmax = v\n\t\t\t}\
    \ else {\n\t\t\t\tif v > max! {\n\t\t\t\t\tmax = v\n\t\t\t\t} else if v < min!\
    \ {\n\t\t\t\t\tmin = v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (min, max)",
  "  if lst.isEmpty { return (nil, nil) }\n  var largest = Int?(0)\n  var smallest\
    \ = Int?(0)\n  for elem in lst {\n    if elem.isNaN { return (nil, nil) }\n  \
    \  if largest == nil || elem > largest {\n      largest = elem\n    }\n    if\
    \ smallest == nil || elem < smallest {\n      smallest = elem\n    }\n  }\n  return\
    \ (largest, smallest)", "  guard let first = lst.first else { return (nil, nil)\
    \ }\n  guard let max = lst.max else { return (nil, nil) }\n  guard let min = lst.min\
    \ else { return (nil, nil) }\n  guard lst.count >= 2 else { return (nil, nil)\
    \ }\n  return (min!, max!)", "    guard !lst.isEmpty else { return (nil, nil)\
    \ }\n    let max = lst[0]\n    let min = lst[0]\n    for i in lst {\n        if\
    \ i > max {\n            max = i\n        } else if i < min {\n            min\
    \ = i\n        }\n    }\n    return (min, max)", "    switch lst.count {\n   \
    \ case 0:\n        return (nil, nil)\n    case 1:\n        return (nil, lst[0])\n\
    \    case 2:\n        if lst[0] < lst[1] {\n            return (lst[0], nil)\n\
    \        }\n        return (nil, lst[1])\n    default:\n        let minVal = minElement(lst)\n\
    \        let maxVal = maxElement(lst)\n        return (minVal, maxVal)\n    }",
  "    if lst.count == 0 {\n        return (nil, nil)\n    }\n    var min = 0\n  \
    \  var max = lst[0]\n    for i in 1..<lst.count {\n        if lst[i] < min {\n\
    \            min = lst[i]\n        }\n        if lst[i] > max {\n            max\
    \ = lst[i]\n        }\n    }\n    return (min, max)", "  var min: Int?\n  var\
    \ max: Int?\n  for case let x <- lst {\n    if x < 0 {\n      if min == nil ||\
    \ x > min {\n        min = x\n      }\n    } else if x > max {\n      if max ==\
    \ nil || x < max {\n        max = x\n      }\n    }\n  }\n  return (min, max)",
  "    // Use a helper function to avoid code duplication\n    let (lower, higher)\
    \ = largest_smallest_integers(lst)\n\n    if !lower {\n        return (nil, nil)\n\
    \    } else if !higher {\n        return (lower, nil)\n    }\n\n    return (lower,\
    \ higher)", "    var largest: Int?\n    var smallest: Int?\n    var max: Int?\
    \ = nil\n    var min: Int? = nil\n    for x in lst {\n        if x < 0 {\n   \
    \         largest = x\n        } else if x > 0 {\n            smallest = x\n \
    \       }\n        if max == nil {\n            max = x\n        } else if x >\
    \ max {\n            max = x\n        }\n        if min == nil {\n           \
    \ min = x\n        } else if x < min {\n            min = x\n        }\n    }\n\
    \    return (largest, smallest)", "\tmaxN := -1000\n\tminN := 1000\n\tfor _, num\
    \ := range lst {\n\t\tif num < minN {\n\t\t\tminN = num\n\t\t} else if num > maxN\
    \ {\n\t\t\tmaxN = num\n\t\t}\n\t}\n\treturn (minN, maxN)", "    if lst.isEmpty\
    \ {\n        return (nil, nil)\n    }\n\n    var largest = lst[0]\n    var smallest\
    \ = lst[0]\n\n    for index in lst.indices {\n        if largest < lst[index]\
    \ {\n            largest = lst[index]\n        }\n        if smallest > lst[index]\
    \ {\n            smallest = lst[index]\n        }\n    }\n\n    return (largest,\
    \ smallest)", "    var min = Int()\n    var max = Int()\n    if lst.isEmpty {\n\
    \        return (nil, nil)\n    }\n    for number in lst {\n        if number\
    \ > max {\n            max = number\n        } else if number < min {\n      \
    \      min = number\n        }\n    }\n    return (min, nil)", "  // First compute\
    \ the smallest and largest elements\n  guard lst.count > 0 else {\n    return\
    \ (Int?(nil), Int?(nil))\n  }\n  var smallest = Int?(0)\n  var largest = Int?(0)\n\
    \  for element in lst {\n    if element > 0 {\n      largest = element\n    }\
    \ else if element < 0 {\n      smallest = element\n    } else {\n      break\n\
    \    }\n  }\n  if smallest == nil {\n    return (Int?(nil), Int?(nil))\n  }\n\n\
    \  // Return the smallest/largest element in the array\n  return (smallest, largest)",
  "    // TODO: return nil if no integers are found\n    var max: Int? = nil\n   \
    \ var min: Int? = nil\n    for number in lst {\n        if number > 0 {\n    \
    \        if max < number {\n                max = number\n            }\n    \
    \    } else {\n            if min > number {\n                min = number\n \
    \           }\n        }\n    }\n    return (max, min)", "  if lst.count == 0\
    \ {\n    return (nil, nil)\n  }\n\n  guard let maxValue = lst.min(), let minValue\
    \ = lst.max() else {\n    return (nil, nil)\n  }\n\n  return (maxValue, minValue)",
  "    var smallest = Int?()\n    var largest = Int?()\n    for number in lst {\n\
    \        if number < smallest {\n            largest = number\n        } else\
    \ if number > largest {\n            smallest = number\n        } else {\n   \
    \         number = smallest\n        }\n    }\n    return (largest, smallest)",
  '    return lst.iter().enumerate().reduce(nil) { $0.1 == nil ? $0.2 : ($0.1 < $0.1
    ? $0.1 : $0.1, $0.2 < $0.2 ? $0.2 : $0.2) }', "    var smallest: Int?\n    var\
    \ largest: Int?\n    for v in lst {\n        if v < 0 {\n            smallest\
    \ = v\n        } else {\n            largest = v\n        }\n    }\n    return\
    \ (largest, smallest)", "    if lst.isEmpty() {\n        return (nil, nil)\n \
    \   }\n\n    if lst.first > 0 {\n        return (nil, lst.first)\n    }\n\n  \
    \  if lst.first < 0 {\n        return (lst.first, lst.last)\n    }\n\n    return\
    \ largest_smallest_integers(lst.dropFirst())", "    guard !lst.isEmpty else {\
    \ return (nil, nil) }\n    guard let minInt = min(lst) else {\n        return\
    \ (nil, nil)\n    }\n    guard let maxInt = max(lst) else {\n        return (nil,\
    \ nil)\n    }\n    return (minInt, maxInt)", "    // Special case for empty list\n\
    \    guard lst.count > 0 else {\n        return (nil, nil)\n    }\n    // Initialize\
    \ max\n    var max: Int?\n    // Initialize min\n    var min: Int?\n    // Check\
    \ every element in array\n    for element in lst {\n        // Find max and min\
    \ in current element\n        guard let newMax = max,\n              let newMin\
    \ = min,\n              newMax > element,\n              newMin < element else\
    \ {\n            return (nil, nil)\n        }\n        // Update max and min\n\
    \        max = newMax\n        min = newMin\n    }\n    return (min,max)", " \
    \   if lst.isEmpty() {\n        return (nil, nil)\n    }\n    var smallest = Int?()\n\
    \    var largest = Int?()\n    for x in lst {\n        if x < 0 {\n          \
    \  smallest = x\n        } else {\n            largest = x\n        }\n    }\n\
    \    return (largest, smallest)", '    return find_max_min(lst, is_positive)',
  "    var largest = Int?()\n    var smallest = Int?()\n\n    for num in lst {\n \
    \       largest = num.max()\n        smallest = num.min()\n\n        if largest!\
    \ == nil {\n            largest = num\n        } else if smallest! == nil {\n\
    \            smallest = num\n        }\n    }\n\n    return (largest, smallest)",
  "  var min = Int()\n  var max = Int()\n  for num in lst {\n    if num < min {\n\
    \      min = num\n    } else if num > max {\n      max = num\n    }\n  }\n  if\
    \ min == Int.min {\n    return (Int.min, Int.max)\n  } else if max == Int.max\
    \ {\n    return (Int.max, Int.min)\n  }\n  return (min, max)", "    // Check for\
    \ empty list\n    if len(lst) == 0 {\n        return (nil, nil)\n    }\n    var\
    \ maxInt : Int? = nil\n    var minInt : Int? = nil\n    // Iterate through the\
    \ list\n    for x in lst {\n        if x < 0 {\n            if maxInt == nil {\n\
    \                // No negative integers, set the new max\n                maxInt\
    \ = x\n            } else {\n                // There is at least one negative\
    \ integer, but no bigger one than the previous\n                // Return the\
    \ bigger negative integer as the new max\n                maxInt = x\n       \
    \     }\n        } else {\n            if minInt == nil {\n                //\
    \ No positive integers, set the new min\n                minInt = x\n        \
    \    } else {\n                // There is at least one positive integer, but\
    \ no smaller one than the previous\n                // Return the smaller positive\
    \ integer as the new min\n                minInt = x\n            }\n        }\n\
    \    }\n    // Return the result if we found both min/max\n    return (minInt,\
    \ maxInt)", "  var min: Int?\n  var max: Int?\n  for value in lst {\n    if value\
    \ < 0 {\n      if min == nil {\n        min = value\n      }\n      continue\n\
    \    }\n    if max < 0 {\n      max = value\n    }\n  }\n  return (min, max)",
  '    return maxSmallestIntegers(lst)', "    var largest = nil\n    var smallest\
    \ = nil\n    for elt in lst {\n        if let elt = elt as? Int {\n          \
    \  if largest == nil || elt > largest {\n                largest = elt\n     \
    \       }\n            if smallest == nil || elt < smallest {\n              \
    \  smallest = elt\n            }\n        } else {\n            if largest ==\
    \ nil || elt > largest {\n                largest = elt\n            }\n     \
    \   }\n    }\n    return (largest, smallest)", "    // Get all of the numbers\
    \ in the list that have an 'Int' type.\n    var numbers = lst.filter{ $0.isKind(of:\
    \ Int.self) }\n    if numbers.count == 0 {\n        return (Int?(), Int?())\n\
    \    }\n\n    // Get the largest of the numbers.\n    var largest = numbers.max()\n\
    \    if largest == Int?() {\n        // If the largest number is nil, return nil\
    \ without an 'Int' type.\n        return (Int?(), Int?())\n    }\n\n    // Get\
    \ the smallest of the numbers.\n    var smallest = numbers.min()\n    if smallest\
    \ == Int?() {\n        // If the smallest number is nil, return nil without an\
    \ 'Int' type.\n        return (Int?(), Int?())\n    }\n\n    return (largest,\
    \ smallest)", "    guard let min = lst.min(by: {$0 < 0}), let max = lst.max(by:\
    \ {$0 >= 0}) else { return (nil, nil) }\n    return (max, min)", "  if lst.isEmpty()\
    \ {\n    return (null, null)\n  }\n  guard let first = lst.first else {\n    return\
    \ (null, null)\n  }\n  var min = first\n  var max = first\n  for element in lst\
    \ {\n    if element > min {\n      min = element\n    }\n    if element < max\
    \ {\n      max = element\n    }\n  }\n  return (max, min)", "    if lst.count\
    \ < 2 { return (nil, nil) }\n\n    // Find first index of first element > 0, then\
    \ return that index and next index\n    var firstIndexOfPositive = 0\n    var\
    \ firstIndexOfNegative = 0\n    for index in lst.indices {\n        if lst[index]\
    \ > 0 {\n            firstIndexOfPositive = index\n            break\n       \
    \ } else {\n            firstIndexOfNegative = index\n        }\n    }\n\n   \
    \ return (lst[firstIndexOfPositive], lst[firstIndexOfNegative])", "  var largest:\
    \ Int? = nil\n  var smallest: Int? = nil\n  for el in lst {\n    if el < 0 {\n\
    \      largest = el\n    } else if el > 0 {\n      smallest = el\n    }\n  }\n\
    \  return (largest, smallest)", "    var min: Int? = nil\n    var max: Int? =\
    \ nil\n\n    for val in lst {\n        if min == nil || val < min {\n        \
    \    min = val\n        }\n        if max == nil || val > max {\n            max\
    \ = val\n        }\n    }\n\n    return (min, max)", "    var a = Int?(0)\n  \
    \  var b = Int?(0)\n    for x in lst {\n        if x < 0 {\n            a = nil\n\
    \            break\n        }\n        a = x\n    }\n    for x in lst {\n    \
    \    if x > 0 {\n            b = nil\n            break\n        }\n        b\
    \ = x\n    }\n    return (a, b)", "    let min = Int64(math.min(lst))\n    let\
    \ max = Int64(math.max(lst))\n    guard min < max else { return (nil, nil) }\n\
    \    return (min > 0 ? min : nil, (min < 0 ? max : nil))", "    var smallest =\
    \ Int?()\n    var largest = Int?()\n    for v in lst {\n        guard v > 0 else\
    \ {\n            // ignore zeros\n            continue\n        }\n        if\
    \ smallest == nil {\n            smallest = v\n        }\n        if v < smallest\
    \ {\n            largest = v\n        }\n    }\n    return (largest, smallest)",
  "    switch lst.count {\n    case 0:\n        return (nil, nil)\n    case 1:\n \
    \       return (lst[0], nil)\n    case 2:\n        return (max(lst[0], lst[1]),\
    \ min(lst[0], lst[1]))\n    default:\n        let min = min(lst.map { max($0,\
    \ 0) })\n        let max = max(lst.map { $0 })\n        return (max(min, 0), min(max,\
    \ 0))\n    }", "    // Write code here\n    var a = Int?(0)\n    var b = Int?(Int.max)\n\
    \    for i in lst {\n        if let i = i {\n            if i < b {\n        \
    \        b = i\n            }\n        } else {\n            a = nil\n       \
    \     b = i\n        }\n    }\n    return (a, b)", "    var max: Int? = nil\n\
    \    var min: Int? = nil\n    for num in lst {\n        if max < num {\n     \
    \       max = num\n        } else if min > num {\n            min = num\n    \
    \    }\n    }\n    return (max, min)", "    // find max and min values\n    var\
    \ max: Int? = nil\n    var min: Int? = nil\n    for i in lst {\n        if max\
    \ < i {\n            max = i\n        }\n        if min > i {\n            min\
    \ = i\n        }\n    }\n    return (max, min)", "    var a: Int? = nil\n    var\
    \ b: Int? = nil\n    for _a in lst {\n        if _a < 0 {\n            a = max(a,\
    \ Int(_a))\n        } else {\n            b = min(b, Int(_a))\n        }\n   \
    \ }\n    return (a, b)", "    if lst.isEmpty {\n        return (Int?(), Int?())\n\
    \    }\n    var minInt = Int?()\n    var maxInt = Int?()\n    for n in lst {\n\
    \        if n < 0 {\n            if minInt == nil {\n                minInt =\
    \ n\n            } else {\n                minInt = min(minInt, n)\n         \
    \   }\n        } else {\n            if maxInt == nil {\n                maxInt\
    \ = n\n            } else {\n                maxInt = max(maxInt, n)\n       \
    \     }\n        }\n    }\n    return (minInt, maxInt)", "    var min_i: Int?\
    \ = nil\n    var max_i: Int? = nil\n    for n in lst {\n        if min_i == nil\
    \ || n < min_i {\n            min_i = n\n        }\n        if max_i == nil ||\
    \ n > max_i {\n            max_i = n\n        }\n    }\n    return (min_i, max_i)",
  "  var result: Int? = nil\n  var result2: Int? = nil\n  for i in lst {\n    if i\
    \ > 0 {\n      result2 = result\n      result = i\n    } else if i < 0 {\n   \
    \   result2 = result\n      result = i\n    }\n  }\n  return (result2, result)",
  "    if lst.count < 2 {\n        return (nil, nil)\n    }\n    var largest: Int?\n\
    \    var smallest: Int?\n    for v in lst {\n        if v < 0 {\n            largest\
    \ = v\n        } else {\n            smallest = v\n        }\n    }\n    return\
    \ (largest, smallest)", "    guard lst.count > 0 else {\n        return (nil,\
    \ nil)\n    }\n    var max: Int? = nil\n    var min: Int? = nil\n    for x in\
    \ lst {\n        guard let x = x else {\n            continue\n        }\n   \
    \     if x > max {\n            max = x\n        } else if x < min {\n       \
    \     min = x\n        }\n    }\n    return (max, min)", '  return largest_smallest_integers(lst:
    lst, cmp: min)', "    guard lst.count > 0 else {\n        return (nil, nil)\n\
    \    }\n    var min: Int? = nil\n    var max: Int? = nil\n    for element in lst\
    \ {\n        if let value = element {\n            if min == nil || value < min\
    \ {\n                min = element\n            }\n            if max == nil ||\
    \ value > max {\n                max = element\n            }\n        }\n   \
    \ }\n    return (min, nil)", "    var smallest = Int?()\n    var largest = Int?()\n\
    \n    for number in lst {\n        if number > largest {\n            largest\
    \ = number\n        } else if number < smallest {\n            smallest = number\n\
    \        }\n    }\n\n    return (largest, smallest)", "    var smallest = Int()\n\
    \    var largest = Int()\n    for elt in lst {\n        if elt < smallest {\n\
    \            smallest = elt\n        }\n        if elt > largest {\n         \
    \   largest = elt\n        }\n    }\n    return (largest, smallest)", "  if lst.count\
    \ < 2 {\n    return (Int?(nil), Int?(nil))\n  }\n  var (lsm, lsmi) = Int?(nil)\n\
    \  for _, v := range lst {\n    if lsmi != nil {\n      if v > lsmi {\n      \
    \  lsm = v\n      }\n    } else if v < lsm {\n      lsm = v\n      lsmi = nil\n\
    \    } else {\n      lsmi = v\n    }\n  }\n  return (lsmi, lsm)", "    guard !lst.isEmpty\
    \ else { return (nil, nil) }\n    var largest = Int?(0)\n    var smallest = Int?(0)\n\
    \    for a in lst {\n        if a > largest {\n            largest = a\n     \
    \   }\n        if a < smallest {\n            smallest = a\n        }\n    }\n\
    \    return (largest, smallest)", "  // If no integer in the list, return nil.\n\
    \  if lst.contains(0) {\n    return (None, None)\n  }\n  // Find the smallest\
    \ integer.\n  var smallest: Int? = lst.min()\n  if smallest.isEmpty {\n    return\
    \ (None, None)\n  }\n  // Find the largest integer.\n  var largest: Int? = lst.max()\n\
    \  if largest.isEmpty {\n    return (None, None)\n  }\n  // Return largest and\
    \ smallest integers.\n  return (largest, smallest)", "  if lst.count == 0 {\n\
    \    return (Int?(), Int?())\n  }\n  var min = -1000000000\n  var max = 1000000000\n\
    \  var minIndex = 0\n  var maxIndex = 0\n  for index in lst {\n    if index <\
    \ 0 {\n      continue\n    }\n    if min > index {\n      min = index\n      minIndex\
    \ = index\n    }\n    if max < index {\n      max = index\n      maxIndex = index\n\
    \    }\n  }\n  if max == -1000000000 {\n    return (Int?(), Int?())\n  }\n  if\
    \ min == -1000000000 {\n    return (Int?(minIndex), Int?(maxIndex))\n  }\n  return\
    \ (Int?(minIndex), Int?(maxIndex))", "    guard lst.count > 0 else { return (nil,\
    \ nil) }\n\n    var largest = Int()\n    var smallest = Int()\n    for n in lst\
    \ {\n        if n < 0 {\n            largest = n\n        } else if n > 0 {\n\
    \            smallest = n\n        }\n    }\n    return (largest, smallest)",
  "    var largest, smallest Int?\n\n    for number in lst {\n        if number <\
    \ smallest {\n            largest = number\n        } else {\n            smallest\
    \ = number\n        }\n    }\n\n    return (largest, smallest)", "  guard lst.count\
    \ > 0 else {\n    return (nil, nil)\n  }\n  var largest = -Float.greatestFiniteMagnitude\n\
    \  var smallest = Float.leastFiniteMagnitude\n  var result = (nil, nil)\n  for\
    \ elem in lst {\n    if elem < smallest {\n      smallest = elem\n    }\n    if\
    \ elem > largest {\n      largest = elem\n    }\n  }\n  guard largest != Float.leastFiniteMagnitude\
    \ else {\n    return result\n  }\n  guard smallest != Float.greatestFiniteMagnitude\
    \ else {\n    return result\n  }\n  result = (largest, smallest)\n  return result",
  "    let isNegative = lst.filter { $0 < 0 }.isEmpty\n    let isPositive = lst.filter\
    \ { $0 >= 0 }.isEmpty\n    if isNegative && isPositive {\n        return (null,\
    \ null)\n    }\n    let maxInt = lst.max()\n    let minInt = lst.min()\n    return\
    \ (maxInt, minInt)", "    var largest = Int?(0)\n    var smallest = Int?(0)\n\
    \    for e in lst {\n        if let e = e {\n            if smallest == nil {\n\
    \                smallest = e\n            } else if e < smallest {\n        \
    \        smallest = e\n            }\n            if largest == nil {\n      \
    \          largest = e\n            } else if e > largest {\n                largest\
    \ = e\n            }\n        }\n    }\n    return (largest, smallest)", "   \
    \ var largest = lst[0]\n    var smallest = lst[0]\n\n    for value in lst {\n\
    \        if value < smallest {\n            largest = value\n        } else if\
    \ value > largest {\n            smallest = value\n        }\n    }\n    return\
    \ (largest, smallest)", "  if lst.isEmpty() {\n    return (nil, nil)\n  }\n\n\
    \  var max: Int? = nil\n  var min: Int? = nil\n  for item in lst {\n    if item\
    \ < 0 {\n      min = item\n    } else {\n      max = item\n    }\n  }\n\n  return\
    \ (max, min)", "    if lst.isEmpty() {\n        return (nil, nil)\n    }\n\n \
    \   var maxValue = Int()\n    var minValue = Int()\n    for v in lst {\n     \
    \   if v < 0 {\n            minValue = min(minValue, v)\n        } else {\n  \
    \          maxValue = max(maxValue, v)\n        }\n    }\n    return (minValue,\
    \ maxValue)", "    guard !lst.isEmpty else { return (nil, nil) }\n    var maxima:\
    \ Int?\n    var minima: Int?\n    if let last = lst.last {\n        for i in 0..<lst.count\
    \ {\n            let x = lst[i]\n            if x > last {\n                maxima\
    \ = x\n                break\n            }\n        }\n    }\n    if let last\
    \ = lst.last {\n        for i in 0..<lst.count {\n            let x = lst[i]\n\
    \            if x < last {\n                minima = x\n                break\n\
    \            }\n        }\n    }\n    return (maxima, minima)", "    if lst.isEmpty()\
    \ {\n        return (Int(nil), Int(nil))\n    }\n    \n    let min = lst.min()\
    \ ?? -1\n    var max = lst.max()\n    \n    for val in lst {\n        if val <\
    \ min {\n            min = val\n        }\n        \n        if val > max {\n\
    \            max = val\n        }\n    }\n    \n    return (min, max)", "    var\
    \ max: Int?\n    var min: Int?\n    for x in lst {\n        if x > max {\n   \
    \         max = x\n        } else if x < min {\n            min = x\n        }\n\
    \    }\n    return (max, min)", "    if lst.count < 2 {\n        return (nil,\
    \ nil)\n    }\n    var max = Int?()\n    var min = Int?()\n    for v in lst {\n\
    \        switch v {\n        case Int8(Int8(-1)),\n            Int8(Int8(-2)),\n\
    \            Int8(Int8(-3)),\n            Int8(Int8(-4)),\n            Int8(Int8(-5)),\n\
    \            Int8(Int8(-6)),\n            Int8(Int8(-7)):\n            if max\
    \ < nil {\n                max = Int8(v)\n            } else if min == nil ||\
    \ v < min {\n                min = Int8(v)\n            }\n        case Int16(Int16(-1)),\n\
    \            Int16(Int16(-2)),\n            Int16(Int16(-3)),\n            Int16(Int16(-4)),\n\
    \            Int16(Int16(-5)),\n            Int16(Int16(-6)),\n            Int16(Int16(-7)):\n\
    \            if max < nil {\n                max = Int16(v)\n            } else\
    \ if min == nil || v < min {\n                min = Int16(v)\n            }\n\
    \        case Int32(Int32(-1)),\n            Int32(Int32(-2)),\n            Int32(Int32(-3)),\n\
    \            Int32(Int32(-4)),\n            Int32(Int32(-5)),\n            Int32(Int32(-6)),\n\
    \            Int32(Int32(-7)):\n            if max < nil {\n                max\
    \ = Int32(v)\n            } else if min == nil || v < min {\n                min\
    \ = Int32(v)\n            }\n        case Int64(Int64(-1)),\n            Int64(Int64(-2)),\n\
    \            Int64(Int64(-3)),\n            Int64(Int64(-4)),\n            Int64(Int64(-5)),\n\
    \            Int64(Int64(-6)),\n            Int64(Int64(-7)):\n            if\
    \ max < nil {\n                max = Int64(v)\n            } else if min == nil\
    \ || v < min {\n                min = Int64(v)\n            }\n        default:\n\
    \            break\n        }\n    }\n    return (max, min)", "    if lst.isEmpty()\
    \ {\n        return (nil, nil)\n    }\n    var min: Int? = nil\n    var max: Int?\
    \ = nil\n    for i in lst {\n        if i < 0 {\n            if min == nil {\n\
    \                min = i\n            } else {\n                max = i\n    \
    \        }\n        } else {\n            if max == nil {\n                max\
    \ = i\n            } else {\n                max = max! > i ? max! : i\n     \
    \       }\n        }\n    }\n    return (min, max)", "  if lst.count <= 0 {\n\
    \    return (nil, nil)\n  }\n\n  var largest = lst.last!\n  var smallest = lst.first!\n\
    \n  for v in lst {\n    if v < smallest {\n      smallest = v\n    }\n\n    if\
    \ v > largest {\n      largest = v\n    }\n  }\n\n  return (nil, largest)", " \
    \   var a : Int? = nil\n    var b : Int? = nil\n    for val in lst {\n       \
    \ if val < 0 {\n            if a == nil {\n                a = val\n         \
    \   } else {\n                a = val\n            }\n        } else {\n     \
    \       if b == nil {\n                b = val\n            } else {\n       \
    \         b = val\n            }\n        }\n    }\n    return (a, b)", "    var\
    \ minInt = nil\n    var maxInt = nil\n\n    for el in lst {\n        if el < 0\
    \ {\n            if minInt == nil {\n                minInt = el\n           \
    \ } else {\n                if maxInt == nil {\n                    maxInt = el\n\
    \                } else {\n                    maxInt = max(el, maxInt)\n    \
    \            }\n            }\n        } else {\n            if maxInt == nil\
    \ {\n                maxInt = el\n            } else {\n                minInt\
    \ = min(el, minInt)\n            }\n        }\n    }\n    return (minInt, maxInt)",
  "    var largest: Int? = nil\n    var smallest: Int? = nil\n    for ele in lst {\n\
    \        if largest == nil || ele > largest {\n            largest = ele\n   \
    \     }\n        if smallest == nil || ele < smallest {\n            smallest\
    \ = ele\n        }\n    }\n    return (largest, smallest)", "    if lst.isEmpty\
    \ {\n        return (nil, nil)\n    }\n\n    // Initialize variables\n    var\
    \ a = Int?()\n    var b = Int?()\n\n    // Initialize min and max values\n   \
    \ var min: Int? = nil\n    var max: Int? = nil\n\n    // Iterate through array\n\
    \    for element in lst {\n        let currentMin = element < min ? element :\
    \ min\n        let currentMax = element > max ? element : max\n\n        if currentMin\
    \ < 0 || currentMax < 0 {\n            min = nil\n            max = nil\n    \
    \    } else {\n            min = currentMin\n            max = currentMax\n  \
    \      }\n\n        a = currentMin\n        b = currentMax\n    }\n\n    return\
    \ (a, b)", "    var smallest = 0\n    var largest = IntMax\n    for i in lst {\n\
    \        if i > largest {\n            largest = i\n        } else if i < smallest\
    \ {\n            smallest = i\n        }\n    }\n    return (largest, smallest)",
  "    if lst.count < 2 {\n        return (nil, nil)\n    }\n    var smallest = Int?(0)\n\
    \    var largest = Int?(0)\n    for number in lst {\n        if number > 0 {\n\
    \            if smallest == nil {\n                smallest = number\n       \
    \     } else {\n                if number < smallest {\n                    smallest\
    \ = number\n                }\n            }\n        } else {\n            if\
    \ largest == nil {\n                largest = number\n            } else {\n \
    \               if number > largest {\n                    largest = number\n\
    \                }\n            }\n        }\n    }\n    return (largest, smallest)",
  "  var max: Int?\n  var min: Int?\n\n  for i := 0; i < len(lst); i++ {\n    if lst[i]\
    \ > max {\n      max = lst[i]\n    }\n    if lst[i] < min {\n      min = lst[i]\n\
    \    }\n  }\n  return (min, nil)", "    if lst.isEmpty {\n        return (Int?(0),\
    \ Int?(0))\n    }\n    let max = lst.max()\n    let min = lst.min()\n    if max\
    \ == min {\n        return (Int?(0), Int?(0))\n    }\n    if max < 0 {\n     \
    \   return (Int?(-max), Int?(max))\n    }\n    return (Int?(min), Int?(max))",
  "  var min: Int? = nil\n  var max: Int? = nil\n  for num in lst {\n    if min ==\
    \ nil || num < min {\n      min = num\n    } else if max == nil || num > max {\n\
    \      max = num\n    }\n  }\n  return (min, max)", "  if lst.contains(0) {\n\
    \    return (nil, nil)\n  }\n  var max: Int? = nil\n  var min: Int? = nil\n  var\
    \ maxIsNegative = false\n  for var i = 0; i < lst.count; i++ {\n    if let num\
    \ = lst[i] {\n      if num < 0 {\n        if maxIsNegative {\n          return\
    \ nil\n        }\n        if let tmp = max {\n          max = num\n        } else\
    \ {\n          max = num\n        }\n        maxIsNegative = true\n      }\n \
    \     if num > 0 {\n        if !minIsNegative {\n          min = num\n       \
    \ } else {\n          min = num\n        }\n      }\n    }\n  }\n  return (max,\
    \ min)", "    if lst.isEmpty() {\n        return (nil, nil)\n    }\n\n    let\
    \ maxInt = lst.max()\n    let minInt = lst.min()\n\n    if maxInt == 0 && minInt\
    \ == 0 {\n        return (nil, nil)\n    }\n\n    return (maxInt, minInt)", " \
    \   if lst.isEmpty { return (nil, nil) }\n    var min = Int.min\n    var max =\
    \ Int.max\n    for x in lst {\n        if x < min { min = x }\n        if x >\
    \ max { max = x }\n    }\n    return (nil, min)", "    if lst.isEmpty {\n    \
    \    return (nil, nil)\n    }\n    largest, smallest := Int(), Int()\n    for\
    \ i := 0; i < len(lst); i++ {\n        if lst[i] < smallest {\n            smaller\
    \ = smallest\n        } else {\n            if lst[i] > largest {\n          \
    \      largest = largest\n            } else {\n                largest = lst[i]\n\
    \                smallest = lst[i]\n            }\n        }\n    }\n    return\
    \ (largest, smallest)", "    var biggest = Int.min\n    var smallest = Int.max\n\
    \n    for element in lst {\n        if element < smallest {\n            smallest\
    \ = element\n        }\n        if element > biggest {\n            biggest =\
    \ element\n        }\n    }\n\n    return (smallest, biggest)", "  var max1: Int?\
    \ = nil\n  var min1: Int? = nil\n  for value in lst {\n    if value == 0 {\n \
    \     continue\n    }\n    if value > 0 {\n      if min1 == nil || value < min1\
    \ {\n        min1 = value\n      }\n      if value > max1 {\n        max1 = value\n\
    \      }\n    } else {\n      if max1 == nil || value > max1 {\n        max1 =\
    \ value\n      }\n      if value < min1 {\n        min1 = value\n      }\n   \
    \ }\n  }\n  return (min1, max1)", "    var largest = 0\n    var smallest = -1024\n\
    \    var largestPos = false\n    var smallestPos = false\n    for element in lst\
    \ {\n        if element > largest {\n            largest = element\n         \
    \   largestPos = true\n        } else if element < smallest {\n            smallest\
    \ = element\n            smallestPos = true\n        }\n    }\n    if largest\
    \ > -1 {\n        return (largest, largestPos)\n    } else if smallest != -1 {\n\
    \        return (smallest, smallestPos)\n    } else {\n        return (None, None)\n\
    \    }", "    var largest = Int?()\n    var smallest = Int?()\n    for i := 0;\
    \ i < len(lst); i++ {\n        if lst[i] < 0 {\n            largest = lst[i]\n\
    \        } else {\n            smallest = lst[i]\n        }\n    }\n    return\
    \ (largest, smallest)", "    var largest: Int?\n    var smallest: Int?\n    for\
    \ num in lst {\n        if num < 0 {\n            largest = num\n        } else\
    \ if num > 0 {\n            smallest = num\n        }\n    }\n    return (largest,\
    \ smallest)", "    var min: Int? = nil\n    var max: Int? = nil\n    for elem\
    \ in lst {\n        if elem < 0 {\n            if min == nil {\n             \
    \   min = elem\n            } else {\n                max = elem\n           \
    \ }\n        } else {\n            if max == nil {\n                max = elem\n\
    \            } else {\n                min = elem\n            }\n        }\n\
    \    }\n    return (min, max)", "    if lst.count <= 0 {\n        return (Int?(),\
    \ Int?())\n    }\n    var smallest, largest : Int?\n    for value in lst {\n \
    \       if smallest == nil {\n            smallest = value\n        } else {\n\
    \            if value < smallest {\n                smallest = value\n       \
    \     }\n        }\n        if largest == nil {\n            largest = value\n\
    \        } else {\n            if value > largest {\n                largest =\
    \ value\n            }\n        }\n    }\n    return (smallest, largest)", " \
    \   var min = UInt32(UInt64(1))\n    var max = UInt32(UInt64(0))\n    if lst.count\
    \ < 2 {\n        // Nothing in lst; return nil because we can't return (nil, nil)\n\
    \        return (nil, nil)\n    }\n    for i in lst {\n        if i < 0 {\n  \
    \          if min < i {\n                min = i\n            }\n        } else\
    \ {\n            if max > i {\n                max = i\n            }\n      \
    \  }\n    }\n    if min < 0 {\n        return nil, min\n    }\n    if max > UInt(Int64(Int32.max))\
    \ {\n        return nil, max\n    }\n    return (min, max)", "    var max = -Float.infinity\n\
    \    var min = Float.infinity\n\n    var maxIndex = 0\n    var minIndex = 0\n\
    \    for idx, i in lst.enumerated() {\n        if i < min {\n            min =\
    \ i\n            minIndex = idx\n        }\n\n        if i > max {\n         \
    \   max = i\n            maxIndex = idx\n        }\n    }\n\n    return (maxIndex,\
    \ minIndex)", "  var max: Int? = nil\n  var min: Int? = nil\n\n  for n in lst\
    \ {\n    if let a = -n as? Int, a < min {\n      min = a\n    }\n    if let b\
    \ = +n as? Int, b > max {\n      max = b\n    }\n  }\n\n  return (max, min)",
  "  let smallest_int = largest(lst)\n  var largest_int = smallest_int\n  for _ in\
    \ lst {\n    largest_int = smallest_int\n    smallest_int = largest(lst)\n  }\n\
    \  return (largest_int, smallest_int)", "  // Create an array of all possible\
    \ negative/positive values.\n  var arr: [Int] = []\n  for n in lst {\n    if n\
    \ < 0 {\n      arr += [-n]\n    }\n    if n >= 0 {\n      arr += [n]\n    }\n\
    \  }\n\n  // Find the largest negative and the smallest positive.\n  var largestNegative:\
    \ Int? = nil\n  var smallestPositive: Int? = nil\n  for n in arr {\n    if n <\
    \ 0 {\n      if !largestNegative || n < largestNegative {\n        largestNegative\
    \ = n\n      }\n    }\n    if n >= 0 {\n      if !smallestPositive || n < smallestPositive\
    \ {\n        smallestPositive = n\n      }\n    }\n  }\n\n  // Return the smallest/largest\
    \ pair.\n  return (smallestPositive, largestNegative)", "    var smallest: Int?\n\
    \    var largest: Int?\n    for number in lst {\n        if number > smallest\
    \ {\n            largest = number\n        } else if smallest == nil {\n     \
    \       smallest = number\n        }\n    }\n    return (largest, smallest)",
  "    var smallest = Int?()\n    var largest = Int?()\n    var result: (Int?, Int?)\
    \ = (nil, nil)\n    if lst.count < 2 {\n        return result\n    }\n\n    if\
    \ lst[0] < 0 {\n        result = (nil, lst[0])\n        return result\n    }\n\
    \n    for i := 0; i < lst.count; i++ {\n        if lst[i] > 0 {\n            if\
    \ smallest == nil {\n                smallest = lst[i]\n            } else {\n\
    \                if lst[i] > smallest {\n                    smallest = lst[i]\n\
    \                }\n            }\n        } else {\n            if largest ==\
    \ nil {\n                largest = lst[i]\n            } else {\n            \
    \    if lst[i] < largest {\n                    largest = lst[i]\n           \
    \     }\n            }\n        }\n    }\n\n    result = (largest, smallest)\n\
    \    return result", "    var largest = Int()\n    var smallest = Int()\n    for\
    \ number in lst {\n        if number > smallest {\n            largest = number\n\
    \        } else if number < smallest {\n            smallest = number\n      \
    \  }\n    }\n    return (largest, smallest)", "    var smallest = Int?(0)\n  \
    \  var largest = Int?(0)\n\n    for number in lst {\n        if number < smallest\
    \ {\n            largest = number\n        } else {\n            smallest = number\n\
    \        }\n    }\n\n    return (largest, smallest)", "    if lst.count < 2 {\n\
    \        return (nil, nil)\n    }\n    var largest = Int?(0)\n    var smallest\
    \ = Int?(0)\n    for i in lst {\n        if i.value < 0 {\n            largest\
    \ = i\n        } else if i.value > 0 {\n            smallest = i\n        }\n\
    \    }\n    return (largest, smallest)", "    for num in lst {\n        if num\
    \ > 0 {\n            return (num, num)\n        } else {\n            if num <\
    \ 0 {\n                num = -num\n                return (num, num)\n       \
    \     }\n        }\n    }\n    return (nil, nil)", "    var smallest = -1000\n\
    \    var largest = 1000\n    for v in lst {\n        if v < smallest {\n     \
    \       smallest = v\n        }\n        if v > largest {\n            largest\
    \ = v\n        }\n    }\n    return smallest, largest", '  return _smallest_largest(lst:
    lst, lt: >)', "  switch lst.count {\n  case 0:\n    return (nil, nil)\n  case\
    \ 1:\n    let i = lst[0]\n    return (i, i)\n  default:\n    let min = lst.min()!\n\
    \    let max = lst.max()!\n    return (min, max)\n  }", "    var largest = Int?()\n\
    \    var smallest = Int?()\n    for el in lst {\n        if el < smallest {\n\
    \            smallest = el\n        }\n        if el > largest {\n           \
    \ largest = el\n        }\n    }\n    return (largest, smallest)", "\tvar min,\
    \ b Int?\n\tmax := 0\n\tfor _, num := range lst {\n\t\tif num < 0 {\n\t\t\tmin\
    \ = num\n\t\t\tcontinue\n\t\t}\n\t\tif min != nil && num > max {\n\t\t\tmin =\
    \ nil\n\t\t}\n\t\tif min == nil && num < min {\n\t\t\tmin = num\n\t\t}\n\t\tmax\
    \ = num\n\t}\n\treturn min, b", "  guard lst.count >= 2 else {\n    return (nil,\
    \ nil)\n  }\n\n  guard let first = lst[0], let last = lst[lst.count - 1] else\
    \ {\n    return (nil, nil)\n  }\n\n  let min1 = first.map { $0 < 0 ? Int.max :\
    \ $0 }\n  let max1 = first.map { $0 < 0 ? Int.min : $0 }\n  let min2 = last.map\
    \ { $0 < 0 ? Int.max : $0 }\n  let max2 = last.map { $0 < 0 ? Int.min : $0 }\n\
    \n  guard let min1 = min1.reduce(0, +), let max1 = max1.reduce(0, -) else {\n\
    \    return (nil, nil)\n  }\n\n  guard let min2 = min2.reduce(0, +), let max2\
    \ = max2.reduce(0, -) else {\n    return (nil, nil)\n  }\n\n  return (min1, min2),\
    \ (max1, max2)", "    if lst.isEmpty() {\n        return (nil, nil)\n    }\n \
    \   if lst.contains(0) {\n        return (nil, 0)\n    }\n    var max = -Int.max\n\
    \    var min = Int.min\n    for i in lst {\n        if i < 0 {\n            max\
    \ = -Int.max\n            break\n        }\n        min = Int.max\n        if\
    \ i > max {\n            max = i\n        }\n        if i < min {\n          \
    \  min = i\n        }\n    }\n    return (min, nil)", "    let sorted = lst.sorted()\n\
    \    let largestIndex = sorted.endIndex.advancedBy(1)\n    let smallestIndex =\
    \ sorted.startIndex.advancedBy(-1)\n    return (sorted[largestIndex], sorted[smallestIndex])",
  "  var min = -1000\n  var max = 1000\n  var ret: (Int?, Int?) = (nil, nil)\n  for\
    \ v in lst {\n    if v < min {\n      min = v\n    } else if v > max {\n     \
    \ max = v\n    }\n  }\n  return (min, max)", "    switch lst.count {\n    case\
    \ 0:\n        return (nil, nil)\n    case 1:\n        return (nil, lst[0])\n \
    \   case 2:\n        if lst[0] > lst[1] {\n            return (lst, lst[0])\n\
    \        } else {\n            return (lst, lst[1])\n        }\n    default:\n\
    \        if lst[0] > 0 {\n            var min = -Int64(Int64.max)\n          \
    \  var max = 0\n            for i := 1; i < lst.count; i++ {\n               \
    \ if lst[i] < min {\n                    min = lst[i]\n                } else\
    \ if lst[i] > max {\n                    max = lst[i]\n                }\n   \
    \         }\n            return (max, min)\n        } else {\n            var\
    \ min = Int64(Int64.max)\n            var max = 0\n            for i := 1; i <\
    \ lst.count; i++ {\n                if lst[i] < min {\n                    min\
    \ = lst[i]\n                } else if lst[i] > max {\n                    max\
    \ = lst[i]\n                }\n            }\n            return (min, nil)\n\
    \        }\n    }", "    guard lst.count > 0 else {\n        return (nil, nil)\n\
    \    }\n    var largest = Int?(0)\n    var smallest = Int?(0)\n    for i in lst\
    \ {\n        if i <= 0 {\n            if smallest == nil {\n                smallest\
    \ = i\n            } else {\n                smallest! = i\n            }\n  \
    \      } else if i > 0 {\n            if largest == nil {\n                largest\
    \ = i\n            } else {\n                largest! = i\n            }\n   \
    \     }\n    }\n    return (largest, smallest)", "    guard lst.count > 0 else\
    \ { return (nil, nil) }\n\n    var max: Int = lst[0]\n    var min: Int = lst[0]\n\
    \    for x in lst {\n        if x > max {\n            max = x\n        } else\
    \ if x < min {\n            min = x\n        }\n    }\n    return (nil, min)",
  "    var max_i = lst.count\n    var min_i = lst.count\n    for i in lst {\n    \
    \    if i < 0 {\n            max_i = i\n        } else {\n            min_i =\
    \ i\n        }\n    }\n    return (max_i, min_i)", "  var max: Int? = nil\n  var\
    \ min: Int? = nil\n  for number in lst {\n    if number > 0 {\n      max = number\n\
    \    } else {\n      if min == nil {\n        min = number\n      } else {\n \
    \       if number < min {\n          min = number\n        }\n      }\n    }\n\
    \  }\n  return (min,max)", "  if lst.isEmpty {\n    return (null, null)\n  }\n\
    \n  let min_ = lst[0]\n  var max_ = min_\n  for elem in lst {\n    if elem > max_\
    \ {\n      max_ = elem\n    }\n  }\n\n  for elem in lst {\n    if elem < min_\
    \ {\n      min_ = elem\n    }\n  }\n\n  return (min_, max_)", "    var smallest:\
    \ Int?\n    var largest: Int?\n    for elem in lst {\n        if elem.isNegative\
    \ {\n            if smallest == nil {\n                smallest = elem\n     \
    \       } else if elem.isLargerThan(smallest!) {\n                smallest = elem\n\
    \            }\n        } else {\n            if largest == nil {\n          \
    \      largest = elem\n            } else if elem.isSmallerThan(largest!) {\n\
    \                largest = elem\n            }\n        }\n    }\n    return (smallest,\
    \ largest)", "  if lst.isEmpty {\n    return (nil, nil)\n  }\n  guard let last\
    \ = lst.last else {\n    return nil, nil\n  }\n  if lst.first < 0 {\n    return\
    \ (lst.first, nil)\n  }\n  return (last, lst.first)", "    if lst.isEmpty() {\n\
    \        return (nil, nil)\n    }\n\n    // Initialize max and min to first integer\n\
    \    var max: Int? = lst[0]\n    var min: Int? = lst[0]\n\n    // Find the maximum\
    \ and minimum elements\n    for i in 1..lst.count {\n        if max == nil ||\
    \ max < lst[i] {\n            max = lst[i]\n        }\n        if min == nil ||\
    \ min > lst[i] {\n            min = lst[i]\n        }\n    }\n\n    return (max,\
    \ min)", "    let lmin = min(lst)\n    if lmin == -1 {\n        return (lmin,\
    \ 0)\n    }\n    let lmax = max(lst)\n    if lmax == -1 {\n        return (nil,\
    \ lmax)\n    }\n    return (lmax, lmin)", "    var min: Int? = nil\n    var max:\
    \ Int? = nil\n    for x in lst {\n        if x < min {\n            min = x\n\
    \        } else if x > max {\n            max = x\n        }\n    }\n    return\
    \ (min, max)", "    var min = -Int64(math.MaxInt64)\n    var max = Int64(math.MinInt64)\n\
    \    for x := range lst {\n        if x > max {\n            max = x\n       \
    \ }\n        if x < min {\n            min = x\n        }\n    }\n    return nil,\
    \ nil", "    switch lst.count {\n    case 0:\n        return (nil, nil)\n    case\
    \ 1:\n        return (nil, lst[0])\n    default:\n        var min: Int?\n    \
    \    var max: Int?\n        for i in lst {\n            if i > 0 {\n         \
    \       max = i\n            } else if i < 0 {\n                min = i\n    \
    \        } else {\n                min == nil\n                max == nil\n  \
    \          }\n        }\n        return (min, max)\n    }", "  var smallest =\
    \ Int?()\n  var largest = Int?()\n  for number in lst {\n    if number > smallest\
    \ {\n      largest = number\n    }\n    if number < smallest {\n      smallest\
    \ = number\n    }\n  }\n  return (smallest, largest)", '    return max_min(lst,
    0)', "    // Sort the list from greatest to smallest\n    var sortedList = lst.sorted()\n\
    \n    // Iterate through the list and return the greatest and smallest values\n\
    \    for idx in 0..<sortedList.count {\n        // If this is the smallest value\
    \ in the list, save it\n        if sortedList[idx] == sortedList[sortedList.count\
    \ - idx - 1].0 {\n            if let smallest = sortedList[sortedList.count -\
    \ idx - 1].1 {\n                return (smallest, nil)\n            }\n      \
    \  } else {\n            if let greatest = sortedList[idx].1 {\n             \
    \   return (nil, greatest)\n            }\n        }\n    }\n\n    // Return nil\
    \ for empty list\n    return (nil, nil)", "    switch lst.count {\n    case 0:\n\
    \        return (nil, nil)\n    case 1:\n        return (lst.first, nil)\n   \
    \ default:\n        let smallestPositive = lst.min_by(lessThan(_: 0))\n      \
    \  let largestNegative = lst.max_by(lessThan(_: 0))\n        return (largestNegative,\
    \ smallestPositive)\n    }", "    if lst.isEmpty { return (nil, nil) }\n    var\
    \ smallest = lst[0]\n    var largest = lst[0]\n    for _i in 0..<lst.count {\n\
    \        if lst[_i] < smallest {\n            largest = smallest\n           \
    \ smallest = lst[_i]\n        } else if lst[_i] > largest {\n            largest\
    \ = lst[_i]\n        }\n    }\n    return (largest, smallest)", "    var a: Int?\n\
    \    var b: Int?\n    for i := 0; i < len(lst); i++ {\n        if !contains(lst,\
    \ i) {\n            (a, b) = (nil, nil)\n        } else {\n            if a <\
    \ i {\n                a = i\n            }\n            if b > i {\n        \
    \        b = i\n            }\n        }\n    }\n    return (a, b)", "    var\
    \ max: Int? = nil\n    var min: Int? = nil\n    for integer in lst {\n       \
    \ if integer > max {\n            max = integer\n        } else if integer < min\
    \ {\n            min = integer\n        }\n    }\n    return (max, min)", "  \
    \  var smallest: Int? = nil\n    var largest: Int? = nil\n    for number in lst\
    \ {\n        if number < 0 {\n            if smallest == nil {\n             \
    \   smallest = number\n            } else {\n                largest = number\n\
    \            }\n        } else {\n            if largest == nil {\n          \
    \      largest = number\n            } else {\n                smallest = number\n\
    \            }\n        }\n    }\n    return (smallest, largest)", "    var min:\
    \ Int? = nil\n    var max: Int? = nil\n    for x in lst {\n        if min == nil\
    \ || x < min {\n            min = x\n        }\n        if max == nil || x > max\
    \ {\n            max = x\n        }\n    }\n    return (min, max)", "    switch\
    \ lst.count {\n    case 0:\n        return (nil, nil)\n    case 1:\n        return\
    \ (0, lst[0])\n    case 2:\n        return ((0, max(lst[0], lst[1])), min(lst[0],\
    \ lst[1]))\n    default:\n        let positive = min(lst, max: max)\n        let\
    \ negative = max(lst, min: min)\n        return (\n            largest_smallest_integers(lst:\
    \ negative),\n            largest_smallest_integers(lst: positive))\n    }", " \
    \ if lst.isEmpty {\n    return (Int?(nil), Int?(nil))\n  }\n  if lst.first! >=\
    \ 0 {\n    return (Int?(lst.first!), Int?(lst.first!))\n  }\n  var largest = -Int.max\n\
    \  var smallest = Int.min\n  for v in lst {\n    if v >= 0 {\n      if v > smallest\
    \ {\n        smallest = v\n      }\n    } else {\n      if v < largest {\n   \
    \     largest = v\n      }\n    }\n  }\n  return (Int?(largest), Int?(smallest))",
  "    let m = min(lst)\n    let n = max(lst)\n    return (n, n)", "    var largest\
    \ = Int?()\n    var smallest = Int?()\n\n    for number in lst {\n        if number\
    \ < 0 {\n            smallest = number\n        } else {\n            largest\
    \ = number\n        }\n    }\n\n    return (largest, smallest)", "    guard lst.count\
    \ > 0 else {\n        return (nil, nil)\n    }\n    let negative: Int?\n    var\
    \ positive: Int?\n    var max: Int?\n    var min: Int?\n\n    // Find the largest\
    \ negative\n    for val in lst {\n        if val < 0 {\n            negative =\
    \ val\n        }\n    }\n\n    // Find the smallest positive\n    for val in lst\
    \ {\n        if val > 0 {\n            positive = val\n        }\n    }\n\n  \
    \  // If the smallest number is negative, just return the largest and smallest\n\
    \    // as nils\n    if let _positive = positive {\n        return (nil, nil)\n\
    \    }\n\n    // Find the max and min of the two numbers\n    if let _negative\
    \ = negative {\n        if _negative > max {\n            max = _negative\n  \
    \      }\n        if _negative < min {\n            min = _negative\n        }\n\
    \    } else {\n        if max > min {\n            return (max, min)\n       \
    \ } else {\n            return (min, max)\n        }\n    }\n    return (positive,\
    \ negative)", "    if lst.isEmpty {\n        return (Int?(Int32.min), Int?(Int32.max))\n\
    \    }\n    \n    var minInt = Int?(Int32.min)\n    var maxInt = Int?(Int32.max)\n\
    \    for idx in 0 ..< lst.count {\n        if let i = Int(lst[idx]) {\n      \
    \      if i < minInt {\n                minInt = i\n            } else if i >\
    \ maxInt {\n                maxInt = i\n            }\n        }\n    }\n    \n\
    \    return (minInt, maxInt)", "    if lst.isEmpty() {\n        return (None,\
    \ None)\n    }\n    \n    // sort the array\n    let sortedArray = lst.sorted()\n\
    \n    // return first and last index of largest & smallest ints\n    return (sortedArray[0],\
    \ sortedArray[sortedArray.count - 1])", "    var a = nil\n    var b = IntMax\n\
    \    for v in lst {\n        switch v.(type) {\n        case Int:\n          \
    \  a ?= v\n        case Int64:\n            b ?= v\n        }\n    }\n    return\
    \ (a, b)", "  var a: Int?, b: Int?\n  if lst.isEmpty {\n    return nil, nil\n\
    \  }\n  var lowest_number = 0\n  var highest_number = -Int.max\n  for element\
    \ in lst {\n    if element < lowest_number {\n      lowest_number = element\n\
    \    }\n    if element > highest_number {\n      highest_number = element\n  \
    \  }\n  }\n  if highest_number < -Int.max {\n    highest_number = nil\n  }\n \
    \ if lowest_number > Int.max {\n    lowest_number = nil\n  }\n  a = lowest_number\n\
    \  b = highest_number\n  return (a, b)", "    var largest: Int?\n    var smallest:\
    \ Int?\n    for integer in lst {\n        if integer < 0 {\n            if smallest\
    \ == nil {\n                smallest = integer\n            } else {\n       \
    \         largest = integer\n            }\n        } else {\n            if largest\
    \ == nil {\n                largest = integer\n            } else {\n        \
    \        if integer < smallest {\n                    smallest = integer\n   \
    \             }\n                if integer > largest {\n                    largest\
    \ = integer\n                }\n            }\n        }\n    }\n    return (largest,\
    \ smallest)", "    // sort the list\n    let lst = lst.sorted()\n    // initialize\
    \ min and max with nil\n    var min = nil\n    var max = nil\n    for num in lst\
    \ {\n        if num < 0 {\n            min = nil\n        }\n        else if num\
    \ > 0 {\n            max = nil\n        }\n        else if min == nil && max ==\
    \ nil {\n            min = max = num\n        }\n        else if num < min {\n\
    \            min = num\n        }\n        else if num > max {\n            max\
    \ = num\n        }\n    }\n    // if no negative integers, return nil\n    if\
    \ min == nil && max == nil {\n        return (min, max)\n    }\n    // otherwise,\
    \ return the two numbers\n    return (min, max)", "    guard lst.isEmpty else\
    \ {\n        return (nil, nil)\n    }\n\n    var smallest: Int? = nil\n    var\
    \ largest: Int? = nil\n\n    for i in lst {\n        if smallest == nil || i <\
    \ smallest {\n            smallest = i\n        }\n\n        if largest == nil\
    \ || i > largest {\n            largest = i\n        }\n    }\n\n    return (largest,\
    \ smallest)", "    switch lst.count {\n    case 0:\n        return (nil, nil)\n\
    \    case 1:\n        return (lst[0], nil)\n    case 2:\n        return (nil,\
    \ lst[0])\n    }\n    var largest: Int? = nil\n    var smallest: Int? = nil\n\
    \    for i in lst {\n        if i < 0 {\n            largest = i\n        } else\
    \ if i > 0 {\n            if smallest == nil {\n                smallest = i\n\
    \            } else if smallest! > i {\n                smallest = i\n       \
    \     }\n        }\n    }\n    return (largest, smallest)", "  var smallest =\
    \ Int?(0)\n  var largest = Int?(0)\n  for num in lst {\n    if num < smallest\
    \ {\n      smallest = num\n    }\n    if num > largest {\n      largest = num\n\
    \    }\n  }\n  return (smallest, largest)", "  var smallestPositive, largestNegative:\
    \ Int?\n\n  for number in lst {\n    if number < 0 {\n      largestNegative =\
    \ number\n    } else if number > 0 {\n      smallestPositive = number\n    }\n\
    \  }\n\n  return (largestNegative, smallestPositive)", "    var max: Int? = nil\n\
    \    var min: Int? = nil\n\n    for number in lst {\n        if max < number {\n\
    \            max = number\n        } else if min > number {\n            min =\
    \ number\n        }\n    }\n\n    return (max, min)", "  var min: Int? = nil\n\
    \  var max: Int? = nil\n  for v in lst {\n    if v < 0 {\n      if min == nil\
    \ || min > v {\n        min = v\n      }\n    } else if v > 0 {\n      if max\
    \ == nil || max < v {\n        max = v\n      }\n    } else {\n      return (nil,\
    \ nil)\n    }\n  }\n  return (min!, max!)", "\tvar maxIndex: Int = -1\n\tvar minIndex:\
    \ Int = 0\n\tfor i := 0; i < len(lst); i++ {\n\t\tif lst[i] > 0 {\n\t\t\tminIndex\
    \ = i\n\t\t}\n\t\tif lst[i] < 0 {\n\t\t\tmaxIndex = i\n\t\t}\n\t}\n\tif maxIndex\
    \ == -1 && minIndex == 0 {\n\t\treturn (nil, nil)\n\t}\n\treturn (&lst[maxIndex],\
    \ &lst[minIndex])", "    var largest: Int? = nil\n    var smallest: Int? = nil\n\
    \    for el in lst {\n        if el < 0 {\n            if largest == nil {\n \
    \               largest = el\n            } else {\n                smallest =\
    \ el\n            }\n        } else {\n            if smallest == nil {\n    \
    \            smallest = el\n            } else {\n                largest = el\n\
    \            }\n        }\n    }\n    return (largest, smallest)", "  var smallest:\
    \ Int? = nil\n  var largest: Int? = nil\n\n  for number in lst {\n    if number\
    \ < 0 {\n      smallest = number\n    } else if number > 0 {\n      largest =\
    \ number\n    }\n  }\n\n  return smallest, largest", "    if lst.count < 2 {\n\
    \        return (nil, nil)\n    }\n    var smallest: Int? = nil\n    var largest:\
    \ Int? = nil\n    for i in lst {\n        if smallest == nil || i > smallest {\n\
    \            smallest = i\n        }\n        if largest == nil || i < largest\
    \ {\n            largest = i\n        }\n    }\n    return (smallest, largest)",
  "    // sort as ascending order\n    var sorted = lst.sorted()\n    if sorted.isEmpty\
    \ {\n        return (nil, nil)\n    }\n    // look for negative and positive integers,\
    \ respectively\n    var min: Int? = sorted.first\n    var max: Int? = sorted.last\n\
    \    // if the first and last number are both negative\n    if min.sign != nil\
    \ {\n        // set the max to be the largest\n        if max.sign != nil {\n\
    \            max = max!\n        } else {\n            max = min!\n        }\n\
    \    }\n    if max.sign != nil {\n        // set the min to be the smallest\n\
    \        if min.sign != nil {\n            min = min!\n        } else {\n    \
    \        min = max!\n        }\n    }\n    return (min, max)", '    return largestSmallestHelper(lst)',
  "    if lst.count < 2 {\n        return (lst[0], nil)\n    }\n    var smallest =\
    \ lst[0]\n    var largest = lst[0]\n    for x in lst {\n        if x < smallest\
    \ {\n            smallest = x\n        }\n        if x > largest {\n         \
    \   largest = x\n        }\n    }\n    return (largest, smallest)", '    return
    LSM(lst)', '    return (largest(lst), smallest(lst))', "    guard lst.count >\
    \ 0 else {\n        return (nil, nil)\n    }\n\n    var largest = 0\n    var smallest\
    \ = 1000000000\n    for x in lst {\n        if x < 0 {\n            largest =\
    \ max(x, largest)\n        } else {\n            smallest = min(x, smallest)\n\
    \        }\n    }\n    return (largest, smallest)", "  // Odd sized lists.\n \
    \ if lst.isEmpty {\n    return (nil, nil)\n  }\n  \n  // Find the max and min\
    \ of the list.\n  var max = Int.max\n  var min = Int.min\n  for value in lst {\n\
    \    if value > max {\n      max = value\n    }\n    if value < min {\n      min\
    \ = value\n    }\n  }\n  \n  // Return a tuple of the largest and the smallest\
    \ of negative and\n  // positive integers.\n  return (max, min)", "    guard lst.count\
    \ > 0 else { return (nil, nil) }\n    var largest = lst.max()\n    var smallest\
    \ = lst.min()\n    guard smallest < 0 &&\n        largest > 0 else {\n       \
    \     return (nil, nil)\n    }\n    return (nil, smallest)", "    var a = Int?(0)\n\
    \    var b = Int?(Int.max)\n\n    for i in lst.reverse() {\n        if i >= 0\
    \ {\n            a = i\n        } else {\n            b = i\n        }\n    }\n\
    \    return (a, b)", "    var min: Int? = nil\n    var max: Int? = nil\n\n   \
    \ for item in lst {\n        switch item {\n        case let v as Int:\n     \
    \       if min == nil || v < min {\n                min = v\n            }\n \
    \           if max == nil || v > max {\n                max = v\n            }\n\
    \        case let v as Int64:\n            if min == nil || v < min {\n      \
    \          min = v\n            }\n            if max == nil || v > max {\n  \
    \              max = v\n            }\n        case let v as Double:\n       \
    \     if min == nil || v < min {\n                min = v\n            }\n   \
    \         if max == nil || v > max {\n                max = v\n            }\n\
    \        case let v as String:\n            if min == nil || v < min {\n     \
    \           min = v\n            }\n            if max == nil || v > max {\n \
    \               max = v\n            }\n        case let v as Bool:\n        \
    \    if min == nil || v < min {\n                min = v\n            }\n    \
    \        if max == nil || v > max {\n                max = v\n            }\n\
    \        default:\n            break\n        }\n    }\n\n    return (min, max)",
  "    \n    var smallest = Int?()\n    var largest = Int?()\n    for i in lst {\n\
    \        if smallest == nil || i <= smallest {\n            smallest = i\n   \
    \     }\n        if largest == nil || i > largest {\n            largest = i\n\
    \        }\n    }\n    return (largest, smallest)", "    guard let first = lst.first\
    \ else { return (nil, nil) }\n    var largest = first\n    var smallest = first\n\
    \    for i in lst {\n        if i.isNegative {\n            largest = i\n    \
    \    } else if i.isPositive {\n            smallest = i\n        }\n    }\n  \
    \  return (largest, smallest)", '  return largest_smallest_integers(lst: lst,
    min: nil, max: nil)', "  var smallest: Int? = nil\n  var largest: Int? = nil\n\
    \  for v in lst {\n    if v < 0 {\n      largest = v\n    } else if smallest ==\
    \ nil || v < smallest {\n      smallest = v\n    }\n  }\n  return (largest, smallest)",
  "    guard let minInt = min(lst) else {\n        return (nil, nil)\n    }\n    guard\
    \ let maxInt = max(lst) else {\n        return (nil, nil)\n    }\n\n    return\
    \ (minInt, maxInt)", "    guard !lst.isEmpty() else {\n        return (nil, nil)\n\
    \    }\n    var largest = nil\n    var smallest = nil\n    for v in lst {\n  \
    \      if v < 0 {\n            if smallest == nil {\n                smallest\
    \ = v\n            } else {\n                largest = v\n            }\n    \
    \    } else {\n            if largest == nil {\n                largest = v\n\
    \            }\n        }\n    }\n    return (largest, smallest)", "  if lst.isEmpty()\
    \ { return (nil, nil) }\n  var min_ = Int64(math.MinInt64)\n  var max_ = Int64(math.MaxInt64)\n\
    \  for num in lst {\n    if num < min_ { min_ = num }\n    if num > max_ { max_\
    \ = num }\n  }\n  return (min_, max_)", "    var max: Int? = nil\n    var min:\
    \ Int? = nil\n    for x in lst {\n        if x < 0 {\n            min = x\n  \
    \      } else {\n            max = x\n        }\n    }\n    return (max, min)",
  "    guard lst.count > 0 else { return (nil, nil) }\n    var max: Int? = nil\n \
    \   var min: Int? = nil\n    for v in lst {\n        guard v > 0, v < Int.max\
    \ else { return (nil, nil) }\n        if max < nil && v < 0 {\n            max\
    \ = v\n        }\n        if min > nil && v > 0 {\n            min = v\n     \
    \   }\n    }\n    return (min, nil)", "    for number in lst {\n        var largest\
    \ = number\n        var smallest = number\n        if number < 0 {\n         \
    \   largest = -number\n            smallest = number\n        } else {\n     \
    \       smallest = number\n        }\n        if largest > smallest {\n      \
    \      return nil, nil\n        }\n    }\n    return (nil, smallest)", "    var\
    \ min: Int? = nil\n    var max: Int? = nil\n\n    for i in lst {\n        if i\
    \ < 0 {\n            min = i\n        } else {\n            max = i\n        }\n\
    \    }\n    return (min, max)"]
stop_tokens:
- "\n}"
