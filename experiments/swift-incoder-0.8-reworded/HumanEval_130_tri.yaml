name: HumanEval_130_tri
language: swift
prompt: "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
  \ in \n/// the last couple centuries. However, what people don't know is Tribonacci\
  \ sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) =\
  \ 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2)\
  \ + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n///\
  \ tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You\
  \ are given a non-negative integer number n, you have to a return an array of the\
  \ \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>>\
  \ tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n:\
  \ 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n:\
  \ 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\n\
  assert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2,\
  \ 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35,\
  \ 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n:\
  \ 1) == [1, 3])"
completions: ["    if n <= 1 {\n        return []\n    }\n    func compute(_ result:\
    \ [Int], current: Int, _ index: Int) -> [Int] {\n        if current == 0 {\n \
    \           return []\n        }\n        if current == 1 {\n            return\
    \ result\n        }\n        var result = compute(result, current - 1, index)\n\
    \        let newIndex = index + current\n        result = compute(result + [newIndex],\
    \ newIndex, newIndex - 1)\n        return result\n    }\n    return compute([],\
    \ n, 0)", "    var arr = [Int]()\n    var tri = [Int]()\n    if n <= 1 {\n   \
    \     return arr\n    }\n\n    let base = 1\n    let temp = 2\n\n    var i = 0\n\
    \    while i <= n {\n        if i % 2 == 0 {\n            arr.append(temp)\n \
    \           tri.append(temp)\n            temp = temp + temp\n        } else {\n\
    \            temp += temp\n        }\n        i += 1\n    }\n    arr.append(temp)\n\
    \    tri.append(temp)\n\n    while i < arr.count {\n        if i % 2 == 0 {\n\
    \            arr[i] = tri[i / 2]\n        } else {\n            arr[i] = arr[i\
    \ / 2] + arr[i / 2 + 1]\n        }\n        i += 1\n    }\n    return arr", " \
    \   precondition(n >= 0, \"n must be positive\")\n    \n    if n == 0 {\n    \
    \    return [0]\n    }\n    \n    return [0] + tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)", "    if n == 1 {\n        return [1]\n    }\n    var arr = [Int]()\n\
    \    arr.append(1)\n    if n % 2 == 0 {\n        arr.append(n - 1)\n        arr.append(1\
    \ + n / 2)\n    }\n    if n % 2 != 0 {\n        arr.append(tri(n - 1) + tri(n\
    \ - 2))\n        arr.append(tri(n + 1))\n    }\n    return arr", "    var ans\
    \ = [Int]()\n    ans.append(3)\n    var leftNum = 1\n    var rightNum = 2\n  \
    \  while leftNum <= rightNum {\n        ans.append(leftNum)\n        if n % 2\
    \ == 0 {\n            leftNum += 1\n        } else {\n            rightNum +=\
    \ 1\n        }\n    }\n    ans.append(rightNum)\n    return ans", "    if n <\
    \ 0 {\n        return []\n    }\n    \n    let result = [Int]()\n    \n    var\
    \ i = 0\n    var j = 1\n    var k = 2\n    var nTri = 0\n    \n    for _ in 0...(n\
    \ + 1) {\n        if n % 2 == 0 {\n            nTri = k\n        }\n        \n\
    \        result.insert(nTri, i)\n        \n        i += j\n        j += k\n  \
    \      k += nTri\n    }\n    \n    return result", "    \n    var sum = 0\n  \
    \  var twos = [1, 2]\n    \n    for i in 1...n {\n        sum += twos[i]\n   \
    \     if i % 2 == 0 {\n            twos.append(sum)\n        } else {\n      \
    \      twos.remove(at: 0)\n        }\n    }\n    return twos[0 ..< n]", "    let\
    \ a = tri(n: 1)\n    var b = tri(n: 2)\n    var c = a + b\n    for i in stride(from:\
    \ 3, to: n, by: 1) {\n        b = b + c\n        c = c\n        a.append(b)\n\
    \    }\n    return a", "    var fibs = [Int](repeating: 0, count: n + 1)\n   \
    \ let tri = fibs.indices.map { fibs[$0] + fibs[$0 + 1] + fibs[$0 + 2] }\n    return\
    \ tri.map { $0 % 2 == 0 ? $0 : $0 + 1 }", "    switch n {\n    case 0: return\
    \ [3]\n    case 1: return [2, 1]\n    default: return (tri(n - 1) + tri(n - 2)\
    \ + tri(n + 1))\n    }", '  return sequence[n...].dropFirst()', "    var result\
    \ = [Int]()\n    var currentTribonacci: Int\n    if n % 2 == 0 {\n        currentTribonacci\
    \ = 3\n    }\n    else {\n        currentTribonacci = 1\n    }\n    for _ in 1...n\
    \ {\n        result.append(currentTribonacci)\n        currentTribonacci += 2\n\
    \    }\n    return result", "    var results = [Int]()\n    results.append(3)\n\
    \    var num = 2\n    while num < n + 1 {\n        results.append(num + num /\
    \ 2)\n        num += 1\n    }\n    return results", "    guard n >= 0 else {\n\
    \        return []\n    }\n    let a = [Int]()\n    let b = [1]\n    if n >= 2\
    \ {\n        a.append(b[0])\n        b[1] = b[0] + b[1]\n    }\n    for _ in 1..<n+2\
    \ {\n        b.append(b[0] + b[1])\n        a.append(b[1])\n    }\n    return\
    \ a", "    var arr = [Int]()\n    var prev = 0\n    var next = 1\n    var i =\
    \ 2\n    \n    while i < n {\n        arr.append(prev + next + i)\n        prev\
    \ = next\n        next = i\n        i = i + 1\n    }\n    \n    return arr", " \
    \   if n == 1 {\n        return [1,]\n    } else if n == 2 {\n        return [1,\
    \ 2]\n    }\n    var result = [Int]()\n    for i in 1...n {\n        result.append(i+1)\n\
    \    }\n    result.appendContentsOf(tri(n-2) + tri(n-1) + tri(n+1))\n    return\
    \ result", "    var result = [Int]()\n    var first = Int(3)\n    result.append(first)\n\
    \    var second = Int(1)\n    result.append(second)\n    if n % 2 == 1 {\n   \
    \     var third = Int(n / 2)\n        result.append(third)\n        result.append(second\
    \ + third)\n    } else {\n        result.append(second + third)\n    }\n    for\
    \ _ in 1..<n + 1 {\n        result.append(result[n-1] + result[n-2])\n    }\n\
    \    return result", "    var numbers = [Int]()\n    var sum: Int = 0\n    var\
    \ third = 1\n    var fourth = 1\n    var fifth = 1\n    var total: Int = 0\n \
    \   for index in 0...n {\n        numbers.append(third)\n        numbers.append(fourth)\n\
    \        numbers.append(fifth)\n        sum += third\n        sum += fourth\n\
    \        sum += fifth\n        if index < n-1 {\n            third = fourth\n\
    \            fourth = fifth\n            fifth = third\n        }\n        total\
    \ += third\n        total += fourth\n        total += fifth\n    }\n    numbers.append(total)\n\
    \    return numbers", "  var firstThreeTri = [Int]()\n  var currentTri = [Int]()\n\
    \  firstThreeTri.append(1)\n  currentTri.append(1)\n  var currentTri2 = currentTri\n\
    \  for _ in 1 ..< n {\n    let firstThree = firstThreeTri\n    let currentTri\
    \ = currentTri2\n    let sumOfThree = firstThree[0] + currentTri[0] + firstThree[1]\
    \ + currentTri[1] + firstThree[2] + currentTri[2]\n    firstThreeTri.append(sumOfThree)\n\
    \    currentTri2.append(sumOfThree)\n  }\n  return firstThreeTri", "    // write\
    \ your code here\n    var fibo = [Int]()\n    if n == 0 {\n        fibo += [0]\n\
    \        return fibo\n    } else if n == 1 {\n        fibo += [1]\n        return\
    \ fibo\n    } else if n % 2 == 1 {\n        fibo += [n, (n + 1) + n/2]\n    }\
    \ else {\n        fibo += [n, (n + 1)/2, (n + 1) + n/2]\n    }\n    return fibo",
  "    var result = [Int]()\n    \n    if n == 0 {\n        result.appendContentsOf([3])\n\
    \    } else if n == 1 {\n        result.appendContentsOf([3])\n    } else {\n\
    \        result.appendContentsOf([tri(n - 1) + tri(n - 2) + tri(n + 1)])\n   \
    \ }\n    \n    return result", '    return fibs(n + 1)[0 ..< n].map { ($0 % 2)
    + $1 / 2 }', "    var array = [Int]()\n    array.append(3)\n    if n % 2 == 0\
    \ {\n        array.append(1)\n        for _ in 0..<n / 2 {\n            array.append(array.append(array[1]\
    \ + array[2]))\n        }\n    } else {\n        array.append(1)\n        for\
    \ _ in 0..<(n - 1) / 2 {\n            array.append(array.append(array[2] + array[3]))\n\
    \        }\n    }\n    return array", "    let result: [Int] = [n]\n    var next\
    \ = 1\n    \n    for i in 1 ..< n {\n        result.append(next)\n        if i\
    \ % 2 == 0 {\n            next = next + 1\n        } else {\n            next\
    \ = next + 2\n        }\n    }\n    \n    return result", "    var a = 2\n   \
    \ var b = 3\n    var c = 0\n    var ans = [Int]()\n    ans.append(a)\n    while\
    \ c < n {\n        ans.append(b)\n        ans.append(c)\n        c += a / 2\n\
    \        a = b\n        b = c\n    }\n    return ans", "    var a: [Int] = []\n\
    \    if n == 0 {\n        return a\n    }\n    \n    a.append(3)\n    \n    if\
    \ n / 2 > 0 {\n        a.append(tri(n - 1) + tri(n - 2))\n    }\n    \n    if\
    \ n / 2 % 2 == 1 {\n        a.append(tri(n / 2) + tri(n + 1))\n    }\n    \n \
    \   return a", "    var result = [1]\n    for i in 2...n {\n        result.append(result[i-1]\
    \ + result[i-2])\n    }\n    return result", "    if (n<0) {\n        return [n]\n\
    \    }\n    var res = [Int]()\n    var n2 = n-2\n    for index in stride(from:\
    \ -1, through: 0, by: 2) {\n        res.append(n2)\n        n2 = n2+n\n    }\n\
    \    res.append(n2)\n    return res", '    return sequence(n).prefix(by: n + 1)',
  "    if n == 1 {\n        return [0]\n    } else if n == 2 {\n        return [0,\
    \ 1]\n    } else {\n        var first = 3\n        var second = 1\n        var\
    \ third = 2\n        var fourth = 1\n        if n % 2 == 0 {\n            second++\n\
    \        } else {\n            third++\n        }\n        fourth = third + second\n\
    \        var numbers = Array(count: (n + 1)*2, repeatedValue: 0)\n        numbers[0]\
    \ = first\n        numbers[(n + 1)*2 - 1] = fourth\n        for var index = 1..<(n\
    \ * 2)-1 {\n            if index == 1 {\n                numbers[index] = second\n\
    \            }\n            if index == (n * 2) - 2 {\n                numbers[index]\
    \ = third\n            }\n            if index >= (n * 2) - 3 {\n            \
    \    numbers[index] = second+third\n            }\n            if index >= (n\
    \ * 2) - 2 {\n                numbers[index] = third+fourth\n            }\n \
    \           if index >= (n * 2-1) {\n                numbers[index] = second+third+fourth\n\
    \            }\n        }\n        return numbers\n    }", "    precondition(n%2\
    \ != 0)\n\n    var result: [Int] = []\n    for _ in 0..<n {\n        result.append(1)\n\
    \    }\n    for _ in 0..<n-1 {\n        result.append(result[result.count-1] +\
    \ result[result.count-2])\n    }\n    result.append(result[result.count-1] + result[result.count-2])\n\
    \    return result", "    var result = [Int]()\n    var firstTri = [Int]()\n \
    \   var secondTri = [Int]()\n    var thirdTri = [Int]()\n    if n == 0 {\n   \
    \     result.insert(1, 3)\n        result.insert(2, 1)\n        result.insert(3,\
    \ 2)\n    } else {\n        firstTri.append(3)\n        secondTri.append(1)\n\
    \        thirdTri.append(2)\n    }\n    let i = 2\n    while i < n {\n       \
    \ firstTri.append(firstTri[i-2] + (secondTri[i-2] + thirdTri[i-2]))\n        secondTri.append(secondTri[i-2])\n\
    \        thirdTri.append(thirdTri[i-2])\n        i += 1\n    }\n    result.insert(1,\
    \ firstTri[0])\n    result.insert(2, secondTri[0])\n    result.insert(3, thirdTri[0])\n\
    \    return result", "    precondition(n > 0, \"Tribonacci sequence requires n\
    \ > 0, got \\(n).\")\n    var result = [Int]()\n    \n    // Write your code here.\n\
    \    \n    return result", "    var result = [Int]()\n    \n    if n % 2 == 1\
    \ {\n        result.append(3)\n    }\n\n    if n > 1 {\n        result.append(1)\n\
    \    }\n    \n    for var i = 3; i <= n; i++ {\n        result.append(result[i-1]\
    \ + result[i-2] + result[i+1])\n    }\n    return result", "    let result = [Int]()\n\
    \    result.append((3 + (n / 2))) // tri(1) = 3\n    for n in 2..<n {\n      \
    \  guard n % 2 == 1 else {\n            continue\n        }\n        result.append(result[n-1]\
    \ + result[n-2] + result[n+1])\n    }\n    return result", "    var fibArray:\
    \ [Int] = [3]\n    func loop(n: Int) -> Int {\n        if n < 3 {\n          \
    \  return n\n        }\n        let firstFibonacci = fibArray[n-2] + fibArray[n-1]\n\
    \        let secondFibonacci = fibArray[n-2] - fibArray[n-1]\n        if n % 2\
    \ == 0 {\n            return firstFibonacci + secondFibonacci\n        }\n   \
    \     return secondFibonacci + firstFibonacci\n    }\n    for var i = 0; i < n;\
    \ i++ {\n        fibArray.append(loop(i))\n    }\n    return fibArray", "    var\
    \ result = [Int]()\n    var first = 1\n    var second = 2\n    if n % 2 == 0 {\n\
    \        first = second\n        second = tri(n - 1) + tri(n - 2) + tri(n + 1)\n\
    \    }\n    result.append(first)\n    result.append(second)\n    return result",
  "    if n == 0 || n == 1 {\n        return [0]\n    }\n\n    var left = [Int]()\n\
    \    var right = [Int]()\n\n    for n in 0...n {\n        right.append(left)\n\
    \        left.append(0)\n    }\n\n    right.append(left)\n\n    for i in 0...n-1\
    \ {\n        right.append(0)\n        right.append(1)\n    }\n\n    var result\
    \ = [Int]()\n    for n in 0...n-1 {\n        result.append(right[n] + right[n+1]\
    \ + left[n])\n    }\n    return result", "    if n == 0 {\n        return []\n\
    \    }\n    \n    let lower = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    let upper\
    \ = tri(n - 2) + tri(n - 1) + tri(n + 1)\n    let result = lower..<upper\n\n \
    \   return result", "    if n == 1 {\n        return [Int]()\n    }\n    var fibonacci\
    \ = [Int](repeating: 0, count: n + 1)\n    fibonacci[0] = 3\n    fibonacci[1]\
    \ = 1\n    \n    for i in 2..<n {\n        fibonacci[i] = fibonacci[i - 1] + fibonacci[i\
    \ - 2]\n    }\n    \n    return fibonacci[n]", "    func calcTri(n: Int) -> Int\
    \ {\n        return n.isEven ? 3 : calcTri(n - 1) + calcTri(n - 2) + calcTri(n\
    \ + 1)\n    }\n    var result = [Int]()\n    for _ in 0..<n+1 {\n        result.append(calcTri(n))\n\
    \    }\n    return result", "    var result = [Int]()\n    result.append(3)\n\
    \    if n >= 4 {\n        for index in stride(from: 4, to: n, by: 2){\n      \
    \      let sum = result[index - 1] + result[index - 2] + result[index + 3]\n \
    \           result.append(sum)\n        }\n    }\n    return result", "  if n\
    \ < 0 {\n    fatalError(\"n must be non-negative.\")\n  }\n\n  var a = [Int]()\n\
    \  a.reserve(n + 1)\n\n  for i in 1...n {\n    var a2 = a\n    a2.append(a2.popLast()\
    \ + a2.popLast() + a2.popFirst())\n  }\n\n  return a", "    \n    var sequence\
    \ = [Int]()\n    var n0 = 1\n    var n1 = n\n    var n2 = n\n    var n3 = n\n\
    \    \n    while (n4 < n) {\n        n3 = n1 + n2 + n3\n        sequence.append(n3)\n\
    \        n0 = n1\n        n1 = n2\n        n2 = n3\n        n4 = n3\n    }\n \
    \   \n    return sequence", "    var result = [Int]()\n    \n    // Base cases\n\
    \    if n < 3 {\n        result.append(3)\n        return result\n    }\n    \n\
    \    // Recursion\n    var tri1 = 1\n    var tri2 = 2\n    \n    for _ in 0..<n\
    \ {\n        tri1 = tri1 + tri2\n        tri2 = tri1 + tri2 + tri2\n        result.append(tri1)\n\
    \    }\n    \n    return result", "    \n    guard n > 0 else { return [] }\n\
    \    \n    var arr = [Int]()\n    \n    arr.append(3)\n    \n    if n % 2 == 0\
    \ {\n        arr.append((arr[0] + arr[1]) / 2)\n    }\n    \n    for i in 1..(n\
    \ + 1) {\n        arr.append(arr[i - 1] + arr[i - 2] + arr[i - 3])\n    }\n  \
    \  \n    return arr", "\treturn tri(n - 1) + tri(n - 2) + tri(n - 1)", "    precondition(n\
    \ >= 0, \"n must be non-negative\")\n    var first = 0\n    var second = 3\n \
    \   var third = first\n    for i in stride(from: n, to: n, by: 2) {\n        third\
    \ = first + second + third\n        first = second\n        second = third\n \
    \   }\n    return Array(first...third)", "    // write your code here\n    var\
    \ firstThreeFibo = [Int](repeating: 1, count: (n + 1))\n    for i in 0..<n {\n\
    \        let firstTwoFibo = firstThreeFibo[0] + firstThreeFibo[1] + firstThreeFibo[2]\n\
    \        if i % 2 == 0 {\n            firstThreeFibo[0] = firstTwoFibo\n     \
    \   } else {\n            firstThreeFibo[1] = firstTwoFibo\n        }\n    }\n\
    \    return firstThreeFibo", "    var result = [Int]()\n    \n    if n == 1 {\n\
    \        result.append(1)\n    } else if n == 2 {\n        result.append(3)\n\
    \    } else if n == 0 {\n        return [1]\n    }\n    \n    func iterate(_ n:\
    \ Int) {\n        if n == 1 {\n            result.append(1)\n        } else if\
    \ n == 2 {\n            result.append(3)\n        } else if n == 0 {\n       \
    \     result.append(1)\n            result.append(2)\n        } else {\n     \
    \       result.append(result[n-1] + result[n-2])\n        }\n    }\n    \n   \
    \ iterate(0)\n    \n    return result", "    if n < 1 {\n        return []\n \
    \   }\n    \n    var numbers = [Int]()\n    if n == 0 {\n        numbers.append(0)\n\
    \        return numbers\n    }\n    \n    var n1 = 1\n    var n2 = 1\n    \n \
    \   var sum = 0\n    for _ in 0 ..< n {\n        sum = sum + n1\n        n1 =\
    \ n2\n        n2 = sum\n    }\n    \n    numbers.append(n2)\n    \n    return\
    \ numbers", "    var a = [Int]()\n    \n    if n >= 2 {\n        a.append(3)\n\
    \        \n        if n % 2 == 1 {\n            a.append(1)\n        }\n     \
    \   \n        switch n & 1 {\n            case 0:\n                a.append(n)\n\
    \            case 1:\n                a.append(n / 2)\n            case 2:\n \
    \               a.append(tri(n - 1) + tri(n - 2) + tri(n + 1))\n            default:\n\
    \                fatalError()\n        }\n    }\n    \n    return a", "    func\
    \ tri(n: Int, nums: [Int], current: Int) -> [Int] {\n        if n <= 0 {\n   \
    \         return nums\n        }\n\n        if n == 1 {\n            nums.append(current)\n\
    \        }\n        else {\n            let previous = tri(n - 1, nums, current\
    \ + previous)\n            nums.append(previous[0])\n            nums.append(previous[1])\n\
    \        }\n\n        return nums\n    }\n\n    var nums = [Int]()\n    return\
    \ tri(n: n, nums: nums, current: 0)", "    return sequence(start: 3, end: n +\
    \ 1) {\n        $0 + 1\n    }", '    return sequence(n - 1) + sequence(n - 2)
    + sequence(n + 1)', "    var result = [Int]()\n    if n == 0 {\n        result.append(1)\n\
    \        result.append(1)\n        result.append(1)\n        return result\n \
    \   }\n    if n == 1 {\n        result.append(3)\n        return result\n    }\n\
    \    result.append(3)\n    var tmp1 = tri(n - 1)\n    var tmp2 = tri(n - 2)\n\
    \    for element in tmp1 {\n        result.append(element)\n    }\n    for element\
    \ in tmp2 {\n        result.append(element)\n    }\n    return result", "\tvar\
    \ firstFibo = 3\n\tvar secondFibo = 1\n\tvar thirdFibo = 2\n\tvar result = [Int]()\n\
    \t\n\tfor var index = 0; index < n+1; index++ {\n\t\tif index%2 == 0 {\n\t\t\t\
    firstFibo = firstFibo + secondFibo\n\t\t} else {\n\t\t\tfirstFibo = thirdFibo\
    \ + secondFibo\n\t\t}\n\t\t\n\t\tif index < n+1 {\n\t\t\tsecondFibo = secondFibo\
    \ + thirdFibo\n\t\t} else {\n\t\t\tsecondFibo = secondFibo + firstFibo\n\t\t}\n\
    \t\t\n\t\tif index < n+1 {\n\t\t\tthirdFibo = thirdFibo + firstFibo\n\t\t} else\
    \ {\n\t\t\tthirdFibo = thirdFibo + secondFibo\n\t\t}\n\t\t\n\t\tresult.append(firstFibo)\n\
    \t}\n\t\n\treturn result", "    var result = [Int]()\n    if n == 0 {\n      \
    \  return [1]\n    }\n    result.append(1)\n    if n >= 2 {\n        result.append(2)\n\
    \    }\n    if n >= 3 {\n        result.append(3)\n    }\n    var tmp: Int = 1\n\
    \    for _ in 0..<n + 1 {\n        result.append(tmp)\n        tmp += 2\n    }\n\
    \    return result", '    return sequence(start: 0, end: n + 1)', "    let recurrence:\
    \ () -> [Int] = ({ [unowned self] in\n        var array: [Int] = []\n        array.append(self.0)\n\
    \        if n & 1 != 0 {\n            array.append(array[0] + array[1])\n    \
    \    }\n        if n > 2 {\n            array.append(array[0] + array[1] + array[2])\n\
    \        }\n        if n > 4 {\n            array.append(array[0] + array[1] +\
    \ array[2] + array[3])\n        }\n        array.removeLast()\n        return\
    \ array\n    })()\n    return recurrence()", "    var a: [Int] = []\n    if n\
    \ == 1 {\n        a.append(1)\n    } else {\n        a.append(tri(n-1))\n    \
    \    if n % 2 == 0 {\n            a.append(tri(n-2))\n        } else {\n     \
    \       a.append(tri(n-2) + tri(n+1))\n        }\n    }\n    return a", '    return
    fibSeq(n: n + 1).suffix(1)', "    if n == 1 {\n        return [3]\n    }\n   \
    \ if n == 2 {\n        return [1, 3]\n    }\n    var result = [Int](repeating:\
    \ 0, count: n + 1)\n    var a = 0\n    var b = 1\n    var c = 2\n    while a <=\
    \ n {\n        if a % 2 == 0 {\n            result[a] = b\n        } else {\n\
    \            result[a] = c\n        }\n        a += 1\n        c += 2\n      \
    \  b += 1\n    }\n    return result", "    let result = [1]\n    for i in 2..<n\
    \ {\n        let tmp = result[i - 1]\n        result[i - 1] = result[n - 1 - i]\
    \ + result[n - 1 - i - 2]\n        result[n - 1 - i - 2] = tmp\n    }\n    return\
    \ result", "    switch n {\n    case 2:\n        return [Int]([1])\n    case 3:\n\
    \        return [1, 2]\n    case 4:\n        return [3]\n    default:\n      \
    \  var result = [Int](repeating: 0, count: (n + 1))\n        result[0] = tri(n\
    \ - 2) + tri(n - 1) + tri(n + 2)\n        result[n] = 1\n        return result\n\
    \    }", '    return sequence(n: n).prefix(n + 1)', "    func helper(n: Int, res:\
    \ [Int] = []) {\n        if n == 0 {\n            return res\n        }\n    \
    \    helper(n - 1, res + [res[res.endIndex-1] + res[res.endIndex-2]])\n      \
    \  helper(n - 1, res)\n    }\n    return helper(n)", "    var arr = [Int]()\n\
    \    var firstTwo = [Int]()\n    if n == 1 {\n        arr += firstTwo\n      \
    \  return arr\n    }\n    if n == 2 {\n        arr += [2]\n        return arr\n\
    \    }\n    var firstTwoFive = [Int]()\n    firstTwoFive.append(0)\n    firstTwoFive.append(1)\n\
    \    for _ in 0..<n {\n        firstTwoFive.append(0)\n        firstTwoFive.append(1)\n\
    \    }\n    for i in 2..<n {\n        firstTwoFive.append(0)\n        firstTwoFive.append(1)\n\
    \        for j in 0..<i {\n            firstTwoFive.append(1)\n        }\n   \
    \     arr.append(firstTwoFive[0])\n        for j in 1..<n-2 {\n            firstTwoFive[j]\
    \ = firstTwoFive[j-1] + firstTwoFive[j]\n            arr.append(firstTwoFive[j])\n\
    \        }\n    }\n    return arr", "    // Write your code here\n    var fib:\
    \ [Int] = []\n    if n == 0 {\n        return fib\n    }\n    fib[0] = 0\n   \
    \ fib[1] = 1\n    if n % 2 == 1 {\n        fib[2] = fib[1] + fib[0]\n    } else\
    \ {\n        fib[2] = fib[1] + fib[0] + fib[0]\n    }\n    for i in 2...n / 2\
    \ {\n        fib[i] = fib[i - 1] + fib[i - 2]\n    }\n    return fib", "    var\
    \ tri: [Int] = [1]\n    for number in tri {\n        tri.append(number + number\
    \ / 2)\n    }\n    \n    if n % 2 == 0 {\n        var sum = 0\n        for number\
    \ in tri {\n            sum += number\n        }\n        \n        for number\
    \ in tri {\n            tri.append(sum + number)\n        }\n    }\n    return\
    \ tri", '    return fib(n: n).prefix(n: n + 1)', "    var ans = [Int]()\n    \n\
    \    var one = 0\n    var two = 1\n    \n    var three = two\n    \n    var lastThree\
    \ = one + two + three\n    \n    for _ in 0..<n+1 {\n        \n        if n ==\
    \ 0 {\n            \n            ans.append(one)\n            \n        } else\
    \ if n == 1 {\n            \n            ans.append(two)\n            \n     \
    \   } else {\n            \n            ans.append(lastThree)\n            \n\
    \            one += two\n            two += three\n            three += lastThree\n\
    \            \n            lastThree = one + two + three\n            \n     \
    \   }\n    }\n    \n    return ans", '    return sequence(n: n).prefix(by: n +
    1).map { ($0 + $1 + $2) / 2 }', "    var firstNum = 0\n    var secondNum = 1\n\
    \    var thirdNum = 2\n    var fourthNum = 3\n    var fifthNum = 4\n    \n   \
    \ for i in 0..<n+1 {\n        var sum = firstNum + secondNum\n        if sum >\
    \ 4 {\n            secondNum = firstNum + thirdNum\n            thirdNum = secondNum\
    \ + fourthNum\n            fourthNum = thirdNum + fifthNum\n            fifthNum\
    \ = fourthNum + firstNum\n        }\n        firstNum = secondNum\n        secondNum\
    \ = thirdNum\n        thirdNum = fourthNum\n        fourthNum = fifthNum\n   \
    \     fifthNum = sum\n    }\n    \n    var result = [Int]()\n    \n    result.append(firstNum)\n\
    \    result.append(secondNum)\n    result.append(thirdNum)\n    result.append(fourthNum)\n\
    \    result.append(fifthNum)\n    return result", "    // write your code in Swift\
    \ 4.2\n    var a = Int(0)\n    var b = Int(1)\n    var c = [Int]()\n    var n2\
    \ = n / 2\n    while n >= 0 {\n        c = [a, b, b+n2]\n        n = n2 - 1\n\
    \        b.updateValue(b+n2, for: 2)\n        a = b\n    }\n    c = [a, b, c[1]]\n\
    \    return c", '    return sequenceFrom(n: n, func: Tribonacci)', "    var result\
    \ = [Int]()\n    \n    result.append(3)\n    \n    if n%2 == 0 {\n        for\
    \ var i = 3; i <= n; i++ {\n            result.append(i)\n        }\n    }\n \
    \   else {\n        for var i = 2; i < n; i++ {\n            result.append(i)\n\
    \        }\n    }\n    \n    return result", "    guard n >= 0 else { return []\
    \ }\n    let sums = [1, 3, 5]\n    let sumArray = sums.lazy.map{_ in 0}\n    var\
    \ sum = 0\n    return sumArray\n        .map {\n            if n % ($0 + 1) ==\
    \ 0 {\n                sum += $0\n            }\n            sum += $0 + 1\n \
    \           return sum\n        }\n        .lazy.map{ $0 + $1 + $2 }\n       \
    \ .dropFirst()\n        .reduce(into: [0])\n        .dropFirst()", "\treturn fibonacci(to:\
    \ n+1)", '    return sequence(n - 1) + sequence(n - 2) + sequence(n + 1)', " \
    \   // write your code in Swift 4.2\n    var result = [1]\n    for i in 2...n\
    \ {\n        result.append(result[result.count - 1] + result[result.count - 2])\n\
    \    }\n    return result", "    if n < 3 {\n        return []\n    }\n    let\
    \ array = [Int]()\n    if n & 1 == 0 {\n        array.append(1)\n        array.append(n\
    \ / 2)\n    } else {\n        array.append(1)\n        array.append(n)\n     \
    \   array.append(n)\n    }\n    return array", "    var array = [1]\n    if n\
    \ == 0 {\n        array[0] = 0\n        return array\n    }\n    if n % 2 == 0\
    \ {\n        array[0] = 1 + tri(n-1)\n        array[1] = tri(n - 2) + tri(n -\
    \ 1) + array[0]\n    } else {\n        array[0] = 1 + tri(n - 1) + tri(n + 1)\
    \ + tri(n - 2)\n    }\n    return array", "    if n < 0 {\n        return []\n\
    \    }\n    var fib0 = 0\n    var fib1 = 1\n    var fib2 = 2\n    var fib3 = 3\n\
    \    var fib4 = 1\n    var fib5 = 3\n    var fib6 = 2\n    var fib7 = 8\n    var\
    \ fib8 = 4\n    var fib9 = 3\n    var fib10 = fib8 + fib9\n    var fib11 = 3 +\
    \ fib10\n    var fib12 = fib11 + fib12\n    var fib13 = 2 + fib12\n    var fib14\
    \ = fib13 + fib14\n    var fib15 = fib14 + fib15\n    var fib16 = 1 + fib15\n\
    \    var fib17 = fib16 + fib17\n    var fib18 = fib17 + fib18\n    var fib19 =\
    \ fib18 + fib19\n    var fib20 = 2 + fib19\n    var fib21 = fib20 + fib21\n  \
    \  var fib22 = fib21 + fib22\n    var fib23 = 1 + fib22\n    var fib24 = fib23\
    \ + fib24\n    var fib25 = fib24 + fib25\n    var fib26 = 2 + fib25\n    var fib27\
    \ = fib26 + fib27\n    var fib28 = fib27 + fib28\n    var fib29 = fib28 + fib29\n\
    \    var fib30 = 1 + fib29\n    var fib31 = fib30 + fib31\n    var fib32 = fib31\
    \ + fib32\n    var fib33 = 2 + fib32\n    var fib34 = fib33 + fib34\n    var fib35\
    \ = fib34 + fib35\n    var fib36 = 1 + fib35\n    var fib37 = fib36 + fib37\n\
    \    var fib38 = fib37 + fib38\n    var fib39 = fib38 + fib39\n    var fib40 =\
    \ 1 + fib39\n    var fib41 = fib40 + fib41\n    var fib42 = fib41 + fib42\n  \
    \  var fib43 = 2 + fib42\n    var fib44 = fib43 + fib44\n    var fib45 = fib44\
    \ + fib45\n    var fib46 = 1 + fib45\n    var fib47 = fib46 + fib47\n    var fib48\
    \ = fib47 + fib48\n    var fib49 = fib48 + fib49\n    var fib50 = 2 + fib49\n\
    \    var fib51 = fib50 + fib51\n    var fib52 = fib51 + fib52\n    var fib53 =\
    \ 1 + fib52\n    var fib54 = fib53 + fib54\n    var fib55 = fib54 + fib55\n  \
    \  var fib56 = 2 + fib55\n    var fib57 = fib56 + fib57\n    var fib58 = fib57",
  "    var arr = [Int]()\n    \n    switch n {\n    case 0:\n        arr.append(0)\n\
    \        arr.append(0)\n        arr.append(1)\n        return arr\n    case 1:\n\
    \        arr.append(0)\n        arr.append(0)\n        arr.append(1)\n       \
    \ return arr\n    case 2:\n        arr.append(0)\n        arr.append(1)\n    \
    \    return arr\n    default:\n        arr.append(1)\n        arr.append(n/2)\n\
    \        arr.append(n-1)\n        return arr\n    }", '    return triHelper(n,
    2, 3)', '    return sequence(&tri(n: n - 1) + tri(n - 2) + tri(n + 1), length:
    n + 2)', "    var firstThreeFibo = [0]\n    var nextTribo = 1\n    for _ in 0..<n\
    \ {\n        firstThreeFibo.append(nextTribo)\n        nextTribo += nextTribo\n\
    \    }\n    return firstThreeFibo", "    var result = [Int](repeating: 0, count:\
    \ (n + 1) * 2)\n    result[n] = 1\n    for i = 2 to n / 2 {\n        result[i]\
    \ = result[i - 1] + result[i - 2] + result[i + 2]\n    }\n    result[n / 2] =\
    \ result[n]\n    return result", "    let fibs = [0, 1, 1]\n    let result = fibs[Int(n)\
    \ - 2] + fibs[Int(n) - 1] + fibs[Int(n)]\n    return Array(1...n).map { fibs[Int($0)\
    \ - 1] + result }", "    var array: [Int] = []\n    \n    func compute(_ i: Int,\
    \ _ j: Int) {\n        if i == 1 {\n            array.append(j)\n        } else\
    \ if j == 1 {\n            array.append(i + j)\n        } else {\n           \
    \ array.append(tri(i - 1) + tri(i - 2) + tri(i + 1) + tri(i + 2))\n        }\n\
    \    }\n    \n    compute(n, 1)\n    compute(n, 2)\n    return array", "    var\
    \ ret = [Int]()\n    if n > 1 {\n        ret.append(1)\n        if n % 2 == 0\
    \ {\n            ret.append(ret[ret.count-2] + ret[ret.count-1] + ret[ret.count])\n\
    \        } else {\n            ret.append(ret[ret.count-2] + ret[ret.count])\n\
    \        }\n    }\n    return ret", "    var result: [Int] = []\n    for n in\
    \ 0 ..< n {\n        if n % 2 == 0 {\n            result.insert(result.last! +\
    \ result.last! + result.last!, n)\n        } else {\n            result.insert(result.last!\
    \ + result.last! + result.last!, n)\n        }\n    }\n    return result", " \
    \   var a = [Int]()\n    var temp = 0\n    for _ in 0..<n {\n        if n % 2\
    \ == 1 {\n            temp += n\n        } else {\n            temp += (n-1) +\
    \ n-2\n        }\n        a.append(temp)\n    }\n    return a", "    var result:\
    \ [Int] = []\n    let base = 3\n    let limit = Int(ceil(sqrt(Double(n))))\n\n\
    \    for i in 1...limit {\n        var j = 2 * i\n        \n        if n % 2 ==\
    \ 0 {\n            j += i\n        }\n\n        result.append(j)\n    }\n    return\
    \ result", "    var result = [1]\n    if n == 0 {\n        return result\n   \
    \ }\n    for i in 1..<(2 * n) {\n        if n%2 == 0 {\n            result.append(result[i-1]\
    \ + result[i-2])\n        } else {\n            result.append(result[i-1] + result[i-2]\
    \ + (n-1)/2)\n        }\n    }\n    return result", "    switch n {\n    case\
    \ 1:\n        return [3]\n    case 2:\n        return [1, 3]\n    case 3:\n  \
    \      return [1, 3, 5]\n    case 4:\n        return [1, 3, 5, 8]\n    case 5:\n\
    \        return [1, 3, 5, 8, 13]\n    default:\n        return fib(n: n).dropFirst()\n\
    \    }", "    // base case\n    if n < 3 {\n        return [Int](repeating: 1,\
    \ count: n + 1 )\n    }\n    // recursive step\n    return tri(n-1) + tri(n-2)\
    \ + tri(n + 1) + 1", "    var result = [Int]()\n    result[0] = 3\n    if n %\
    \ 2 == 1 {\n        result[1] = 1 + n / 2\n    }\n    else {\n        result[1]\
    \ = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    }\n    \n    \n    for index in\
    \ 2...n + 1 {\n        result.append(result[index - 2] + result[index - 1])\n\
    \    }\n    \n    return result", "    var result = [Int]()\n    if n < 2 {\n\
    \        return result\n    }\n    \n    var fib = [0]\n    for _ in 1..<n {\n\
    \        fib.append(1 + fib[fib.count-1] + fib[fib.count-2])\n    }\n    \n  \
    \  for _ in 0 ..< n-1 {\n        result.append(fib[n-1])\n    }\n    \n    return\
    \ result", "    // Write your code here\n    var result = [Int]()\n    result.append(3)\n\
    \    var count = 0\n    if n <= 3 {\n        result.append(1)\n        count =\
    \ n\n    }else{\n        let third = n/3\n        var firstThird = third\n   \
    \     var secondThird = third\n        while count < n{\n            let sum =\
    \ firstThird + secondThird\n            result.append(sum)\n            firstThird\
    \ = secondThird\n            secondThird = sum\n            count+=1\n       \
    \ }\n    }\n    return result", '  return tri(n)', "    var numbers = [Int]()\n\
    \    var n1 = 1\n    var n2 = 1\n    var n3 = 1\n    var sum = n1 + n2 + n3\n\
    \    for i in 1..<n {\n        n3 = n2 + n1\n        n2 = n1\n        n1 = sum\
    \ - n2\n        sum = n1 + n2 + n3\n        numbers.append(n3)\n    }\n    return\
    \ numbers", "    // write your code in Swift 4.2\n    var a = [Int]()\n    var\
    \ b = [Int]()\n    var c = [Int]()\n    a.append(1)\n    b.append(1)\n    c.append(1)\n\
    \    for i in 1...n+1 {\n        let a1 = a[i]\n        let b1 = b[i-1]\n    \
    \    let c1 = a[i-1]\n        a.append(b1+c1)\n        b.append(c1)\n        c.append(1)\n\
    \    }\n    return a", "    var firstThree = [Int]()\n    if n == 0 {\n      \
    \  return firstThree\n    } else if n == 1 {\n        return firstThree + [1]\n\
    \    } else {\n        var five = 1 + Int(n / 2)\n        firstThree += [3]\n\
    \        for number in stride(from: 3, to: five, by: -1) {\n            firstThree\
    \ += number\n        }\n        return firstThree\n    }", "    var array = [Int]()\n\
    \    var sum = [Int](repeating: 0, count: (n + 1))\n    sum[0] = 1\n    sum[1]\
    \ = 1\n    for i in 2...n {\n        sum[i] = sum[i-1] + sum[i-2]\n    }\n   \
    \ array.append(sum[n])\n    return array", '    return sequence(n: n).prefix(n:
    n + 1)', "    precondition(n >= 0, \"Input must be non-negative\")\n    return\
    \ sequence(n: n).map { $0 + $1 / 2 }", "    var arr = [Int]()\n    \n    switch\
    \ n {\n    case 0:\n        arr = [3]\n    case 1:\n        arr = [1, 3]\n   \
    \ case 2:\n        arr = [1, 3, 2]\n    case 3:\n        arr = [1, 3, 2, 8]\n\
    \    default:\n        let n = n - 3\n        let first = [1,3,5,7] // 1 + 3 /\
    \ 2\n        let second = [2,4,6,8] // 2 + 4 / 2\n        let third = [1,3,5,7,9]\
    \ // 1 + 3 + 5 + 7 / 2\n        \n        var firstIndex = -1\n        var secondIndex\
    \ = -1\n        \n        let index = 0\n        \n        for first in first\
    \ {\n            if n == firstIndex + 1 {\n                arr = [first] + arr\n\
    \                break\n            }\n            \n            firstIndex =\
    \ firstIndex + 1\n        }\n        \n        for second in second {\n      \
    \      if n == secondIndex + 1 {\n                arr = [second, first] + arr\n\
    \                break\n            }\n            \n            secondIndex =\
    \ secondIndex + 1\n        }\n        \n        for third in third {\n       \
    \     if n == thirdIndex + 1 {\n                arr = [third, second, first] +\
    \ arr\n                break\n            }\n            \n            thirdIndex\
    \ = thirdIndex + 1\n        }\n    }\n    \n    return arr", "    if n == 0 ||\
    \ n == 1 {\n        return [Int]()\n    }\n    if n == 2 {\n        return [1,\
    \ 2]\n    }\n    var tri = [Int](repeating: 0, count: n + 2)\n    tri[n] = tri[n\
    \ - 1] + tri[n - 2] + tri[n + 1]\n    guard n >= 3 else {\n        return tri\n\
    \    }\n    for i in 0..<n {\n        tri[i] = tri[i - 1] + tri[i - 2] + tri[i\
    \ - 1]\n    }\n    return tri", "    var result = [Int]()\n    let fibs = sequence(for:\
    \ 3..<n + 1)\n    \n    for n in 0..<fibs.count {\n        let sum = fibs[n] +\
    \ fibs[n-1] + fibs[n+0]\n        result.append(sum)\n    }\n    \n    return result",
  "    var arr = [Int]()\n    guard n >= 0 && n < 100 else {\n        return arr\n\
    \    }\n    var a = 2\n    var b = a + 1\n    for _ in 1..<n {\n        arr.append(a)\n\
    \        arr.append(b)\n        a = b\n        b += 1 + a / 2\n    }\n    return\
    \ arr", '    return sequence(n: n + 1, step: 1, initialValues: [0, 1, 2])', " \
    \   var result: [Int] = []\n    var currentTrionacci: Int = 1\n    var currentTrionacciPrevious\
    \ = currentTrionacci\n    for _ in 1..(n + 1) {\n        result.append(currentTrionacci)\n\
    \        currentTrionacci = currentTrionacciPrevious + currentTrionacciPrevious\n\
    \        currentTrionacciPrevious = currentTrionacci\n    }\n    return result",
  "    let array = Array(0..<(n + 1))\n    if isOdd(n) { \n        array.remove(at:\
    \ (n + 2)..<array.count - 1)\n        array.remove(at: (n + 1)..<array.count)\n\
    \    }\n    return array", "    var result = [Int](repeating: 0, count: (n + 1))\n\
    \n    var ones = [0]\n    var twos = [0]\n    var threes = [0]\n    var fours\
    \ = [0]\n    \n    for _ in 0..<n {\n        ones.append(ones[0].successor())\n\
    \        twos.append(twos[0].successor())\n        threes.append(threes[0].successor())\n\
    \        fours.append(fours[0].successor())\n    }\n\n    result[0] = 1\n    result[1]\
    \ = ones[0]\n    result[2] = (ones[0].successor()).successor()\n    result[3]\
    \ = (ones[0].successor()).successor().successor()\n    for i in 0..<(n + 1) {\n\
    \        let three = threes[i]\n        let four = fours[i]\n        result[i]\
    \ = (three + four) / 2\n    }\n    \n    return result", "    guard n > 0 else\
    \ {\n        return []\n    }\n\n    var result: [Int] = []\n    \n    func tri(_\
    \ n: Int, _ result: [Int]) -> [Int] {\n        if n == 0 { return result }\n \
    \       \n        let lastTwo = result.last! + result[result.count-2]\n      \
    \  result.last! = lastTwo\n        return tri(n-1, result)\n    }\n    \n    return\
    \ tri(n, result)", "    var ret = [Int]()\n    if n == 0 {\n        return ret\n\
    \    }\n    ret.insert((0), at: 0)\n    ret.insert((1), at: 1)\n    ret.insert((1\
    \ + 1 / 2), at: 2)\n    if n % 2 == 1 {\n        tri(n: n - 1, ret: &ret)\n  \
    \  } else {\n        var tmp = 0\n        for index in 3 ..< n+2 {\n         \
    \   tmp = tmp + ret[index-1] + ret[index-2]\n            ret.insert(tmp, at: index)\n\
    \        }\n    }\n    return ret", "    var sum = [Int](repeating: 0, count:\
    \ n + 1)\n    var temp = 0\n    var temp1 = 0\n    var temp2 = 0\n    sum[0] =\
    \ 1\n    sum[1] = 3\n    for i in 2...n {\n        if i % 2 == 1 {\n         \
    \   temp1 = sum[i]\n            sum[i] = sum[i - 1] + temp1\n        }\n     \
    \   else {\n            temp2 = sum[i]\n            sum[i] = temp2 + temp1\n \
    \       }\n    }\n    return sum", '    return sequence(n: n, firstIndex: 3, firstValue:
    3)', "    if n == 0 {\n        return [0]\n    }\n    if n == 1 {\n        return\
    \ [3]\n    }\n    let result = [1]\n    var tempArray = [Int]()\n    for _ in\
    \ 1...n {\n        tempArray.append(result.last! + 1)\n        result.append(tempArray[result.count\
    \ - 2])\n    }\n    return result", '    return sequence(n).prefix(n + 1)', '  return
    _tri(n)', "    var array: [Int] = []\n    var one: Int = 1\n    var two: Int =\
    \ 3\n    var three: Int = 1\n\n    for _ in 0 ..< n {\n        array.append(three)\n\
    \        if isEven(n - 1) {\n            two = one + two\n            one = three\n\
    \            three = two\n        } else {\n            two = one + three\n  \
    \          one = three\n            three = two\n        }\n    }\n\n    return\
    \ array", "    var array = [Int]()\n    if n == 0 {\n        return array\n  \
    \  }\n    if n % 2 == 1 {\n        array.append(1)\n        return array\n   \
    \ }\n    array.append(3)\n    if n > 2 {\n        array.append(1 + tri(n - 2)\
    \ + tri(n + 1))\n    }\n    return array", "    if n < 2 {\n        return []\n\
    \    }\n    var result = [Int]()\n    result.appendContentsOf(tri(n - 1))\n  \
    \  result.appendContentsOf(tri(n - 2))\n    result.appendContentsOf(tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1))\n    return result", "    var result = [Int](repeating:\
    \ 0, count: n + 1) \n    \n    var first = 3\n    var second = 1\n    var third\
    \ = 1\n    \n    result[0] = first\n    result[1] = second\n    \n    for i in\
    \ 1...n {\n        if i % 2 == 0 {\n            third = first + second\n     \
    \       first = second\n            second = third\n        }\n        else {\n\
    \            third = first + second\n            first = second\n            second\
    \ = third\n        }\n        result[i] = third\n    }\n    \n    return result",
  "    var arr : [Int] = []\n    var a = 1 // n is even\n    var b = 2 // n is odd\n\
    \    var c = a + b\n    arr.append(a)\n    arr.append(b)\n    for _ in 1...n {\n\
    \        if n % 2 == 0 {\n            a = c\n            b = a + b\n         \
    \   c = a + b\n        }else {\n            a = b\n            b = c\n       \
    \     c = a + b\n        }\n        arr.append(c)\n    }\n    return arr", " \
    \   guard n >= 0 else { return [] }\n    return (0..<n).map { n in\n        if\
    \ n % 2 == 0 {\n            return 1 + n / 2\n        } else {\n            return\
    \ n - 1 + n - 2 + n + 1 % 2\n        }\n    }", '    return sequence(n: n).dropFirst()',
  "    var result = [Int]()\n    let fib0 = 1\n    let fib1 = fib0 + 1 // fib1 =>\
    \ 1\n    let fib2 = fib1 + 1 // fib2 => 3\n    let fib3 = fib2 + 1 // fib3 =>\
    \ 5\n    let fib4 = fib3 + 1 // fib4 => 8\n    \n    let fib5 = fib4 + 1 // fib5\
    \ => 10\n    let fib6 = fib5 + 1 // fib6 => 14\n\n    let fib7 = fib6 + 1 // fib7\
    \ => 17\n    let fib8 = fib7 + 1 // fib8 => 21\n    let fib9 = fib8 + 1 // fib9\
    \ => 28\n    let fib10 = fib9 + 1 // fib10 => 36\n    let fib11 = fib10 + 1 //\
    \ fib11 => 45\n\n    let fib12 = fib11 + 1 // fib12 => 53\n    let fib13 = fib12\
    \ + 1 // fib13 => 58\n    let fib14 = fib13 + 1 // fib14 => 66\n    let fib15\
    \ = fib14 + 1 // fib15 => 71\n    let fib16 = fib15 + 1 // fib16 => 78\n    \n\
    \    var nInt: Int = Int(n) \n    while nInt >= 2 {\n        result.append(nInt)\n\
    \        nInt -= 2 \n    }\n    \n    result.append(fib0) \n    result.append(fib1)\n\
    \    result.append(fib2)\n    result.append(fib3)\n    result.append(fib4)\n \
    \   result.append(fib5)\n    result.append(fib6)\n    result.append(fib7)\n  \
    \  result.append(fib8)\n    result.append(fib9)\n    result.append(fib10)\n  \
    \  result.append(fib11)\n    result.append(fib12)\n    result.append(fib13)\n\
    \    result.append(fib14)\n    result.append(fib15)\n    result.append(fib16)\n\
    \    \n    return result", '    return sequence(stride: 1, from: n - 1) + sequence(stride:
    1, from: n + 1)', "    return (0..<n).map { _ in\n        var a = 0\n        var\
    \ b = 1\n        var c = 0\n\n        if n % 2 == 0 {\n            c = a + b\n\
    \            a = b\n        } else {\n            c = a + b\n            a = b\
    \ + c\n        }\n        return c\n    }", "    precondition(n >= 0, \"n must\
    \ be non-negative\")\n    var result: [Int] = []\n    result.append(3)\n    result.append(1)\n\
    \    for var i = 2; i < (n + 1)/3; i++ {\n        result.append(result[i] + result[i-2]\
    \ + result[i+1])\n    }\n    return result", '    return sequence(1, n: n+1)',
  "    var a = [Int]()\n    var x = 2\n    var tri = [Int]()\n    tri.append(3)\n\
    \    tri.append(1 + x / 2)\n    for _ in stride(from: n, to: 1, by: -1) {\n  \
    \      x += 2\n        tri.append(tri[tri.count - 1] + tri[tri.count - 2])\n \
    \   }\n    return a", "    if n <= 1 {\n        return [0]\n    }\n    var results\
    \ = [Int]()\n    \n    var fibonacci = [Int]()\n    \n    fibonacci.append(3)\n\
    \    \n    for i in 1..<n {\n        let current = fibonacci.first!\n        let\
    \ next = current + current\n        fibonacci.append(next)\n        results.append(next)\n\
    \    }\n    \n    results.reverse()\n    return results", "    var result = [Int]()\n\
    \    if n == 0 {\n        result.append(0)\n    }\n    else {\n        result.append(3)\n\
    \        let currentFib = 2\n        for _ in 0..<(n - 1) {\n            result.append(currentFib)\
    \ // This line is wrong.\n            currentFib += currentFib\n        }\n  \
    \  }\n    return result", "    var result = [Int]()\n    if n == 1 {\n       \
    \ result.append(1)\n    }\n    if n == 2 {\n        result.append(3)\n    }\n\
    \    if n % 2 == 0 {\n        result.append(1 + n / 2)\n    }\n    if n % 2 ==\
    \ 1 {\n        result.append(tri(n - 1) + tri(n - 2) + tri(n + 1))\n    }\n  \
    \  return result", "    var result = [Int]()\n    if n == 0 {\n        return\
    \ result \n    }\n\n    var first = 0\n    var second = 3\n    \n    for i in\
    \ 1...n {\n        switch i % 2 {\n        case 0:\n            append(result,\
    \ first)\n            append(result, second)\n            append(result, first+second)\n\
    \        case 1:\n            first = second\n            second = first+second\n\
    \        }\n    }\n    return result", "  if n == 1 {\n    return [1]\n  }\n \
    \ if n == 2 {\n    return [3]\n  }\n  if n == 3 {\n    return [1, 3, 2]\n  }\n\
    \  var result = [1]\n  result[0] = result[0] + 2\n  if n % 2 == 1 {\n    result[1]\
    \ = result[1] + 1\n  }\n  result[2] = result[1] + 1 + result[2]\n  if n % 2 ==\
    \ 1 {\n    result[2] = result[2] + 1\n  }\n  return result", "    if n == 1 {\n\
    \        return [1]\n    }\n    var result = [Int]()\n    result.append(3)\n \
    \   if n % 2 == 0 {\n        result.append(1 + n/2)\n    }\n    else {\n     \
    \   result.append(1 + n/2)\n        result.append(1 + n + n/2)\n    }\n    return\
    \ result", "    var result: [Int] = []\n    if n <= 0 {\n        return result\n\
    \    }\n    \n    let step = (n - 1) >> 1\n    for x in stride(from: step, through:\
    \ 0, by: 1) {\n        let y = x + x\n        result.insert(y, at: 0)\n    }\n\
    \    return result", "    precondition(n >= 0, \"n must be non-negative\")\n \
    \   var result = [Int]()\n    func addFirst(n: Int) {\n        result.append(n)\n\
    \    }\n    \n    if n%2 == 0 {\n        addFirst(3)\n    } else {\n        let\
    \ third = tri(n-1)\n        let first: Int = third[0] + third[1]\n        let\
    \ second: Int = third[0] + third[1] + third[2]\n        addFirst(first)\n    \
    \    addFirst(second)\n    }\n    result", "    var result = [Int]()\n    if n\
    \ == 1 {\n        result.append(1)\n        return result\n    }\n    \n    var\
    \ a = 1\n    var b = 1\n    if n % 2 == 0 {\n        result = result + [Int](n)\n\
    \    }\n    \n    for _ in 1..<n / 2 {\n        a = a + b\n        b = a + b\n\
    \    }\n    \n    if n % 2 == 1 {\n        a = a + b\n        b = a + b\n    }\n\
    \    \n    result = result + [a]\n    return result", "    var a = tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1)\n    if n % 2 == 1 {\n        a[n / 2] = a[n] + a[n\
    \ + 1]\n    }\n    return a", "    var result: [Int] = []\n    for i in 1...n\
    \ {\n        if i == 3 {\n            result.append(i)\n        } else {\n   \
    \         result.append(i + Int(Double(i) / Double(2)))\n        }\n    }\n  \
    \  return result", "    var result = [Int]()\n    result.append(3)\n    guard\
    \ n >= 2 else { return result }\n\n    if n % 2 == 0 {\n        result.append((1\
    \ + n) / 2)\n    } else {\n        var n1 = 1\n        var n2 = 2\n        var\
    \ n3 = n + 1\n\n        while n3 < n {\n            result.append(n1)\n      \
    \      (n1, n2, n3) = (n2, n3, n1 + n3)\n        }\n        result.append(n1)\n\
    \    }\n    return result", "\tvar result = [Int](repeating: 0, count: (n + 1)\
    \ * 2)\n\n\tfor i in 1 ..< n + 1 {\n\t\tresult[i] = i + 1\n\t\tif i % 2 == 1 {\n\
    \t\t\tresult[i * 2] += i\n\t\t}\n\t}\n\n\treturn result", "    switch n {\n  \
    \  case 0: return [3]\n    case 1: return [1, 3]\n    case 2: return [1, 1, 3]\n\
    \    default: return [1, n / 2, 1 + n / 2, 1 + 2 * n / 2, 1 + 3 * n / 2, 1 + 4\
    \ * n / 2, 1 + 5 * n / 2, 1 + 6 * n / 2, 1 + 7 * n / 2, 1 + 8 * n / 2, 1 + 9 *\
    \ n / 2, 1 + 10 * n / 2, 1 + 11 * n / 2, 1 + 12 * n / 2, 1 + 13 * n / 2, 1 + 14\
    \ * n / 2, 1 + 15 * n / 2, 1 + 16 * n / 2, 1 + 17 * n / 2, 1 + 18 * n / 2, 1 +\
    \ 19 * n / 2, 1 + 20 * n / 2, 1 + 21 * n / 2, 1 + 22 * n / 2, 1 + 23 * n / 2,\
    \ 1 + 24 * n / 2, 1 + 25 * n / 2, 1 + 26 * n / 2, 1 + 27 * n / 2, 1 + 28 * n /\
    \ 2, 1 + 29 * n / 2, 1 + 30 * n / 2, 1 + 31 * n / 2, 1 + 32 * n / 2, 1 + 33 *\
    \ n / 2, 1 + 34 * n / 2, 1 + 35 * n / 2, 1 + 36 * n / 2, 1 + 37 * n / 2, 1 + 38\
    \ * n / 2, 1 + 39 * n / 2, 1 + 40 * n / 2, 1 + 41 * n / 2, 1 + 42 * n / 2, 1 +\
    \ 43 * n / 2, 1 + 44 * n / 2, 1 + 45 * n / 2, 1 + 46 * n / 2, 1 + 47 * n / 2,\
    \ 1 + 48 * n / 2, 1 + 49 * n / 2, 1 + 50 * n / 2, 1 + 51 * n / 2, 1 + 52 * n /\
    \ 2, 1 + 53 * n / 2, 1 + 54 * n / 2, 1 + 55 * n / 2, 1 + 56 * n / 2, 1 + 57 *\
    \ n / 2, 1 + 58 * n / 2, 1 + 59 * n / 2, 1 + 60 * n / 2, 1 + 61 * n / 2, 1 + 62\
    \ * n / 2, 1 + 63 * n / 2, 1 + 64 * n / 2, 1 + 65 * n / 2, 1 + 66 * n / 2, 1 +\
    \ 67 * n / 2, 1 + 68 * n / 2, 1 + 69 * n / 2, 1 + 70 * n / 2, 1 + 71 * n / 2,\
    \ 1 + 72 * n / 2, 1 + 73 * n / 2, 1 + 74 * n / 2, 1 + 75 * n / 2, 1 + 76 * n /\
    \ 2, 1 + 77 * n / 2, 1 + 78 * n / 2, 1 + 79 * n / 2, 1 + 80 * n / 2, 1 + 81 *\
    \ n / 2, 1 + 82 * n / ", "    \n    if n == 1 || n == 2 {\n        return [1]\n\
    \    }\n    \n    var a: [Int] = []\n    for i in 0..<n {\n        a.append(1\
    \ + i/2)\n    }\n    \n    if n % 2 == 1 {\n        for _ in 0..<(n-2) {\n   \
    \         a.append(a[a.count - 1])\n        }\n    }\n    \n    return a", " \
    \   // write your code here\n    var arr : [Int] = []\n    var triArray = [Int]()\n\
    \    if n == 0 {\n        return arr\n    }\n\n    triArray.append(3)\n    triArray.append(1)\n\
    \    triArray.append(2)\n    triArray.append(1 + n / 2)\n\n    if n % 2 == 0 {\n\
    \        triArray.append(triArray[n-3])\n    }\n    return triArray", "    var\
    \ a: [Int] = []\n    var b: [Int] = [3]\n\n    var temp = 0\n    if n % 2 == 0\
    \ {\n        temp = 3\n    } else {\n        temp = 1\n    }\n\n    for _ in 0..<n+1\
    \ {\n        let temp1 = temp\n        a = temp1 + b\n        b = a\n    }\n \
    \   return a", "    var result = [Int](repeating: 0, count: n + 1)\n    result[0]\
    \ = 3\n    result[1] = 1 + n / 2\n    result[n] = tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\n    return result", "    var fibArray = [Int]()\n    var fib1: Int = 3\n\
    \    var fib2: Int = 3\n    var fib3: Int = 0\n    for _ in 0..<n {\n        fibArray.append(fib1)\n\
    \        fib1 = fib1 + fib2\n        fib2 = fib3 + 1\n        fib3 = fib2 + fib3\n\
    \    }\n    return fibArray", "    let result = [Int]()\n    for i in 1...n {\n\
    \        switch i % 2 {\n        case 0:\n            result.append(i)\n     \
    \   case 1:\n            result.append(result[i-1] + result[i-2] + result[i-3])\n\
    \        }\n    }\n    return result", "    // return your code\n    var a: [Int]\
    \ = []\n    switch n {\n    case 0:\n        return a\n    case 1:\n        return\
    \ [3] + a\n    default:\n        var firstTri: Int = 0\n        var secondTri:\
    \ Int = 0\n        var thirdTri: Int = 0\n        var firstTriAdded: Int = 0\n\
    \        var secondTriAdded: Int = 0\n        for _ in 0..<n {\n            if\
    \ n % 2 != 0 {\n                secondTri = secondTri + thirdTri\n           \
    \     thirdTri = secondTri + secondTriAdded\n                secondTriAdded =\
    \ firstTri + secondTriAdded\n            } else {\n                firstTri =\
    \ firstTri + secondTri\n                secondTri = firstTri + firstTriAdded\n\
    \                firstTriAdded = secondTri + firstTriAdded\n            }\n  \
    \          a += firstTri\n        }\n        return a\n    }", '    return sequence(n:
    n).filter { $0 % 2 == 0 }.prefix(n + 1)', "    if n < 2 {\n        return []\n\
    \    }\n    var res = [Int]()\n    res.append(3)\n    var tmp = [Int]()\n    for\
    \ _ in 0 ..< n {\n        tmp.append(0)\n    }\n    tmp[0] = 1\n    tmp[1] = 1\n\
    \    var j = 0\n    for _ in 0 ..< (n - 1) {\n        tmp[j] = (j + 1) / 2\n \
    \       j = (j + 1) % 2\n    }\n    j = j - 1\n    for _ in 0 ..< (n - 2) {\n\
    \        tmp[j + 1] = tmp[j] + tmp[j + 1]\n        j = (j + 1) % 2\n    }\n  \
    \  res.append(tmp[n])\n    return res", "    precondition(n >= 0)\n    var numbers\
    \ = [Int](repeating: 0, count: n + 1)\n    numbers[0] = 3\n    for number in 1...n\
    \ {\n        numbers[number] = numbers[number - 1] + numbers[number - 2] + numbers[number\
    \ + 1]\n    }\n    return numbers", "    var a = Int(3) + 1\n    var b = Int(1)\
    \ + Int(n) / 2\n    var c = Int(n) + 1\n    var result = [Int]()\n    for i in\
    \ 0..<n {\n        result.append(a)\n        a, b = b, c\n        c = a + b\n\
    \    }\n    return result", "    if n <= 1 {\n        return []\n    }\n    var\
    \ result = [Int]()\n    result.append(3)\n    for n > 2 {\n        let triResult\
    \ = tri(n - 1) + tri(n - 2) + tri(n + 1)\n        result.append(triResult)\n \
    \   }\n    return result", "    if (n == 0) {\n        return [0]\n    }\n   \
    \ let results: [Int] = [n]\n    for i in 1...n {\n        results.append(results[i-1]\
    \ + results[i-2])\n    }\n    return results", "\treturn _tri(n)", "    var result\
    \ = [1]\n    if n == 0 {\n        return result\n    }\n    for i = 3; i <= n;\
    \ i++ {\n        result.append(result[i-2] + result[i-1])\n    }\n    return result",
  '    return [Int]()', "    var arr = [Int]()\n    var a = 1\n    var b = 3\n   \
    \ if n % 2 == 0 {\n        while a < n / 2 {\n            arr.append(a)\n    \
    \        a = a + b\n            arr.append((a + b) / 2)\n            b = 3 + b\n\
    \        }\n        arr.append(n)\n        arr.append(a)\n    } else {\n     \
    \   while a < n / 2 {\n            arr.append(a)\n            a = a + b\n    \
    \        arr.append((a + b) / 2)\n            b = 3 + b\n        }\n        arr.append(b)\n\
    \        arr.append(n)\n    }\n    return arr", "    if n == 1 {\n        return\
    \ [3]\n    }\n    \n    if n % 2 == 0 {\n        return tri(n: n - 1) + tri(n:\
    \ n - 2) + tri(n: n + 1) \n    }\n    \n    return tri(n: n - 1) + tri(n: n -\
    \ 2) + tri(n: n + 1) + [n]", "    switch n {\n    case 0:\n        return []\n\
    \    case 1:\n        return [3]\n    case 2:\n        let a = tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\n        return a\n    }", "    var triSequence = [Int]()\n\
    \    if n <= 1 {\n        return triSequence\n    }\n    let third = n / 3\n \
    \   var first = 0\n    var second = 3\n    triSequence.append(first)\n    triSequence.append(second)\n\
    \    for i in 1...n {\n        let currentTri = tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\n        first = second\n        second = currentTri\n        triSequence.append(currentTri)\n\
    \    }\n    return triSequence", "    var a: [Int] = []\n    let limit: Int =\
    \ 3\n    guard n >= 0 else { return [] }\n    var temp: Int = 0\n    a.append(1)\n\
    \    while n != 0 {\n        temp += n/2\n        n = temp\n        if n % 2 ==\
    \ 0 {\n            temp += temp\n        } else {\n            temp += temp\n\
    \            temp += temp\n        }\n        a.append(temp)\n    }\n    return\
    \ a", '    return sequence(start: 0, end: n + 1)', "    var result = [Int]()\n\
    \    for _ in 0 ..< n {\n        result.insert(3, 1)\n        if n % 2 == 0 {\n\
    \            result.insert(3, n + 3 / 2)\n        } else {\n            result.insert(3,\
    \ n + 4)\n        }\n    }\n    return result", "    var results = [Int]()\n \
    \   if n == 1 {\n        results.append(1)\n        return results + [1]\n   \
    \ }\n    if n == 2 {\n        results.append(3)\n        return results + [1,\
    \ 1, 2]\n    }\n    let a1 = (tri(n - 1) + tri(n - 2))\n    let a2 = tri(n + 1)\
    \ // add last number in array\n    results.append(a1)\n    results.append(a2)\n\
    \    return results", "    var result: [Int] = []\n    var n2 = n % 2 == 0 ? n\
    \ : n + 1 // n is odd, add 1\n    var n3 = n2 % 2 == 0 ? n2 : n2 + 1\n    var\
    \ n4 = n3 % 2 == 0 ? n3 : n3 + 1\n    var n5 = n4 % 2 == 0 ? n4 : n4 + 1\n\n \
    \   result[0] = n\n    result[1] = n2 + n\n    result[2] = n3 + n2 + n\n    result[3]\
    \ = n4 + n3 + n2 + n\n    return result", '    return recur(n, 1, 1, 3, 1)', " \
    \   var result = [Int]()\n    let recurrence: Int\n    if n % 2 == 0 {\n     \
    \   recurrence = 3\n    } else {\n        recurrence = (1 + n) / 2\n    }\n  \
    \  for i in 1...n {\n        result.append(recurrence)\n        recurrence = recurrence\
    \ + recurrence + recurrence\n    }\n    return result", "    return (0...n).map{\n\
    \        Tribonacci.call($0)\n    }", "    var result = [1]\n    for _ in 2..<n\
    \ {\n        result *= 2\n        result.append(result[-1] + result[-2])\n   \
    \ }\n    return result.prefix(n + 1)", "    var sums = [Int]()\n    var twos =\
    \ [1]\n    for _ in 0..<n {\n        sums.append(twos[(sums.last ?? 0) + 1..<sums.count])\n\
    \        twos = twos + twos[..<sums.count] + [1]\n    }\n    return sums", " \
    \   var sum = 1\n    \n    for i in 1...n {\n        sum += (i + 1) / 2\n    }\n\
    \    \n    return Array(1...n).prefix(sum)", "    if (n == 0) || (n == 1) || (n\
    \ == 2) || (n % 2 == 0) || (n % 2 != 0) {\n        return [Int](repeatElement(0,\
    \ count: n + 1))\n    } else {\n        let result = tri(n - 1) + tri(n - 2) +\
    \ tri(n + 1)\n        return result + result[0..<n]\n    }", "    var result =\
    \ [Int]()\n    if n <= 3 {\n        for num in 1...n {\n            result.append(num)\n\
    \        }\n    } else {\n        for num in 1...n {\n            result.append((num\
    \ % 2 == 0) ? 1 : 0)\n        }\n    }\n    return result", "    if n < 3 {\n\
    \        return [Int]()\n    }\n\n    var result = [1]\n\n    var tri = 0\n\n\
    \    for _ in 0 ..< n / 2 {\n        tri += 1\n        result.append(tri)\n  \
    \  }\n\n    if n % 2 == 1 {\n        result.append(tri)\n    }\n    return result",
  "    let result = [Int]()\n    if n <= 1 {\n        result.append(1)\n        return\
    \ result\n    }\n    result.append(3)\n    if n % 2 == 0 {\n        result.append(tri(n\
    \ - 1) + tri(n - 2))\n    }\n    if n % 2 == 1 {\n        result.append(tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1))\n    }\n    return result", "    let result\
    \ = [Int](repeating: 0, count: (n + 1))\n    result[0] = 3\n    result[n] = 1\
    \ + n / 2\n    result[n] = result[n] + result[n-1]\n    return result", "    if\
    \ n < 2 {\n        return [Int]()\n    }\n    var arr = [Int]()\n    arr.append(1)\n\
    \    arr.append(n + 1)\n    for i in  2..<n {\n        arr.append(tri(i-1) + tri(i-2))\n\
    \    }\n    return arr", "    var result = [Int]()\n    if n <= 3 {\n        result\
    \ = [1]\n    } else {\n        for i in 1...n {\n            if i % 2 == 0 {\n\
    \                result.append(i + 1)\n            } else {\n                result.append(i\
    \ + i + 1)\n            }\n        }\n    }\n    return result", "    var numbers\
    \ = [Int]()\n    \n    if n%2 == 0 {\n        numbers.append(3)\n    }\n    else\
    \ {\n        let a = tri(n: n - 1)\n        let b = tri(n: n - 2)\n        numbers.append(a[0]+b[0])\n\
    \    }\n    \n    return numbers", "    var result = [0]\n\n    if n == 0 {\n\
    \        return result\n    }\n    if n == 1 {\n        result[0] = 1\n      \
    \  return result\n    }\n\n    // Add first three numbers in series and save them\
    \ in result\n    result[0] = result[0] + result[1] + result[2]\n    if n % 2 ==\
    \ 0 {\n        result[2] = result[2] + result[3]\n    }\n\n    // Add last two\
    \ numbers in series and save them in result\n    result[1] = result[0] + result[1]\n\
    \    if n % 2 == 0 {\n        result[3] = result[3] + result[4]\n    }\n\n   \
    \ return result", "    var res: [Int] = []\n    var a1 = 1\n    var a2 = 1\n \
    \   var b1 = 2\n    var b2 = 2\n    while n >= 0 {\n        if n & 1 == 0 {\n\
    \            a1 = a1 + b2\n            b1 = b1 + a1\n            a2 = a2 + b2\n\
    \            b2 = b2 + a2\n        }\n        n -= 1\n    }\n    res.reserve(n\
    \ + 1)\n    res.append(a1)\n    res.append(a2)\n    res.append(b1)\n    res.append(b2)\n\
    \    return res", "    switch n {\n    case 1: return [3]\n    case 2: return\
    \ [1, 3]\n    case 3: return [1, 3, 3]\n    default:\n        let prev1 = tri(n-1)\n\
    \        let prev2 = tri(n-2)\n        var sum = 0\n        for i in 0 ..< n {\n\
    \            sum = prev1[i] + prev2[i] + sum\n        }\n        return [sum]\
    \ + prev1 + prev2\n    }", "  var ans = [Int]()\n  if n < 3 {\n    return ans\n\
    \  }\n  ans.append(1)\n  ans.append(n / 2)\n  if n % 2 == 0 {\n    ans.append(n\
    \ / 2 + n/2 + 1)\n  } else {\n    ans.append(n)\n  }\n  return ans", "    // write\
    \ your code in Swift 4.2 or later\n    \n    var ret: [Int] = []\n    if n ==\
    \ 1 {\n        ret = [3]\n    } else if n == 2 {\n        ret = [1, 3]\n    }\
    \ else {\n        let n = n % 2\n        let f = n + n - 1\n        let g = n\
    \ + n + n\n        ret = [n, f] + ret\n        if n < g {\n            ret[0]\
    \ = ret[0] + ret[1] + ret[2] + ret[3]\n        }\n    }\n    return ret", "  \
    \  var result = [Int]()\n    let leftTri = tri(n - 2)\n    let rightTri = tri(n\
    \ - 1)\n    for element in leftTri {\n        result.append(element)\n    }\n\
    \    for element in rightTri {\n        result.append(element)\n    }\n    return\
    \ result", "    var res: [Int] = []\n    if n == 1 {\n        res.append(3)\n\
    \        return res\n    }\n    \n    if n % 2 == 0 {\n        res.append(tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1))\n    } else {\n        res.append(tri(n - 2)\
    \ + tri(n + 1))\n    }\n    return res", "    var fibonacci = [Int](count: n +\
    \ 1, repeatedValue: 0)\n    fibonacci[0] = 3\n    \n    for i in 1..<n {\n   \
    \     fibonacci[i+1] = fibonacci[i] + fibonacci[i-1]\n    }\n    return fibonacci",
  "    var sequence = [Int]()\n    var fibonacci = [1]\n    var last = 0\n\n    for\
    \ i in 1...n {\n        switch i % 2 {\n        case 0:\n            fibonacci.append(fibonacci[last]\
    \ + fibonacci[last-1])\n            last = 0\n        case 1:\n            last\
    \ = fibonacci[last] + fibonacci[last-1]\n        }\n\n        sequence.append(fibonacci[last])\n\
    \    }\n    return sequence", "    var arr = [Int]()\n    arr.reserve(1 + n)\n\
    \    arr[0] = 2\n    for i in  1...n {\n        arr.append(arr[i-2] + arr[i-1])\n\
    \    }\n    return arr", "    var result: [Int] = []\n    if n == 0 {\n      \
    \  return result;\n    }\n    var one = 1\n    var two = 2\n    var three = 3\n\
    \    var four = two\n    if n % 2 == 1 {\n        result.append(one)\n    }\n\
    \    for n in 1...(n + 1) {\n        result.append(one)\n        if n % 2 == 1\
    \ {\n            result.append(two)\n        }\n        if n % 3 == 1 {\n    \
    \        result.append(three)\n        }\n        if n % 5 == 1 {\n          \
    \  result.append(four)\n        }\n        one = two\n        two = three\n  \
    \      three = four\n        four = one + two + three + four\n    }\n    return\
    \ result"]
stop_tokens:
- "\n}"
