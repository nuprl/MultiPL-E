name: HumanEval_83_starts_one_ends
language: swift
prompt: "\n/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfunc starts_one_ends(n: Int) ->\
  \ Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n:\
  \ 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4)\
  \ == 1800)\nassert(starts_one_ends(n: 5) == 18000)"
completions: ["    // return n / 10 + (n % 10 == 1)\n    let total: Int = Int(log10(Double(n)))\
    \ + 1\n    return total / 10 + (total % 10 == 1)", "    var count = 0\n    for\
    \ start in 1...n {\n        for end in start+1...n {\n            if start ==\
    \ end {\n                continue\n            }\n            if !is_power_of_ten(start)\
    \ || !is_power_of_ten(end) {\n                continue\n            }\n      \
    \      if start > end {\n                start = start - 10\n                end\
    \ = end - 10\n            }\n            if start == 1 && end == n {\n       \
    \         count += 1\n            }\n            if start == n && end == n {\n\
    \                count += 1\n            }\n        }\n    }\n    return count",
  "    if n < 0 {\n        return -1\n    }\n    \n    guard n > 0 else {\n      \
    \  return 0\n    }\n    \n    let zero = Int(UInt64(1ULL) * UInt64(1ULL) * UInt64(1ULL))\n\
    \    \n    let start = zero + Int(n / Int64(Int64(UInt64(1ULL) + UInt64(n))))\n\
    \    let end = start + Int(n % Int64(Int64(UInt64(1ULL) + UInt64(n))))\n    \n\
    \    return end - start", "\tswitch n {\n\tcase 0:\n\t\treturn 1\n\tcase 1:\n\t\
    \treturn 0\n\tdefault:\n\t\tvar count = 0\n\t\tfor i := 1; i <= n; i++ {\n\t\t\
    \tif n == starts_one_ends(i) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\treturn count\n\
    \t}", "    var count = 0\n    for k in 1..n {\n        if n%k == 1 {\n       \
    \     count += 1\n        }\n    }\n    return count", "    // TODO: this would\
    \ be O(n^2) in the worst case\n    \n    // special case\n    if n == 1 {\n  \
    \      return 1\n    }\n    \n    // start case\n    if starts_ends(n, 1) {\n\
    \        return 1 + starts_ends(n-1, 1)\n    }\n    \n    // end case\n    if\
    \ starts_ends(n, -1) {\n        return 1 + starts_ends(n-1, -1)\n    }\n    \n\
    \    return 0", "    if n < 10 { return n }\n    if n < 100 { return 1 }\n   \
    \ if n < 1000 {\n        return 1 + (n - 9)*starts_one_ends(n/10)\n    }\n   \
    \ if n < 10000 {\n        return 1 + (n - 99)*starts_one_ends(n/100)\n    }\n\
    \    if n < 100000 {\n        return 1 + (n - 999)*starts_one_ends(n/1000)\n \
    \   }\n    if n < 1000000 {\n        return 1 + (n - 9999)*starts_one_ends(n/10000)\n\
    \    }\n    if n < 10000000 {\n        return 1 + (n - 99999)*starts_one_ends(n/100000)\n\
    \    }\n    if n < 100000000 {\n        return 1 + (n - 999999)*starts_one_ends(n/1000000)\n\
    \    }\n    if n < 1000000000 {\n        return 1 + (n - 9999999)*starts_one_ends(n/10000000)\n\
    \    }\n    if n < 10000000000 {\n        return 1 + (n - 99999999)*starts_one_ends(n/100000000)\n\
    \    }\n    if n < 100000000000 {\n        return 1 + (n - 99999999999)*starts_one_ends(n/1000000000)\n\
    \    }\n    if n < 1000000000000 {\n        return 1 + (n - 9999999999)*starts_one_ends(n/10000000000)\n\
    \    }\n    if n < 10000000000000 {\n        return 1 + (n - 9999999999999)*starts_one_ends(n/100000000000)\n\
    \    }\n    if n < 100000000000000 {\n        return 1 + (n - 999999999999981)*starts_one_ends(n/1000000000000)\n\
    \    }\n    if n < 1000000000000000 {\n        return 1 + (n - 9999999999999812)*starts_one_ends(n/10000000000000)\n\
    \    }\n    if n < 100000000000000000 {\n        return 1 + (n - 999999999999981231)*starts_one_ends(n/100000000000000)\n\
    \    }\n    return 1 + (n - 999999999999981234)*starts_one_ends(n/1000000000000000)",
  "    guard n >= 0 else {\n        return 0\n    }\n    return Int(log2(n)) - (n\
    \ % 2 == 0 ? 0 : 1)", "    guard n >= 0 else {\n        return 0\n    }\n    return\
    \ n / 10 + 1 + (n % 10 == 1)", "    var nZeros = n + 4\n    var count = 0\n\n\
    \    repeat {\n        let digit = nZeros % 10\n        guard digit == 1 else\
    \ {\n            count = count + 1\n            nZeros = nZeros / 10\n       \
    \     continue\n        }\n        nZeros = nZeros / 10\n    } while nZeros !=\
    \ 0\n\n    return count", "    guard n >= 1 else {\n        return -1\n    }\n\
    \    \n    var count = 0\n    var prev: Int = 0\n    for x in 1...n {\n      \
    \  if x == prev + 1 {\n            count++\n        }\n        prev = x\n    }\n\
    \    return count", "    var count = 0\n    var isStartOne = false\n    var isEndOne\
    \ = false\n\n    for i := 0; i < n; i++ {\n        isStartOne = !isStartOne\n\n\
    \        for j := i; j < n; j++ {\n            if isStartOne && !isEndOne {\n\
    \                if j != i && j % 10 == 1 {\n                    count = count\
    \ + 1\n                }\n            }\n            if !isStartOne && !isEndOne\
    \ {\n                if j != i && j % 10 == 0 {\n                    count = count\
    \ + 1\n                }\n            }\n\n            if isStartOne && !isEndOne\
    \ {\n                if j == i || j % 10 == 1 {\n                    isStartOne\
    \ = false\n                }\n            }\n            if !isStartOne && !isEndOne\
    \ {\n                if j == i || j % 10 == 0 {\n                    isEndOne\
    \ = true\n                }\n            }\n        }\n    }\n    return count",
  "    let ones = Int(floor(log2(n)))\n    var count = 0\n    \n    for i in 1..n-1\
    \ {\n        if ((n & (1 << i)) != 0) {\n            count += 1\n        }\n \
    \   }\n    \n    return count", "    var count = 0\n    for x in 1...n {\n   \
    \     if x == 1 || x%10 == 1 {\n            count += 1\n        }\n    }\n   \
    \ return count", "    var count = 0\n    let max = (1 << 32) - 1\n    for val\
    \ in 1..(max + 1) {\n        if val <= n {\n            if ((val & 1) == 0) {\n\
    \                count += ((val / 10) % 10) * val\n            }\n        }\n\
    \    }\n    return count", '    return count_substr_ats(n, 1, true)', "    if\
    \ n < 2 {\n        return 0\n    }\n    var count = 0\n    var n1 = n\n    var\
    \ n2 = n - 1\n    while n2 > 0 {\n        if n1 == 0 {\n            count += 1\n\
    \        }\n        if n1 == 1 {\n            break\n        }\n        count\
    \ += 1\n        n1 /= 10\n        n2 -= 1\n    }\n    return count", "    var\
    \ count = 0\n    for _ in 0..<n {\n        if number == 1 || number == 0 {\n \
    \           count += 1\n        }\n    }\n    return count", '    return n/10
    + n%10 == 0', "    // Count how many numbers are evenly divisible by 10\n    var\
    \ count_evenly_divisible_by_10 = 0\n    for num_i in 1...n {\n        if num_i\
    \ % 10 == 0 {\n            count_evenly_divisible_by_10 += 1\n        }\n    }\n\
    \    if count_evenly_divisible_by_10 == 0 {\n        return 0\n    }\n\n    //\
    \ Count the number of numbers that have a single digit\n    var count_single_digits\
    \ = 0\n    for num_i in 1...n {\n        if num_i == 1 || num_i == 0 {\n     \
    \       count_single_digits += 1\n        }\n    }\n    if count_single_digits\
    \ == 0 {\n        return 0\n    }\n\n    // Count the number of numbers that start\
    \ or end with 1\n    var count_starts_or_ends_with = 1\n    for num_i in 1...n\
    \ {\n        if num_i % 2 == 1 {\n            count_starts_or_ends_with += 1\n\
    \        }\n    }\n    return count_evenly_divisible_by_10 + count_single_digits\
    \ + count_starts_or_ends_with", "    var count = 0\n    for num in 1..n {\n  \
    \      if num == 1 && num%10 == 1 {\n            count += 1\n        }\n     \
    \   if num > 1 && num%10 == 0 {\n            count += 1\n        }\n    }\n  \
    \  return count", "    var count = 0\n    \n    for _ in 0..<n {\n        let\
    \ x = random1()\n        \n        if x == 1 {\n            count += 1\n     \
    \   }\n    }\n    \n    return count", "    let result = n\n    let mut count\
    \ = 0\n    let mut start = true\n    for _ in 0..(n-1){\n        if start {\n\
    \            start ^= false\n            count += 1\n        } else {\n      \
    \      start ^= true\n            count += 1\n        }\n    }\n    result", " \
    \   var count : Int = 0\n    for k in stride(from: n, to: 1, by: -1) {\n     \
    \   if n % k == 0 {\n            count += 1\n        }\n    }\n    return count",
  "    var i = 0\n    var count = 0\n    while i < n {\n        if i % 10 == 1 {\n\
    \            count += 1\n        }\n        i += 1\n    }\n    return count",
  "    var count = 0\n    var x = 1\n    while x < n {\n        count += 1\n     \
    \   if x == n {\n            break\n        }\n        x += 1\n    }\n    return\
    \ count", "    // We will iterate over all the integers from 10 to n and count\n\
    \    // the number of such integers that start or end with 1.\n    var count =\
    \ 0\n    for number in 10...n {\n        // If the number is divisible by 10 and\
    \ is odd, then it's a\n        // positive integer that starts or ends with 1.\n\
    \        if number % 10 == 1 && number % 2 == 0 {\n            count += 1\n  \
    \      }\n    }\n    return count", "    if n <= 0 { return 0 }\n    var count\
    \ = 0\n    var pos = 0\n    while n >= 10 {\n        n /= 10\n        count +=\
    \ 1\n        pos += 1\n    }\n    for pos < n {\n        n /= 10\n        count\
    \ += 1\n    }\n    return count", "    var result = 0\n    for num in 1...n {\n\
    \        if num == 1 && num <= n {\n            result += num\n        }\n   \
    \     if num == n && num > 1 && num >= n {\n            result += num\n      \
    \  }\n    }\n    return result", "    var count = 0\n    for i in 1...n {\n  \
    \      if i % 10 == 1 {\n            count += 1\n        } else if i % 10 == 0\
    \ {\n            count += 2\n        } else {\n            count += 0\n      \
    \  }\n    }\n    return count", "  let mut count = 0;\n  for i1 = 0; i1 < n; i1\
    \ += 1 {\n    for i2 = i1 + 1; i2 < n; i2 += 1 {\n      if i1%10 == i2/10 {\n\
    \        if i1%10 != 0 {\n          count += 1;\n        } else {\n          count\
    \ += 1;\n        }\n      }\n    }\n  }\n  return count;", "    let zeroes = pow(10,\
    \ n) - 1\n    var count = 0\n    for _ in 1...n {\n        count += zeroes % 10\
    \ != 0\n        zeroes = zeroes / 10\n    }\n    return count", "    // The longest\
    \ sequence of consecutive 1's is the number of\n    // 1's minus the number of\
    \ zeros (since 0 is a sequence of 1\n    // followed by a zero).\n    var consecutiveZeros\
    \ = 0\n    for x in 1..<n {\n        if x % 10 == 0 {\n            consecutiveZeros\
    \ = 0\n        }\n        if x % 10 == 1 && consecutiveZeros > 0 {\n         \
    \   return consecutiveZeros - 1\n        }\n        if x % 10 == 1 {\n       \
    \     consecutiveZeros += 1\n        }\n    }\n    return n", "  // Add 1 to avoid\
    \ negative n.\n  if n == 1{\n    return 1\n  }\n  return starts_one_ends(n / 10)\
    \ + n % 10", "    if n < 1 {\n        return 0\n    }\n\n    var count = 0\n\n\
    \    for i := 1; i <= n; i++ {\n        if i % 10 == 1 {\n            count++\n\
    \        }\n\n        if i > n {\n            break\n        }\n\n        if i\
    \ % 10 == 0 {\n            break\n        }\n    }\n\n    return count", "   \
    \ switch n {\n    case 0:\n        return 1\n    case 1:\n        return 0\n \
    \   case 2:\n        return 0\n    case 3:\n        return 2\n    case 4:\n  \
    \      return 3\n    case 5:\n        return 4\n    case 6:\n        return 4\n\
    \    case 7:\n        return 5\n    case 8:\n        return 5\n    case 9:\n \
    \       return 6\n    case 10:\n        return 6\n    case 11:\n        return\
    \ 7\n    case 12:\n        return 7\n    case 13:\n        return 8\n    case\
    \ 14:\n        return 8\n    case 15:\n        return 8\n    case 16:\n      \
    \  return 9\n    case 17:\n        return 9\n    case 18:\n        return 10\n\
    \    case 19:\n        return 10\n    case 20:\n        return 10\n    case 21:\n\
    \        return 11\n    case 22:\n        return 11\n    case 23:\n        return\
    \ 12\n    case 24:\n        return 12\n    case 25:\n        return 12\n    case\
    \ 26:\n        return 13\n    case 27:\n        return 13\n    case 28:\n    \
    \    return 14\n    case 29:\n        return 14\n    case 30:\n        return\
    \ 15\n    case 31:\n        return 15\n    case 32:\n        return 16\n    case\
    \ 33:\n        return 16\n    case 34:\n        return 17\n    case 35:\n    \
    \    return 17\n    case 36:\n        return 18\n    case 37:\n        return\
    \ 18\n    case 38:\n        return 19\n    case 39:\n        return 19\n    case\
    \ 40:\n        return 20\n    case 41:\n        return 20\n    case 42:\n    \
    \    return 21\n    case 43:\n        return 21\n    case 44:\n        return\
    \ 22\n    case 45:\n        return 22\n    case 46:\n        return 23\n    case\
    \ 47:\n        return 23\n    case 48:\n        return 24\n    case 49:\n    \
    \    return 24\n    case 50:\n        return 25\n    case 51:\n        return\
    \ 25\n    case 52:\n        return 26\n    case 53:\n        return 26\n    case\
    \ 54:\n        return 27\n    case 55:\n        return 27\n    case 56:\n    \
    \    return 28\n    case 57:\n        return 28\n    case 58:\n        return\
    \ 29\n    case 59:\n        return 29\n    case 60:\n        return 30\n    case\
    \ 61:\n        return 30\n    case 62:\n        return 31\n    case 63:\n    \
    \    return 31\n    case 64:\n        return 32\n    case 65:\n        return\
    \ 32\n    case 66:\n        return 33\n    case 67:\n        return 33\n    case\
    \ 68:\n        return 34\n    case 69:\n        return 34\n    case 70:\n    \
    \    return 35\n    case 71:\n        return 35\n    case 72:\n        return\
    \ 36\n    case 73:\n        return 36\n    case 74:\n        return 37\n    case\
    \ 75:\n        return 37\n    case 76:\n        return ", "    if n <= 1 {\n \
    \       return n\n    }\n\n    var count = 1\n    var digits = 1\n    for i :=\
    \ 0; i < n; i++ {\n        if digits == 1 {\n            digits++\n          \
    \  continue\n        }\n        digits += 1\n        if digits == 10 {\n     \
    \       count = 0\n            digits = 1\n        }\n    }\n    return count",
  "    var count = 0\n\n    for _ in self.prefix(n).filter({ $0 != 1 }) {\n      \
    \  count += 1\n    }\n\n    return count", '    return binarySearch(n, "000000001",
    0, 7, false, false)', "    let mut counts = vec![1usize; n]\n    if n<0 { return\
    \ 0 }\n    for i in (1..n).rev() {\n        if counts.iter().any(|&_| i == _)\
    \ {\n            counts[i] = 0\n        }\n        if i < n {\n            counts[i]\
    \ += 1\n        }\n        if i == 1 {\n            counts[i] += 1\n        }\n\
    \    }\n    counts.iter().count()", "    var count = 0\n    var current: Int\n\
    \    var start = 1\n    while n > 0 {\n        current = n % 10\n        if current\
    \ == 1 || current == 9 {\n            if start == 0 {\n                count +=\
    \ 1\n            }\n            start = 1\n        } else {\n            start\
    \ = 0\n        }\n        n = n / 10\n    }\n    if start != 0 {\n        count\
    \ += 1\n    }\n    return count", "    var i = 0\n    var count = 0\n    for _\
    \ in 1..n {\n        i += 1\n        if i % 1000 == 0 {\n            println(i)\n\
    \        }\n        if i >= n {\n            break\n        }\n        count +=\
    \ i%10 != 0\n    }\n    return count", "    var count = 0\n    if n >= 10000 {\n\
    \        // 10k <= n <= 10000\n        for start in 0..10000 {\n            if\
    \ starts_end_with(start, n) { count += 1; }\n        }\n    } else {\n       \
    \ // n >= 10000\n        for start in 1...n {\n            if starts_end_with(start,\
    \ n) { count += 1; }\n        }\n    }\n    return count", "    var count = 0\n\
    \    while n >= 10 {\n        count += n % 10 == 0\n        n = n / 10\n    }\n\
    \    return count", "    let count = starts_one_ends_count(n)\n    return (count\
    \ > 0) ? (n - count) : 0", "  // [begin, end) pairs.\n  var pairs = [Int]()\n\n\
    \  for i := 1; i <= n/2; i++ {\n    var b = i\n    var e = i\n    var m\n    while\
    \ b > 0 {\n      m = b / 10\n      e = b\n      if e == 0 {\n        pairs.append(1)\n\
    \        break\n      }\n      if m == 1 && e < n {\n        // If e is too large,\
    \ only count the previous digit.\n        pairs.append(0)\n        break\n   \
    \   }\n      pairs.append(pairs[e] * (m-1)+m)\n      b = e / 10\n    }\n  }\n\n\
    \  return len(pairs)", "    var num = 1\n    var count = 0\n    while num < n\
    \ {\n        if n % num == 0 {\n            count += 1\n        }\n        num\
    \ *= 10\n    }\n    return count", "    if n < 1 {\n        return 0\n    }\n\
    \    var count = 0\n    for i in 1..n {\n        if i%10 == 1 {\n            count++\n\
    \        }\n    }\n    return count", "    let count = (n.max(0) / 9).floor()\n\
    \    return (9 - count).min(count)", "    let mut count: Int = 0\n    for _ in\
    \ 1..n {\n        if n % 10 == 1 {\n            count += 1\n        }\n      \
    \  n /= 10\n    }\n    return count", '    return Int(ceil(log2(n)))', "    var\
    \ count = 0\n    var last = 1\n    var last2 = 1\n    while n > 0 {\n        var\
    \ digit = n % 10\n        if digit != 1 {\n            count = count + 1\n   \
    \     }\n        if digit == 1 {\n            count = 0\n            last = 1\n\
    \            last2 = 1\n            last = digit + 1\n        } else {\n     \
    \       last2 = digit\n            last = last2 + last\n        }\n        n =\
    \ n / 10\n    }\n    return count", "    var count = 0\n    let maxPow10 = 100\n\
    \    for pow10 in 1..maxPow10 {\n        count = count*pow10 + findCount(&n, pow10)\n\
    \        if n >= pow10 {\n            break\n        }\n    }\n    return count",
  "    // TODO: add test\n    return 0", "\tswitch {\n\tcase n <= 0:\n\t\treturn 0\n\
    \tcase n < 10:\n\t\treturn 1\n\tcase n > 10 and starts_one_ends(n - 1) == n:\n\
    \t\treturn starts_one_ends(n - 1)\n\tdefault:\n\t\tn -= 9\n\t\treturn n + starts_one_ends(n)\n\
    \t}", "    var count = 0\n    for number in 1...n {\n        if ((number - 1)\
    \ % 10 != 0) {\n            count += 1\n        }\n        if number % 10 == 1\
    \ {\n            count += 1\n        }\n    }\n    return count", "    // We are\
    \ looking for sequences of 1's and 0's which begin or end with 1\n    // We want\
    \ to exclude sequences of zero's, as this would have only 1 element.\n    let\
    \ zero = 0\n    var count = 0\n\n    while n > zero {\n        if n % 10 == 1\
    \ {\n            count += 1\n            if n == 1 {\n                break\n\
    \            }\n        }\n\n        if n % 10 == 0 {\n            count -= 1\n\
    \            if n == 0 {\n                break\n            }\n        }\n\n\
    \        n /= 10\n    }\n\n    return count", "    // The first n 1's is just\
    \ to count the leading ones\n    var count = 0\n    \n    for i in 1 ... n {\n\
    \        count = count*10 + Int(i) == 1\n    }\n    \n    return count", "   \
    \ // The solution is simple, just do n iterations.\n    var count = 0\n    for\
    \ _ in 0..<n {\n        if n % 10 == 1 {\n            if n == 1 || n == 0 {\n\
    \                count++\n            }\n        } else {\n            count++\n\
    \        }\n        n /= 10\n    }\n    return count", "    // Special case\n\
    \    if n < 1 || n >= 1000 {\n        return 0\n    }\n    // Divide by 10 to\
    \ get the number of digits to the left of n\n    let digits_to_left = n / 10\n\
    \    // Calculate the number of 1s in each of the digits\n    let digits_with_twos\
    \ = digits_to_left.powi(2) / 2\n    // Take the mod of the result and add one\
    \ to the result\n    return (digits_to_left - digits_with_twos).mod", "    if\
    \ n < 0 {\n        return 0\n    }\n\n    var i = 0\n    var count = 0\n    while\
    \ i < n {\n        if i >= n {\n            break\n        }\n        let x =\
    \ Int(i) % 1000000007\n        if x == 1 {\n            count += 1\n        }\n\
    \        i += 1\n    }\n\n    return count", "  var count = 0\n  var i = n - 1\n\
    \  while i >= 0 {\n    if n % 10 == 1 {\n      count = count + 1\n    }\n    i\
    \ /= 10\n  }\n  return count", "    if n < 2 {\n        return n\n    }\n    var\
    \ sum = 0\n    for x := 1; x <= n; x++ {\n        if n == x {\n            sum++\n\
    \        }\n        if n == x-1 {\n            sum++\n        }\n    }\n    return\
    \ sum", "    let start = n.truncatingRemainder(dividingBy: 10).magnitude\n   \
    \ let end = start.adding(1)\n    return n - end - start + 1", "    \n    // Initialize\
    \ result to zero.\n    var result = 0\n    \n    // If the number is even, result\
    \ is 2.\n    if n % 2 == 0 {\n        result = 2\n    }\n    \n    // Else, if\
    \ the number is odd, result is 1.\n    else {\n        result = 1\n    }\n   \
    \ \n    // Recur on the even number to find n-1 evens.\n    for evenIndex in 0..<n\
    \ / 2 {\n        if n % 2 == 1 {\n            result += starts_one_ends(n / 2\
    \ - 1)\n        }\n    }\n    \n    // Recur on the odd number to find n-1 odds.\n\
    \    for oddIndex in 0..<n / 2 {\n        if n % 2 == 0 {\n            result\
    \ += starts_one_ends(n / 2 + 1)\n        }\n    }\n    \n    return result", " \
    \   var count = 0\n    var i = n - 1\n    var starts = 1\n    var ends = 1\n\n\
    \    for ; (i >= 0); i-- {\n        var x = 1\n        if i >= 1 {\n         \
    \   x = 1\n        }\n        if x != ends && x != starts {\n            count++\n\
    \        }\n        starts = x\n        ends = x\n    }\n\n    return count",
  "\t// Special case: if the input is a power of 2, then any number that starts\n\t\
    // with 1 or ends with 1 is also a power of 2.\n\tif n == 1 {\n\t\treturn 1\n\t\
    }\n\t// If input is a power of 2, then we know that any number that starts or\
    \ ends with 1 is also a power of 2.\n\tif n&1 == 1 {\n\t\treturn 1\n\t}\n\t//\
    \ We know that any number that ends with 1 is also a power of 2, since if any\
    \ number ends with 1,\n\t// then it must have ended in a power of 2.\n\tlet pow2\
    \ = n >> 1\n\treturn 1 + ends_one_ends(pow2)", "    // Start and end with 1\n\
    \    return (n / 10).bit_shl(1).xor((n / 100).bit_shl(1).xor(n / 1000).bit_shl(1))",
  "    // Special case: one digit number.\n    if n < 10 {\n        return n\n   \
    \ }\n\n    // Special case: starting or ending with a 1.\n    if n % 10 == 1 &&\
    \ n % 100 != 11 {\n        return n\n    }\n\n    // Special case: starting or\
    \ ending with a 0.\n    if n % 10 == 0 && (n % 100 != 10 || n % 100 == 1) {\n\
    \        return n\n    }\n\n    var sum: Int = 0\n    var digit: Int = n % 10\n\
    \    var rest = n - digit\n\n    // Digit count. Loop over rest of digits in the\
    \ number.\n    while rest > 0 {\n        sum += rest%10\n        rest = rest/10\n\
    \    }\n\n    // Add last digit to count if number ends with it.\n    if digit\
    \ == 1 {\n        sum += digit\n    }\n    return sum", "    var count = 0\n \
    \   for (i = 0, i <= n; i += 1, i += 1) {\n        if i % 100 == 0 {\n       \
    \     if i >= 100 {\n                count += starts_one_ends(i)\n           \
    \ }\n        } else if i % 10 == 0 {\n            count += 1\n        }\n    }\n\
    \    return count", "    if n < 1 {\n        return 0\n    }\n    return starts_one_ends(n-1)\
    \ + ends_one_starts(n-1)", "    // Special cases.\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n\n    let base = 10\n    var ndigits = n\n    var result =\
    \ 1\n    \n    // While there are still digits to be considered.\n    while ndigits\
    \ > 0 {\n        // If there are still digits to be considered, divide into the\n\
    \        // remaining digits and count the results.\n        if ndigits >= base\
    \ {\n            ndigits /= base\n            result += ndigits == 1\n       \
    \ } else {\n            ndigits /= 10\n        }\n    }\n    return result", " \
    \   var count = 0\n    \n    if n == 0 || n == 1 {\n        return count\n   \
    \ }\n    \n    for d in 1...n {\n        if n % d == 0 {\n            count +=\
    \ 1\n        }\n    }\n    return count", "    var count = 0\n    for d in 0 ...\
    \ n-1 {\n        if ((d > 0) == (n % 10 > 0) == (n % 10 < 9)) {\n            count++\n\
    \        }\n    }\n    return count", '    return starts_one_ends_helper(n - 1)',
  "\tif n <= 0 {\n\t\treturn 0\n\t}\n\tresult := 0\n\tfor i := n; i > 0; i /= 10 {\n\
    \t\tresult++\n\t\tif i == 1 {\n\t\t\treturn result\n\t\t}\n\t}\n\treturn -1",
  "    switch n {\n    case 0:\n        return 0\n    case 1:\n        return 1\n\
    \    default:\n        return 1 + count((n - 1) / starts_one_ends(n / starts_one_ends(n)))\n\
    \    }", "    // return 0 // uncomment this line for testing\n\n    let limit\
    \ = pow(10, n)\n    var count = 0\n    for number in 1...limit {\n        if number\
    \ / power(10, n) == 1 {\n            count += 1\n        }\n    }\n    return\
    \ count", "    var count = 0\n    var x = 1\n    for _ in 0..<n {\n        if\
    \ x == 1 {\n            count += 1\n        }\n        x /= 10\n    }\n    return\
    \ count", "    var count = 0\n    for x in 1...n {\n        if x != 1 && n % x\
    \ == 0 {\n            count += 1\n        }\n    }\n    return count", "    func\
    \ counts(start: Int, end: Int, count: Int) -> Int {\n        if start == end {\n\
    \            return count\n        }\n\n        if start > end {\n           \
    \ return counts(start, n-1, count) + 1\n        }\n\n        return counts(n-1,\
    \ end, count) + 1\n    }\n\n    return counts(0, n-1, 0)", "    let maxInt: Int\
    \ = 9 * n - 2\n    var starts: Int = 1\n    var ends: Int = 0\n    var last: Int\
    \ = 0\n    repeat {\n        last++\n        if last >= maxInt {\n           \
    \ break\n        }\n        last = last / 10\n        if last >= 1 && last < n\
    \ {\n            starts++\n        }\n        if last >= n - 1 && last < n {\n\
    \            ends++\n        }\n    } while last < n\n    return starts + ends",
  "    var count = 0\n    var n1 = n\n    while n > 0 {\n        n1 = n1 * (10 + 1)\
    \ + (n - 1)\n        n = n / 10\n        count++\n    }\n    return count", " \
    \   let digits = String(n - 1).utf8\n    var count = 0\n    for digit in digits\
    \ {\n        if digit == \"1\" {\n            count += 1\n        }\n    }\n \
    \   return count", "    switch n {\n    case 0:\n        return 2\n    case 1:\n\
    \        return 1\n    case 2:\n        return 2\n    default:\n        let (starts,\
    \ ends) = starts_ends(n)\n        return starts + ends + 1\n    }", "    // The\
    \ number we are testing starts with 1 so we only need to consider odd numbers\n\
    \    // We will also have to ignore all numbers greater than the square root of\
    \ the number we are testing\n    // to handle the case where n == 1\n    var count\
    \ = 0\n    for number in 1...(Int(pow(Double(n), 0.5))), {\n        if n % number\
    \ == 0 {\n            count += 1\n        }\n    }\n\n    return count", "  var\
    \ ndigits = 1\n  var count = 0\n  while n > 0 {\n    if n & 1 == 1 {\n      count\
    \ += 1\n    }\n    n >>= 1\n    ndigits += 1\n  }\n  return ndigits - count",
  "    var count = 0\n    for number in 1...n {\n        if number == 1 {\n      \
    \      count += 1\n            if number == n {\n                return count\n\
    \            }\n            continue\n        }\n        count += (number % 10\
    \ == 1) * (number / 10 == n) * (number / 10 == 1)\n    }\n    return count", " \
    \   let start = 10\n    let end = n\n    var count = 1\n    for i = start * end;\
    \ i != 0; i /= end {\n        if i % end == 0 {\n            count += 1\n    \
    \    }\n    }\n    return count", "\tswitch {\n\tcase n < 0:\n\t\tpanic(\"Negative\
    \ n is not allowed.\")\n\tcase n == 0 || n == 1:\n\t\treturn 0\n\tcase n % 2 ==\
    \ 0: // even\n\t\treturn starts_one_ends(n/2) + starts_one_ends(n-1)\n\tdefault:\
    \ // odd\n\t\treturn starts_one_ends(n/2) + starts_one_ends(n-1) + starts_one_ends(n-2)\
    \ + starts_one_ends(n-3)\n\t}", "    guard n >= 0 else {\n        return 0\n \
    \   }\n    return Int(pow(10, Double(n).truncatingRemainder(&NSDecimalDigits(10))))\
    \ + 1", "    // n is positive\n    if n <= 0 {\n        return 0\n    }\n\n  \
    \  // n is odd\n    if n % 2 == 1 {\n        return starts_one_ends(n+1) + 1\n\
    \    }\n\n    // n is even\n    if n % 2 == 0 {\n        return starts_one_ends(n/2)\
    \ + 1\n    }\n\n    // n == 1\n    return 0", "    var count = 0\n    for d in\
    \ 1...n {\n        if n % d == 0 {\n            count += 1\n        }\n    }\n\
    \    return count", "    guard n >= 0 else {\n        return 0\n    }\n\n    var\
    \ count = 0\n    let x = n\n\n    let one = 1\n    while x > 0 {\n        x -=\
    \ one\n        count += 1\n    }\n\n    return count", "  var count = 0\n  for\
    \ i in 1...n {\n    if i / i == 1 || i / i == 0 {\n      count += 1\n    }\n \
    \ }\n  return count", "    var sum = 0\n    while n >= 0 {\n        sum += (n\
    \ / 10_0) - 1\n        n %= 10_0\n    }\n    return sum", "    let upperBound\
    \ = pow(10, n)\n    return sum(\n        range(1...upperBound)\n            .filter\
    \ { $0 % 10 == 1 }\n            .map { $0 % 10 }\n            .count\n    )",
  "    var start = 0\n    var count = 0\n    for digit in 1...n {\n        if digit\
    \ == 1 {\n            count += 1\n        }\n        if start == 0 {\n       \
    \     if digit == 0 {\n                start = digit\n            } else {\n \
    \               count = 0\n                start = digit\n            }\n    \
    \    } else {\n            if digit == 0 {\n                count = 0\n      \
    \          start = digit\n            } else {\n                count += 1\n \
    \           }\n        }\n    }\n    return count", "    var count = 0\n    for\
    \ _ in 1..<n {\n        if n % 10 == 1 {\n            count += 1\n        }\n\
    \        n /= 10\n    }\n    return count", "    var starts = 0\n    var ends\
    \ = 0\n    for x in 1...n {\n        if x % 10 == 1 {\n            starts += 1\n\
    \        } else {\n            ends += 1\n        }\n    }\n    return starts\
    \ + ends", "    if n <= 0 {\n        return 0\n    }\n    var cnt = 0\n    for\
    \ cur in 1...n {\n        if cur == 1 || cur == n {\n            cnt++\n     \
    \   }\n        if cur == n {\n            break\n        }\n    }\n    return\
    \ cnt", "    if n == 1 {\n        return n\n    }\n    if n == 2 {\n        return\
    \ 1\n    }\n    \n    if n == 3 {\n        return 1\n    }\n    \n    if n % 2\
    \ == 0 {\n        var count = 0\n        \n        for index in 1...n / 2 {\n\
    \            if n % 2 == 0 {\n                count += 1\n            }\n    \
    \        \n            n /= 2\n        }\n        \n        return count\n   \
    \ }\n    \n    var count = 0\n    \n    for index in 1...n {\n        if index\
    \ == 1 || index == n - 1 {\n            count += 1\n        }\n        n -= 1\n\
    \    }\n    \n    return count", "    // precondition:\n    assert(n >= 0)\n \
    \   \n    var i = 0\n    var j = n\n    var s = 0\n    while j > 0 {\n       \
    \ if j % 2 == 0 {\n            s += 1\n            i ++\n        }\n        j\
    \ /= 2\n    }\n    return s", "    var count = 0\n    for x in 1...n {\n     \
    \   if x % 10 == 1 {\n            count += 1\n        } else {\n            break\n\
    \        }\n    }\n    return count", "    // The starting digits will be 0, 1,\
    \ ... n-2, n-3, ... n-k\n    // The ending digits will be k+n-k+1, k+n-k+2, ...\
    \ n-k+n-1, n+k+n-1, ... n+k+n\n    // The sum of the two will be n + k + n, which\
    \ is n(n+1)/2\n    let k = n - 1\n    let sum = (n * k + n) / 2\n    var count\
    \ = 0\n    for var i = k; i <= sum; i += k {\n        count += 1\n        if i\
    \ >= k+n {\n            break\n        }\n    }\n    return count", "    var count\
    \ = 0\n    for i := 1; i <= n / 10; i++ {\n        if n%i == 0 && i > 1 {\n  \
    \          count++\n        }\n    }\n    return count", "    let ones = Set(0..<n)\n\
    \    guard n > 0 else { return 0 }\n    var count = 0\n    var i = ones\n    while\
    \ i != nil {\n        let head = i.min()\n        let tail = i.max()\n       \
    \ count = count + (head == tail ? 0 : 1)\n        i.subtract(tail)\n    }\n  \
    \  return count", "    n -= 1\n    return (n * n * (n - 1)) / 2", "    var count\
    \ = 0\n    var d = 1\n    while n / d > 0 {\n        n /= d\n        count +=\
    \ 1\n    }\n    if n < 1 {\n        return count\n    }\n    d = 1\n    while\
    \ n % d == 0 {\n        n /= d\n    }\n    return count", "    var count = 0\n\
    \    var end = 0\n    var start = 1\n    while n != 0 {\n        if n%10 == 1\
    \ {\n            if end == 0 {\n                count = n\n            }\n   \
    \         end = end + 1\n        }\n        start = start + 1\n        n = n /\
    \ 10\n    }\n    if end == 0 {\n        count = start\n    }\n    return count",
  "    // start or end with 1 is n\n    if n%10 == 1 {\n        return Int(n/10)\n\
    \    } else {\n        return Int(n/10) + starts_one_ends(n%10)\n    }", "   \
    \ var count: Int = 0\n    switch n {\n    case 0:\n        return count\n    case\
    \ 1:\n        return count\n    case 2:\n        return count\n    default:\n\
    \        for i = 1; i < n; i++ {\n            if starts_one_ends(i) == 1 {\n \
    \               count += 1\n            } else {\n                break\n    \
    \        }\n        }\n    }\n    return count", "    var count = 0\n    var isEnd:\
    \ Bool = false\n    var last: Int = 0\n    while n > 0 {\n        if n < 10 {\n\
    \            last = last * 10 + n\n        } else {\n            last = n / 10\n\
    \            n %= 10\n            if n == 1 {\n                isEnd = true\n\
    \            }\n        }\n        count += 1\n        if isEnd {\n          \
    \  count += 1\n            break\n        }\n    }\n    return count", "    var\
    \ count = 0\n    for k in 1..<n {\n        let is_start = (n - k) % 9 == 0\n \
    \       if is_start {\n            count += 1\n        }\n    }\n    return count",
  "\tswitch {\n\tcase n < 10:\n\t\treturn n\n\tcase n > 100:\n\t\treturn 0\n\tdefault:\n\
    \t\tvar n int\n\t\tn = n%100\n\t\tn /= 10\n\t\tif n == 1 {\n\t\t\treturn 1\n\t\
    \t} else {\n\t\t\treturn starts_one_ends(n) + 1\n\t\t}\n\t}", '    return (math.Pow(float64(n),
    0.5) - math.Pow(float64(n), 0.5))', "    if n <= 0 {\n        return 0\n    }\n\
    \n    var count = 0\n    var last = 0\n    var current = 0\n    var num = 0\n\
    \    var lastStart = 0\n    var lastEnd = 0\n\n    for num < n {\n        current\
    \ = num\n        num++\n        if current == 1 {\n            if lastEnd == 0\
    \ {\n                lastStart = last\n            } else {\n                lastEnd\
    \ = last\n            }\n            last = 1\n        } else if current == 0\
    \ {\n            last = 1\n        } else {\n            last = 0\n        }\n\
    \        count += 1\n    }\n\n    return count", "    guard n > 0 else {\n   \
    \     return 0\n    }\n    var count = 0\n    for _ in 0..<n {\n        let c\
    \ = n % 10\n        if c == 1 {\n            if n < 100 {\n                count\
    \ += 1\n            }\n        } else {\n            if c == 2 {\n           \
    \     count += 1\n            }\n        }\n        n /= 10\n    }\n    return\
    \ count", "\t// Write your code here.\n\treturn 0", "    if n < 10 || n > 100\
    \ {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    var\
    \ count = starts_one_ends(n-1)\n    if count > 0 {\n        return count + 1\n\
    \    }\n    count = 0\n    for i = 0; i <= n/2; i += 2 {\n        if n%i == 0\
    \ {\n            count += 1\n        }\n    }\n    return count", "    var sum\
    \ = 0\n    for x in\n        1..n{\n            if x == n {\n                sum\
    \ += 1\n            } else {\n                sum += 1\n                if x ==\
    \ n-1 {\n                    sum -= 1\n                }\n            }\n    \
    \    }\n    return sum", "    if n < 1 {\n        return 0\n    }\n    \n    //\
    \ Get count of n-digit positive integers starting with 1\n    var count = 0\n\
    \    var nDigits = 1\n    for ; nDigits <= n; nDigits++ {\n        count += (n\
    \ - nDigits) / nDigits\n    }\n    \n    return count", "    var cnt = 0\n   \
    \ for i in 0..n {\n        if ((n % (10*i+1)) == 1) {\n            cnt = cnt +\
    \ 1\n        }\n    }\n    return cnt", "    guard n >= 1 else {\n        return\
    \ 0\n    }\n    return (n * 10).powi(n - 1) / 10", "  var count = 0\n  for digit\
    \ in 1...n {\n    if digit(n) == 1 {\n      count += 1\n    }\n  }\n  return count",
  "    // A positive integer is a start or end with 1 iff the sum of the digits\n\
    \    // is odd or if the sum of digits is even\n    if n <= 0 {\n        return\
    \ 0\n    }\n    var sumOfDigits = 0\n    for digitIndex := 0; digitIndex < n;\
    \ digitIndex++ {\n        if n >= 10 || n % 10 != 0 {\n            sumOfDigits\
    \ += digitIndex\n        }\n    }\n    if sumOfDigits == 0 || sumOfDigits % 2\
    \ == 1 {\n        return 0\n    }\n    return Int(sumOfDigits / 2)", "    if n\
    \ < 0 {\n        throwSyntaxError(tokError(\"starts_one_ends: negative number\"\
    , nil), n)\n    }\n    switch n {\n    case 0:\n        return 1\n    case 1:\n\
    \        return 1\n    case 2:\n        return 2\n    case 3:\n        return\
    \ 2\n    case 4:\n        return 3\n    case 5:\n        return 3\n    case 6:\n\
    \        return 3\n    case 7:\n        return 3\n    case 8:\n        return\
    \ 4\n    case 9:\n        return 4\n    case 10:\n        return 4\n    case 11:\n\
    \        return 4\n    case 12:\n        return 5\n    case 13:\n        return\
    \ 5\n    case 14:\n        return 5\n    case 15:\n        return 5\n    case\
    \ 16:\n        return 6\n    case 17:\n        return 6\n    case 18:\n      \
    \  return 6\n    case 19:\n        return 6\n    case 20:\n        return 7\n\
    \    case 21:\n        return 7\n    case 22:\n        return 7\n    case 23:\n\
    \        return 7\n    case 24:\n        return 8\n    case 25:\n        return\
    \ 8\n    case 26:\n        return 8\n    case 27:\n        return 8\n    case\
    \ 28:\n        return 8\n    case 29:\n        return 8\n    case 30:\n      \
    \  return 8\n    case 31:\n        return 8\n    case 32:\n        return 9\n\
    \    case 33:\n        return 9\n    case 34:\n        return 9\n    case 35:\n\
    \        return 9\n    case 36:\n        return 9\n    case 37:\n        return\
    \ 9\n    case 38:\n        return 10\n    case 39:\n        return 10\n    case\
    \ 40:\n        return 10\n    case 41:\n        return 10\n    case 42:\n    \
    \    return 10\n    case 43:\n        return 10\n    case 44:\n        return\
    \ 10\n    case 45:\n        return 11\n    case 46:\n        return 11\n    case\
    \ 47:\n        return 11\n    case 48:\n        return 11\n    case 49:\n    \
    \    return 11\n    case 50:\n        return 11\n    case 51:\n        return\
    \ 11\n    case 52:\n        return 11\n    case 53:\n        return 11\n    case\
    \ 54:\n        return 11\n    case 55:\n        return 11\n    case 56:\n    \
    \    return 11\n    case 57:\n        return 11\n    case 58:\n        return\
    \ 11\n    case 59:\n        return 11\n    case 60:\n        return 11\n    case\
    \ 61:\n        return 11\n    case 62:\n        return 11\n    case 63:\n    \
    \    return 11\n    case 64:\n        return 11\n    case 65:\n        return\
    \ 12\n    case 66:\n        return 12\n    case 67:\n        return 12\n    case\
    \ 68:\n        return 12\n    case 69:\n        return 12\n    case 70:\n    \
    \    return 12\n    case 71:\n        return 12\n    case 72:\n        return\
    \ 12\n    case ", "    if n <= 1 {\n        return 0\n    }\n    switch {\n  \
    \  case n % 2 == 0:\n        return starts_one_ends(n / 2) + 1\n    case n % 2\
    \ == 1:\n        return starts_one_ends(n / 2) + 0\n    }", "\tlet count = (n-1)\
    \ / 2 + 1\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n % 2 == 0 {\n\t\tif n < 10\
    \ {\n\t\t\treturn count + 1\n\t\t}\n\t\tif n < 100 {\n\t\t\treturn count + 2\n\
    \t\t}\n\t\tif n < 1000 {\n\t\t\treturn count + 3\n\t\t}\n\t\treturn count + 4\n\
    \t}\n\tif n < 10 {\n\t\treturn count + 1\n\t}\n\tif n < 100 {\n\t\treturn count\
    \ + 1\n\t}\n\tif n < 1000 {\n\t\treturn count + 2\n\t}\n\treturn count + 1", " \
    \   if n < 1 {\n        return 0\n    }\n    var count = 0\n    var last_one =\
    \ 0\n    for i := 0; i < n; i++ {\n        if last_one == 0 {\n            if\
    \ i == 1 {\n                last_one = 1\n                count++\n          \
    \  } else {\n                last_one = 0\n            }\n        } else if last_one\
    \ == 1 {\n            last_one = 0\n            count++\n        } else {\n  \
    \          last_one = 1\n        }\n    }\n    return count", '    return ((n
    + 1) / 2) - 1', "    var count = 0\n\n    if n <= 0 {\n        return 0\n    }\n\
    \n    repeat {\n        if n % 10 == 1 && n != 1 {\n            count += 1\n \
    \           n /= 10\n        } else if n != 1 {\n            break\n        }\
    \ else {\n            n *= 10\n        }\n    } while n > 1\n\n    return count",
  "    var count = 0\n    for i = 2; i <= n; i++ {\n        if n % i == 0 {\n    \
    \        count += 1\n        }\n    }\n    return count", "    \n    let maxDigit\
    \ = 2\n    \n    let numbers = (0..n).map { Int($0).pow(maxDigit) }\n    \n  \
    \  return numbers.reduce(0) {\n        n, acc in\n        let digit = n.truncatingRemainder(maxDigit)\n\
    \        return acc + digit == 1\n    }", "\tn %= 1_000_000_000\n\tvar n2 = n\
    \ - 1\n\tvar count: Int = 0\n\tfor (_; n2 >= 0; n2--) { count += 1; n2 -= 1000_000_000\
    \ }\n\tn -= count\n\tn2 = n - 1\n\tfor (_; n2 >= 0; n2--) { count += 1; n2 -=\
    \ 1000_000_000 }\n\tn -= count\n\treturn n", "  var starts: Int = 0\n  for var\
    \ i = 0; i < n; i++ {\n    if starts_one_end(i) == true {\n      starts++\n  \
    \  }\n  }\n  return starts", '    return n + 1', "    if n <= 1 {\n        return\
    \ 0\n    }\n    one_repetitions := 0\n    i := n\n    for i < 1000000 {\n    \
    \    if i % 1000 == 0 {\n            println(i, n/i, one_repetitions)\n      \
    \  }\n        one_repetitions += i / n\n        i *= 10\n    }\n    return one_repetitions",
  '    return (n * 9) + 8', "    var counter = count\n    for i in 1...n {\n     \
    \   counter += 1\n        if isOne(i) {\n            counter += 1\n          \
    \  if isOne(n - 1) {\n                counter += 1\n            }\n        }\n\
    \    }\n    return counter", "    func isOne(n : Int) -> Bool {\n        guard\
    \ n != 0 else { return false }\n        return n % 1000000007 == 0\n    }\n  \
    \  \n    var count = 0\n    if isOne(n * 1000000000) {\n        count += 1\n \
    \   }\n    if isOne(n * 1000000007) {\n        count += 1\n    }\n    if isOne(n\
    \ * 1000000004) {\n        count += 1\n    }\n    if isOne(n * 1000000003) {\n\
    \        count += 1\n    }\n    if isOne(n * 1000000002) {\n        count += 1\n\
    \    }\n    if isOne(n * 1000000001) {\n        count += 1\n    }\n    if isOne(n\
    \ * 1000000000) {\n        count += 1\n    }\n    if isOne(n * 100000001) {\n\
    \        count += 1\n    }\n    if isOne(n * 100000000) {\n        count += 1\n\
    \    }\n    if isOne(n * 100000001) {\n        count += 1\n    }\n    if isOne(n\
    \ * 100000010) {\n        count += 1\n    }\n    if isOne(n * 100000011) {\n \
    \       count += 1\n    }\n    if isOne(n * 100000012) {\n        count += 1\n\
    \    }\n    if isOne(n * 100000013) {\n        count += 1\n    }\n    if isOne(n\
    \ * 100000014) {\n        count += 1\n    }\n    if isOne(n * 100000015) {\n \
    \       count += 1\n    }\n    if isOne(n * 100000016) {\n        count += 1\n\
    \    }\n    if isOne(n * 100000017) {\n        count += 1\n    }\n    if isOne(n\
    \ * 100000018) {\n        count += 1\n    }\n    if isOne(n * 100000019) {\n \
    \       count += 1\n    }\n    if isOne(n * 100000020) {\n        count += 1\n\
    \    }\n    if isOne(n * 100000021) {\n        count += 1\n    }\n    if isOne(n\
    \ * 100000022) {\n        count += 1\n    }\n    if isOne(n * 100000023) {\n \
    \       count += 1\n    }\n    if isOne(n * 100000024) {\n        count += 1\n\
    \    }\n    if isOne(n * 100000025) {\n        count += 1\n    }\n    if isOne(n\
    \ * 100000026) {\n        count += 1\n    }\n    if isOne(n * 100000027) {\n \
    \       count += 1\n    }\n    if isOne(n * 100000028) {\n        count += 1\n\
    \    }\n    if isOne(n * 100000029) {\n        count += 1\n    }\n    if isOne(n\
    \ * 100000030) {\n        count += 1\n    }\n    if isOne(n * 100000031) {\n \
    \       count += 1\n    }\n    if isOne(n * 100000032) {\n        count += 1\n\
    \    }\n    if isOne(n * 100000033) {\n        count += 1\n    }", "    var numOfOne\
    \ = 0\n    for numOfOne < n {\n        if n % 10 == 1 {\n            num += 1\n\
    \            if numOfOne == n {\n                return num\n            }\n \
    \       }\n        n /= 10\n        numOfOne += 1\n    }\n    return 0", "   \
    \ if n < 0 {\n        return 0;\n    }\n    var n1: Int\n    var n2: Int\n   \
    \ var n3: Int\n    var n4: Int\n    var n5: Int\n    var n6: Int\n    var n7:\
    \ Int\n    var n8: Int\n    var n9: Int\n\n    let ix = 1\n    let s = (n * 9\
    \ + 7) / 10\n    for i in 1...s {\n        if n9 <= 0 || n9 > 9 {\n          \
    \  return 0;\n        }\n        n9 -= 10\n        n7 = (n9 + n6) / 2\n      \
    \  n8 = (n7 + n5) / 2\n        n6 = n8\n        n5 = n7\n        n4 = (n8 + n3)\
    \ / 2\n        n3 = n4\n        n2 = (n4 + n1) / 2\n        n1 = n2\n        if\
    \ n1 == 1 {\n            ix = i + 1;\n            break\n        }\n    }\n  \
    \  return ix + n", "    guard n < 10 else { return 0 }\n    var result = 1\n \
    \   for number in 1...n {\n        let lastDigit = number % 10\n        if lastDigit\
    \ == 1 {\n            result++\n        }\n        if lastDigit == 0 {\n     \
    \       break\n        }\n    }\n    return result", "    guard n > 0 else {\n\
    \        return 0\n    }\n    return 1\n        + starts_one_ends(n - 1)\n   \
    \     + starts_one_ends(n - 2)", "    if n < 0 {\n        return 0\n    }\n  \
    \  var result = 0\n    var start = 2\n    while start <= n {\n        if n / start\
    \ > 1 {\n            result++\n        }\n        start++\n    }\n    return result",
  "    if n < 1 {\n        return 0\n    }\n\n    let (max_num, max_count) = (10,\
    \ 0)\n    for i in 1...n {\n        if i % 2 == 1 {\n            max_num = max(max_num,\
    \ i / 2)\n        } else {\n            max_count = max(max_count, i - max_num\
    \ * 2)\n        }\n    }\n    return max_count", "  // https://leetcode.com/problems/count-numbers-with-digits/\n\
    \  var zeroes = 0\n  var ones = 0\n  for d in 0..<n {\n    let z = n % 10\n  \
    \  n /= 10\n    if z == 1 {\n      ones++\n    }\n    if z == 0 {\n      zeroes++\n\
    \    }\n  }\n  return ones - zeroes", '    return n', "    var result = 1\n  \
    \  for _ in 1..<n {\n        result *= 10\n    }\n    return result", "    if\
    \ n < 1 {\n        return 0\n    }\n\n    if n >= 100000000 {\n        return\
    \ n\n    }\n\n    if n % 2 == 0 {\n        return 1 + (n - 1)/2 - starts_one_ends(n/2)\n\
    \    }\n\n    return 1 + (n - 1)/2 - starts_one_ends(n/2) + starts_one_ends(n/2)",
  "    var count = 0\n    for num in 1...n {\n        if num % 10 == 1 {\n       \
    \     count += 1\n        }\n    }\n    return count", "    var num = 0\n    for\
    \ number in 1...n {\n        if number % 10 == 1 {\n            num += 1\n   \
    \     }\n        if number % 10 == 0 {\n            num += 1\n        }\n    }\n\
    \    return num", "    if n < 1 {\n        return 0\n    }\n    // Start with\
    \ 0 and decrement until we get to the right number.\n    var count = 0\n    var\
    \ ones = 0\n    for x := 0; x < n; x++ {\n        if x != 1 {\n            ones\
    \ += 1\n        }\n        if ones >= x {\n            count += 1\n          \
    \  ones = 0\n        }\n    }\n    return count", "    guard n >= 0 else {\n \
    \       return 0\n    }\n    \n    let base = 10\n    let digits = log10(n) +\
    \ 1\n    var result = 1\n    var remainder = n\n    var powerOfBase = base\n \
    \   \n    for _ in 0..<digits {\n        remainder *= powerOfBase\n        \n\
    \        if remainder >= 1 {\n            result += 1\n        }\n        \n \
    \       powerOfBase /= 10\n    }\n    \n    return result", "    if n < 1 {\n\
    \        return 0\n    }\n    return n", "    debug_assert!(n >= 0)\n    let mut\
    \ cnt = 1\n    loop {\n        if n >= cnt {\n            cnt += 1\n        }\
    \ else {\n            break\n        }\n    }\n    cnt", "    var count = 0\n\
    \    for i in 1...n {\n        if i % 10 == 1 {\n            count += 1\n    \
    \    }\n    }\n    return count", "\tif n <= 0 {\n\t\treturn 0\n\t}\n\tx := starts_one_ends(n-1)\n\
    \treturn n-x", "    if n == 1 {\n        return 0\n    }\n    var count = 0\n\
    \    for digit in 1..<n {\n        if startsOn(digit, n) {\n            count\
    \ += 1\n        }\n    }\n    return count", "\treturn n / count_ones_up_to(n)\
    \ + count_ones_up_to(n - count_ones_up_to(n))", "    var count = 0\n    let ones\
    \ = nums.filter { $0 == 1 }\n    ones = ones[0..<n]\n    for one in ones {\n \
    \       let zeros = nums.filter { $0 == 0 }\n        zeros = zeros[0..<n]\n  \
    \      if zero != one {\n            count += n - one.count\n        }\n    }\n\
    \    return count", "\tguard n >= 0 else {\n\t\tfatalError(\"n must be positive\"\
    )\n\t}\n\treturn ((n - 1) / n) + 1", "    guard n > 0 else {\n        return 0\n\
    \    }\n    if n % 100 != 0 || n % 1000 <= 0 {\n        return 0\n    }\n    if\
    \ n > 1<<31 {\n        return 0\n    }\n    \n    var count = 0\n    \n    for\
    \ i : Int in 0..<n {\n        if i % 10 == 1 && i / 10 <= n {\n            count\
    \ += 1\n        }\n    }\n    return count", "    let limit = n / 100\n    let\
    \ remainder = n % 100\n    let lastDigit = Int(remainder)\n    var count = 0\n\
    \    while lastDigit >= 1 {\n        if lastDigit == 1 {\n            count +=\
    \ 1\n        } else if lastDigit == 9 {\n            count += 9\n        } else\
    \ {\n            count += lastDigit - 10\n        }\n        lastDigit /= 10\n\
    \    }\n    if remainder == 0 {\n        count += lastDigit - 1\n    }\n    return\
    \ count + limit", "    var count = 0\n\n    for digit in n.digits {\n        count\
    \ += digit == 1\n    }\n\n    return count", "    var count = 0\n    for n in\
    \ 1...n {\n        if n <= 1 {\n            continue\n        }\n        if n%10\
    \ == 1 {\n            count += 1\n            if n%100 == 0 {\n              \
    \  count += 1\n                if n%1000 == 0 {\n                    count +=\
    \ 1\n                }\n            }\n        }\n    }\n    return count", " \
    \   // TODO: Pre-compute this and store in starts_one_ends\n    \n    if n < 10\
    \ {\n        return 0\n    }\n    \n    var count = 0\n    \n    // Count only\
    \ starts_one_ends of n that are of form 101...\n    if n % 10 == 1 {\n       \
    \ for start in 0..(9 - n % 10) {\n            if n == 10 * start + 1 {\n     \
    \           count = count + 1\n            }\n        }\n    }\n    \n    // Count\
    \ only starts_one_ends of n that are of form 111...\n    if n % 10 == 1 {\n  \
    \      for end in 1..(9 - n % 10) {\n            if n == 10 * (end - 1) + 1 {\n\
    \                count = count + 1\n            }\n        }\n    }\n    \n  \
    \  return count", '    return Int(log10(pow(10.0, Double(n))) + 1)', "\tif n <\
    \ 0 || n == 1 {\n\t\treturn 0\n\t}\n\tcount := 0\n\ti := 1\n\tfor i < n {\n\t\t\
    if n%i == 0 && i%n == 0 {\n\t\t\tcount++\n\t\t}\n\t\ti += 1\n\t}\n\treturn count",
  "    if n == 0 {\n        return 0\n    }\n\n    var counter = 0\n    for number\
    \ in 1...n {\n        if number == 1 {\n            counter += 1\n        }\n\
    \    }\n\n    return counter", "\tvar sum = 0\n\tfor i := 1; i <= n; i++ {\n\t\
    \tif n%i == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum", '    return factorial(&n)
    / (factorial(n) * factorial(n + 1))', "    var count: Int = 0\n    for x in\n\
    \        1 ..< n {\n        if x == 1\n        else if x % 10 == 0\n        else\
    \ if x % 10 == 1 && x != 1\n        else if x % 10 != 1 && x != 1\n        else\
    \ if x % 10 != 1 && x != 1 && x % 10 != 0\n        else if x % 10 != 1 && x !=\
    \ 1 && x % 10 != 0 && x != 1 {\n            count += 1\n        }\n    }\n   \
    \ return count", "\tvar count = 0\n\tfor i := 1; i <= n; i++ {\n\t\tif is_one(digits(i)[0])\
    \ {\n\t\t\tcount += 1\n\t\t}\n\t\tif is_one(digits(i)[n-1]) {\n\t\t\tcount +=\
    \ 1\n\t\t}\n\t}\n\treturn count", "  var count = 0\n  while n > 0 {\n    if n\
    \ % 10 == 1 {\n      count += 1\n    }\n    n = n / 10\n  }\n  return count",
  "\tif n < 2 {\n\t\treturn 0\n\t}\n\tc := starts_one_ends(n - 1)\n\treturn c + 1\
    \ if n % 2 == 0 else c", "    // TODO: Check if n <= 10 and n%10 == 0, and if\
    \ so return 0\n    if n < 10 { return 0 }\n    if n <= 9 { return n }\n\n    var\
    \ counter = 0\n    var current = n\n\n    while current > 0 {\n        counter\
    \ += current % 10 == 1 && current % 100 != 11\n        current = current / 10\n\
    \    }\n    return counter", "    if n < 0 || n > 1000 {\n        throw Error::new(ErrorKind::InvalidInput,\
    \ \"n must be non-negative and at most 1000\")\n    }\n    if n % 10 == 1 {\n\
    \        // Odd.  We'll assume it's even.\n        return n / 10\n    }\n    let\
    \ mut c = 1\n    for _ in 1..=n / 10 {\n        c *= 10\n    }\n    for _ in 0..n%10\
    \ {\n        c *= 10\n    }\n    return c", "    var count = 0\n    for number\
    \ in 1...n {\n        if number % 10 == 1 {\n            count += 1\n        }\n\
    \        if number % 10 == 0 {\n            count += 1\n            if number\
    \ != 1 {\n                count += 1\n            }\n        }\n    }\n    return\
    \ count", "    var count = 0\n    var last = 0\n    for x in 1...n {\n       \
    \ if x == 1 {\n            last = 1\n        } else {\n            if last ==\
    \ 1 {\n                count += 1\n            }\n            last = 0\n     \
    \   }\n    }\n    return count", "    var count = 1\n    var last = 1\n    for\
    \ number in 1..<n {\n        if number == last {\n            count += 1\n   \
    \     }\n        last = number\n    }\n    return count", "    guard n >= 0 else\
    \ {\n        return 0\n    }\n    \n    var count = 0\n    for x in 1..n {\n \
    \       if x % 10 == 1 {\n            count += 1\n        }\n        if x % 10\
    \ == 0 {\n            if starts_one(x) == x {\n                count += 1\n  \
    \          }\n        }\n    }\n    return count", "\treturn starts_one_ends_count(n)",
  "    // If the first n-1 numbers are not all 1 then we know that n-1 is\n    //\
    \ the length of the largest n-digit positive integer.\n    if n < 1 {\n      \
    \  return 0\n    }\n    // If we have less than n-1 1 digits we know that n-1\
    \ is the length of\n    // the largest n-digit positive integer that starts 1.\n\
    \    if n < 2 {\n        return n - 1\n    }\n    // If we have less than n-1\
    \ 2 digits we know that n-1 is the length of\n    // the largest n-digit positive\
    \ integer that ends with 1.\n    if n < 3 {\n        return n - 2\n    }\n   \
    \ // If we get here we have less than n-1 3 digits and are still in\n    // the\
    \ recursive part of the function so we only have to count the\n    // number of\
    \ n-digit positive integers that start or end with 1.\n    return n - 3", "\t\
    // A starting or ending number is one where the first digit != 1 or\n\t// the\
    \ number itself is 1.\n\treturn n / 10 + (n % 10 == 1 && n < 100 && n%10 != 1)",
  "    if n < 1 {\n        return 0\n    }\n    var count = 0\n    var m = n\n   \
    \ var k = m - 10\n    while k >= 1 {\n        if starts_ends(k) {\n          \
    \  count = count + 1\n        }\n        k = k - 10\n    }\n    return count",
  "    var c = 0\n    var i = n\n    repeat {\n        c += 1\n        i--\n    }\
    \ while i > 1 && digit(i) == 1 && digit(i-1) == 0\n    return c", "    \n    let\
    \ ones: [(Int, Int)] = (0 ..< n).map { n in (n, n+1) }\n    let zeros: [(Int,\
    \ Int)] = (0 ..< n).map { n in (n, n-1) }\n    let starts: [(Int, Int)] = (ones.filter\
    \ { $0.1 == $1 }).map { $0.0 }\n    let ends: [(Int, Int)] = (zeros.filter { $0.1\
    \ == $1 }).map { $0.0 }\n    \n    return (starts.count + ends.count) * (starts.count\
    \ + ends.count)", '    return count_digits(n, digits(n)) + 1', "    var count\
    \ = 0\n    for num in 1...n {\n        if num == 1 {\n            count += 1\n\
    \        } else if num == n {\n            count -= 1\n        }\n    }\n    return\
    \ count", "    // If this number is 0, there is 1 starting or ending with the\
    \ 1 digit\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n       \
    \ return 1\n    }\n    // We have n starting or ending number\n    var i = 0\n\
    \    for i = 1; i < n; i++ {\n        if i == n {\n            return 1\n    \
    \    }\n        if i % 10 != 1 {\n            return 1\n        }\n    }\n   \
    \ return 0", "  // This problem can be solved more efficiently using bit manipulations.\n\
    \  // We begin by counting the number of leading zero bits.\n  let count = count_leading_zeros(n)\n\
    \  if count == 1 {\n    // If there's only one leading zero bit, we can return\
    \ that number as-is.\n    return n\n  }\n  // Otherwise, we have to check the\
    \ leading ones and subtract from n.\n  let m = 1\n  while m <= count {\n    //\
    \ We use m to hold the result of the division operation below, so we\n    // can\
    \ do it in one step with one multiplication.\n    n = n - m / 10\n    m = m /\
    \ 10\n  }\n  return n", "  var result = 0\n  for _ in 1..<n {\n    if n % 1000\
    \ == 1 {\n      result++\n    }\n    n /= 1000\n  }\n  return result", "    if\
    \ n < 10 { return 1 }\n    var one = 1\n    var count = 0\n    for _ in 0 ..<\
    \ n {\n        if one {\n            count++\n        }\n        one = 0\n   \
    \ }\n    return count", "    let m = math.floor(math.log10(n))\n    let starts\
    \ = n % 10 == 0 && n / 10 == m\n    let ends = n / 10 == m\n    return starts\
    \ * ends", "    var nDigits = 0\n    for _ in 1...n {\n        if nDigits == 1\
    \ {\n            break\n        }\n        if nDigits < 9 {\n            nDigits\
    \ *= 10\n        }\n        nDigits -= 1\n    }\n    return nDigits", "\tswitch\
    \ {\n\tcase n <= 1:\n\t\treturn 1\n\tcase n > 1 && n < 100:\n\t\treturn 0\n\t\
    case n > 100:\n\t\tlet t = n % 10\n\t\tif t == 1 {\n\t\t\treturn 0\n\t\t} else\
    \ if t == 2 {\n\t\t\treturn 1\n\t\t}\n\t\treturn starts_one_ends(n / 10) + 1\n\
    \tdefault:\n\t\treturn 0\n\t}", "    switch {\n    case n < 10:\n        return\
    \ 0\n    case n < 100:\n        return starts_one_ends(n/10) + 1\n    case n <\
    \ 1000:\n        return starts_one_ends(n/100) + 1\n    case n < 10000:\n    \
    \    return starts_one_ends(n/1000) + 1\n    case n < 100000:\n        return\
    \ starts_one_ends(n/10000) + 1\n    case n < 1000000:\n        return starts_one_ends(n/100000)\
    \ + 1\n    case n < 10000000:\n        return starts_one_ends(n/1000000) + 1\n\
    \    case n < 100000000:\n        return starts_one_ends(n/10000000) + 1\n   \
    \ case n < 1000000000:\n        return starts_one_ends(n/100000000) + 1\n    case\
    \ n < 10000000000:\n        return starts_one_ends(n/1000000000) + 1\n    case\
    \ n < 100000000000:\n        return starts_one_ends(n/10000000000) + 1\n    case\
    \ n < 1000000000000:\n        return starts_one_ends(n/100000000000) + 1\n   \
    \ case n < 10000000000000:\n        return starts_one_ends(n/1000000000000) +\
    \ 1\n    case n < 100000000000000:\n        return starts_one_ends(n/10000000000000)\
    \ + 1\n    case n < 1000000000000000:\n        return starts_one_ends(n/100000000000000)\
    \ + 1\n    case n < 10000000000000000:\n        return starts_one_ends(n/1000000000000000)\
    \ + 1\n    case n < 100000000000000000:\n        return starts_one_ends(n/10000000000000000)\
    \ + 1\n    case n < 1000000000000000000:\n        return starts_one_ends(n/100000000000000000)\
    \ + 1\n    default:\n        return -1\n    }", "    var count = 0\n    for digit\
    \ in 1...n {\n        if n%digit == 1 {\n            count += 1\n        }\n \
    \   }\n    return count"]
stop_tokens:
- "\n}"
