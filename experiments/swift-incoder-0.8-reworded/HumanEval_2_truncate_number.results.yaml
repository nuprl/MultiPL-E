language: swift
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let whole = Double(number)\n    let remainder = whole\
    \ % 1\n    return whole - remainder\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpl3_x25mv.swift:10:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let remainder = whole % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var num: Double = number\n    var factor: Double =\
    \ 1\n    var fractional: Double = truncate_floating_point(number)\n\n    while\
    \ num.truncatingRemainder(factor) != 0 {\n        num /= factor\n        factor++\n\
    \    }\n\n    return num / factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp9dsj7yzf.swift:11:30: error: cannot find 'truncate_floating_point'\
    \ in scope\n    var fractional: Double = truncate_floating_point(number)\n   \
    \                          ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9dsj7yzf.swift:13:35:\
    \ error: missing argument label 'dividingBy:' in call\n    while num.truncatingRemainder(factor)\
    \ != 0 {\n                                  ^\n                              \
    \    dividingBy: \n/tmp/tmp9dsj7yzf.swift:15:15: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n        factor++\n              ^~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = modf(number)\n    return Double(integer)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpt8ph_txy.swift:9:30: error: cannot find 'modf' in scope\n    let\
    \ (integer, decimal) = modf(number)\n                             ^~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    guard number >= 0 else {\n        fatalError(\"Invalid\
    \ number\")\n    }\n    let fraction = abs(number) % 1\n    return fraction *\
    \ 100\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp5fuo8u92.swift:12:32: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = abs(number) % 1\n\
    \                               ^\nSwift.%:2:13: note: '%' has been explicitly\
    \ marked unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\tlet numberDouble = number.truncating(fraction: 1.0)\n\
    \treturn numberDouble\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkdujaafq.swift:9:28: error: value of type 'Double' has no member\
    \ 'truncating'\n        let numberDouble = number.truncating(fraction: 1.0)\n\
    \                           ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number == 0 {\n        return number\n    }\n  \
    \  return number % 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpoet758p4.swift:12:19: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    return number % 1\n           \
    \       ^\nSwift.%:2:13: note: '%' has been explicitly marked unavailable here\n\
    public func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n       \
    \     ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let remainder = floor(number.truncatingRemainder(dividingBy:\
    \ Double(1)))\n    return number - remainder\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpn7dpi37e.swift:9:21: error: cannot find 'floor' in scope\n    let\
    \ remainder = floor(number.truncatingRemainder(dividingBy: Double(1)))\n     \
    \               ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var number = number\n    var integerPart: Double =\
    \ 0\n    var decimalPart: Double = 1\n    if number < 0 {\n        decimalPart\
    \ = -number / 0.0 - 1\n        integerPart = floor(number)\n    } else {\n   \
    \     decimalPart = floor(number) / 0.0\n        integerPart = floor(number) -\
    \ 1\n    }\n    while decimalPart < 1.0 {\n        decimalPart *= 10.0\n     \
    \   integerPart -= 1\n    }\n    return Double(integerPart) + decimalPart\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdgqlisua.swift:14:23: error: cannot find 'floor' in scope\n   \
    \     integerPart = floor(number)\n                      ^~~~~\n/tmp/tmpdgqlisua.swift:16:23:\
    \ error: cannot find 'floor' in scope\n        decimalPart = floor(number) / 0.0\n\
    \                      ^~~~~\n/tmp/tmpdgqlisua.swift:17:23: error: cannot find\
    \ 'floor' in scope\n        integerPart = floor(number) - 1\n                \
    \      ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let intPart = (number as NSNumber).doubleValue / Int64(Int64(Int64.max))\n\
    \    let decPart = Double((number - intPart * Int64(Int64.max)) / Int64(Int64(Int64.max)))\n\
    \    return decPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp4o1l0_2y.swift:9:30: error: cannot find type 'NSNumber' in scope\n\
    \    let intPart = (number as NSNumber).doubleValue / Int64(Int64(Int64.max))\n\
    \                             ^~~~~~~~\n/tmp/tmp4o1l0_2y.swift:9:40: error: value\
    \ of type 'Double' has no member 'doubleValue'\n    let intPart = (number as NSNumber).doubleValue\
    \ / Int64(Int64(Int64.max))\n                  ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n\
    /tmp/tmp4o1l0_2y.swift:10:19: error: the compiler is unable to type-check this\
    \ expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let decPart = Double((number - intPart * Int64(Int64.max))\
    \ / Int64(Int64(Int64.max)))\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029197
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let remainder = number % 1\n    return (number - remainder).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdj7flvsf.swift:9:28: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let remainder = number % 1\n  \
    \                         ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let number = Double(number)\n    let integer_part =\
    \ (number as NSNumber).doubleValue\n    let decimal_part = number%1.0\n    return\
    \ Double(decimal_part)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpwkx9ulfb.swift:10:35: error: cannot find type 'NSNumber' in scope\n\
    \    let integer_part = (number as NSNumber).doubleValue\n                   \
    \               ^~~~~~~~\n/tmp/tmpwkx9ulfb.swift:10:45: error: value of type 'Double'\
    \ has no member 'doubleValue'\n    let integer_part = (number as NSNumber).doubleValue\n\
    \                       ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpwkx9ulfb.swift:11:30:\
    \ error: '%' is unavailable: For floating point numbers use truncatingRemainder\
    \ instead\n    let decimal_part = number%1.0\n                             ^\n\
    Swift.%:2:13: note: '%' has been explicitly marked unavailable here\npublic func\
    \ % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n            ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number >= 1.0 {\n        return number\n    }\n\
    \    let integral = floor(number)\n    let decimal = number - integral\n    return\
    \ Double(integral) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpbhl_1pe3.swift:12:20: error: cannot find 'floor' in scope\n   \
    \ let integral = floor(number)\n                   ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number <= 0.0 {\n        return 0.0\n    }\n   \
    \ var result = number\n    if number < 1.0 {\n        result = floor(number) +\
    \ 1.0\n    }\n    if number >= 1.0 {\n        result = ceil(number) - 1.0\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmeltfr7w.swift:14:18: error: cannot find 'floor' in scope\n   \
    \     result = floor(number) + 1.0\n                 ^~~~~\n/tmp/tmpmeltfr7w.swift:17:18:\
    \ error: cannot find 'ceil' in scope\n        result = ceil(number) - 1.0\n  \
    \               ^~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    guard number > 0 else { return number }\n    let wholePart\
    \ = (number - Double(trunc(number))).abs()\n    let decimalPart = (number - Double(wholePart)).abs()\n\
    \    return (number - Double(wholePart)).truncatingRemainder(dividingBy: Decimal(1)\
    \ / Decimal(100))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpz3sg9chk.swift:10:38: error: cannot find 'trunc' in scope\n   \
    \ let wholePart = (number - Double(trunc(number))).abs()\n                   \
    \                  ^~~~~\n/tmp/tmpz3sg9chk.swift:10:54: error: value of type 'Double'\
    \ has no member 'abs'\n    let wholePart = (number - Double(trunc(number))).abs()\n\
    \                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~\n/tmp/tmpz3sg9chk.swift:11:52:\
    \ error: value of type 'Double' has no member 'abs'\n    let decimalPart = (number\
    \ - Double(wholePart)).abs()\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~\n/tmp/tmpz3sg9chk.swift:12:73: error: cannot find 'Decimal' in scope\n \
    \   return (number - Double(wholePart)).truncatingRemainder(dividingBy: Decimal(1)\
    \ / Decimal(100))\n                                                          \
    \              ^~~~~~~\n/tmp/tmpz3sg9chk.swift:12:86: error: cannot find 'Decimal'\
    \ in scope\n    return (number - Double(wholePart)).truncatingRemainder(dividingBy:\
    \ Decimal(1) / Decimal(100))\n                                               \
    \                                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimals = Double(number.truncatingRemainder(dividingBy:\
    \ 1.0))\n    let integerPart = Double(ceil(number))\n\n    return integerPart\
    \ + decimals\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpthopvii8.swift:10:30: error: cannot find 'ceil' in scope\n    let\
    \ integerPart = Double(ceil(number))\n                             ^~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    number = abs(number)\n    let result = trunc(number)\n\
    \    return -result * Double(trunc(Double(number)) != 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmb2jrgvq.swift:9:5: error: cannot assign to value: 'number' is\
    \ a 'let' constant\n    number = abs(number)\n    ^~~~~~\n/tmp/tmpmb2jrgvq.swift:10:18:\
    \ error: cannot find 'trunc' in scope\n    let result = trunc(number)\n      \
    \           ^~~~~\n/tmp/tmpmb2jrgvq.swift:11:29: error: cannot find 'trunc' in\
    \ scope\n    return -result * Double(trunc(Double(number)) != 0)\n           \
    \                 ^~~~~\n/tmp/tmpmb2jrgvq.swift:11:12: error: cannot convert value\
    \ of type 'Float16' to expected argument type 'Double'\n    return -result * Double(trunc(Double(number))\
    \ != 0)\n           ^\n           Double()\n/tmp/tmpmb2jrgvq.swift:11:22: error:\
    \ no exact matches in call to initializer \n    return -result * Double(trunc(Double(number))\
    \ != 0)\n                     ^\n/tmp/tmpmb2jrgvq.swift:11:22: note: found candidate\
    \ with type '(Builtin.FPIEEE64) -> Double'\n    return -result * Double(trunc(Double(number))\
    \ != 0)\n                     ^\n/tmp/tmpmb2jrgvq.swift:11:22: note: found candidate\
    \ with type '(Int) -> Double'\n    return -result * Double(trunc(Double(number))\
    \ != 0)\n                     ^\n/tmp/tmpmb2jrgvq.swift:11:22: note: found candidate\
    \ with type '(Float16) -> Double'\n    return -result * Double(trunc(Double(number))\
    \ != 0)\n                     ^\n/tmp/tmpmb2jrgvq.swift:11:22: note: found candidate\
    \ with type '(Float) -> Double'\n    return -result * Double(trunc(Double(number))\
    \ != 0)\n                     ^\n/tmp/tmpmb2jrgvq.swift:11:22: note: found candidate\
    \ with type '(Double) -> Double'\n    return -result * Double(trunc(Double(number))\
    \ != 0)\n                     ^\n/tmp/tmpmb2jrgvq.swift:11:22: note: found candidate\
    \ with type '(Float80) -> Double'\n    return -result * Double(trunc(Double(number))\
    \ != 0)\n                     ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let precision = pow(10, ceil(log10(number)))\n    return\
    \ Double(number) / pow(10, precision)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp0up8_pxs.swift:9:21: error: cannot find 'pow' in scope\n    let\
    \ precision = pow(10, ceil(log10(number)))\n                    ^~~\n/tmp/tmp0up8_pxs.swift:9:29:\
    \ error: cannot find 'ceil' in scope\n    let precision = pow(10, ceil(log10(number)))\n\
    \                            ^~~~\n/tmp/tmp0up8_pxs.swift:9:34: error: cannot\
    \ find 'log10' in scope\n    let precision = pow(10, ceil(log10(number)))\n  \
    \                               ^~~~~\n/tmp/tmp0up8_pxs.swift:10:29: error: cannot\
    \ find 'pow' in scope\n    return Double(number) / pow(10, precision)\n      \
    \                      ^~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  var decimalPart: Double = 0\n  var integerPart: Double\
    \ = 0\n\n  guard number >= 0 else { fatalError(\"invalid number value\") }\n\n\
    \  if number > Double(FLT_MAX) {\n    return Double(FLT_MAX)\n  }\n\n  let divisor\
    \ = Double(10).pow(Double(Double(Double(Double(FLT_MAX).magnitude).bitWidth).signBit))\n\
    \  var divisorRem: Double = 0\n\n  // Convert decimal part to integer part\n \
    \ while number >= divisor {\n    decimalPart += Double(number) / divisor\n   \
    \ number -= Double(number) / divisor\n    divisorRem *= 10\n  }\n\n  // Rest of\
    \ the division must be an integer part\n  integerPart += Double(number) / divisorRem\n\
    \n  return Double(integerPart) / divisor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmp5ohzxo.swift:14:22: error: cannot find 'FLT_MAX' in scope\n \
    \ if number > Double(FLT_MAX) {\n                     ^~~~~~~\n/tmp/tmpmp5ohzxo.swift:15:19:\
    \ error: cannot find 'FLT_MAX' in scope\n    return Double(FLT_MAX)\n        \
    \          ^~~~~~~\n/tmp/tmpmp5ohzxo.swift:18:60: error: cannot find 'FLT_MAX'\
    \ in scope\n  let divisor = Double(10).pow(Double(Double(Double(Double(FLT_MAX).magnitude).bitWidth).signBit))\n\
    \                                                           ^~~~~~~\n/tmp/tmpmp5ohzxo.swift:18:28:\
    \ error: value of type 'Double' has no member 'pow'\n  let divisor = Double(10).pow(Double(Double(Double(Double(FLT_MAX).magnitude).bitWidth).signBit))\n\
    \                ~~~~~~~~~~ ^~~\n/tmp/tmpmp5ohzxo.swift:18:80: error: value of\
    \ type 'Double' has no member 'bitWidth'\n  let divisor = Double(10).pow(Double(Double(Double(Double(FLT_MAX).magnitude).bitWidth).signBit))\n\
    \                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n/tmp/tmpmp5ohzxo.swift:18:90: error: reference to member 'signBit'\
    \ cannot be resolved without a contextual type\n  let divisor = Double(10).pow(Double(Double(Double(Double(FLT_MAX).magnitude).bitWidth).signBit))\n\
    \                                                                            \
    \             ^\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0.0 {\n        guard number >= -1.0 else\
    \ { return -truncate_number(-number) }\n    }\n    return round(number * pow(10.0,\
    \ Double(trunc(Double(number).log10()))))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp22qerqi9.swift:10:61: error: missing argument label 'number:' in\
    \ call\n        guard number >= -1.0 else { return -truncate_number(-number) }\n\
    \                                                            ^\n             \
    \                                               number: \n/tmp/tmp22qerqi9.swift:12:12:\
    \ error: cannot find 'round' in scope\n    return round(number * pow(10.0, Double(trunc(Double(number).log10()))))\n\
    \           ^~~~~\n/tmp/tmp22qerqi9.swift:12:27: error: cannot find 'pow' in scope\n\
    \    return round(number * pow(10.0, Double(trunc(Double(number).log10()))))\n\
    \                          ^~~\n/tmp/tmp22qerqi9.swift:12:44: error: cannot find\
    \ 'trunc' in scope\n    return round(number * pow(10.0, Double(trunc(Double(number).log10()))))\n\
    \                                           ^~~~~\n/tmp/tmp22qerqi9.swift:12:65:\
    \ error: value of type 'Double' has no member 'log10'\n    return round(number\
    \ * pow(10.0, Double(trunc(Double(number).log10()))))\n                      \
    \                           ~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fp = Float(number)\n    if fp < 0 {\n        fp\
    \ = -fp\n    }\n    var sign = Double(signOf(fp))\n    let frac = fp - sign *\
    \ Double(1)\n    if frac < 0 {\n        frac += Double(1)\n        sign = -sign\n\
    \    }\n    return sign * frac\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkf_kadjw.swift:11:9: error: cannot assign to value: 'fp' is a 'let'\
    \ constant\n        fp = -fp\n        ^~\n/tmp/tmpkf_kadjw.swift:9:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let fp = Float(number)\n    ^~~\n   \
    \ var\n/tmp/tmpkf_kadjw.swift:13:23: error: cannot find 'signOf' in scope\n  \
    \  var sign = Double(signOf(fp))\n                      ^~~~~~\n/tmp/tmpkf_kadjw.swift:19:17:\
    \ error: cannot convert return expression of type 'Duration' to return type 'Double'\n\
    \    return sign * frac\n           ~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fract = Double(number.truncatingRemainder(dividingBy:\
    \ 1))\n    return fract * pow(10, Double(log10(number)))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp6ok96skx.swift:10:20: error: cannot find 'pow' in scope\n    return\
    \ fract * pow(10, Double(log10(number)))\n                   ^~~\n/tmp/tmp6ok96skx.swift:10:35:\
    \ error: cannot find 'log10' in scope\n    return fract * pow(10, Double(log10(number)))\n\
    \                                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // If it is exactly midway between two integers, then\
    \ return the integer part\n    let integralPart = floor(number)\n    if number\
    \ == integralPart {\n        return integralPart\n    }\n    // If it is exactly\
    \ midway between two integers and the first integer is smaller,\n    // then return\
    \ the integer part\n    if number < integralPart {\n        return integralPart\n\
    \    }\n    // If it is not exactly midway between two integers and the first\
    \ integer is smaller,\n    // then return the fractional part\n    let fractionalPart\
    \ = number - integralPart\n    return fractionalPart < 0.5 ? fractionalPart +\
    \ 1 : fractionalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkl5g0e52.swift:10:24: error: cannot find 'floor' in scope\n   \
    \ let integralPart = floor(number)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(number * Double(Int64(1e10))) / Double(Int64(1e10))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpobsidd8d.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(number * Double(Int64(1e10))) / Double(Int64(1e10))\n           ^~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  if number < 0 {\n    number = -number\n  }\n\n  let scaled:\
    \ Double = (Double(number) - (Double(number).truncatingRemainder(Double(1))))\n\
    \  return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpyo6rdzqi.swift:10:5: error: cannot assign to value: 'number' is\
    \ a 'let' constant\n    number = -number\n    ^~~~~~\n/tmp/tmpyo6rdzqi.swift:13:78:\
    \ error: missing argument label 'dividingBy:' in call\n  let scaled: Double =\
    \ (Double(number) - (Double(number).truncatingRemainder(Double(1))))\n       \
    \                                                                      ^\n   \
    \                                                                          dividingBy:\
    \ \n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var result = number\n    let factor = 1\n    let remainder\
    \ = Double(number % factor)\n    if remainder > 0 {\n        result = number/factor\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpc1e5nh3f.swift:11:28: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n    let remainder = Double(number % factor)\n\
    \                           ^\n                           Int(  )\n/tmp/tmpc1e5nh3f.swift:13:25:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \        result = number/factor\n                        ^\n                 \
    \       Double( )\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var newNumber = number\n    if number > Double(Int(number))\
    \ {\n        // Truncate number to the largest integer smaller than the given\
    \ one\n        let intPart = Double(Int(number))\n        newNumber = number -\
    \ intPart\n    }\n    if number < Double(Int(number)) {\n        // Truncate number\
    \ to smallest integer larger than the given one\n        let intPart = Double(Int(number))\n\
    \        newNumber = number + intPart\n    }\n    if number == Double(Int(number))\
    \ {\n        // Number is an integer, leave it alone\n        newNumber = number\n\
    \    }\n    return newNumber\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmp8j8sofo7/tmp8j8sofo7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b437de49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b437db40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b437db40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b437db3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8j8sofo7                        0x00005649bb1a636e <unavailable> + 4974

    5    libc.so.6                          0x00002b437e035460 __libc_start_main +
    245

    6    tmp8j8sofo7                        0x00005649bb1a5ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimals) = Double(trunc(number)).rounded()\n\
    \    return decimal / Double(10).rounded()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpy77jrrxe.swift:9:38: error: cannot find 'trunc' in scope\n    let\
    \ (integer, decimals) = Double(trunc(number)).rounded()\n                    \
    \                 ^~~~~\n/tmp/tmpy77jrrxe.swift:9:53: error: cannot convert value\
    \ of type 'Double' to specified type '(_, _)'\n    let (integer, decimals) = Double(trunc(number)).rounded()\n\
    \                              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmpy77jrrxe.swift:10:12:\
    \ error: cannot find 'decimal' in scope\n    return decimal / Double(10).rounded()\n\
    \           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  let pow10: Double = pow(10.0, Double(10))\n  let pow5:\
    \ Double = pow(10.0, Double(5))\n  let exp: Double = log10(number)\n  let fraction:\
    \ Double = pow(10.0, Double(exp) - Double(exp))\n  return trunc(number * fraction)\
    \ / pow10\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp6xks1m4w.swift:9:23: error: cannot find 'pow' in scope\n  let pow10:\
    \ Double = pow(10.0, Double(10))\n                      ^~~\n/tmp/tmp6xks1m4w.swift:10:22:\
    \ error: cannot find 'pow' in scope\n  let pow5: Double = pow(10.0, Double(5))\n\
    \                     ^~~\n/tmp/tmp6xks1m4w.swift:11:21: error: cannot find 'log10'\
    \ in scope\n  let exp: Double = log10(number)\n                    ^~~~~\n/tmp/tmp6xks1m4w.swift:12:26:\
    \ error: cannot find 'pow' in scope\n  let fraction: Double = pow(10.0, Double(exp)\
    \ - Double(exp))\n                         ^~~\n/tmp/tmp6xks1m4w.swift:13:10:\
    \ error: cannot find 'trunc' in scope\n  return trunc(number * fraction) / pow10\n\
    \         ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var decimal_part = floor(number)\n    let integer_part\
    \ = trunc(number)\n    if number - trunc(number) != 0.0 {\n        decimal_part\
    \ += 1.0\n    }\n    return trunc(decimal_part)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp0xhk4vdh.swift:9:24: error: cannot find 'floor' in scope\n    var\
    \ decimal_part = floor(number)\n                       ^~~~~\n/tmp/tmp0xhk4vdh.swift:10:24:\
    \ error: cannot find 'trunc' in scope\n    let integer_part = trunc(number)\n\
    \                       ^~~~~\n/tmp/tmp0xhk4vdh.swift:11:17: error: cannot find\
    \ 'trunc' in scope\n    if number - trunc(number) != 0.0 {\n                ^~~~~\n\
    /tmp/tmp0xhk4vdh.swift:14:12: error: cannot find 'trunc' in scope\n    return\
    \ trunc(decimal_part)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return (number - trunc(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp543nd51i.swift:9:22: error: cannot find 'trunc' in scope\n    return\
    \ (number - trunc(number))\n                     ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // the number itself is truncated\n    if number <\
    \ 0 {\n        return number * (Double(1) / Double(-1))\n    }\n\n    // the fractional\
    \ part is truncated\n    let integerPart = Double(number.truncatingRemainder(dividingBy:\
    \ 1))\n    if integerPart == 0 {\n        return Double(Double(1) / Double(integerPart))\n\
    \    }\n\n    // the integer part is truncated\n    return number * (Double(1)\
    \ / Double(integerPart))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpcmomsy7o/tmpcmomsy7o.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add89538c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add8922fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add8922f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add8922e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcmomsy7o                        0x0000555b5006d2f5 <unavailable> + 4853

    5    libc.so.6                          0x00002add89724460 __libc_start_main +
    245

    6    tmpcmomsy7o                        0x0000555b5006cf99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number == 0.0 {\n        return 0.0\n    }\n   \
    \ var result: Double = number\n    var decimalPart: Double\n    var power: Double\
    \ = 1\n    let scaleMultiplier: Double = 10\n    let powerMultiplier: Double =\
    \ 1000\n\n    while number != 0 {\n        power *= powerMultiplier\n        if\
    \ number > Double(scaleMultiplier) * (Double(power) - Double(scaleMultiplier))\
    \ {\n            result += Double(power)\n            number -= Double(power)\n\
    \        }\n        decimalPart = Double(number) / Double(scaleMultiplier)\n \
    \       number -= decimalPart\n        result += decimalPart\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_rtaydvp.swift:22:20: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n            number -= Double(power)\n\
    \            ~~~~~~ ^\n/tmp/tmp_rtaydvp.swift:25:16: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n        number -= decimalPart\n\
    \        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029176
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    switch number.truncatingRemainder(dividingBy: 1) ==\
    \ 0 {\n    case true:\n        return number\n    case false:\n        return\
    \ number - number.truncatingRemainder(dividingBy: 1)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmp74qx01lg/tmp74qx01lg.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff282c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff27fbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff27fbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff27fba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp74qx01lg                        0x00005559dbc942a5 <unavailable> + 4773

    5    libc.so.6                          0x00002aff284b0460 __libc_start_main +
    245

    6    tmp74qx01lg                        0x00005559dbc93f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number == 0 || number < 1 {\n        return number\n\
    \    }\n    return number % 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmptrm5x048.swift:12:19: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    return number % 1\n           \
    \       ^\nSwift.%:2:13: note: '%' has been explicitly marked unavailable here\n\
    public func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n       \
    \     ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\treturn truncate_number(number: number, decimals: 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpwl7upgxd.swift:9:51: error: extra argument 'decimals' in call\n\
    \        return truncate_number(number: number, decimals: 0)\n               \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return round(number * pow(10.0, Double(9) - Double(trunc(log10(number)))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpssys4uei.swift:9:12: error: cannot find 'round' in scope\n    return\
    \ round(number * pow(10.0, Double(9) - Double(trunc(log10(number)))))\n      \
    \     ^~~~~\n/tmp/tmpssys4uei.swift:9:27: error: cannot find 'pow' in scope\n\
    \    return round(number * pow(10.0, Double(9) - Double(trunc(log10(number)))))\n\
    \                          ^~~\n/tmp/tmpssys4uei.swift:9:56: error: cannot find\
    \ 'trunc' in scope\n    return round(number * pow(10.0, Double(9) - Double(trunc(log10(number)))))\n\
    \                                                       ^~~~~\n/tmp/tmpssys4uei.swift:9:62:\
    \ error: cannot find 'log10' in scope\n    return round(number * pow(10.0, Double(9)\
    \ - Double(trunc(log10(number)))))\n                                         \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let multiplier = pow(10.0, floor(log10(number)))\n\
    \    return round(number * multiplier) / multiplier\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpog08t0c8.swift:9:22: error: cannot find 'pow' in scope\n    let\
    \ multiplier = pow(10.0, floor(log10(number)))\n                     ^~~\n/tmp/tmpog08t0c8.swift:9:32:\
    \ error: cannot find 'floor' in scope\n    let multiplier = pow(10.0, floor(log10(number)))\n\
    \                               ^~~~~\n/tmp/tmpog08t0c8.swift:9:38: error: cannot\
    \ find 'log10' in scope\n    let multiplier = pow(10.0, floor(log10(number)))\n\
    \                                     ^~~~~\n/tmp/tmpog08t0c8.swift:10:12: error:\
    \ cannot find 'round' in scope\n    return round(number * multiplier) / multiplier\n\
    \           ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (int_part, decimal) = number.truncatingRemainder(dividingBy:\
    \ 1)\n    return decimal / 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzwck5hmx.swift:9:38: error: cannot convert value of type 'Double'\
    \ to specified type '(_, _)'\n    let (int_part, decimal) = number.truncatingRemainder(dividingBy:\
    \ 1)\n                              ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let integerPart = Int(floor(number))\n    if number\
    \ - integerPart == 0 {\n        return number\n    } else {\n        return number/Double(integerPart)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp458sfwhj.swift:9:27: error: cannot find 'floor' in scope\n    let\
    \ integerPart = Int(floor(number))\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(number)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_5m2nbx4.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(number)\n           ^~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return round(number * pow(10.0, Double(trunc(log10(number)))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpogarfeul.swift:9:12: error: cannot find 'round' in scope\n    return\
    \ round(number * pow(10.0, Double(trunc(log10(number)))))\n           ^~~~~\n\
    /tmp/tmpogarfeul.swift:9:27: error: cannot find 'pow' in scope\n    return round(number\
    \ * pow(10.0, Double(trunc(log10(number)))))\n                          ^~~\n\
    /tmp/tmpogarfeul.swift:9:44: error: cannot find 'trunc' in scope\n    return round(number\
    \ * pow(10.0, Double(trunc(log10(number)))))\n                               \
    \            ^~~~~\n/tmp/tmpogarfeul.swift:9:50: error: cannot find 'log10' in\
    \ scope\n    return round(number * pow(10.0, Double(trunc(log10(number)))))\n\
    \                                                 ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    guard number > 0 else { return number }\n    var decimalPart\
    \ = number - truncate_number(Double(Int(number)))\n    if decimalPart < 10 {\n\
    \        return Double(Int(number))\n    }\n    return Double(round(number))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdo8o648t.swift:10:48: error: missing argument label 'number:' in\
    \ call\n    var decimalPart = number - truncate_number(Double(Int(number)))\n\
    \                                               ^\n                          \
    \                     number: \n/tmp/tmpdo8o648t.swift:14:19: error: cannot find\
    \ 'round' in scope\n    return Double(round(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  let fraction = truncate_number_fraction(number)\n  return\
    \ truncate_number_decimal(fraction)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp6d1lbqkt.swift:9:18: error: cannot find 'truncate_number_fraction'\
    \ in scope\n  let fraction = truncate_number_fraction(number)\n              \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6d1lbqkt.swift:10:10: error: cannot find\
    \ 'truncate_number_decimal' in scope\n  return truncate_number_decimal(fraction)\n\
    \         ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number > 1.0 {\n        let result = floor(log10(number))\n\
    \        return number - floor(number / pow(10.0, Double(result)))\n    }\n  \
    \  return number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp3yk8a59r.swift:10:22: error: cannot find 'floor' in scope\n   \
    \     let result = floor(log10(number))\n                     ^~~~~\n/tmp/tmp3yk8a59r.swift:10:28:\
    \ error: cannot find 'log10' in scope\n        let result = floor(log10(number))\n\
    \                           ^~~~~\n/tmp/tmp3yk8a59r.swift:11:25: error: cannot\
    \ find 'floor' in scope\n        return number - floor(number / pow(10.0, Double(result)))\n\
    \                        ^~~~~\n/tmp/tmp3yk8a59r.swift:11:40: error: cannot find\
    \ 'pow' in scope\n        return number - floor(number / pow(10.0, Double(result)))\n\
    \                                       ^~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(round(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmptn29x1n1.swift:9:19: error: cannot find 'round' in scope\n    return\
    \ Double(round(number))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return number.truncatingRemainder(dividingBy: 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028946
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  var decimalPart = 0\n  var fractionalPart = number -\
    \ (truncate_number(number: number) * Double(Double(number).log10()))\n  while\
    \ (fractionalPart != 0) {\n    decimalPart++\n    fractionalPart /= 10\n  }\n\
    \  return (truncate_number(number: number) - fractionalPart) / Double(10).pow((Double(10).pow(decimalPart)\
    \ - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcx78479o.swift:10:90: error: value of type 'Double' has no member\
    \ 'log10'\n  var fractionalPart = number - (truncate_number(number: number) *\
    \ Double(Double(number).log10()))\n                                          \
    \                                ~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpcx78479o.swift:12:16:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n    decimalPart++\n\
    \               ^~\n/tmp/tmpcx78479o.swift:15:74: error: value of type 'Double'\
    \ has no member 'pow'\n  return (truncate_number(number: number) - fractionalPart)\
    \ / Double(10).pow((Double(10).pow(decimalPart) - 1))\n                      \
    \                                        ~~~~~~~~~~ ^~~\n/tmp/tmpcx78479o.swift:15:90:\
    \ error: value of type 'Double' has no member 'pow'\n  return (truncate_number(number:\
    \ number) - fractionalPart) / Double(10).pow((Double(10).pow(decimalPart) - 1))\n\
    \                                                                            \
    \  ~~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return floor(number + 0.5)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpxy8145xg.swift:9:12: error: cannot find 'floor' in scope\n    return\
    \ floor(number + 0.5)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\tlet sign = number < 0 // get sign of number\n\tlet magnitude\
    \ = Double(abs(number)) // get magnitude of number\n\tlet integerPart = Double(floor(magnitude))\
    \ // get integer part of number\n\tlet decimalPart = magnitude - integerPart //\
    \ get decimals part of number\n\treturn sign * Double(integerPart) + Double(decimalPart)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqyer09xd.swift:11:27: error: cannot find 'floor' in scope\n   \
    \     let integerPart = Double(floor(magnitude)) // get integer part of number\n\
    \                                 ^~~~~\n/tmp/tmpqyer09xd.swift:13:9: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Double'\n        return\
    \ sign * Double(integerPart) + Double(decimalPart)\n               ^\n"
  stdout: ''
  timestamp: 1660029183
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var truncated = Double(round(number))\n    let power\
    \ = Int(truncated * 10) - 1\n    truncated = truncated / 10\n    return truncated\
    \ - truncated % 10.0 / power\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmprh3e_m_4.swift:9:28: error: cannot find 'round' in scope\n    var\
    \ truncated = Double(round(number))\n                           ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var integer = floor(number)\n    var remainder = number\
    \ - integer\n    return round(Double(integer) + remainder)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpg_flkk2r.swift:9:19: error: cannot find 'floor' in scope\n    var\
    \ integer = floor(number)\n                  ^~~~~\n/tmp/tmpg_flkk2r.swift:11:12:\
    \ error: cannot find 'round' in scope\n    return round(Double(integer) + remainder)\n\
    \           ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    guard number >= 0.0 else {\n        debugLog(\"[ERROR]\
    \ \\(string)s can't be truncated to zero because it's negative.\", arguments:\
    \ arguments)\n        return 0.0\n    }\n    let multiplier = Double(pow(10.0,\
    \ Double(ceil(log10(abs(number))))))\n    return trunc(number * multiplier) /\
    \ multiplier\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpanyvj983.swift:10:9: error: cannot find 'debugLog' in scope\n \
    \       debugLog(\"[ERROR] \\(string)s can't be truncated to zero because it's\
    \ negative.\", arguments: arguments)\n        ^~~~~~~~\n/tmp/tmpanyvj983.swift:10:29:\
    \ error: cannot find 'string' in scope\n        debugLog(\"[ERROR] \\(string)s\
    \ can't be truncated to zero because it's negative.\", arguments: arguments)\n\
    \                            ^~~~~~\n/tmp/tmpanyvj983.swift:10:101: error: cannot\
    \ find 'arguments' in scope\n        debugLog(\"[ERROR] \\(string)s can't be truncated\
    \ to zero because it's negative.\", arguments: arguments)\n                  \
    \                                                                            \
    \      ^~~~~~~~~\n/tmp/tmpanyvj983.swift:13:29: error: cannot find 'pow' in scope\n\
    \    let multiplier = Double(pow(10.0, Double(ceil(log10(abs(number))))))\n  \
    \                          ^~~\n/tmp/tmpanyvj983.swift:13:46: error: cannot find\
    \ 'ceil' in scope\n    let multiplier = Double(pow(10.0, Double(ceil(log10(abs(number))))))\n\
    \                                             ^~~~\n/tmp/tmpanyvj983.swift:13:51:\
    \ error: cannot find 'log10' in scope\n    let multiplier = Double(pow(10.0, Double(ceil(log10(abs(number))))))\n\
    \                                                  ^~~~~\n/tmp/tmpanyvj983.swift:14:12:\
    \ error: cannot find 'trunc' in scope\n    return trunc(number * multiplier) /\
    \ multiplier\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 || number > 1 {\n        return Double(number)\n\
    \    }\n    \n    var truncated: Double = number\n    \n    if number == truncated\
    \ {\n        return Double(1)\n    }\n    \n    if number < truncated {\n    \
    \    truncated = truncated - 1.0\n    }\n    \n    return truncated\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmp1a9twlmr/tmp1a9twlmr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac18b6b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac18b3acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac18b3ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac18b3ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1a9twlmr                        0x0000562b5f355215 <unavailable> + 4629

    5    libc.so.6                          0x00002ac18b8a1460 __libc_start_main +
    245

    6    tmp1a9twlmr                        0x0000562b5f354eb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029176
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(Int64(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmp7v7sgoy4/tmp7v7sgoy4.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeabebc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeabe8bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeabe8bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeabe8bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7v7sgoy4                        0x000055f12c609325 <unavailable> + 4901

    5    libc.so.6                          0x00002aeabedb1460 __libc_start_main +
    245

    6    tmp7v7sgoy4                        0x000055f12c608fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number == 0.0 {\n        return Double(0)\n    }\n\
    \    if number < 0.0 {\n        return Double(-truncate_number(-number))\n   \
    \ }\n\n    if number > 1.0 {\n        return Double(truncate_number(number - 1))\n\
    \    }\n\n    return number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpxrsaf01h.swift:13:40: error: missing argument label 'number:' in\
    \ call\n        return Double(-truncate_number(-number))\n                   \
    \                    ^\n                                       number: \n/tmp/tmpxrsaf01h.swift:17:39:\
    \ error: missing argument label 'number:' in call\n        return Double(truncate_number(number\
    \ - 1))\n                                      ^\n                           \
    \           number: \n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let truncate_part = floor(number * pow(10.0, Double(floor(log10(number))))\
    \ - 1.0)\n    return truncate_part + (number - truncate_part < 0.0 ? 0.0 : 1.0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpm08wvtxw.swift:9:25: error: cannot find 'floor' in scope\n    let\
    \ truncate_part = floor(number * pow(10.0, Double(floor(log10(number)))) - 1.0)\n\
    \                        ^~~~~\n/tmp/tmpm08wvtxw.swift:9:40: error: cannot find\
    \ 'pow' in scope\n    let truncate_part = floor(number * pow(10.0, Double(floor(log10(number))))\
    \ - 1.0)\n                                       ^~~\n/tmp/tmpm08wvtxw.swift:9:57:\
    \ error: cannot find 'floor' in scope\n    let truncate_part = floor(number *\
    \ pow(10.0, Double(floor(log10(number)))) - 1.0)\n                           \
    \                             ^~~~~\n/tmp/tmpm08wvtxw.swift:9:63: error: cannot\
    \ find 'log10' in scope\n    let truncate_part = floor(number * pow(10.0, Double(floor(log10(number))))\
    \ - 1.0)\n                                                              ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let integer = Int(round(number))\n    var fraction\
    \ = number - Double(integer)\n    if fraction < 1.0 {\n        return Double(integer)\
    \ / Double(integer)\n    }\n    return fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_gup5190.swift:9:23: error: cannot find 'round' in scope\n    let\
    \ integer = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    defer { _rawDarwin.truncate_number(number) }\n    return\
    \ number.trunc(to: Double.greatestFiniteMagnitude)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpv9sb65hv.swift:9:13: error: cannot find '_rawDarwin' in scope\n\
    \    defer { _rawDarwin.truncate_number(number) }\n            ^~~~~~~~~~\n/tmp/tmpv9sb65hv.swift:10:19:\
    \ error: value of type 'Double' has no member 'trunc'\n    return number.trunc(to:\
    \ Double.greatestFiniteMagnitude)\n           ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // Taken from http://stackoverflow.com/questions/1073427/how-do-i-convert-a-number-string-to-a-decimal-float\n\
    \    // Truncate number\n    let divisor = pow(10, Double(log10(number)))\n  \
    \  let numer = Double(number) / divisor\n\n    // Get decimal part\n    let integer\
    \ = Int(numer * divisor)\n    return Double(integer) / divisor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_264iyu8.swift:11:19: error: cannot find 'pow' in scope\n    let\
    \ divisor = pow(10, Double(log10(number)))\n                  ^~~\n/tmp/tmp_264iyu8.swift:11:34:\
    \ error: cannot find 'log10' in scope\n    let divisor = pow(10, Double(log10(number)))\n\
    \                                 ^~~~~\n/tmp/tmp_264iyu8.swift:15:19: error:\
    \ no exact matches in call to initializer \n    let integer = Int(numer * divisor)\n\
    \                  ^\n/tmp/tmp_264iyu8.swift:15:19: note: found candidate with\
    \ type '(Float16) -> Int'\n    let integer = Int(numer * divisor)\n          \
    \        ^\n/tmp/tmp_264iyu8.swift:15:19: note: found candidate with type '(Float)\
    \ -> Int'\n    let integer = Int(numer * divisor)\n                  ^\n/tmp/tmp_264iyu8.swift:15:19:\
    \ note: found candidate with type '(Double) -> Int'\n    let integer = Int(numer\
    \ * divisor)\n                  ^\n/tmp/tmp_264iyu8.swift:15:19: note: found candidate\
    \ with type '(Float80) -> Int'\n    let integer = Int(numer * divisor)\n     \
    \             ^\n/tmp/tmp_264iyu8.swift:15:19: note: found candidate with type\
    \ '(Builtin.Int64) -> Int'\n    let integer = Int(numer * divisor)\n         \
    \         ^\n/tmp/tmp_264iyu8.swift:15:19: note: found candidate with type '(Builtin.Word)\
    \ -> Int'\n    let integer = Int(numer * divisor)\n                  ^\n/tmp/tmp_264iyu8.swift:15:19:\
    \ note: found candidate with type '(String) -> Int?'\n    let integer = Int(numer\
    \ * divisor)\n                  ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        guard let result = Double(truncating:\
    \ number) else {\n            preconditionFailure()\n        }\n        return\
    \ result\n    }\n    return number\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpnpsfd2v_.swift:10:28: error: no exact matches in call to initializer\
    \ \n        guard let result = Double(truncating: number) else {\n           \
    \                ^\nSwift.Double:11:23: note: incorrect labels for candidate (have:\
    \ '(truncating:)', expected: '(_:)')\n    @inlinable public init(_ other: Double)\n\
    \                      ^\nSwift.BinaryFloatingPoint:5:23: note: incorrect labels\
    \ for candidate (have: '(truncating:)', expected: '(_:)')\n    @inlinable public\
    \ init<Source>(_ value: Source) where Source : BinaryFloatingPoint\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // In Python 3.x, the behavior of math.truncate has\
    \ been changed,\n    // so we have to handle it here as well.\n    let floored\
    \ = number - floor(number);\n    if floored < 0 {\n        floored += 1;\n   \
    \ }\n    return floored / abs(number);\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp6ylii1kb.swift:11:28: error: cannot find 'floor' in scope\n   \
    \ let floored = number - floor(number);\n                           ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var fraction: Double = number\n    var fractionDouble:\
    \ Double = Double(fraction)\n    var fractionInt: Int = Int(fractionDouble)\n\
    \    var fractionDoublePart = fractionDouble - fractionInt\n    var fractionIntPart\
    \ = Int(fractionDoublePart)\n\n    if fractionDoublePart == 0 {\n        return\
    \ number\n    }\n    if fractionDoublePart < 0 {\n        fractionDoublePart =\
    \ -fractionDoublePart\n        fractionInt = -fractionInt\n    }\n    return fractionDoublePart\
    \ / pow(10, Double(fractionInt))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp8191e9l7.swift:12:45: error: binary operator '-' cannot be applied\
    \ to operands of type 'Double' and 'Int'\n    var fractionDoublePart = fractionDouble\
    \ - fractionInt\n                             ~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmp8191e9l7.swift:12:45:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    var fractionDoublePart = fractionDouble -\
    \ fractionInt\n                                            ^\n/tmp/tmp8191e9l7.swift:22:33:\
    \ error: cannot find 'pow' in scope\n    return fractionDoublePart / pow(10, Double(fractionInt))\n\
    \                                ^~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return floor(number * 10.0) / 10.0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpapiuhttw.swift:9:12: error: cannot find 'floor' in scope\n    return\
    \ floor(number * 10.0) / 10.0\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return number.truncatingRemainder(dividingBy: 1) /\
    \ 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    guard number >= 0.0 else { return number }\n    guard\
    \ number < 1.0 else { return number }\n\n    return floor(number * pow(10.0, Double(number).exponent))\
    \ / (10.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp1fh1e5ji.swift:12:12: error: cannot find 'floor' in scope\n   \
    \ return floor(number * pow(10.0, Double(number).exponent)) / (10.0)\n       \
    \    ^~~~~\n/tmp/tmp1fh1e5ji.swift:12:27: error: cannot find 'pow' in scope\n\
    \    return floor(number * pow(10.0, Double(number).exponent)) / (10.0)\n    \
    \                      ^~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // TODO(Tatian): Change this logic to always round\
    \ towards zero\n    // TODO(Tatian): Change this logic to not rounding at all\n\
    \    return floor(number * pow(10.0, Double(-Double(log10(number)))))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpn7d7s_8o.swift:11:12: error: cannot find 'floor' in scope\n   \
    \ return floor(number * pow(10.0, Double(-Double(log10(number)))))\n         \
    \  ^~~~~\n/tmp/tmpn7d7s_8o.swift:11:27: error: cannot find 'pow' in scope\n  \
    \  return floor(number * pow(10.0, Double(-Double(log10(number)))))\n        \
    \                  ^~~\n/tmp/tmpn7d7s_8o.swift:11:52: error: cannot find 'log10'\
    \ in scope\n    return floor(number * pow(10.0, Double(-Double(log10(number)))))\n\
    \                                                   ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let parts: [(Double, Double)] = (\n        (number\
    \ - floorf(number), number),\n        (number, floor(number)),\n        (floor(number),\
    \ floor(number) - floorf(number))\n    )\n\n    let (integer, decimal) = parts.last!\n\
    \    return decimal + trunc(integer) * pow(10.0, floor(log10(trunc(integer))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp0mtyed0k.swift:10:19: error: cannot find 'floorf' in scope\n  \
    \      (number - floorf(number), number),\n                  ^~~~~~\n/tmp/tmp0mtyed0k.swift:11:18:\
    \ error: cannot find 'floor' in scope\n        (number, floor(number)),\n    \
    \             ^~~~~\n/tmp/tmp0mtyed0k.swift:12:10: error: cannot find 'floor'\
    \ in scope\n        (floor(number), floor(number) - floorf(number))\n        \
    \ ^~~~~\n/tmp/tmp0mtyed0k.swift:12:25: error: cannot find 'floor' in scope\n \
    \       (floor(number), floor(number) - floorf(number))\n                    \
    \    ^~~~~\n/tmp/tmp0mtyed0k.swift:12:41: error: cannot find 'floorf' in scope\n\
    \        (floor(number), floor(number) - floorf(number))\n                   \
    \                     ^~~~~~\n/tmp/tmp0mtyed0k.swift:16:22: error: cannot find\
    \ 'trunc' in scope\n    return decimal + trunc(integer) * pow(10.0, floor(log10(trunc(integer))))\n\
    \                     ^~~~~\n/tmp/tmp0mtyed0k.swift:16:39: error: cannot find\
    \ 'pow' in scope\n    return decimal + trunc(integer) * pow(10.0, floor(log10(trunc(integer))))\n\
    \                                      ^~~\n/tmp/tmp0mtyed0k.swift:16:49: error:\
    \ cannot find 'floor' in scope\n    return decimal + trunc(integer) * pow(10.0,\
    \ floor(log10(trunc(integer))))\n                                            \
    \    ^~~~~\n/tmp/tmp0mtyed0k.swift:16:55: error: cannot find 'log10' in scope\n\
    \    return decimal + trunc(integer) * pow(10.0, floor(log10(trunc(integer))))\n\
    \                                                      ^~~~~\n/tmp/tmp0mtyed0k.swift:16:61:\
    \ error: cannot find 'trunc' in scope\n    return decimal + trunc(integer) * pow(10.0,\
    \ floor(log10(trunc(integer))))\n                                            \
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return number % 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmtmc6yrl.swift:9:19: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    return number % 1\n           \
    \       ^\nSwift.%:2:13: note: '%' has been explicitly marked unavailable here\n\
    public func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n       \
    \     ^\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = truncate_fraction(number)\n    let whole\
    \ = truncate_whole(number)\n    return whole + fraction\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmptdwn2z82.swift:9:20: error: cannot find 'truncate_fraction' in\
    \ scope\n    let fraction = truncate_fraction(number)\n                   ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmptdwn2z82.swift:10:17: error: cannot find 'truncate_whole' in scope\n \
    \   let whole = truncate_whole(number)\n                ^~~~~~~~~~~~~~\n/tmp/tmptdwn2z82.swift:11:18:\
    \ error: cannot convert return expression of type 'String' to return type 'Double'\n\
    \    return whole + fraction\n           ~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029176
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: -1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0.0 {\n        return 0.0\n    }\n    \n\
    \    var remainder = number\n    var decimal: Double = 0.0\n    while number >\
    \ 0.0 {\n        remainder /= 10.0\n        decimal += remainder\n    }\n    return\
    \ decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660029182
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var result: Double = 0\n    var part: Double = 0\n\n\
    \    var decimalPart = floor(number - truncate(number, &part))\n\n    while decimalPart\
    \ > 1 || decimalPart == 0 {\n        decimalPart /= 10\n        result += part\n\
    \        part /= 10\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmph_kxt9jy.swift:12:23: error: cannot find 'floor' in scope\n   \
    \ var decimalPart = floor(number - truncate(number, &part))\n                \
    \      ^~~~~\n/tmp/tmph_kxt9jy.swift:12:38: error: cannot find 'truncate' in scope\n\
    \    var decimalPart = floor(number - truncate(number, &part))\n             \
    \                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let intPart = (number / 10).truncatingRemainder(dividingBy:\
    \ 10)\n    return Double(intPart * 10 + 0.5)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpyqoaxa_5/tmpyqoaxa_5.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08e221cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08e1f13b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08e1f13988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08e1f127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyqoaxa_5                        0x000055e516c862f5 <unavailable> + 4853

    5    libc.so.6                          0x00002b08e2408460 __libc_start_main +
    245

    6    tmpyqoaxa_5                        0x000055e516c85f99 <unavailable> + 3993

    '
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncating(to: 0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpd82_reo6.swift:9:27: error: value of type 'Double' has no member\
    \ 'truncating'\n    return Double(number).truncating(to: 0)\n           ~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 || number >= 1.0 {\n        return number\n\
    \    }\n    var integer = Int(number)\n    var decimal = number - Double(integer)\n\
    \    while decimal < 1.0 {\n        integer += 1\n        decimal = number - Double(integer)\n\
    \    }\n    return Double(integer)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpq_fp9xuc/tmpq_fp9xuc.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba8753cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8750c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8750c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8750c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq_fp9xuc                        0x0000562d24dcd255 <unavailable> + 4693

    5    libc.so.6                          0x00002ba8755b6460 __libc_start_main +
    245

    6    tmpq_fp9xuc                        0x0000562d24dccef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var decimalPart: Double = 0\n    var integerPart: Double\
    \ = 0\n    var remainder: Double\n\n    let decimalPart = number % 1\n    integerPart\
    \ = (number - decimalPart).truncatingRemainder(dividingBy: 1)\n    remainder =\
    \ number % 1\n\n    return integerPart + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmptt2ix4ed.swift:13:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmptt2ix4ed.swift:13:9: error: invalid redeclaration of 'decimalPart'\n\
    \    let decimalPart = number % 1\n        ^\n/tmp/tmptt2ix4ed.swift:9:9: note:\
    \ 'decimalPart' previously declared here\n    var decimalPart: Double = 0\n  \
    \      ^\n/tmp/tmptt2ix4ed.swift:15:24: error: '%' is unavailable: For floating\
    \ point numbers use truncatingRemainder instead\n    remainder = number % 1\n\
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let integerPart = (Double(number).truncatingRemainder(dividingBy:\
    \ 1.0).rounded(.towardZero))\n    let decimalPart = (Double(number).truncatingRemainder(dividingBy:\
    \ 10.0).rounded(.towardZero))\n    return Double(integerPart) + Double(decimalPart)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ceo2Ap/tmp0pv9ns3w-1.o:tmp0pv9ns3w-1.o:function $s11tmp0pv9ns3w15truncate_number0C0S2d_tF:
    error: undefined reference to '''
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return (number - truncate_number(Double(number))) /\
    \ truncate_number(Double(1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzckju4eu.swift:9:38: error: missing argument label 'number:' in\
    \ call\n    return (number - truncate_number(Double(number))) / truncate_number(Double(1))\n\
    \                                     ^\n                                    \
    \ number: \n/tmp/tmpzckju4eu.swift:9:73: error: missing argument label 'number:'\
    \ in call\n    return (number - truncate_number(Double(number))) / truncate_number(Double(1))\n\
    \                                                                        ^\n \
    \                                                                       number:\
    \ \n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // Get integer part and decimals part\n    var intPart:\
    \ Double = floor(number)\n    let decimalsPart = number - intPart\n    \n    //\
    \ Return integer part\n    return intPart\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpctizkswi.swift:10:27: error: cannot find 'floor' in scope\n   \
    \ var intPart: Double = floor(number)\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = ceil(number.toInt64()) - number.toInt64()\n\
    \    return number - Double(decimalPart)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpb779dgzu.swift:9:23: error: cannot find 'ceil' in scope\n    let\
    \ decimalPart = ceil(number.toInt64()) - number.toInt64()\n                  \
    \    ^~~~\n/tmp/tmpb779dgzu.swift:9:35: error: value of type 'Double' has no member\
    \ 'toInt64'\n    let decimalPart = ceil(number.toInt64()) - number.toInt64()\n\
    \                           ~~~~~~ ^~~~~~~\n/tmp/tmpb779dgzu.swift:9:55: error:\
    \ value of type 'Double' has no member 'toInt64'\n    let decimalPart = ceil(number.toInt64())\
    \ - number.toInt64()\n                                               ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number == 0.0 {\n        return number\n    }\n\
    \    var decimals = Int(number.toInt64() / 10.0)\n    return number.toDouble()\
    \ / 10.0 - decimals.toDouble()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpskleoeyq.swift:12:31: error: value of type 'Double' has no member\
    \ 'toInt64'\n    var decimals = Int(number.toInt64() / 10.0)\n               \
    \        ~~~~~~ ^~~~~~~\n/tmp/tmpskleoeyq.swift:13:19: error: value of type 'Double'\
    \ has no member 'toDouble'\n    return number.toDouble() / 10.0 - decimals.toDouble()\n\
    \           ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let sign = Double.signbit(number)\n    let exp = (Double.exponent(number)\
    \ + 1.0).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.exponentBitCount)))\n\
    \    let fraction = Double(UInt64(Double.bitPattern: Double.exactlyOnesComplement(number)).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.exponentBitCount)))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))\n    let digits = Double(UInt64(Double.bitPattern:\
    \ Double.exactlyOnesComplement(number)).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.decimalBitCount)))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))\n\n    return Double(exactlyOnesComplement(number\
    \ - Double.one).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.decimalBitCount)))\
    \ * (10 ** Double(Double.decimalBitCount)).pow(Double(Double.exponentBitCount))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) + Double(exactlyOnesComplement(Double.one).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) * (10 ** Double(Double.decimalBitCount)).pow(Double(Double.exponentBitCount))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) * (10 ** Double(Double.exponentBitCount)).pow(Double(Double.decimalBitCount))).truncatingRemainder(dividingBy:\
    \ 10).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.exponentBitCount)))\
    \ * (10 ** Double(Double.exponentBitCount)).pow(Double(Double.decimalBitCount)))\
    \ * fraction + Double(exactlyOnesComplement(Double.one).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) * (10 ** Double(Double.decimalBitCount)).pow(Double(Double.exponentBitCount)))\
    \ * digits).truncatingRemainder(dividingBy: 10).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.exponentBitCount))) * (10 ** Double(Double.\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp79hv33u7.swift:11:51: error: expected ',' separator\n    let fraction\
    \ = Double(UInt64(Double.bitPattern: Double.exactlyOnesComplement(number)).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.exponentBitCount)))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))\n                          \
    \                        ^\n                                                 \
    \ ,\n/tmp/tmp79hv33u7.swift:11:51: error: expected expression in list of expressions\n\
    \    let fraction = Double(UInt64(Double.bitPattern: Double.exactlyOnesComplement(number)).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.exponentBitCount)))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))\n                          \
    \                        ^\n/tmp/tmp79hv33u7.swift:12:49: error: expected ','\
    \ separator\n    let digits = Double(UInt64(Double.bitPattern: Double.exactlyOnesComplement(number)).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))\n                          \
    \                      ^\n                                                ,\n\
    /tmp/tmp79hv33u7.swift:12:49: error: expected expression in list of expressions\n\
    \    let digits = Double(UInt64(Double.bitPattern: Double.exactlyOnesComplement(number)).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount)))\n                          \
    \                      ^\n/tmp/tmp79hv33u7.swift:14:660: error: consecutive statements\
    \ on a line must be separated by ';'\n    return Double(exactlyOnesComplement(number\
    \ - Double.one).truncatingRemainder(dividingBy: Double(10).pow(Double(Double.decimalBitCount)))\
    \ * (10 ** Double(Double.decimalBitCount)).pow(Double(Double.exponentBitCount))).truncatingRemainder(dividingBy:\
    \ Double(10).pow(Double(Double.decimalBitCount))) + Double(exactlyOnesComplement(Double.one).truncatingRemainder(d"
  stdout: ''
  timestamp: 1660029199
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var result = number\n    if number > 0.0 {\n      \
    \  let remainder = Double(floor(number))\n        result = number - remainder\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpa7le73cy.swift:11:32: error: cannot find 'floor' in scope\n   \
    \     let remainder = Double(floor(number))\n                               ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(trunc(Double(number)))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpix49zje3.swift:9:19: error: cannot find 'trunc' in scope\n    return\
    \ Double(trunc(Double(number)))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart: Double = abs(number) % 1\n    let\
    \ integerPart: Double = Double(abs(number).truncatingRemainder(dividingBy: 1)\
    \ + 1)\n    return truncate_number(decimalPart) + integerPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7vbabpvt.swift:9:43: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let decimalPart: Double = abs(number)\
    \ % 1\n                                          ^\nSwift.%:2:13: note: '%' has\
    \ been explicitly marked unavailable here\npublic func % <T>(lhs: T, rhs: T) ->\
    \ T where T : BinaryFloatingPoint\n            ^\n/tmp/tmp7vbabpvt.swift:11:28:\
    \ error: missing argument label 'number:' in call\n    return truncate_number(decimalPart)\
    \ + integerPart\n                           ^\n                           number:\
    \ \n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number_with_precision(number, Float64())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpnc4ge5q1.swift:9:12: error: cannot find 'truncate_number_with_precision'\
    \ in scope\n    return truncate_number_with_precision(number, Float64())\n   \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return number - truncate_number(Double(number))\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcprrg_p1.swift:9:37: error: missing argument label 'number:' in\
    \ call\n    return number - truncate_number(Double(number))\n                \
    \                    ^\n                                    number: \n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  let (integer, decimals) = truncate_number_to_int(number)\n\
    \  return integer + number * Double(pow(10, Double(decimals) / Double(10)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp1w8b6g3y.swift:9:29: error: cannot find 'truncate_number_to_int'\
    \ in scope\n  let (integer, decimals) = truncate_number_to_int(number)\n     \
    \                       ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1w8b6g3y.swift:10:36:\
    \ error: cannot find 'pow' in scope\n  return integer + number * Double(pow(10,\
    \ Double(decimals) / Double(10)))\n                                   ^~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let integerPart = ceil(number.toInt64() / Double(100))\n\
    \    let decimalPart = number.toInt64() % Double(100)\n    return integerPart\
    \ * Double(100) + decimalPart\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpl_8xpvja.swift:9:23: error: cannot find 'ceil' in scope\n    let\
    \ integerPart = ceil(number.toInt64() / Double(100))\n                      ^~~~\n\
    /tmp/tmpl_8xpvja.swift:9:35: error: value of type 'Double' has no member 'toInt64'\n\
    \    let integerPart = ceil(number.toInt64() / Double(100))\n                \
    \           ~~~~~~ ^~~~~~~\n/tmp/tmpl_8xpvja.swift:10:30: error: value of type\
    \ 'Double' has no member 'toInt64'\n    let decimalPart = number.toInt64() % Double(100)\n\
    \                      ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let value = Double(trunc(number))\n    return value\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpsx9bwes2.swift:9:24: error: cannot find 'trunc' in scope\n    let\
    \ value = Double(trunc(number))\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number * pow(10.0, ceil(log10(number))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpks4bg5er.swift:9:28: error: cannot find 'pow' in scope\n    return\
    \ Double(number * pow(10.0, ceil(log10(number))))\n                          \
    \ ^~~\n/tmp/tmpks4bg5er.swift:9:38: error: cannot find 'ceil' in scope\n    return\
    \ Double(number * pow(10.0, ceil(log10(number))))\n                          \
    \           ^~~~\n/tmp/tmpks4bg5er.swift:9:43: error: cannot find 'log10' in scope\n\
    \    return Double(number * pow(10.0, ceil(log10(number))))\n                \
    \                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\treturn truncate_number(number.truncatingRemainder(dividingBy:\
    \ 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqi01bnfj.swift:9:25: error: missing argument label 'number:' in\
    \ call\n        return truncate_number(number.truncatingRemainder(dividingBy:\
    \ 1))\n                               ^\n                               number:\
    \ \n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    number -= floor((number + 1) * 0.5)\n    return number\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpo4szx6we.swift:9:15: error: cannot find 'floor' in scope\n    number\
    \ -= floor((number + 1) * 0.5)\n              ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let intPart = Int(round(number))\n    return Double(intPart)\
    \ / number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp76wwamiz.swift:9:23: error: cannot find 'round' in scope\n    let\
    \ intPart = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double((number - truncate_number(Float(number))).rounded())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp5xny19_t.swift:9:45: error: missing argument label 'number:' in\
    \ call\n    return Double((number - truncate_number(Float(number))).rounded())\n\
    \                                            ^\n                             \
    \               number: \n/tmp/tmp5xny19_t.swift:9:45: error: cannot convert value\
    \ of type 'Float' to expected argument type 'Double'\n    return Double((number\
    \ - truncate_number(Float(number))).rounded())\n                             \
    \               ^\n                                            Double(      )\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // Float to Int\n    let intPart = Int(round(number))\n\
    \    // Decimal part of intPart\n    let decimalPart = number - Double(intPart)\n\
    \    return Double(intPart) / Double(10) + decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpv1khdya_.swift:10:23: error: cannot find 'round' in scope\n   \
    \ let intPart = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let result = number % 1\n    if abs(result) > 10 {\n\
    \        return truncate_number(Double(number)/10.0)\n    } else {\n        return\
    \ result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_d_53dct.swift:9:25: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let result = number % 1\n     \
    \                   ^\nSwift.%:2:13: note: '%' has been explicitly marked unavailable\
    \ here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp_d_53dct.swift:11:32: error: missing argument label 'number:'\
    \ in call\n        return truncate_number(Double(number)/10.0)\n             \
    \                  ^\n                               number: \n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let negativeSign = number < 0\n    if negativeSign\
    \ {\n        number = -number\n    }\n\n    var integerPart = 0.0\n    var decimalPart\
    \ = 0.0\n    while number >= Double.greatestFiniteMagnitude {\n        let remainder\
    \ = number % Double(Double.greatestFiniteMagnitude)\n        integerPart += Double(trunc(log10(Double(number)/Double(Double.greatestFiniteMagnitude))))\
    \ * Double(Double.greatestFiniteMagnitude)\n        number = Double(number / Double(Double.greatestFiniteMagnitude))\n\
    \        decimalPart += remainder * Double(Double.greatestFiniteMagnitude)\n \
    \   }\n    if number >= 0 {\n        return integerPart + decimalPart\n    }\n\
    \    else {\n        return Double(trunc(log10(Double(number)/Double(Double.leastFiniteMagnitude))))\
    \ * Double(Double.leastFiniteMagnitude) + decimalPart\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpt7kngv2f.swift:11:9: error: cannot assign to value: 'number' is\
    \ a 'let' constant\n        number = -number\n        ^~~~~~\n/tmp/tmpt7kngv2f.swift:17:32:\
    \ error: '%' is unavailable: For floating point numbers use truncatingRemainder\
    \ instead\n        let remainder = number % Double(Double.greatestFiniteMagnitude)\n\
    \                               ^\nSwift.%:2:13: note: '%' has been explicitly\
    \ marked unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpt7kngv2f.swift:18:31: error: cannot find 'trunc' in scope\n\
    \        integerPart += Double(trunc(log10(Double(number)/Double(Double.greatestFiniteMagnitude))))\
    \ * Double(Double.greatestFiniteMagnitude)\n                              ^~~~~\n\
    /tmp/tmpt7kngv2f.swift:18:37: error: cannot find 'log10' in scope\n        integerPart\
    \ += Double(trunc(log10(Double(number)/Double(Double.greatestFiniteMagnitude))))\
    \ * Double(Double.greatestFiniteMagnitude)\n                                 \
    \   ^~~~~\n/tmp/tmpt7kngv2f.swift:19:9: error: cannot assign to value: 'number'\
    \ is a 'let' constant\n        number = Double(number / Double(Double.greatestFiniteMagnitude))\n\
    \        ^~~~~~\n/tmp/tmpt7kngv2f.swift:26:23: error: cannot find 'trunc' in scope\n\
    \        return Double(trunc(log10(Double(number)/Double(Double.leastFiniteMagnitude))))\
    \ * Double(Double.leastFiniteMagnitude) + decimalPart\n                      ^~~~~\n\
    /tmp/tmpt7kngv2f.swift:26:29: error: cannot find 'log10' in scope\n        return\
    \ Double(trunc(log10(Double(number)/Double(Double.leastFiniteMagnitude)))) * Double(Double.leastFiniteMagnitude)\
    \ + decimalPart\n                            ^~~~~\n/tmp/tmpt7kngv2f.swift:26:64:\
    \ error: type 'Double' has no member 'leastFiniteMagnitude'\n        return Double(trunc(log10(Double(number)/Double(Double.leastFiniteMagnitude))))\
    \ * Double(Double.leastFiniteMagnitude) + decimalPart\n                      \
    \                                  ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt7kngv2f.swift:26:105:\
    \ error: type 'Double' has no member 'leastFiniteMagnitude'\n     "
  stdout: ''
  timestamp: 1660029180
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  return truncate_number(number: number, scale: 0)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp5v1hcjy3.swift:9:49: error: extra argument 'scale' in call\n  return\
    \ truncate_number(number: number, scale: 0)\n                        ~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let divisor = pow(10, (Double(log10(number)) / Double(10)))\n\
    \    return round(number * divisor)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpi33n4_dq.swift:9:19: error: cannot find 'pow' in scope\n    let\
    \ divisor = pow(10, (Double(log10(number)) / Double(10)))\n                  ^~~\n\
    /tmp/tmpi33n4_dq.swift:9:35: error: cannot find 'log10' in scope\n    let divisor\
    \ = pow(10, (Double(log10(number)) / Double(10)))\n                          \
    \        ^~~~~\n/tmp/tmpi33n4_dq.swift:10:12: error: cannot find 'round' in scope\n\
    \    return round(number * divisor)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let x = number\n    let negative = x < 0\n\n    if\
    \ negative {\n        return -number\n    }\n    \n    let fractionalPart = x.truncatingRemainder(dividingBy:\
    \ 1)\n    \n    if fractionalPart == 0 {\n        return number // this number\
    \ is already an integer\n    }\n    \n    return fractionalPart\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpe_9l9wlh/tmpe_9l9wlh.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a1b4cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a1b1c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a1b1c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a1b1c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe_9l9wlh                        0x000055e60caa83be <unavailable> + 5054

    5    libc.so.6                          0x00002b5a1b6b7460 __libc_start_main +
    245

    6    tmpe_9l9wlh                        0x000055e60caa7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var result = number\n    var exponent = Decimal()\n\
    \    while exponent > Decimal.Zero\n        && result < 1\n    {\n        result\
    \ *= 10\n        exponent = exponent - Decimal(1)\n    }\n    return result /\
    \ Decimal(1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpqr86_ers.swift:10:20: error: cannot find 'Decimal' in scope\n \
    \   var exponent = Decimal()\n                   ^~~~~~~\n/tmp/tmpqr86_ers.swift:11:22:\
    \ error: cannot find 'Decimal' in scope\n    while exponent > Decimal.Zero\n \
    \                    ^~~~~~~\n/tmp/tmpqr86_ers.swift:15:31: error: cannot find\
    \ 'Decimal' in scope\n        exponent = exponent - Decimal(1)\n             \
    \                 ^~~~~~~\n/tmp/tmpqr86_ers.swift:17:21: error: cannot find 'Decimal'\
    \ in scope\n    return result / Decimal(1)\n                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let wholeNumber = truncate_double(number: number)\n\
    \    return floor(wholeNumber) - wholeNumber\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpuhinjp9j.swift:9:23: error: cannot find 'truncate_double' in scope\n\
    \    let wholeNumber = truncate_double(number: number)\n                     \
    \ ^~~~~~~~~~~~~~~\n/tmp/tmpuhinjp9j.swift:10:12: error: cannot find 'floor' in\
    \ scope\n    return floor(wholeNumber) - wholeNumber\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\treturn ceil(number * 10) / 10.0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp_38kcn35.swift:9:9: error: cannot find 'ceil' in scope\n      \
    \  return ceil(number * 10) / 10.0\n               ^~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(round(number).truncatingRemainder(dividingBy:\
    \ 1.0)) / 1.0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp9o0ksz3e.swift:9:19: error: cannot find 'round' in scope\n    return\
    \ Double(round(number).truncatingRemainder(dividingBy: 1.0)) / 1.0\n         \
    \         ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var digits = floor(log2(number))\n    var integralPart\
    \ = floor(number / pow(10.0, Double(digits)))\n    var decimalPart = floor(number\
    \ - integralPart * pow(10.0, Double(digits)))\n    return decimalPart\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpq9ssctay.swift:9:18: error: cannot find 'floor' in scope\n    var\
    \ digits = floor(log2(number))\n                 ^~~~~\n/tmp/tmpq9ssctay.swift:9:24:\
    \ error: cannot find 'log2' in scope\n    var digits = floor(log2(number))\n \
    \                      ^~~~\n/tmp/tmpq9ssctay.swift:10:24: error: cannot find\
    \ 'floor' in scope\n    var integralPart = floor(number / pow(10.0, Double(digits)))\n\
    \                       ^~~~~\n/tmp/tmpq9ssctay.swift:10:39: error: cannot find\
    \ 'pow' in scope\n    var integralPart = floor(number / pow(10.0, Double(digits)))\n\
    \                                      ^~~\n/tmp/tmpq9ssctay.swift:11:23: error:\
    \ cannot find 'floor' in scope\n    var decimalPart = floor(number - integralPart\
    \ * pow(10.0, Double(digits)))\n                      ^~~~~\n/tmp/tmpq9ssctay.swift:11:53:\
    \ error: cannot find 'pow' in scope\n    var decimalPart = floor(number - integralPart\
    \ * pow(10.0, Double(digits)))\n                                             \
    \       ^~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  var intPart: Double = number\n  var decimalPart: Double\
    \ = number\n\n  while intPart.isMultiple(10) {\n    intPart = intPart.truncatingRemainder(10)\n\
    \    decimalPart = decimalPart.truncatingRemainder(10)\n  }\n  return decimalPart\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpt3o7icwv.swift:12:17: error: value of type 'Double' has no member\
    \ 'isMultiple'\n  while intPart.isMultiple(10) {\n        ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpt3o7icwv.swift:13:43: error: missing argument label 'dividingBy:' in call\n\
    \    intPart = intPart.truncatingRemainder(10)\n                             \
    \             ^\n                                          dividingBy: \n/tmp/tmpt3o7icwv.swift:14:51:\
    \ error: missing argument label 'dividingBy:' in call\n    decimalPart = decimalPart.truncatingRemainder(10)\n\
    \                                                  ^\n                       \
    \                           dividingBy: \n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let quotient = trunc(number)\n    let decimal = number\
    \ - quotient\n    return quotient + decimal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp0cyuq2la.swift:9:20: error: cannot find 'trunc' in scope\n    let\
    \ quotient = trunc(number)\n                   ^~~~~\n/tmp/tmp0cyuq2la.swift:11:21:\
    \ error: cannot convert return expression of type 'String' to return type 'Double'\n\
    \    return quotient + decimal\n           ~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\treturn truncate_number_helper(number, 0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpc25_xf4v.swift:9:9: error: cannot find 'truncate_number_helper'\
    \ in scope\n        return truncate_number_helper(number, 0)\n               ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let result = floor(number + 0.5)\n    return result\
    \ / Int64(Int64.max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzdojcz81.swift:9:18: error: cannot find 'floor' in scope\n    let\
    \ result = floor(number + 0.5)\n                 ^~~~~\n/tmp/tmpzdojcz81.swift:10:19:\
    \ error: cannot convert return expression of type 'Int64' to return type 'Double'\n\
    \    return result / Int64(Int64.max)\n           ~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \           Double(                  )\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var result: Double = 0\n    var sign: Bool = false\n\
    \    if number < 0 {\n        sign = true\n        number = -number\n    }\n \
    \   if number < 10 {\n        result = (number / 10) + 0.5\n    } else {\n   \
    \     result = (number / 10) + 1\n    }\n    if sign {\n        result = -result\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmptrjo5wud.swift:13:9: error: cannot assign to value: 'number' is\
    \ a 'let' constant\n        number = -number\n        ^~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(floor(number * 100))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp1bbk9ud4.swift:9:19: error: cannot find 'floor' in scope\n    return\
    \ Double(floor(number * 100))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimalPart = ceil(log10(number))\n    return trunc(number\
    \ * pow(10.0, Double(decimalPart)))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp3d3mz6c3.swift:9:23: error: cannot find 'ceil' in scope\n    let\
    \ decimalPart = ceil(log10(number))\n                      ^~~~\n/tmp/tmp3d3mz6c3.swift:9:28:\
    \ error: cannot find 'log10' in scope\n    let decimalPart = ceil(log10(number))\n\
    \                           ^~~~~\n/tmp/tmp3d3mz6c3.swift:10:12: error: cannot\
    \ find 'trunc' in scope\n    return trunc(number * pow(10.0, Double(decimalPart)))\n\
    \           ^~~~~\n/tmp/tmp3d3mz6c3.swift:10:27: error: cannot find 'pow' in scope\n\
    \    return trunc(number * pow(10.0, Double(decimalPart)))\n                 \
    \         ^~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\treturn Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return floor(number * 100.0) / 100\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphbu4g0e0.swift:9:12: error: cannot find 'floor' in scope\n    return\
    \ floor(number * 100.0) / 100\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // if number is NaN return NaN\n    if fma(number,\
    \ 1, number) == number {\n        return NaN\n    }\n\n    let mantissa = Double(fma(number,\
    \ 1 / Double(10), 1))\n    let integer = Double(trunc(number))\n    // return\
    \ integer part and decimal part (rounded to 2 decimal places)\n    return round(Double(trunc(mantissa)\
    \ * 10 + integer)) * 10 / 10\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpjx74_m_8.swift:10:8: error: cannot find 'fma' in scope\n    if\
    \ fma(number, 1, number) == number {\n       ^~~\n/tmp/tmpjx74_m_8.swift:11:16:\
    \ error: cannot find 'NaN' in scope\n        return NaN\n               ^~~\n\
    /tmp/tmpjx74_m_8.swift:14:27: error: cannot find 'fma' in scope\n    let mantissa\
    \ = Double(fma(number, 1 / Double(10), 1))\n                          ^~~\n/tmp/tmpjx74_m_8.swift:15:26:\
    \ error: cannot find 'trunc' in scope\n    let integer = Double(trunc(number))\n\
    \                         ^~~~~\n/tmp/tmpjx74_m_8.swift:17:12: error: cannot find\
    \ 'round' in scope\n    return round(Double(trunc(mantissa) * 10 + integer)) *\
    \ 10 / 10\n           ^~~~~\n/tmp/tmpjx74_m_8.swift:17:25: error: cannot find\
    \ 'trunc' in scope\n    return round(Double(trunc(mantissa) * 10 + integer)) *\
    \ 10 / 10\n                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(number * 1e10) / 1e10\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp3aijnwe.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(number * 1e10) / 1e10\n           ^~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  return ceil(number * Double(Int64(Int64.max) / Double(Int64(Int64.max)\
    \ - Int64(Int64(Int64(Double(number))) + 1))) / Double(Int64(Int64.max))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp02q2ei4f.swift:10:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp02q2ei4f.swift:9:14: note: to match this opening '('\n  return ceil(number\
    \ * Double(Int64(Int64.max) / Double(Int64(Int64.max) - Int64(Int64(Int64(Double(number)))\
    \ + 1))) / Double(Int64(Int64.max))\n             ^\n/tmp/tmp02q2ei4f.swift:9:10:\
    \ error: cannot find 'ceil' in scope\n  return ceil(number * Double(Int64(Int64.max)\
    \ / Double(Int64(Int64.max) - Int64(Int64(Int64(Double(number))) + 1))) / Double(Int64(Int64.max))\n\
    \         ^~~~\n/tmp/tmp02q2ei4f.swift:9:10: error: the compiler is unable to\
    \ type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n  return ceil(number * Double(Int64(Int64.max)\
    \ / Double(Int64(Int64.max) - Int64(Int64(Int64(Double(number))) + 1))) / Double(Int64(Int64.max))\n\
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029196
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return (number / 10).floor()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpymg7e4ts.swift:9:26: error: value of type 'Double' has no member\
    \ 'floor'\n    return (number / 10).floor()\n           ~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let (integer, decimal) = log10f(number)\n    let fraction\
    \ = number - Double(integer) * Double(pow(10.0, Double(decimal)))\n    return\
    \ fraction / pow(10.0, Double(decimal))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp1rmf0bjx.swift:9:30: error: cannot find 'log10f' in scope\n   \
    \ let (integer, decimal) = log10f(number)\n                             ^~~~~~\n\
    /tmp/tmp1rmf0bjx.swift:10:54: error: cannot find 'pow' in scope\n    let fraction\
    \ = number - Double(integer) * Double(pow(10.0, Double(decimal)))\n          \
    \                                           ^~~\n/tmp/tmp1rmf0bjx.swift:11:23:\
    \ error: cannot find 'pow' in scope\n    return fraction / pow(10.0, Double(decimal))\n\
    \                      ^~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // http://stackoverflow.com/questions/307230/how-do-i-round-a-number-to-the-nearest-n-decimal-places-in-swift-for-example\n\
    \    let scaledNumber = round(number * pow(10.0, Double(floor(log10(number))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))) // use floor to get rid of integer\
    \ part of number, then log base 10 to get the scale factor\n    return scaledNumber\
    \ / pow(10.0, Double(floor(log10(scaledNumber))))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpclk0630h.swift:10:24: error: cannot find 'round' in scope\n   \
    \ let scaledNumber = round(number * pow(10.0, Double(floor(log10(number)))) /\
    \ pow(10.0, Double(floor(log10(abs(number)))))) // use floor to get rid of integer\
    \ part of number, then log base 10 to get the scale factor\n                 \
    \      ^~~~~\n/tmp/tmpclk0630h.swift:10:39: error: cannot find 'pow' in scope\n\
    \    let scaledNumber = round(number * pow(10.0, Double(floor(log10(number))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))) // use floor to get rid of integer\
    \ part of number, then log base 10 to get the scale factor\n                 \
    \                     ^~~\n/tmp/tmpclk0630h.swift:10:56: error: cannot find 'floor'\
    \ in scope\n    let scaledNumber = round(number * pow(10.0, Double(floor(log10(number))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))) // use floor to get rid of integer\
    \ part of number, then log base 10 to get the scale factor\n                 \
    \                                      ^~~~~\n/tmp/tmpclk0630h.swift:10:62: error:\
    \ cannot find 'log10' in scope\n    let scaledNumber = round(number * pow(10.0,\
    \ Double(floor(log10(number)))) / pow(10.0, Double(floor(log10(abs(number))))))\
    \ // use floor to get rid of integer part of number, then log base 10 to get the\
    \ scale factor\n                                                             ^~~~~\n\
    /tmp/tmpclk0630h.swift:10:81: error: cannot find 'pow' in scope\n    let scaledNumber\
    \ = round(number * pow(10.0, Double(floor(log10(number)))) / pow(10.0, Double(floor(log10(abs(number))))))\
    \ // use floor to get rid of integer part of number, then log base 10 to get the\
    \ scale factor\n                                                             \
    \                   ^~~\n/tmp/tmpclk0630h.swift:10:98: error: cannot find 'floor'\
    \ in scope\n    let scaledNumber = round(number * pow(10.0, Double(floor(log10(number))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))) // use floor to get rid of integer\
    \ part of number, then log base 10 to get the scale factor\n                 \
    \                                                "
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(Double(number) / Double(10)).rounded(.towardZero)\
    \ * Double(10)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp4a_3pasp.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(Double(number) / Double(10)).rounded(.towardZero) * Double(10)\n      \
    \     ^~~~\n/tmp/tmp4a_3pasp.swift:9:55: error: cannot infer contextual base in\
    \ reference to member 'towardZero'\n    return ceil(Double(number) / Double(10)).rounded(.towardZero)\
    \ * Double(10)\n                                                     ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let truncatedNumber = number < 0 ? -number + 0.0 :\
    \ number + 0.0;\n    return truncatedNumber / pow(10.0, Double(floor(log10(abs(truncatedNumber)))\
    \ + 1));\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmprwwln163.swift:10:30: error: cannot find 'pow' in scope\n    return\
    \ truncatedNumber / pow(10.0, Double(floor(log10(abs(truncatedNumber))) + 1));\n\
    \                             ^~~\n/tmp/tmprwwln163.swift:10:47: error: cannot\
    \ find 'floor' in scope\n    return truncatedNumber / pow(10.0, Double(floor(log10(abs(truncatedNumber)))\
    \ + 1));\n                                              ^~~~~\n/tmp/tmprwwln163.swift:10:53:\
    \ error: cannot find 'log10' in scope\n    return truncatedNumber / pow(10.0,\
    \ Double(floor(log10(abs(truncatedNumber))) + 1));\n                         \
    \                           ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let factor: Double = pow(10.0, Double(log10(abs(number))))\n\
    \    return (number / factor).rounded(.towardZero) * factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpghv0o68a.swift:9:26: error: cannot find 'pow' in scope\n    let\
    \ factor: Double = pow(10.0, Double(log10(abs(number))))\n                   \
    \      ^~~\n/tmp/tmpghv0o68a.swift:9:43: error: cannot find 'log10' in scope\n\
    \    let factor: Double = pow(10.0, Double(log10(abs(number))))\n            \
    \                              ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number <= 0.0 {\n        return 0.0\n    }\n   \
    \ let (integer, decimal) = Double.trunc(number)\n    return Double(integer + decimal)\
    \ / Double(10)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpvhnr788t.swift:12:37: error: type 'Double' has no member 'trunc'\n\
    \    let (integer, decimal) = Double.trunc(number)\n                         \
    \    ~~~~~~ ^~~~~\n/tmp/tmpvhnr788t.swift:13:12: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n    return Double(integer\
    \ + decimal) / Double(10)\n           ^\n/tmp/tmpvhnr788t.swift:13:12: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return Double(integer + decimal) / Double(10)\n           ^\n           (  \
    \                       ?? <#default value#>)\n/tmp/tmpvhnr788t.swift:13:12: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    return Double(integer + decimal) / Double(10)\n           ^\n           \
    \                         !\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let divisor = pow(10.0, ceil(log10(number)))\n    return\
    \ Double(number) / divisor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmponifyb5r.swift:9:19: error: cannot find 'pow' in scope\n    let\
    \ divisor = pow(10.0, ceil(log10(number)))\n                  ^~~\n/tmp/tmponifyb5r.swift:9:29:\
    \ error: cannot find 'ceil' in scope\n    let divisor = pow(10.0, ceil(log10(number)))\n\
    \                            ^~~~\n/tmp/tmponifyb5r.swift:9:34: error: cannot\
    \ find 'log10' in scope\n    let divisor = pow(10.0, ceil(log10(number)))\n  \
    \                               ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let integerPart = Int(trunc(number))\n    let decimalPart\
    \ = number - trunc(number)\n    return decimalPart\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpch1_vrqo.swift:9:27: error: cannot find 'trunc' in scope\n    let\
    \ integerPart = Int(trunc(number))\n                          ^~~~~\n/tmp/tmpch1_vrqo.swift:10:32:\
    \ error: cannot find 'trunc' in scope\n    let decimalPart = number - trunc(number)\n\
    \                               ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(Int64(number).truncatingRemainder(dividingBy:\
    \ 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpncgwqx53.swift:9:33: error: value of type 'Int64' has no member\
    \ 'truncatingRemainder'\n    return Double(Int64(number).truncatingRemainder(dividingBy:\
    \ 1))\n                  ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(number * Double(M_PI)) / Double(M_PI)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpj_hxz6c1.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(number * Double(M_PI)) / Double(M_PI)\n           ^~~~\n/tmp/tmpj_hxz6c1.swift:9:33:\
    \ error: cannot find 'M_PI' in scope\n    return ceil(number * Double(M_PI)) /\
    \ Double(M_PI)\n                                ^~~~\n/tmp/tmpj_hxz6c1.swift:9:49:\
    \ error: cannot find 'M_PI' in scope\n    return ceil(number * Double(M_PI)) /\
    \ Double(M_PI)\n                                                ^~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number > 0 {\n        return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n    } else {\n        return Double(number).truncatingRemainder(dividingBy:\
    \ Double(1).pow(Double(-1)))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp18jztwt2.swift:12:73: error: value of type 'Double' has no member\
    \ 'pow'\n        return Double(number).truncatingRemainder(dividingBy: Double(1).pow(Double(-1)))\n\
    \                                                              ~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 1.0 {\n        return floor(number * pow(10.0,\
    \ Double(truncatingBitCount64(number))))\n    } else {\n        return floor(number\
    \ * pow(10.0, Double(truncatingBitCount64(number) + 52)))\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpi2myi90b.swift:10:16: error: cannot find 'floor' in scope\n   \
    \     return floor(number * pow(10.0, Double(truncatingBitCount64(number))))\n\
    \               ^~~~~\n/tmp/tmpi2myi90b.swift:10:31: error: cannot find 'pow'\
    \ in scope\n        return floor(number * pow(10.0, Double(truncatingBitCount64(number))))\n\
    \                              ^~~\n/tmp/tmpi2myi90b.swift:10:48: error: cannot\
    \ find 'truncatingBitCount64' in scope\n        return floor(number * pow(10.0,\
    \ Double(truncatingBitCount64(number))))\n                                   \
    \            ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpi2myi90b.swift:12:16: error: cannot\
    \ find 'floor' in scope\n        return floor(number * pow(10.0, Double(truncatingBitCount64(number)\
    \ + 52)))\n               ^~~~~\n/tmp/tmpi2myi90b.swift:12:31: error: cannot find\
    \ 'pow' in scope\n        return floor(number * pow(10.0, Double(truncatingBitCount64(number)\
    \ + 52)))\n                              ^~~\n/tmp/tmpi2myi90b.swift:12:48: error:\
    \ cannot find 'truncatingBitCount64' in scope\n        return floor(number * pow(10.0,\
    \ Double(truncatingBitCount64(number) + 52)))\n                              \
    \                 ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    switch number.truncatingRemainder(dividingBy: 1.0)\
    \ {\n    case (_, .0):\n        return 0.0\n    case (_, .1):\n        return\
    \ 0.1\n    case (_, .2):\n        return 0.2\n    case (_, .3):\n        return\
    \ 0.3\n    case (_, .4):\n        return 0.4\n    case (_, .5):\n        return\
    \ 0.5\n    case (_, .6):\n        return 0.6\n    case (_, .7):\n        return\
    \ 0.7\n    case (_, .8):\n        return 0.8\n    case (_, 0.9):\n        return\
    \ 0.9\n    case (_, 1.0):\n        return 1.0\n    case (_, 1.1):\n        return\
    \ 1.1\n    case (_, 2.0):\n        return 2.0\n    case (_, 3.0):\n        return\
    \ 3.0\n    case (_, 4.0):\n        return 4.0\n    case (_, 5.0):\n        return\
    \ 5.0\n    case (_, 6.0):\n        return 6.0\n    case (_, 7.0):\n        return\
    \ 7.0\n    case (_, 8.0):\n        return 8.0\n    case (_, 9.0):\n        return\
    \ 9.0\n    case (_, 10.0):\n        return 10.0\n    case (_, 11.0):\n       \
    \ return 11.0\n    case (_, 12.0):\n        return 12.0\n    case (_, 13.0):\n\
    \        return 13.0\n    case (_, 14.0):\n        return 14.0\n    case (_, 15.0):\n\
    \        return 15.0\n    case (_, 16.0):\n        return 16.0\n    case (_, 17.0):\n\
    \        return 17.0\n    case (_, 18.0):\n        return 18.0\n    case (_, 19.0):\n\
    \        return 19.0\n    case (_, 20.0):\n        return 20.0\n    case (_, 21.0):\n\
    \        return 21.0\n    case (_, 22.0):\n        return 22.0\n    case (_, 23.0):\n\
    \        return 23.0\n    case (_, 24.0):\n        return 24.0\n    case (_, 25.0):\n\
    \        return 25.0\n    case (_, 26.0):\n        return 26.0\n    case (_, 27.0):\n\
    \        return 27.0\n    case (_, 28.0):\n        return 28.0\n    case (_, 29.0):\n\
    \        return 29.0\n    case (_, 30.0):\n        return 30.0\n    case (_, 31.0):\n\
    \        return 31.0\n    case (_, 32.0):\n        return 32.0\n    case (_, 33.0):\n\
    \        return 33.0\n    case (_, 34.0):\n        return 34.0\n    case (_, 35.0):\n\
    \        return 35.0\n    case (_, 36.0):\n        return 36.0\n    case (_, 37.0):\n\
    \        return 37.0\n    case (_, 38.0):\n        return 38.0\n    case (_, 39.0):\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpvx1kfl1m.swift:10:14: error: '.0' is not a valid floating point\
    \ literal; it must be written '0.0'\n    case (_, .0):\n             ^~\n    \
    \         0\n/tmp/tmpvx1kfl1m.swift:12:14: error: '.1' is not a valid floating\
    \ point literal; it must be written '0.1'\n    case (_, .1):\n             ^~\n\
    \             0\n/tmp/tmpvx1kfl1m.swift:14:14: error: '.2' is not a valid floating\
    \ point literal; it must be written '0.2'\n    case (_, .2):\n             ^~\n\
    \             0\n/tmp/tmpvx1kfl1m.swift:16:14: error: '.3' is not a valid floating\
    \ point literal; it must be written '0.3'\n    case (_, .3):\n             ^~\n\
    \             0\n/tmp/tmpvx1kfl1m.swift:18:14: error: '.4' is not a valid floating\
    \ point literal; it must be written '0.4'\n    case (_, .4):\n             ^~\n\
    \             0\n/tmp/tmpvx1kfl1m.swift:20:14: error: '.5' is not a valid floating\
    \ point literal; it must be written '0.5'\n    case (_, .5):\n             ^~\n\
    \             0\n/tmp/tmpvx1kfl1m.swift:22:14: error: '.6' is not a valid floating\
    \ point literal; it must be written '0.6'\n    case (_, .6):\n             ^~\n\
    \             0\n/tmp/tmpvx1kfl1m.swift:24:14: error: '.7' is not a valid floating\
    \ point literal; it must be written '0.7'\n    case (_, .7):\n             ^~\n\
    \             0\n/tmp/tmpvx1kfl1m.swift:26:14: error: '.8' is not a valid floating\
    \ point literal; it must be written '0.8'\n    case (_, .8):\n             ^~\n\
    \             0\n/tmp/tmpvx1kfl1m.swift:108:5: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n    case (_, 39.0):\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmpvx1kfl1m.swift:127:46: error: expected '}'\
    \ at end of brace statement\nassert(truncate_number(number: 123.0) == 0.0)\n \
    \                                            ^\n/tmp/tmpvx1kfl1m.swift:8:48: note:\
    \ to match this opening '{'\nfunc truncate_number(number: Double) -> Double {\n\
    \                                               ^\n/tmp/tmpvx1kfl1m.swift:10:10:\
    \ error: tuple pattern cannot match values of the non-tuple type 'Double'\n  \
    \  case (_, .0):\n         ^\n/tmp/tmpvx1kfl1m.sw"
  stdout: ''
  timestamp: 1660029177
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return number - 0.5\n    }\n\
    \    return number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpzfimobxe/tmpzfimobxe.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38f59b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38f56a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38f56a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38f56a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzfimobxe                        0x00005634f4ee51c5 <unavailable> + 4549

    5    libc.so.6                          0x00002b38f5b9e460 __libc_start_main +
    245

    6    tmpzfimobxe                        0x00005634f4ee4e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = number % 1\n    let integer_part = floor(number)\
    \ as Double\n\n    if fraction < 0.5 {\n        return integer_part\n    }\n \
    \   return integer_part + (fraction - 0.5)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp7gv50u0w.swift:9:27: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = number % 1\n   \
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmp7gv50u0w.swift:10:24: error: cannot find 'floor' in scope\n\
    \    let integer_part = floor(number) as Double\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // Decompose the number into integer and decimal parts\n\
    \    var integerPart: Double = ceil(number)\n    var decimalPart: Double = number\
    \ - integerPart\n    if decimalPart > 0 {\n        return number\n    } else {\n\
    \        return integerPart\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpyjrh1fgk.swift:10:31: error: cannot find 'ceil' in scope\n    var\
    \ integerPart: Double = ceil(number)\n                              ^~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // If the number is zero, return zero.\n    if number\
    \ == 0.0 {\n        return 0.0\n    }\n    // If the number is negative, return\
    \ zero.\n    if number < 0.0 {\n        return 0.0\n    }\n    // If the number\
    \ is negative, return the largest integer smaller than number.\n    // The decimal\
    \ part of the number remains unchanged.\n    var truncated = Int(ceil(Double(number)))\n\
    \    // If the number is non-zero, return the fractional part and the\n    //\
    \ decimal part.\n    if number != 0.0 {\n        truncated += 1\n    }\n    return\
    \ truncated / Double(10) /* 10 is the maximum number of decimal digits in Double.\
    \ */\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpluo3vl4a.swift:19:25: error: cannot find 'ceil' in scope\n    var\
    \ truncated = Int(ceil(Double(number)))\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(number) / Double(10)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpw0q1a800.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(number) / Double(10)\n           ^~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return round(number * pow(10.0, Double(floor(log10(abs(number))))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpyeusy0ch.swift:9:12: error: cannot find 'round' in scope\n    return\
    \ round(number * pow(10.0, Double(floor(log10(abs(number)))))) / pow(10.0, Double(floor(log10(abs(number)))))\n\
    \           ^~~~~\n/tmp/tmpyeusy0ch.swift:9:27: error: cannot find 'pow' in scope\n\
    \    return round(number * pow(10.0, Double(floor(log10(abs(number)))))) / pow(10.0,\
    \ Double(floor(log10(abs(number)))))\n                          ^~~\n/tmp/tmpyeusy0ch.swift:9:44:\
    \ error: cannot find 'floor' in scope\n    return round(number * pow(10.0, Double(floor(log10(abs(number))))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))\n                           \
    \                ^~~~~\n/tmp/tmpyeusy0ch.swift:9:50: error: cannot find 'log10'\
    \ in scope\n    return round(number * pow(10.0, Double(floor(log10(abs(number))))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))\n                           \
    \                      ^~~~~\n/tmp/tmpyeusy0ch.swift:9:75: error: cannot find\
    \ 'pow' in scope\n    return round(number * pow(10.0, Double(floor(log10(abs(number))))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))\n                           \
    \                                               ^~~\n/tmp/tmpyeusy0ch.swift:9:92:\
    \ error: cannot find 'floor' in scope\n    return round(number * pow(10.0, Double(floor(log10(abs(number))))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))\n                           \
    \                                                                ^~~~~\n/tmp/tmpyeusy0ch.swift:9:98:\
    \ error: cannot find 'log10' in scope\n    return round(number * pow(10.0, Double(floor(log10(abs(number))))))\
    \ / pow(10.0, Double(floor(log10(abs(number)))))\n                           \
    \                                                                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: -1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660029183
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return floor(number * 10) / 10.0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzyzuovl5.swift:9:12: error: cannot find 'floor' in scope\n    return\
    \ floor(number * 10) / 10.0\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 1.0 {\n        return floor(number);\n\
    \    }\n    return floor(number * 10.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpjvobagir.swift:10:16: error: cannot find 'floor' in scope\n   \
    \     return floor(number);\n               ^~~~~\n/tmp/tmpjvobagir.swift:12:12:\
    \ error: cannot find 'floor' in scope\n    return floor(number * 10.0)\n     \
    \      ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var trunc = 0\n    var dec = 0.0\n    var negated =\
    \ false\n\n    if number < 0.0 {\n        negated = true\n        number = -number\n\
    \    }\n\n    if number < 1.0 {\n        trunc = Int(ceil(Double(number) * 1e10))\n\
    \    } else {\n        trunc = Int(floor(Double(number) * 1e10))\n    }\n    \n\
    \    for _ in 0..<trunc {\n        dec += pow(10.0, trunc - 1)\n    }\n\n    if\
    \ dec > 1.0 {\n        return number - dec\n    }\n\n    return number\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpj1hvlf3t.swift:15:9: error: cannot assign to value: 'number' is\
    \ a 'let' constant\n        number = -number\n        ^~~~~~\n/tmp/tmpj1hvlf3t.swift:19:21:\
    \ error: cannot find 'ceil' in scope\n        trunc = Int(ceil(Double(number)\
    \ * 1e10))\n                    ^~~~\n/tmp/tmpj1hvlf3t.swift:21:21: error: cannot\
    \ find 'floor' in scope\n        trunc = Int(floor(Double(number) * 1e10))\n \
    \                   ^~~~~\n/tmp/tmpj1hvlf3t.swift:25:16: error: cannot find 'pow'\
    \ in scope\n        dec += pow(10.0, trunc - 1)\n               ^~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  let integerPartOfNumber = truncate_int(number)\n  let\
    \ decimalPartOfNumber = number - integerPartOfNumber\n  return decimalPartOfNumber\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpybpz9wff.swift:9:29: error: cannot find 'truncate_int' in scope\n\
    \  let integerPartOfNumber = truncate_int(number)\n                          \
    \  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let divisor = pow(10, Double(ceil(log10(number))))\n\
    \    return number / divisor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpwyw4qqq3.swift:9:19: error: cannot find 'pow' in scope\n    let\
    \ divisor = pow(10, Double(ceil(log10(number))))\n                  ^~~\n/tmp/tmpwyw4qqq3.swift:9:34:\
    \ error: cannot find 'ceil' in scope\n    let divisor = pow(10, Double(ceil(log10(number))))\n\
    \                                 ^~~~\n/tmp/tmpwyw4qqq3.swift:9:39: error: cannot\
    \ find 'log10' in scope\n    let divisor = pow(10, Double(ceil(log10(number))))\n\
    \                                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 1.0 {\n        return number\n    }\n \
    \   let value = Double(number)\n    let fraction = value % 1\n    let whole =\
    \ Int(value)\n    return whole * 1.0 / fraction\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpicfxzhix.swift:13:26: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = value % 1\n    \
    \                     ^\nSwift.%:2:13: note: '%' has been explicitly marked unavailable\
    \ here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n/tmp/tmpicfxzhix.swift:15:12: error: cannot convert value of type\
    \ 'Int' to expected argument type 'Double'\n    return whole * 1.0 / fraction\n\
    \           ^\n           Double( )\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var number = number\n    if number < 1.0 {\n      \
    \  number = 1.0\n    }\n    if number > 1.0 {\n        number = 1.0\n    }\n \
    \   return number - floor(number * pow(10.0, -ceil(log10(number))))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpokykybjc.swift:16:21: error: cannot find 'floor' in scope\n   \
    \ return number - floor(number * pow(10.0, -ceil(log10(number))))\n          \
    \          ^~~~~\n/tmp/tmpokykybjc.swift:16:36: error: cannot find 'pow' in scope\n\
    \    return number - floor(number * pow(10.0, -ceil(log10(number))))\n       \
    \                            ^~~\n/tmp/tmpokykybjc.swift:16:47: error: cannot\
    \ find 'ceil' in scope\n    return number - floor(number * pow(10.0, -ceil(log10(number))))\n\
    \                                              ^~~~\n/tmp/tmpokykybjc.swift:16:52:\
    \ error: cannot find 'log10' in scope\n    return number - floor(number * pow(10.0,\
    \ -ceil(log10(number))))\n                                                   ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var integerPart: Double = 0\n    var decimalPart =\
    \ number % 1\n    \n    while decimalPart > 0.5 {\n        decimalPart -= 0.5\n\
    \        integerPart += 1\n    }\n    \n    return integerPart + decimalPart\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp2y8xg04z.swift:10:30: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    var decimalPart = number % 1\n\
    \                             ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return 0\n    }\n    if number\
    \ == 0 {\n        return 0\n    }\n    var integralPart = Int(number)\n    var\
    \ decimalPart = Int(number - Double(integralPart))\n    if decimalPart > 0 {\n\
    \        return Double(integralPart) / pow(10, Double(decimalPart))\n    } else\
    \ {\n        return Double(integralPart)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp16mauhdh.swift:18:39: error: cannot find 'pow' in scope\n     \
    \   return Double(integralPart) / pow(10, Double(decimalPart))\n             \
    \                         ^~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let fraction = Double(number) % 1\n    return Double(number)\
    \ - fraction\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp1jlkhrbz.swift:9:35: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fraction = Double(number) %\
    \ 1\n                                  ^\nSwift.%:2:13: note: '%' has been explicitly\
    \ marked unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return 0\n    }\n\n    let\
    \ fraction = truncate_fraction(number: number)\n\n    return fraction * Double(pow(10.0,\
    \ Double(-Int32(math.ceil(log10(number)))))) / Double(pow(10.0, Double(Int32(math.ceil(log10(number))))))\
    \ / Double(10)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp9g83gwye.swift:13:20: error: cannot find 'truncate_fraction' in\
    \ scope\n    let fraction = truncate_fraction(number: number)\n              \
    \     ^~~~~~~~~~~~~~~~~\n/tmp/tmp9g83gwye.swift:15:30: error: cannot find 'pow'\
    \ in scope\n    return fraction * Double(pow(10.0, Double(-Int32(math.ceil(log10(number))))))\
    \ / Double(pow(10.0, Double(Int32(math.ceil(log10(number)))))) / Double(10)\n\
    \                             ^~~\n/tmp/tmp9g83gwye.swift:15:54: error: cannot\
    \ find 'math' in scope\n    return fraction * Double(pow(10.0, Double(-Int32(math.ceil(log10(number))))))\
    \ / Double(pow(10.0, Double(Int32(math.ceil(log10(number)))))) / Double(10)\n\
    \                                                     ^~~~\n/tmp/tmp9g83gwye.swift:15:64:\
    \ error: cannot find 'log10' in scope\n    return fraction * Double(pow(10.0,\
    \ Double(-Int32(math.ceil(log10(number)))))) / Double(pow(10.0, Double(Int32(math.ceil(log10(number))))))\
    \ / Double(10)\n                                                             \
    \  ^~~~~\n/tmp/tmp9g83gwye.swift:15:92: error: cannot find 'pow' in scope\n  \
    \  return fraction * Double(pow(10.0, Double(-Int32(math.ceil(log10(number))))))\
    \ / Double(pow(10.0, Double(Int32(math.ceil(log10(number)))))) / Double(10)\n\
    \                                                                            \
    \               ^~~\n/tmp/tmp9g83gwye.swift:15:115: error: cannot find 'math'\
    \ in scope\n    return fraction * Double(pow(10.0, Double(-Int32(math.ceil(log10(number))))))\
    \ / Double(pow(10.0, Double(Int32(math.ceil(log10(number)))))) / Double(10)\n\
    \                                                                            \
    \                                      ^~~~\n/tmp/tmp9g83gwye.swift:15:125: error:\
    \ cannot find 'log10' in scope\n    return fraction * Double(pow(10.0, Double(-Int32(math.ceil(log10(number))))))\
    \ / Double(pow(10.0, Double(Int32(math.ceil(log10(number)))))) / Double(10)\n\
    \                                                                            \
    \                                                ^~~~~\n/tmp/tmp9g83gwye.swift:15:12:\
    \ error: the compile"
  stdout: ''
  timestamp: 1660029219
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return number < 0 ? ceil_to_dec(number, 0.0) : floor_to_dec(number,\
    \ 0.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpb621jr3_.swift:9:25: error: cannot find 'ceil_to_dec' in scope\n\
    \    return number < 0 ? ceil_to_dec(number, 0.0) : floor_to_dec(number, 0.0)\n\
    \                        ^~~~~~~~~~~\n/tmp/tmpb621jr3_.swift:9:52: error: cannot\
    \ find 'floor_to_dec' in scope\n    return number < 0 ? ceil_to_dec(number, 0.0)\
    \ : floor_to_dec(number, 0.0)\n                                              \
    \     ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return round(number * pow(10.0, Double(trunc(log10(number)))))\
    \ / pow(10.0, Double(trunc(log10(number))))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpsttuqo84.swift:9:12: error: cannot find 'round' in scope\n    return\
    \ round(number * pow(10.0, Double(trunc(log10(number))))) / pow(10.0, Double(trunc(log10(number))))\n\
    \           ^~~~~\n/tmp/tmpsttuqo84.swift:9:27: error: cannot find 'pow' in scope\n\
    \    return round(number * pow(10.0, Double(trunc(log10(number))))) / pow(10.0,\
    \ Double(trunc(log10(number))))\n                          ^~~\n/tmp/tmpsttuqo84.swift:9:44:\
    \ error: cannot find 'trunc' in scope\n    return round(number * pow(10.0, Double(trunc(log10(number)))))\
    \ / pow(10.0, Double(trunc(log10(number))))\n                                \
    \           ^~~~~\n/tmp/tmpsttuqo84.swift:9:50: error: cannot find 'log10' in\
    \ scope\n    return round(number * pow(10.0, Double(trunc(log10(number))))) /\
    \ pow(10.0, Double(trunc(log10(number))))\n                                  \
    \               ^~~~~\n/tmp/tmpsttuqo84.swift:9:70: error: cannot find 'pow' in\
    \ scope\n    return round(number * pow(10.0, Double(trunc(log10(number))))) /\
    \ pow(10.0, Double(trunc(log10(number))))\n                                  \
    \                                   ^~~\n/tmp/tmpsttuqo84.swift:9:87: error: cannot\
    \ find 'trunc' in scope\n    return round(number * pow(10.0, Double(trunc(log10(number)))))\
    \ / pow(10.0, Double(trunc(log10(number))))\n                                \
    \                                                      ^~~~~\n/tmp/tmpsttuqo84.swift:9:93:\
    \ error: cannot find 'log10' in scope\n    return round(number * pow(10.0, Double(trunc(log10(number)))))\
    \ / pow(10.0, Double(trunc(log10(number))))\n                                \
    \                                                            ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let integerPart = Int(round(number))\n    return Double(integerPart)\
    \ / Double(10)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphrl7frz0.swift:9:27: error: cannot find 'round' in scope\n    let\
    \ integerPart = Int(round(number))\n                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var rem = number\n    var integer = Double()\n\n  \
    \  for _ in 0..<64 {\n        integer = Double(rem)\n        rem -= integer %\
    \ Double(1)\n    }\n\n    return rem\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpfl8w7x8h.swift:14:24: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n        rem -= integer % Double(1)\n\
    \                       ^\nSwift.%:2:13: note: '%' has been explicitly marked\
    \ unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number >= 0 {\n        return number\n    }\n\n\
    \    let decimalPart = round(number % 1)\n    let integerPart = floor(number)\
    \ % 1\n    return decimalPart * pow(10, floor(log10(number)))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphkwzi0z2.swift:13:23: error: cannot find 'round' in scope\n   \
    \ let decimalPart = round(number % 1)\n                      ^~~~~\n/tmp/tmphkwzi0z2.swift:14:23:\
    \ error: cannot find 'floor' in scope\n    let integerPart = floor(number) % 1\n\
    \                      ^~~~~\n/tmp/tmphkwzi0z2.swift:15:26: error: cannot find\
    \ 'pow' in scope\n    return decimalPart * pow(10, floor(log10(number)))\n   \
    \                      ^~~\n/tmp/tmphkwzi0z2.swift:15:34: error: cannot find 'floor'\
    \ in scope\n    return decimalPart * pow(10, floor(log10(number)))\n         \
    \                        ^~~~~\n/tmp/tmphkwzi0z2.swift:15:40: error: cannot find\
    \ 'log10' in scope\n    return decimalPart * pow(10, floor(log10(number)))\n \
    \                                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 1 {\n        return 1.0\n    }\n    let\
    \ result = trunc(number)\n    return result - floor(result) + 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmhmkg3b5.swift:12:18: error: cannot find 'trunc' in scope\n   \
    \ let result = trunc(number)\n                 ^~~~~\n/tmp/tmpmhmkg3b5.swift:13:21:\
    \ error: cannot find 'floor' in scope\n    return result - floor(result) + 1\n\
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  let integralPart = Int(number)\n  let decimalPart = number\
    \ - Double(integralPart)\n  return Double(integralPart) + Double(decimalPart)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpj2_j3u2d/tmpj2_j3u2d.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0716ea4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0716b9bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0716b9b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0716b9a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj2_j3u2d                        0x00005615e7e772a5 <unavailable> + 4773

    5    libc.so.6                          0x00002b0717090460 __libc_start_main +
    245

    6    tmpj2_j3u2d                        0x00005615e7e76f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 1.0 {\n        return Double(number)\n\
    \    }\n    var digits: String = \"\"\n    while number > 1.0 {\n        digits\
    \ += \"1\"\n        number -= Double(trunc(number))\n    }\n    digits += \"0\"\
    \n    return Double(trunc(Double(number) / Double(10)))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpve78mm4j.swift:15:26: error: cannot find 'trunc' in scope\n   \
    \     number -= Double(trunc(number))\n                         ^~~~~\n/tmp/tmpve78mm4j.swift:18:19:\
    \ error: cannot find 'trunc' in scope\n    return Double(trunc(Double(number)\
    \ / Double(10)))\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return round(number - floor(number))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcer03wdw.swift:9:12: error: cannot find 'round' in scope\n    return\
    \ round(number - floor(number))\n           ^~~~~\n/tmp/tmpcer03wdw.swift:9:27:\
    \ error: cannot find 'floor' in scope\n    return round(number - floor(number))\n\
    \                          ^~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(number * Double(Int64(Decimal.pow(10, Decimal.truncatingBitWidth()-1))))\
    \ / Double(Decimal.pow(10, Decimal.truncatingBitWidth()))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmplakngi_g.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(number * Double(Int64(Decimal.pow(10, Decimal.truncatingBitWidth()-1))))\
    \ / Double(Decimal.pow(10, Decimal.truncatingBitWidth()))\n           ^~~~\n/tmp/tmplakngi_g.swift:9:39:\
    \ error: cannot find 'Decimal' in scope\n    return ceil(number * Double(Int64(Decimal.pow(10,\
    \ Decimal.truncatingBitWidth()-1)))) / Double(Decimal.pow(10, Decimal.truncatingBitWidth()))\n\
    \                                      ^~~~~~~\n/tmp/tmplakngi_g.swift:9:55: error:\
    \ cannot find 'Decimal' in scope\n    return ceil(number * Double(Int64(Decimal.pow(10,\
    \ Decimal.truncatingBitWidth()-1)))) / Double(Decimal.pow(10, Decimal.truncatingBitWidth()))\n\
    \                                                      ^~~~~~~\n/tmp/tmplakngi_g.swift:9:99:\
    \ error: cannot find 'Decimal' in scope\n    return ceil(number * Double(Int64(Decimal.pow(10,\
    \ Decimal.truncatingBitWidth()-1)))) / Double(Decimal.pow(10, Decimal.truncatingBitWidth()))\n\
    \                                                                            \
    \                      ^~~~~~~\n/tmp/tmplakngi_g.swift:9:115: error: cannot find\
    \ 'Decimal' in scope\n    return ceil(number * Double(Int64(Decimal.pow(10, Decimal.truncatingBitWidth()-1))))\
    \ / Double(Decimal.pow(10, Decimal.truncatingBitWidth()))\n                  \
    \                                                                            \
    \                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return floor(number * pow(10.0, Double(log10(number))).rounded(.towardZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp2yiqn9wt.swift:9:12: error: cannot find 'floor' in scope\n    return\
    \ floor(number * pow(10.0, Double(log10(number))).rounded(.towardZero))\n    \
    \       ^~~~~\n/tmp/tmp2yiqn9wt.swift:9:27: error: cannot find 'pow' in scope\n\
    \    return floor(number * pow(10.0, Double(log10(number))).rounded(.towardZero))\n\
    \                          ^~~\n/tmp/tmp2yiqn9wt.swift:9:44: error: cannot find\
    \ 'log10' in scope\n    return floor(number * pow(10.0, Double(log10(number))).rounded(.towardZero))\n\
    \                                           ^~~~~\n/tmp/tmp2yiqn9wt.swift:9:69:\
    \ error: cannot infer contextual base in reference to member 'towardZero'\n  \
    \  return floor(number * pow(10.0, Double(log10(number))).rounded(.towardZero))\n\
    \                                                                   ~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029177
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let digits = ceil(log10(abs(number))) + 1\n    let\
    \ factor = 10.0**Double(digits)\n    return number * factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmph157ku4p.swift:9:18: error: cannot find 'ceil' in scope\n    let\
    \ digits = ceil(log10(abs(number))) + 1\n                 ^~~~\n/tmp/tmph157ku4p.swift:9:23:\
    \ error: cannot find 'log10' in scope\n    let digits = ceil(log10(abs(number)))\
    \ + 1\n                      ^~~~~\n/tmp/tmph157ku4p.swift:10:22: error: cannot\
    \ find operator '**' in scope\n    let factor = 10.0**Double(digits)\n       \
    \              ^~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0.0 {\n        return -truncate_number(-number)\n\
    \    }\n    var decPart = Double()\n    if number < 1.0e-36 {\n        return\
    \ number\n    }\n    let power = log2(Double(number))\n    var result: Double\
    \ = Double()\n    for i in 1..power {\n        result = result + Double(pow(2.0,\
    \ Double(i)))\n    }\n    decPart = result - number\n    return decPart\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpmod6bqgv.swift:10:33: error: missing argument label 'number:' in\
    \ call\n        return -truncate_number(-number)\n                           \
    \     ^\n                                number: \n/tmp/tmpmod6bqgv.swift:16:17:\
    \ error: cannot find 'log2' in scope\n    let power = log2(Double(number))\n \
    \               ^~~~\n/tmp/tmpmod6bqgv.swift:18:15: error: cannot find operator\
    \ '..' in scope; did you mean '...'?\n    for i in 1..power {\n              ^~\n\
    \              ...\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\treturn trunc(number*100)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphr7984d3.swift:9:9: error: cannot find 'trunc' in scope\n     \
    \   return trunc(number*100)\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  return ceil(Double(number) / Decimal(1))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpnufhzhk4.swift:9:10: error: cannot find 'ceil' in scope\n  return\
    \ ceil(Double(number) / Decimal(1))\n         ^~~~\n/tmp/tmpnufhzhk4.swift:9:32:\
    \ error: cannot find 'Decimal' in scope\n  return ceil(Double(number) / Decimal(1))\n\
    \                               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        switch number {\n        case\
    \ Double(Int64(math.pow(10, 64))):\n            return 0.0\n        default:\n\
    \            return number\n        }\n    } else {\n        return floor(number\
    \ * 10 + 0.5)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzgvj9n3q.swift:11:27: error: cannot find 'math' in scope\n    \
    \    case Double(Int64(math.pow(10, 64))):\n                          ^~~~\n/tmp/tmpzgvj9n3q.swift:17:16:\
    \ error: cannot find 'floor' in scope\n        return floor(number * 10 + 0.5)\n\
    \               ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let digits = log10(number) + 1\n    let decimals =\
    \ floor(digits - digits(number))\n    return trunc(number * pow(10.0, Double(decimals)))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpe8cjaxgt.swift:9:18: error: cannot find 'log10' in scope\n    let\
    \ digits = log10(number) + 1\n                 ^~~~~\n/tmp/tmpe8cjaxgt.swift:10:20:\
    \ error: cannot find 'floor' in scope\n    let decimals = floor(digits - digits(number))\n\
    \                   ^~~~~\n/tmp/tmpe8cjaxgt.swift:11:12: error: cannot find 'trunc'\
    \ in scope\n    return trunc(number * pow(10.0, Double(decimals)))\n         \
    \  ^~~~~\n/tmp/tmpe8cjaxgt.swift:11:27: error: cannot find 'pow' in scope\n  \
    \  return trunc(number * pow(10.0, Double(decimals)))\n                      \
    \    ^~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var decimal_part = 0.0;\n    if number > 0.0 && number\
    \ < 1.0 {\n        decimal_part = ceil(log10(number));\n    }\n    return number\
    \ - decimal_part;\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzqv7iu0h.swift:11:24: error: cannot find 'ceil' in scope\n    \
    \    decimal_part = ceil(log10(number));\n                       ^~~~\n/tmp/tmpzqv7iu0h.swift:11:29:\
    \ error: cannot find 'log10' in scope\n        decimal_part = ceil(log10(number));\n\
    \                            ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  var num = number\n  var decimal: Double = 0.0\n  while\
    \ (num > 0 && num > 1) {\n    num /= 10\n    decimal += 1\n  }\n  return round(num\
    \ * 10) + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp80nevbbm.swift:15:10: error: cannot find 'round' in scope\n  return\
    \ round(num * 10) + decimal\n         ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let decimal = floor(log10(number));\n    let fraction\
    \ = number / pow(10.0, Double(decimal));\n    return fraction;\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpcpmwuhiv.swift:9:19: error: cannot find 'floor' in scope\n    let\
    \ decimal = floor(log10(number));\n                  ^~~~~\n/tmp/tmpcpmwuhiv.swift:9:25:\
    \ error: cannot find 'log10' in scope\n    let decimal = floor(log10(number));\n\
    \                        ^~~~~\n/tmp/tmpcpmwuhiv.swift:10:29: error: cannot find\
    \ 'pow' in scope\n    let fraction = number / pow(10.0, Double(decimal));\n  \
    \                          ^~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    \n    var decimal: Double = 1\n    \n    if number\
    \ < 1 {\n        return number\n    }\n    \n    decimal = Decimal(string: \"\\\
    (number).0\").decimalValue\n    \n    return number - Double(decimal)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp9n91dwtk.swift:16:15: error: cannot find 'Decimal' in scope\n \
    \   decimal = Decimal(string: \"\\(number).0\").decimalValue\n              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let parts = number.trunc(at: 1)\n    let integerPart\
    \ = Double(Int(number))\n    return Double((integerPart - parts) / 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpg8v10h6k.swift:9:24: error: value of type 'Double' has no member\
    \ 'trunc'\n    let parts = number.trunc(at: 1)\n                ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    switch fmod64(number, Double(pow(10.0, Double(M_PI_4).ceil()))).truncatingRemainder(dividingBy:\
    \ Double(pow(10.0, Double(M_PI_4)))).floor {\n    case 0.0: return number / Double(pow(10.0,\
    \ Double(M_PI_4)))\n    case 1.0: return number\n    default: return number -\
    \ Double(pow(10.0, Double(M_PI_4)))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpxg3pmw7v.swift:9:12: error: cannot find 'fmod64' in scope\n   \
    \ switch fmod64(number, Double(pow(10.0, Double(M_PI_4).ceil()))).truncatingRemainder(dividingBy:\
    \ Double(pow(10.0, Double(M_PI_4)))).floor {\n           ^~~~~~\n/tmp/tmpxg3pmw7v.swift:9:34:\
    \ error: cannot find 'pow' in scope\n    switch fmod64(number, Double(pow(10.0,\
    \ Double(M_PI_4).ceil()))).truncatingRemainder(dividingBy: Double(pow(10.0, Double(M_PI_4)))).floor\
    \ {\n                                 ^~~\n/tmp/tmpxg3pmw7v.swift:9:51: error:\
    \ cannot find 'M_PI_4' in scope\n    switch fmod64(number, Double(pow(10.0, Double(M_PI_4).ceil()))).truncatingRemainder(dividingBy:\
    \ Double(pow(10.0, Double(M_PI_4)))).floor {\n                               \
    \                   ^~~~~~\n/tmp/tmpxg3pmw7v.swift:9:108: error: cannot find 'pow'\
    \ in scope\n    switch fmod64(number, Double(pow(10.0, Double(M_PI_4).ceil()))).truncatingRemainder(dividingBy:\
    \ Double(pow(10.0, Double(M_PI_4)))).floor {\n                               \
    \                                                                            ^~~\n\
    /tmp/tmpxg3pmw7v.swift:9:125: error: cannot find 'M_PI_4' in scope\n    switch\
    \ fmod64(number, Double(pow(10.0, Double(M_PI_4).ceil()))).truncatingRemainder(dividingBy:\
    \ Double(pow(10.0, Double(M_PI_4)))).floor {\n                               \
    \                                                                            \
    \                 ^~~~~~\n/tmp/tmpxg3pmw7v.swift:9:59: error: reference to member\
    \ 'ceil' cannot be resolved without a contextual type\n    switch fmod64(number,\
    \ Double(pow(10.0, Double(M_PI_4).ceil()))).truncatingRemainder(dividingBy: Double(pow(10.0,\
    \ Double(M_PI_4)))).floor {\n                                                \
    \          ^\n/tmp/tmpxg3pmw7v.swift:10:38: error: cannot find 'pow' in scope\n\
    \    case 0.0: return number / Double(pow(10.0, Double(M_PI_4)))\n           \
    \                          ^~~\n/tmp/tmpxg3pmw7v.swift:10:55: error: cannot find\
    \ 'M_PI_4' in scope\n    case 0.0: return number / Double(pow(10.0, Double(M_PI_4)))\n\
    \                                          "
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var numberDouble = number\n    var fraction: Double\
    \ = 1.0\n    let fractionRep = numberDouble % 1\n    if fractionRep < 0 {\n  \
    \      fraction = fractionRep\n    }\n    let fractionRep = numberDouble % 1\n\
    \    if fractionRep < 0 {\n        fraction = fractionRep\n    }\n    return numberDouble\
    \ - fraction\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpootoa0uw.swift:11:36: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n    let fractionRep = numberDouble\
    \ % 1\n                                   ^\nSwift.%:2:13: note: '%' has been\
    \ explicitly marked unavailable here\npublic func % <T>(lhs: T, rhs: T) -> T where\
    \ T : BinaryFloatingPoint\n            ^\n/tmp/tmpootoa0uw.swift:15:36: error:\
    \ '%' is unavailable: For floating point numbers use truncatingRemainder instead\n\
    \    let fractionRep = numberDouble % 1\n                                   ^\n\
    Swift.%:2:13: note: '%' has been explicitly marked unavailable here\npublic func\
    \ % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n            ^\n/tmp/tmpootoa0uw.swift:15:9:\
    \ error: invalid redeclaration of 'fractionRep'\n    let fractionRep = numberDouble\
    \ % 1\n        ^\n/tmp/tmpootoa0uw.swift:11:9: note: 'fractionRep' previously\
    \ declared here\n    let fractionRep = numberDouble % 1\n        ^\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number) - (Int(number) > 0 ? Int(number)\
    \ : Double(1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpidmcs3jm.swift:9:48: error: result values in '? :' expression have\
    \ mismatching types 'Int' and 'Double'\n    return Double(number) - (Int(number)\
    \ > 0 ? Int(number) : Double(1))\n                                           \
    \    ^~~~~~~~~~~\n                                               Double(    )\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(number * 10)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp9mh2dca9.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(number * 10)\n           ^~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var num : Double = number\n    if num < 0 {\n     \
    \   num = -num\n    }\n    return Double(num).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number(number: number, precision: 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmppp1p08w6.swift:9:55: error: extra argument 'precision' in call\n\
    \    return truncate_number(number: number, precision: 1)\n                  \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmp_9g4e2nt/tmp_9g4e2nt.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dafa06c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3daf6fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3daf6fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3daf6fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_9g4e2nt                        0x000055c35342c215 <unavailable> + 4629

    5    libc.so.6                          0x00002b3dafbf2460 __libc_start_main +
    245

    6    tmp_9g4e2nt                        0x000055c35342beb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(ceil(trunc(number)))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpxoy3f75w.swift:9:19: error: cannot find 'ceil' in scope\n    return\
    \ Double(ceil(trunc(number)))\n                  ^~~~\n/tmp/tmpxoy3f75w.swift:9:24:\
    \ error: cannot find 'trunc' in scope\n    return Double(ceil(trunc(number)))\n\
    \                       ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 0
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(number).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660029055
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // TODO, handle negative numbers\n    if number < 0.0\
    \ {\n        let negate = Double(-1 * number)\n        return negate / truncate_number(negate)\n\
    \    } else {\n        return truncate_number_base(number, truncate_number_base)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmps7b9_orz.swift:12:41: error: missing argument label 'number:' in\
    \ call\n        return negate / truncate_number(negate)\n                    \
    \                    ^\n                                        number: \n/tmp/tmps7b9_orz.swift:14:16:\
    \ error: cannot find 'truncate_number_base' in scope\n        return truncate_number_base(number,\
    \ truncate_number_base)\n               ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmps7b9_orz.swift:14:45:\
    \ error: cannot find 'truncate_number_base' in scope\n        return truncate_number_base(number,\
    \ truncate_number_base)\n                                            ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var result = Double(round(number))\n    if number <\
    \ 0 {\n        result = -result\n    }\n    return result.rounded(to: 5)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpdckgtjc2.swift:9:25: error: cannot find 'round' in scope\n    var\
    \ result = Double(round(number))\n                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n\tlet truncPart = (number - Double(trunc(number))).truncatingRemainder(dividingBy:\
    \ 1)\n\treturn truncPart + Double(1)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp0tzw1p3g.swift:9:35: error: cannot find 'trunc' in scope\n    \
    \    let truncPart = (number - Double(trunc(number))).truncatingRemainder(dividingBy:\
    \ 1)\n                                         ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n  return ceil(number * Double(10)).truncatingRemainder(dividingBy:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpzgxd6be_.swift:9:10: error: cannot find 'ceil' in scope\n  return\
    \ ceil(number * Double(10)).truncatingRemainder(dividingBy: 1)\n         ^~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return ceil(number * Double(10).pow(Double(10).ceil(log10(abs(number)))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpe0qkhvfd.swift:9:12: error: cannot find 'ceil' in scope\n    return\
    \ ceil(number * Double(10).pow(Double(10).ceil(log10(abs(number)))))\n       \
    \    ^~~~\n/tmp/tmpe0qkhvfd.swift:9:57: error: cannot find 'log10' in scope\n\
    \    return ceil(number * Double(10).pow(Double(10).ceil(log10(abs(number)))))\n\
    \                                                        ^~~~~\n/tmp/tmpe0qkhvfd.swift:9:37:\
    \ error: value of type 'Double' has no member 'pow'\n    return ceil(number *\
    \ Double(10).pow(Double(10).ceil(log10(abs(number)))))\n                     \
    \    ~~~~~~~~~~ ^~~\n/tmp/tmpe0qkhvfd.swift:9:52: error: value of type 'Double'\
    \ has no member 'ceil'\n    return ceil(number * Double(10).pow(Double(10).ceil(log10(abs(number)))))\n\
    \                                        ~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    var whole: Double\n    var fraction: Double\n\n   \
    \ if number < 0 {\n        whole = abs(number)\n        fraction = 1.0 - whole\n\
    \    } else {\n        whole = number\n        fraction = 1.0\n    }\n\n    var\
    \ wholeInt: Double\n    if whole < 1.0 {\n        wholeInt = round(whole)\n  \
    \  } else {\n        wholeInt = floor(whole)\n    }\n\n    let fractionInt = round(fraction)\n\
    \n    // Return integer part - wholeInt\n    if fractionInt >= 1.0 {\n       \
    \ return wholeInt\n    } else {\n        return wholeInt + 1.0 - fractionInt\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpwqg8r3cs.swift:22:20: error: cannot find 'round' in scope\n   \
    \     wholeInt = round(whole)\n                   ^~~~~\n/tmp/tmpwqg8r3cs.swift:24:20:\
    \ error: cannot find 'floor' in scope\n        wholeInt = floor(whole)\n     \
    \              ^~~~~\n/tmp/tmpwqg8r3cs.swift:27:23: error: cannot find 'round'\
    \ in scope\n    let fractionInt = round(fraction)\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // Truncate to 1 decimal place\n    let result = trunc(number)\n\
    \    // Divide by 10^n\n    return (result / pow(10.0, Double(trunc(log10(number))))).floor()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpp9cag1ht.swift:10:18: error: cannot find 'trunc' in scope\n   \
    \ let result = trunc(number)\n                 ^~~~~\n/tmp/tmpp9cag1ht.swift:12:22:\
    \ error: cannot find 'pow' in scope\n    return (result / pow(10.0, Double(trunc(log10(number))))).floor()\n\
    \                     ^~~\n/tmp/tmpp9cag1ht.swift:12:39: error: cannot find 'trunc'\
    \ in scope\n    return (result / pow(10.0, Double(trunc(log10(number))))).floor()\n\
    \                                      ^~~~~\n/tmp/tmpp9cag1ht.swift:12:45: error:\
    \ cannot find 'log10' in scope\n    return (result / pow(10.0, Double(trunc(log10(number))))).floor()\n\
    \                                            ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return round(number * pow(10.0, Double(truncate_float_to_int(number))))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp2cp1ig08.swift:9:12: error: cannot find 'round' in scope\n    return\
    \ round(number * pow(10.0, Double(truncate_float_to_int(number))))\n         \
    \  ^~~~~\n/tmp/tmp2cp1ig08.swift:9:27: error: cannot find 'pow' in scope\n   \
    \ return round(number * pow(10.0, Double(truncate_float_to_int(number))))\n  \
    \                        ^~~\n/tmp/tmp2cp1ig08.swift:9:44: error: cannot find\
    \ 'truncate_float_to_int' in scope\n    return round(number * pow(10.0, Double(truncate_float_to_int(number))))\n\
    \                                           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return number - floorf(number)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpc4zw2085.swift:9:21: error: cannot find 'floorf' in scope\n   \
    \ return number - floorf(number)\n                    ^~~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return truncate_number_impl(&number, number: number)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmp8rlreb4v.swift:9:12: error: cannot find 'truncate_number_impl'\
    \ in scope\n    return truncate_number_impl(&number, number: number)\n       \
    \    ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8rlreb4v.swift:9:33: error: cannot pass immutable\
    \ value as inout argument: 'number' is a 'let' constant\n    return truncate_number_impl(&number,\
    \ number: number)\n                                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number <= 0.0 {\n        return 0.0\n    }\n   \
    \ decimalPart := ceil(log10(abs(number)))\n    return number * pow(10.0, Double(decimalPart))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpe8ecgpna.swift:12:16: error: consecutive statements on a line must\
    \ be separated by ';'\n    decimalPart := ceil(log10(abs(number)))\n         \
    \      ^\n               ;\n/tmp/tmpe8ecgpna.swift:12:17: error: expected expression\n\
    \    decimalPart := ceil(log10(abs(number)))\n                ^\n/tmp/tmpe8ecgpna.swift:12:5:\
    \ error: cannot find 'decimalPart' in scope\n    decimalPart := ceil(log10(abs(number)))\n\
    \    ^~~~~~~~~~~\n/tmp/tmpe8ecgpna.swift:13:21: error: cannot find 'pow' in scope\n\
    \    return number * pow(10.0, Double(decimalPart))\n                    ^~~\n\
    /tmp/tmpe8ecgpna.swift:13:38: error: cannot find 'decimalPart' in scope\n    return\
    \ number * pow(10.0, Double(decimalPart))\n                                  \
    \   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return Double(Int64(number).truncatingRemainder(dividingBy:\
    \ Double(UInt64(1)))) / Double(10)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpkdsn1xq7.swift:9:33: error: value of type 'Int64' has no member\
    \ 'truncatingRemainder'\n    return Double(Int64(number).truncatingRemainder(dividingBy:\
    \ Double(UInt64(1)))) / Double(10)\n                  ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    // Truncate to nearest integer.\n    let factor = 1000.0;\n\
    \    return Double(number) / factor;\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpkzsqz_pr/tmpkzsqz_pr.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1b7eb2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1b7ba9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1b7ba9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1b7ba87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkzsqz_pr                        0x000055bb450e8215 <unavailable> + 4629

    5    libc.so.6                          0x00002ae1b809e460 __libc_start_main +
    245

    6    tmpkzsqz_pr                        0x000055bb450e7eb9 <unavailable> + 3769

    '
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    let num = ceil(Double(number))\n    return num * pow(10.0,\
    \ Double(trunc(log10(num))) + 1.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number: 1.25)\
    \ == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmptdxbev2j.swift:9:15: error: cannot find 'ceil' in scope\n    let\
    \ num = ceil(Double(number))\n              ^~~~\n/tmp/tmptdxbev2j.swift:10:18:\
    \ error: cannot find 'pow' in scope\n    return num * pow(10.0, Double(trunc(log10(num)))\
    \ + 1.0)\n                 ^~~\n/tmp/tmptdxbev2j.swift:10:35: error: cannot find\
    \ 'trunc' in scope\n    return num * pow(10.0, Double(trunc(log10(num))) + 1.0)\n\
    \                                  ^~~~~\n/tmp/tmptdxbev2j.swift:10:41: error:\
    \ cannot find 'log10' in scope\n    return num * pow(10.0, Double(trunc(log10(num)))\
    \ + 1.0)\n                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    switch Int(floor(log10(number) + 1)) { // +1 because\
    \ log10(0) is -Inf\n    case 0: return number\n    case 1: return round(number\
    \ * 10) / 10\n    case 2: return number - round(number * 10) / 10\n    case 3:\
    \ return number - round(number * 10) / 10\n    case 4: return number - round(number\
    \ * 10) / 10\n    case 5: return number - round(number * 10) / 10\n    case 6:\
    \ return number - round(number * 10) / 10\n    case 7: return number - round(number\
    \ * 10) / 10\n    case 8: return number - round(number * 10) / 10\n    case 9:\
    \ return number - round(number * 10) / 10\n    case 10: return number - round(number\
    \ * 10) / 10\n    case 11: return number - round(number * 10) / 10\n    case 12:\
    \ return number - round(number * 10) / 10\n    case 13: return number - round(number\
    \ * 10) / 10\n    case 14: return number - round(number * 10) / 10\n    case 15:\
    \ return number - round(number * 10) / 10\n    case 16: return number - round(number\
    \ * 10) / 10\n    case 17: return number - round(number * 10) / 10\n    case 18:\
    \ return number - round(number * 10) / 10\n    case 19: return number - round(number\
    \ * 10) / 10\n    case 20: return number - round(number * 10) / 10\n    case 21:\
    \ return number - round(number * 10) / 10\n    case 22: return number - round(number\
    \ * 10) / 10\n    case 23: return number - round(number * 10) / 10\n    case 24:\
    \ return number - round(number * 10) / 10\n    case 25: return number - round(number\
    \ * 10) / 10\n    case 26: return number - round(number * 10) / 10\n    case 27:\
    \ return number - round(number * 10) / 10\n    case 28: return number - round(number\
    \ * 10) / 10\n    case 29: return number - round(number * 10) / 10\n    case 30:\
    \ return number - round(number * 10) / 10\n    case 31: return number - round(number\
    \ * 10) / 10\n    case 32: return number - round(number * 10) / 10\n    case 33:\
    \ return number - round(number * 10) / 10\n    case 34: return number - round(number\
    \ * 10) / 10\n    case 35: return number - round(number * 10) / 10\n    case 36:\
    \ return number - round(number * 10) / 10\n    case 37: return number - round(number\
    \ * 10) / 10\n    case 38: return number - round(number * 10) / 10\n    case 39:\
    \ return number - round(number * 10) / 10\n    case 40: return number - round(number\
    \ * 10) / 10\n    case 41: return number - round(number * 10) / 10\n    case 42:\
    \ return number - round(number * 10) / 10\n    case 43: return number - round(number\
    \ * 10) / 10\n    case 44: return number - round(number * 10) / 10\n    case 45:\
    \ return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpuczqtixt.swift:73:46: error: expected '}' at end of brace statement\n\
    assert(truncate_number(number: 123.0) == 0.0)\n                              \
    \               ^\n/tmp/tmpuczqtixt.swift:8:48: note: to match this opening '{'\n\
    func truncate_number(number: Double) -> Double {\n                           \
    \                    ^\n/tmp/tmpuczqtixt.swift:9:16: error: cannot find 'floor'\
    \ in scope\n    switch Int(floor(log10(number) + 1)) { // +1 because log10(0)\
    \ is -Inf\n               ^~~~~\n/tmp/tmpuczqtixt.swift:9:22: error: cannot find\
    \ 'log10' in scope\n    switch Int(floor(log10(number) + 1)) { // +1 because log10(0)\
    \ is -Inf\n                     ^~~~~\n/tmp/tmpuczqtixt.swift:11:20: error: cannot\
    \ find 'round' in scope\n    case 1: return round(number * 10) / 10\n        \
    \           ^~~~~\n/tmp/tmpuczqtixt.swift:12:29: error: cannot find 'round' in\
    \ scope\n    case 2: return number - round(number * 10) / 10\n               \
    \             ^~~~~\n/tmp/tmpuczqtixt.swift:13:29: error: cannot find 'round'\
    \ in scope\n    case 3: return number - round(number * 10) / 10\n            \
    \                ^~~~~\n/tmp/tmpuczqtixt.swift:14:29: error: cannot find 'round'\
    \ in scope\n    case 4: return number - round(number * 10) / 10\n            \
    \                ^~~~~\n/tmp/tmpuczqtixt.swift:15:29: error: cannot find 'round'\
    \ in scope\n    case 5: return number - round(number * 10) / 10\n            \
    \                ^~~~~\n/tmp/tmpuczqtixt.swift:16:29: error: cannot find 'round'\
    \ in scope\n    case 6: return number - round(number * 10) / 10\n            \
    \                ^~~~~\n/tmp/tmpuczqtixt.swift:17:29: error: cannot find 'round'\
    \ in scope\n    case 7: return number - round(number * 10) / 10\n            \
    \                ^~~~~\n/tmp/tmpuczqtixt.swift:18:29: error: cannot find 'round'\
    \ in scope\n    case 8: return number - round(number * 10) / 10\n            \
    \                ^~~~~\n/tmp/tmpuczqtixt.swift:19:29: error: cannot find 'round'\
    \ in scope\n    case 9: return number - round(number * 10) / 10\n            \
    \                ^~~~~\n/tmp/tmpuczqtixt.swift:20:30: error: cannot "
  stdout: ''
  timestamp: 1660029179
- exit_code: -4
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        fatalError(\"cannot truncate\
    \ negative number\")\n    }\n    return number\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(truncate_number(number: 3.5) == 0.5)\nassert(truncate_number(number:\
    \ 1.25) == 0.25)\nassert(truncate_number(number: 123.0) == 0.0)"
  status: Exception
  stderr: 'tmpjk2y4b4n/tmpjk2y4b4n.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81f9b81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81f9878b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81f9878988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81f98777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjk2y4b4n                        0x0000556fb016f245 <unavailable> + 4677

    5    libc.so.6                          0x00002b81f9d6d460 __libc_start_main +
    245

    6    tmpjk2y4b4n                        0x0000556fb016eee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    if number < 0 {\n        return number * pow(10, ceil(log10(number)))\
    \ - 1.0\n    }\n    return number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(truncate_number(number:\
    \ 3.5) == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmpnx6fuprm.swift:10:25: error: cannot find 'pow' in scope\n     \
    \   return number * pow(10, ceil(log10(number))) - 1.0\n                     \
    \   ^~~\n/tmp/tmpnx6fuprm.swift:10:33: error: cannot find 'ceil' in scope\n  \
    \      return number * pow(10, ceil(log10(number))) - 1.0\n                  \
    \              ^~~~\n/tmp/tmpnx6fuprm.swift:10:38: error: cannot find 'log10'\
    \ in scope\n        return number * pow(10, ceil(log10(number))) - 1.0\n     \
    \                                ^~~~~\n"
  stdout: ''
  timestamp: 1660029178
- exit_code: 1
  program: "\n/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(number: 3.5)\n/// 0.5\nfunc truncate_number(number:\
    \ Double) -> Double {\n    return number - truncate_number(number: number, base:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(truncate_number(number: 3.5)\
    \ == 0.5)\nassert(truncate_number(number: 1.25) == 0.25)\nassert(truncate_number(number:\
    \ 123.0) == 0.0)"
  status: SyntaxError
  stderr: "/tmp/tmphqn0sejs.swift:9:59: error: extra argument 'base' in call\n   \
    \ return number - truncate_number(number: number, base: 1)\n                 \
    \                  ~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660029178
