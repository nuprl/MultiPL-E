name: HumanEval_99_closest_integer
language: swift
prompt: "\n/// Create a function that takes a value (string) representing a number\n\
  /// and returns the closest integer to it. If the number is equidistant\n/// from\
  \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
  \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
  /// Rounding away from zero means that if the given number is equidistant\n/// from\
  \ two integers, the one you should return is the one that is the\n/// farthest from\
  \ zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
  -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\n\
  assert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value: \"\
  -15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
  \ \"0\") == 0)"
completions: ["\tlet value = NumberParser().number(from: value) ?? 0\n\tlet min =\
    \ abs(value).floor()\n\tlet max = abs(value).ceiling()\n\tif value < 0 {\n\t\t\
    return min\n\t}\n\tif value > 0 {\n\t\treturn max\n\t}\n\treturn min", "    guard\
    \ let value = Int(value) else {\n        return -1\n    }\n    guard value >=\
    \ 0 && value < 100 else {\n        return -1\n    }\n    var diff: Int = 0\n \
    \   var maxDiff: Int = 0\n    for n in 1...100 {\n        let d = abs(value -\
    \ n)\n        if d > maxDiff {\n            maxDiff = d\n            diff = n\n\
    \        }\n    }\n    return diff", "\tlet stringValue = String(value)\n\tguard\
    \ let num = Int(stringValue) else { return 0 }\n\treturn Int(ceiling(Double(num)))",
  "    let floatValue = Float(value) ?? 0.0\n\n    if floatValue <= -0.00000001 {\n\
    \        return Int(-floatValue)\n    }\n\n    return Int(floor(floatValue + 0.5))",
  "    \n    // 1. If number is empty or null, return null\n    guard let num = value.toInt(),\
    \ num ~= 0 else { return Int64(0) }\n    \n    // 2. If number is equidistant\
    \ from two integers, round it away from zero\n    let diff = (abs(num - Int(num))\
    \ < abs(num - Int(Int(num))))\n    return Int(Double(num).rounded(.towardZero))",
  "    // The easiest way to deal with this problem is to use a string as a number\n\
    \    // and then convert it to a string representing a number.\n    let num:Double\
    \ = Double(value)\n    return Int(ceil(num))", "  var closest = Int(value)\n \
    \ if closest < 0 {\n    closest = 0\n  }\n  for i in 0..<MAX_INT_DIGITS {\n  \
    \  var delta = Int(value[MAX_INT_DIGITS-i-1])\n    if delta > closest {\n    \
    \  closest = delta\n    }\n  }\n  return closest", "    let value = value.parse()\n\
    \    let smallest: Int? = Int64(value - Int64((value % 1) == 0)) + 1\n    let\
    \ largest: Int? = Int64(value + Int64((value % 1) == 0)) - 1\n    if smallest\
    \ != nil {\n        return smallest!\n    }\n    if largest != nil {\n       \
    \ return largest!\n    }\n    return value", "    let floatValue = Float(value)\n\
    \    return Int(ceil(floatValue))", "    if let value = try? Double(value)?.rounded(.down)\
    \ {\n        return Int(value)\n    }\n    if let value = try? Float(value)?.rounded(.down)\
    \ {\n        return Int(value)\n    }\n    if let value = try? Int(value) {\n\
    \        return Int(value)\n    }\n    if let value = try? NSNumber(value).doubleValue()\
    \ {\n        return Int(value)\n    }\n    // FIXME: handle NaN, Inf, etc.\n \
    \   return 0", "    let trimmed = value.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \"-0123456789\"))\n    if trimmed.isEmpty {\n        return 0\n    }\n    var\
    \ closest: Int = 0\n    if let decimalIndex = trimmed.index(of: \".\") {\n   \
    \     let floatValue = (trimmed[..<decimalIndex]).compactMap(Int.init)\n     \
    \   let intValue = decimalIndex < trimmed.count - 1 ? Int(trimmed[decimalIndex...].compactMap(Int.init))\
    \ : 0\n        let halfway = (floatValue + intValue) / 2\n        if halfway <\
    \ closest {\n            closest = halfway\n        }\n    } else {\n        let\
    \ intValue = Int(trimmed.compactMap(Int.init))\n        if intValue < closest\
    \ {\n            closest = intValue\n        }\n    }\n    return closest", " \
    \   let number = NSScanner(string: value)\n    number.getInteger()\n    return\
    \ Int(number.integerValue)", "    // TODO: Handle negative numbers as well\n \
    \   // TODO: Handle decimal numbers correctly\n    guard let number = Int(value)\
    \ else {\n        return 0\n    }\n    let smallestNumber = number < 0 ? -number\
    \ : number\n    let smallestDifference = (number - smallestNumber).abs\n\n   \
    \ if smallestDifference < numberToClosestIntegerDistance {\n        return number\n\
    \    }\n\n    let largestDifference =\n        ((-number + numberToClosestIntegerDistance).abs()\
    \ - smallestDifference)\n\n    return smallestDifference > largestDifference ?\n\
    \        smallestNumber : number + numberToClosestIntegerDistance", "    // Get\
    \ first and second value from the string\n    let firstValue, secondValue = value.split(separator:\
    \ \".\").map { Int($0) }\n\n    // If first value is negative, add its absolute\
    \ value\n    if firstValue < 0 {\n        firstValue += firstValue\n    }\n\n\
    \    // If second value is negative, add its absolute value\n    if secondValue\
    \ < 0 {\n        secondValue += secondValue\n    }\n\n    // Calculate the difference\n\
    \    let difference = abs(firstValue - secondValue)\n\n    // Check if difference\
    \ is smaller than 1\n    if difference < 1 {\n        return firstValue\n    }\
    \ else {\n        return secondValue\n    }", "    var result = value.characters.reduce(0)\
    \ { $0 }\n    for digit in value.characters {\n        let charAsInt: Int = Int(digit)\n\
    \        let current: Int = result + charAsInt\n        result = current\n   \
    \ }\n    return result", "    // Return early\n    if value == \"\" {\n      \
    \  return 0\n    }\n\n    let decimal = Decimal(string: value)\n    if let dec\
    \ = decimal, dec.isZero {\n        return dec.negativeWrap().integerValue\n  \
    \  }\n\n    // Round down, return the integer value of the decimal\n    return\
    \ decimal.roundDown()", "    let value = value.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    guard value.characters.count == 3 else { return 0 }\n    let firstInt, secondInt,\
    \ third int\n    let components = value.components(separatedBy: \".\")\n    if\
    \ components.count == 2 {\n        firstInt, secondInt, third = components[0].parse(),\
    \ components[1].parse(), 0\n    } else if components.count == 3 {\n        firstInt,\
    \ secondInt, third = components[0].parse(), components[1].parse(), components[2].parse()\n\
    \    } else {\n        return 0\n    }\n    var closestToZero: Int\n    if firstInt\
    \ < secondInt {\n        closestToZero = secondInt\n    } else {\n        closestToZero\
    \ = firstInt\n    }\n    if third < closestToZero {\n        closestToZero = third\n\
    \    }\n    return closestToZero", "    if let num = Int(value) {\n        return\
    \ num\n    }\n\n    if let num = Double(value) {\n        let absValue = abs(num)\n\
    \        if absValue < 0.5 {\n            return num\n        } else {\n     \
    \       return ceil(absValue)\n        }\n    }\n\n    guard let num = Number(value)\
    \ else {\n        fatalError(\"Unable to create integer from value: \\(value).\"\
    )\n    }\n\n    var closestValue = num\n    var closestDistance: Double = abs(num)\n\
    \    for i in 0...Int(closestDistance) {\n        let num2 = closestValue * Double(i)\
    \ / Double(closestDistance)\n        let distance2 = abs(num2 - num)\n       \
    \ if distance2 < closestDistance {\n            closestValue = num2\n        \
    \    closestDistance = distance2\n        }\n    }\n\n    return closestValue",
  "\treturn closestInteger(toDouble(value))", '    return Int(value).rounded(to: .min)',
  "    if value == \"0\" {\n        return 0\n    }\n    let numberFormatter = NumberFormatter()\n\
    \    numberFormatter.numberStyle = .decimal\n    numberFormatter.locale = Locale(identifier:\
    \ \"en_US_POSIX\")\n    guard let double = numberFormatter.number(from: value)?.doubleValue\n\
    \    else {\n        return 0\n    }\n    let closestDouble = closestDouble(from:\
    \ double)\n    return Int(closestDouble)", "    let intValue: Int\n\n    guard\
    \ let intValue = Int(value) else { return 0 }\n\n    let closestToZero = abs(intValue)\
    \ - abs(intValue)\n\n    if closestToZero > 0 {\n        return intValue + closestToZero\n\
    \    }\n\n    return intValue", "    var n: Double = Double(value)\n    let intVal\
    \ = Double(Int(n))\n\n    // If the number is too close to zero we round to nearest\n\
    \    if (n < 0.0) {\n        n = -n\n        intVal = Int64(intVal + (n * 0.000000000001))\n\
    \    }\n\n    var intVal2: Int64 = Int64(intVal)\n\n    // Loop until we get an\
    \ actual integer\n    while (intVal2 % 1 != 0) {\n        intVal2 /= 1\n    }\n\
    \n    // return the rounded value\n    return Int64(intVal2)", "    var result\
    \ = Int64(math.MaxFloat64)\n    for c in value {\n        switch c {\n       \
    \ case '0':\n        case '1':\n        case '2':\n        case '3':\n       \
    \ case '4':\n        case '5':\n        case '6':\n        case '7':\n       \
    \ case '8':\n        case '9':\n            result = min(result, Int64(c - '0'))\n\
    \        default:\n            return Int64(math.MaxFloat64)\n        }\n    }\n\
    \    return result", '    return Int(round(Float(value)))', "    let result =\
    \ Int(value)\n    var min = result\n    var max = result\n    var distance = 0\n\
    \    for d in \"0123456789\".characters.reversed() {\n        let v = Int(value[distance..<distance+1])\n\
    \        min = min < v && v != min ? v : min\n        max = max > v && v != max\
    \ ? v : max\n        distance += 1\n    }\n    guard distance == value.characters.count\
    \ else { return result }\n    return min < max ? min : max", "    let number =\
    \ value.number\n    if number.isInfiniteOrNull {\n        return nil\n    }\n\
    \    let zero = Int(truncatingRemainder(dividingBy: number.decimal)) + 0.5\n \
    \   return Int(truncatingRemainder(dividingBy: number.decimal)) + 0.5", "  //\
    \ Find the difference between value and zero rounded to an integer.\n  let difference\
    \ = Int(round(value.doubleValue - 0.1))\n\n  // If difference is greater than\
    \ zero, then the value is closer than it was\n  // before.\n  if difference >\
    \ 0 {\n    return difference\n  }\n\n  // If the difference is negative then the\
    \ value is closer than it was\n  // before.\n  return -difference", "    defer\
    \ { _validateInput(value: value) }\n    return closestInteger(string: value)",
  "    let str = value.characters.compactMap { Double($0) }\n    return Int(ceil(str.min().powi(2)\
    \ - str.max().powi(2)))", "    let floatValue = Float(value)\n    let closestInteger\
    \ = Int(ceil(floatValue))\n\n    if closestInteger < 0 {\n        return -closestInteger\n\
    \    }\n\n    return closestInteger", "    var result = Int(value[0])\n    for\
    \ number in value.dropFirst() {\n        result = Int(number)\n        if result\
    \ > 0 {\n            return result\n        }\n    }\n    return result", "  \
    \  if let number = Float64(value),\n       let nearestInteger = Int(floor(number))\
    \ {\n        return nearestInteger\n    }\n    else if let number = Double(value),\n\
    \             let nearestInteger = Int(floor(number)) {\n        return nearestInteger\n\
    \    }\n    return 0", "    // TODO: Use a regexp to strip out non-digits\n  \
    \  guard let value = Int(\"\\(Int(value))\") else {\n        fatalError(\"invalid\
    \ integer value \\(String(describing: value))\")\n    }\n    var closestIndex\
    \ = value.nextClearBit(from: 0)\n    var closestValue = value\n\n    while closestIndex\
    \ >= 8 {\n        let currentValue = value.nextClearBit(from: closestIndex)\n\
    \        if abs(currentValue - closestValue) < abs(closestValue - value) {\n \
    \           closestValue = currentValue\n            closestIndex = closestIndex.nextClearBit(from:\
    \ closestIndex + 1)\n        } else {\n            closestIndex = closestIndex.nextClearBit(from:\
    \ closestIndex + 1)\n        }\n    }\n    return closestIndex", "\tvalue, err\
    \ := strconv.Atoi(value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif value <\
    \ 0 {\n\t\treturn -math.Ceil(float64(value))\n\t}\n\treturn math.Ceil(float64(value))",
  "    var closest: Int? = nil\n    let numbers = value.componentsSeparatedByString(\"\
    .\").map {\n        Int($0)\n    }\n    let lower = numbers.min()\n    let upper\
    \ = numbers.max()\n    closest = numbers.min(where: {\n        abs($0 - lower)\
    \ < abs($0 - upper)\n    })\n    return closest!", "    let number: Double = Double(value)\n\
    \    let difference = abs(number - ceil(number))\n    if difference < 0.00000000001\
    \ {\n        return ceil(number)\n    }\n    return round(number)", "  var num\
    \ = Int(value)\n  guard num > 0 else {\n    num = num - num % 1.0\n  }\n  return\
    \ num", '  return closestInteger(value.unicodeScalars)', "    let string = value.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines).lowercased()\n    if string == \"nan\"\
    \ { return 0 }\n    guard let intValue = Int(string) else {\n        throw Error.argument(\"\
    value\", \"value must be an integer\")\n    }\n    // TODO: use Double\n    guard\
    \ intValue >= 0 else {\n        throw Error.argument(\"value\", \"value must not\
    \ be negative\")\n    }\n    var closest: Int?\n    for num in -intValue, intValue\
    \ - 1, -intValue + 1, intValue {\n        let absDistance = abs(num - intValue)\n\
    \        if closest.isEmpty || absDistance < closest! {\n            closest =\
    \ num\n        }\n    }\n    return closest!", "    guard value.range(of: NumberFormatter.decimalSeparator)\
    \ == nil else { return 0 }\n\n    let intValue = Int((value ?? \"\") ?? \"\")\n\
    \    let fraction = intValue % 1\n    let integerPart = intValue - fraction\n\
    \    let exponent = abs(fraction) - Int(fraction.truncatingRemainder(dividingBy:\
    \ 1))\n\n    return integerPart + (exponent > 0 ? exponent : -exponent)", "  \
    \  if let number = Int(value) {\n        return number\n    }\n    if let number\
    \ = Double(value) {\n        if number < 0 {\n            return 0\n        }\n\
    \        return Int(number)\n    }\n    return 0", "    let parsedValue = Int(value)\n\
    \    return max(floor(parsedValue), parsedValue)", '    return Int(round(Float(String(cstr(value)))!))',
  '    return Int(value)', "    let value: Double = Double(value)\n    let zero =\
    \ floor(value / 1.0)\n    let diff = abs(value - zero)\n    if diff > 0.1 {\n\
    \        return Int(round(value + zero))\n    }\n    return Int(round(value -\
    \ zero))", "    // If the given value is zero, return zero.\n    if value == \"\
    \" {\n        return 0\n    }\n    // Split the value into a decimal and an integer.\n\
    \    let decimal = value.split(separator: \".\")[0]\n    let integer = Int(decimal)\n\
    \    // If the integer is equidistant from both its neighbors, return the\n  \
    \  // nearest integer.\n    if decimal.isCloseTo(\"0\") || decimal.isCloseTo(\"\
    -0\") {\n        return integer\n    }\n    // If the integer is equidistant from\
    \ two integers, round it away from\n    // zero.\n    return abs(integer - roundToNearestN(integer,\
    \ 2))", "    guard let num = Int(value) else { return 0 }\n    let negative =\
    \ num < 0\n    let diff = abs(num - Int(value))\n    if diff > 0 || (diff == 0\
    \ && num != 0) {\n        return negative ? -num : num\n    }\n    return negative",
  "    var num = value.toDouble()\n    var closest = 0\n    while num > 0 {\n    \
    \    closest += 1\n        num -= num.toDouble()\n    }\n    return Int(closest)",
  "    guard let num = NSDecimalNumber(string: value)?.decimalValue else {\n     \
    \   return -1\n    }\n    return Int(round(num)) + minInt", "    guard let num\
    \ = Int(value) else { return 0 }\n    var difference = num\n    if num == 0 ||\
    \ num == -1 {\n        difference = 0\n    } else {\n        for _ in 0..<4 {\n\
    \            guard num != 0 else { return 0 }\n            difference = abs((num\
    \ - difference) / num)\n        }\n    }\n    if difference != 0 {\n        return\
    \ num + difference\n    } else {\n        return num\n    }", "    guard let number\
    \ = Float(String(value)),\n          let closestInteger = Int(number),\n     \
    \     closestInteger > 0 else {\n        throw AbortError(message: \"Cannot return\
    \ closest integer with value \\(String(value))\")\n    }\n    return closestInteger",
  "    let number = Int(value)\n    if number < 0 {\n        return -(number + 1)\n\
    \    }\n    if number == 0 || number % 1 != 0 {\n        return number\n    }\n\
    \    if number % 2 == 0 {\n        return number / 2\n    }\n    return 3*number\
    \ + 1", '    return Int(value) |> round', "    switch value {\n    case \".inf\"\
    : return math.Inf(.tiny)\n    case \".nan\": return math.NaN\n    case \"\": return\
    \ 0\n    case \"+inf\": return math.Inf(.tiny)\n    case \"-inf\": return math.Inf(.tiny)\n\
    \    case \"+nan\": return math.NaN\n    case \"-nan\": return math.NaN\n    case\
    \ \"inf\": return math.Inf(.tiny)\n    case \"nan\": return math.NaN\n    case\
    \ \"-inf\": return -math.Inf(.tiny)\n    case \"+nan\": return -math.NaN\n   \
    \ case \"-nan\": return -math.NaN\n    case \"+inf\": return math.Inf(.tiny)\n\
    \    case \"+inf\": return math.Inf(.tiny)\n    case \"-inf\": return -math.Inf(.tiny)\n\
    \    case \"-inf\": return -math.Inf(.tiny)\n    default:\n        var inf = Float(value)\n\
    \        if math.IsNaN(inf) || math.IsInf(inf) {\n            return math.NaN\n\
    \        }\n        var result = inf\n        if math.Abs(result) == result {\n\
    \            if math.Abs(result) == result {\n                result = math.Abs(result)\n\
    \            }\n            if math.Abs(result) == result {\n                result\
    \ = math.Abs(result)\n            }\n        }\n        return result\n    }",
  "    let num = value.toInt()\n    \n    func round_towards_zero(number: Double)\
    \ -> Double {\n        let floor = floor(number)\n        return floor(number-number-floor)\n\
    \    }\n    \n    return round_towards_zero(number: num)", "    if let value =\
    \ Float(string: value) {\n        let fractionalPart = Double(value) - Double(truncating:\
    \ value)\n        let integerPart = Int(truncating: fractionalPart)\n        return\
    \ integerPart\n    }\n    return 0", '    return Int(value)', "    let floatVal\
    \ = Float(value)\n    if floatVal >= 0.5 {\n        return Int(floatVal)\n   \
    \ } else {\n        return Int(floatVal) + 1.0\n    }", "    let numberString\
    \ = value.map { $0.toInt() }\n    var smallest = Int64.min\n    var largest =\
    \ Int64.max\n    for i in numberString {\n        smallest = Int64(minimum(smallest,\
    \ i))\n        largest = Int64(maximum(largest, i))\n    }\n    if largest < smallest\
    \ {\n        largest = Int64(maximum(0, largest))\n    }\n    return largest",
  "    guard let number = Int(value) else {\n        return defaultValue\n    }\n\
    \    \n    let min = number - defaultValue\n    let max = number + defaultValue\n\
    \    \n    if min < 0 {\n        return min\n    } else if max < 0 {\n       \
    \ return max\n    } else if min == 0 {\n        return number\n    } else {\n\
    \        return max\n    }", "    let doubleValue = Double(value)\n    let rounded\
    \ = Int((doubleValue + Double.pi).rounded())\n    return rounded", "\tlet parsedValue\
    \ = Double(value)\n\tguard parsedValue != .zero else {\n\t\tpreconditionFailure(\"\
    Non numeric value passed\")\n\t}\n\n\t// If value is equidistant, round it away\
    \ from zero.\n\tlet distanceFromZero = abs(value - Double(floor(Double(value))))\n\
    \n\tif distanceFromZero < DISTANCE_EPSILON {\n\t\t// If distance is small (less\
    \ than epsilon as defined) then return the\n\t\t// original value as it is.\n\t\
    \treturn value\n\t}\n\n\tswitch distanceFromZero {\n\tcase .some(let distance):\n\
    \t\t// Round the value towards zero.\n\t\tlet newValue = value - distance\n\t\t\
    // If newValue is closer to zero, return it. Else, return the\n\t\t// original\
    \ value.\n\t\treturn newValue < 0 ? value : newValue\n\tcase .some(let distance):\n\
    \t\t// Round the value towards the closest integer.\n\t\tlet newValue = round(value\
    \ - distance)\n\t\t// If newValue is closer to zero, return it. Else, return the\n\
    \t\t// original value.\n\t\treturn newValue < 0 ? value : newValue\n\tdefault:\n\
    \t\t// Value is equidistant to two other values. Return the\n\t\t// original value.\n\
    \t\treturn value\n\t}", '    return Int(closestIntTo(value))', "  var num: Double\
    \ = Double(value)\n  num = (num + 0.5).round()\n  return Int(num)", "    if let\
    \ v = Double(value) {\n        return Int(floor(v))\n    }\n    return Int(round(value))",
  "\tlet decimal = Decimal(string: value)\n\tguard let closestInteger = decimal.closestValueInt()\
    \ else {\n\t\treturn Int(round(value))\n\t}\n\treturn closestInteger", "  // TODO:\
    \ use math/round\n  var closest = 0\n  for i in 0..<value.count {\n    let iValue\
    \ = Int(value[i])\n    let diff = (iValue - closest)\n    closest = (closest +\
    \ iValue) % 16\n    if diff > 0 && closest != 0 {\n      closest = (closest +\
    \ 16) % 16\n    }\n  }\n  return closest", '    return Int(round(NSSingleEntryIndex.value(for:
    value)?.closestTo(.nearest)))', "    var intValue = Int(value)\n    if intValue\
    \ < 0 {\n        intValue = abs(intValue)\n    }\n    var closestToZero = intValue\n\
    \    var closestToEnd = intValue\n    var distance = 0\n\n    while closestToZero\
    \ < 0 && closestToEnd < 0 {\n        closestToZero = abs(closestToZero)\n    \
    \    closestToEnd = abs(closestToEnd)\n        distance = distance + 1\n    }\n\
    \    if closestToZero == closestToEnd {\n        return closestToZero\n    }\n\
    \    if closestToZero > closestToEnd {\n        closestToZero = closestToEnd +\
    \ 1\n    }\n    return closestToZero", "    let number = Double(value)\n    return\
    \ Int(ceil(number))", "    let float = Double(value)\n    let closest = Int(floor(float))\n\
    \    if closest == 0 {\n        closest = 1\n    }\n    return closest", "   \
    \ if let value = Double(value) {\n        let value = floor(value / Double(10_000_000))\n\
    \        return value >= Int(0) ? value : Int(value)\n    } else {\n        //\
    \ Not a number, so just return 0\n        return 0\n    }", "\tlet parts = value.componentsSeparatedByCharactersInSet([NSCharacterSet.decimalDigitCharacterSet()])\n\
    \tvar closestInteger = parts[0].toInt()\n\tlet difference = abs(closestInteger\
    \ - parts[1].toInt())\n\t\n\tswitch difference {\n\tcase 0...2:\n\t\treturn closestInteger\n\
    \tcase 2...3:\n\t\treturn closestInteger - 1\n\tdefault:\n\t\treturn closestInteger\
    \ + 1\n\t}", '  return closestInteger(value)', "    var result = Int(value)\n\
    \    if result >= 1 && result <= 99999 {\n        return Int(value) + Int(result/1000)\n\
    \    }\n    return result", "\treturn Int(value)", "    var numberAsInt = Int(value)\n\
    \    if numberAsInt == value {\n        return 0\n    }\n    // We need to check\
    \ numberAsInt as string\n    let distanceFromZero = abs(numberAsInt - Int(value))\n\
    \n    if distanceFromZero < abs(numberAsInt - Int(value)) {\n        return numberAsInt\n\
    \    }\n\n    if distanceFromZero < abs(numberAsInt - Int(value) + 1) {\n    \
    \    return numberAsInt + 1\n    }\n\n    if distanceFromZero < abs(numberAsInt\
    \ - Int(value) - 1) {\n        return numberAsInt - 1\n    }\n\n    return numberAsInt",
  "    let value = value.trimmingCharacters(in: .whitespacesAndNewlines).parse() ??\
    \ 0\n    guard value >= 0 else { fatalError(\"value is less than or equal to zero\"\
    ) }\n    if value % 2 != 0 {\n        if value < 0 && value % 2 == 1 {\n     \
    \       return -(value+1)\n        } else if value > 0 && value % 2 == 0 {\n \
    \           return (value - 1)\n        } else {\n            return value\n \
    \       }\n    } else {\n        return -value\n    }", "    let digits = value.chars\n\
    \        .filter { CharacterSet.decimalDigits.isSuperset(of: $0) }\n        .map\
    \ { Int(String($0)) }\n    return closestIndex(digits, 0)", "    let floatValue\
    \ = Float(value)\n    var closestValue: Int = 0\n    let diff = abs(floatValue\
    \ - nearestInt(floatValue))\n    for integer in 1...100 {\n        if abs(nearestInt(Float(integer)\
    \ - floatValue)) < diff {\n            closestValue = integer\n            diff\
    \ = abs(nearestInt(Float(integer) - floatValue))\n        }\n    }\n    return\
    \ closestValue", "    let number = value.parse()\n    return number.round().toInt()",
  "    guard let convertedValue = Float(string: value) else {\n        return 0\n\
    \    }\n\n    func distance(x: Float, y: Float) -> Int {\n        return Int(pow(max(abs(x),\
    \ abs(y)), 0.5))\n    }\n\n    var closest = 0\n    let sortedValues = value.characters.sorted()\n\
    \    let closestPair = sortedValues.last?.distance(\n        value: convertedValue,\n\
    \        fromX: sortedValues.first!\n    )\n    if closestPair > 0 {\n       \
    \ let diff = sortedValues.last! - sortedValues.first!\n        if diff < closest\
    \ {\n            closest = diff\n            closestPair = 0\n        }\n    }\n\
    \n    if closestPair == 0 {\n        return Int(round(convertedValue))\n    }\
    \ else {\n        return Int(round(nearestInteger(convertedValue, closestPair:\
    \ closestPair)))\n    }", '    return Int(ceil(value))', "    var value =  StringInt(value)\n\
    \    if value.is_neg {\n        value = -value.value\n    }\n    var closest_integer\
    \ = value\n    var difference = value.value - closest_integer.value\n    if abs(difference)\
    \ < abs(closest_integer.value - value.value) {\n        closest_integer = value.value\n\
    \    }\n    difference = closest_integer.value - value.value\n    if abs(difference)\
    \ < abs(closest_integer.value - value.value) {\n        closest_integer = value.value\n\
    \    }\n    return Int64(closest_integer)", "    let value = value.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    let float = Float(value)\n    return\
    \ Int(floor(abs(float)))", '  return int(closestToZero(toDouble(value)))', " \
    \   let intvalue = Int16(value)!\n    let closest = abs(intvalue - int64(intvalue))\n\
    \    if closest < int64(int(Int64(Int32.max))) {\n        return int64(intvalue)\n\
    \    }\n    return int64(intvalue - int64(closest))", '    return Int(floor(Double(value).truncatingRemainder(dividingBy:
    1.0)))', "    \n    let value = value.doubleValue\n    \n    // The numbers can\
    \ be equidistant if the first number is smaller.\n    // The numbers can be equidistant\
    \ if the second number is smaller.\n    // The numbers don't need to be in that\
    \ order.\n    var firstNumber = Int(ceil(Double(value)))\n    var secondNumber\
    \ = Int(floor(Double(value)))\n    \n    // If the numbers are equidistant, return\
    \ the closest number.\n    if firstNumber == secondNumber {\n        return firstNumber\n\
    \    }\n    \n    // If the first number was larger, swap them.\n    if firstNumber\
    \ > secondNumber {\n        let tmp = firstNumber\n        firstNumber = secondNumber\n\
    \        secondNumber = tmp\n    }\n    \n    // If the second number was larger,\
    \ swap them.\n    if firstNumber > secondNumber {\n        let tmp = firstNumber\n\
    \        firstNumber = secondNumber\n        secondNumber = tmp\n    }\n    \n\
    \    // If the numbers are equal, return the smaller number.\n    if firstNumber\
    \ == secondNumber {\n        return firstNumber\n    }\n    \n    // Otherwise\
    \ return the smaller of the first two numbers.\n    return firstNumber", "   \
    \ if let string = try? float(value) {\n        let value = Int32(string)\n   \
    \     let two = value * 2.0\n        let half = value * 0.5\n        if value\
    \ >= 0 {\n            return Int(round(value / two) * two)\n        } else {\n\
    \            return Int(round(value / half) * half) - value\n        }\n    }\n\
    \    return Int()", "    var result = Int(value)\n    if result == Int(value)\
    \ {\n        return Int(value)\n    }\n    if result < 0 {\n        let absResult\
    \ = abs(result)\n        if absResult < result {\n            if result > 0 {\n\
    \                result = result - absResult\n            } else {\n         \
    \       result = absResult + result\n            }\n        }\n    }\n    return\
    \ result", "  let intValue = Int(value)\n  let zeroValue = Int(0)\n  let minValue\
    \ = Int64(Int64.max) - 1\n  let maxValue = Int64(Int64.min)\n\n  let result =\
    \ (intValue - zeroValue) * Int64(Int64(Int64.min) / intValue)\n\n  return Int(result)",
  "    let decimal = Decimal(string: value)\n    return decimal.intValue", "    let\
    \ intValue = value.c\n    let sign = Int8(value == \"-\" ? -1 : 1)\n    return\
    \ sign == Int8(value == \"0\" ? 0 : intValue)\n        ? sign * int(round(x))\n\
    \        : intValue", "    guard let number = NumberFormatter().number(from: value)\
    \ else {\n        return defaultValue\n    }\n    let closest = (number.doubleValue\
    \ * 100).round()\n    return closest", "  let fraction = value.split(separator:\
    \ \",\").last!\n  return Double(fraction)", "    var integer: Int\n    if let\
    \ _ = integer.from(value: value) {\n        return integer\n    }\n    \n    guard\
    \ let floatValue = Double(string: value) else {\n        return 0\n    }\n   \
    \ \n    guard floatValue > 0 else { return 0 }\n    \n    let remainders = floatValue\
    \ % 1\n    return Int(ceil(remainders))", '    return Int(ceil(Double(value)).toInt())
    * sign', "\tlet ints = value.characters\n\t\t.map({ Int(String($0)) })\n\t\t.sorted()\n\
    \t\t.map({ abs($0) })\n\t\t.prefix(1)\n\t\t.reduce(0, +)\n\treturn ints", "  \
    \  guard let parsed = NumberFormatter().number(from: value) else {\n        return\
    \ -1\n    }\n    let isNegative = value.characters.count < value.startIndex\n\
    \    let closestInteger: Int?\n    switch parsed.exponent {\n    case .nan:\n\
    \        closestInteger = nil\n    case .normal:\n        closestInteger = Int(parsed.value)\
    \ + Int(isNegative) * abs(Int(parsed.value))\n    default:\n        closestInteger\
    \ = Int(parsed.value) + Int(isNegative) * abs(Int(parsed.value)) + Int(parsed.exponent\
    \ - 1)\n    }\n    guard closestInteger != nil else {\n        return -1\n   \
    \ }\n    return closestInteger!", "    let digits = value.unicodeScalars.filter\
    \ { $0.value > 0 }\n        .sorted { $0.value > $1.value }\n        .map { Int($0.value)\
    \ }\n    return Int(digits.reversed().first!)", "    // TODO: replace with math.isClose\n\
    \    let closestInteger = Int(value)\n    if closestInteger == value {\n     \
    \   // Same number, so return immediately\n        return closestInteger\n   \
    \ }\n    \n    // Find closest integer that is larger than or equal the given\
    \ number\n    for i in 1..9 {\n        if closestInteger >= Int(Int64(i)*10) {\n\
    \            return Int(Int64(i)*10)\n        }\n    }\n    // If no integer larger\
    \ than or equal the given number is found,\n    // just return the given number\n\
    \    return Int(value)", "    // TODO: add support for floats\n    // TODO: add\
    \ support for negative numbers\n    // TODO: Add support for decimals\n    //\
    \ TODO: Add support for scientific notation (e.g. 5.005e+4)\n    let value = NumberFormatter().number(from:\
    \ value)?.intValue\n    if value != nil {\n        if let value = value {\n  \
    \          let difference = abs(value - Int64(value!))\n            if difference\
    \ < Int64(Int64(Int64(1))/2) {\n                return Int64(Int64(value!))\n\
    \            } else {\n                return Int64(0)\n            }\n      \
    \  } else {\n            return Int64(0)\n        }\n    } else {\n        return\
    \ Int64(0)\n    }", '    return Int(trunc(value))', "  // TODO: this does not\
    \ handle \"infinity\", which is equidistant to zero\n  // and therefore returns\
    \ \"-1\"\n  guard let parsedValue = Double(value) else { return -1 }\n  let closestValue\
    \ = closestIntegerFromZero(parsedValue)\n  if closestValue == parsedValue {\n\
    \    return closestValue\n  } else {\n    return parsedValue\n  }", "    let value\
    \ = value.stringValue\n    var result = Int(0)\n\n    if value == \"\" || value.characters.count\
    \ == 0 {\n        return 0\n    }\n\n    let digits: [[Double]] = [\n        [1.0,\
    \ 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0],\n        [2.0, 3.0, 4.0,\
    \ 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0],\n        [13.0, 14.0, 15.0, 16.0,\
    \ 17.0, 18.0, 19.0, 20.0, 21.0, 22.0],\n        [23.0, 24.0, 25.0, 26.0, 27.0,\
    \ 28.0, 29.0, 30.0, 31.0, 32.0],\n        [33.0, 34.0, 35.0, 36.0, 37.0, 38.0,\
    \ 39.0, 40.0, 41.0, 42.0],\n        [43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0,\
    \ 50.0, 51.0, 52.0],\n        [53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0,\
    \ 61.0, 62.0],\n        [63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0,\
    \ 72.0],\n        [73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0],\n\
    \        [83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0],\n     \
    \   [93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0, 101.0, 102.0],\n       \
    \ [103.0, 104.0, 105.0, 106.0, 107.0, 108.0, 109.0, 110.0, 111.0, 112.0],\n  \
    \      [113.0, 114.0, 115.0, 116.0, 117.0, 118.0, 119.0, 120.0, 121.0, 122.0],\n\
    \        [123.0, 124.0, 125.0, 126.0, 127.0, 128.0, 129.0, 130.0, 131.0, 132.0],\n\
    \        [133.0, 134.0, 135.0, 136.0, 137.0, 138.0, 139.0, 140.0, 141.0, 142.0],\n\
    \        [143.0, 144.0, 145.0, 146.0, 147.0, 148.0, 149.0, 150.0, 151.0, 152.0],\n\
    \        [153.0, 154.0, 155.0, 156.0, 157.0, 158.0, 159.0, 160.0, 161.0, 162.0],\n\
    \        [163.0, 164.0, 165.0, 166.0, 167.0, 168.0, 169.0, 170.0, 171.0, 172.0],\n\
    \        [173.0, 174.0, 175.0, 176.0, 177.0, 178.0, 179.0, 180.0, 181.0, 182.0],\n\
    \        [183.0, 184.0, 185.0, 186.0, ", "    guard value.contains(\".\") else\
    \ {\n        return Int(value)\n    }\n\n    let components = value.components(separatedBy:\
    \ \".\")\n    guard components.count >= 2 else {\n        return 0\n    }\n  \
    \  let digits = components[0].unicodeScalars.filter({ $0 >= 48 && $0 <= 57 }).count\n\
    \    let frac = components[0].unicodeScalars.filter({ $0 >= 0x3000 && $0 <= 0x36fb\
    \ }).count\n    if digits == 0 {\n        return 0\n    }\n    if digits < frac\
    \ {\n        return Int(value)\n    }\n    if digits > frac {\n        return\
    \ Int(value)\n    }\n    return Int(value).rounded(to: .down)", "  let value:\
    \ Int\n  if let num = Int(\"\\(Float(Double(value))).floor\") {\n    value = num\n\
    \  } else if let num = Int(\"\\(Double(value)).floor\") {\n    value = num\n \
    \ } else if let num = Int(value) {\n    value = num\n  } else {\n    return 0\n\
    \  }\n  guard value > 0 else {\n    return 0\n  }\n  let min = Int(value - 1)\n\
    \  let max = Int(value + 1)\n  return min > max ? min : max", "    // TODO: use\
    \ BigInt\n    var closest: Int\n    if value.hasPrefix(\"-\") {\n        let value\
    \ = value.dropFirst()\n        let decimal = value.dropLast()\n        let number\
    \ = decimal.toInt()\n        closest = (number - 1) - (number % 1)\n    } else\
    \ {\n        let number = value.toInt()\n        closest = (number - 1) + (number\
    \ % 1)\n    }\n    if closest < 0 {\n        closest += 1\n    }\n    return closest",
  "    guard let number = Double(value) else {\n        fatalError(\"Invalid number\"\
    )\n    }\n\n    let offset = abs(number.signum - Double.sign.signum)\n    let\
    \ roundingOffset = offset % 1\n    var closest: Int = 0\n    var closestRoundingOffset:\
    \ Double = 0.\n    let divisor = Double(ceil(ceil(Float(number) / 10.0)))\n\n\
    \    guard divisor != 0 else {\n        fatalError(\"Can't divide by zero\")\n\
    \    }\n\n    let maxRoundingOffset = divisor - offset\n    if maxRoundingOffset\
    \ < 0.0 {\n        fatalError(\"Can't divide by zero or negative\")\n    }\n \
    \   guard maxRoundingOffset > 0.0 else {\n        fatalError(\"Can't divide by\
    \ zero or negative\")\n    }\n    while number > 0 && closest == 0 {\n       \
    \ let nextDivisor = ceil(ceil(Float(number) / divisor))\n        if nextDivisor\
    \ != divisor {\n            closest = nextDivisor - 1\n            closestRoundingOffset\
    \ = nextDivisor - divisor\n        } else {\n            closest = nextDivisor\n\
    \            closestRoundingOffset = offset\n        }\n        number -= closest\n\
    \        divisor -= closest\n        maxRoundingOffset -= closestRoundingOffset\n\
    \    }\n\n    let nearest: Double = number + (offset * closest)\n    return round(nearest)",
  "    let string = value.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    let length = string.count\n\n    guard length > 0 else {\n        return\
    \ 0\n    }\n\n    var smallest = Int.max\n\n    for i in 1..<length {\n      \
    \  let value = string.index(string.startIndex, offsetBy: i, limitedBy: string.endIndex)\n\
    \        let result = Int(string[value])\n\n        if smallest == Int.max ||\
    \ result < smallest {\n            smallest = result\n        }\n    }\n\n   \
    \ return smallest", '    return Int(round(100 * Double(value)))', "    let floatValue\
    \ = Float(value)\n    if let integer = Int(floatValue) {\n        return integer\n\
    \    }\n    if floatValue < 0.0 {\n        return 0.0\n    }\n    if floatValue\
    \ > 0.0 {\n        return Int(floor(floatValue) + 1.0)\n    }\n    return Int(ceil(floatValue))",
  "    var number = Int(value)\n    var closest = 1\n\n    if number < 0 {\n     \
    \   closest = -(number + 1)\n    }\n\n    for number in 1...closest/2 {\n    \
    \    if abs(number - Int(value)) == abs(closest - Int(value)) {\n            break\n\
    \        }\n    }\n\n    return number", "    switch value {\n    case \"+inf\"\
    , \"+inf+\", \"+inf-inf\":\n        return math.MaxInt64\n    case \"-inf\", \"\
    -inf-\", \"+inf+inf\":\n        return -math.MaxInt64\n    case \"-inf\", \"+inf-\"\
    , \"+inf-inf\":\n        return -math.MaxInt64\n    case \"+inf\", \"-inf\", \"\
    +inf-inf\":\n        return -math.MaxInt64\n    case \"-inf\", \"-inf\", \"+inf+inf\"\
    :\n        return math.MaxInt64\n    case \"0\", \"1\", \"2\", \"3\", \"4\", \"\
    5\", \"6\", \"7\", \"8\", \"9\":\n        return Int(value)\n    case \"1\":\n\
    \        return Int(value) + 1 // \"101\" => 11\n    case \"2\":\n        return\
    \ Int(value) + 2 // \"121\" => 12\n    case \"3\":\n        return Int(value)\
    \ + 3 // \"123\" => 13\n    case \"4\":\n        return Int(value) + 4 // \"1234\"\
    \ => 14\n    case \"5\":\n        return Int(value) + 5 // \"12345\" => 15\n \
    \   case \"6\":\n        return Int(value) + 6 // \"123456\" => 16\n    case \"\
    7\":\n        return Int(value) + 7 // \"1234567\" => 17\n    case \"8\":\n  \
    \      return Int(value) + 8 // \"12345678\" => 18\n    case \"9\":\n        return\
    \ Int(value) + 9 // \"123456789\" => 19\n    case \"10\":\n        return Int(value)\
    \ + 10 // \"1234567890\" => 20\n    case \"11\":\n        return Int(value) +\
    \ 11 // \"12345678901\" => 21\n    case \"12\":\n        return Int(value) + 12\
    \ // \"123456789012\" => 22\n    case \"13\":\n        return Int(value) + 13\
    \ // \"1234567890123\" => 23\n    case \"14\":\n        return Int(value) + 14\
    \ // \"12345678901234\" => 24\n    case \"15\":\n        return Int(value) + 15\
    \ // \"123456789012345\" => 25\n    case \"16\":\n        return Int(value) +\
    \ 16 // \"1234567890123456789\" => 26\n    case \"17\":\n        return Int(value)\
    \ + 17 // \"12345678901234567890\" => 27\n    case \"18\":\n        return Int(value)\
    \ + 18 // \"123456789012345678901\" => 28\n    case \"19\":\n        return Int(value)\
    \ + 19 // \"1234567890123456789012\" => 29\n    case \"20\":\n        return Int(value)\
    \ + 20 // \"12345678901234567890123\" => 30\n    case \"21\":\n        return\
    \ Int(value) + 21 // \"123456789012345678901234\" => 31\n    ", "    guard let\
    \ input = Int64(value) else {\n        return 0\n    }\n    \n    let min = abs(input)\n\
    \    let closest = (min + input) / 2.0\n\n    if input == closest {\n        return\
    \ input\n    }\n    \n    return closest", '    return Int(round(Double(number:
    value).rounded()))', "    let result = Int(value.toDouble())\n    return isClosestTo(result,\
    \ Int((Double(1) - Double(result)) * 100))", "    let int = Int(value)\n    if\
    \ int < 0 {\n        return -int(abs(int))\n    }\n    return int(abs(int))",
  "    let intValue = Int64(value)\n    let diffValue = intValue - intValue.truncatingRemainder(dividingBy:\
    \ 1)\n    guard diffValue == 0 || diffValue != diffValue.truncatingRemainder(dividingBy:\
    \ 1) else {\n        return 0\n    }\n    return intValue.truncatingRemainder(dividingBy:\
    \ 1)", "    let intVal = Int(value)\n    let intDiff = abs(value - intVal)\n\n\
    \    if intDiff < Int64(MATH_EPSILON) {\n        return intVal\n    }\n\n    if\
    \ intDiff < abs(intVal * 2 - 1) {\n        return intVal + 1\n    }\n\n    return\
    \ intVal - 1", "    let result = Int(value)\n    let difference = abs(result -\
    \ value)\n    if difference < Int(Int64(difference) * 0.5) {\n        return result\n\
    \    }\n    return result", "    let radix: Int\n    let digit: Int\n    if let\
    \ stringValue = Double(string: value).round(to: .down), let stringValueString\
    \ = stringValue.toString() as? String {\n        radix = stringValueString.count\n\
    \        let decimal = stringValueString.index(stringValueString.startIndex, offsetBy:\
    \ 1)\n        digit = Int(stringValueString.substring(from: decimal + 1..<decimal))\n\
    \    } else {\n        radix = 10\n        digit = value.index(value, offsetBy:\
    \ 1)\n    }\n    var closest: Int = 0\n    var current: Int = 0\n    for _ in\
    \ 0..<Int(radix) {\n        current += digit * radix\n        current = Int(current)\n\
    \        if current < closest {\n            closest = current\n        }\n  \
    \  }\n    return closest", "    let v = Double(value)\n    guard v.truncatingRemainder(dividingBy:\
    \ 1) == 0 else { return 0 }\n    return Int(ceil(Double(v)))", "    // Check empty\
    \ case\n    if value == \"\" {\n        return 0\n    }\n\n    // Parse the value\n\
    \    let newValue = NSNumberFormatter().numberFromString(value).intValue\n   \
    \ \n    // Handle edge cases\n    if newValue <= 0 {\n        return newValue\n\
    \    }\n\n    var closestInteger: Int = newValue\n    var closestIntegerDifference:\
    \ Int = newValue\n\n    // Compare with the first integer\n    for let currentInteger\
    \ in 0..<closestInteger - 1 {\n        // Find the difference between the current\
    \ number and the next number\n        let currentIntegerDifference = closestIntegerDifference\
    \ - currentInteger\n\n        // If the current difference is smaller, replace\
    \ it\n        if currentIntegerDifference < closestIntegerDifference {\n     \
    \       closestIntegerDifference = currentIntegerDifference\n            closestInteger\
    \ = currentInteger\n        }\n    }\n\n    return closestInteger", "    let (integer,\
    \ frac) = value.decimalNumber\n    if integer == nil {\n        return 0\n   \
    \ }\n\n    func closest(\n        integer: Int,\n        fraction: Double,\n \
    \       factor: Double,\n    ) -> Double {\n        guard abs(fraction - factor)\
    \ < abs(fraction - integer) else {\n            return fraction\n        }\n\n\
    \        return integer\n    }\n\n    var factor: Double\n    var integer: Int\n\
    \n    if fractionalIntegerPart(value: value) != nil {\n        (integer, factor)\
    \ = fractionalIntegerPart(value: value)\n    } else {\n        (integer, factor)\
    \ = integer(value: value)\n    }\n\n    guard abs(integer - round(integer)) <\
    \ abs(integer - round(integer)) else {\n        return 0\n    }\n\n    return\
    \ closest(integer: integer, fraction: frac, factor: factor)", '    return Int(roundf(Float(NSNumber(value:
    value).floatValue)))', '    return Int((value ?? "").closest())', "    if let\
    \ number = Int(value) {\n        return number\n    }\n    else if let number\
    \ = Int(value, radix: 10.0) {\n        return number\n    }\n    else if let number\
    \ = Int(value, radix: 2) {\n        return number\n    }\n    else if let number\
    \ = Int(value, radix: 8) {\n        return number\n    }\n    else {\n       \
    \ fatalError(\"Not a valid int: \\(value).\")\n    }", "    var num: Int? = nil\n\
    \    var divisor: Int? = nil\n    if let x = Int(value) {\n        num = Int(x)\n\
    \    }\n    if let y = Int(value) {\n        divisor = Int(y)\n    }\n    var\
    \ min = num\n    var max = num\n    if divisor! > 1 {\n        for i in 1..divisor!\
    \ {\n            if min == nil && max == nil {\n                min = (i * num!)\n\
    \                max = i\n            }\n            if min! < max! {\n      \
    \          min! = (i * num!)\n            }\n            max -= 1\n        }\n\
    \    }\n    if divisor! < -1 {\n        for i in -1..-divisor! {\n           \
    \ if min == nil && max == nil {\n                max = -((i * num!) + 1)\n   \
    \             min = -i\n            }\n            if min! > max! {\n        \
    \        max! = (i * num!)\n            }\n            min += 1\n        }\n \
    \   }\n    return min!", '    return Int(value) ~= 0 ? (Int(value) ~= 1 ? Int(value)
    : Int(value) - 1) : 0', "\tlet v = value.cString(using: String.Encoding.utf8)\
    \ ?? \"\"\n\tlet r = Regex(\"^-?\\\\d+(\\\\.\\\\d+)?$\")\n\tif r.firstMatch(in:\
    \ v) != nil {\n\t\tlet value = r.firstMatch(in: v)!.range(at: 1).length\n\t\t\
    return Int(value)\n\t}\n\treturn Int(value)!", "    guard let number = Double(value)\
    \ else {\n        return 0\n    }\n    \n    var closest = 0\n    \n    if number\
    \ < 0 {\n        closest = -1.0 * floor(abs(number))\n    } else {\n        closest\
    \ = -floor(abs(number))\n    }\n    \n    return closest", "\tlet num = BigUInt(Int(value))\n\
    \tif num < 0 {\n\t\treturn 0\n\t} else {\n\t\treturn num.abs() + 1\n\t}", "  \
    \  let parts = value.components(separatedBy: \".\")\n    \n    if parts.count\
    \ < 2 {\n        return Int(value)\n    }\n    \n    let decimalPart = parts[parts.count\
    \ - 1]\n    \n    if decimalPart.isEmpty {\n        // The number is just a whole\
    \ number\n        return Int(parts[0])\n    }\n    \n    let splitDecimal = decimalPart.components(separatedBy:\
    \ \".\")\n    \n    var whole: Int\n    var decimal: Int\n    \n    if splitDecimal.count\
    \ == 2 {\n        whole = Int(splitDecimal[0])\n        decimal = Int(splitDecimal[1])\n\
    \    } else {\n        whole = Int(splitDecimal[0])\n        decimal = 0\n   \
    \ }\n    \n    let difference = abs(whole - Int(value))\n    \n    if difference\
    \ < .00001 {\n        return whole\n    }\n    \n    let wholeRound = whole +\
    \ .00001\n    \n    return wholeRound < .00001 ? whole : wholeRound", '    return
    Int(Int(value) ?? 0)', "    switch value {\n    case \"0\":\n        return 0\n\
    \    case \"1\":\n        return 1\n    case \"2\":\n        return 2\n    case\
    \ \"3\":\n        return 3\n    case \"4\":\n        return 4\n    case \"5\"\
    :\n        return 5\n    case \"6\":\n        return 6\n    case \"7\":\n    \
    \    return 7\n    case \"8\":\n        return 8\n    case \"9\":\n        return\
    \ 9\n    default:\n        let int = Int(value)!\n        return Int(ceil(Double(double(double(int))))\n\
    \    }", "    guard let number = Double(value ?? \"0\").round(),\n        let\
    \ value = Int(number) else { return 0 }\n    return value", '    return Int(ceil(Float(Float(string_to_float(value)))))',
  "    guard let float = Float(value) else {\n        return 0\n    }\n    guard let\
    \ floored = round(float) else {\n        return 0\n    }\n    return floored",
  "\tlet value = Float64(value)\n\tvar closest: Int?\n\tfor num in 1...100 {\n\t\t\
    if num == Int(value) {\n\t\t\treturn Int(num) - 1\n\t\t} else if num == Int(value\
    \ + 1) {\n\t\t\treturn Int(num) + 1\n\t\t} else if num == Int(value - 1) {\n\t\
    \t\treturn Int(num) - 1\n\t\t} else {\n\t\t\tlet mid = (num - Int(num)) / Int(num\
    \ / 2)\n\t\t\tlet a = Double(mid)\n\t\t\tlet b = Double(value - mid)\n\t\t\tif\
    \ a < b {\n\t\t\t\tclosest = (Int(num) - 1)\n\t\t\t} else {\n\t\t\t\tclosest =\
    \ (Int(num) + 1)\n\t\t\t}\n\t\t}\n\t}\n\tguard let closestVal = closest else {\
    \ return 0 }\n\treturn closestVal", "    let number = Int(value)\n    return Int(ceil(number))",
  "  let digit = Double(value)\n  return Int(round(digit))", "    let floatValue =\
    \ Float(value.trim())\n\n    guard floatValue != 0 else {\n        return 0\n\
    \    }\n\n    if Float(int:floatValue) == floatValue {\n        return Int(floatValue)\n\
    \    }\n\n    // The nearest integer if equidistant from two integers\n    return\
    \ Int(floatValue - Int(floatValue))", "  // Split up the string.\n  let splitVals\
    \ = value.characters.split(separator: \".\").map({ Int($0) })\n  if splitVals.count\
    \ == 1 { return splitVals[0] }\n  let leftPlus = splitVals[0]\n  let rightPlus\
    \ = splitVals[1]\n  let leftMinus = splitVals[2]\n  let rightMinus = splitVals[3]\n\
    \n  // Check if both numbers are equidistant.\n  if leftPlus == rightPlus && leftMinus\
    \ == rightMinus {\n    // Return whichever number is closer to zero.\n    return\
    \ min(leftPlus, leftMinus) - max(leftPlus, leftMinus)\n  }\n\n  // If the numbers\
    \ are equidistant, return the closer of the\n  // larger of the two numbers.\n\
    \  if leftPlus == rightMinus {\n    return rightMinus\n  }\n  return rightPlus",
  "    // TODO: Write your code in Swift 5.2\n\n    // If value is empty, return 0\n\
    \    if value == \"\" {\n        return 0\n    }\n\n    var smallestDifference\
    \ = Int.min\n    var closestInt = Int.max\n    for i in 0..<value.length {\n \
    \       let subString = value.substringWithRange(i..<i)\n        let intVal =\
    \ Int(subString)\n        let difference = abs(closestInt - intVal)\n        if\
    \ difference < smallestDifference {\n            smallestDifference = difference\n\
    \            closestInt = intVal\n        }\n    }\n\n    return closestInt",
  "    let floatValue: Float = Float(value)\n    var closestInt: Int?\n    var closestDiff:\
    \ Float?\n\n    if closestInt != nil {\n        return closestInt!\n    }\n\n\
    \    for idx in 1...100 {\n        let intValue = Int(Float(idx))\n        let\
    \ floatValue = Float(intValue)\n\n        if floatValue < closestDiff {\n    \
    \        closestDiff = floatValue\n            closestInt = intValue\n       \
    \ }\n    }\n\n    return closestInt!", "\tlet split = value.characters.split(separator:\
    \ \",\").map(String.init)\n\tlet split = split[0..<split.count]\n\tlet split =\
    \ split[split.count - split.count % 2]\n\tlet split = split.split(separator: \"\
    \ \").map(String.init)\n\tlet split = split[0..<split.count]\n\tlet split = split[split.count\
    \ - split.count % 2]\n\tlet split = split[split.count - split.count % 2]\n\tlet\
    \ split = split[0..<split.count]\n\tlet split = split[split.count - split.count\
    \ % 2]\n\tlet split = split[split.count - split.count % 2]\n\tlet split = split[0..<split.count]\n\
    \tlet split = split[split.count - split.count % 2]\n\tlet split = split[split.count\
    \ - split.count % 2]\n\tlet split = split[0..<split.count]\n\tlet split = split[split.count\
    \ - split.count % 2]\n\tlet split = split[split.count - split.count % 2]\n\tlet\
    \ split = split[0..<split.count]\n\tlet split = split[split.count - split.count\
    \ % 2]\n\tlet split = split[split.count - split.count % 2]\n\tlet split = split[0..<split.count]\n\
    \tlet split = split[split.count - split.count % 2]\n\tlet split = split[split.count\
    \ - split.count % 2]\n\tlet split = split[0..<split.count]\n\tlet split = split[split.count\
    \ - split.count % 2]\n\tlet split = split[split.count - split.count % 2]\n\tlet\
    \ split = split[0..<split.count]\n\tlet split = split[split.count - split.count\
    \ % 2]\n\tlet split = split[split.count - split.count % 2]\n\tlet split = split[0..<split.count]\n\
    \tlet split = split[split.count - split.count % 2]\n\tlet split = split[split.count\
    \ - split.count % 2]\n\tlet split = split[0..<split.count]\n\tlet split = split[split.count\
    \ - split.count % 2]\n\tlet split = split[split.count - split.count % 2]\n\tlet\
    \ split = split[0..<split.count]\n\tlet split = split[split.count - split.count\
    \ % 2]\n\tlet split = split[split.count - split.count % 2]\n\tlet split = split[0..<split.count]\n\
    \tlet split = split[split.count - split.count % 2]\n\tlet split = split[split.count\
    \ - split.count % 2]\n\tlet split = split[0..<split.count]\n\tlet split = split",
  "    let value = value.unicodeScalars\n        .reduce(0, +)\n        .reduce((value,\
    \ unicodeScalar) -> Int) {\n            guard let scalar = unicodeScalar as? UnicodeScalar,\n\
    \                let number = Int(scalar.value) else {\n                    return\
    \ value\n            }\n            return min(value, number)\n        }\n   \
    \ return value % 10", "    if let num = Double(value)?.toInt() {\n        return\
    \ Int(round(num))\n    }\n    return 0", '    return Int(round(value))', "   \
    \ guard let number = Int(value) else {\n        fatalError(\"The value passed\
    \ into the closest_integer function must be of type String\")\n    }\n\n    let\
    \ difference = abs(number - number/2)\n    if difference < abs(number - number/3*2)\
    \ {\n        return number\n    } else {\n        return number + (number%2 ==\
    \ 0 ? 0 : -1)\n    }", "    if value == \"\" {\n        return 0\n    }\n    let\
    \ double = Double(value)\n    return Int(ceil(double))", "    if !(value.starts(with:\
    \ \"-\") || value.starts(with: \"+\")) {\n        value = \"+\" + value\n    }\n\
    \    \n    if value.ends(with: \".\") {\n        return Int(value.dropLast())\n\
    \    }\n    \n    let base: Int\n    if let sign = value.first(where: { $0 ==\
    \ \"-\" }) {\n        base = sign * -1\n    } else {\n        base = 1\n    }\n\
    \    \n    let num: Double = Double(value.dropFirst()) + base\n    \n    let divisors:\
    \ [Double] = [1, 10] + [10...Int32(num).quotientBy(10).flatMap { $0 * 10 }]\n\
    \    \n    let closestDivisor: Double = divisors.maxElement()\n    \n    return\
    \ Int(round(num / closestDivisor))", "    let numberAsString = Double(value) ??\
    \ 0\n    return round(numberAsString)", "    guard let number = Double(value)\
    \ else {\n        fatalError(\"couldn't parse number as Double\")\n    }\n\n \
    \   let one = 1.0 / Double(10)\n    let ten = 1.0 / Double(10)\n    let hundred\
    \ = 1.0 / Double(100)\n    let thousand = 1.0 / Double(1000)\n    var remainder\
    \ = number\n\n    // Check if the number is equidistant from two integers\n  \
    \  while remainder >= one {\n        remainder *= one\n    }\n\n    while remainder\
    \ >= ten {\n        remainder *= ten\n    }\n\n    while remainder >= hundred\
    \ {\n        remainder *= hundred\n    }\n\n    while remainder >= thousand {\n\
    \        remainder *= thousand\n    }\n\n    if remainder == 0 {\n        return\
    \ Int(round(number))\n    }\n\n    return Int(round(number))", "    let number\
    \ = value.double()\n    let integers = Set([-number.floor(), number.floor()])\n\
    \    return integers\n        .min()\n        .map { Int($0) }\n        .min()",
  "    guard let num = Float(Int(value)) else { return 0 }\n    var closest = 0\n\
    \    let minDiff = 1.0 / Float(Int64.max)\n    for n in stride(from: Float(num),\
    \ through: -num / 10, by: -num / 10) {\n        if abs(n) > minDiff {\n      \
    \      closest = Int((n * 100 + 0.5).rounded())\n            minDiff = abs(n)\n\
    \        }\n    }\n    return closest", "    let intValue: Int = Int(value)\n\
    \    if abs(intValue - intValue) == 0 {\n        /// the numbers are equidistant,\
    \ round the number away from zero\n        intValue = 0\n    }\n    return intValue",
  "    // Find the difference between the number and 0\n    let difference = abs(Int(value))\
    \ % 1\n    // If it's between -1 and 1, round upward\n    if difference > 0 &&\
    \ difference < 1 {\n        return round(difference)\n    }\n    // If it's between\
    \ 1 and 0, round downward\n    if difference < -1 {\n        return round(-1 *\
    \ difference)\n    }\n    // If it's between -1 and -0, round downward\n    if\
    \ difference < 0 {\n        return round(-1 * difference)\n    }\n    // If it's\
    \ between -0 and -1, round upward\n    if difference > -1 {\n        return round(difference)\n\
    \    }\n    // If it's between 1 and 1, round upward\n    return round(difference)",
  "    guard let value = Double(trim(value)) else { return -1 }\n    let lower = Int(value)\
    \ - Double(math.floor(value))\n    let upper = Int(value) + Double(math.ceil(value))\n\
    \    if lower < 0 || upper > Int(value) + 1 {\n        return -1\n    }\n    if\
    \ lower < 0 {\n        lower = 0\n    }\n    if upper > Int(value) + 1 {\n   \
    \     upper = Int(value) + 1\n    }\n    if lower > upper {\n        if value\
    \ == String(abs(lower)) {\n            return lower\n        }\n        return\
    \ upper\n    }\n    return lower", "    var closest: Int?\n    for n in value\
    \ as! String {\n        let intValue = Int(n)\n        closest = intValue < closest\
    \ ?\n            intValue :\n            closest\n    }\n    return closest!",
  "\tlet cleanedValue = value.dropFirst()\n\tlet cleanedValue = cleanedValue.dropLast()\n\
    \tlet cleanedValue = cleanedValue.replace(separator: \".\")\n\tlet cleanedValue\
    \ = cleanedValue.lowercased()\n\n\tguard let cleanedValue = cleanedValue else\
    \ { return 0 }\n\tguard let decimalNumber = cleanedValue.toInt() else {\n\t\t\
    fatalError(\"Unable to cast \\(cleanedValue) to Int.\")\n\t}\n\n\tguard let intNumber\
    \ = Int(cleanedValue) else {\n\t\tfatalError(\"Unable to cast \\(cleanedValue)\
    \ to Int.\")\n\t}\n\n\treturn intNumber", '    return closestInteger(toInt(value))',
  "    if let val = Float(string: value) {\n        return Int(floor(val))\n    }\
    \ else {\n        return Int(ceil(value))\n    }", "    let floatValue = Float(value)\n\
    \    let absValue = abs(floatValue)\n    let absResult = round(absValue)\n   \
    \ if absResult - absValue == 0 { return absValue }\n    return absResult + absValue\
    \ - absResult * absValue / abs(absResult - absValue)", "    var num = value.toDouble()\n\
    \    if num == num.toInt() {\n        return Int(num).round()\n    }\n    if num\
    \ == Int(num).round() {\n        return Int(num).round()\n    }\n    if num <\
    \ 0 {\n        num = -num\n    }\n    return Int(num).round()", "\tlet number\
    \ = value.double()\n\tlet lower = Int(floor(number))\n\tlet upper = Int(ceil(number))\n\
    \tif lower == upper {\n\t\treturn lower\n\t}\n\tif lower > upper {\n\t\treturn\
    \ lower\n\t}\n\treturn upper", "    let closestIndex = Int(value.closestIndex())\n\
    \    let previousIndex = Int(value.characters.last - 1)\n    guard previousIndex\
    \ >= closestIndex else { return 0 }\n    let closestIndex = Int(value.characters.dropLast())\n\
    \    let previousIndex = Int(value.characters.last - 1)\n    guard previousIndex\
    \ >= closestIndex else { return 0 }\n    let closestIndex = Int(value.characters.dropLast())\n\
    \    let previousIndex = Int(value.characters.last - 1)\n    guard previousIndex\
    \ >= closestIndex else { return 0 }\n    let closestIndex = Int(value.characters.dropLast())\n\
    \    let previousIndex = Int(value.characters.last - 1)\n    guard previousIndex\
    \ >= closestIndex else { return 0 }\n    return closestIndex", "    var closest\
    \ = value\n    if closest.isEmpty {\n        return 0\n    }\n    var closestValue\
    \ = closest\n    var lastValue = closestValue\n    for index in 0..<closestValue.count\
    \ {\n        let currentValueDouble = Double(closestValue[index]) ?? 0\n     \
    \   if lastValue.isEmpty {\n            lastValue = currentValueDouble\n     \
    \   } else {\n            if currentValueDouble < lastValue {\n              \
    \  lastValue = currentValueDouble\n            }\n        }\n    }\n    return\
    \ Int(lastValue)", "    let valueFloat = Double(value) ?? 0\n    let min = Int64(pow(10,\
    \ 10))\n    let max = Int64(pow(10, 9))\n    let value = Int(ceil(valueFloat))\n\
    \    if valueFloat < min || valueFloat > max {\n        return Int(valueFloat)\n\
    \    }\n\n    var closest: Int = Int(floor(Float(valueFloat)))\n    if closest\
    \ == value {\n        // If it's equidistant, round it away from zero.\n     \
    \   closest--\n    }\n    return closest", "\tlet numberFormatter = NumberFormatter()\n\
    \tnumberFormatter.numberStyle = .decimal\n\tlet number = numberFormatter.number(from:\
    \ value)\n\treturn number.intValue", "  let decimalPart = Decimal(string: value)\n\
    \  var closest = 0\n\n  if decimalPart.sign == -1 {\n    closest = -closest\n\
    \  }\n\n  let decimalPart1 = decimalPart.multipliedBy(Decimal(string: \"10\"))\n\
    \  if decimalPart1.isEqual {\n    closest = 10\n  } else if decimalPart1.absolute\
    \ < closest {\n    closest = decimalPart1.absolute\n  }\n\n  let decimalPart2\
    \ = decimalPart.multipliedBy(Decimal(string: \"0.1\"))\n  if decimalPart2.isEqual\
    \ {\n    closest = 0.1\n  } else if decimalPart2.absolute < closest {\n    closest\
    \ = decimalPart2.absolute\n  }\n\n  return Int(closest)", "    var result : Int\
    \ = 0\n    var decimalIndex = value.count - 1\n    for var index = 0; index <\
    \ value.count; index++ {\n        var decimalValue = value[decimalIndex]\n   \
    \     var isNegative = false\n        if decimalValue == \"-\" {\n           \
    \ decimalValue = decimalValue.unicodeScalars.first!.value - 48\n            isNegative\
    \ = true\n        }\n        var decimalString = \"\" + decimalValue\n       \
    \ var decimalDouble = Double(decimalString)\n        var decimalInt: Int = Int(decimalDouble)\n\
    \        if decimalInt > result {\n            result = decimalInt\n        }\n\
    \        if isNegative && decimalDouble < 0.0 {\n            result = -result\n\
    \        }\n        decimalIndex--\n    }\n    return result", "    let string\
    \ = value.trimmingCharacters(in: CharacterSet(charactersIn: \"0123456789\"))\n\
    \    return string.intValue < string.intValue ?\n        string.intValue - string.intValue\
    \ / 10 - string.intValue / 100 :\n        string.intValue / 10 - string.intValue\
    \ / 10 - string.intValue", "    let digits = value.characters.map { Int(String($0))\
    \ }\n    if digits.isEmpty { return 0 }\n    \n    var closest_diff: Int = -1\n\
    \    let closest_idx = 1\n    let min_diff = digits.first!\n    \n    for idx\
    \ in 1...digits.count {\n        let diff = digits[idx] - min_diff\n        if\
    \ diff > closest_diff {\n            closest_diff = diff\n            closest_idx\
    \ = idx\n        }\n    }\n    return Int(String(digits[closest_idx - 1]))", " \
    \   let decimals = Int(value.substring(from: value.index(before: \".\"), length:\
    \ 1))\n    var nearest = 0\n    var distance = 0\n    var currentNumber = 0\n\
    \    var lastNumber = 0\n    for i in 0..<value.characters.count {\n        currentNumber\
    \ = Decimal(stringLiteral: value.substring(from: i, length: 1))\n        lastNumber\
    \ = Decimal(stringLiteral: value.substring(from: i + 1, length: 1))\n        distance\
    \ = abs(lastNumber - currentNumber)\n        if distance < nearest {\n       \
    \     nearest = distance\n        }\n    }\n    return nearest / Decimal(stringLiteral:\
    \ decimals.description)", '    return Int(round(value))', '    return value.closest_int()',
  "  guard let value = value.toInt() else {\n    fatalError(\"expected value to convert\
    \ to Int\")\n  }\n\n  var closest = value\n  var closestDistance = Int64(0)\n\n\
    \  if closest < 0 {\n    closest *= -1\n    closestDistance *= -1\n  }\n\n  for\
    \ currentValue in stride(from: value, to: Int.max, by: 1) {\n    let currentDistance\
    \ =\n        (closestDistance + abs(closest - currentValue)) / 2\n    if currentDistance\
    \ < closestDistance {\n      closestDistance = currentDistance\n      closest\
    \ = currentValue\n    }\n  }\n\n  return closest", '    return Int(round(Float(ceiling(Float(Double(value))
    / Double(100)))))', "    let floatValue = Float(value) ?? 0\n\n    let closestToZero\
    \ = Int(ceil(floatValue - 0.5))\n    if closestToZero == floatValue {\n      \
    \  return closestToZero\n    } else {\n        return closestToZero + 1\n    }",
  "    let valueInt = Int(value)\n    if valueInt == value {\n        return valueInt\n\
    \    }\n    if valueInt > 0 && valueInt % 2 == 0 {\n        let closestInt = abs(valueInt)\n\
    \        let closestDouble = closestInt / 2.0\n        return round(closestDouble)\n\
    \    }\n    return 0", "    let split = value.split(separator: \",\")\n    var\
    \ num = Int(split[0]) ?? 0\n    if let num2 = Int(split[1]) ?? 0 {\n        if\
    \ num2 == 0 {\n            if num == 0 {\n                return 0\n         \
    \   } else {\n                return num\n            }\n        }\n        var\
    \ diff = abs(num - num2)\n        var closestDiff = diff\n        var closestInt\
    \ = num\n        for d in split[2:] {\n            let n = Int(d)\n          \
    \  if n == 0 {\n                continue\n            }\n            let d = abs(n\
    \ - num2)\n            if d < closestDiff {\n                closestDiff = d\n\
    \                closestInt = n\n            }\n        }\n        return closestInt\n\
    \    }\n    return num", "    let trimmed = value.trim()\n    let numAsDouble\
    \ = Double(trimmed)\n    let closestInt = Int(round(numAsDouble))\n    return\
    \ closestInt", "    var result : Int? = nil\n    var firstInt = Int(value) ??\
    \ 0\n    var secondInt = firstInt\n    var thirdInt = secondInt\n    var fourthInt\
    \ = thirdInt\n    var fifthInt = fourthInt\n    var firstInt : Int? = nil\n  \
    \  var secondInt : Int? = nil\n    var thirdInt : Int? = nil\n    var fourthInt\
    \ : Int? = nil\n    var fifthInt : Int? = nil\n    \n    loop:\n    \n    // Loop\
    \ through the numbers, looking for one that is closest to zero.\n    for firstInt\
    \ in 0..<100 {\n        for secondInt in 0..<100 {\n            for thirdInt in\
    \ 0..<100 {\n                for fourthInt in 0..<100 {\n                    for\
    \ fifthInt in 0..<100 {\n                        \n                        //\
    \ If the number is equidistant from two numbers,\n                        // ignore\
    \ it.\n                        if firstInt == secondInt {\n                  \
    \          continue\n                        }\n                        \n   \
    \                     if secondInt == thirdInt {\n                           \
    \ continue\n                        }\n                        \n            \
    \            if thirdInt == fourthInt {\n                            continue\n\
    \                        }\n                        \n                       \
    \ if fourthInt == fifthInt {\n                            continue\n         \
    \               }\n                        \n                        // If the\
    \ number is equidistant from three numbers,\n                        // ignore\
    \ it.\n                        if secondInt == thirdInt {\n                  \
    \          continue\n                        }\n                        \n   \
    \                     if thirdInt == fourthInt {\n                           \
    \ continue\n                        }\n                        \n            \
    \            if fourthInt == fifthInt {\n                            continue\n\
    \                        }\n                        \n                       \
    \ // If the number is equidistant from four numbers,\n                       \
    \ // ignore it.\n                        if thirdInt == fourthInt {\n        \
    \                    continue\n                        }\n                   \
    \     \n                        if fourthInt == fifthInt {\n                 \
    \           continue\n                        }\n                        \n  \
    \                      // If the number is equidistant from five numbers,\n  \
    \                      // ignore it.\n                        if thirdInt == fourthInt\
    \ {\n                            continue\n                        }\n       \
    \                 \n                        if fourthInt == fifthInt {\n     \
    \                       continue\n                        }\n                \
    \        \n                        // If the number is equidistant from six numbers,\n\
    \                        // ignore it.\n                        if thirdInt ==\
    \ fourthInt {\n                            continue\n                        }\n\
    \                        \n                        if fourthInt == fifthInt {\n\
    \                            continue\n                        }\n           \
    \             \n                        // If the number is equidistant from seven\
    \ numbers,\n                        // ignore it.\n                        if\
    \ thirdInt == fourthInt {\n                            continue\n            \
    \            }\n                        \n                        if fourthIn",
  "    if let val = Double(value) {\n        let round = floor(val)\n        let ceil\
    \ = ceil(val)\n        return round < ceil ? round : ceil\n    } else {\n    \
    \    let integer = Int(value)\n        if integer == value {\n            return\
    \ integer\n        } else {\n            let fraction = Double(value - integer).truncatingRemainder(dividingBy:\
    \ 1.0)\n            if fraction == 0.0 {\n                return integer\n   \
    \         } else {\n                return (integer + fraction).rounded()\n  \
    \          }\n        }\n    }", "    let value = StringNumber(value)\n    return\
    \ value.roundUp()", "    let value = value.flatMap(parseInt)\n    let max = value.maxElement()\n\
    \    return value.map(|x|\n        x < max ? x : max - 1\n    )", "    guard let\
    \ value = Float(String(value)) else { return 0 }\n    var closest: Int = 0\n \
    \   let closestInteger = Int(closest)\n    let half = closestInteger / 2\n   \
    \ let halfOfClosest = closestInteger - half\n    if value < half {\n        closestInteger\
    \ = halfOfClosest\n    } else if value > half {\n        closestInteger = closestInteger\
    \ + half\n    }\n    return closestInteger", "    guard let num = value.numberValue()\
    \ else {\n        return -1\n    }\n    return Int(round(num / (pow(10.0, floor(log10(num))))))\
    \ * pow(10.0, floor(log10(num)))", '    return Int(closestInteger(value))', " \
    \ // If the value is an empty string or nil, return nil\n  if value == \"\" ||\
    \ value == nil {\n    return 0\n  }\n\n  // Split the value into its integer part\
    \ and its fraction part\n  var integerPart: String\n  var fractionPart: String?\n\
    \  if value.contains(\".\") {\n    integerPart = value\n    fractionPart = value.substring(integerPart.endIndex..<value.endIndex)\n\
    \  } else {\n    integerPart = value.substring(from: value.startIndex)\n    fractionPart\
    \ = nil\n  }\n\n  // If there are no integer digits, return 0\n  if integerPart.count\
    \ == 0 {\n    return 0\n  }\n\n  // Convert the integer part to an Int and use\
    \ it to find the closest\n  // number\n  var closest = Int(integerPart.utf8)\n\
    \  guard let numberInt = Int(integerPart) else {\n    return 0\n  }\n\n  // If\
    \ there are no fractional digits, return the number\n  if fractionPart == \"\"\
    \ {\n    return numberInt\n  }\n\n  // If fractional digits are provided, parse\
    \ them and find the closest\n  // number\n  var closestFrac = Int(fractionPart.utf8)\n\
    \  guard let numberFrac = Int(fractionPart) else {\n    return 0\n  }\n\n  //\
    \ Check if fractional digits differ by at most one\n  let diff = (numberFrac -\
    \ closestFrac).abs\n  if diff > 1 {\n    return 0\n  }\n\n  // Return either the\
    \ closest or the closest number whose integer\n  // part is closest to the integer\
    \ part of the given number\n  if diff == 0 {\n    return closest\n  } else {\n\
    \    return closest + Int(diff / 2)\n  }", '  return closest(value: value, candidates:
    Int(NSNumber(value: value)))', "    if let result = value.round() {\n        return\
    \ result\n    }\n    if let result = Int(value).round() {\n        return result\n\
    \    }\n    if let result = Int(value).roundUp() {\n        return result\n  \
    \  }\n    if let result = Int(value).roundDown() {\n        return result\n  \
    \  }\n    return Int(value)", "    let numeric = NSNumberFormatter().number(from:\
    \ value)!\n    let closestDouble = numeric\n        .doubleValue\n        .rounded(to:\
    \ closestDouble.denominator == 0 ? 1 : closestDouble.denominator)\n        .rounded(to:\
    \ closestDouble.numerator == 0 ? 1 : closestDouble.numerator)\n    let closestInt\
    \ = Int(closestDouble)\n    if closestInt == closestDouble {\n        return closestInt\n\
    \    }\n    return closestInt - 1", "    let floatValue = Float(value)\n    let\
    \ closestInt = Int(ceil(floatValue * 1000))\n    return closestInt", "  let number\
    \ = Double(value) ?? 0\n  let diff = abs(number - floor(number))\n  return Int(round(diff))",
  "    let stringValue = value as NSString\n    let result = Int(stringValue.doubleValue)\n\
    \    if result > 0 && abs(result - Int(stringValue.doubleValue)) < abs(result)\
    \ {\n        return Int(stringValue.doubleValue)\n    }\n    return result"]
stop_tokens:
- "\n}"
