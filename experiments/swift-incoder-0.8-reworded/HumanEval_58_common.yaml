name: HumanEval_58_common
language: swift
prompt: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
  \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n///\
  \ >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2:\
  \ [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2:\
  \ [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2:\
  \ [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
  assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
completions: ["    var set1 = Set<Int>(l1)\n    var set2 = Set<Int>(l2)\n    var common:\
    \ [Int] = []\n\n    for value in set1.intersection(set2) {\n        if !contains(common,\
    \ value) {\n            common.append(value)\n        }\n    }\n\n    return common",
  "    if l1 == l2 { return l1 }\n    var arr: [Int] = []\n    for e in l1 {\n   \
    \     if !contains(l2, e) {\n            append(arr, e)\n        }\n    }\n  \
    \  return arr", "    if l1.isEmpty() || l2.isEmpty() {\n        return []\n  \
    \  }\n    \n    var result: [Int] = []\n    var j = l1[0]\n    var k = l2[0]\n\
    \    \n    while j < k {\n        if l1[j] == l2[k] {\n            result.append(j)\n\
    \            j++\n            k++\n        } else if l1[j] > l2[k] {\n       \
    \     j = l1[j]\n        } else {\n            k = l2[k]\n        }\n    }\n \
    \   \n    return result", "    var l: Int = 0\n    var r: Int = 0\n    var result:\
    \ [Int] = []\n    while l < l2.count {\n        r = l\n        while r < l2.count\
    \ && l1[r] == l2[l] {\n            r += 1\n        }\n        result.append(l1[l])\n\
    \        for var i = l + 1; i <= r; i++ {\n            l1.remove(at: i)\n    \
    \    }\n        l = r + 1\n    }\n    result.append(l1[0])\n    return result",
  "    var common = [Int]()\n    var x = l1[0]\n    var y = l2[0]\n    var found =\
    \ false\n    var count = 0\n    while x != y && !found {\n        if x != y {\n\
    \            if x > y {\n                count = count + 1\n            } else\
    \ {\n                count = count - 1\n            }\n        }\n        if count\
    \ == 0 {\n            common.append(x)\n            found = true\n        }\n\
    \        x = l1[x]\n        y = l2[y]\n    }\n    return common", "    var result:\
    \ [Int] = []\n    for i in 0 ..< min(l1.count, l2.count) {\n        let a = l1[i]\n\
    \        let b = l2[i]\n        if a == b {\n            result.append(a)\n  \
    \      }\n    }\n    for i in 0 ..< min(l1.count, l2.count) {\n        if !contains(result,\
    \ l2[i]) {\n            result.append(l2[i])\n        }\n    }\n    return result",
  "    let len = min(l1.count, l2.count)\n    let result = Array(repeating: 0, count:\
    \ len)\n\n    for i in 0..<len {\n        result[i] = l1[i] < l2[i] ? l1[i] :\
    \ l2[i]\n    }\n    return result", "    // Initialize with 0s, so that we don't\
    \ need to worry about index out of bounds\n    var a = 0\n    var b = 0\n    var\
    \ i = 0\n    var j = 0\n    var n1 = l1?.count ?? 0\n    var n2 = l2?.count ??\
    \ 0\n    var result = [Int]()\n    while a < n1 && b < n2 {\n        if l1[i]\
    \ < l2[j] {\n            result.append(l1[i])\n            a++\n        } else\
    \ {\n            result.append(l2[j])\n            b++\n        }\n        i +=\
    \ 1\n        j += 1\n    }\n    while a < n1 {\n        result.append(l1[i])\n\
    \        a++\n        i += 1\n    }\n    while b < n2 {\n        result.append(l2[j])\n\
    \        b++\n        j += 1\n    }\n    return result", "    var result = [Int]()\n\
    \    for i in l1 {\n        for j in l2 {\n            if i == j {\n         \
    \       continue\n            }\n            if !result.contains(i) {\n      \
    \          result.insert(i, at: 0)\n            }\n            if !result.contains(j)\
    \ {\n                result.insert(j, at: 0)\n            }\n            if result.count\
    \ > 1 {\n                break\n            }\n        }\n    }\n    return result",
  "    var result = [Int]()\n    var index1 = -1\n    var index2 = -1\n    for x in\
    \ l1 {\n        for y in l2 {\n            if x == y {\n                if index1\
    \ == -1 || index2 != y {\n                    index1 = x\n                   \
    \ index2 = y\n                }\n            } else {\n                break\n\
    \            }\n        }\n        if index1 != -1 {\n            break\n    \
    \    }\n        result.append(x)\n    }\n    return result", "    var l3 = [Int]()\n\
    \    for i in 0..<min(l1.count, l2.count) {\n        if l1[i] == l2[i] {\n   \
    \         l3.append(l1[i])\n        }\n    }\n    l3.sort()\n    return l3", " \
    \   var result = [Int]()\n    for i in l1 {\n        if !contains(l2, i) {\n \
    \           result = append(result, i)\n        }\n    }\n    return result",
  "    var result: [Int] = []\n    let sortedL1 = l1.sorted()\n    let sortedL2 =\
    \ l2.sorted()\n    var i = 0\n    while i < sortedL1.count && i < sortedL2.count\
    \ {\n        let idx1 = sortedL1[i]\n        let idx2 = sortedL2[i]\n        if\
    \ idx1 == idx2 {\n            result.append(idx1)\n            i += 1\n      \
    \  } else if idx1 < idx2 {\n            result.append(idx1)\n            i +=\
    \ 1\n        } else {\n            result.append(idx2)\n            i += 1\n \
    \       }\n    }\n    while i < sortedL1.count {\n        result.append(sortedL1[i])\n\
    \        i += 1\n    }\n    while i < sortedL2.count {\n        result.append(sortedL2[i])\n\
    \        i += 1\n    }\n    return result", "    var res: [Int] = []\n\n    for\
    \ x in l1 {\n        for y in l2 {\n            if x == y {\n                continue\n\
    \            }\n            if !res.contains(x) {\n                res.append(x)\n\
    \            }\n            if !res.contains(y) {\n                res.append(y)\n\
    \            }\n        }\n    }\n    return res", "    var a = [Int](l1)\n  \
    \  a.sort()\n    var b = [Int](l2)\n    b.sort()\n    var c = [Int]()\n    var\
    \ i = 0\n    for k in a {\n        if b[i] != k {\n            c[c.count] = k\n\
    \        }\n        i += 1\n    }\n    return c", "    var c = [Int]()\n    var\
    \ l1I = 0\n    var l2I = 0\n    while l1I < l1.count {\n        while l2I < l2.count\
    \ && l1[l1I] == l2[l2I] {\n            c[l2I] = l1[l1I]\n            l2I++\n \
    \       }\n        if l2I < l2.count {\n            c[l2I] = l2[l2I]\n       \
    \     l2I++\n        }\n        l1I++\n    }\n    return c", "    var unique:\
    \ [Int] = l1\n    for index in l2 {\n        if !contains(unique, index) {\n \
    \           unique.append(index)\n        }\n    }\n    return unique", "    var\
    \ a = l1\n    var b = l2\n    var result: [Int] = []\n    while !a.isEmpty &&\
    \ !b.isEmpty {\n        if a[0] < b[0] {\n            result.append(a[0])\n  \
    \          a.removeAtIndex(0)\n        } else {\n            result.append(b[0])\n\
    \            b.removeAtIndex(0)\n        }\n    }\n    while !a.isEmpty {\n  \
    \      result.append(a[0])\n        a.removeAtIndex(0)\n    }\n    while !b.isEmpty\
    \ {\n        result.append(b[0])\n        b.removeAtIndex(0)\n    }\n    return\
    \ result", "    var results = [Int]()\n    for i in l1 {\n        if l2.contains(i)\
    \ {\n            results.append(i)\n        }\n    }\n    return results", "\t\
    var l: Int?\n\t\n\tvar commonCount: Int = 0\n\tvar common = [Int]()\n\tfor i :\
    \ Int in l1 {\n\t\tif commonCount == 0 {\n\t\t\tcommon.append(i)\n\t\t} else {\n\
    \t\t\tfor j : Int in l2 {\n\t\t\t\tif i == j {\n\t\t\t\t\tcommonCount += 1\n\t\
    \t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif commonCount > 1 {\n\t\t\t\t\tbreak\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif commonCount > 1 {\n\t\t\t\tbreak\n\t\t\t\
    }\n\t\t\t\n\t\t\tcommon.append(i)\n\t\t}\n\t}\n\t\n\treturn common", "    if l1\
    \ == l2 {\n        return l1\n    }\n    \n    // create hash map\n    var map\
    \ = [Int: Int]()\n    \n    for value in l1 {\n        if let count = map[value]\
    \ {\n            map[value] += 1 // increment\n        } else {\n            map[value]\
    \ = 1\n        }\n    }\n    \n    for value in l2 {\n        if let count = map[value]\
    \ {\n            map[value] += 1 // increment\n        } else {\n            map[value]\
    \ = 1\n        }\n    }\n    \n    var result = [Int]()\n    for value in map\
    \ {\n        if let count = map[value] {\n            if count == 1 {\n      \
    \          result.append(value)\n            }\n        }\n    }\n    \n    return\
    \ result", "    let resultSet = NSSet(array: l1)\n    let otherSet = NSSet(array:\
    \ l2)\n    let uniqueResults = resultSet.intersect(otherSet)\n    return uniqueResults.array",
  "    guard l1.count != l2.count else { return [] }\n\n    var result: [Int] = []\n\
    \    for i in 0..<l1.count {\n        if l1[i] == l2[i] {\n            result.append(l1[i])\n\
    \        }\n    }\n\n    return result.sorted()", "    var result = [Int]()\n\
    \    var j = 0\n    for i in 0..<min(l1.count, l2.count) {\n        if l1[i] !=\
    \ l2[j] {\n            result.append(l1[i])\n            j++\n        } else {\n\
    \            j++\n        }\n    }\n    if l1.count < l2.count {\n        result\
    \ = result[0..<l1.count]\n    }\n    return result", "    guard l1.count > 0 &&\
    \ l2.count > 0 else {\n        return []\n    }\n\n    var set1 = Set<Int>(l1)\n\
    \    var set2 = Set<Int>(l2)\n    var commonElements = Set<Int>()\n\n    commonElements.formUnion(set2)\n\
    \n    for element in set1.formUnion(set2) {\n        commonElements.formRemove(element)\n\
    \    }\n\n    return commonElements.formValues()", "\tvar l1 = l1\n\tvar l2 =\
    \ l2\n\tvar i, j, m\n\tvar n = max(l1.count, l2.count)\n\tl1 = l1[0:n]\n\tl2 =\
    \ l2[0:n]\n\tm = max(m, n)\n\tvar u = Array(count: m, repeatedValue: Int()) //\
    \ unique in l1, unique in l2\n\tvar i = l1.count\n\tvar j = l2.count\n\tvar k\
    \ = 0\n\tfor ; k < m && i < j; k++ {\n\t\tif l1[k] != l2[k] {\n\t\t\tif l1.removeAtIndex(k)\
    \ {\n\t\t\t\tl2.removeAtIndex(k)\n\t\t\t\tj--\n\t\t\t} else {\n\t\t\t\ti--\n\t\
    \t\t}\n\t\t} else {\n\t\t\tu[k] = l1[k]\n\t\t\ti += 1\n\t\t\tj += 1\n\t\t}\n\t\
    }\n\treturn u", "    var result = l1\n    for i in l2 {\n        if !contains(result,\
    \ i) {\n            result = append(result, i)\n        }\n    }\n    return result",
  "    var shared: Set<Int> = Set()\n    var arr: [Int] = []\n\n    for x in l1 {\n\
    \        shared.insert(x)\n    }\n\n    for x in l2 {\n        if shared.contains(x)\
    \ {\n            shared.insert(x)\n        } else {\n            arr.append(x)\n\
    \        }\n    }\n\n    return arr", "  var l1idx = l1Indexes(l1)\n  var l2idx\
    \ = l2Indexes(l2)\n  rebuildIndexes()\n  var l = l1idx.count\n  var r = l2idx.count\n\
    \n  var out: [Int] = []\n\n  // Search for common elements in both arrays\n  while\
    \ l > 0 || r > 0 {\n    var maxIndex: Int = l > r ? l : r\n    if maxIndex ==\
    \ 0 {\n      return out\n    }\n\n    if l1idx[maxIndex-1] == l2idx[maxIndex-1]\
    \ {\n      out.append(l1idx[maxIndex-1])\n      l -= 1\n      r -= 1\n    } else\
    \ {\n      // Increment maxIndex and search again from the current position or\n\
    \      // maxIndex for all elements.\n      var currentMaxIndex = maxIndex\n \
    \     for i in\n          0..<l1idx.count {\n        if l1idx[i] == l2idx[currentMaxIndex]\
    \ {\n          out.append(l1idx[i])\n          l -= 1\n          r -= 1\n    \
    \      currentMaxIndex -= 1\n        } else if l1idx[i] == l2idx[currentMaxIndex-1]\
    \ {\n          currentMaxIndex -= 1\n        }\n      }\n    }\n  }\n\n  return\
    \ out", "    var result: [Int] = []\n    var j = 0\n    var k = 0\n    var lastElem\
    \ = l1[0]\n    for _, b in l1[j:] {\n        while k < j {\n            k += 1\n\
    \            if l1[k] == b {\n                result.append(b)\n             \
    \   lastElem = b\n                break\n            }\n        }\n    }\n   \
    \ for _, b in l2[j:] {\n        while k < j {\n            k += 1\n          \
    \  if l2[k] == b {\n                result.append(b)\n                lastElem\
    \ = b\n                break\n            }\n        }\n    }\n    result.append(lastElem)\n\
    \    return result", "    var result: [Int] = []\n    var l1Len = l1.count\n \
    \   var l2Len = l2.count\n\n    for (i = 0; i < l1Len; i++) {\n        if l1.contains(l2[i])\
    \ {\n            result.append(l2[i])\n        }\n    }\n    for (i = 0; i < l2Len;\
    \ i++) {\n        if l2.contains(l1[i]) {\n            result.append(l1[i])\n\
    \        }\n    }\n\n    return result", "    let set1 = Set(l1)\n    let set2\
    \ = Set(l2)\n    return set1.intersection(set2).sorted().sorted(by: <)", "   \
    \ var result: [Int] = []\n    for i in l1 {\n        for j in l2 {\n         \
    \   if i == j {\n                continue\n            } else {\n            \
    \    result.append(i)\n                break\n            }\n        }\n    }\n\
    \    return result", "    var result = Set()\n    for i in l1 {\n        result.insert(i)\n\
    \    }\n    for j in l2 {\n        result.delete(j)\n    }\n    return result.sorted()",
  "    if l1.count == 0 {\n        return l2\n    }\n    if l2.count == 0 {\n    \
    \    return l1\n    }\n    // sort the lists by their first element\n    let (L1,\
    \ L2) = (l1, l2)\n    if L1[0] != L2[0] {\n        let firstValue = L1[0]\n  \
    \      let firstIdx  = l1.index(of: firstValue)\n        let secondValue = L2[0]\n\
    \        let secondIdx  = l2.index(of: secondValue)\n        // If they are equal\
    \ sort the other way.\n        if firstIdx == secondIdx {\n            L1 = L1.sorted()\n\
    \            L2 = L2.sorted()\n        }\n    }\n    // find first common element\n\
    \    var l3 = [Int]()\n    let firstElement = L1[0]\n    var i = 0\n    while\
    \ i < L1.count {\n        if L1[i] == firstElement {\n            l3.append(L1[i])\n\
    \            i += 1\n        }\n        i += 1\n    }\n    // find second common\
    \ element\n    i = 0\n    while i < L2.count {\n        if L2[i] == firstElement\
    \ {\n            l3.append(L2[i])\n            i += 1\n        }\n        i +=\
    \ 1\n    }\n    return l3", "    var commonElements = l1\n    for element in l2\
    \ {\n        if commonElements.contains(element) {\n            commonElements.remove(element)\n\
    \        }\n    }\n    return commonElements", '    return common(common(Array.toIx(l1),
    Array.toIx(l2)), Array(l1))', "    if l1 == l2 { return l1 }\n    let result =\
    \ l1\n    if l1.count != l2.count { return l1 }\n    for i in l1 {\n        guard\
    \ l2.contains(i) else { return l1 }\n    }\n    return result", "    let s1  =\
    \ Set(l1)\n    let s2  = Set(l2)\n    return Array([s1.intersection(s2)])", " \
    \   var l1: NSArray = l1\n    var l2: NSArray = l2\n\n    var res: [Int] = []\n\
    \n    for x in l1 {\n        for y in l2 {\n            if x == y {\n        \
    \        res.append(x)\n                break\n            }\n        }\n    }\n\
    \n    return res", "    var result = Set()\n    for element in l1 {\n        result.insert(element)\n\
    \    }\n    for element in l2 {\n        result.insert(element)\n    }\n    result.sort()\n\
    \    return Array(result)", "    // Check both array are of same length\n    if\
    \ l1.count != l2.count {\n        return nil\n    }\n\n    var results = [Int]()\n\
    \n    for i in 0..<l1.count {\n        if l1[i] == l2[i] {\n            results.append(l1[i])\n\
    \        }\n    }\n\n    return results", "    var result = [Int]()\n    for num1\
    \ in l1 {\n        for num2 in l2 {\n            if num1 == num2 {\n         \
    \       continue\n            }\n            if result.contains(&num1) {\n   \
    \             continue\n            }\n            if result.contains(&num2) {\n\
    \                continue\n            }\n            result.append(num1)\n  \
    \      }\n    }\n    return result", "    var results = [Int]()\n    var pointers\
    \ = [Int]()\n    var size1 = 0\n    var size2 = 0\n    while size1 < l1.count\
    \ {\n        size2++\n    }\n    while size2 < l2.count {\n        pointers[size2]\
    \ = l2\n        size2++\n    }\n    while size1 < l1.count {\n        pointers[size1]\
    \ = l1\n        size1++\n    }\n    for var i = 0; i < l1.count; i++ {\n     \
    \   var j = 0\n        while j < l2.count {\n            if l1[i] == pointers[j]\
    \ {\n                results.append(l1[i])\n            }\n            j++\n \
    \       }\n    }\n    return results", "    if l1 == l2 { return l1 }\n    var\
    \ l1 = l1\n    var l2 = l2\n    var ret = [Int](count: l1.count, {_ in 0})\n \
    \   var isInL1 = false\n    var isInL2 = false\n    for index in 0 ..< l1.count\
    \ {\n        if l1[index] != l2[index] {\n            ret[index] = l1[index]\n\
    \            if l1[index] == l2[index] {\n                isInL1 = true\n    \
    \            isInL2 = true\n            } else {\n                if !isInL1 {\
    \ isInL1 = true }\n                if !isInL2 { isInL2 = true }\n            }\n\
    \        }\n    }\n    return ret", "    var array: [Int] = []\n    for element\
    \ in l1 {\n        if l2.contains(element) {\n            array.append(element)\n\
    \        }\n    }\n    return array", "    let m = l1.count\n    let n = l2.count\n\
    \    var l = l1\n    var r = l2\n    let k = (m - n) + 1\n    while (k > 0) {\n\
    \        if l[0] == r[0] {\n            l.remove(at: 0)\n            r.remove(at:\
    \ 0)\n            k -= 1\n        } else {\n            var index = 0\n      \
    \      guard let r1 = r.index(of: l[0]) else { return [] }\n            for element\
    \ in r {\n                if l[index] == element {\n                    index\
    \ -= 1\n                    break\n                }\n            }\n        \
    \    l.remove(at: index)\n            r.remove(at: index)\n            k -= 1\n\
    \        }\n    }\n    return l", "    var result: [Int] = []\n    for a in l1\
    \ {\n        for b in l2 {\n            if a == b {\n                continue\n\
    \            }\n            for c in result {\n                if a == c {\n \
    \                   break\n                }\n                if b == c {\n  \
    \                  break\n                }\n            }\n            if a !=\
    \ b {\n                result.append(a)\n            }\n        }\n    }\n   \
    \ return result", "    if l1.count > l2.count {\n        l1, l2 = l2, l1\n   \
    \ }\n    var common = l1\n    for element in l2 {\n        if element != nil {\n\
    \            for commonIndex in 0..<common.count {\n                if common[commonIndex]\
    \ == element {\n                    break\n                } else {\n        \
    \            common.removeAtIndex(commonIndex)\n                }\n          \
    \  }\n        }\n    }\n    return common", "    guard let firstArray = l1.sorted(),\
    \ let secondArray = l2.sorted() else { return [] }\n    var result: [Int] = []\n\
    \    for x in firstArray {\n        if secondArray.contains(x) {\n           \
    \ result.append(x)\n        }\n    }\n    return result", "    let num1 = l1.count\n\
    \    let num2 = l2.count\n    var common = [Int]()\n    for i in 0..<min(num1,\
    \ num2) {\n        for j in 0..<min(num1, num2) {\n            if l1[i] == l2[j]\
    \ {\n                common.append(l1[i])\n                break\n           \
    \ }\n        }\n    }\n    return common", "    var common: [Int] = []\n    for\
    \ i in l1 {\n        if l2.contains(i) {\n            common.append(i)\n     \
    \   }\n    }\n    return common", "    guard let l1 = l1.sorted else { return\
    \ l1 }\n    guard let l2 = l2.sorted else { return l2 }\n    let common = Array(zip(l1,\
    \ l2)).filter { l1.contains($0.0)\n        && l2.contains($1.0)\n    }.map({ $0.0\
    \ }).sorted()\n    return common", "    var i = 0\n    var j = 0\n    var n =\
    \ l1.count\n    while i < n && j < n {\n        if l1[i] == l2[j] {\n        \
    \    i += 1\n            j += 1\n        } else {\n            if l1[i] < l2[j]\
    \ {\n                i += 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n    }\n    while i < n {\n        i += 1\n        j +=\
    \ 1\n    }\n    while j < n {\n        j += 1\n    }\n    return l1[i..<j]", '    return
    zip(l1, l2).filter { (_, e) in e }.map { ($0.0, $0.1) }', "    var result: [Int]\
    \ = []\n\n    for e in l1 {\n        if l2.contains(e) {\n            result.append(e)\n\
    \        }\n    }\n\n    return result", "    var result = [Int]()\n    var pos1\
    \ = 0\n    var pos2 = 0\n    var len1 = l1.count\n    var len2 = l2.count\n  \
    \  while pos1 < len1 && pos2 < len2 {\n        if l1[pos1] == l2[pos2] {\n   \
    \         result.append(l1[pos1])\n            pos1 += 1\n            pos2 +=\
    \ 1\n        }\n        else if l1[pos1] > l2[pos2] {\n            pos1 += 1\n\
    \        }\n        else if l1[pos1] < l2[pos2] {\n            pos2 += 1\n   \
    \     }\n    }\n    while pos1 < len1 {\n        result.append(l1[pos1])\n   \
    \     pos1 += 1\n    }\n    while pos2 < len2 {\n        result.append(l2[pos2])\n\
    \        pos2 += 1\n    }\n    return result", "    var result = [Int]()\n   \
    \ var found = 0\n    for x in l1 {\n        if l2.contains(x) {\n            result[found]\
    \ = x\n            found += 1\n        }\n    }\n    return result", "    var\
    \ result = [Int]()\n    for i in 0 ..< min(l1.count, l2.count) {\n        if l1[i]\
    \ == l2[i] {\n            result.append(l1[i])\n        }\n    }\n    for j in\
    \ 0 ..< min(l1.count, l2.count) {\n        if !contains(result, l1[j]) {\n   \
    \         result.append(l1[j])\n        }\n    }\n    return result", "    //\
    \ Find the smallest set\n    var smallest = l1\n    var smallerSet: Set<Int> =\
    \ Set()\n    for elem in l2 {\n        if smallest == elem {\n            continue\n\
    \        } else {\n            if !smallerSet.contains(elem) {\n             \
    \   smallerSet.insert(elem)\n            } else {\n                return []\n\
    \            }\n        }\n    }\n    if !smallerSet.contains(smallest) {\n  \
    \      smallerSet.insert(smallest)\n    }\n    return smallerSet.sorted()", " \
    \   var result = [Int]()\n    for i in l1 {\n        for j in l2 {\n         \
    \   if i == j {\n                result.append(i)\n            }\n        }\n\
    \    }\n    return result.sorted()", "    var i = 0\n    var j = 0\n    var commonCount\
    \ = 0\n    while i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n\
    \            commonCount++\n        }\n        i += 1\n        j += 1\n    }\n\
    \    return Array(l1[..<min(i, j)]).sorted() + Array(l2[..<min(i, j)])", "   \
    \ var u = [Int]()\n    for x in l1 {\n        if !contains(u, x) {\n         \
    \   u.append(x)\n        }\n    }\n    for x in l2 {\n        if !contains(u,\
    \ x) {\n            u.append(x)\n        }\n    }\n    return u", "    let m =\
    \ min(l1.count, l2.count)\n    var res: [Int] = []\n    for i in 0..<m {\n   \
    \     let x = l1[i] > l2[i] ? l1[i] : l2[i]\n        if res.contains(&x) {\n \
    \           continue\n        }\n        res.append(x)\n    }\n    return res",
  "    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < l1.count\
    \ && j < l2.count {\n        if l1[i] == l2[j] {\n            result.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   while i < l1.count {\n        result.append(l1[i])\n        i += 1\n    }\n\
    \    while j < l2.count {\n        result.append(l2[j])\n        j += 1\n    }\n\
    \    return result", "    var common = [Int]()\n    let len = min(l1.count, l2.count)\n\
    \    for i in 0..<len {\n        if l1[i] == l2[i] {\n            common.append(l1[i])\n\
    \        }\n    }\n    return common", "    let l1: CFMutableArray = CFArrayCreateMutable(nil,\
    \ CFArrayGetCount(l1), &kCFTypeArrayCallBacks)\n    let l2: CFMutableArray = CFArrayCreateMutable(nil,\
    \ CFArrayGetCount(l2), &kCFTypeArrayCallBacks)\n\n    for i in 0..<CFArrayGetCount(l1)\
    \ {\n        CFArraySetValueAtIndex(l1, i, CFNumberCreate(kCFAllocatorSystemDefault,\
    \ CFNumberType(kCFNumberIntType)))\n    }\n    for i in 0..<CFArrayGetCount(l2)\
    \ {\n        CFArraySetValueAtIndex(l2, i, CFNumberCreate(kCFAllocatorSystemDefault,\
    \ CFNumberType(kCFNumberIntType)))\n    }\n    let common: CFArray = CFArrayIntersection(l1,\
    \ l2)\n    let result: CFMutableArray = CFArrayCreateMutable(nil, CFArrayGetCount(common),\
    \ &kCFTypeArrayCallBacks)\n    CFArraySortValues(common, &kCFTypeArrayCallBacks)\n\
    \    CFArrayAppendArray(result, common)\n\n    return CFArrayGetValueAtIndex(result,\
    \ 0) as! [Int]", "    var l = []\n    for _, _ in l1l1l2(l1, l2) {\n        l.append(_)\n\
    \    }\n    l = l.sort()\n    return l", "    var result = l1\n    result.sort()\
    \ // TODO: use a better algorithm to sort arrays, e.g. mergesort\n    l2.forEach\
    \ { result.contains($0) }\n    return Array(result).sorted()", "    var sortedL1\
    \ = Array(l1)\n    var sortedL2 = Array(l2)\n    sortedL1.sort()\n    sortedL2.sort()\n\
    \    var result = [Int]()\n    for i in 0 ..< sortedL1.count {\n        if sortedL1[i]\
    \ == sortedL2[i] {\n            result.append(sortedL1[i])\n        }\n    }\n\
    \    return result", "    let sorted1 = Array(l1).sorted()\n    let sorted2 =\
    \ Array(l2).sorted()\n    var result = [Int]()\n    for i in 0 ..< sorted1.count\
    \ {\n        if sorted1[i] == sorted2[i] {\n            result.append(sorted1[i])\n\
    \        }\n    }\n    return result", "    guard l1.count != l2.count else {\
    \ return [] }\n    var result: [Int] = []\n    for i in 0 ..< l1.count {\n   \
    \     let x = l1[i]\n        let y = l2[i]\n        if x != y {\n            result.append(x)\n\
    \        }\n    }\n    return result", "    let n1 = l1.count\n    let n2 = l2.count\n\
    \    var common = [Int]()\n    for i in 0..<n1 {\n        for j in 0..<n2 {\n\
    \            if l1[i] == l2[j] {\n                common.append(l1[i])\n     \
    \           break\n            }\n        }\n    }\n    return common", "    var\
    \ index = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var commonCount\
    \ = 0\n    var result = [Int]()\n    while i < len(l1) && j < len(l2) {\n    \
    \    if l1[i] == l2[j] {\n            result.append(l1[i])\n            i += 1\n\
    \            j += 1\n            commonCount++\n        } else if l1[i] > l2[j]\
    \ {\n            k += 1\n            commonCount += 1\n        } else {\n    \
    \        k += 1\n            commonCount += 1\n        }\n        if k >= 2 {\n\
    \            break\n        }\n    }\n    while i < len(l1) {\n        result.append(l1[i])\n\
    \        i += 1\n    }\n    while j < len(l2) {\n        result.append(l2[j])\n\
    \        j += 1\n    }\n    return result", "    var uniques = [Int]()\n    var\
    \ uniquesLen = 0\n    var intersection = [Int]()\n    var intersectionLen = 0\n\
    \    for x in l1 {\n        for y in l2 {\n            if x == y {\n         \
    \       intersection[intersectionLen] = x\n                intersectionLen++\n\
    \            } else {\n                for k in uniques {\n                  \
    \  if x == k {\n                        uniques.removeAtIndex(k)\n           \
    \             break\n                    }\n                }\n              \
    \  uniques[uniquesLen] = x\n                uniquesLen++\n            }\n    \
    \    }\n    }\n    for i in 0..<uniquesLen {\n        l1[intersection[i]] = uniques[i]\n\
    \    }\n    return l1", "    var result = [Int]()\n    var i = 0\n    let n =\
    \ min(l1.count, l2.count)\n    while i < n {\n        if l1[i] == l2[i] {\n  \
    \          result.append(l1[i])\n            i += 1\n        } else if l1[i] >\
    \ l2[i] {\n            i += 1\n        } else {\n            i += 1\n        }\n\
    \    }\n    result", "    var result = l1\n    var j = 0\n    for i : Int  in\
    \ l1 {\n        while j < l2.count && l2[j] == i {\n            j++\n        }\n\
    \        if j == l2.count {\n            result.append(i)\n        }\n    }\n\
    \    return result", "    var result = [Int]()\n\n    // Check for common elements\
    \ in both arrays\n    for index in 0..<min(l1.count, l2.count) {\n        let\
    \ l1Index = index(l1, index)\n        let l2Index = index(l2, index)\n       \
    \ if l1[l1Index] == l2[l2Index] {\n            result.append(l1[l1Index])\n  \
    \      } else {\n            result.insert(l1[l1Index], at: 0)\n            result.insert(l2[l2Index],\
    \ at: 0)\n        }\n    }\n\n    // Add remaining elements to result\n    if\
    \ l1.count < l2.count {\n        for index in 1..<l2.count {\n            result.append(l2[index])\n\
    \        }\n    } else {\n        for index in 1..<l1.count {\n            result.append(l1[index])\n\
    \        }\n    }\n\n    return result", "    guard l1.count > 0 && l2.count >\
    \ 0 else {\n        return []\n    }\n    var result = [Int]()\n    var j = 0\n\
    \    for i in 0..<l1.count {\n        if l1[i] != l2[j] {\n            result.append(l1[i])\n\
    \            j += 1\n        } else {\n            result.append(l2[j])\n    \
    \    }\n    }\n    result.reverse()\n    return result", "    var result = [Int]()\n\
    \    for el1 in l1 {\n        for el2 in l2 {\n            if el1 == el2 {\n \
    \               continue\n            }\n            if contains(result, el1)\
    \ {\n                continue\n            }\n            if contains(result,\
    \ el2) {\n                continue\n            }\n            result.append(el1)\n\
    \            result.append(el2)\n        }\n    }\n    return result", "    var\
    \ result: [Int] = []\n    guard l1.count >= l2.count else { return result }\n\
    \    for i in 0..<l1.count {\n        if l1[i] == l2[i] { continue }\n       \
    \ if l1[i] > l2[i] { break }\n        insert(&result, l1[i])\n    }\n    for i\
    \ in 0..<l2.count {\n        if l2[i] > l1[i] { break }\n        insert(&result,\
    \ l2[i])\n    }\n    return result", "    if l1 == l2 { return l1 }\n    let sorted1\
    \ = l1.sorted()\n    let sorted2 = l2.sorted()\n    if sorted1.count == 0 || sorted2.count\
    \ == 0 {\n        return sorted1\n    }\n    if sorted1[0] != sorted2[0] {\n \
    \       return sorted1\n    }\n    var c = 0\n    var r = 0\n    var i = 0\n \
    \   var j = 0\n    var k = 0\n    var r1 = 0\n    var r2 = 0\n    var maxR = 0\n\
    \    var minR = 0\n    while i < sorted1.count && j < sorted2.count {\n      \
    \  if sorted1[i] == sorted2[j] {\n            c++\n            i++\n         \
    \   j++\n            continue\n        }\n        r1 = sorted1[r]\n        r2\
    \ = sorted2[r]\n        maxR = max(maxR, r1)\n        minR = min(minR, r2)\n \
    \       if r1 < r2 {\n            k = c\n            c += r1 - r2\n          \
    \  r += 1\n            sorted1[r] = r1 - k\n            sorted2[r] = k + r2\n\
    \        } else {\n            k = c\n            c += r2 - r1\n            r\
    \ += 1\n            sorted1[r] = k + r1\n            sorted2[r] = r2 - k\n   \
    \     }\n    }\n    if i < sorted1.count {\n        r1 = sorted1[r]\n        sorted1[r]\
    \ = sorted2[r]\n        sorted2[r] = r1\n    }\n    sorted1.removeDuplicates()\n\
    \    sorted2.removeDuplicates()\n    return sorted1", "    var l1 = l1\n    var\
    \ l2 = l2\n    let maxLen = min(l1.count, l2.count)\n    for i in 0..<maxLen {\n\
    \        if l1.count != l2.count {\n            break\n        }\n        if l1[i]\
    \ == l2[i] {\n            l1 = l1[i..<l1.count]\n            l2 = l2[i..<l2.count]\n\
    \            continue\n        }\n        if l1[i] > l2[i] {\n            l1 =\
    \ l1[i..<l1.count]\n            l2 = l2[i..<l2.count]\n        } else {\n    \
    \        l1 = l1[i..<l1.count]\n            l2 = l2[i..<l2.count]\n        }\n\
    \    }\n    if l1.count != l2.count {\n        return l1\n    }\n    return l2",
  "    var l1 = l1\n    var l2 = l2\n    var result = [Int]()\n    var l1Pos = 0\n\
    \    var l2Pos = 0\n    while l1.count > 0 && l2.count > 0 {\n        let l1Key\
    \ = l1[l1Pos]\n        let l2Key = l2[l2Pos]\n        if (l1Key < l2Key) {\n \
    \           result.append(l1Key)\n            l1Pos++\n        } else {\n    \
    \        result.append(l2Key)\n            l2Pos++\n        }\n    }\n    while\
    \ l1.count > 0 {\n        result.append(l1[l1Pos])\n        l1Pos++\n    }\n \
    \   while l2.count > 0 {\n        result.append(l2[l2Pos])\n        l2Pos++\n\
    \    }\n    return result", "    let set1 = Set([l1])\n    let set2 = Set([l2])\n\
    \    var common: [Int] = []\n    for i in set1 {\n        if set2.contains(i)\
    \ {\n            common.append(i)\n        }\n    }\n    return common", "   \
    \ var r: [Int] = []\n    var i = 0\n    while i < l1.count && i < l2.count {\n\
    \        if l1[i] == l2[i] {\n            r.append(l1[i])\n        } else {\n\
    \            i += 1\n        }\n    }\n    return r", "    var i1 : [Int] = l1\n\
    \    var i2 : [Int] = l2\n    guard i1.count != i2.count else { return i1 }\n\
    \    var c = 0\n    var result : [Int] = []\n    while i1.count > 0 && i2.count\
    \ > 0 {\n        guard i1.last == i2.first else { return i1 }\n        \n    \
    \    // Find the smallest element to remove from both arrays\n        if c < i1.count\
    \ {\n            i1.removeLast()\n        }\n        if c < i2.count {\n     \
    \       i2.removeFirst()\n        }\n        c++\n    }\n    for i in i1.enumerated()\
    \ {\n        result.append(i.element)\n    }\n    for i in i2.enumerated() {\n\
    \        result.append(i.element)\n    }\n    return result", "    var set1 =\
    \ Set<Int>(l1)\n    var set2 = Set<Int>(l2)\n    commonSets(&set1, &set2)\n  \
    \  return set1.sorted() + set2.sorted()", "    var result = [Int]()\n    var current\
    \ = 0\n    for element in l1 {\n        if l2.contains(element) {\n          \
    \  result.append(element)\n        } else {\n            current = element as\
    \ Int\n        }\n    }\n    return result", "    var a = l1\n    var b = l2\n\
    \    var result = [Int]()\n    var i = 0\n    var j = 0\n    var k = 0\n    while\
    \ i < a.count && j < b.count {\n        if a[i] == b[j] {\n            result.append(a[i])\n\
    \            i += 1\n            j += 1\n        }\n        if i == a.count {\n\
    \            result.append(b[j])\n            j += 1\n        }\n        if j\
    \ == b.count {\n            result.append(a[i])\n            i += 1\n        }\n\
    \    }\n    return result", "    let l1 = Array(l1)\n    let l2 = Array(l2)\n\
    \    var ret = [Int]()\n    for x in l1 {\n        for y in l2 {\n           \
    \ if x == y {\n                continue\n            }\n            ret.append(x)\n\
    \        }\n    }\n    return ret", "    var l1 = l1 as NSArray\n    var l2 =\
    \ l2 as NSArray\n    var set1 = NSMutableSet()\n    var set2 = NSMutableSet()\n\
    \    for i in 0..<l1.count {\n        set1.addObject(l1.objectAtIndex(i))\n  \
    \  }\n    for i in 0..<l2.count {\n        set2.addObject(l2.objectAtIndex(i))\n\
    \    }\n    var common = NSMutableArray()\n    for obj in set1.arrayByAddingObjectsFromArray(set2.arrayByAddingObjectsFromArray(common))\
    \ {\n        if !common.containsObject(obj) {\n            common.addObject(obj)\n\
    \        }\n    }\n    return common.arrayByAddingObjectsFromArray(NSArray())",
  "    var i = 0\n    var j = 0\n    var result = [Int]()\n    while i < l1.count\
    \ && j < l2.count {\n        if l1[i] < l2[j] {\n            result.append(l1[i])\n\
    \            i += 1\n        } else if l1[i] > l2[j] {\n            result.append(l2[j])\n\
    \            j += 1\n        } else {\n            result.append (l1[i])\n   \
    \         i += 1\n            j += 1\n        }\n    }\n    return result.appending(l2[i...]).sorted()",
  "    var common: [Int] = []\n    for x in l1 {\n        if l2Contains(common, x)\
    \ {\n            continue\n        }\n        if l2Contains(l2, x) {\n       \
    \     common.append(x)\n        } else {\n            append(common, x)\n    \
    \    }\n    }\n    return common", "    var result: [Int] = []\n    \n    // Sort\
    \ both arrays by their first elements.\n    // The first element of each array\
    \ will be used in the comparison.\n    let sortedL1 = l1.sorted { $0 < $1 }\n\
    \    let sortedL2 = l2.sorted { $0 < $1 }\n    \n    // The index of the first\
    \ element of each array will be used.\n    var i = 0\n    var j = 0\n    while\
    \ i < sortedL1.count && j < sortedL2.count {\n        // Check if the elements\
    \ are equal.\n        if sortedL1[i] == sortedL2[j] {\n            i += 1\n  \
    \          j += 1\n        } else {\n            // They are different. Add the\
    \ remaining elements.\n            if i < sortedL1.count {\n                result.insert(sortedL1[i],\
    \ at: 0)\n                i += 1\n            } else {\n                result.insert(sortedL2[j],\
    \ at: 0)\n                j += 1\n            }\n        }\n    }\n    \n    return\
    \ result", "    var i = l1\n    var j = l2\n    var k = 0\n    while i < n &&\
    \ j < n {\n        if l1[Int(i)] < l2[Int(j)] {\n            i += 1\n        }\
    \ else if l1[Int(i)] > l2[Int(j)] {\n            j -= 1\n        } else {\n  \
    \          k += 1\n        }\n    }\n    while i < n {\n        k += 1\n     \
    \   i += 1\n    }\n    while j < n {\n        k -= 1\n        j -= 1\n    }\n\
    \    return [k] + [i...[j]]", "    var result: [Int] = []\n    for i in l1 {\n\
    \        if l2.contains(i) {\n            result.append(i)\n        }\n    }\n\
    \    return result", "    var result: [Int] = []\n    var i = 0\n    while i <\
    \ l1.count && i < l2.count {\n        if l1[i] == l2[i] {\n            result.append(l1[i])\n\
    \            i += 1\n        } else {\n            if l1[i] > l2[i] {\n      \
    \          result.append(l1[i])\n                i += 1\n            } else {\n\
    \                result.append(l2[i])\n                i += 1\n            }\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    var index\
    \ = 0\n    while index < l1.count && index < l2.count {\n        if l1[index]\
    \ == l2[index] {\n            result.append(l1[index])\n            index++\n\
    \        } else {\n            if result.count > 0 {\n                if index\
    \ == l1.count {\n                    result.append(l2[index])\n              \
    \      index++\n                } else {\n                    break\n        \
    \        }\n            } else {\n                if index == l2.count {\n   \
    \                 result.append(l1[index])\n                    index++\n    \
    \            } else {\n                    break\n                }\n        \
    \    }\n        }\n    }\n    return result", "    var l = [Int]()\n    for v\
    \ in l1 {\n        if !contains(v, l) {\n            l.append(v)\n        }\n\
    \    }\n    for v in l2 {\n        if !contains(v, l) {\n            l.append(v)\n\
    \        }\n    }\n    return l", "    if l1 == l2 {\n        return l1\n    }\n\
    \    var result = l1\n    var isPresent = false\n    for i in l2 {\n        if\
    \ isPresent == false {\n            result = l1\n            isPresent = true\n\
    \        } else {\n            if i == result {\n                result = l1\n\
    \                isPresent = true\n            } else {\n                result\
    \ = result\n            }\n        }\n    }\n    if isPresent == false {\n   \
    \     result = l1\n    }\n    return result", "    var result = [Int]()\n    for\
    \ i in l1 {\n        if l2.contains(i) {\n            result.append(i)\n     \
    \   }\n    }\n    return result", "  var result: [Int] = []\n  for i in 0..<min(l1.count,\
    \ l2.count) {\n    if l1[i] == l2[i] {\n      continue\n    }\n    if l1[i] >\
    \ l2[i] {\n      result.insert(i, l1[i])\n    } else {\n      result.insert(i,\
    \ l2[i])\n    }\n  }\n  return result", "    let maxLength: Int = max(l1.count,\
    \ l2.count)\n    var result = [Int]()\n    let index = 0\n    while index < maxLength\
    \ {\n        if l1.count < l2.count {\n            let element = l1.count\n  \
    \          l1.append(element)\n        }\n        else if l2.count < l1.count\
    \ {\n            let element = l2.count\n            l2.append(element)\n    \
    \    }\n\n        if l1.count == l2.count {\n            if l1[index] == l2[index]\
    \ {\n                result.append(l1[index])\n                index++\n     \
    \       }\n            else {\n                let a = l1[index]\n           \
    \     let b = l2[index]\n                while a != b {\n                    a++\n\
    \                    b++\n                }\n                result.append(a)\n\
    \                index++\n            }\n        }\n        else {\n         \
    \   let a = l1[index]\n            let b = l2[index]\n            while a != b\
    \ {\n                a++\n                b++\n            }\n            result.append(a)\n\
    \            index++\n        }\n    }\n    return result", "    var common =\
    \ [Int]()\n    for idx in l1[0..<min(l1.count, l2.count)] {\n        if l2[idx]\
    \ == l1[idx] {\n            common.append(idx)\n        }\n    }\n    return common",
  "    var c = 0\n    var d = l1\n    var e = l2\n    while c < min(e.count, d.count)\
    \ && d < e {\n        if d[c] == e[c] {\n            c++\n        } else {\n \
    \           if d[c] > e[c] {\n                d.append(e[c])\n            } else\
    \ {\n                d.append(d[c])\n            }\n        }\n        c++\n \
    \   }\n    return d[c..<min(e.count, d.count)]", '    return commonPrepend(l1,
    l2, 0)', "    let result = [Int]()\n    let i = 0\n    let j = l1.count - l1[0]!\
    \ - 1\n\n    while (i < j) {\n        let flag = l1[i]! == l2[i]!\n\n        if\
    \ flag {\n            result.append(l1[i]!)\n        }\n\n        i += 1\n   \
    \     j += 1\n    }\n\n    return result", "    var res: [Int] = l1.prefix(min(l1.count,\
    \ l2.count)) + l2.prefix(min(l1.count, l2.count))\n    if res.count == 0 {\n \
    \       return res\n    }\n    for i in 0..<res.count {\n        if res[i] !=\
    \ l1[i] {\n            if res[i] != l2[i] {\n                return res\n    \
    \        }\n            break\n        }\n    }\n    return res", "    var result\
    \ = l1\n    var i = index(l1, l2)\n    while i != -1 {\n        result.removeLast()\n\
    \        i = index(l1, l2, &i)\n    }\n    return result", "    var result = [Int]()\n\
    \    for e in l1 {\n        if !contains(l2, e) {\n            result.append(e)\n\
    \        }\n    }\n    for e in l2 {\n        if !contains(l1, e) {\n        \
    \    result.append(e)\n        }\n    }\n    return result", "    var res = l1\n\
    \    res.reserveCapacity(l2.count)\n    guard l1.count >= l2.count else { return\
    \ res }\n    for i in 0..<l1.count {\n        guard let ji = l2.firstIndex(of:\
    \ l1[i]) else {\n            res.removeAll(keepingCapacity: true)\n          \
    \  return res\n        }\n        res.insert(l1[i], at: ji)\n        l1.remove(at:\
    \ i)\n        l2.remove(at: ji)\n    }\n    return res", "    var result = l1\n\
    \    var i = 0\n    var j = 0\n    while i < l1.count && j < l2.count {\n    \
    \    if l1[i] < l2[j] {\n            result.remove(at: i)\n        }\n       \
    \ else if l1[i] > l2[j] {\n            result.remove(at: j)\n        }\n     \
    \   i += 1\n        j += 1\n    }\n    while i < l1.count {\n        result.remove(at:\
    \ i)\n        i += 1\n    }\n    while j < l2.count {\n        result.remove(at:\
    \ j)\n        j += 1\n    }\n    return result", "    var result = [Int]()\n \
    \   var index = 0\n    while index < l1.count && index < l2.count {\n        if\
    \ l1[index] == l2[index] {\n            result.append(l1[index])\n           \
    \ index++\n        } else {\n            index++\n        }\n    }\n    if index\
    \ < l1.count {\n        result = result[0..<(index)]\n    }\n    if index < l2.count\
    \ {\n        result = result.prefix(4)\n    }\n    return result", '    return
    commonFunc(l1, l2, true)', "    var result = l1\n    for x in l2 {\n        if\
    \ !contain(result, x) {\n            result = append(result, x)\n        }\n \
    \   }\n    return result", '    return Set(l1).intersection(Set(l2)).sorted()',
  "    var commonCount = 0\n    let l1Count = l1.count\n    let l2Count = l2.count\n\
    \    for i in 0..<l1Count {\n        if l1[i] == l2[i] {\n            commonCount++\n\
    \        }\n    }\n    commonCount = l1Count - commonCount\n    var result: [Int]\
    \ = []\n    var resultCount = 0\n    for i in 0..<l2Count {\n        if commonCount\
    \ == 0 {\n            break\n        }\n        if l2[i] == commonCount {\n  \
    \          result[resultCount] = l2[i]\n            resultCount++\n        }\n\
    \        commonCount--\n    }\n    return result", "    guard l1.count == l2.count\
    \ else { return [] }\n\n    var result = [Int]()\n    for i in l1 { result.append(i)\
    \ }\n    for i in l2 { result.removeAll(where: { $0 == i }) }\n    return result",
  "    var result = Array(0..<(l1.count)).map { i in\n        l1[i] & l2[i]\n    }\n\
    \    return result", "    var l1 = l1\n    var l2 = l2\n    var common = [Int]()\n\
    \    while l1.count > 0 || l2.count > 0 {\n        if l1.count == 0 {\n      \
    \      l1.append(l2[0])\n            l2.removeAtIndex(0)\n        } else if l2.count\
    \ == 0 {\n            l1.append(l2[0])\n            l2.removeAtIndex(0)\n    \
    \    } else {\n            if l1[0] > l2[0] {\n                l2.removeAtIndex(0)\n\
    \            } else {\n                l1.removeAtIndex(0)\n            }\n  \
    \      }\n    }\n    return common", "    var l = [Int]()\n    for i in l1 {\n\
    \        if !contains(l2, i) {\n            append(l, i)\n        }\n    }\n \
    \   return l", "  var result = [Int]()\n  var i = 0\n  var j = 0\n  while (i <\
    \ l1.count && j < l2.count) {\n    if l1[i] < l2[j] {\n      i += 1\n      continue\n\
    \    }\n    if l1[i] > l2[j] {\n      j += 1\n      continue\n    }\n    result.append(l1[i])\n\
    \    i += 1\n    j += 1\n  }\n  return result", "    guard l1.count >= l2.count\
    \ else { return [l1.first!] }\n    var results = [Int]()\n    let imax = l1.count\n\
    \    let jmax = l2.count\n    for i in 0..imax {\n        let j = jmax\n     \
    \   let mmax = jmax - i\n        for j in 0..mmax {\n            if l1[i] == l2[j]\
    \ {\n                results.append(l1[i])\n                j -= 1\n         \
    \   }\n            if j == 0 {\n                break\n            }\n       \
    \ }\n    }\n    return results", "    var result: [Int] = []\n    var j = 0\n\
    \    var k = 0\n    while j < l1.count && k < l2.count {\n        if l1[j] ==\
    \ l2[k] {\n            result.append(l1[j])\n            j += 1\n            k\
    \ += 1\n        } else {\n            j += 1\n        }\n    }\n    while j <\
    \ l1.count {\n        result.append(l1[j])\n        j += 1\n    }\n    while k\
    \ < l2.count {\n        result.append(l2[k])\n        k += 1\n    }\n    return\
    \ result", '    return Array(Set(l1).intersection(Set(l2)))', "    \n    var i\
    \ = 0\n    var j = 0\n    var n = min(l1.count, l2.count)\n    var common = [Int]()\n\
    \    var hash1 = l1\n    var hash2 = l2\n    \n    for _ in 0..<n {\n        while\
    \ hash1[i] == hash2[j] {\n            i += 1\n            j += 1\n           \
    \ if i == n {\n                break\n            }\n        }\n        if i ==\
    \ hash1.count {\n            if j == hash2.count {\n                break\n  \
    \          }\n            i += 1\n        } else {\n            if j == hash2.count\
    \ {\n                j += 1\n            }\n        }\n        common.append(hash1[i])\n\
    \    }\n    return common", "    if l1.count != l2.count {\n        return nil\n\
    \    }\n\n    let mut result = Set<Int>()\n\n    for i in 0..<l1.count {\n   \
    \     if l1.contains(i) {\n            let found = l2.index(of: l1[i])\n     \
    \       if found != nil {\n                result.insert(found!)\n           \
    \ }\n        }\n    }\n    return Array(result)", "    let commonCount = Set(l1).intersection(l2).count\n\
    \    var common = [Int]()\n    for i in l1 {\n        if commonCount == 0 {\n\
    \            break\n        }\n        if l2.contains(i) {\n            common.append(i)\n\
    \            commonCount -= 1\n        }\n    }\n    return common", "    var\
    \ a = l1\n    var b = l2\n    var n = a.count\n\n    for i in 0..<n {\n      \
    \  if (a[i] != b[i]) {\n            return common(b.dropLast(), a.dropLast())\n\
    \        }\n    }\n\n    return a", "    var result = [Int]()\n    var index =\
    \ 0\n    for index in 0..<min(l1.count, l2.count) {\n        if l1[index] == l2[index]\
    \ {\n            result.append(l1[index])\n        }\n    }\n    return result",
  '  return Array(Set(l1).intersection(Set(l2)))', "    var common = l1.sort()\n \
    \   for i in 0..<common.count {\n        if common[i] == l2[i] {\n           \
    \ common.removeAtIndex(common[i])\n        }\n    }\n    return common", "   \
    \ var i1 = l1\n    var i2 = l2\n    var i3 = []\n    var done = false\n    while\
    \ !done {\n        if i1 < i2 {\n            i3 = i3 + 1\n            i1 = i1\
    \ + 1\n        } else {\n            i2 = i2 + 1\n            if i2 == i3 {\n\
    \                done = true\n            } else {\n                i1 = i1 +\
    \ 1\n            }\n        }\n    }\n    return i3", "    if l1 == l2 {\n   \
    \     return l1\n    }\n    if l1 == [] || l2 == [] {\n        return l1\n   \
    \ }\n    var set = [Int]()\n    for item in l1 {\n        if !contains(set, item)\
    \ {\n            set = append(set, item)\n        }\n    }\n    for item in l2\
    \ {\n        if !contains(set, item) {\n            set = append(set, item)\n\
    \        }\n    }\n    return set", "    var result = l1\n    for element in l2\
    \ {\n        if element == result[0] {\n            result = result[1:]\n    \
    \    } else {\n            break\n        }\n    }\n    return result", "    var\
    \ result: [Int] = []\n    for i in 0 ..< min(l1.count, l2.count) {\n        if\
    \ l1[i] == l2[i] {\n            result.append(l1[i])\n        }\n    }\n    return\
    \ result", "    let mut sortedL1 = l1.sorted()\n    let mut sortedL2 = l2.sorted()\n\
    \    while sortedL1.first() != sortedL2.first() {\n        if sortedL1.first()\
    \ == sortedL2.first() {\n            if sortedL1.last() != sortedL2.last() {\n\
    \                return sortedL1.last()\n            }\n            return sortedL1.last()\n\
    \        }\n        if sortedL1.first() > sortedL2.first() {\n            sortedL1.removeFirst()\n\
    \        } else {\n            sortedL2.removeFirst()\n        }\n    }\n    if\
    \ sortedL1.first() != sortedL2.first() {\n        return sortedL1.last()\n   \
    \ }\n    return sortedL2.last()", "    var result = [Int]()\n    for x in l1 {\n\
    \        if !contains(result, x) {\n            result = result + [x]\n      \
    \  }\n    }\n    for x in l2 {\n        if !contains(result, x) {\n          \
    \  result = result + [x]\n        }\n    }\n    return result", "    var common\
    \ = [Int](count: l1.count, repeatedValue: -1)\n    var i = 0\n    var j = 0\n\
    \    for x in l1 {\n        if common[i] == x {\n            i += 1\n        \
    \    continue\n        }\n        for y in l2 {\n            if common[j] == y\
    \ {\n                j += 1\n                continue\n            }\n       \
    \     if x < y {\n                common[j] = x\n                j += 1\n    \
    \        } else {\n                common[i] = y\n                i += 1\n   \
    \         }\n        }\n    }\n    return common", "    var result: [Int] = []\n\
    \    for i in l1 {\n        if contains(l2, i) {\n            result.append(i)\n\
    \        }\n    }\n    return result", "    var unique = Set()\n    for elem in\
    \ l1 { unique.insert(elem) }\n    for elem in l2 { unique.insert(elem) }\n   \
    \ return Array(unique)", "    var result = l1\n    for i in l2 {\n        var\
    \ index = result.index {$0 === i}\n        if index >= 0 {\n            result.removeSubrange(index,\
    \ 1)\n        } else {\n            result = append(result, i)\n        }\n  \
    \  }\n    return result", "    var a = l1\n    var b = l2\n    var result = [Int]()\n\
    \    var i = 0\n    var j = 0\n    while i < a.count && j < b.count {\n      \
    \  if a[i] == b[j] {\n            result.append(a[i])\n            i += 1\n  \
    \          j += 1\n        } else if a[i] < b[j] {\n            i += 1\n     \
    \   } else {\n            j += 1\n        }\n    }\n    return result.count >\
    \ 0 ? result : [Int]()", "    var l = [Int]()\n    for x in l1 {\n        for\
    \ y in l2 {\n            if x == y {\n                l.append(x)\n          \
    \      break\n            }\n        }\n    }\n    return l", "    var array =\
    \ [Int]()\n    var i = 0\n    for x in l1 {\n        if l2[i] < x {\n        \
    \    array = append(array, l2[i])\n        }\n        i += 1\n    }\n    for x\
    \ in l2 {\n        if array[0] != x {\n            array = append(array, x)\n\
    \        }\n    }\n    return array", "    // Special case: if one of the list\
    \ is empty, return the other\n    var commonArray = l1\n    if !l1.isEmpty {\n\
    \        commonArray = l2\n    }\n    var result = [Int]()\n\n    for i in 0 ..<\
    \ commonArray.count {\n        if commonArray[i] != 0 && commonArray[i] != l1[i]\
    \ {\n            result.append(commonArray[i])\n        }\n    }\n\n    return\
    \ result", "    // Find the shared elements\n    var set = Set()\n    var common\
    \ = [Int]()\n    for value in l1 {\n        if !set.contains(value) {\n      \
    \      set.insert(value)\n            common.append(value)\n        }\n    }\n\
    \    for value in l2 {\n        if !set.contains(value) {\n            set.insert(value)\n\
    \            common.append(value)\n        }\n    }\n\n    return common", " \
    \   guard l1.count != 0 || l2.count != 0 else {\n        return []\n    }\n  \
    \  \n    var a = [Int](count: l1.count + 1, repeatedValue: 0)\n    var b = [Int](count:\
    \ l2.count + 1, repeatedValue: 0)\n    \n    for i in 0 ..< l1.count {\n     \
    \   a[i+1] = l1[i]\n    }\n    for i in 0 ..< l2.count {\n        b[i+1] = l2[i]\n\
    \    }\n    for i in 0 ..< l1.count {\n        if a[i+1] != b[i+1] {\n       \
    \     return a[i..<l1.count]\n        }\n    }\n    \n    return b[1..<l2.count]",
  "    var commonElements: [Int] = []\n    for i in 0..<min(l1.count, l2.count) {\n\
    \        if l1[i] == l2[i] {\n            commonElements.append(l1[i])\n     \
    \   }\n    }\n    if l1.count < l2.count {\n        for i in l1..<l2.count {\n\
    \            commonElements.append(l2[i])\n        }\n    }\n    return commonElements",
  "    var result = Set()\n    for x in l1 {\n        if !l2.contains(x) {\n     \
    \       result.add(x)\n        }\n    }\n    return Array(result.sorted(by: >))",
  '    return sort(Array(Set(l1).intersection(Set(l2))))', "    var x = [Int]()\n\
    \    var y = [Int]()\n    for x in l1 {\n        if !contains(l2, x) {\n     \
    \       append(x, y)\n            append(l2, x)\n        }\n    }\n    for y in\
    \ l2 {\n        if !contains(l1, y) {\n            append(x, y)\n            append(l1,\
    \ y)\n        }\n    }\n    return unique(x)", "    if l1.count != l2.count {\n\
    \        return []\n    }\n    var result = l1\n    for i in 0..<l1.count {\n\
    \        let index1 = index(l1, i)\n        let index2 = index(l2, i)\n      \
    \  if index1 != index2 {\n            result.removeAtIndex(index1)\n         \
    \   result.removeAtIndex(index2)\n        }\n    }\n    return result", "    var\
    \ result = [Int]()\n    for num in l1 {\n        guard let foundIndex = l2.index(of:\
    \ num) else {\n            continue\n        }\n        if result.removeAll {\
    \ $0 == foundIndex }.isEmpty {\n            result.append(foundIndex)\n      \
    \  }\n    }\n    return result", "    var result = [Int]()\n    for element in\
    \ a {\n        if b.contains(element) {\n            result.append(element)\n\
    \        }\n    }\n    return result", "    var s1 = l1\n    var s2 = l2\n   \
    \ var index1 = 0\n    var index2 = 0\n    var tmp = 0\n\n    while index1 < s1.count\
    \ && index2 < s2.count {\n        if s1[index1] > s2[index2] {\n            tmp\
    \ = s1[index1]\n            s1[index1] = s2[index2]\n            s2[index2] =\
    \ tmp\n        } else {\n            tmp = s2[index2]\n            s2[index2]\
    \ = s1[index1]\n            s1[index1] = tmp\n        }\n        index1 += 1\n\
    \        index2 += 1\n    }\n\n    let sorted1 = s1\n    let sorted2 = s2\n  \
    \  let sorted1Count = sorted1.count\n    let sorted2Count = sorted2.count\n\n\
    \    var result = [Int]()\n    if sorted1Count == sorted2Count {\n        for\
    \ index1 = 0; index1 < sorted1Count; index1 += 1 {\n            result.append(sorted1[index1])\n\
    \        }\n        return result\n    }\n\n    if sorted1Count > sorted2Count\
    \ {\n        for index1 = 0; index1 < sorted1Count; index1 += 1 {\n          \
    \  result.append(sorted1[index1])\n        }\n        return result\n    }\n\n\
    \    for index1 = 0; index1 < sorted2Count; index1 += 1 {\n        result.append(sorted2[index1])\n\
    \    }\n    return result", "    let m = min(l1.count, l2.count)\n    var u =\
    \ [Int](repeating: 0, count: m)\n    var l = [Int](repeating: 0, count: m)\n \
    \   for i in 0 ..< m {\n        if l1[i] != l2[i] {\n            l[i] = l1[i]\n\
    \        } else {\n            u[i] = l1[i]\n        }\n    }\n    return u",
  "    var result = [Int]()\n    \n    for aElem in l1 {\n        for bElem in l2\
    \ {\n            if aElem == bElem {\n                result.append(aElem)\n \
    \           }\n        }\n    }\n    \n    return result", "    var result = [Int]()\n\
    \    for x in l1 {\n        if !contains(l2, x) {\n            result.append(x)\n\
    \        }\n    }\n    return result", '    return common(Array(l1), Array(l2))',
  "    var set = Set()\n    for i in l1 {\n        set.add(i)\n    }\n    for i in\
    \ l2 {\n        if set.contains(i) {\n            set.remove(i)\n        }\n \
    \   }\n    return Array(set.array())", "    var result = [Int]()\n    for i in\
    \ l1 {\n        if !l2.contains(i) {\n            result.append(i)\n        }\n\
    \    }\n    return result", "\tvar result = Array(count: l1.count, repeatedValue:\
    \ Int64(-1))\n\tcommonUnsafe(l1, l2, &result)\n\treturn result", "    var common:\
    \ [Int] = []\n    for e in l1 {\n        if let index = commonIndex(l1, e, l2)\
    \ {\n            common = common[..<index]\n            common.append(e)\n   \
    \     }\n    }\n    return common", "    var i = 0\n    var j = 0\n    var commonCount\
    \ = 0\n    var array1 = l1\n    var array2 = l2\n    while i < array1.count &&\
    \ j < array2.count {\n        if array1[i] == array2[j] {\n            commonCount++\n\
    \            i++\n            j++\n        } else if array1[i] < array2[j] {\n\
    \            i++\n        } else {\n            j++\n        }\n    }\n    return\
    \ array1.suffix(array1.count - commonCount).prefix(commonCount)", "    var result\
    \ = [Int]()\n    func helper(pos: Int, arr: [Int], arr2: [Int]) -> [Int] {\n \
    \       var l1 = arr[l1pos]\n        var l2 = arr2[l2pos]\n        if l1 == l2\
    \ {\n            if l1pos == l2pos {\n                result.append(l1)\n    \
    \        }\n            return result\n        }\n        switch l1 {\n      \
    \  case .min() where l2 == .max():\n            result.append(l1)\n          \
    \  return result\n        case .min():\n            result.append(l1)\n      \
    \      return result\n        case .max():\n            result.append(l2)\n  \
    \          return result\n        }\n        if l2 < l1 {\n            arr[l1pos]\
    \ = l1\n            l1pos++\n            arr2[l2pos] = l2\n            l2pos++\n\
    \            helper(pos, arr, arr2)\n            arr[l1pos] = l1\n           \
    \ l1pos++\n            arr2[l2pos] = l2\n            l2pos++\n        } else {\n\
    \            arr[l1pos] = l2\n            l1pos++\n            arr2[l2pos] = l1\n\
    \            l2pos++\n            helper(pos, arr, arr2)\n            arr[l1pos]\
    \ = l2\n            l1pos++\n            arr2[l2pos] = l1\n            l2pos++\n\
    \        }\n        return nil\n    }\n    l1pos = 0\n    l2pos = 0\n    for _\
    \ in 0 ..< l1.count {\n        helper(l1pos, &l1[0..<l1.count], &l2[0..<l2.count])\n\
    \    }\n    return result", "    let set = Set(l1 + l2)\n    let result = Array(set.sorted()).sorted()\n\
    \    return Array(result[0..<l1Length])", "    var result = [Int]()\n    \n  \
    \  for index in l1 {\n        if l2.contains(index) {\n            result.append(index)\n\
    \        }\n    }\n    \n    return result", "    guard l1.count > 0 && l2.count\
    \ > 0 else { return [] }\n    var result: [Int] = []\n    for i in 0..<min(l1.count,\
    \ l2.count) {\n        let a = l1[i] < l2[i] ? l1[i] : l2[i]\n        let b =\
    \ l1[i] < l2[i] ? l2[i] : l1[i]\n        if a != b {\n            result.append(a)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for number\
    \ in l1 {\n        if l2Contains(number, l2) {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var common = Array(count: min(l1.count,\
    \ l2.count), repeatedValue: 0)\n    for (_, i, _) in common.Compute {\n      \
    \  if i >= l1.count {\n            break\n        }\n        if i >= l2.count\
    \ {\n            break\n        }\n        if l1[i] == l2[i] {\n            common[i]\
    \ = 0\n        } else {\n            common[i] = 1\n        }\n    }\n    return\
    \ common", "    var result = [Int]()\n    func compare<T>(_ a1: T, _ a2: T) ->\
    \ Bool {\n        return a1 == a2 ? 0 : 1\n    }\n    for i in l1 {\n        if\
    \ l2.contains(&i) {\n            result.append(i)\n        }\n    }\n    result.sort(by:\
    \ compare)\n    return result", "    if l1 == l2 {\n        return l1\n    }\n\
    \n    let i1 = l1.startIndex\n    let i2 = l2.startIndex\n    var l = i1\n   \
    \ var r = i2\n    while l <= r {\n        if l1[l] != l2[l] {\n            r =\
    \ r - 1\n        }\n        else {\n            l++\n        }\n    }\n\n    return\
    \ l1[l - i1 + l2.startIndex..<l]", "  var result: [Int] = []\n\n  l1.sort()\n\
    \  l2.sort()\n\n  for element in l1 where l2[0] == element {\n    l2.remove(element)\n\
    \  }\n\n  for i in 0..<(l2.count - 1) {\n    if l1[l1Index] == l2[i] {\n     \
    \ result.insert(l1Index + 1, l2[i])\n      l1Index += 1\n    } else {\n      break\n\
    \    }\n  }\n\n  return result", "    var result: [Int] = []\n    for element\
    \ in l1 {\n        if l2.contains(element) {\n            result.append(element)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n\n    for item\
    \ in  l1 {\n        if !contains(result, item) {\n            result = result\
    \ + [l2]\n        }\n    }\n    for item in  l2 {\n        if !contains(result,\
    \ item) {\n            result = result + [l1]\n        }\n    }\n    return result",
  "    var common = l1\n    var i = 0\n    var j = 0\n    while i < common.Size &&\
    \ j < l2.Size {\n        if common[i] < l2[j] {\n            i += 1\n        }\
    \ else if common[i] > l2[j] {\n            j += 1\n        } else {\n        \
    \    common.removeAtIndex(i)\n            i += 1\n            j += 1\n       \
    \ }\n    }\n    while i < common.Size {\n        common.removeAtIndex(i)\n   \
    \     i += 1\n    }\n    while j < l2.Size {\n        common.removeAtIndex(j)\n\
    \        j += 1\n    }\n    return common", "    var result = [Int]()\n    for\
    \ x in l1 {\n        for y in l2 {\n            if x == y {\n                result.appendContentsOf(result)\n\
    \            } else {\n                break\n            }\n        }\n    }\n\
    \    return result", "    var result: [Int] = l1\n    for element in l2 {\n  \
    \      if !contains(result, element) {\n            result = append(result, element)\n\
    \        }\n    }\n    return result", "    if l1 == l2 {\n        return l1\n\
    \    }\n\n    var l1 = Array(l1)\n    var l2 = Array(l2)\n    var l1 = l1.sorted()\n\
    \    var l2 = l2.sorted()\n\n    var i = 0\n    var j = 0\n\n    while i < l1.count\
    \ && j < l2.count {\n        if l1[i] < l2[j] {\n            l1.removeAtIndex(i)\n\
    \            i -= 1\n        } else {\n            l2.removeAtIndex(j)\n     \
    \       j -= 1\n        }\n    }\n\n    return l1.append(l2.sorted())", "    let\
    \ sorted1 = l1.sorted()\n    let sorted2 = l2.sorted()\n    var result = [Int]()\n\
    \    var i = 0\n    var j = 0\n    while i < sorted1.count && j < sorted2.count\
    \ {\n        let c1 = sorted1[i]\n        let c2 = sorted2[j]\n        if c1 ==\
    \ c2 {\n            result.append(c1)\n            i += 1\n            j += 1\n\
    \        } else if c1 < c2 {\n            i += 1\n        } else {\n         \
    \   j += 1\n        }\n    }\n    result.removeAll(keepingCapacity: true)\n  \
    \  return result", '    return Set(l1).intersect(Set(l2))', "    var common =\
    \ [Int]()\n    var i = 0\n    let l1 = ArrayUtils.fromArray(l1)\n    let l2 =\
    \ ArrayUtils.fromArray(l2)\n    while (l1.count > 0 && l2.count > 0) {\n     \
    \   if (l1.0[Int32(i)] == l2.0[Int32(i)]) {\n            common.append(l1.0[Int32(i)])\n\
    \            l1.remove(at: 0)\n            l2.remove(at: 0)\n        } else {\n\
    \            i += 1\n        }\n    }\n    return common", "    var l = [Int]()\n\
    \    let minCount = min(l1.count, l2.count)\n    for i in 0..<minCount {\n   \
    \     if l1[i] == l2[i] {\n            l.append(l1[i])\n        }\n    }\n   \
    \ return l.sort()", "    var aSet = Set()\n    for x in l1 {\n        if aSet.contains(x)\
    \ {\n            aSet.add(x)\n        } else {\n            aSet.add(x)\n    \
    \    }\n    }\n    var bSet = Set()\n    for x in l2 {\n        if bSet.contains(x)\
    \ {\n            bSet.add(x)\n        } else {\n            bSet.add(x)\n    \
    \    }\n    }\n    var result = Set()\n    for x in aSet {\n        if !bSet.contains(x)\
    \ {\n            result.add(x)\n        }\n    }\n    return result", "    var\
    \ result = l1\n    var i = 0\n    var j = 0\n    while i < l1.count && j < l2.count\
    \ {\n        if l1[i] != l2[j] {\n            result.remove(at: i)\n        }\n\
    \        i += 1\n        j += 1\n    }\n    if j == l2.count {\n        result.remove(at:\
    \ i)\n    }\n    return result", '    return sorted(Set(l1).intersect(Set(l2)))',
  "    var result = [Int]()\n    var count1 = Int()\n    var count2 = Int()\n    for\
    \ element in l1 {\n        if l2contains element {\n            count1++ \n  \
    \      }\n    }\n    for element in l2 {\n        if l1contains element {\n  \
    \          count2++\n        }\n    }\n    if count1 > count2 {\n        result\
    \ += l1\n        result += l2\n    }\n    if count1 < count2 {\n        result\
    \ += l2\n        result += l1\n    }\n    return result", "    var a = [Int]()\n\
    \    var b = [Int]()\n\n    for x in l1 {\n        if !contains(b, x) {\n    \
    \        append(b, x)\n        }\n    }\n\n    for x in l2 {\n        if !contains(a,\
    \ x) {\n            append(a, x)\n        }\n    }\n\n    return arrayUnique(a)",
  "    let l: Int = max(l1, l2).sorted().reduce(0) { (ac, a) in\n        return ac\
    \ > a ? ac : a\n    }\n    if l == 0 {\n        return l1\n    }\n    if l ==\
    \ max(l1, l2) {\n        return l2\n    }\n    var ret: [Int] = []\n    for i\
    \ in l1 {\n        ret.insert(i, at: 0)\n    }\n    for i in l2 {\n        ret.insert(i,\
    \ at: 1)\n    }\n    return ret", "    var result: [Int] = []\n    var j = 0\n\
    \    for i in l1 {\n        if l2[j] == i {\n            result.append(i)\n  \
    \          j++\n        } else {\n            break\n        }\n    }\n    return\
    \ result", "    var result = [Int]()\n    guard l1.count != 0 && l2.count != 0\
    \ else {\n        return nil\n    }\n    while l1.count > 0 && l2.count > 0 {\n\
    \        if l1[0] < l2[0] {\n            result.insert(l1[0], at: 0)\n       \
    \     l1.remove(at: 0)\n        } else {\n            result.insert(l2[0], at:\
    \ 0)\n            l2.remove(at: 0)\n        }\n    }\n    if l1.count > 0 {\n\
    \        result.extend(l1[0...])\n    }\n    if l2.count > 0 {\n        result.extend(l2[0...])\n\
    \    }\n    return result", "    var l1c = [Int]()\n    var l2c = [Int]()\n  \
    \  for v in l1 {\n        if !contains(l2c, v) {\n            l1c.append(v)\n\
    \        }\n    }\n    for v in l2 {\n        if !contains(l1c, v) {\n       \
    \     c2c.append(v)\n        }\n    }\n    return l1c", '    return ArrayUtils.sortUnique(ArrayUtils.subtractUnique(l1,
    l2))', "    guard l1.count == l2.count else { return [] }\n    var result = [Int]()\n\
    \    var index = 0\n    while index < l1.count && index < l2.count {\n       \
    \ if l1[index] == l2[index] {\n            result.append(l1[index])\n        \
    \    index += 1\n            continue\n        }\n        if l1[index] > l2[index]\
    \ {\n            result.append(l1[index])\n            index += 1\n        } else\
    \ {\n            result.append(l2[index])\n            index += 1\n        }\n\
    \    }\n    result.removeAll({ l2.contains($0) })\n    return result", "    var\
    \ set = Set()\n    var result = Set()\n    for a in l1 {\n        if !set.contains(a)\
    \ {\n            for b in l2 {\n                if a == b {\n                \
    \    set.insert(a)\n                    break\n                }\n           \
    \ }\n        }\n    }\n    for a in l2 {\n        if !set.contains(a) {\n    \
    \        for b in l1 {\n                if a == b {\n                    set.insert(a)\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    return array.filter({ set.contains($0) })", "    var result = [Int]()\n \
    \   if l1 == l2 { return result }\n    for x in l1 {\n        for y in l2 {\n\
    \            if x == y { continue }\n            guard result.contains(&y) else\
    \ {\n                result.append(y)\n            }\n        }\n    }\n    return\
    \ result", "    var res = Set()\n    for i in l1 {\n        if !res.contains(i)\
    \ {\n            res.add(i)\n        }\n    }\n    for i in l2 {\n        if !res.contains(i)\
    \ {\n            res.add(i)\n        }\n    }\n    return Array(res)", "    var\
    \ result = [Int]()\n\n    for x in l1 {\n        for y in l2 {\n            if\
    \ x == y {\n                continue\n            }\n            if !contains(&result,\
    \ &x) {\n                result.append(x)\n            }\n        }\n    }\n \
    \   return result"]
stop_tokens:
- "\n}"
