name: HumanEval_21_rescale_to_unit
language: swift
prompt: "\n/// Given array of numbers (of at least two elements), apply a linear transform\
  \ to that array,\n/// such that the smallest number will become 0 and the largest\
  \ will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n///\
  \ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) ==\
  \ [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
  \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
  \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
  \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
completions: ["    var sum: Double = 0\n    for number in numbers {\n        sum +=\
    \ number\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number / sum)\n    }\n    return scaled", "    // Find\
    \ min and max\n    let maxValue = numbers.max()\n    let minValue = numbers.min()\n\
    \n    // Apply linear transformation to array\n    var scaledNumbers = [Double]()\n\
    \    for i in 0..<numbers.count {\n        let originalNumber = numbers[i]\n \
    \       let scaledNumber = originalNumber - minValue\n        scaledNumbers.append(scaledNumber)\n\
    \    }\n\n    // Return scaled array\n    return scaledNumbers", "    return map(numbers)\
    \ { number in\n        number / min(number, 1.0)\n    }", "    var rescaled: [Double]\
    \ = []\n    let minNum = numbers.min()\n    let maxNum = numbers.max()\n\n   \
    \ var currentMin: Double = 0.0\n    var currentMax: Double = 1.0\n\n    for i\
    \ in 0..<numbers.count {\n        currentMin = currentMin\n        currentMax\
    \ = currentMax\n\n        if numbers[i] < minNum {\n            currentMin = minNum\n\
    \        }\n\n        if numbers[i] > maxNum {\n            currentMax = maxNum\n\
    \        }\n\n        rescaled[i] = currentMin + (numbers[i] - currentMin) * (currentMax\
    \ - currentMin) / (currentMax - currentMin)\n    }\n\n    return rescaled", " \
    \   if numbers.count == 1 {\n        return numbers + [0.0]\n    }\n\n    // Calculate\
    \ the mean and standard deviation of the input numbers\n    let mean = numbers.reduce(0,\
    \ +) / Double(numbers.count)\n    let std = numbers.map{$0.powi(2) - mean.powi(2)}.max()\n\
    \    return numbers + [Double(std) * 0.5]", '    return numbers.map { Double(min(1.0,
    max(0.0, $0))) }', "    let max_value = max(numbers)\n    let min_value = min(numbers)\n\
    \    var scaled = numbers\n    for i in 0..<numbers.count {\n        scaled[i]\
    \ = scaled[i] / (max_value - min_value)\n    }\n    return scaled", "    let min\
    \ = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double] = []\n\
    \    for n in numbers {\n        scaled.append((n - min) / (max - min))\n    }\n\
    \    return scaled", "    var rescaled: [Double] = []\n    for x in numbers {\n\
    \        let scaledX = min(max(x, Double(0.0)), Double(1.0))\n        rescaled.append(scaledX)\n\
    \    }\n    return rescaled", "    var rescaledNumbers = [Double](repeating: 0.0,\
    \ count: numbers.count)\n\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n\n\
    \    for number in numbers {\n        rescaledNumbers[numbers.index(where: { $0\
    \ >= min && $0 <= max })] = number\n    }\n\n    return rescaledNumbers", "  \
    \  var scale = 1.0\n    for number in numbers {\n        scale *= (number + 1.0)\
    \ / 2.0\n    }\n    return numbers.map { $0 / scale }", "    if numbers.isEmpty()\
    \ {\n        return numbers\n    }\n    var min = Double(numbers[0])\n    var\
    \ max = Double(numbers[0])\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ < min {\n            min = numbers[i]\n        } else if numbers[i] > max {\n\
    \            max = numbers[i]\n        }\n    }\n    var scale: Double = 1.0 /\
    \ (max - min)\n    return numbers.map { $0 * scale }", "    var max: Double =\
    \ 0\n    var min: Double = Double.max\n    for number in numbers {\n        max\
    \ = max(max, number)\n        min = min(min, number)\n    }\n    let min = min(min,\
    \ 0)\n    let max = max(max, 1)\n    var scaled: [Double] = []\n    for number\
    \ in numbers {\n        scaled.append((number - min) / (max - min))\n    }\n \
    \   return scaled", "    if numbers.isEmpty { return numbers }\n    let min =\
    \ min(numbers)\n    let max = max(numbers)\n    var rescaled: [Double] = []\n\
    \    for i in numbers {\n        let ratio = (i - min) / (max - min)\n       \
    \ rescaled.append(ratio)\n    }\n    return rescaled", "    if numbers.count ==\
    \ 0 || numbers.count == 1 {\n        return numbers\n    }\n\n    var scaled =\
    \ [Double]()\n    var min: Double?\n    var max: Double?\n\n    for number in\
    \ numbers {\n        if min == nil || number < min {\n            min = number\n\
    \        }\n\n        if max == nil || number > max {\n            max = number\n\
    \        }\n    }\n\n    if max == nil {\n        return scaled\n    }\n\n   \
    \ if min == nil {\n        return scaled\n    }\n\n    var first: Double?\n  \
    \  var second: Double?\n\n    for number in numbers {\n        if first == nil\
    \ {\n            first = number\n        } else {\n            if number >= first\
    \ {\n                second--\n            } else {\n                second++\n\
    \            }\n        }\n\n        scaled.append(Double(number) - Double(first)\
    \ * Double(second) / Double(max - min))\n    }\n\n    return scaled", "    var\
    \ smallest = numbers[0]\n    var largest = numbers[0]\n    for number in numbers\
    \ {\n        largest = number if number > largest else largest\n        smallest\
    \ = number if number < smallest else smallest\n    }\n    var scalingFactor =\
    \ 1.0 / (largest - smallest)\n    var result = [Double]()\n    for number in numbers\
    \ {\n        result.append(scalingFactor * number)\n    }\n    return result",
  "    var scaledNumbers: [Double] = []\n    for num in numbers {\n        let offset\
    \ = min(abs(num), 1.0)\n        scaledNumbers.append(num - offset)\n    }\n  \
    \  return scaledNumbers", "  var min: Double?\n  var max: Double?\n  numbers.forEach\
    \ { number in\n    if min == nil || number < min {\n      min = number\n    }\n\
    \    if max == nil || number > max {\n      max = number\n    }\n  }\n\n  var\
    \ scale: Double?\n  if let min = min {\n    scale = Double(max - min) / (numbers.count\
    \ - 1)\n  }\n  if let max = max {\n    return Array(numbers.map { $0 / (scale\
    \ ?? 1.0) + min })\n  } else {\n    return numbers\n  }", "    return numbers.map({\
    \ (value) in\n        let scale = min(max(0.0, value), 1)\n        return Double(scale)\
    \ / Double(max(0.0, value))\n    })", "\tswitch numbers.count {\n\tcase 1:\n\t\
    \treturn [numbers[0]]\n\tcase 2:\n\t\tif numbers[0] < numbers[1] {\n\t\t\treturn\
    \ [numbers[0]]\n\t\t}\n\t\treturn [numbers[1]]\n\tcase 3:\n\t\tif numbers[0] <\
    \ numbers[1] && numbers[1] < numbers[2] {\n\t\t\treturn [numbers[0]]\n\t\t}\n\t\
    \treturn [numbers[1]]\n\tcase 4:\n\t\tif numbers[0] < numbers[1] && numbers[1]\
    \ < numbers[2] && numbers[2] < numbers[3] {\n\t\t\treturn [numbers[0]]\n\t\t}\n\
    \t\treturn [numbers[1]]\n\tcase 5:\n\t\tif numbers[0] < numbers[1] && numbers[1]\
    \ < numbers[2] && numbers[2] < numbers[3] && numbers[3] < numbers[4] {\n\t\t\t\
    return [numbers[0]]\n\t\t}\n\t\treturn [numbers[1]]\n\tdefault:\n\t\tpreconditionFailure(\"\
    Too many arguments\")\n\t}\n\treturn [numbers[0]]", "    var maxValue = 0.0\n\
    \    var minValue = 100000000.0\n    for value in numbers {\n        if value\
    \ > maxValue {\n            maxValue = value\n        } else if value < minValue\
    \ {\n            minValue = value\n        }\n    }\n    var rescaledNumbers =\
    \ [Double](repeating: 0, count: numbers.count)\n    for value in numbers {\n \
    \       let offset = (value - minValue) / (maxValue - minValue)\n        rescaledNumbers[numbers.index(value,\
    \ offset)]++\n    }\n    return rescaledNumbers", "    let min_val = min(numbers)\n\
    \    let max_val = max(numbers)\n    var result = [Double]()\n    for n in numbers\
    \ {\n        result.append((n - min_val) / (max_val - min_val))\n    }\n    return\
    \ result", '    return numbers.map { 1 / $0 }', "    guard numbers.count > 1 else\
    \ { return numbers }\n    var min = numbers[0]\n    var max = numbers[0]\n   \
    \ for number in numbers {\n        if number < min {\n            min = number\n\
    \        } else if number > max {\n            max = number\n        }\n    }\n\
    \    var result = [Double]()\n    for number in numbers {\n        result.append(min\
    \ + ((number - min) / (max - min) * (numbers.count - 1)))\n    }\n    return result",
  "    // sort by absolute value so we can normalize the array without having to use\
    \ abs\n    var sortedNumbers = numbers\n    sortedNumbers.sort(by: { abs($0) <\
    \ abs($1) })\n\n    // scale to the [0,1] range and round the final result\n \
    \   var rescaledNumbers = sortedNumbers.map { $0 / (1.0 + abs($0)) }\n    return\
    \ rescaledNumbers.map { round(100 * $0) }", "    if numbers.count < 2 { return\
    \ numbers }\n    var min: Double? = nil\n    var max: Double? = nil\n    for number\
    \ in numbers {\n        if number < min { min = number }\n        if number >\
    \ max { max = number }\n    }\n    guard min != nil && max != nil else { return\
    \ numbers }\n    return [min! / max!]", "    guard numbers.count > 1 else { return\
    \ numbers }\n    var minValue = numbers[0]\n    var maxValue = numbers[0]\n  \
    \  var sum = 0\n    var prevSum = 0\n    for value in numbers {\n        sum +=\
    \ value\n        if value > maxValue {\n            maxValue = value\n       \
    \ }\n        if value < minValue {\n            minValue = value\n        }\n\
    \        if sum == 0 {\n            prevSum = value\n        }\n    }\n    if\
    \ sum != 0 {\n        return Array(numbers.map { Double(prevSum / sum) * $0 +\
    \ Double($1 - prevSum) / sum })\n    }\n    return numbers", "    guard numbers.count\
    \ > 1 else { return numbers }\n\n    let maxNumber = max(numbers)\n    let minNumber\
    \ = min(numbers)\n\n    var rescaledNumbers = [Double]()\n    for i in 0..<numbers.count\
    \ {\n        let value = numbers[i]\n        rescaledNumbers.append(value / maxNumber)\n\
    \    }\n    return rescaledNumbers", "    var max_number = numbers[0]\n    var\
    \ min_number = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_number {\n            max_number = numbers[i]\n        }\n        if numbers[i]\
    \ < min_number {\n            min_number = numbers[i]\n        }\n    }\n    return\
    \ [Double(min_number) - Double(min_number) == 0 ? 0 : Double(max_number) - Double(min_number)\
    \ * Double(numbers.count - 1)]", '    return numbers.map { $0 /min(numbers.map
    { abs($0) }).min() + 0.5 }', "    var max: Double = 0\n    var min: Double = 1000000000\n\
    \    for n in numbers {\n        max = max(max, n)\n        min = min(min, n)\n\
    \    }\n    if min == 0 {\n        return [1.0]\n    }\n    var scaled = Array(repeating:\
    \ 0.0, count: numbers.count)\n    for i in 0..<numbers.count {\n        scaled[i]\
    \ = numbers[i] - min\n        scaled[i] = scaled[i] * (max - min) / (max - min)\n\
    \    }\n    return scaled", "    var smallest = Double.MaxValue\n    var largest\
    \ = Double.MinValue\n\n    for number in numbers {\n        smallest = number\
    \ < smallest ? number : smallest\n        largest = number > largest ? number\
    \ : largest\n    }\n\n    return [((largest-smallest)/(numbers.count-1)), ...numbers]",
  "    var rescaled_numbers = [Double]()\n    guard numbers.count > 1 else { return\
    \ rescaled_numbers }\n    let min_val = min(numbers)\n    let max_val = max(numbers)\n\
    \    for i in 0..<numbers.count {\n        rescaled_numbers.append(numbers[i]/max_val-min_val/min_val)\n\
    \    }\n    return rescaled_numbers", "    var min: Double = Double(numbers[0])\n\
    \    var max: Double = Double(numbers[0])\n    for value in numbers {\n      \
    \  if value < min {\n            min = value\n        } else if value > max {\n\
    \            max = value\n        }\n    }\n\n    // The difference between min\
    \ and max will give us the scale we need for the new numbers\n    let scale: Double\
    \ = max - min\n\n    // Apply scale to the numbers\n    var output: [Double] =\
    \ []\n    for value in numbers {\n        // The scaled value\n        let scaledValue\
    \ = value * scale\n        output.append(scaledValue)\n    }\n\n    return output",
  "    let range = numbers.max() - numbers.min()\n    return numbers.map { $0 / (range\
    \ + 1) }", "    let min = numbers.min()\n    let max = numbers.max()\n    let\
    \ scale: Double = max - min\n    let scaled: [Double] = numbers.map { Double($0)\
    \ / scale }\n    return scaled", "    \n    // Get minimum and maximum values\n\
    \    var minValue: Double = Double(Int.max)\n    var maxValue: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < minValue {\n            minValue\
    \ = number\n        }\n        if number > maxValue {\n            maxValue =\
    \ number\n        }\n    }\n    \n    // Get scale factor between minimum and\
    \ maximum values\n    var scaleFactor: Double = maxValue - minValue\n    \n  \
    \  // Calculate transformed values\n    var transformedValues: [Double] = []\n\
    \    for number in numbers {\n        let transformedNumber = (number - minValue)\
    \ / scaleFactor\n        transformedValues.append(transformedNumber)\n    }\n\
    \    \n    return transformedValues", "    var max = Double(0)\n    var min =\
    \ Double(0)\n    for number in numbers {\n        if number > max {\n        \
    \    max = number\n        } else if number < min {\n            min = number\n\
    \        }\n    }\n\n    let scale = max - min\n    let shift = Double(-1 * (min\
    \ / scale))\n    let results: [Double] = numbers.map { $0 - shift }\n    return\
    \ results", "    let max = numbers.max()\n    let min = numbers.min()\n\n    //\
    \ Handle edge cases\n    if min == 0.0 {\n        return [0.0]\n    } else if\
    \ max == 0.0 {\n        return ([1.0] + numbers[1..<numbers.count]).map { Double($0)\
    \ }\n    }\n\n    // Handle zero\n    if min == max {\n        if numbers[0] ==\
    \ 0.0 {\n            return []\n        } else {\n            return [0]\n   \
    \     }\n    }\n\n    // Compute delta\n    let delta = max - min\n\n    // Perform\
    \ transform\n    return (0.0 - min) / delta + numbers.map { Double($0) * Double(delta)\
    \ }", "    var smallest = min(numbers)\n    var largest = max(numbers)\n    var\
    \ size = largest-smallest\n    var factor = 1.0/size\n    var result = [Double](repeating:\
    \ 0.0, count: numbers.count)\n    for number in numbers {\n        result[numbers.index(of:\
    \ number)] = number*factor\n    }\n    return result", "    if numbers.count <\
    \ 2 {\n        return numbers\n    }\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        switch numbers[i] {\n\
    \        case smallest {\n            largest = i\n            break\n       \
    \ }\n        case largest {\n            smallest = i\n            break\n   \
    \     }\n    }\n    let scale = (largest - smallest) / (numbers.count - 1)\n \
    \   var result = [Double]()\n    for i in 1..<numbers.count {\n        result.append(scale\
    \ * (numbers[i] - smallest))\n    }\n    return result", "    // If less than\
    \ two elements, just return the array\n    if numbers.count < 2 {\n        return\
    \ numbers\n    }\n\n    // Find min and max element\n    var minimum = numbers[0]\n\
    \    var maximum = numbers[0]\n    for number in numbers {\n        if number\
    \ < minimum {\n            minimum = number\n        }\n        if number > maximum\
    \ {\n            maximum = number\n        }\n    }\n\n    // Calculate scale\
    \ and return\n    return map(numbers) { (number) -> Double in\n        let normalized\
    \ = (number - minimum) / Double(maximum - minimum)\n        return normalized.rounded(.up)\
    \ / Double(maximum - minimum)\n    }", "    if numbers.isEmpty {\n        return\
    \ []\n    }\n    var max = numbers.min()\n    var min = numbers.max()\n    if\
    \ max - min < 0.001 {\n        return [Double(max)]\n    }\n    var normalized\
    \ = [Double]()\n    for i in numbers {\n        normalized.append(Double(i)/Double(max-min))\n\
    \    }\n    return normalized", "    let minValue = numbers.min()\n    let maxValue\
    \ = numbers.max()\n    let range = (maxValue - minValue).reciprocal()\n    let\
    \ scaledNumbers = numbers.map { $0.roundTo(places: 0).multiplying(by: range) +\
    \ minValue }\n    return scaledNumbers", '    return map(numbers) { x / min(1.0+abs(x),
    1.0) }', "    var result: [Double] = []\n    numbers.forEach { number in\n   \
    \     let min = min(numbers)\n        let max = max(numbers)\n        result.append(number\
    \ - min)\n        result.append(1.0 / max(max - min, 1))\n    }\n    return result",
  "    let min = min(numbers)\n    let max = max(numbers)\n    let scale = max - min\n\
    \    let result = numbers.map { $0 - min / scale }\n    return result", "    let\
    \ minValue = numbers.min()\n    let maxValue = numbers.max()\n\n    var normalizedNumbers\
    \ = [Double]()\n    for number in numbers {\n        let normalizedNumber = number\
    \ - minValue\n        normalizedNumbers.append(normalizedNumber)\n    }\n\n  \
    \  var sum = 0\n    for number in normalizedNumbers {\n        sum += number\n\
    \    }\n\n    for number in normalizedNumbers {\n        normalizedNumbers.append(number\
    \ / sum)\n    }\n\n    return normalizedNumbers", "    guard numbers.count > 1\
    \ else { return numbers }\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    var rescaled = [Double]()\n    for n in numbers {\n        rescaled.append(n\
    \ - min / max - min / max * n)\n    }\n    return rescaled", "\tguard numbers.count\
    \ >= 2 else {\n\t\tfatalError(\"Invalid numbers\")\n\t}\n\tlet min = min(numbers)\n\
    \tlet max = max(numbers)\n\treturn map(numbers) { number in\n\t\tnumber - min\
    \ / max - min / max\n\t}", "    assert(numbers.count > 1)\n    var min = numbers[0]\n\
    \    var max = numbers[0]\n    for number in numbers {\n        if number < min\
    \ {\n            min = number\n        }\n        if number > max {\n        \
    \    max = number\n        }\n    }\n    let interval = (max - min) / 2\n    var\
    \ newNumbers = [Double]()\n    for i in 0..<numbers.count {\n        let number\
    \ = numbers[i]\n        newNumbers.append(number * interval)\n    }\n    return\
    \ newNumbers", "    var newNumbers = numbers.map { $0 }\n    newNumbers.sort()\n\
    \    guard newNumbers.count > 1 && newNumbers.last > newNumbers.first else {\n\
    \        return newNumbers\n    }\n\n    guard let newLast = Double(newNumbers.last),\
    \ let newFirst = Double(newNumbers.first) else {\n        return newNumbers\n\
    \    }\n\n    if newLast == newFirst {\n        return newNumbers\n    }\n\n \
    \   let range = newLast - newFirst\n    newNumbers.forEach() {\n        let newVal\
    \ = $0 - newFirst\n        if newVal > range {\n            newVal -= range\n\
    \        } else if newVal < -range {\n            newVal += range\n        }\n\
    \        $0 = newVal\n    }\n\n    return newNumbers", "    var largest = Double(max(numbers))\n\
    \    var smallest = Double(min(numbers))\n    var scaled: [Double] = []\n    for\
    \ i in 0..<numbers.count {\n        scaled.append(Double(numbers[i]) / largest)\n\
    \        largest = Double(max(scaled.count))\n    }\n    if smallest != 0.0 {\n\
    \        for i in 0..<numbers.count {\n            scaled.append(Double(numbers[i])\
    \ / smallest)\n            smallest = Double(min(scaled.count))\n        }\n \
    \   }\n    return scaled", "    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return numbers.map { $0 / (max - min) }", "    guard numbers.count >= 2 else\
    \ {\n        return []\n    }\n    var result = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if result-i > 0.001 {\n            result = (result + numbers[i])\
    \ / 2\n        } else {\n            result = numbers[i]\n        }\n    }\n \
    \   return result", "    var min = Double.infinity\n    var max = Double.infinity\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n\n    var normalized = [Double](repeating: 0, count: numbers.count)\n \
    \   if min < 0 {\n        for number in numbers {\n            if number > 0 {\n\
    \                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (max - min)\n            } else {\n\
    \                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (1 - min)\n            }\n      \
    \  }\n    } else {\n        for number in numbers {\n            if number < 0\
    \ {\n                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (min - max)\n            } else {\n\
    \                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (max - min)\n            }\n    \
    \    }\n    }\n    return normalized", "    var rescaled = [Double]()\n    for\
    \ i in 0..<numbers.count {\n        let scaled = min(1.0, numbers[i]/numbers[numbers.count\
    \ - 1])\n        rescaled.append(scaled)\n    }\n    return rescaled", "    assert(numbers.count\
    \ >= 2)\n    \n    let length = numbers.count\n    var smallest_number = numbers[0]\n\
    \    var largest_number = numbers[0]\n    for i in 1..length {\n        if smallest_number\
    \ > numbers[i] {\n            smallest_number = numbers[i]\n        }\n      \
    \  if largest_number < numbers[i] {\n            largest_number = numbers[i]\n\
    \        }\n    }\n    let fraction = (largest_number - smallest_number).reciprocal()\n\
    \    var result = [Double](repeating: 0.0, count: length)\n    \n    for i in\
    \ 0..<length {\n        result[i] = numbers[i] * fraction\n    }\n    \n    return\
    \ result", "    if numbers.isEmpty { return [] }\n    let min = min(numbers)\n\
    \    let max = max(numbers)\n    let step = (max - min) / Double(numbers.count)\n\
    \    var numbers2 = numbers.map { $0 - min }\n    return numbers.map { (double)\
    \ -> Double in\n        let val = double / step + min\n        let result = val\n\
    \        return result < 0 ? 0 : result > 1 ? 1 : result\n    }", "    return\
    \ map(numbers, { number in\n        if number < 0 {\n            return number\
    \ / 0\n        } else {\n            return 1.0\n        }\n    })", '    return
    numbers.map { $0 - min(numbers)/max(numbers) }', '    return map2(numbers, 0.0,
    1.0, 0.0, Double.max)', "    guard numbers.count >= 2 else {\n        return numbers\n\
    \    }\n    var result = numbers[0]\n    numbers.forEach {\n        if it > result\
    \ {\n            result = it\n        }\n    }\n    return Array(numbers.map {\
    \ result + (it - result) / numbers.count })", "    var rescaled_numbers = [Double]()\n\
    \    var i = 0\n    let min = numbers[0]\n    let max = numbers[0]\n    for number\
    \ in numbers {\n        rescaled_numbers.append(number - min)\n        rescaled_numbers.append(number\
    \ - max)\n        min = min(number, min)\n        max = max(number, max)\n   \
    \ }\n    return rescaled_numbers", "    guard numbers.count >= 2 else { return\
    \ numbers }\n    var normalized = numbers.map { $0 / 2.0 }\n    var smallest:\
    \ Double = normalized[0]\n    var largest: Double = normalized[0]\n    for n in\
    \ normalized {\n        if n < smallest { smallest = n }\n        if n > largest\
    \ { largest = n }\n    }\n    normalized = normalized.map { $0 - smallest }\n\
    \    normalized = normalized.map { $1 / largest }\n    return normalized", " \
    \   guard numbers.count >= 2 else {\n        return []\n    }\n\n    var result:\
    \ [Double] = []\n    var min: Double = Double(numbers[0])\n    var max: Double\
    \ = Double(numbers[0])\n    for n in numbers {\n        min = (n < min) ? n :\
    \ min\n        max = (n > max) ? n : max\n    }\n\n    for n in numbers {\n  \
    \      result.append(n / max - min)\n    }\n\n    return result", "    let maxValue\
    \ = numbers.max()!\n    var result = numbers.map { $0 / maxValue }\n    if result.isEmpty\
    \ {\n        return result\n    }\n\n    // If the input values are all different,\
    \ result will be\n    // [0.0, 1.0, ..., 0.0]. Replace any zeros with an appropriate\
    \ value\n    let minValue = result.min()!\n    var index = result.index(of: minValue)\n\
    \    if index == result.endIndex {\n        index = 0\n    }\n    result[index]\
    \ = maxValue\n\n    return result", "    var min = Double(numbers.first!)\n  \
    \  var max = Double(numbers.last!)\n    for number in numbers {\n        guard\
    \ number > max else { max = number; continue}\n        guard number < min else\
    \ { min = number; continue}\n    }\n    var result = [Double]()\n    for number\
    \ in numbers {\n        guard number > min && number < max else { continue }\n\
    \        result.append ((number - min) / (max - min))\n    }\n    return result",
  "    return numbers.map { number -> Double in\n        let scaled: Double = number\
    \ / numbers.min()\n        return scaled\n    }", '    return numbers.map{ x /
    min(numbers) }', "    // Calculate range from min to max\n    let range = (numbers.min()\
    \ + numbers.max()) / 2\n    // Calculate min and max values\n    let minValue\
    \ = numbers.min()\n    let maxValue = numbers.max()\n    // Map between min and\
    \ max\n    let mappedValue = (minValue + (maxValue - minValue) * range) / range\n\
    \    // Scale the mapped min and max values\n    return numbers.map { mappedValue\
    \ }", "    \n    let min = min(numbers)\n    let max = max(numbers)\n    let range\
    \ = max - min\n    let newNumbers = [Double](repeating: 0.0, count: numbers.count)\n\
    \    \n    for i in 0..<numbers.count {\n        newNumbers[i] = ((numbers[i]\
    \ - min) / range)\n    }\n    \n    return newNumbers", "    if numbers.isEmpty\
    \ { return [] }\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min = numbers[0]\n    var max = numbers[0]\n    for number in numbers {\n  \
    \      if number < min { min = number }\n        if number > max { max = number\
    \ }\n    }\n    let newMin = 0.0\n    let newMax = 1.0\n    var newNumbers: [Double]\
    \ = []\n    for number in numbers {\n        let scale = (newMax - newMin) / (number\
    \ - min)\n        newNumbers.append(scale * (number - min) + newMin)\n    }\n\
    \    return newNumbers", '    return numbers.map { $0 / min(numbers) - 1.0 }',
  "    var min = Double.leastNormalMagnitude\n    var max = Double.greatestNormalMagnitude\n\
    \    for i in numbers {\n        min = min(min, i)\n        max = max(max, i)\n\
    \    }\n    var result = numbers\n    for i in numbers {\n        result[i] =\
    \ Double((i - min) / (max - min))\n    }\n    return result", "\t\n\tvar rescaled:\
    \ [Double] = []\n\t\n\tfor i in numbers {\n\t\t\n\t\tif i >= 0 {\n\t\t\t\n\t\t\
    \trescaled.append(i)\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\trescaled.append(-i)\n\t\
    \t}\n\t}\n\t\n\treturn rescaled", "    assert(numbers.count >= 2)\n    let min\
    \ = min(numbers)\n    let max = max(numbers)\n    var scale: Double\n    if min\
    \ == max {\n        scale = 0.0\n    } else {\n        scale = 1.0 / min(max,\
    \ min)\n    }\n    let output = numbers.map { $0 * scale }\n    return output",
  "    guard numbers.count > 1 else { return [1.0] }\n\n    var min = Double(numbers[0])\n\
    \    var max = Double(numbers[0])\n\n    for i in 1..<numbers.count {\n      \
    \  min = min(numbers[i], min)\n        max = max(numbers[i], max)\n    }\n\n \
    \   var min = Double(min / 2.0)\n    var max = Double(max / 2.0)\n    var diff\
    \ = (max - min) / (numbers.count - 1)\n\n    var result = numbers.map { value\
    \ -> Double in\n        return (value - min) / diff\n    }\n\n    return result",
  "    if numbers.count < 2 {\n        return numbers\n    }\n    let min = numbers[0]\n\
    \    let max = numbers[0]\n    for number in numbers {\n        if number < min\
    \ {\n            min = number\n        }\n        if number > max {\n        \
    \    max = number\n        }\n    }\n    return numbers.map({ $0 / (max - min)\
    \ })", "    let sum = numbers.reduce(0.0, {$0 + $1})\n    var scaled: [Double]\
    \ = []\n    for i in numbers {\n        scaled.append(i/sum)\n    }\n    return\
    \ scaled", '    return numbers.map { $0 / min(numbers, {$1 > $1})}', "    guard\
    \ numbers.count > 1 else { return numbers }\n    var scaled = numbers[0]\n   \
    \ for n in numbers {\n        scaled = (n - scaled) * 0.5 + 0.5\n    }\n    return\
    \ [Double](scaled)", "    var rescaled: [Double] = []\n    var largest = numbers[0]\n\
    \    var smallest = numbers[0]\n    var length = numbers.count\n    \n    guard\
    \ length > 0 else {\n        return rescaled\n    }\n    \n    for i in 0..<length\
    \ {\n        let num = numbers[i]\n        if num > largest {\n            largest\
    \ = num\n        }\n        if num < smallest {\n            smallest = num\n\
    \        }\n    }\n    \n    if smallest > largest {\n        let diff = largest\
    \ - smallest\n        largest = smallest + diff\n        smallest = smallest -\
    \ diff\n    }\n    \n    for i in 0..<length {\n        let num = numbers[i]\n\
    \        let remaining = num - smallest\n        let scaled = (remaining / largest)\
    \ * Double(length)\n        rescaled.append(scaled)\n    }\n    \n    return rescaled",
  "    guard numbers.count > 1 else {\n        return numbers\n    }\n    let scale\
    \ = Double(numbers.min()) / Double(numbers.max())\n    return numbers.map { $0\
    \ / scale }", "    if numbers.isEmpty {\n        return numbers;\n    }\n    var\
    \ smallest: Double = numbers.first!;\n    var largest: Double = numbers.last!;\n\
    \    for i in numbers.indices {\n        smallest = min(smallest, numbers[i]);\n\
    \        largest = max(largest, numbers[i]);\n    }\n    var scaled: [Double]\
    \ = [Double]();\n    for i in 0..<numbers.count {\n        let numerator = (numbers[i]\
    \ + smallest - largest) / (smallest - largest);\n        let denominator = largest\
    \ - smallest;\n        scaled.append(numerator / denominator);\n    }\n    return\
    \ scaled;", "    guard !numbers.isEmpty else { return [1.0] }\n    return (0...<numbers.count).map\
    \ { number in numbers[number] }", "    let max_value = numbers.max()\n    return\
    \ numbers.map { number -> Double in\n        number / max_value\n    }", "   \
    \ if numbers.isEmpty {\n        return numbers\n    }\n    var rescaled = [Double](repeating:\
    \ 0.0, count: numbers.count)\n    \n    var smallest: Double?\n    for number\
    \ in numbers {\n        if smallest == nil || number < smallest {\n          \
    \  smallest = number\n        }\n    }\n    \n    for number in numbers {\n  \
    \      rescaled[numbers.index(number)] = number / smallest ?? 0.0\n    }\n   \
    \ \n    return rescaled", "    var rescaled: [Double] = []\n    for number in\
    \ numbers {\n        let minValue: Double = min(numbers)\n        let maxValue:\
    \ Double = max(numbers)\n        rescaled.append(maxValue - minValue + 0.5)\n\
    \        numbers.remove(at: 0)\n    }\n    return rescaled", "\tswitch numbers.count\
    \ {\n\tcase 1:\n\t\treturn numbers\n\tcase 2:\n\t\tif numbers[0] == numbers[1]\
    \ {\n\t\t\treturn [0.0, 1.0]\n\t\t}\n\t\tlet first = numbers[0]\n\t\tlet last\
    \  = numbers[1]\n\t\tif first == 0.0 {\n\t\t\treturn [0.0, 1.0]\n\t\t}\n\t\tif\
    \ last == 0.0 {\n\t\t\treturn [0.0, last]\n\t\t}\n\t\tif last < 1.0 {\n\t\t\t\
    return [0.0, (last + 1.0) * 0.5]\n\t\t}\n\t\treturn [0.0, (last - 1.0) * 0.5]\n\
    \tdefault:\n\t\tlet range = numbers.startIndex..<numbers.endIndex\n\t\tvar sum\
    \  = 0.0\n\t\tvar min = Double(Int.max)\n\t\tvar max = Double(Int.min)\n\t\tfor\
    \ n in range {\n\t\t\tlet n = numbers[n]\n\t\t\tif n == 0.0 {\n\t\t\t\tbreak\n\
    \t\t\t}\n\t\t\tsum += n\n\t\t\tif n < min {\n\t\t\t\tmin = n\n\t\t\t}\n\t\t\t\
    if n > max {\n\t\t\t\tmax = n\n\t\t\t}\n\t\t}\n\t\tif sum == 0.0 {\n\t\t\treturn\
    \ [0.0, 1.0]\n\t\t}\n\t\tlet denom = max - min\n\t\tlet ratio = 1.0 / ((1.0 /\
    \ (denom - 1.0)) * sum)\n\t\treturn numbers.map { n in n * ratio }\n\t}", '    return
    numbers.map { min(0, $0) / (max($0, 0.0) + 0.0) }', "    var smallest = Double(numbers[0])\n\
    \    var largest = Double(numbers[0])\n    for i in numbers.indices {\n      \
    \  if i < numbers.count - 1 {\n            if numbers[i] > largest {\n       \
    \         largest = numbers[i]\n            }\n            if numbers[i] < smallest\
    \ {\n                smallest = numbers[i]\n            }\n        } else {\n\
    \            if numbers[i] > largest {\n                largest = numbers[i]\n\
    \            }\n        }\n    }\n    var output = Array(repeating: 0.0, count:\
    \ numbers.count)\n    for i in 0..<numbers.count {\n        if numbers[i] < smallest\
    \ {\n            output[i] = Double(numbers[i])\n        } else {\n          \
    \  output[i] = Double(numbers[i]) / largest\n        }\n    }\n    return output",
  "    if numbers.isEmpty {\n        return numbers\n    }\n    let minNumber = numbers.min()\n\
    \    let maxNumber = numbers.max()\n    let diff = (maxNumber - minNumber)\n \
    \   let range = (maxNumber + minNumber) / 2\n    return [minNumber - range * diff]",
  "    var smallest = Double(Int.max)\n    var largest = Double(0)\n    for n in numbers\
    \ {\n        if n < smallest {\n            smallest = 0\n        } else {\n \
    \           if n > largest {\n                largest = 1\n            }\n   \
    \     }\n    }\n\n    var scaled: [Double] = []\n    for n in numbers {\n    \
    \    let newN = n * (largest - smallest) + smallest\n        scaled.append(newN)\n\
    \    }\n\n    return scaled", '    return numbers.map { $0 / min(max(0.0, $0),
    1.0) }', "    var scaled: [Double] = []\n    for number in numbers {\n       \
    \ scaled.append(number/numbers.min(by:))\n    }\n    return scaled", "    assert(numbers.count\
    \ > 1)\n\n    var sum: Double = 0\n    for number in numbers {\n        sum +=\
    \ number\n    }\n\n    let magnitude = numbers.reduce(0) { $0 + $1 * ($0 + $1)\
    \ }\n    switch magnitude {\n    case .zero:\n        return numbers\n    case\
    \ .infinity:\n        return [0.0]\n    case .negativeInfinity:\n        return\
    \ [-1.0]\n    case .one:\n        return [0.0]\n    case .two:\n        return\
    \ [0.5, 1.0]\n    case .three:\n        return [0.25, 0.5, 0.75, 1.0]\n    case\
    \ .four:\n        return [0.25, 0.5, 0.75, 1.0, 2.0]\n    case .five:\n      \
    \  return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0]\n    case .six:\n        return\
    \ [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0, 5.0, 6.0, 7.0]\n    case .seven:\n   \
    \     return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0,\
    \ 11.0]\n    case .eight:\n        return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0,\
    \ 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0]\n    case .nine:\n        return\
    \ [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0,\
    \ 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0,\
    \ 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0,\
    \ 39.0, 40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0,\
    \ 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0,\
    \ 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0,\
    \ 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0,\
    \ 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100]:\n        return\
    \ [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0,\
    \ 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0,\
    \ 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0,\
    \ 39.0, ", "    let min = numbers.min()\n    let max = numbers.max()\n    return\
    \ numbers.map{(_ - min) / (max - min)} + [min]", "    var result = [Double]()\n\
    \    var min = numbers[0]\n    var max = numbers[0]\n    for number in numbers\
    \ {\n        min = min(number, min)\n        max = max(number, max)\n    }\n \
    \   for number in numbers {\n        result.append(0.5 * (number - min) / (max\
    \ - min))\n    }\n    return result", "    var scaledNumbers: [Double] = []\n\
    \    let max: Double = max(numbers)\n    let min: Double = min(numbers)\n    for\
    \ i in 0..<numbers.count {\n        let scaled = (numbers[i] - min) / (max - min)\n\
    \        scaledNumbers.append(scaled)\n    }\n    return scaledNumbers", "   \
    \ var smallest = numbers[0]\n    var largest = numbers[0]\n    for number in numbers\
    \ {\n        if number < smallest {\n            smallest = number\n        }\n\
    \        if number > largest {\n            largest = number\n        }\n    }\n\
    \    var result: [Double] = []\n    for i in 0 ..< numbers.count {\n        result.append(numbers[i]\
    \ / largest)\n    }\n    return result", "    let total: Double = numbers.reduce(0,\
    \ +)\n    return numbers.map { Double(it) / total }", "    precondition(numbers.count\
    \ >= 2, \"Needs at least 2 numbers\")\n\n    var largestNumber = Double(1.0)\n\
    \    var smallestNumber = Double(1.0)\n    for number in numbers {\n        largestNumber\
    \ = max(largestNumber, number)\n        smallestNumber = min(smallestNumber, number)\n\
    \    }\n    var largest = largestNumber\n    var smallest = smallestNumber\n\n\
    \    for number in numbers {\n        largest = largest * (Double(number) - Double(smallest))\n\
    \        smallest = smallest * (Double(number) - Double(smallest))\n    }\n  \
    \  return [Double(largest), Double(1.0)]", "    return numbers.map { number in\n\
    \        if number < .leastNonzeroMagnitude {\n            return number - .leastNonzeroMagnitude\n\
    \        } else {\n            return number + .leastNonzeroMagnitude\n      \
    \  }\n    }", "    var result = [Double]()\n    var smallest = Double(Int.max)\n\
    \    var largest = Double(0)\n    for number in numbers {\n        smallest =\
    \ min(number, smallest)\n        largest = max(number, largest)\n    }\n    for\
    \ number in numbers {\n        let offset = (number - smallest) / (largest - smallest)\n\
    \        result.append(offset * (largest-smallest) + smallest)\n    }\n    return\
    \ result", '    return numbers.map{ $0 / min(1.0, $1) }', "    var max = numbers[0]\n\
    \    for number in numbers {\n        if number > max {\n            max = number\n\
    \        }\n    }\n\n    var min = numbers[0]\n    for number in numbers {\n \
    \       if number < min {\n            min = number\n        }\n    }\n\n    var\
    \ delta = (max - min) * 0.5\n    var newNumbers = [Double]()\n    for number in\
    \ numbers {\n        let rescaled = number - min\n        newNumbers.append(rescaled\
    \ / delta)\n    }\n    return newNumbers", "    let minNumber = min(numbers)\n\
    \    let maxNumber = max(numbers)\n    var rescaledNumbers = [Double]()\n    for\
    \ number in numbers {\n        let rescaledNumber = (number - minNumber) / (maxNumber\
    \ - minNumber)\n        rescaledNumbers.append(rescaledNumber)\n    }\n    return\
    \ rescaledNumbers", "    guard numbers.count >= 2 else {\n        throw Abort(code:\
    \ .invalidArgument)\n    }\n    var min = numbers[0]\n    var max = numbers[0]\n\
    \    for n in numbers {\n        if n < min {\n            min = n\n        }\n\
    \        if n > max {\n            max = n\n        }\n    }\n    let scaleFactor\
    \ = 1.0 / Double(max - min)\n    return [min].map { $0 * scaleFactor }", "   \
    \ guard numbers.count >= 2 else { return numbers}\n    var sum = numbers.reduce(0,\
    \ combine: +)\n    var scaled = [Double]()\n    for i in 0..<numbers.count {\n\
    \        let normalized = numbers[i] / sum\n        scaled.append(normalized)\n\
    \        sum += normalized\n    }\n    return scaled", '    return numbers.map
    { $0 < $1 ? $0 : $1 / $0 }', "    let min = min(numbers)\n    let max = max(numbers)\n\
    \    var numbers = numbers.map { number in\n        let multiplier = (number -\
    \ min) / (max - min)\n        return multiplier * (max - min) + min\n    }\n \
    \   return numbers", "    // TODO: Swift 2.0\n    let result = numbers[0]\n  \
    \  let min = numbers[0]\n    let max = numbers[0]\n\n    for n in numbers {\n\
    \        if (n > max) {\n            max = n\n        } else if (n < min) {\n\
    \            min = n\n        }\n    }\n\n    let diff = (max - min) / 2.0\n\n\
    \    for n in numbers {\n        if (n > max) {\n            max = n + diff\n\
    \        } else if (n < min) {\n            min = n - diff\n        }\n    }\n\
    \n    return [min..<max]", "    if numbers.count < 2 {\n        return numbers\n\
    \    }\n    var max: Double = 0\n    var min: Double = 0\n    var sum: Double\
    \ = 0\n    for number in numbers {\n        if number > max {\n            max\
    \ = number\n        }\n        if number < min {\n            min = number\n \
    \       }\n        sum += number\n    }\n\n    return Array(\n        zip(\n \
    \           (0...numbers.count).map { (number - min) / Double(max - min) },\n\
    \            numbers.map { number - sum }\n        )\n    )", "    var scaledNumbers\
    \ = [Double](repeating: 0.0, count: numbers.count)\n    let minimum = numbers.min()\n\
    \    let maximum = numbers.max()\n    scaledNumbers[0] = minimum\n    scaledNumbers.enumerate().forEach\
    \ { (index, value) in\n        if value < minimum {\n            scaledNumbers[index]\
    \ = minimum\n        }\n        if value > maximum {\n            scaledNumbers[index]\
    \ = maximum\n        }\n    }\n    return scaledNumbers", "    guard numbers.count\
    \ > 1 else { return numbers }\n\n    var min: Double? = nil\n    var max: Double?\
    \ = nil\n    for i in 0..<numbers.count {\n        guard let min = min(numbers[i..<numbers.count])\
    \ else {\n            return numbers\n        }\n        guard let max = max(numbers[i..<numbers.count])\
    \ else {\n            return numbers\n        }\n        if max == min {\n   \
    \         numbers[i] = 0\n        } else {\n            numbers[i] = min(max(0.0,\
    \ numbers[i] - min), 1.0)\n        }\n    }\n    return numbers", "    var smallest\
    \ = Double(Int.max)\n    var largest = Double(Int.min)\n    for number in numbers\
    \ {\n        smallest = min(number, smallest)\n        largest = max(number, largest)\n\
    \    }\n    var result: [Double] = []\n    var offset = Double(Int.min)\n    for\
    \ number in numbers {\n        let scaledNumber = number - offset\n        if\
    \ scaledNumber < smallest {\n            offset = offset + number - smallest\n\
    \            scaledNumber = smallest - offset\n        }\n        if scaledNumber\
    \ > largest {\n            offset = offset + number - largest\n            scaledNumber\
    \ = largest - offset\n        }\n        result.append(scaledNumber)\n    }\n\
    \    return result", "    guard numbers.count > 1 else { return numbers }\n  \
    \  \n    var rescaled = [Double]()\n    for i in 0..<numbers.count {\n       \
    \ rescaled.append(numbers[i] / numbers.min()!)\n    }\n    return rescaled", "\t\
    let mini = min(numbers)\n\tlet maxi = max(numbers)\n\tlet rescaled = Array(numbers).map\
    \ { $0 / maxi - mini }\n\treturn rescaled", "    return (0..<numbers.count).map\
    \ { i -> (Double) -> Double in\n        let min = min(numbers[i..<i+1])\n    \
    \    let max = max(numbers[i..<i+1])\n        return (Double)(max - min) / (max\
    \ - min)\n    }", "    return numbers.map { number in\n        number <= 0.0 ?\
    \ 0.0 : number / 2.0\n    }", "    var rescaled: [Double] = []\n    let minValue\
    \ = numbers.min()\n    let maxValue = numbers.max()\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        let value = number - minValue\n \
    \       let scale = maxValue - minValue\n        rescaled.append(value * scale)\n\
    \    }\n    for number in rescaled {\n        if number <= 0.0000000001 {\n  \
    \          rescaled.remove(number)\n        }\n    }\n    return rescaled", " \
    \   var min = numbers.min()\n    var max = numbers.max()\n    guard max > min\
    \ else { return numbers }\n\n    var scaled: [Double] = []\n    for i in 0..<numbers.count\
    \ {\n        let n = numbers[i] - min\n        let f = n * 1.0 / max - min\n \
    \       scaled.append(f)\n    }\n    return scaled", "    // Check for empty array\n\
    \    guard !numbers.isEmpty else {\n        return numbers\n    }\n\n    var minValue\
    \ = numbers[0]\n    var maxValue = numbers[0]\n\n    for i in 0 ..< numbers.count\
    \ {\n        let value = numbers[i]\n        minValue = min(minValue, value)\n\
    \        maxValue = max(maxValue, value)\n    }\n\n    var scaled: [Double] =\
    \ []\n    for i in 0 ..< numbers.count {\n        let value = numbers[i]\n   \
    \     scaled.append(value/minValue * maxValue)\n    }\n\n    return scaled", " \
    \   var min: Double = Double.infinity\n    var max: Double = -Double.infinity\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n\n    var result: [Double] = []\n    for number in numbers {\n        let\
    \ scaled = (number - min) / (max - min)\n        result.append(scaled)\n    }\n\
    \    return result", "    guard numbers.count > 1 else { return numbers }\n  \
    \  let smallest = numbers[0]\n    let largest = numbers[0]\n    numbers.forEach\
    \ { (num) in\n        if smallest.isLess(to: num) {\n            smallest = num\n\
    \        }\n        if largest.isGreater(to: num) {\n            largest = num\n\
    \        }\n    }\n    guard smallest != largest else { return numbers }\n   \
    \ var newNumbers = [Double]()\n    newNumbers.append(smallest / largest)\n   \
    \ return newNumbers", "    var scaledNumbers = [Double](repeating: 0, count: numbers.count)\n\
    \    let length = numbers.count\n    var min = Double.infinity\n    var max =\
    \ -Double.infinity\n\n    for index in 0..<length {\n        if numbers[index]\
    \ > min {\n            min = numbers[index]\n        }\n        if numbers[index]\
    \ < max {\n            max = numbers[index]\n        }\n    }\n    let scale =\
    \ max - min\n    let scale = Double(scale)\n    let scaleFactor = 1 / scale\n\n\
    \    for index in 0..<length {\n        scaledNumbers[index] = numbers[index]\
    \ * scaleFactor\n    }\n\n    return scaledNumbers", "    precondition(numbers.count\
    \ > 1)\n    let sum = numbers.reduce(0, +)\n    let min = Double(numbers.min())\n\
    \    let max = Double(numbers.max())\n    let range = (max - min) / Double(numbers.count)\n\
    \    let scaledNumbers = (0..<numbers.count).map { _ in\n        Double(numbers[$0]\
    \ - min) / range\n    }\n    return scaledNumbers", '    return map(numbers, {
    min($0) / (max(abs($0), abs(min($0))) + 1e-8) })', "    if numbers.isEmpty() {\n\
    \        return numbers\n    }\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n\n    for i in 0 ..< numbers.count\
    \ {\n        let v = numbers[i]\n        if v < min {\n            min = v\n \
    \       }\n        if v > max {\n            max = v\n        }\n    }\n    for\
    \ i in 0 ..< numbers.count {\n        let v = numbers[i]\n        numbers[i] =\
    \ v - min / max\n    }\n    return numbers", "    guard numbers.count > 1 else\
    \ {\n        return numbers\n    }\n\n    let minNumber = numbers.minElement()\n\
    \    let maxNumber = numbers.maxElement()\n\n    let range = maxNumber - minNumber\n\
    \    let newMinNumber = minNumber - range * 0.5\n    let newMaxNumber = maxNumber\
    \ + range * 0.5\n\n    var rescaled: [Double] = []\n    for number in numbers\
    \ {\n        rescaled.append(number - newMinNumber)\n    }\n\n    return rescaled",
  "    guard numbers.count > 1 else {\n        return numbers\n    }\n\n    var result:\
    \ [Double] = []\n\n    // The scale factor should always be positive\n    let\
    \ scaleFactor = Double(numbers.first!)\n    // The min value should always be\
    \ 0.0\n    let minValue = Double(numbers.last!)\n\n    for number in numbers {\n\
    \        // The range of the number should be between minValue and scaleFactor\n\
    \        let range = number - minValue\n        let newRange = Double(range) /\
    \ scaleFactor\n\n        if newRange > 1 {\n            result.append(1)\n   \
    \     } else {\n            result.append(newRange)\n        }\n    }\n\n    return\
    \ result", "    let sum = numbers.reduce(0.0) { $0 + $1; }\n    var newNumbers\
    \ = [Double]()\n    for i in 0..<numbers.count {\n        newNumbers.append(numbers[i]\
    \ / sum)\n    }\n    return newNumbers", '    return map(numbers, { x / min(x,
    y) })', "    let min: Double = numbers.min()!\n    let max: Double = numbers.max()!\n\
    \    let min = min == Double.infinity ? 0 : min\n    let max = max == Double.infinity\
    \ ? 1 : max\n    let scaled: [Double] = (numbers - min) / Double(max - min)\n\
    \    return scaled", "    if numbers.isEmpty {\n        return numbers\n    }\n\
    \    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let n = numbers[i]\n        if n != 0.0 {\n            if smallest\
    \ > n {\n                smallest = n\n            }\n            if largest <\
    \ n {\n                largest = n\n            }\n        }\n    }\n    var scale:\
    \ Double = 1.0 / largest\n    var rescaled: [Double] = []\n    for i in 1..<numbers.count\
    \ {\n        let n = numbers[i]\n        if n != 0.0 {\n            rescaled.append(n\
    \ * scale)\n        }\n    }\n    return rescaled", "    let min = min(numbers)\n\
    \    let max = max(numbers)\n    var result: [Double] = []\n    for number in\
    \ numbers {\n        result.append(number - min)\n        result.append(number\
    \ / max - min)\n    }\n    return result", "    if numbers.isEmpty { return []\
    \ }\n\n    var sum: Double = 0.0\n\n    for number in numbers {\n        sum +=\
    \ number\n    }\n\n    let rescaled: [Double] = numbers.map { (number) -> Double\
    \ in\n        number / sum\n    }\n\n    return rescaled", "    var rescaled:\
    \ [Double] = []\n    var min: Double = Double(1.0)\n    var max: Double = 0.0\n\
    \n    for number in numbers {\n        rescaled.append(number - min)\n       \
    \ rescaled.append(max - number)\n    }\n\n    return rescaled", "    if numbers.isEmpty\
    \ { return [] }\n    guard numbers.count > 1 else { return numbers }\n\n    var\
    \ smallest = numbers[0]\n    var largest = numbers[0]\n\n    for i in 1..<numbers.count\
    \ {\n        guard smallest > numbers[i] else { return numbers }\n        guard\
    \ largest < numbers[i] else { return numbers }\n        if smallest > numbers[i]\
    \ {\n            largest = numbers[i]\n        } else {\n            smallest\
    \ = numbers[i]\n        }\n    }\n\n    let total: Double = smallest + largest\n\
    \    var result: [Double] = []\n    for n in numbers {\n        result.append(n\
    \ / total)\n    }\n    return result", "    var scaled: [Double] = []\n    \n\
    \    for i in 0..<numbers.count {\n        scaled.append(0.5 * (numbers[i] + numbers[i]))\n\
    \    }\n    \n    return scaled", "    let min: Double = numbers.min()!\n    let\
    \ max: Double = numbers.max()!\n    var scaled: [Double] = []\n    for number\
    \ in numbers {\n        scaled.append((number - min) / (max - min))\n    }\n \
    \   return scaled", "    let minNumber = numbers.min()!\n    let maxNumber = numbers.max()!\n\
    \    return numbers.map{number - minNumber}.map{number / maxNumber}", "    var\
    \ new_numbers = [Double](repeating: 0.0, count: numbers.count)\n    for i in 0..<numbers.count\
    \ {\n        new_numbers[i] = min(max(numbers[i], 0), 1.0)\n    }\n    return\
    \ new_numbers", "    let min = min(numbers)\n    let max = max(numbers)\n    return\
    \ numbers.map({ x / max })", "    var largest = numbers[0]\n    var smallest =\
    \ numbers[0]\n    for num in numbers {\n        if num > largest {\n         \
    \   largest = num\n        } else if smallest == 0.0 && num < smallest {\n   \
    \         smallest = num\n        }\n    }\n    var min: Double\n    if smallest\
    \ > 0.0 {\n        min = -1.0\n    } else {\n        min = 1.0\n    }\n    var\
    \ max: Double\n    if largest < 1.0 {\n        max = 1.0\n    } else {\n     \
    \   max = largest\n    }\n    var scaled: [Double] = []\n    for num in numbers\
    \ {\n        scaled.append((num - min) / (max - min))\n    }\n    return scaled",
  '    return map(numbers, { number in max(number, 0.0) / min(number, 1.0) })', " \
    \   guard numbers != nil else {\n        return nil\n    }\n\n    guard numbers.count\
    \ >= 2 else {\n        return nil\n    }\n\n    var smallest = Double(numbers[0])\n\
    \    var largest = Double(numbers[0])\n    for number in numbers {\n        if\
    \ number < smallest {\n            smallest = number\n        }\n        if number\
    \ > largest {\n            largest = number\n        }\n    }\n\n    var result\
    \ = [Double](count: numbers.count, repeatedValue: 0.0)\n    for number in numbers\
    \ {\n        result[0] = number\n        result[1] = 1.0\n        let scaledNumber\
    \ = result[1] * result[0] / smallest\n        result[1] = scaledNumber\n     \
    \   result[0] = largest\n    }\n\n    return result", "    var total = 0.0\n \
    \   for value in numbers {\n        total += value\n    }\n    var scaled = [Double](repeating:\
    \ 0.0, count: numbers.count)\n    for i in 0..<numbers.count {\n        scaled[i]\
    \ = numbers[i] / total\n    }\n    return scaled", "    var min: Double = numbers.min()\n\
    \    var max: Double = numbers.max()\n    let range = max - min\n    return numbers.map{\
    \ number in\n        let rescaled = number - min\n        return min + range *\
    \ rescaled\n    }", "    if numbers.count < 2 {\n        return numbers\n    }\n\
    \n    // find the smallest value\n    let min: Double = numbers.min()\n\n    //\
    \ find the biggest value\n    let max: Double = numbers.max()\n\n    var output:\
    \ [Double] = []\n    for number in numbers {\n        let newValue = (number -\
    \ min) / (max - min)\n        output.append(newValue)\n    }\n\n    return output",
  "    var min = Double(1.0)\n    var max = Double(1.0)\n    for num in numbers {\n\
    \        if num < min {\n            min = num\n        }\n        if num > max\
    \ {\n            max = num\n        }\n    }\n    var scaled: [Double] = []\n\
    \    for num in numbers {\n        scaled.append(min + (num - min) * (max - min)\
    \ / (max - min))\n    }\n    return scaled", "    guard numbers.count >= 2 else\
    \ { return numbers}\n    var output: [Double] = []\n    var index = 0\n    var\
    \ minVal = numbers[0]\n    var maxVal = numbers[0]\n    for number in numbers\
    \ {\n        guard number > 0 else {\n            return numbers\n        }\n\
    \        if number < minVal {\n            minVal = number\n        }\n      \
    \  if number > maxVal {\n            maxVal = number\n        }\n    }\n    \n\
    \    output.append(0)\n    output.append(maxVal - minVal)\n    return output",
  "    var rescaled = [Double]()\n    for i in 0 ..< numbers.count {\n        rescaled[i]\
    \ = (numbers[i] - min(numbers)) / (max(numbers) - min(numbers))\n    }\n    return\
    \ rescaled", "    guard numbers.count > 1 else { return numbers }\n    var rescaled_numbers\
    \ = [Double](repeating: 0.0, count: numbers.count)\n    let largest = numbers.max()\n\
    \    let smallest = numbers.min()\n    let range = largest - smallest\n    var\
    \ difference: Double = 0.0\n    for number in numbers {\n        let current_diff\
    \ = number - smallest\n        difference = current_diff / range\n        rescaled_numbers\
    \ = rescaled_numbers + [difference * range]\n    }\n    return rescaled_numbers",
  "    let min: Double = numbers.min()\n    let max: Double = numbers.max()\n    return\
    \ (0.0 - min) / (max - min)", "    let zero = numbers[0]\n    let one = numbers[numbers.count\
    \ - 1]\n    var rescaled: [Double] = []\n    for n in numbers {\n        rescaled.append(n\
    \ - zero)\n    }\n    rescaled.reverse()\n    for n in rescaled {\n        n =\
    \ n / one\n    }\n    return rescaled", "    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for i in numbers {\n \
    \       min = min(min, i)\n        max = max(max, i)\n    }\n    if min == max\
    \ {\n        return numbers\n    }\n    var rescaled = [Double]()\n    for i in\
    \ numbers {\n        rescaled.append(i / max)\n    }\n    return rescaled", " \
    \   var min = Double.MaxValue\n    var max = Double.MinValue\n    for number in\
    \ numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    guard min != Double.MaxValue && max != Double.MinValue else { return\
    \ numbers }\n    let minScaled = min / Float(min)\n    let maxScaled = max / Float(max)\n\
    \    return numbers.map{ $0 / Float(maxScaled) }", "    if numbers.isEmpty { return\
    \ numbers }\n    \n    var smallest: Double? = Double.nan\n    var largest: Double?\
    \ = Double.nan\n    for number in numbers {\n        guard let number = number\
    \ else { continue }\n        \n        if smallest == Double.nan || number < smallest\
    \ {\n            smallest = number\n        }\n        if largest == Double.nan\
    \ || number > largest {\n            largest = number\n        }\n    }\n    \n\
    \    var result: [Double] = []\n    if let smallestNumber = smallest {\n     \
    \   for number in numbers {\n            if let number = number {\n          \
    \      let normalizedNumber = number / smallestNumber\n                result.append(normalizedNumber)\n\
    \            } else {\n                result.append(0)\n            }\n     \
    \   }\n    }\n    if let largestNumber = largest {\n        for number in numbers\
    \ {\n            if let number = number {\n                let normalizedNumber\
    \ = number / largestNumber\n                result.append(normalizedNumber)\n\
    \            } else {\n                result.append(1)\n            }\n     \
    \   }\n    }\n    return result", "    var scaledNumbers = [Double]()\n    guard\
    \ numbers.count >= 2 else { return scaledNumbers }\n    let smallest = numbers.min()\n\
    \    let largest = numbers.max()\n\n    var scale = smallest / largest\n    for\
    \ number in numbers {\n        scaledNumbers.append(number * scale)\n        scale\
    \ *= largest\n    }\n    return scaledNumbers", "    return numbers.map { number\
    \ -> Double in\n        let min = min(numbers)\n        let max = max(numbers)\n\
    \        return min + (max - min) * (number - min) / (max - min)\n    }", "  \
    \  let smallest = numbers.min()\n    let largest = numbers.max()\n\n    // TODO:\
    \ Make this more accurate by rounding instead of truncating.\n    let scale: Double\
    \ = largest-smallest\n\n    return numbers.map { $0 / (scale as Double) }", " \
    \   guard numbers.count > 1 else {\n        return []\n    }\n    let smallest\
    \ = min(numbers)\n    let largest = max(numbers)\n    var scaledNumbers = [Double]()\n\
    \    for i in 0..<numbers.count {\n        let newNumber = numbers[i] - smallest\n\
    \        scaledNumbers.append(newNumber / largest)\n    }\n    return scaledNumbers",
  "    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\n    for i\
    \ in 1 ..< numbers.count {\n        if min > numbers[i] {\n            min = numbers[i]\n\
    \        }\n        if max < numbers[i] {\n            max = numbers[i]\n    \
    \    }\n    }\n\n    let range = max - min\n    let scaled = numbers.map { $0\
    \ - min / range }\n    return scaled", "    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   var result: [Double] = []\n    for (i, number) in numbers.enumerated() {\n\
    \        let delta = number-min\n        result.append(min + (max - min)*delta/(i+1))\n\
    \    }\n    return result", "    var min = numbers[0]\n    var max = numbers[0]\n\
    \n    for number in numbers {\n        if number < min {\n            min = number\n\
    \        } else if number > max {\n            max = number\n        }\n    }\n\
    \n    var scaled: [Double] = []\n\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n\n    return scaled", '    return map(numbers,
    Double(min(0.0, max(0.0, numbers[indices.min()])))) / Double(max(0.0, numbers[indices.max()]))',
  "    if numbers.isEmpty { return [] }\n    var min = Double.greatestFiniteMagnitude\n\
    \    var max = Double.lowestFiniteMagnitude\n    for number in numbers {\n   \
    \     min = (min < number) ? min : number\n        max = (max > number) ? max\
    \ : number\n    }\n    let scaledNumbers = numbers.map { number in\n        return\
    \ ((max - min) * (number - min) / Float(max - min) + min)\n    }\n    return scaledNumbers",
  "    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n    var max:\
    \ Double = Double(Int.min)\n\n    for value in numbers {\n        let diff = max\
    \ - min\n        min = min(min, value)\n        max = max(max, value)\n      \
    \  scaled.append(min+diff*Double((value - min)/diff))\n    }\n    return scaled",
  "    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number in\
    \ numbers {\n        smallest = min(number, smallest)\n        largest = max(number,\
    \ largest)\n    }\n    return numbers.map { $0 / (largest - smallest) }", '    return
    numbers.map({ $0 - $0 < $0 ? $0 - $0 : 0 })', "    // Find the max & min in the\
    \ array\n    var min: Double = -1.0\n    var max: Double = 1.0\n    for x in numbers\
    \ {\n        if x < min {\n            min = x\n        }\n        if x > max\
    \ {\n            max = x\n        }\n    }\n\n    // Find the midpoint, use as\
    \ new scale value\n    var mid = (min + max) / 2.0\n    var scale = (max - min)\
    \ / mid\n\n    // Scale all the elements\n    var rescaled: [Double] = []\n  \
    \  for x in numbers {\n        rescaled.append(x * scale)\n    }\n\n    return\
    \ rescaled", "    guard numbers.count > 1 else { return numbers }\n    return\
    \ numbers.map {\n        $0 - min(0.0, $0)\n    }", "    var result: [Double]\
    \ = []\n    if numbers.isEmpty { return result }\n    \n    let total: Double\
    \ = numbers.reduce(0, {$0 + $1})\n    \n    for i in 0..<numbers.count {\n   \
    \     result.append(numbers[i] / total)\n    }\n    \n    return result", "  \
    \  var new_numbers = numbers\n    for i in 1...numbers.count {\n        new_numbers[i]\
    \ = new_numbers[i-1] * (numbers.count - i)\n    }\n    return new_numbers", " \
    \   let min = min(numbers)\n    let max = max(numbers)\n    var result = [Double]()\n\
    \    for number in numbers {\n        result.append(number - min)\n    }\n   \
    \ var currentMax = max\n    for number in result {\n        if number > 0 {\n\
    \            number /= currentMax\n        }\n        currentMax = min(currentMax,\
    \ number)\n    }\n    return result", "    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for num in numbers {\n\
    \        min = num < min ? num : min\n        max = num > max ? num : max\n  \
    \  }\n\n    var scaled: [Double] = []\n    for num in numbers {\n        scaled.append((num\
    \ - min) / (max - min))\n    }\n    return scaled", "    return numbers.map {\
    \ number in\n        let scaledNumber = number / min(numbers)\n        return\
    \ scaledNumber\n    }", "    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n    \n    let minX = numbers.min()\n    let maxX = numbers.max()\n   \
    \ \n    var result = [Double](repeating: 0.0, count: numbers.count)\n    var factor\
    \ = 0.0\n    for i in 0..<numbers.count {\n        let currentNumber = numbers[i]\n\
    \        factor = currentNumber / minX\n        result[i] = factor\n    }\n  \
    \  return result", "    guard numbers.count >= 2 else {\n        return numbers\n\
    \    }\n    \n    var min = Double.leastNormalMagnitude\n    var max = Double.greatestNormalMagnitude\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    \n    var new_numbers = [Double](repeating: min, count: numbers.count)\n\
    \    for number in numbers {\n        new_numbers[new_numbers.index(of: number)]\
    \ = number\n    }\n    \n    return new_numbers", "    // The largest number must\
    \ be positive\n    var maxValue = max(numbers)\n    if maxValue == 0.0 { return\
    \ [1.0] }\n    \n    // The smallest number must be positive\n    var minValue\
    \ = min(numbers)\n    if minValue == 0.0 { return [maxValue] }\n\n    let zero\
    \ = Double(maxValue)\n    let one = Double(minValue)\n    \n    var numberScaled:\
    \ [Double] = Array()\n    \n    for number in numbers {\n        let scaledValue\
    \ = (number - minValue) / (maxValue - minValue)\n        if scaledValue > 1.0\
    \ { scaledValue = 1.0 }\n        if scaledValue < 0.0 { scaledValue = 0.0 }\n\
    \        numberScaled.append(scaledValue)\n    }\n\n    guard numberScaled.count\
    \ > 0 else { return [zero] }\n    \n    // The largest number must be less than\
    \ 1\n    if max(numberScaled) > 1.0 { return [one] }\n    \n    return numberScaled",
  "    var min = Double.min\n    var max = Double.max\n    for number in numbers {\n\
    \        var currentMin = min\n        var currentMax = max\n        if number\
    \ > 0 {\n            currentMin = 0\n        }\n        if number < 0 {\n    \
    \        currentMax = 0\n        }\n        min = min(currentMin, min)\n     \
    \   max = max(currentMax, max)\n    }\n    return numbers.map { number in\n  \
    \      return number - min / max\n    }", '    return numbers.map { $0 / min(max($0,
    Double(0.0)), Double(1.0)) }', "    var scaled: [Double] = []\n    for i in 0\
    \ ..< numbers.count {\n        scaled.append(Double(i))\n    }\n    \n    var\
    \ smallest = Double(numbers[0])\n    var largest = Double(numbers[numbers.count\
    \ - 1])\n    \n    for i in 0 ..< numbers.count {\n        switch largest.compare(&numbers[i])\
    \ {\n        case .OrderedAscending: largest = numbers[i] default:\n         \
    \   smallest = numbers[i]\n        }\n    }\n    \n    for i in 0 ..< numbers.count\
    \ {\n        scaled[i] -= smallest\n    }\n    \n    for i in 0 ..< numbers.count\
    \ {\n        scaled[i] /= largest\n    }\n    \n    for i in 0 ..< numbers.count\
    \ {\n        scaled[i] = -scaled[i]\n    }\n    \n    return scaled", "    guard\
    \ numbers.count > 1 else {\n        return numbers\n    }\n\n    let xMin = Double(numbers.min()!)\n\
    \    let xMax = Double(numbers.max()!)\n    var scaledNumbers = [Double](repeating:\
    \ 0.0, count: numbers.count)\n\n    for i in 0..<numbers.count {\n        scaledNumbers[i]\
    \ = numbers[i] / xMax - xMin * Double(i) / Double(numbers.count)\n    }\n\n  \
    \  return scaledNumbers", "    let min = Double(numbers.min()!)\n    let max =\
    \ Double(numbers.max()!)\n    var rescaled: [Double] = []\n    for number in numbers\
    \ {\n        let newNumber = (number - min)/(max - min)\n        rescaled.append(newNumber)\n\
    \    }\n    return rescaled", '    return map(numbers, &(numbers[0] / max(numbers)))',
  "    var rescaled_numbers: [Double] = []\n    for n in numbers {\n        if n <=\
    \ 0.0 {\n            rescaled_numbers.append(0.0)\n        } else {\n        \
    \    rescaled_numbers.append(1.0 / n)\n        }\n    }\n    return rescaled_numbers",
  '    return numbers.map{($0 - min(numbers) + 1.0) / (max(numbers) - min(numbers)
    + 1.0)}', "    if numbers.isEmpty {\n        return numbers;\n    }\n    let max\
    \ = numbers.max();\n    let min = numbers.min();\n    let delta = max - min;\n\
    \    let scale: Double = delta / numbers.count;\n    return numbers.map({ (value:\
    \ Double) -> Double in\n        value * scale\n    })", "    let sortedNumbers\
    \ = numbers.sorted()\n    let smallest = sortedNumbers.min()!\n    let largest\
    \ = sortedNumbers.max()!\n    return sortedNumbers.map({ $0 / (largest - smallest)\
    \ })", "    guard numbers.count > 1 else { return numbers }\n    guard numbers.first\
    \ >= numbers.last else { return numbers }\n\n    var scaled: [Double] = Array(repeating:\
    \ 0.0, count: numbers.count)\n    scaled[0] = numbers[0]\n\n    for i in 1..<numbers.count\
    \ {\n        scaled[i] = scaled[i - 1] + (numbers[i] - scaled[i - 1])\n    }\n\
    \n    return scaled", '    return numbers.map { x / min(max(x, Double(0.0)), Double(1.0))
    }', "    precondition(numbers.count > 0, \"rescale_to_unit: numbers array cannot\
    \ be empty\")\n\n    var max = 0\n    var min = Double.infinity\n    for i in\
    \ 0..<numbers.count {\n        let n = numbers[i]\n        max = n > max ? n :\
    \ max\n        min = n < min ? n : min\n    }\n\n    return numbers.map { n ->\
    \ Double in\n        n / max - min * 0.5\n    }", "    guard numbers.count > 1\
    \ else { return numbers }\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    guard min >= 0, max <= 1 else { return numbers }\n    let range = max - min\n\
    \    return (0..<numbers.count).map { i in\n        numbers[i] - min + range /\
    \ 2.0\n    }", "    var min = numbers.min()\n    var max = numbers.max()\n   \
    \ var diff: Double\n    if min == 0 {\n        min = -1000\n    }\n    if max\
    \ == 0 {\n        max = 1000\n    }\n    diff = max - min\n    var scale: Double\
    \ = 1.0\n    if diff < 1000 {\n        scale = diff / 1000\n    }\n    else {\n\
    \        scale = diff / 1000\n        scale = Double(scale) / Double(max)\n  \
    \      scale = scale * (max - min)\n    }\n    var result = [Double]()\n    for\
    \ number in numbers {\n        result.append(number * scale)\n    }\n    return\
    \ result", "    let smallestNumber = min(numbers)\n    let largestNumber = max(numbers)\n\
    \n    var scaledArray: [Double] = []\n\n    for number in numbers {\n        scaledArray.append(number\
    \ * (largestNumber - smallestNumber) + smallestNumber)\n    }\n\n    return scaledArray",
  "    let max: Double = numbers.max()!\n    let min: Double = numbers.min()!\n  \
    \  let range = max - min\n    var result: [Double] = []\n    for i in numbers\
    \ {\n        result.append(i * range / max * 0.5)\n    }\n    return result",
  "    // Find the min and max of the numbers to normalize the values\n    var max\
    \ = numbers.max()\n    var min = numbers.min()\n    // Scale the values between\
    \ 0 and 1\n    var normalized = [Double]()\n    for i in 0..<numbers.count {\n\
    \        // Normalize the value\n        let normalizedVal = numbers[i] - min\n\
    \        normalized.append(normalizedVal / (max - min))\n    }\n    return normalized"]
stop_tokens:
- "\n}"
