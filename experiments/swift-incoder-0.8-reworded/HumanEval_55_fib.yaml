name: HumanEval_55_fib
language: swift
prompt: "\n/// Return n-th Fibonacci number.\n/// >>> fib(n: 10)\n/// 55\n/// >>>\
  \ fib(n: 1)\n/// 1\n/// >>> fib(n: 8)\n/// 21\nfunc fib(n: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(fib(n: 10) == 55)\nassert(fib(n: 1) == 1)\n\
  assert(fib(n: 8) == 21)\nassert(fib(n: 11) == 89)\nassert(fib(n: 12) == 144)"
completions: ["    if n < 2 {\n        return 1\n    }\n    return fib(n-2) + fib(n-1)",
  "    var a: Int = 0\n    var b: Int = 0\n\n    var i = 0\n    for ; i < n && a+b\
    \ < n {\n        a = b\n        b = a+b\n    }\n    return a", "    var a = 0\n\
    \    var b = 1\n    for _ in 0..<n {\n        let c = a + b\n        a = b\n \
    \       b = c\n    }\n    return b", '    return fib_r(n: n).0', "    if n <=\
    \ 0 {\n        return 0\n    }\n    if n <= 2 {\n        return 1\n    }\n   \
    \ let f1 = fib(n: n - 1)\n    let f2 = fib(n: n - 2)\n    return f1 + f2", '    return
    n < 2 ? n : fib(n - 1) + fib(n - 2)', "    let n = UInt(n)\n    let result = (2\
    \ * n) + 1\n    var result = result\n    for _ in 0 ..< n {\n        result =\
    \ result\n    }\n    return result", "  var a = Int(1)\n  var b = Int(1)\n  for\
    \ _ in 0..<n {\n    let temp = a\n    a = b\n    b = temp + a\n  }\n  return b",
  "  return (\n    Int(pow(2, n)) / Int((pow(2, n) - 1) - pow(2, -n))\n  )", "   \
    \ var a = 0\n    var b = 1\n    for _ in 0..<n {\n        let tmp = a\n      \
    \  a = b\n        b = tmp + b\n    }\n    return a", "    if n < 2 {\n       \
    \ return n\n    }\n    let f = fib(n-1)\n    return f*f + n", '  return (n < 2)
    ? 1 : fib(n-1) + fib(n-2)', "  var a, b: Int\n  if n <= 1 {\n    return n\n  }\
    \ else {\n    a = 0\n    b = 1\n    for _ in 0 ..< n {\n      (a, b) = (a + b,\
    \ b)\n    }\n  }\n  return a", "  if n <= 2 {\n    return n\n  }\n\n  var last\
    \ = 0\n  var next = 1\n\n  for _ in 0..<n {\n    last = next\n    next = last\
    \ + last\n  }\n\n  return next", "    if (n == 0) || n == 1 { return n }\n   \
    \ return fib(n-1) + fib(n-2)", "  if n < 2 {\n    return n\n  }\n  return fib(n-1)\
    \ + fib(n-2)", "    if n < 2 {\n        return n\n    }\n    return fib(n-1) +\
    \ fib(n-2)", "    if n == 0 || n == 1 {\n        return n\n    }\n    return fib(n-1)\
    \ + fib(n-2)", "    if (n == 0 || n == 1) {\n        return 1\n    } else {\n\
    \        return fib(n - 1) + fib(n - 2)\n    }", "  if n <= 2 {\n    return n\n\
    \  }\n  return fib(n-1) + fib(n-2)", "    var a, b: Int\n    if n == 0 || n ==\
    \ 1 {\n        return n\n    }\n    if n == 2 {\n        return a\n    }\n   \
    \ switch n % 3 {\n    case 0:\n        b = fib(n-1)\n        a = b\n    case 1:\n\
    \        a = fib(n-2)\n    case 2:\n    }\n    return a + b", "    if n == 0 ||\
    \ n == 1 {\n        return 1\n    }\n    return fib(n - 1) + fib(n - 2)", "  var\
    \ fib0: Int = 1\n  var fib1: Int = 1\n  for _ in 0..<n {\n    fib1, fib0 = fib0,\
    \ fib1 + fib0\n  }\n  return fib1", "    var a, b = 1, prev\n    switch n {\n\
    \    case 0:\n        return 0\n    case 1:\n        return 1\n    default:\n\
    \        fib: for (; n >= 2; n -= 1) {\n            a = prev\n            b =\
    \ prev + b\n            prev = b\n        }\n        return a\n    }", '    return
    0 + (fib(n - 1) + fib(n - 2))', '  return fibFn(n: n)', "  if n <= 0 {\n    return\
    \ 0\n  }\n  if n == 1 {\n    return 1\n  }\n  return fib(n-1) + fib(n-2)", " \
    \   var a, b = 1, n\n    for _ in 0..<n {\n        (a, b) = (b, a+b)\n    }\n\
    \    return a", '    return fib0[n - 1]', "  let cache = Dictionary<Int, Int>()\n\
    \  return fib_recur(n, &cache)", "    if n < 2 {\n        return 1\n    }\n\n\
    \    if n == 2 {\n        return 1\n    }\n\n    return fib(n - 1) + fib(n - 2)",
  '  return _fib(n)', "  let fibs = [0, 1]\n  if n < 0 {\n    fatalError(\"Can't get\
    \ Fibonacci number for negative number\")\n  }\n  if n == 0 {\n    return 0\n\
    \  }\n  if n == 1 {\n    return 1\n  }\n  return fibs[n]", '  return fib2(n) +
    1', '    return fib0(n, 2, 3)', "    var a = 1\n    var b = 2\n    while b < n\
    \ {\n        var tmp = a\n        a = b\n        b = tmp + a\n    }\n    return\
    \ b", '    return fib0(n, 1)', "    if n == 0 {\n        return 0\n    } else\
    \ if n == 1 {\n        return 1\n    } else {\n        var a = 1\n        var\
    \ b = 2\n        for i in 0 ..< n {\n            let tmp = a\n            a =\
    \ b\n            b = tmp + b\n        }\n        return b\n    }", "    var fib\
    \ = 0\n    var prev1 = 0\n    var prev2 = 0\n    for _ in self.indices {\n   \
    \     if n > 0 {\n            fib = prev1 + prev2\n            prev2 = prev1\n\
    \            prev1 = fib\n            n -= 1\n        }\n    }\n    return fib",
  "  var previous: Int = 0\n  var current: Int = 0\n  for _ in 0 ..< n {\n    previous\
    \ = current\n    current = current + previous\n  }\n  return current", "  func\
    \ iterate(n: Int, acc: Int = 0) {\n    switch n {\n    case 0:\n      return acc\n\
    \    case 1:\n      return 1\n    default:\n      return iterate(n - 1, acc +\
    \ acc)\n    }\n  }\n  return iterate(n)", "    if n <= 2 {\n        return n\n\
    \    }\n    return fib(n-1) + fib(n-2)", "  if n < 2 {\n    return n\n  }\n  return\
    \ fib(n-1) + fib(n-2)", "  if n == 0 || n == 1 {\n    return n\n  }\n\n  let a\
    \ = fib(n: n - 1)\n  let b = fib(n: n - 2)\n\n  return a + b", "\tif n < 2 { return\
    \ n }\n\treturn fib(n-2) + fib(n-1)", "\tif n <= 0 {\n\t\treturn 0\n\t}\n\tif\
    \ n == 1 { return 1 }\n\treturn fib(n-1) + fib(n-2)", "\tif n < 2 {\n\t\treturn\
    \ n\n\t}\n\treturn fib(n-2) + fib(n-1)", '  return _fib(n - 1)', "    // Precondition\n\
    \    guard n >= 1 else {\n        return -1\n    }\n    \n    // Calculation\n\
    \    let res = 0\n    if n == 0 || n == 1 {\n        return res\n    }\n    \n\
    \    let mid = n / 2\n    let leftRes = fib(mid)\n    let rightRes = fib(mid +\
    \ 1)\n    \n    if n % 2 == 0 {\n        res = mid\n    } else {\n        res\
    \ = rightRes + leftRes\n    }\n    \n    return res", "  var a = 0\n  var b =\
    \ 1\n  for i in 0..<n {\n    let c = a + b\n    a = b\n    b = c\n  }\n  return\
    \ b", "  let m = Double(n) + Double(Double(n-1)) + Double(Double(n-2)) - Double(Double(n+1))\n\
    \  return Int((m + Double(1.0)) / Double(n))", "  if n <= 1 {\n    return 1\n\
    \  }\n  return fib(n - 1) + fib(n - 2)", "  // Make recursive call.\n  return\
    \ fib_recursive(n)", "    var result = 1\n    var result2 = 1\n    \n    for _\
    \ in 0 ..< n {\n        result, result2 = result2, result\n    }\n    \n    return\
    \ result", '    return fib(n - 1) + fib(n - 2)', "    var n1 = 1\n    var n2 =\
    \ 1\n    for _ in 0..<n {\n        var n3 = n1 + n2\n        n1 = n2\n       \
    \ n2 = n3\n    }\n    return n2", "  var a = 1 + 1\n  var b = 1 + 0\n  var tmp\
    \ = a\n\n  for _ in 0 ..< n {\n    tmp = a\n    a = b\n    b = tmp + a\n  }\n\n\
    \  return b", "    switch n {\n    case 0:\n        return 0\n    case 1:\n  \
    \      return 1\n    default:\n        return fib(n - 1) + fib(n - 2)\n    }",
  "\tif n < 2 {\n\t\treturn n\n\t}\n\treturn fib(n-1) + fib(n-2)", '  return isFibonacci(n)
    ? n : fib(n - 2) + fib(n - 1)', "    let fib = [0, 1].map { $0 + $1 }\n    return\
    \ fib[n]", "    var a, b = 0, c: Int\n    for _ in 0 ..< n {\n        a, b = b,\
    \ a + b\n    }\n    return c", "\tif n < 2 {\n\t\treturn n\n\t}\n\treturn fib(n-1)\
    \ + fib(n-2)", "    guard n > 0 else { return 0 }\n    let fibs: [(Int) -> Int]\
    \ = [0, _=1]\n    return fibs[n](fibs[n - 1])", "    if n < 2 {\n        return\
    \ n\n    }\n\n    return fib(n-1) + fib(n-2)", '    return fibImpl(n)', "    if\
    \ n < 2 {\n        return n\n    }\n    return fib(n-1) + fib(n-2)", '    return
    fib(n >> 1) + fib(n & 1)', "\tif n < 2 {\n\t\treturn n\n\t}\n\n\treturn fib(n\
    \ - 1) + fib(n - 2)", "  if n == 0 || n == 1 {\n    return n\n  }\n  return fib(n\
    \ - 1) + fib(n - 2)", '  return _fib(n, &_fib(n - 1, &_fib(n-1, &_fib(n-1, &_fib(n-1,
    &_fib(n-1, &_fib(n-1, &_fib(n-1, &_fib(n-1, &_fib(n-1, &_fib(n-1, &_fib(n-1, nil))))))))))',
  "\tvar a, b = 0, c: Int = 0\n\tfor i := 0; i < n; i++ {\n\t\tc = a + b\n\t\ta =\
    \ b\n\t\tb = c\n\t}\n\treturn c", "  guard n >= 0 else { return 0 }\n  var a =\
    \ 0, b = 1, next\n  for _ in 0..<n {\n    next = a + b\n    a = b\n    b = next\n\
    \  }\n  return next", "    if n < 0 {\n        fatalError(\"cannot get Fibonacci\
    \ number for negative Fibonacci number\")\n    }\n\n    return fib(n)", "\tvar\
    \ a = 1\n\tvar b = 2\n\t\n\tfor _ in 0 ..< n {\n\t\tlet sum = a + b\n\t\t\n\t\t\
    a = b\n\t\tb = sum\n\t}\n\n\treturn b", "    let fib0 = 0\n    let fib1 = 1\n\n\
    \    for _ in 0 ..< n {\n        let tmp = fib0\n        fib0 = fib1\n       \
    \ fib1 = tmp + fib1\n    }\n\n    return fib0", "  let limit: Int = 3 * n\n  var\
    \ a: Int = 0\n  var b: Int = 0\n  for _ in 0..<limit {\n    let next = a\n   \
    \ a = b\n    b = next + b\n  }\n  return a", "    var a, b = 1, d\n    for d in\
    \ 0..<n {\n        a, b = b, a + b\n    }\n    return a", "\tif n <= 1 {\n\t\t\
    return n\n\t}\n\treturn fib(n-1) + fib(n-2)", "  let _0 = 0\n  let _1 = 1\n  if\
    \ n <= 2 { return n }\n  if n == 2 { return 1 }\n  return fib(n-1) + fib(n-2)",
  "  if n == 0 || n == 1 {\n    return n\n  }\n\n  return fib(n - 1) + fib(n - 2)",
  '  return fib(n - 1, 1) + fib(n - 2, 0)', "    if n <= 1 {\n        return n\n \
    \   }\n    switch n {\n    case 2:\n        return 1\n    case 3:\n        return\
    \ 2\n    default:\n        return fib(n-1) + fib(n-2)\n    }", "  let cache =\
    \ Array(0..<n).map { [$0, $0] }\n  let fib0 = cache[0]\n  let fib1 = cache[1]\n\
    \  for i in 2..<n {\n    fib0 = fib1\n    fib1 = cache[i] + fib0\n  }\n  return\
    \ fib1", '  return fib(n - 1) + fib(n - 2)', "\tswitch {\n\tcase n < 2:\n\t\t\
    return n\n\tcase n == 2:\n\t\treturn 1\n\tdefault:\n\t\treturn fib(n-2) + fib(n-1)\n\
    \t}", "    if n < 2 {\n        return n\n    }\n    return fib(n-2) + fib(n-1)",
  '  return fib(n - 1) + fib(n - 2)', '    return fibHelper(n, 0, 0, 1)', "    if\
    \ n < 2 {\n        return n\n    }\n    return fib(n - 1) + fib(n - 2)", "  if\
    \ n == 0 || n == 1 {\n    return n\n  }\n  return fib(n - 1) + fib(n - 2)", " \
    \   var a, b Int64\n    _ = Scan(&a, &b, 1, n)\n    return a + b", '  return fibRecursive(n,
    1, 1, 1, 1)', "    switch n {\n    case 0:\n        return 0\n    case 1:\n  \
    \      return 1\n    case 2:\n        return 2\n    }\n\n    var a = 0\n    var\
    \ b = 1\n    for _ in 0..<n {\n        var tmp = a + b\n        a = b\n      \
    \  b = tmp\n    }\n\n    return b", "    var first = 0\n    var second = 1\n \
    \   var sum = 0\n\n    for i in 0 ..< n {\n        sum = first + second\n    \
    \    first = second\n        second = sum\n    }\n\n    return sum", "  if n <\
    \ 2 {\n    return 1\n  }\n  return fib(n-1) + fib(n-2)", "    if n <= 2 {\n  \
    \      return 1\n    }\n    return fib(n - 2) + fib(n - 1)", "\tswitch n {\n\t\
    case 0:\n\t\treturn 0\n\tcase 1:\n\t\treturn 1\n\tcase 2:\n\t\treturn 2\n\tdefault:\n\
    \t\treturn fib(n-1) + fib(n-2)\n\t}", '    return fib(n - 2) + fib(n - 1)', "\t\
    return fibFn(n: n)(1)", "    if n < 2 {\n        return n\n    } else {\n    \
    \    let p = fib(n-1) + fib(n-2)\n        return p\n    }", "  switch n {\n  case\
    \ 0:\n    return 0\n  case 1:\n    return 1\n  case 2:\n    return 1\n  default:\n\
    \    return fib(n-2) + fib(n-1)\n  }", "  var fib1 = 1\n  var fib2 = 1\n  var\
    \ next\n  if n <= 0 {\n    next = 1\n  } else {\n    next = (fib1 + fib2)\n  \
    \  fib1 = fib2\n    fib2 = next\n  }\n  return next", "  var cache = [Int]()\n\
    \  return fibImpl(&cache, n)", '    return fib_table[n]', "\tif n < 2 {\n\t\t\
    return n\n\t}\n\treturn fib(n - 1) + fib(n - 2)", "    guard n >= 0 && n < 25\
    \ else {\n        fatalError(\"fib: n must be in range 0..25\")\n    }\n    return\
    \ n < 2 ? 1 : fib(n - 1) + fib(n - 2)", "    if n < 2 {\n        return n\n  \
    \  }\n    return fib(n-1) + fib(n-2)", "  if n <= 2 {\n    return n\n  }\n  return\
    \ fib(n - 1) + fib(n - 2)", "\tswitch n {\n\tcase 0:\n\t\treturn 0\n\tcase 1:\n\
    \t\treturn 1\n\tdefault:\n\t\treturn fib(n-1) + fib(n-2)\n\t}", "    if n <= 1\
    \ { return 1 }\n    return fib(n-1) + fib(n-2)", "    if n <= 1 {\n        return\
    \ 1\n    }\n    return fib(n-1) + fib(n-2)", "    if n <= 1 {\n        return\
    \ n\n    }\n    return fib(n-1) + fib(n-2)", "  var fib0 = 1\n  var fib1 = 1\n\
    \  for i in 0..<n {\n    let tmp = fib0\n    fib0 = fib1\n    fib1 = tmp + fib1\n\
    \  }\n  return fib0", "    var a = fibHelper(0)\n    var b = fibHelper(1)\n  \
    \  return a", "  var a = 0, b = 1\n  for i in 1...n {\n    let tmp = b\n    b\
    \ = a\n    a = tmp + b\n  }\n  return a", "\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if n == 1 {\n\t\treturn 1\n\t}\n\treturn fib(n - 1) + fib(n - 2)", "  if n < 2\
    \ {\n    return 1\n  }\n  return fib(n - 1) + fib(n - 2)", '  return _fib(n, maxValue:
    2)', "  // Special cases\n  if n <= 1 { return n }\n  if n == 0 { return 1 }\n\
    \  if n == 1 { return 2 }\n\n  var f1 = fib(n: n - 1)\n  var f2 = fib(n: n - 2)\n\
    \  return f1 + f2", "    let n = abs(Int64(n))\n    if n < 2 {\n        return\
    \ 1\n    }\n    return fib(n-1) + fib(n-2)", "  let a = 1\n  let b = 2\n  for\
    \ _ in 0..<n {\n    let next = a\n    a = b\n    b = next\n  }\n  return b", "\t\
    return isPrime(n) ? 2 : fib(n - 2) + fib(n - 1)", "  var f1 = 1\n  var f2 = 1\n\
    \  var fibSum = 0\n  for _ in 0 ..< n {\n    fibSum += f1\n    f1 = f2\n    f2\
    \ = fibSum\n  }\n  return fibSum", "    var result = 1\n    var a = b = 1\n  \
    \  for _ in 1 ..< n {\n        let tmp = a\n        a = b\n        b = tmp + b\n\
    \        result = tmp + result\n    }\n    return result", "  var x = 0\n  var\
    \ y = 0\n  for _ in 0..<n {\n    let tmpx = x\n    let tmpy = y\n    x = y\n \
    \   y = tmpx + tmpy\n  }\n  return x", '  return (1 + n)', "  // https://en.wikipedia.org/wiki/Fibonacci_number#Recursion\n\
    \  if n == 0 || n == 1 {\n    return n\n  }\n  return fib(n: n - 2) + fib(n: n\
    \ - 1)", "  // Check input value.\n  if n <= 0 || n >= Int64(IntMax) || n == Int64(IntMax)-1\
    \ {\n    return 0\n  }\n\n  // Calculate and return the n-th Fibonacci number.\n\
    \  let x: Int64 = 0\n  let y: Int64 = 1\n  \n  for i in 1 ..< n {\n    let term\
    \ = x + y\n    x = y\n    y = term\n  }\n  return y", "    if n <= 2 {\n     \
    \   return n\n    } else {\n        return fib(n - 1) + fib(n - 2)\n    }", " \
    \ // Create a temporary variable\n  var a = 0, b = 1, next\n  if n > 0 {\n   \
    \ next = a + b\n    a = b\n    b = next\n  }\n  return next", '  return _fib(Int(n))',
  "  var a = 1\n  var b = 1 \n  for i in 0..n {\n    let temp = a\n    a = b\n   \
    \ b = temp + a\n  }\n  return a", "    if n == 0 || n == 1 {\n        return n\n\
    \    }\n    return fib(n - 1) + fib(n - 2)", "    if n == 0 {\n        return\
    \ 0\n    }\n    \n    guard n > 0 else { return 1 }\n    \n    var a, b = 1 //\
    \ a = 1, b = 2\n    for i in 1..n {\n        (a, b) = (b, a + b)\n    }\n    \n\
    \    return b", '    return fib(n - 1) + fib(n - 2)', "    let cache = [1,1]\n\
    \    return cache[n]", "    if n <= 0 {\n        return n\n    }\n    return fib(n-1)\
    \ + fib(n-2)", '  return fibHelper(n, 1, 2)', '  return _fib(n)', '  return fib(n
    - 1) + fib(n - 2)', "\tif n < 2 {\n\t\treturn n\n\t}\n\treturn fib(n-1) + fib(n-2)",
  "    if n <= 2 { return n }\n    return fib(n - 1) + fib(n - 2)", "  var result:\
    \ Int = 0\n  var first: Int = 0\n  var second: Int = 0\n  for _ in 0...n {\n \
    \   first = second\n    second = first+second\n    result += second\n  }\n  return\
    \ result", "    switch n {\n    case 0: return 0\n    case 1: return 1\n    default:\
    \ return fib(n-1) + fib(n-2)\n    }", '    return (1..<n).reduce(0)', "  if n\
    \ <= 1 {\n    return n\n  } else {\n    return fib(n - 1) + fib(n - 2)\n  }",
  '  return fib(n, max: 0)', "    var fib1: Int = 0\n    var fib2: Int = 0\n    for\
    \ _ in 0 ..< n {\n        fib1 += fib2\n        fib2 = fib1\n        fib1 -= fib2\n\
    \    }\n    return fib1", "    func fibRecursion(_ a: Int,_ b: Int) -> Int {\n\
    \        guard a <= b else {\n            return b\n        }\n        return\
    \ fibRecursion(a + 1,b + b)\n    }\n    return fibRecursion(0,1)", "    // return\
    \ in last iteration\n    if n == 0 || n == 1 {\n        return 1\n    }\n\n  \
    \  return fib(n-1) + fib(n-2)", "\treturn _fibonacci(n).sum", "  var result =\
    \ 0\n  var prev = 0\n  for i in 0 ..< n {\n    result += prev\n    prev = result\
    \ - 1\n  }\n  return result", "    if n < 0 {\n        return 0\n    }\n\n   \
    \ return fib(n-2) + fib(n-1)", "\tswitch n {\n\tcase 0:\n\t\treturn 0\n\tcase\
    \ 1:\n\t\treturn 1\n\tdefault:\n\t\treturn fib(n-1) + fib(n-2)\n\t}", "\tswitch\
    \ n {\n\tcase 0: return 0\n\tcase 1: return 1\n\tcase 2: return 1\n\tdefault:\
    \ return fib(n-1) + fib(n-2)\n\t}", "    if n < 2 {\n        return 1\n    }\n\
    \    return fib(n - 2) + fib(n - 1)", "  if n < 2 {\n    return n\n  }\n  return\
    \ fib(n-1) + fib(n-2)", "  var f1: Int = 0\n  var f2: Int = 0\n  if n <= 0 {\n\
    \    return 0\n  }\n  f1 = f1\n  f2 = f2\n  for _ in 1..n {\n    f1, f2 = f2,\
    \ f1 + f2\n  }\n  return f2", "    var a : Int = 0\n    var b : Int = 0\n    \n\
    \    for _ in 0..<n {\n        (a, b) = (b, a+b)\n    }\n    \n    return b",
  "    if n <= 0 {\n        return 0\n    }\n\n    return fib(n-1) + fib(n-2)", " \
    \   func fib(head : Int) -> Int {\n        return head + fib(head - 1)\n    }\n\
    \n    if n == 0 || n == 1 {\n        return 1\n    }\n    return fib(n - 1)",
  "  if n < 2 {\n    return n\n  }\n  return fib(n-1) + fib(n-2)", "    func fib(_\
    \ i: Int) -> Int {\n        return fib(i+1) + fib(i-1)\n    }\n    return fib(n)\
    \ % 2147483647", "    let result = n <= 0 ? 0 : fib(n - 1) + fib(n - 2)\n    return\
    \ result", "\tif n <= 0 {\n\t\treturn 0\n\t}\n\treturn fib(n - 1) + fib(n - 2)",
  '  return fib(n - 1) + fib(n - 2)', "    if n < 1 {\n        return 0\n    }\n \
    \   \n    return fib(n-1) + fib(n-2)", "    // use tail recursion, saving some\
    \ stack space\n    func fibHelper(_ n: Int, _ result: inout Int) -> Int {\n  \
    \      guard n >= 0 else {\n            result = 0\n            return 1\n   \
    \     }\n\n        if n == 0 {\n            result = 0\n            return 1\n\
    \        }\n\n        fibHelper(n - 1, &result)\n        result\n    }\n\n   \
    \ return fibHelper(n, &0)", "  func fibonacci(index: Int) -> Int {\n    if index\
    \ > 0 {\n      return fibonacci(index - 1) + fibonacci(index - 2)\n    }\n   \
    \ return 0\n  }\n\n  return fibonacci(n)", "    if n <= 1 {\n        return n\n\
    \    }\n    return fib(n-1) + fib(n-2)", "    if n == 0 || n == 1 {\n        return\
    \ 1\n    }\n    return fib(n - 1) + fib(n - 2)", "    var next: Int\n    var next2:\
    \ Int\n    next = next2 = 1\n    for i in 1..n {\n        next = next2 + next\n\
    \        next2 = next\n    }\n    return next", "    let cache = [0, 1]\n    if\
    \ n >= 2 { cache[n] = fib(n-1) + fib(n-2) }\n    return cache[n]", "  var a =\
    \ 0\n  var b = 1\n  for _ in 0..<n {\n    let next = a + b\n    a = b\n    b =\
    \ next\n  }\n  return b", "    var a, b Int\n    \n    // first two terms are\
    \ 0\n    if n == 0 || n == 1 {\n        return n\n    }\n    \n    // otherwise\
    \ calculate fib(n-1) and fib(n-2)\n    a, b = b, a + b\n    if n < 0 {\n     \
    \   n += a\n        n -= b\n    }\n    \n    // return the result\n    return\
    \ n", "  var a = 1 // a is the base of Fibonacci sequence\n  var b = 1 // b is\
    \ the base of Fibonacci sequence\n  var i = 0 // i is the base of Fibonacci sequence\n\
    \  var tmp = 0 // tmp is temporary variable used to calculate Fibonacci sequence\n\
    \  \n  for i = 2; i <= n; i++) {\n    tmp = a + b\n    a = b\n    b = tmp\n  }\n\
    \n  return b", "    if n == 0 || n == 1 {\n        return n\n    }\n\n    return\
    \ fib(n-1) + fib(n-2)", '  return fibImpl(n - 1)', "  if n == 0 || n == 1 {\n\
    \    return n\n  }\n\n  return fib(n: n - 1) + fib(n: n - 2)", "    if n < 2 {\n\
    \        return 1\n    }\n    return fib(n-1) + fib(n-2)", "    var a: Int = 0\n\
    \    var b: Int = 0\n    var c: Int = 0\n    for _ in 0..<n {\n        c = a +\
    \ b\n        a = b\n        b = c\n    }\n    return b", '    return fibAux(n,
    0)', "  if n <= 1 {\n    return n\n  }\n\n  return fib(n - 1) + fib(n - 2)", " \
    \ // O(N), linear recursion.\n  var a = 1;\n  var b = 1;\n  for i := 0; i < n;\
    \ i++ {\n    a, b = b, a+b;\n  }\n  return a;", "  var result = 1\n  for number\
    \ in 1...n {\n    result = result + result\n  }\n  return result", "\tif n < 2\
    \ {\n\t\treturn n\n\t}\n\treturn fib(n-2) + fib(n-1)", "    switch n {\n    case\
    \ 0:\n        return 0\n    case 1:\n        return 1\n    case 2:\n        return\
    \ 2\n    }\n    var a = 0\n    var b = 1\n    for _ in 0..<n {\n        var c\
    \ = a + b\n        a = b\n        b = c\n    }\n    return b", "    if n <= 1\
    \ {\n        return 1\n    }\n    return fib(n-1) + fib(n-2)", "  // TODO\n  return\
    \ 0", "    if n < 2 {\n        return 1\n    }\n    return fib(n-2) + fib(n-1)",
  "    if n < 1 {\n        return 0\n    }\n\n    if n < 2 {\n        return 1\n \
    \   }\n\n    return fib(n - 1) + fib(n - 2)", "    if n <= 1 {\n        return\
    \ n\n    }\n    return fib(n-1) + fib(n-2)", '    return fibonacci(n - 2)', " \
    \   var fib = [0, 1]\n    for i in 2...n {\n        fib[i] = fib[i - 1] + fib[i\
    \ - 2]\n    }\n    return fib[n]", "  // Create a stack based buffer with a capacity\
    \ of n\n  var fibStack = Array<Int>(capacity: n)\n  fibStack.push(fibStack[0],\
    \ fibStack[1], 0)\n  var fibResult = 0\n  var fibStackSize = 0\n\n  // For each\
    \ number in fibonacci series\n  for _ in 0 ..< n {\n    // For each number in\
    \ the stack\n    for _ in 0 ..< fibStackSize {\n      // Add the number on top\
    \ of the stack to the result of the addition\n      fibResult = fibResult + fibStack[fibStackSize\
    \ - 1]\n      fibStack[fibStackSize] = fibStack[fibStackSize - 1]\n      fibStackSize\
    \ += 1\n    }\n  }\n\n  return fibResult", "    if n <= 1 {\n        return 1\n\
    \    }\n    return fib(n - 1) + fib(n - 2)", "    if n < 2 {\n        return 1\n\
    \    }\n\n    return fib(n-1) + fib(n-2)", "  if n < 2 {\n    return n\n  }\n\
    \  return fib(n-2) + fib(n-1)", "  var a = b = 0\n  return func next() -> Int\
    \ {\n    defer { a, b = b, a+b }\n    return n == 0 ? a : next(n - 1)\n  }"]
stop_tokens:
- "\n}"
