language: swift
name: HumanEval_125_split_words
results:
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: .whitespaces)\n    if words.isEmpty\
    \ {\n        return .failure(25)\n    } else {\n        let comma = words.firstIndex(where:\
    \ { $0 == \",\" })\n        if comma >= 0 {\n            return .success(words[0..<comma])\n\
    \        } else {\n            let lowercases = words.filter({ $0.range(of: CharacterSet.lowercaseLetters)\
    \ != nil })\n            let odd_order = lowercases.count % 2 == 0\n         \
    \   if odd_order {\n                return .success(lowercases[lowercases.startIndex...lowercases.startIndex.advanced(by:\
    \ 1)])\n            } else {\n                return .success(lowercases[lowercases.startIndex...lowercases.startIndex.advanced(by:\
    \ -1)])\n            }\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpo1yivuos.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: .whitespaces)\n  \
    \              ~~~ ^~~~~~~~~~\n/tmp/tmpo1yivuos.swift:15:46: error: cannot infer\
    \ contextual base in reference to member 'whitespaces'\n    let words = txt.components(separatedBy:\
    \ .whitespaces)\n                                            ~^~~~~~~~~~~\n/tmp/tmpo1yivuos.swift:23:58:\
    \ error: cannot find 'CharacterSet' in scope\n            let lowercases = words.filter({\
    \ $0.range(of: CharacterSet.lowercaseLetters) != nil })\n                    \
    \                                     ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return try Result($0.split(separator: \" \").map { $0.trimmingCharacters(in:\
    \ .whitespaces)})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptonr9ayc.swift:15:23: error: anonymous closure argument not contained\
    \ in a closure\n    return try Result($0.split(separator: \" \").map { $0.trimmingCharacters(in:\
    \ .whitespaces)})\n                      ^\n/tmp/tmptonr9ayc.swift:15:16: error:\
    \ cannot convert return expression of type 'Result<[String], any Error>' to return\
    \ type 'Result<[String], Int>'\n    return try Result($0.split(separator: \" \"\
    ).map { $0.trimmingCharacters(in: .whitespaces)})\n               ^\n/tmp/tmptonr9ayc.swift:15:16:\
    \ note: arguments to generic parameter 'Failure' ('any Error' and 'Int') are expected\
    \ to be equal\n    return try Result($0.split(separator: \" \").map { $0.trimmingCharacters(in:\
    \ .whitespaces)})\n               ^\n/tmp/tmptonr9ayc.swift:15:23: error: missing\
    \ argument label 'catching:' in call\n    return try Result($0.split(separator:\
    \ \" \").map { $0.trimmingCharacters(in: .whitespaces)})\n                   \
    \   ^\n                      catching: \n/tmp/tmptonr9ayc.swift:15:81: error:\
    \ cannot infer contextual base in reference to member 'whitespaces'\n    return\
    \ try Result($0.split(separator: \" \").map { $0.trimmingCharacters(in: .whitespaces)})\n\
    \                                                                            \
    \   ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let split = txt.split(separator: \" \", maxSplits: 2) else\
    \ {\n        return Result.failure(3)\n    }\n    return Result.success(split.map\
    \ { String($0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnu8e_l2l.swift:15:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let split = txt.split(separator: \" \", maxSplits: 2) else {\n    \
    \      ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: .whitespacesAndNewlines)\n\
    \    guard !words.isEmpty else { return .failure(1) }\n    \n    let split = words.map\
    \ {\n        guard let word = $0 else {\n            return .failure(2)\n    \
    \    }\n        guard let chars = word.split() else { return .failure(3) }\n \
    \       return chars\n    }\n    \n    let evenLettersCount = split.map { chars\
    \ -> Int in\n        guard let count = chars.reduce(0) { $0 + 1 } else { return\
    \ 0 }\n        if count % 2 == 0 {\n            return count\n        } else {\n\
    \            return count/2\n        }\n    }.reduce(0, +)\n    \n    guard evenLettersCount\
    \ % 2 == 0 else { return .failure(4) }\n    \n    let upperCaseLettersCount =\
    \ split.map { chars -> Int in\n        guard let count = chars.reduce(0) { $0\
    \ + 1 } else { return 0 }\n        if count % 2 == 1 {\n            return count\n\
    \        } else {\n            return count/2\n        }\n    }.reduce(0, +)\n\
    \    \n    return .success([split.joined(separator: \", \"), evenLettersCount,\
    \ upperCaseLettersCount])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz5n9t1qr.swift:27:43: error: expected 'else' after 'guard' condition\n\
    \        guard let count = chars.reduce(0) { $0 + 1 } else { return 0 }\n    \
    \                                      ^\n                                   \
    \       else \n/tmp/tmpz5n9t1qr.swift:27:45: error: anonymous closure arguments\
    \ cannot be used inside a closure that has explicit arguments; did you mean 'chars'?\n\
    \        guard let count = chars.reduce(0) { $0 + 1 } else { return 0 }\n    \
    \                                        ^~\n                                \
    \            chars\n/tmp/tmpz5n9t1qr.swift:27:53: error: consecutive statements\
    \ on a line must be separated by ';'\n        guard let count = chars.reduce(0)\
    \ { $0 + 1 } else { return 0 }\n                                             \
    \       ^\n                                                    ;\n/tmp/tmpz5n9t1qr.swift:27:54:\
    \ error: expected expression\n        guard let count = chars.reduce(0) { $0 +\
    \ 1 } else { return 0 }\n                                                    \
    \ ^\n/tmp/tmpz5n9t1qr.swift:38:43: error: expected 'else' after 'guard' condition\n\
    \        guard let count = chars.reduce(0) { $0 + 1 } else { return 0 }\n    \
    \                                      ^\n                                   \
    \       else \n/tmp/tmpz5n9t1qr.swift:38:45: error: anonymous closure arguments\
    \ cannot be used inside a closure that has explicit arguments; did you mean 'chars'?\n\
    \        guard let count = chars.reduce(0) { $0 + 1 } else { return 0 }\n    \
    \                                        ^~\n                                \
    \            chars\n/tmp/tmpz5n9t1qr.swift:38:53: error: consecutive statements\
    \ on a line must be separated by ';'\n        guard let count = chars.reduce(0)\
    \ { $0 + 1 } else { return 0 }\n                                             \
    \       ^\n                                                    ;\n/tmp/tmpz5n9t1qr.swift:38:54:\
    \ error: expected expression\n        guard let count = chars.reduce(0) { $0 +\
    \ 1 } else { return 0 }\n                                                    \
    \ ^\n/tmp/tmpz5n9t1qr.swift"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split_words(txt: txt, delimiters: CharacterSet.whitespacesAndNewlines)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb_g156uq.swift:15:46: error: cannot find 'CharacterSet' in scope\n\
    \    return split_words(txt: txt, delimiters: CharacterSet.whitespacesAndNewlines)\n\
    \                                             ^~~~~~~~~~~~\n/tmp/tmpb_g156uq.swift:15:59:\
    \ error: extra argument 'delimiters' in call\n    return split_words(txt: txt,\
    \ delimiters: CharacterSet.whitespacesAndNewlines)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words: [String] = txt.components(separatedBy: .whitespaces)\n\
    \    if words.count == 0 {\n        return .failure(0) // If there is no whitespaces\
    \ split on commas\n    }\n    \n    if words.count % 2 == 1 {\n        return\
    \ .failure(words.count + 1) // If there are an odd number of words,\n        \
    \                                // return the number of lower-case letters\n\
    \    }\n    \n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmjpzpvbm.swift:15:31: error: value of type 'String' has no member\
    \ 'components'\n    let words: [String] = txt.components(separatedBy: .whitespaces)\n\
    \                          ~~~ ^~~~~~~~~~\n/tmp/tmpmjpzpvbm.swift:15:56: error:\
    \ cannot infer contextual base in reference to member 'whitespaces'\n    let words:\
    \ [String] = txt.components(separatedBy: .whitespaces)\n                     \
    \                                 ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = [txt]\n    let space = \" \".into()\n    let comma =\
    \ \",\".into()\n    \n    if txt.contains(space) {\n        words.append(txt.split(space))\n\
    \    }\n    if txt.contains(comma) {\n        words.append(txt.split(comma))\n\
    \    }\n    if let number = Int(txt.lowercaseString) {\n        let results: [String]\
    \ = []\n        for word in words {\n            if let _ = word?.lowercaseString.contains(String(number\
    \ % 26)) {\n                results.append(word)\n            }\n        }\n \
    \       return .success(results)\n    }\n    return .failure(Int(txt.lowercaseString)\
    \ % 26)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpx9f53r7e.swift:16:21: error: value of type 'String' has no member\
    \ 'into'\n    let space = \" \".into()\n                ~~~ ^~~~\n/tmp/tmpx9f53r7e.swift:17:21:\
    \ error: value of type 'String' has no member 'into'\n    let comma = \",\".into()\n\
    \                ~~~ ^~~~\n/tmp/tmpx9f53r7e.swift:20:15: error: no exact matches\
    \ in call to instance method 'append'\n        words.append(txt.split(space))\n\
    \              ^\n/tmp/tmpx9f53r7e.swift:20:15: note: found candidate with type\
    \ '(__owned String) -> ()'\n        words.append(txt.split(space))\n         \
    \     ^\n/tmp/tmpx9f53r7e.swift:20:15: note: found candidate with type '(__owned\
    \ [ArraySlice<String.Element>]) -> ()' (aka '(__owned Array<ArraySlice<Character>>)\
    \ -> ()')\n        words.append(txt.split(space))\n              ^\n/tmp/tmpx9f53r7e.swift:20:26:\
    \ error: no exact matches in call to instance method 'split'\n        words.append(txt.split(space))\n\
    \                         ^\n/tmp/tmpx9f53r7e.swift:20:26: note: found candidate\
    \ with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]' (aka\
    \ '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n        words.append(txt.split(space))\n\
    \                         ^\n/tmp/tmpx9f53r7e.swift:20:26: note: found candidate\
    \ with type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character,\
    \ Int, Bool) -> Array<Substring>')\n        words.append(txt.split(space))\n \
    \                        ^\n/tmp/tmpx9f53r7e.swift:23:15: error: no exact matches\
    \ in call to instance method 'append'\n        words.append(txt.split(comma))\n\
    \              ^\n/tmp/tmpx9f53r7e.swift:23:15: note: found candidate with type\
    \ '(__owned String) -> ()'\n        words.append(txt.split(comma))\n         \
    \     ^\n/tmp/tmpx9f53r7e.swift:23:15: note: found candidate with type '(__owned\
    \ [ArraySlice<String.Element>]) -> ()' (aka '(__owned Array<ArraySlice<Character>>)\
    \ -> ()')\n        words.append(txt.split(comma))\n              ^\n/tmp/tmpx9f53r7e.swift:23:26:\
    \ error: no exact matches in call to instance method 'split'\n        words.append(txt.split(comma))\n\
    \     "
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let lowercaseStr = txt.lowercased()\n    var splitWords = [String]()\n\
    \    \n    // remove any double spaces and newlines \n    txt = txt.trimmingCharacters(in:\
    \ CharacterSet.whitespaces)\n    \n    // remove any commas \n    txt = txt.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    \n    // if there are no words return\
    \ this string\n    if txt.isEmpty {\n        return .success(splitWords)\n   \
    \ }\n    \n    // loop through each letter and add letters to splitWords\n   \
    \ for char in lowercaseStr {\n        let index = getLowercaseIndex(char, alphabet:\
    \ lowercaseStr)\n        let word = lowercaseStr[index..<index+1]\n        splitWords.append(word)\n\
    \    }\n    \n    // return success\n    return .success(splitWords)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpczsnlazg.swift:19:38: error: cannot find 'CharacterSet' in scope\n\
    \    txt = txt.trimmingCharacters(in: CharacterSet.whitespaces)\n            \
    \                         ^~~~~~~~~~~~\n/tmp/tmpczsnlazg.swift:19:5: error: cannot\
    \ assign to value: 'txt' is a 'let' constant\n    txt = txt.trimmingCharacters(in:\
    \ CharacterSet.whitespaces)\n    ^~~\n/tmp/tmpczsnlazg.swift:19:15: error: value\
    \ of type 'String' has no member 'trimmingCharacters'\n    txt = txt.trimmingCharacters(in:\
    \ CharacterSet.whitespaces)\n          ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpczsnlazg.swift:22:38:\
    \ error: cannot find 'CharacterSet' in scope\n    txt = txt.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n                                     ^~~~~~~~~~~~\n\
    /tmp/tmpczsnlazg.swift:22:5: error: cannot assign to value: 'txt' is a 'let' constant\n\
    \    txt = txt.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n \
    \   ^~~\n/tmp/tmpczsnlazg.swift:22:15: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    txt = txt.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \          ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpczsnlazg.swift:31:21: error: cannot\
    \ find 'getLowercaseIndex' in scope\n        let index = getLowercaseIndex(char,\
    \ alphabet: lowercaseStr)\n                    ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    \n    let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    guard let letters = txt.enumerated() else { return .failure(3) }\n    \n\
    \    var result: [String] = []\n    \n    for (_, letter) in letters {\n     \
    \   guard let char = letter.value else { return .failure(2) }\n        let char\
    \ = char.lowercased()\n        \n        if let index = result.index(of: char)\
    \ {\n            \n            if let next = result[index + 1] {\n           \
    \     \n                if next == \",\" || next == \"\" {\n                 \
    \   result.remove(at: index)\n                } else {\n                    return\
    \ .failure(3)\n                }\n            } else {\n                return\
    \ .success(result)\n            }\n            \n        } else {\n          \
    \  result.append(char)\n        }\n    }\n    \n    if result.isEmpty {\n    \
    \    return .success(result)\n    }\n    \n    let count = result.count\n    \n\
    \    if count % 2 != 0 {\n        return .success(result)\n    }\n    \n    for\
    \ i in 0..<count {\n        if result[i] == \",\" || result[i] == \"\" {\n   \
    \         result.remove(at: i)\n        }\n    }\n    \n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3gpuc20h.swift:17:19: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \              ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp3gpuc20h.swift:17:43: error: cannot\
    \ infer contextual base in reference to member 'whitespacesAndNewlines'\n    let\
    \ txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n                \
    \                         ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3gpuc20h.swift:22:5:\
    \ error: failed to produce diagnostic for expression; please submit a bug report\
    \ (https://swift.org/contributing/#reporting-bugs) and include the project\n \
    \   for (_, letter) in letters {\n    ^\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.isEmpty {\
    \ return .failure(0) }\n    var result: [String] = []\n    \n    for word in words\
    \ {\n        if word.count > 1 {\n            if word.range(of: \",\", options:\
    \ .caseInsensitive).location == NSNotFound {\n                if let count = word.lowercaseString.characters.count\
    \ {\n                    result.appendContentsOf(word.lowercaseString)\n     \
    \               return .success(result)\n                }\n            } else\
    \ {\n                result.appendContentsOf(word)\n            }\n        }\n\
    \    }\n    \n    if let count = result.characters.count {\n        let startIndex\
    \ = txt.range(of: \"[a-z]\", options: .caseInsensitive)?.lowerBound\n        let\
    \ endIndex = txt.range(of: \"[a-z]\", options: .caseInsensitive)?.upperBound\n\
    \        let evenOrOdd = count(from: startIndex!, to: endIndex!, using: .ascii)\n\
    \        if evenOrOdd % 2 == 0 {\n            let start = startIndex?.upperBound\n\
    \            let end = endIndex?.lowerBound\n            return .success(result.prefix(start!).dropFirst().suffix(end!))\n\
    \        } else {\n            return .success(result)\n        }\n    } else\
    \ {\n        return .failure(0)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgb1spstw.swift:21:75: error: cannot find 'NSNotFound' in scope\n\
    \            if word.range(of: \",\", options: .caseInsensitive).location == NSNotFound\
    \ {\n                                                                        \
    \  ^~~~~~~~~~\n/tmp/tmpgb1spstw.swift:21:21: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'range'\n            if word.range(of: \",\"\
    , options: .caseInsensitive).location == NSNotFound {\n               ~~~~ ^~~~~\n\
    /tmp/tmpgb1spstw.swift:21:46: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n            if word.range(of: \",\", options: .caseInsensitive).location\
    \ == NSNotFound {\n                                            ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpgb1spstw.swift:22:37: error: value of type 'String.SubSequence' (aka 'Substring')\
    \ has no member 'lowercaseString'\n                if let count = word.lowercaseString.characters.count\
    \ {\n                               ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpgb1spstw.swift:23:28:\
    \ error: value of type '[String]' has no member 'appendContentsOf'\n         \
    \           result.appendContentsOf(word.lowercaseString)\n                  \
    \  ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpgb1spstw.swift:23:50: error: value of type\
    \ 'String.SubSequence' (aka 'Substring') has no member 'lowercaseString'\n   \
    \                 result.appendContentsOf(word.lowercaseString)\n            \
    \                                ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpgb1spstw.swift:27:24:\
    \ error: value of type '[String]' has no member 'appendContentsOf'\n         \
    \       result.appendContentsOf(word)\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpgb1spstw.swift:32:27: error: value of type '[String]' has no member 'characters'\n\
    \    if let count = result.characters.count {\n                   ~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpgb1spstw.swift:33:77: error: type of expression is ambiguous without more\
    \ context\n        let startIndex = txt.range(of: \"[a-z]\", options: .caseInsensitive)?.lowerBound\n\
    \                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/t"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    // Split into words, drop commas\n    let words = txt.components(separatedBy:\
    \ \",\")\n    // Filter out any characters that are not letters or whitespace\n\
    \    let onlyLettersOrWhitespace = words.filter { \n        $0.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil || \n        $0.rangeOfCharacter(from: CharacterSet.whitespaces)\
    \ == nil\n    }\n    // Find number of letters that should be odd in this alphabet\n\
    \    var totalOddOrderLetters = 0\n    for i in 0..<onlyLettersOrWhitespace.count\
    \ {\n        let odd = onlyLettersOrWhitespace[i] % 2\n        if odd == 0 {\n\
    \            totalOddOrderLetters += 1\n        }\n    }\n    // If the count\
    \ of letters should be odd in this alphabet is greater than the number of words\
    \ in the text then\n    // we have no odd letters and should return an error\n\
    \    if totalOddOrderLetters > words.count {\n        return Result.failure(totalOddOrderLetters)\n\
    \    }\n    // If there is a space in the text, split on spaces.\n    if txt.contains(\"\
    ,\") {\n        let words = txt.components(separatedBy: \" \")\n        return\
    \ Result.success(words)\n    }\n    // If there are no spaces in the text, split\
    \ the text on whitespace\n    let words = txt.components(separatedBy: CharacterSet.whitespaces)\n\
    \    return Result.success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpuhnqxk2v.swift:16:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \",\")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpuhnqxk2v.swift:19:35: error: cannot find 'CharacterSet'\
    \ in scope\n        $0.rangeOfCharacter(from: CharacterSet.letters) == nil ||\
    \ \n                                  ^~~~~~~~~~~~\n/tmp/tmpuhnqxk2v.swift:20:35:\
    \ error: cannot find 'CharacterSet' in scope\n        $0.rangeOfCharacter(from:\
    \ CharacterSet.whitespaces) == nil\n                                  ^~~~~~~~~~~~\n\
    /tmp/tmpuhnqxk2v.swift:37:25: error: value of type 'String' has no member 'components'\n\
    \        let words = txt.components(separatedBy: \" \")\n                    ~~~\
    \ ^~~~~~~~~~\n/tmp/tmpuhnqxk2v.swift:41:45: error: cannot find 'CharacterSet'\
    \ in scope\n    let words = txt.components(separatedBy: CharacterSet.whitespaces)\n\
    \                                            ^~~~~~~~~~~~\n/tmp/tmpuhnqxk2v.swift:41:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ CharacterSet.whitespaces)\n                ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let letters = \"abcdefghijklmnopqrstuvwxyz\".characters\n    var\
    \ lowercase_letters = 0\n    var words: [String] = []\n    var split_points: [Int]\
    \ = []\n    for i in 0..<letters.count {\n        let letter = letters[i]\n  \
    \      let split_point = letters.distance(from: i, to: letters.endIndex)\n   \
    \     if txt.rangeOfCharacter(from: letter) != nil {\n            words.append(txt.substringWithRange(NSRange(location:\
    \ i, length: split_point)))\n            split_points.append(split_point)\n  \
    \          lowercase_letters += 1\n        }\n    }\n    if lowercase_letters\
    \ % 2 != 0 {\n        return .failure(lowercase_letters)\n    }\n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpakohmmtl.swift:15:48: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = \"abcdefghijklmnopqrstuvwxyz\".characters\n\
    \                                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpakohmmtl.swift:20:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let letter = letters[i]\n                     ^~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpakohmmtl.swift:21:50:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \        let split_point = letters.distance(from: i, to: letters.endIndex)\n \
    \                                                ^\n/tmp/tmpakohmmtl.swift:22:16:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n        if txt.rangeOfCharacter(from:\
    \ letter) != nil {\n           ~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpakohmmtl.swift:23:49:\
    \ error: cannot find 'NSRange' in scope\n            words.append(txt.substringWithRange(NSRange(location:\
    \ i, length: split_point)))\n                                                ^~~~~~~\n\
    /tmp/tmpakohmmtl.swift:23:30: error: value of type 'String' has no member 'substringWithRange'\n\
    \            words.append(txt.substringWithRange(NSRange(location: i, length:\
    \ split_point)))\n                         ~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    // check each character of string for whitespace\n    let words:\
    \ String\n    if let firstChar = txt.first() {\n        let rest = txt.dropFirst()\n\
    \        if let last = rest.last {\n            words = firstChar + rest\n   \
    \     } else {\n            words = firstChar\n        }\n    } else {\n     \
    \   words = \"\"\n    }\n\n    // check each character for comma\n    let words2:\
    \ [String]\n    if let first = words.first() {\n        let rest = words.dropFirst()\n\
    \        if let last = rest.last {\n            words2 = first + rest\n      \
    \  } else {\n            words2 = first\n        }\n    } else {\n        words2\
    \ = []\n    }\n\n    // return the number of characters with odd order in the\
    \ alphabet\n    let odd = count(words2)\n    if odd % 2 == 0 {\n        Ok(words2)\n\
    \    } else {\n        Err(odd)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvjl5_8gf.swift:17:28: error: cannot call value of non-function\
    \ type 'String.Element?' (aka 'Optional<Character>')\n    if let firstChar = txt.first()\
    \ {\n                           ^    ~~\n                                \n/tmp/tmpvjl5_8gf.swift:30:26:\
    \ error: cannot call value of non-function type 'String.Element?' (aka 'Optional<Character>')\n\
    \    if let first = words.first() {\n                         ^    ~~\n      \
    \                        \n/tmp/tmpvjl5_8gf.swift:33:28: error: binary operator\
    \ '+' cannot be applied to operands of type '[String]' and 'String.SubSequence'\
    \ (aka 'Substring')\n            words2 = first + rest\n                     ~~~~~\
    \ ^ ~~~~\n/tmp/tmpvjl5_8gf.swift:42:15: error: cannot find 'count' in scope\n\
    \    let odd = count(words2)\n              ^~~~~\n/tmp/tmpvjl5_8gf.swift:44:9:\
    \ error: cannot find 'Ok' in scope\n        Ok(words2)\n        ^~\n/tmp/tmpvjl5_8gf.swift:46:9:\
    \ error: cannot find 'Err' in scope\n        Err(odd)\n        ^~~\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let re = try! NSRegularExpression(pattern: \"\\\\s+|,\")\n    guard\
    \ let m = re.firstMatchInString(txt, options: .WithoutAnchoringBounds) else {\n\
    \        return Result.failure(3)\n    }\n\n    let start = txt.index(m.range,\
    \ in: txt)\n    let end = txt.index(m.range, in: txt, offsetBy: re.numberOfMatches)\n\
    \n    var words = [String]()\n    \n    if start < 0 {\n        return Result.failure(3)\n\
    \    }\n\n    words.append(txt[start..<end])\n\n    let start = end.advanced(by:\
    \ re.numberOfMatches)\n    \n    while let m = re.firstMatchInString(txt[start..<end],\
    \ options: .WithoutAnchoringBounds) {\n        if m.range.length > 0 {\n     \
    \       words.append(txt[start..<m.range])\n        }\n\n        start = m.range.advanced(by:\
    \ re.numberOfMatches)\n    }\n    \n    return Result.success(words.map { $0.trimmingCharacters(in:\
    \ \" \\t\\n\\r\") })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0p58uvsp.swift:15:19: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let re = try! NSRegularExpression(pattern: \"\\\\s+|,\")\n   \
    \               ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp0p58uvsp.swift:16:56: error: cannot\
    \ infer contextual base in reference to member 'WithoutAnchoringBounds'\n    guard\
    \ let m = re.firstMatchInString(txt, options: .WithoutAnchoringBounds) else {\n\
    \                                                      ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0p58uvsp.swift:20:21: error: no exact matches in call to instance method\
    \ 'index'\n    let start = txt.index(m.range, in: txt)\n                    ^\n\
    /tmp/tmp0p58uvsp.swift:20:21: note: found candidate with type '(String.Index)\
    \ -> String.Index'\n    let start = txt.index(m.range, in: txt)\n            \
    \        ^\n/tmp/tmp0p58uvsp.swift:20:21: note: found candidate with type '(String.Index)\
    \ -> String.Index'\n    let start = txt.index(m.range, in: txt)\n            \
    \        ^\n/tmp/tmp0p58uvsp.swift:20:21: note: found candidate with type '(String.Index,\
    \ Int) -> String.Index'\n    let start = txt.index(m.range, in: txt)\n       \
    \             ^\n/tmp/tmp0p58uvsp.swift:20:21: note: found candidate with type\
    \ '((String.Element) throws -> Bool) throws -> String.Index?' (aka '((Character)\
    \ throws -> Bool) throws -> Optional<String.Index>')\n    let start = txt.index(m.range,\
    \ in: txt)\n                    ^\n/tmp/tmp0p58uvsp.swift:20:21: note: found candidate\
    \ with type '(String.Element) -> String.Index?' (aka '(Character) -> Optional<String.Index>')\n\
    \    let start = txt.index(m.range, in: txt)\n                    ^\n/tmp/tmp0p58uvsp.swift:21:38:\
    \ error: extra argument 'in' in call\n    let end = txt.index(m.range, in: txt,\
    \ offsetBy: re.numberOfMatches)\n                       ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0p58uvsp.swift:33:69: error: cannot infer contextual base in reference\
    \ to member 'WithoutAnchoringBounds'\n    while let m = re.firstMatchInString(txt[start..<end],\
    \ options: .WithoutAnchoringBounds) {\n                                      \
    \                             "
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return withUnsafeBytes(of: txt) { data in\n        let byteCount\
    \ = data.count\n        let words = UnsafeBufferPointer(start: data.baseAddress,\
    \ count: byteCount)\n        let splitWords = words.withUnsafeBytes { words in\n\
    \            let count = words.count\n            if count > 0 {\n           \
    \     var strs = [String]()\n                var chars = CharacterSet.lowercaseLetters\n\
    \                let wordRanges = stride(from: words.startIndex, to: words.endIndex,\
    \ by: 1).map {\n                    String.UnicodeScalarView(words.baseAddress,\
    \ offset: $0).withUnsafeBufferPointer { charsView in\n                       \
    \ guard let chars = charsView.baseAddress\n                        else {\n  \
    \                          return nil\n                        }\n           \
    \             chars = Character(chars)\n                        return String(unicodeScalars:\
    \ chars, count: chars.count)\n                    }\n                }\n     \
    \           let wordRangeCount = wordRanges.count\n                for wordRange\
    \ in wordRanges {\n                    let wordRangeChars = wordRange.characters.reduce(\"\
    \") { (result, c) in\n                        result += String(unicodeScalars:\
    \ c.unicodeScalars, count: c.unicodeScalars.count)\n                        if\
    \ c.isSeparator {\n                            return result\n               \
    \         }\n                        else {\n                            return\
    \ result + \",\"\n                        }\n                    }\n         \
    \           if !wordRangeChars.isEmpty, let first = wordRange[0], let last = wordRange.last,\
    \ count > wordRangeCount {\n                        let count = count - wordRangeCount\n\
    \                        if count == 0 {\n                            strs.append(first)\n\
    \                            strs.append(last)\n                        }\n  \
    \                      else {\n                            strs.append(first)\n\
    \                            strs.append(last)\n                            strs.append(String(repeating:\
    \ \"x\", count: count))\n                        }\n                    }\n  \
    \              }\n                if strs.count > 1 {\n                    return\
    \ .success(strs)\n                }\n                else {\n                \
    \    return .failure(count)\n                }\n            }\n            else\
    \ {\n                return .success([])\n            }\n        }\n        return\
    \ .success(splitWords)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpsvry2vt4.swift:22:29: error: cannot find 'CharacterSet' in scope\n\
    \                var chars = CharacterSet.lowercaseLetters\n                 \
    \           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.unicodeScalars\n        .reduce(into: [String]())\
    \ { (result, u) in\n            if let lastChar = u.removeLast() {\n         \
    \       result.append(String(lastChar))\n            }\n            if !result.isEmpty\
    \ {\n                result.append(\" \")\n            }\n            result.append(String(u))\n\
    \        }\n    if words.isEmpty {\n        return .failure(3)\n    }\n    return\
    \ .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2ts16e62.swift:17:33: error: value of type 'Unicode.Scalar' has\
    \ no member 'removeLast'\n            if let lastChar = u.removeLast() {\n   \
    \                           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return Result(string: txt, success: textComponents(txt).split(separator:\
    \ \" \", omittingEmptySubstrings: true), failure: 3)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmps6kr1o81.swift:15:41: error: cannot find 'textComponents' in scope\n\
    \    return Result(string: txt, success: textComponents(txt).split(separator:\
    \ \" \", omittingEmptySubstrings: true), failure: 3)\n                       \
    \                 ^~~~~~~~~~~~~~\n/tmp/tmps6kr1o81.swift:15:18: error: extra arguments\
    \ at positions #1, #2, #3 in call\n    return Result(string: txt, success: textComponents(txt).split(separator:\
    \ \" \", omittingEmptySubstrings: true), failure: 3)\n                 ^\nSwift.Result:2:12:\
    \ note: 'init(catching:)' declared here\n    public init(catching body: () throws\
    \ -> Success)\n           ^\n/tmp/tmps6kr1o81.swift:15:19: error: missing argument\
    \ for parameter 'catching' in call\n    return Result(string: txt, success: textComponents(txt).split(separator:\
    \ \" \", omittingEmptySubstrings: true), failure: 3)\n                  ^\n  \
    \                catching: <#() throws -> [String]#>, \nSwift.Result:2:12: note:\
    \ 'init(catching:)' declared here\n    public init(catching body: () throws ->\
    \ Success)\n           ^\n/tmp/tmps6kr1o81.swift:15:12: error: cannot convert\
    \ return expression of type 'Result<[String], any Error>' to return type 'Result<[String],\
    \ Int>'\n    return Result(string: txt, success: textComponents(txt).split(separator:\
    \ \" \", omittingEmptySubstrings: true), failure: 3)\n           ^\n/tmp/tmps6kr1o81.swift:15:12:\
    \ note: arguments to generic parameter 'Failure' ('any Error' and 'Int') are expected\
    \ to be equal\n    return Result(string: txt, success: textComponents(txt).split(separator:\
    \ \" \", omittingEmptySubstrings: true), failure: 3)\n           ^\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    // check for null and non-null input\n    if txt.isEmpty {\n\
    \        return .failure(txt)\n    }\n    \n    // lowercase letters only\n  \
    \  var letters: [Character] = []\n    for i in txt.lowercased().unicodeScalars\
    \ {\n        if !i.isControl {\n            letters.append(i)\n        }\n   \
    \ }\n    \n    // filter out non-letters (including space)\n    let filtered =\
    \ letters.filter({ !Character.isLetter(_) })\n    \n    // check for commas in\
    \ the text\n    if filtered.contains(\",\") {\n        let delimiters = filtered\n\
    \            .components(separatedBy: \",\")\n            .filter({\n        \
    \        !$0.isControl && $0.isLetter && !$0.isWhiteSpace && !$0.isSeparator\n\
    \            })\n            .map({\n                Character($0)!\n        \
    \    })\n        return .success(delimiters)\n    }\n    \n    // check for spaces\n\
    \    if filtered.contains(\"  \") {\n        let delimiters = filtered\n     \
    \       .components(separatedBy: \" \")\n            .filter({\n             \
    \   !$0.isControl && $0.isLetter && !$0.isWhiteSpace && !$0.isSeparator\n    \
    \        })\n            .map({\n                Character($0)!\n            })\n\
    \        return .success(delimiters)\n    }\n    \n    // if there are no spaces\
    \ and no commas, split the letters\n    if filtered.count == 0 {\n        let\
    \ delimiters = filtered\n            .components(separatedBy: \",\")\n       \
    \     .filter({\n                !$0.isControl && $0.isLetter && !$0.isWhiteSpace\
    \ && !$0.isSeparator\n            })\n            .map({\n                Character($0)!\n\
    \            })\n        return .success(delimiters)\n    }\n    \n    // otherwise\
    \ return number of letters\n    return .success(filtered.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptu0ihbab.swift:18:25: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        return .failure(txt)\n            \
    \            ^\n/tmp/tmptu0ihbab.swift:24:15: error: value of type 'Unicode.Scalar'\
    \ has no member 'isControl'\n        if !i.isControl {\n            ~ ^~~~~~~~~\n\
    /tmp/tmptu0ihbab.swift:25:21: error: no exact matches in call to instance method\
    \ 'append'\n            letters.append(i)\n                    ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'Character' for parameter #1 (got 'Unicode.Scalar')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmptu0ihbab.swift:25:21: note: found\
    \ candidate with type '(__owned Unicode.Scalar) -> ()'\n            letters.append(i)\n\
    \                    ^\n/tmp/tmptu0ihbab.swift:30:57: error: '_' can only appear\
    \ in a pattern or on the left side of an assignment\n    let filtered = letters.filter({\
    \ !Character.isLetter(_) })\n                                                \
    \        ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \    if words.count == 1 {\n        return .success(words)\n    } else if words.count\
    \ == 2 {\n        return .success(Array(words.prefix(1).appending(words.last!)))\n\
    \    } else {\n        return .failure(3)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpn740uw72.swift:15:45: error: cannot find 'CharacterSet' in scope\n\
    \    let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \                                            ^~~~~~~~~~~~\n/tmp/tmpn740uw72.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ CharacterSet.whitespacesAndNewlines)\n                ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if let txt = txt {\n        let result = txt.components(separatedBy:\
    \ \" \")\n            .flatMap { $0.components(separatedBy: \",\") }\n       \
    \     .map { $0.trimmingCharacters(in: .whitespaces)}\n            .filter { !$0.isEmpty\
    \ }\n            .map { $0.lowercased() }\n            .sorted()\n           \
    \ .filter { $0.isNotEmpty}\n            .map { String($0) }\n            .count\n\
    \            .advanced(by: 1)\n            .map { Int($0) }\n        return result.map(Result.success)\n\
    \    }\n    return Result.failure(Int(3))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9aclk_4s.swift:16:22: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        let result = txt.components(separatedBy: \" \")\n \
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9aclk_4s.swift:27:27:\
    \ error: generic parameter 'Success' could not be inferred\n        return result.map(Result.success)\n\
    \                          ^\n/tmp/tmp9aclk_4s.swift:27:27: error: generic parameter\
    \ 'Failure' could not be inferred\n        return result.map(Result.success)\n\
    \                          ^\n/tmp/tmp9aclk_4s.swift:27:27: note: explicitly specify\
    \ the generic arguments to fix this issue\n        return result.map(Result.success)\n\
    \                          ^\n                                <Any, <#Failure:\
    \ Error#>>\n/tmp/tmp9aclk_4s.swift:15:8: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    if let txt = txt {\n       ^    \
    \     ~~~\n"
  stdout: ''
  timestamp: 1660054564
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    // Split on whitespace.\n    let splitOnWhitespaceRegex = try! NSRegularExpression(pattern:\
    \ \"\\\\s+\")\n    \n    // Split on commas if no commas exist.\n    let splitOnCommaRegex\
    \ = try! NSRegularExpression(pattern: \",\")\n    \n    // Count lower-case letters\
    \ with odd order.\n    let countOrderRegex = try! NSRegularExpression(pattern:\
    \ \"[^abc]*a[bc]+[^abc]*b[ac]+[^abc]*c[ad]+[^abc]*d[be]+[^abc]*e[bf]+[^abc]*f[ag]+[^abc]*h[ai]+[^abc]*i[j]+[^abc]*k[l]+[^abc]*m[n]+[^abc]*o[p]+[^abc]*q[r]+[^abc]*s[t]+[^abc]*u[w]+[^abc]*v[x]+[^abc]*y[z]+\"\
    , options: NSRegularExpressionOptions.CaseInsensitive)\n    \n    // Remove whitespace.\n\
    \    let trimRegexes = splitOnWhitespaceRegex.stringByReplacingMatchesInString(txt,\
    \ options: nil, range: NSMakeRange(0, txt.length), withTemplate: \"\", replacement:\
    \ \"\")\n    let trimmedString = trimRegexes.stringByReplacingOccurrencesOfString(\"\
    \\\\n\", withString: \"\", options: NSRegularExpressionOptions.CaseInsensitive,\
    \ range: NSMakeRange(0, trimRegexes.length))\n    \n    // Remove commas.\n  \
    \  let trimCommaRegex = try! NSRegularExpression(pattern: \",\")\n    let trimmedCommaString\
    \ = trimCommaRegex.stringByReplacingMatchesInString(trimmedString, options: nil,\
    \ range: NSMakeRange(0, trimmedString.length), withTemplate: \"\", replacement:\
    \ \"\")\n    \n    // Remove lower-case letters with odd order.\n    let trimStripOrderRegex\
    \ = try! NSRegularExpression(pattern: \"[^abc]*a[bc]+[^abc]*b[ac]+[^abc]*c[ad]+[^abc]*d[be]+[^abc]*e[bf]+[^abc]*f[ag]+[^abc]*h[ai]+[^abc]*i[j]+[^abc]*k[l]+[^abc]*m[n]+[^abc]*o[p]+[^abc]*q[r]+[^abc]*s[t]+[^abc]*u[w]+[^abc]*v[x]+[^abc]*y[z]+\"\
    , options: NSRegularExpressionOptions.CaseInsensitive)\n    let trimStripedOrderString\
    \ = trimStripOrderRegex.stringByReplacingMatchesInString(trimmedCommaString, options:\
    \ nil, range: \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdghkelio.swift:35:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpdghkelio.swift:16:39: error: cannot find 'NSRegularExpression' in\
    \ scope\n    let splitOnWhitespaceRegex = try! NSRegularExpression(pattern: \"\
    \\\\s+\")\n                                      ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpdghkelio.swift:19:34:\
    \ error: cannot find 'NSRegularExpression' in scope\n    let splitOnCommaRegex\
    \ = try! NSRegularExpression(pattern: \",\")\n                               \
    \  ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpdghkelio.swift:22:32: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let countOrderRegex = try! NSRegularExpression(pattern: \"[^abc]*a[bc]+[^abc]*b[ac]+[^abc]*c[ad]+[^abc]*d[be]+[^abc]*e[bf]+[^abc]*f[ag]+[^abc]*h[ai]+[^abc]*i[j]+[^abc]*k[l]+[^abc]*m[n]+[^abc]*o[p]+[^abc]*q[r]+[^abc]*s[t]+[^abc]*u[w]+[^abc]*v[x]+[^abc]*y[z]+\"\
    , options: NSRegularExpressionOptions.CaseInsensitive)\n                     \
    \          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpdghkelio.swift:22:273: error: cannot find\
    \ 'NSRegularExpressionOptions' in scope\n    let countOrderRegex = try! NSRegularExpression(pattern:\
    \ \"[^abc]*a[bc]+[^abc]*b[ac]+[^abc]*c[ad]+[^abc]*d[be]+[^abc]*e[bf]+[^abc]*f[ag]+[^abc]*h[ai]+[^abc]*i[j]+[^abc]*k[l]+[^abc]*m[n]+[^abc]*o[p]+[^abc]*q[r]+[^abc]*s[t]+[^abc]*u[w]+[^abc]*v[x]+[^abc]*y[z]+\"\
    , options: NSRegularExpressionOptions.CaseInsensitive)\n                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                       ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdghkelio.swift:25:105:\
    \ error: cannot find 'NSMakeRange' in scope\n    let trimRegexes = splitOnWhitespaceRegex.stringByReplacingMatchesInString(txt,\
    \ options: nil, range: NSMakeRange(0, txt.length), withTemplate: \"\", replacement:\
    \ \"\")\n                                                                    \
    \                                    ^~~~~~~~~~~\n/tmp/tmpdghkelio.swift:25:93:\
    \ error: 'nil' req"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if !txt.characters.contains(where: { $0 == \" \" || $0 == \",\"\
    \ }) { return .failure(0) }\n\n    var splittings = \"\"\n    var words: [String]\
    \ = []\n    for word in txt.split(separator: \" \") {\n        if word == \"\"\
    \ {\n            continue\n        }\n\n        if word.isEmpty {\n          \
    \  return .failure(Int(word.count))\n        }\n\n        splittings += word +\
    \ \" \"\n\n        if splittings.count > maxWordLength {\n            return .failure(Int(splittings.count))\n\
    \        }\n    }\n\n    for char in splittings {\n        if splittings.lowercased().index(char)\
    \ != splittings.lowercased().endIndex {\n            return .failure(Int(splittings.count))\n\
    \        }\n    }\n\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp4b6e4_fz.swift:15:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if !txt.characters.contains(where: { $0 == \" \" ||\
    \ $0 == \",\" }) { return .failure(0) }\n            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp4b6e4_fz.swift:30:31: error: cannot find\
    \ 'maxWordLength' in scope\n        if splittings.count > maxWordLength {\n  \
    \                            ^~~~~~~~~~~~~\n/tmp/tmp4b6e4_fz.swift:36:42: error:\
    \ missing argument label 'of:' in call\n        if splittings.lowercased().index(char)\
    \ != splittings.lowercased().endIndex {\n                                    \
    \     ^\n                                         of: \n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.characters.split(separator: \" \")\n    \n    //\
    \ Check for no whitespaces, commas and no letters are odd-order\n    var i = 0\n\
    \    var letters = 0\n    for char in words {\n        if char.count == 0 {\n\
    \            return Err(Int(letters))\n        }\n        if char.count % 2 ==\
    \ 1 {\n            return Err(Int(letters))\n        }\n        if char.lowercased()\
    \ > 'z' {\n            return Err(Int(letters))\n        }\n        i += 1\n \
    \       letters += char.count\n    }\n    \n    return Ok(words)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvf_g_edx.swift:27:32: error: single-quoted string literal found,\
    \ use '\"'\n        if char.lowercased() > 'z' {\n                           \
    \    ^~~\n                               \"z\"\n/tmp/tmpvf_g_edx.swift:15:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    let words\
    \ = txt.characters.split(separator: \" \")\n                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvf_g_edx.swift:22:20: error: cannot find\
    \ 'Err' in scope\n            return Err(Int(letters))\n                   ^~~\n\
    /tmp/tmpvf_g_edx.swift:25:20: error: cannot find 'Err' in scope\n            return\
    \ Err(Int(letters))\n                   ^~~\n/tmp/tmpvf_g_edx.swift:28:20: error:\
    \ cannot find 'Err' in scope\n            return Err(Int(letters))\n         \
    \          ^~~\n/tmp/tmpvf_g_edx.swift:34:12: error: cannot find 'Ok' in scope\n\
    \    return Ok(words)\n           ^~\n"
  stdout: ''
  timestamp: 1660054550
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var result = \"\"\n    for word in txt.split(\" \") {\n        for\
    \ letter in word.toLower(){\n            if letter != letter{\n              \
    \  if letter > letter{\n                    return Err(Int(1))\n             \
    \   }\n            }\n            result += letter\n        }\n        result\
    \ += \"\\n\"\n    }\n    if txt.lowercased().count % 2 != 0 {\n        return\
    \ Err(Int(txt.lowercased().count))\n    }\n    return Ok(txt.lowercased().split(separator:\
    \ \",\").map(String.init).filter({ $0 != \"\\n\"}))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvf1rb9gz.swift:16:21: error: no exact matches in call to instance\
    \ method 'split'\n    for word in txt.split(\" \") {\n                    ^\n\
    Swift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)', expected:\
    \ '(separator:)')\n    @inlinable public __consuming func split(separator: Self.Element,\
    \ maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpvf1rb9gz.swift:28:16: error: cannot find\
    \ 'Err' in scope\n        return Err(Int(txt.lowercased().count))\n          \
    \     ^~~\n/tmp/tmpvf1rb9gz.swift:30:12: error: cannot find 'Ok' in scope\n  \
    \  return Ok(txt.lowercased().split(separator: \",\").map(String.init).filter({\
    \ $0 != \"\\n\"}))\n           ^~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let regex = try! NSRegularExpression(pattern: \"[\\\\s,]+\", options:\
    \ .caseInsensitive)\n    let ranges = regex.matches(in: txt, range: NSMakeRange(0,\
    \ txt.characters.count))\n    \n    var results = [String]()\n    var result =\
    \ 0\n    for i in 0..<ranges.count {\n        let range = ranges[i]\n        let\
    \ match = txt[range]\n        \n        // If there is no whitespace\n       \
    \ if range.location == txt.characters.count {\n            results.append(match)\n\
    \            results += 1\n        } else if let match = Range<String.Index>(range:\
    \ range, in: txt).lowercased() {\n            \n            // If there is an\
    \ odd number of lowercase letters\n            if result == 0 {\n            \
    \    results.append(match)\n                results += 1\n            } else {\n\
    \                result = 0\n                results.append(match)\n         \
    \       results += 1\n            }\n        } else if let match = Range<String.Index>(range:\
    \ range, in: txt) {\n            results.append(match)\n            results +=\
    \ 1\n        }\n    }\n    \n    if results == 0 {\n        return .failure(Int(count))\n\
    \    }\n    \n    return .success(results)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpsnjlyj9j.swift:15:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"[\\\\s,]+\", options:\
    \ .caseInsensitive)\n                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpsnjlyj9j.swift:15:72:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \    let regex = try! NSRegularExpression(pattern: \"[\\\\s,]+\", options: .caseInsensitive)\n\
    \                                                                      ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpsnjlyj9j.swift:16:48: error: cannot find 'NSMakeRange' in scope\n    let\
    \ ranges = regex.matches(in: txt, range: NSMakeRange(0, txt.characters.count))\n\
    \                                               ^~~~~~~~~~~\n/tmp/tmpsnjlyj9j.swift:45:16:\
    \ error: binary operator '==' cannot be applied to operands of type '[String]'\
    \ and 'Int'\n    if results == 0 {\n       ~~~~~~~ ^  ~\n/tmp/tmpsnjlyj9j.swift:45:16:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    if results == 0 {\n               ^\n/tmp/tmpsnjlyj9j.swift:46:29:\
    \ error: cannot find 'count' in scope\n        return .failure(Int(count))\n \
    \                           ^~~~~\n/tmp/tmpsnjlyj9j.swift:28:31: error: referencing\
    \ initializer 'init(_:)' on 'Range' requires that 'String.Index' conform to 'Strideable'\n\
    \        } else if let match = Range<String.Index>(range: range, in: txt).lowercased()\
    \ {\n                              ^\nSwift.Range:1:11: note: where 'Bound' =\
    \ 'String.Index'\nextension Range where Bound : Strideable, Bound.Stride : SignedInteger\
    \ {\n          ^\n/tmp/tmpsnjlyj9j.swift:28:69: error: extra argument 'in' in\
    \ call\n        } else if let match = Range<String.Index>(range: range, in: txt).lowercased()\
    \ {\n                                                 ~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpsnjlyj9j.swift:28:74: error: value of type 'Range<String.Index>' has no\
    \ member 'lowercased'\n        } else if let match = Range<String.Index>(range:\
    \ range, in: txt).lowercased() {\n                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if !txt.isEmpty {\n        let spaces = CharacterSet(charactersIn:\
    \ \" \\t\\n\\r\").inverted\n        let comma = CharacterSet(charactersIn: \"\
    ,\")\n        let words = txt.components(separatedBy: spaces)\n            .filter\
    \ { !$0.isEmpty }\n            .map { $0.lowercased() }\n            .filter {\
    \ !$1.isEmpty }\n            .filter({ $0.count % 2 == 1 })\n            .map\
    \ { $0.lowercased() }\n            .filter { !$0.isEmpty }\n            .sorted(by:\
    \ { $0.lowercased() < $1.lowercased() })\n        if !words.isEmpty {\n      \
    \      return .success(words)\n        }\n        return .failure(\n         \
    \   words.isEmpty\n                ? 1\n                : words.count / 2 + words.count\
    \ % 2 == 1\n                    ? 1\n                    : Int((words.count +\
    \ commas.count) / 2))\n    }\n    return .failure(txt.isEmpty ? 1 : 0)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmph3dva9ph.swift:16:22: error: cannot find 'CharacterSet' in scope\n\
    \        let spaces = CharacterSet(charactersIn: \" \\t\\n\\r\").inverted\n  \
    \                   ^~~~~~~~~~~~\n/tmp/tmph3dva9ph.swift:17:21: error: cannot\
    \ find 'CharacterSet' in scope\n        let comma = CharacterSet(charactersIn:\
    \ \",\")\n                    ^~~~~~~~~~~~\n/tmp/tmph3dva9ph.swift:18:21: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n        let words\
    \ = txt.components(separatedBy: spaces)\n                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmph3dva9ph.swift:34:42: error: cannot find 'commas' in scope\n         \
    \           : Int((words.count + commas.count) / 2))\n                       \
    \                  ^~~~~~\n"
  stdout: ''
  timestamp: 1660054587
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return Result.success(txt.components(separatedBy: NSCharacterSet.whitespaces.inverted).flatMap\
    \ { $0.components(separatedBy: \",\") })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp32hrlwqh.swift:15:55: error: cannot find 'NSCharacterSet' in scope\n\
    \    return Result.success(txt.components(separatedBy: NSCharacterSet.whitespaces.inverted).flatMap\
    \ { $0.components(separatedBy: \",\") })\n                                   \
    \                   ^~~~~~~~~~~~~~\n/tmp/tmp32hrlwqh.swift:15:31: error: value\
    \ of type 'String' has no member 'components'\n    return Result.success(txt.components(separatedBy:\
    \ NSCharacterSet.whitespaces.inverted).flatMap { $0.components(separatedBy: \"\
    ,\") })\n                          ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.unicodeScalars.compactMap(unicodeScalar).map(String.init)\n\
    \    guard words.count > 0 else {\n        return .failure(txt.count)\n    }\n\
    \    guard !words.contains(\"\") else {\n        return .success(Array(words))\n\
    \    }\n    let noSpace = words.filter { $0.contains(\" \") }\n    if !noSpace.count\
    \ == words.count {\n        return .success(Array(words))\n    }\n    let comma\
    \ = words.filter { $0.contains(\",\") }\n    if !comma.count == words.count {\n\
    \        return .success(Array(words))\n    }\n    return .success(Array(noSpace))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2vwypg35.swift:15:47: error: cannot find 'unicodeScalar' in scope\n\
    \    let words = txt.unicodeScalars.compactMap(unicodeScalar).map(String.init)\n\
    \                                              ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    if txt == \"\" {\n        return .failure(0) // should split\
    \ on spaces\n    }\n    \n    let arr = txt.components(separatedBy: \" \")\n \
    \   \n    var words: [String] = []\n    \n    for elem in arr {\n        let count\
    \ = elem.lowercaseString.characters.count\n        \n        if count > 1 && count\
    \ % 2 != 0 {\n            words.append(elem)\n        }\n    }\n    \n    if words.count\
    \ > 0 {\n        return .success(words)\n    }\n    \n    if arr.count == 0 {\n\
    \        return .failure(0) // should split on commas\n    }\n    \n    let arr\
    \ = txt.components(separatedBy: \",\")\n    \n    var words: [String] = []\n \
    \   \n    for elem in arr {\n        let count = elem.lowercaseString.characters.count\n\
    \        \n        if count > 1 && count % 2 != 0 {\n            words.append(elem)\n\
    \        }\n    }\n    \n    if words.count > 0 {\n        return .success(words)\n\
    \    }\n    \n    return .failure(0) // should split on spaces\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcxg846xr.swift:20:19: error: value of type 'String' has no member\
    \ 'components'\n    let arr = txt.components(separatedBy: \" \")\n           \
    \   ~~~ ^~~~~~~~~~\n/tmp/tmpcxg846xr.swift:40:19: error: value of type 'String'\
    \ has no member 'components'\n    let arr = txt.components(separatedBy: \",\"\
    )\n              ~~~ ^~~~~~~~~~\n/tmp/tmpcxg846xr.swift:42:9: error: invalid redeclaration\
    \ of 'words'\n    var words: [String] = []\n        ^\n/tmp/tmpcxg846xr.swift:22:9:\
    \ note: 'words' previously declared here\n    var words: [String] = []\n     \
    \   ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return .success(\n        txt.characters.split(separator: Character.whitespaces)\n\
    \            .map { $0.trim() }\n            .map { $0.lowercased() }\n      \
    \      .filter { !$0.isEmpty })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptibfdymr.swift:16:51: error: type 'Character' has no member 'whitespaces'\n\
    \        txt.characters.split(separator: Character.whitespaces)\n            \
    \                            ~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmptibfdymr.swift:17:23:\
    \ error: reference to member 'trim' cannot be resolved without a contextual type\n\
    \            .map { $0.trim() }\n                      ^\n/tmp/tmptibfdymr.swift:18:18:\
    \ error: unable to infer type of a closure parameter '$0' in the current context\n\
    \            .map { $0.lowercased() }\n                 ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let splits = txt.components(separatedBy: \" \")\n    if splits.count\
    \ < 2 {\n        return .failure(25)\n    }\n    if splits.count > 2 {\n     \
    \   return .failure(28)\n    }\n    let res = splits[0]\n    if res.lowercased().count\
    \ == 25 {\n        return .success(res)\n    }\n    return .success(res.lowercased().characters.split(separator:\
    \ \", \").map(String.init))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpodqvcijh.swift:15:22: error: value of type 'String' has no member\
    \ 'components'\n    let splits = txt.components(separatedBy: \" \")\n        \
    \         ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let regex = try! NSRegularExpression(pattern: \" \", options: [])\n\
    \    let match = regex.firstMatch(in: txt, options: [], range: NSRange(0..<txt.utf16.count))\n\
    \n    let words = Array(txt.utf16[match.range(at: 1) ..< match.range(at: 2)])\n\
    \    let numWords = words.count\n\n    let upperIndex = txt.index(txt.startIndex,\
    \ offsetBy: 0).distance(from: txt.endIndex, to: txt.index(txt.endIndex, offsetBy:\
    \ -1)) % 26\n    let lowerIndex = txt.index(txt.startIndex, offsetBy: 0).distance(from:\
    \ txt.endIndex, to: txt.index(txt.endIndex, offsetBy: -1)) - numWords % 26\n\n\
    \    if numWords == 0 {\n        return .failure(Int(numWords))\n    }\n    if\
    \ upperIndex == lowerIndex {\n        return .success(Array(words))\n    }\n \
    \   let isUpper = upperIndex > lowerIndex\n    return .success(Array(words) +\
    \ (isUpper ? [String](repeating: String(), count: upperIndex - lowerIndex) : [String](repeating:\
    \ String(), count: lowerIndex - upperIndex)))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpc8fzznuh.swift:15:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \" \", options:\
    \ [])\n                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpc8fzznuh.swift:16:63:\
    \ error: cannot find 'NSRange' in scope\n    let match = regex.firstMatch(in:\
    \ txt, options: [], range: NSRange(0..<txt.utf16.count))\n                   \
    \                                           ^~~~~~~\n/tmp/tmpc8fzznuh.swift:21:61:\
    \ error: value of type 'String.Index' has no member 'distance'\n    let upperIndex\
    \ = txt.index(txt.startIndex, offsetBy: 0).distance(from: txt.endIndex, to: txt.index(txt.endIndex,\
    \ offsetBy: -1)) % 26\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n/tmp/tmpc8fzznuh.swift:22:61: error: value of type 'String.Index'\
    \ has no member 'distance'\n    let lowerIndex = txt.index(txt.startIndex, offsetBy:\
    \ 0).distance(from: txt.endIndex, to: txt.index(txt.endIndex, offsetBy: -1)) -\
    \ numWords % 26\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n\
    /tmp/tmpc8fzznuh.swift:31:95: error: cannot convert value of type 'Duration' to\
    \ expected argument type 'Int'\n    return .success(Array(words) + (isUpper ?\
    \ [String](repeating: String(), count: upperIndex - lowerIndex) : [String](repeating:\
    \ String(), count: lowerIndex - upperIndex)))\n                              \
    \                                                                ^\n/tmp/tmpc8fzznuh.swift:31:159:\
    \ error: cannot convert value of type 'Duration' to expected argument type 'Int'\n\
    \    return .success(Array(words) + (isUpper ? [String](repeating: String(), count:\
    \ upperIndex - lowerIndex) : [String](repeating: String(), count: lowerIndex -\
    \ upperIndex)))\n                                                            \
    \                                                                            \
    \                      ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let text = txt.lowercased() else {\n        return .failure(NSNumber(integer:\
    \ 0))\n    }\n    \n    let words: [String] = []\n    let hasComma = text.contains(\"\
    ,\")\n    let hasSpace = text.contains(\"  \")\n    \n    if hasComma {\n    \
    \    let firstComma = text.index(text.startIndex, offsetBy: text.count) // index\
    \ after the comma start\n        let lastComma = text.index(firstComma, offsetBy:\
    \ 1) // index before the comma end\n        let commaText = text.substring(from:\
    \ firstComma, to: lastComma)\n        \n        words = text.components(separatedBy:\
    \ \",\")\n    } else if hasSpace {\n        let firstSpace = text.index(text.startIndex,\
    \ offsetBy: text.count) // index after the space start\n        let lastSpace\
    \ = text.index(firstSpace, offsetBy: 1) // index before the space end\n      \
    \  let spaceText = text.substring(from: firstSpace, to: lastSpace)\n        \n\
    \        words = text.components(separatedBy: \" \")\n    } else {\n        let\
    \ asciiLowercase = Array(text).filter({ $0.isLowercase })\n        let asciiUppercase\
    \ = Array(text).filter({ $0.isUppercase })\n        \n        // odd number of\
    \ characters in alphabet counts as odd order\n        let oddOrder = asciiUppercase.count().squared()\
    \ - (asciiLowercase.count().squared() + asciiUppercase.count())\n        let evenOrder\
    \ = asciiLowercase.count().squared() - (asciiUppercase.count().squared() + asciiLowercase.count())\n\
    \        \n        words = Array(asciiUppercase).append(asciiLowercase)\n    \
    \        .prefix(oddOrder)\n            .compactMap({ String($0, radix: .uppercase)\
    \ })\n            .dropFirst()\n            .prefix(evenOrder)\n            .compactMap({\
    \ String($0, radix: .lowercase) })\n            .dropFirst()\n            .map{\
    \ String($0, radix: .alphanumeric) }\n    }\n    \n    guard words != nil else\
    \ {\n        return .failure(NSNumber(integer: 0))\n    }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp4nw9ds4p.swift:16:25: error: cannot find 'NSNumber' in scope\n\
    \        return .failure(NSNumber(integer: 0))\n                        ^~~~~~~~\n\
    /tmp/tmp4nw9ds4p.swift:15:11: error: initializer for conditional binding must\
    \ have Optional type, not 'String'\n    guard let text = txt.lowercased() else\
    \ {\n          ^          ~~~~~~~~~~~~~~~~\n/tmp/tmp4nw9ds4p.swift:26:30: error:\
    \ value of type 'String' has no member 'substring'\n        let commaText = text.substring(from:\
    \ firstComma, to: lastComma)\n                        ~~~~ ^~~~~~~~~\n/tmp/tmp4nw9ds4p.swift:28:9:\
    \ error: cannot assign to value: 'words' is a 'let' constant\n        words =\
    \ text.components(separatedBy: \",\")\n        ^~~~~\n/tmp/tmp4nw9ds4p.swift:19:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let words: [String] = []\n\
    \    ^~~\n    var\n/tmp/tmp4nw9ds4p.swift:28:22: error: value of type 'String'\
    \ has no member 'components'\n        words = text.components(separatedBy: \"\
    ,\")\n                ~~~~ ^~~~~~~~~~\n/tmp/tmp4nw9ds4p.swift:32:30: error: value\
    \ of type 'String' has no member 'substring'\n        let spaceText = text.substring(from:\
    \ firstSpace, to: lastSpace)\n                        ~~~~ ^~~~~~~~~\n/tmp/tmp4nw9ds4p.swift:34:9:\
    \ error: cannot assign to value: 'words' is a 'let' constant\n        words =\
    \ text.components(separatedBy: \" \")\n        ^~~~~\n/tmp/tmp4nw9ds4p.swift:19:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let words: [String] = []\n\
    \    ^~~\n    var\n/tmp/tmp4nw9ds4p.swift:34:22: error: value of type 'String'\
    \ has no member 'components'\n        words = text.components(separatedBy: \"\
    \ \")\n                ~~~~ ^~~~~~~~~~\n/tmp/tmp4nw9ds4p.swift:40:75: error: cannot\
    \ call value of non-function type 'Int'\n        let oddOrder = asciiUppercase.count().squared()\
    \ - (asciiLowercase.count().squared() + asciiUppercase.count())\n            \
    \                                                              ^    ~~\n     \
    \                                                                          \n\
    /tmp/tmp4nw9ds4p.swift:40:39: error: cannot call value of non-func"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\
    \ else {\n        return .failure(count)\n    }\n    let lowercaseLetters = words.map({\
    \ $0.lowercased() })\n    let alphabetically = lowercaseLetters.filter({ $0.isAlphabetic\
    \ })\n    \n    let letters = lowercaseLetters.count\n    let oddOrder = letters.filter({\
    \ !$0.isOdd })\n    if oddOrder.isEmpty {\n        return .success(alphabetically)\n\
    \    } else {\n        return .failure(oddOrder.count)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpi8xzfk83.swift:15:51: error: cannot find 'CharacterSet' in scope\n\
    \    guard let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\
    \ else {\n                                                  ^~~~~~~~~~~~\n/tmp/tmpi8xzfk83.swift:15:27:\
    \ error: value of type 'String' has no member 'components'\n    guard let words\
    \ = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines) else {\n\
    \                      ~~~ ^~~~~~~~~~\n/tmp/tmpi8xzfk83.swift:16:25: error: cannot\
    \ find 'count' in scope\n        return .failure(count)\n                    \
    \    ^~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var result: [String] = []\n    var count = [String: Int]()\n   \
    \ for c in txt {\n        if c == ' ' || c == ',' {\n            result.append(contentsOf:\
    \ result)\n            count[String(count[count])!] += 1\n            count[String(count[count])!]\
    \ = 0\n        } else {\n            result.append(c)\n        }\n    }\n    if\
    \ count.isEmpty {\n        return .success(result)\n    } else {\n        return\
    \ .failure(count[String(count[count])!])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp14bb08b8.swift:18:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == ' ' || c == ',' {\n                ^~~\n         \
    \       \" \"\n/tmp/tmp14bb08b8.swift:18:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c == ' ' || c == ',' {\n                       \
    \     ^~~\n                            \",\"\n/tmp/tmp14bb08b8.swift:20:31: error:\
    \ no exact matches in call to subscript \n            count[String(count[count])!]\
    \ += 1\n                              ^\n/tmp/tmp14bb08b8.swift:20:31: note: found\
    \ candidate with type '(Dictionary<String, Int>.Index) -> (key: String, value:\
    \ Int)'\n            count[String(count[count])!] += 1\n                     \
    \         ^\n/tmp/tmp14bb08b8.swift:20:31: note: found candidate with type '(String)\
    \ -> @lvalue Int?'\n            count[String(count[count])!] += 1\n          \
    \                    ^\n/tmp/tmp14bb08b8.swift:20:31: note: found candidate with\
    \ type '(Range<Dictionary<String, Int>.Index>) -> Slice<[String : Int]>'\n   \
    \         count[String(count[count])!] += 1\n                              ^\n\
    /tmp/tmp14bb08b8.swift:20:31: note: found candidate with type '((UnboundedRange_)\
    \ -> ()) -> Dictionary<String, Int>.SubSequence' (aka '((UnboundedRange_) -> ())\
    \ -> Slice<Dictionary<String, Int>>')\n            count[String(count[count])!]\
    \ += 1\n                              ^\n/tmp/tmp14bb08b8.swift:20:19: error:\
    \ no exact matches in call to initializer \n            count[String(count[count])!]\
    \ += 1\n                  ^\n/tmp/tmp14bb08b8.swift:20:19: note: found candidate\
    \ with type '((key: String, value: Int)) -> String'\n            count[String(count[count])!]\
    \ += 1\n                  ^\n/tmp/tmp14bb08b8.swift:20:19: note: found candidate\
    \ with type '((key: String, value: Int), Int, Bool) -> String'\n            count[String(count[count])!]\
    \ += 1\n                  ^\n/tmp/tmp14bb08b8.swift:20:19: note: candidate has\
    \ partially matching parameter list (Substring.UTF8View)\n            count[String(count[count])!]\
    \ += 1\n                  ^\n/tmp/tmp14bb08b8.swift:20:19: note: candidate h"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let split = txt.split(separator: \" \").map(String.init) else\
    \ {\n        return .failure(3)\n    }\n    let count = split.reduce(0) { sum,\
    \ elt in\n        if let char = elt.first {\n            sum += char.unicodeScalars.filter({\
    \ $0.isLowercase })?.count ?? 0\n        }\n        return sum\n    }\n    if\
    \ count == 0 {\n        return .success(split.map { $0.lowercased() })\n    }\n\
    \    let oddIndex = count % 2\n    let letters = String(repeating: \"\", count:\
    \ count)\n    return .success(letters[0..<(count - 1)].append([split.first!]).append(letters[(count\
    \ - 1)..<(count)].map { $0.lowercased() })[oddIndex..<(oddIndex + 1).reversed()].map\
    \ { $0 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplyjulncf.swift:15:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String]'\n    guard let split = txt.split(separator:\
    \ \" \").map(String.init) else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplyjulncf.swift:20:52: error: value of type 'Unicode.Scalar' has no member\
    \ 'isLowercase'\n            sum += char.unicodeScalars.filter({ $0.isLowercase\
    \ })?.count ?? 0\n                                                ~~ ^~~~~~~~~~~\n\
    /tmp/tmplyjulncf.swift:20:66: error: cannot use optional chaining on non-optional\
    \ value of type 'Character.UnicodeScalarView' (aka 'String.UnicodeScalarView')\n\
    \            sum += char.unicodeScalars.filter({ $0.isLowercase })?.count ?? 0\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n        \
    \                                                         \n/tmp/tmplyjulncf.swift:29:12:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n    return .success(letters[0..<(count\
    \ - 1)].append([split.first!]).append(letters[(count - 1)..<(count)].map { $0.lowercased()\
    \ })[oddIndex..<(oddIndex + 1).reversed()].map { $0 })\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054569
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    return words.count\
    \ == 0 ? .failure(0) : .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz8lo3mr8.swift:16:54: error: cannot convert value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to expected argument type '[String]'\n    return words.count\
    \ == 0 ? .failure(0) : .success(words)\n                                     \
    \                ^\n/tmp/tmpz8lo3mr8.swift:16:54: note: arguments to generic parameter\
    \ 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are expected\
    \ to be equal\n    return words.count == 0 ? .failure(0) : .success(words)\n \
    \                                                    ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Result.failure(Int(self))\n    }\n    var lowercaseLetter = 0\n    var result\
    \ = [String]()\n    for word in words {\n        guard let word = word.trimmingCharacters(in:\
    \ .whitespaces) else { continue }\n        lowercaseLetter += 1\n        result.append(word)\n\
    \    }\n    guard lowercaseLetter % 2 == 1 else { return Result.failure(Int(self))\
    \ }\n    return Result.success(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpq3i2nspl.swift:16:35: error: cannot find 'self' in scope; did you\
    \ mean to use it in a type or extension context?\n        return Result.failure(Int(self))\n\
    \                                  ^~~~\n/tmp/tmpq3i2nspl.swift:15:11: error:\
    \ initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    guard let words = txt.split(separator: \" \")\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpq3i2nspl.swift:21:31:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        guard let word = word.trimmingCharacters(in: .whitespaces) else { continue\
    \ }\n                         ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpq3i2nspl.swift:21:55:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       guard let word = word.trimmingCharacters(in: .whitespaces) else { continue\
    \ }\n                                                     ~^~~~~~~~~~~\n/tmp/tmpq3i2nspl.swift:25:69:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n    guard lowercaseLetter % 2 == 1 else { return Result.failure(Int(self))\
    \ }\n                                                                    ^~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(\" \").map { String($0) }\n    guard words.count\
    \ != 0 else {\n        return Err(3)\n    }\n    return words.count == 1 ? .success(words)\
    \ : .failure(words.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7fv1f4rk.swift:15:21: error: no exact matches in call to instance\
    \ method 'split'\n    let words = txt.split(\" \").map { String($0) }\n      \
    \              ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n/tmp/tmp7fv1f4rk.swift:17:16: error:\
    \ cannot find 'Err' in scope\n        return Err(3)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return NSString.stringWithString(txt).characters.split(separator:\
    \ \",\").flatMap({ text -> [String] in\n        let text = text.lowercaseString\n\
    \        let chars = text.characters.filter({ !($0.isWhitespace || $0.isSeparator)})\n\
    \        return chars.filter({ !($0.isLetter) }).countByEnumeratingWithState(\n\
    \            chars, options: .byIsUppercase)\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpou341lo5.swift:15:12: error: cannot find 'NSString' in scope\n\
    \    return NSString.stringWithString(txt).characters.split(separator: \",\").flatMap({\
    \ text -> [String] in\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var words = [String]()\n    let words = txt.componentsSeparatedByString(\"\
    \ \")\n    for word in words {\n        words.append(word)\n    }\n    return\
    \ words.count == 0 ? .success(words) : words.count == 1 ? .failure(words.count)\
    \ : .failure(.failure)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfnywkvum.swift:16:21: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = txt.componentsSeparatedByString(\"\
    \ \")\n                ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpfnywkvum.swift:20:102:\
    \ error: type 'Int' has no member 'failure'\n    return words.count == 0 ? .success(words)\
    \ : words.count == 1 ? .failure(words.count) : .failure(.failure)\n          \
    \                                                                            \
    \              ~^~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: -4
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if txt.isEmpty {\n        return .failure(3)\n    }\n    var result\
    \ = [String]()\n    var i = 0\n    for ch in txt {\n        if ch.isWhitespace\
    \ {\n            if i > 0 {\n                result.append(String(i))\n      \
    \      }\n            i = 0\n        } else {\n            i += 1\n        }\n\
    \    }\n    if i > 0 {\n        result.append(String(i))\n    }\n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: Exception
  stderr: 'tmpvq2dxytr/tmpvq2dxytr.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007efee23cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007efee20c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007efee20c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007efee20c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvq2dxytr                        0x0000564fa82a7b2c <unavailable> + 6956

    5    libc.so.6                          0x00007efee1bb8460 __libc_start_main +
    245

    6    tmpvq2dxytr                        0x0000564fa82a7669 <unavailable> + 5737

    '
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words: [String] = txt.components(separatedBy: .whitespacesAndNewlines)\n\
    \    if words == nil || words.count == 0 {\n        return Result.failure(3)\n\
    \    }\n    if words.contains(where: {$0.isEmpty}) {\n        return Result.success(words)\n\
    \    }\n    if words.contains(where: {$0.isEmpty && $0.count % 2 == 1}) {\n  \
    \      return Result.success(words.prefix(words.count / 2))\n    }\n    if words.count\
    \ % 2 == 1 {\n        return Result.success(words.prefix(words.count / 2 + 1))\n\
    \    }\n    \n    let firstCharacter = words.prefix(words.count / 2)\n    let\
    \ secondCharacter = words.suffix(words.count / 2)\n    let letterOrder: [Int]\
    \ = [firstCharacter.count]\n    let lettersOfTheSecondCharacter = [secondCharacter]\n\
    \    for character in secondCharacter {\n        letterOrder.append(letterOrder.last!\
    \ + 1)\n        lettersOfTheSecondCharacter.append(character)\n    }\n    return\
    \ Result.success(firstCharacter + letterOrder + lettersOfTheSecondCharacter)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprmodrpic.swift:15:31: error: value of type 'String' has no member\
    \ 'components'\n    let words: [String] = txt.components(separatedBy: .whitespacesAndNewlines)\n\
    \                          ~~~ ^~~~~~~~~~\n/tmp/tmprmodrpic.swift:15:56: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words: [String] = txt.components(separatedBy: .whitespacesAndNewlines)\n\
    \                                                      ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprmodrpic.swift:16:14: warning: comparing non-optional value of type '[String]'\
    \ to 'nil' always returns false\n    if words == nil || words.count == 0 {\n \
    \      ~~~~~ ^  ~~~\n/tmp/tmprmodrpic.swift:23:37: error: cannot convert value\
    \ of type 'ArraySlice<String>' to expected argument type '[String]'\n        return\
    \ Result.success(words.prefix(words.count / 2))\n                            \
    \        ^\n/tmp/tmprmodrpic.swift:26:37: error: cannot convert value of type\
    \ 'ArraySlice<String>' to expected argument type '[String]'\n        return Result.success(words.prefix(words.count\
    \ / 2 + 1))\n                                    ^\n/tmp/tmprmodrpic.swift:34:21:\
    \ error: cannot use mutating member on immutable value: 'letterOrder' is a 'let'\
    \ constant\n        letterOrder.append(letterOrder.last! + 1)\n        ~~~~~~~~~~~\
    \ ^\n/tmp/tmprmodrpic.swift:31:5: note: change 'let' to 'var' to make it mutable\n\
    \    let letterOrder: [Int] = [firstCharacter.count]\n    ^~~\n    var\n/tmp/tmprmodrpic.swift:35:37:\
    \ error: no exact matches in call to instance method 'append'\n        lettersOfTheSecondCharacter.append(character)\n\
    \                                    ^\n/tmp/tmprmodrpic.swift:35:37: note: found\
    \ candidate with type '(__owned ArraySlice<String>) -> ()'\n        lettersOfTheSecondCharacter.append(character)\n\
    \                                    ^\n/tmp/tmprmodrpic.swift:35:37: note: found\
    \ candidate with type '(__owned String) -> ()'\n        lettersOfTheSecondCharacter.append(character)\n\
    \                                    ^\n/tmp/tmprmodrpic.swift:37:56: error: binary\
    \ operator '+"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \    return words.count == 0 ? Err(3) // no whitespaces or new lines -> return\
    \ number of lower-case letters with odd order in the alphabet\n        .map {\
    \ words in\n            let alphabet = Array(Int('a'..<'z').filter {\n       \
    \         words.filter({ Character($0).isLower }).count > 1\n            }) //\
    \ e.g. ['a','b','c'] -> ['a','c']\n            return words.map { word in\n  \
    \              alphabet[alphabet.index(word.lowercased())]\n            }\n  \
    \      }\n    : .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgvox4pw1.swift:18:38: error: single-quoted string literal found,\
    \ use '\"'\n            let alphabet = Array(Int('a'..<'z').filter {\n       \
    \                              ^~~\n                                     \"a\"\
    \n/tmp/tmpgvox4pw1.swift:18:44: error: single-quoted string literal found, use\
    \ '\"'\n            let alphabet = Array(Int('a'..<'z').filter {\n           \
    \                                ^~~\n                                       \
    \    \"z\"\n/tmp/tmpgvox4pw1.swift:15:45: error: cannot find 'CharacterSet' in\
    \ scope\n    let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \                                            ^~~~~~~~~~~~\n/tmp/tmpgvox4pw1.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ CharacterSet.whitespacesAndNewlines)\n                ~~~ ^~~~~~~~~~\n/tmp/tmpgvox4pw1.swift:16:31:\
    \ error: cannot find 'Err' in scope\n    return words.count == 0 ? Err(3) // no\
    \ whitespaces or new lines -> return number of lower-case letters with odd order\
    \ in the alphabet\n                              ^~~\n/tmp/tmpgvox4pw1.swift:18:34:\
    \ error: no exact matches in call to initializer \n            let alphabet =\
    \ Array(Int('a'..<'z').filter {\n                                 ^\n/tmp/tmpgvox4pw1.swift:18:34:\
    \ note: found candidate with type '(Float16) -> Int'\n            let alphabet\
    \ = Array(Int('a'..<'z').filter {\n                                 ^\n/tmp/tmpgvox4pw1.swift:18:34:\
    \ note: found candidate with type '(Float) -> Int'\n            let alphabet =\
    \ Array(Int('a'..<'z').filter {\n                                 ^\n/tmp/tmpgvox4pw1.swift:18:34:\
    \ note: found candidate with type '(Double) -> Int'\n            let alphabet\
    \ = Array(Int('a'..<'z').filter {\n                                 ^\n/tmp/tmpgvox4pw1.swift:18:34:\
    \ note: found candidate with type '(Float80) -> Int'\n            let alphabet\
    \ = Array(Int('a'..<'z').filter {\n                                 ^\n/tmp/tmpgvox4pw1.swift:18:34:\
    \ note: found candidate with type '(Builtin.Int64) -> Int'\n    "
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return try run(.parse, txt)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz1c9oh_s.swift:15:16: error: cannot find 'run' in scope\n    return\
    \ try run(.parse, txt)\n               ^~~\n/tmp/tmpz1c9oh_s.swift:15:21: error:\
    \ cannot infer contextual base in reference to member 'parse'\n    return try\
    \ run(.parse, txt)\n                   ~^~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else {\n        return\
    \ Result.failure(WordSplitError.badString)\n    }\n    let allWords = words.flatMap\
    \ { String($0) }\n    guard let words = allWords.split(separator: \",\") else\
    \ {\n        return Result.failure(WordSplitError.badString)\n    }\n    let odd\
    \ = allWords.filter { $0.isUppercase }\n    let even = allWords.filter { !$0.isUppercase\
    \ }\n    if odd.count == 0 {\n        if even.count % 2 == 1 {\n            return\
    \ Result.success(even)\n        }\n        return Result.success(odd.count - 1)\n\
    \    }\n    if even.count % 2 == 0 {\n        return Result.success(even.count\
    \ / 2)\n    }\n    return Result.success(even.count)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpvqxbpotb.swift:16:31: error: cannot find 'WordSplitError' in scope\n\
    \        return Result.failure(WordSplitError.badString)\n                   \
    \           ^~~~~~~~~~~~~~\n/tmp/tmpvqxbpotb.swift:15:11: error: initializer for\
    \ conditional binding must have Optional type, not '[String.SubSequence]' (aka\
    \ 'Array<Substring>')\n    guard let words = txt.split(separator: \" \") else\
    \ {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvqxbpotb.swift:20:31:\
    \ error: cannot find 'WordSplitError' in scope\n        return Result.failure(WordSplitError.badString)\n\
    \                              ^~~~~~~~~~~~~~\n/tmp/tmpvqxbpotb.swift:19:11: error:\
    \ initializer for conditional binding must have Optional type, not '[ArraySlice<String.Element>]'\
    \ (aka 'Array<ArraySlice<Character>>')\n    guard let words = allWords.split(separator:\
    \ \",\") else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvqxbpotb.swift:26:35:\
    \ error: cannot convert value of type '[String.Element]' (aka 'Array<Character>')\
    \ to expected argument type '[String]'\n            return Result.success(even)\n\
    \                                  ^\n/tmp/tmpvqxbpotb.swift:26:35: note: arguments\
    \ to generic parameter 'Element' ('String.Element' (aka 'Character') and 'String')\
    \ are expected to be equal\n            return Result.success(even)\n        \
    \                          ^\n/tmp/tmpvqxbpotb.swift:28:41: error: cannot convert\
    \ value of type 'Int' to expected argument type '[String]'\n        return Result.success(odd.count\
    \ - 1)\n                                        ^\n/tmp/tmpvqxbpotb.swift:31:42:\
    \ error: cannot convert value of type 'Int' to expected argument type '[String]'\n\
    \        return Result.success(even.count / 2)\n                             \
    \            ^\n/tmp/tmpvqxbpotb.swift:33:32: error: cannot convert value of type\
    \ 'Int' to expected argument type '[String]'\n    return Result.success(even.count)\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let words = txt.componentsSeparatedByString(\" \")\n    \n\
    \    guard !words.isEmpty else {\n        return .failure(txt.characters.count)\n\
    \    }\n    \n    if words.count % 2 != 0 {\n        let numLowercaseLetters:\
    \ Int = Int(txt.characters.reduce(0) { ($0 + (($1 >= 97 && $1 <= 122) || ($1 >=\
    \ 65 && $1 <= 90))) ? $0 + 1 : $0 })\n        return .success(Array(txt.characters.filter\
    \ { $0 < 32 }).reduce(0) { ($0 == 0 && $1.isASCIILowercase()) ? $0 + 1 : $0 }\
    \ / numLowercaseLetters)\n    } else {\n        return .success(Array(words).map(String.init).reduce(0)\
    \ { ($0 == 0 && $1.isASCIILowercase()) ? $0 + 1 : $0 })\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "error: compile command failed due to signal 15 (use -v to see invocation)\n\
    /tmp/tmpdt8i0nr1.swift:16:21: error: value of type 'String' has no member 'componentsSeparatedByString'\n\
    \    let words = txt.componentsSeparatedByString(\" \")\n                ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdt8i0nr1.swift:19:29: error: 'characters' is unavailable: Please use String\
    \ directly\n        return .failure(txt.characters.count)\n                  \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660054790
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let words = txt.componentsSeparatedByString(\" \")\n    if\
    \ words.count % 2 != 0 {\n        return Result.failure(words[words.count/2].characters.count-1)\n\
    \    }\n    let count = words.count/2\n    var result: [String] = []\n    \n \
    \   for _ in 0..<count {\n        let first = words[words.count/2].characters.first\n\
    \        let last = words[words.count/2].characters.last\n        var resultWord\
    \ = \"\"\n        if first == last {\n            resultWord = String(first)\n\
    \        } else {\n            for i in 0..<(last.unicodeScalars.count-1) {\n\
    \                let ch = first\n                ch += last.unicodeScalars.elementAt(i)\n\
    \                resultWord.append(String(ch))\n            }\n        }\n   \
    \     result.append(resultWord)\n    }\n    \n    return Result.success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8hko_96o.swift:16:21: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = txt.componentsSeparatedByString(\"\
    \ \")\n                ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let text = txt else {\n        return .failure(25)\n    }\n\
    \    let words = [String]()\n    let whiteSpace = CharacterSet.whitespaces\n \
    \   let comma = CharacterSet.commaDot\n    text.split(separator: whiteSpace, maxSplits:\
    \ Int.max).forEach({ word in\n        if word.characters.isSuperset(of: comma)\
    \ {\n            words.append(word)\n        } else {\n            words.append(word.lowercased())\n\
    \        }\n    })\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzn_enl0a.swift:15:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let text = txt else {\n   \
    \       ^          ~~~\n/tmp/tmpzn_enl0a.swift:19:22: error: cannot find 'CharacterSet'\
    \ in scope\n    let whiteSpace = CharacterSet.whitespaces\n                  \
    \   ^~~~~~~~~~~~\n/tmp/tmpzn_enl0a.swift:20:17: error: cannot find 'CharacterSet'\
    \ in scope\n    let comma = CharacterSet.commaDot\n                ^~~~~~~~~~~~\n\
    /tmp/tmpzn_enl0a.swift:22:28: error: value of type 'Substring' has no member 'isSuperset'\n\
    \        if word.characters.isSuperset(of: comma) {\n           ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let splits = txt.characters.split(separator: \" \").map(String.init)\n\
    \    return splits.count == 1 ? .success([String]()) : .failure(splits.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp74sd74ts.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let splits = txt.characters.split(separator: \" \"\
    ).map(String.init)\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split(txt).map({ $1.filter({ Character.isLetter($0) }) })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_285w0wj.swift:15:12: error: cannot find 'split' in scope\n   \
    \ return split(txt).map({ $1.filter({ Character.isLetter($0) }) })\n         \
    \  ^~~~~\n/tmp/tmp_285w0wj.swift:15:41: error: instance member 'isLetter' cannot\
    \ be used on type 'Character'; did you mean to use a value of this type instead?\n\
    \    return split(txt).map({ $1.filter({ Character.isLetter($0) }) })\n      \
    \                                  ^~~~~~~~~\n/tmp/tmp_285w0wj.swift:15:51: error:\
    \ cannot call value of non-function type 'Bool'\n    return split(txt).map({ $1.filter({\
    \ Character.isLetter($0) }) })\n                                             \
    \     ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let splits = txt.characters.split{$0 == \" \"}\n    if splits.count\
    \ == txt.characters.count {\n        return .success(splits)\n    } else {\n \
    \       return .failure(splits.count)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphl6ceij8.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let splits = txt.characters.split{$0 == \" \"}\n  \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphl6ceij8.swift:16:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    if splits.count == txt.characters.count {\n       \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphl6ceij8.swift:17:25: error: cannot convert value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to expected argument type '[String]'\n        return\
    \ .success(splits)\n                        ^\n/tmp/tmphl6ceij8.swift:17:25: note:\
    \ arguments to generic parameter 'Element' ('String.SubSequence' (aka 'Substring')\
    \ and 'String') are expected to be equal\n        return .success(splits)\n  \
    \                      ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let split = txt.split(separator: \" \").map(String.init)\n\
    \    if split.count == 0 {\n        return Err(Int(0))\n    }\n    \n    let split\
    \ = txt.split(separator: \",\").map(String.init)\n    if split.count == 0 {\n\
    \        return Err(Int(1))\n    }\n    \n    let split = txt.lowercaseString.split(separator:\
    \ \"\").map(String.init)\n    if split.count == 0 {\n        return Err(Int(2))\n\
    \    }\n    \n    let result = split.map(String.init)\n    \n    return Ok(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpynnsg1ar.swift:18:16: error: cannot find 'Err' in scope\n     \
    \   return Err(Int(0))\n               ^~~\n/tmp/tmpynnsg1ar.swift:21:9: error:\
    \ invalid redeclaration of 'split'\n    let split = txt.split(separator: \",\"\
    ).map(String.init)\n        ^\n/tmp/tmpynnsg1ar.swift:16:9: note: 'split' previously\
    \ declared here\n    let split = txt.split(separator: \" \").map(String.init)\n\
    \        ^\n/tmp/tmpynnsg1ar.swift:23:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(1))\n               ^~~\n/tmp/tmpynnsg1ar.swift:26:21:\
    \ error: value of type 'String' has no member 'lowercaseString'\n    let split\
    \ = txt.lowercaseString.split(separator: \"\").map(String.init)\n            \
    \    ~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpynnsg1ar.swift:28:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int(2))\n               ^~~\n/tmp/tmpynnsg1ar.swift:33:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let count = txt.characters.count\n\n    if count > 2 {\n       \
    \ let split = txt.characters.split{$0 == \",\"}\n        if split.count == 2 {\n\
    \            if split(1)[0] != \" \" {\n                let words = [split(0)[0],\
    \ split(1)[0]]\n                if let chars = split(1){\n                   \
    \ words.append(chars)\n                }\n                return .success(words)\n\
    \            } else {\n                let words = [split(0)[0], split(1)[1]]\n\
    \                if let chars = split(1){\n                    words.append(chars)\n\
    \                }\n                return .success(words)\n            }\n  \
    \      } else {\n            return .failure(count)\n        }\n    } else {\n\
    \        return .success(Array(txt.characters))\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptmbsff3e.swift:15:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let count = txt.characters.count\n                \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmptmbsff3e.swift:18:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ split = txt.characters.split{$0 == \",\"}\n                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmptmbsff3e.swift:20:16:\
    \ error: cannot call value of non-function type '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \            if split(1)[0] != \" \" {\n               ^\n/tmp/tmptmbsff3e.swift:21:30:\
    \ error: cannot call value of non-function type '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \                let words = [split(0)[0], split(1)[0]]\n                    \
    \         ^\n/tmp/tmptmbsff3e.swift:21:43: error: cannot call value of non-function\
    \ type '[String.SubSequence]' (aka 'Array<Substring>')\n                let words\
    \ = [split(0)[0], split(1)[0]]\n                                          ^\n\
    /tmp/tmptmbsff3e.swift:22:32: error: cannot call value of non-function type '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n                if let chars = split(1){\n       \
    \                        ^\n/tmp/tmptmbsff3e.swift:27:30: error: cannot call value\
    \ of non-function type '[String.SubSequence]' (aka 'Array<Substring>')\n     \
    \           let words = [split(0)[0], split(1)[1]]\n                         \
    \    ^\n/tmp/tmptmbsff3e.swift:27:43: error: cannot call value of non-function\
    \ type '[String.SubSequence]' (aka 'Array<Substring>')\n                let words\
    \ = [split(0)[0], split(1)[1]]\n                                          ^\n\
    /tmp/tmptmbsff3e.swift:28:32: error: cannot call value of non-function type '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n                if let chars = split(1){\n       \
    \                        ^\n/tmp/tmptmbs"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var words = [String]()\n    var currentWord = \"\"\n    for letter\
    \ in txt {\n        if letter != \" \" {\n            currentWord = currentWord\
    \ + letter\n        } else {\n            words.append(currentWord)\n        \
    \    currentWord = \"\"\n        }\n    }\n    if currentWord != \"\" {\n    \
    \    words.append(currentWord)\n    }\n    if let count = words.count {\n    \
    \    return Ok(words.enumerated().filter { $0.element! % 2 == 1 }).map { [Int]($0.element)\
    \ / count }\n    } else {\n        return Err(Int(bitPattern: 0))\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjcnrdhy0.swift:19:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            currentWord = currentWord +\
    \ letter\n                                        ^\n/tmp/tmpjcnrdhy0.swift:29:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(words.enumerated().filter\
    \ { $0.element! % 2 == 1 }).map { [Int]($0.element) / count }\n              \
    \ ^~\n/tmp/tmpjcnrdhy0.swift:29:57: error: cannot force unwrap value of non-optional\
    \ type 'String'\n        return Ok(words.enumerated().filter { $0.element! % 2\
    \ == 1 }).map { [Int]($0.element) / count }\n                                \
    \              ~~~~~~~~~~^\n                                                 \
    \       \n/tmp/tmpjcnrdhy0.swift:29:57: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        return Ok(words.enumerated().filter\
    \ { $0.element! % 2 == 1 }).map { [Int]($0.element) / count }\n              \
    \                                          ^\n/tmp/tmpjcnrdhy0.swift:29:77: error:\
    \ cannot convert value of type '[Int]' to expected argument type 'Int'\n     \
    \   return Ok(words.enumerated().filter { $0.element! % 2 == 1 }).map { [Int]($0.element)\
    \ / count }\n                                                                \
    \            ^\n/tmp/tmpjcnrdhy0.swift:31:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(bitPattern: 0))\n               ^~~\n/tmp/tmpjcnrdhy0.swift:28:8:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \    if let count = words.count {\n       ^           ~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.trimmingCharacters(in: .whitespaces)\n        .replacingOccurrences(of:\
    \ \",\", with: \" \", options: .caseInsensitive)\n        .lowercased()\n    return\
    \ words.components(separatedBy: .whitespaces)\n        .map { String(aceOf: $0)\
    \ }\n        .filter { $0.count % 2 == 1 }\n        .map { $0.reversed().first\
    \ }\n        .map { $0.uppercased() }\n        .map { String($0) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcu1awzbp.swift:15:21: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    let words = txt.trimmingCharacters(in: .whitespaces)\n\
    \                ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpcu1awzbp.swift:15:45: error:\
    \ cannot infer contextual base in reference to member 'whitespaces'\n    let words\
    \ = txt.trimmingCharacters(in: .whitespaces)\n                               \
    \            ~^~~~~~~~~~~\n/tmp/tmpcu1awzbp.swift:16:61: error: cannot infer contextual\
    \ base in reference to member 'caseInsensitive'\n        .replacingOccurrences(of:\
    \ \",\", with: \" \", options: .caseInsensitive)\n                           \
    \                                ~^~~~~~~~~~~~~~~\n/tmp/tmpcu1awzbp.swift:18:12:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n    return words.components(separatedBy:\
    \ .whitespaces)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054568
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.componentsSeparatedByString(\" \")\n    let letters\
    \ = txt.characters\n        .filter({$0 >= 'a' && $0 <= 'z'})\n        .filter({$0\
    \ >= 'a' && $0 <= 'z'})\n        .filter({$0 >= 'a' && $0 <= 'z'})\n        .filter({$0\
    \ >= 'a' && $0 <= 'z'})\n        .filter({$0 >= 'a' && $0 <= 'z'})\n        .filter({$0\
    \ >= 'a' && $0 <= 'z'})\n        .count\n    if letters % 2 != 0 {\n        return\
    \ .failure(letters / 2)\n    }\n    return .success(words)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpslj21pgf.swift:17:24: error: single-quoted string literal found,\
    \ use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n                      \
    \ ^~~\n                       \"a\"\n/tmp/tmpslj21pgf.swift:17:37: error: single-quoted\
    \ string literal found, use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n\
    \                                    ^~~\n                                   \
    \ \"z\"\n/tmp/tmpslj21pgf.swift:18:24: error: single-quoted string literal found,\
    \ use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n                      \
    \ ^~~\n                       \"a\"\n/tmp/tmpslj21pgf.swift:18:37: error: single-quoted\
    \ string literal found, use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n\
    \                                    ^~~\n                                   \
    \ \"z\"\n/tmp/tmpslj21pgf.swift:19:24: error: single-quoted string literal found,\
    \ use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n                      \
    \ ^~~\n                       \"a\"\n/tmp/tmpslj21pgf.swift:19:37: error: single-quoted\
    \ string literal found, use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n\
    \                                    ^~~\n                                   \
    \ \"z\"\n/tmp/tmpslj21pgf.swift:20:24: error: single-quoted string literal found,\
    \ use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n                      \
    \ ^~~\n                       \"a\"\n/tmp/tmpslj21pgf.swift:20:37: error: single-quoted\
    \ string literal found, use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n\
    \                                    ^~~\n                                   \
    \ \"z\"\n/tmp/tmpslj21pgf.swift:21:24: error: single-quoted string literal found,\
    \ use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n                      \
    \ ^~~\n                       \"a\"\n/tmp/tmpslj21pgf.swift:21:37: error: single-quoted\
    \ string literal found, use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n\
    \                                    ^~~\n                                   \
    \ \"z\"\n/tmp/tmpslj21pgf.swift:22:24: error: single-quoted string literal found,\
    \ use '\"'\n        .filter({$0 >= 'a' && $0 <= 'z'})\n                      \
    \ ^~"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let txtLowercase = txt.lowercased()\n    var countLetters = 0\n\
    \    for char in txtLowercase {\n        let code = char.ascii\n        if !((code\
    \ >= 97 && code <= 122) || (code >= 65 && code <= 90)) {\n            countLetters\
    \ += (code - 32)\n        }\n    }\n    let txtChars = txtLowercase.chars\n  \
    \  let txtRange = (txtChars.startIndex..<txtChars.endIndex)\n    var results =\
    \ [String]()\n    for range in txtRange {\n        let char = txtChars[range]\n\
    \        let code = (char.ascii).clamped(0, 25).lowerCase().bytes()\n        if\
    \ code != nil {\n            results.append(String(code))\n        }\n    }\n\
    \    if results.count == 0 { return .failure(countLetters) }\n    \n    let firstLetters\
    \ = results.count\n    let lastLetters = results.count - 1\n    \n    if results.count\
    \ % 2 == 0 {\n        return results[lastLetters..<firstLetters]\n    } else {\n\
    \        let evenNumbers = results.count / 2\n        return evenNumbers == 2\
    \ ? .success(results[lastLetters..<firstLetters]) : .failure(countLetters)\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpr0o30hcn.swift:18:25: error: value of type 'Character' has no member\
    \ 'ascii'\n        let code = char.ascii\n                   ~~~~ ^~~~~\n/tmp/tmpr0o30hcn.swift:23:33:\
    \ error: value of type 'String' has no member 'chars'\n    let txtChars = txtLowercase.chars\n\
    \                   ~~~~~~~~~~~~ ^~~~~\n/tmp/tmpr0o30hcn.swift:39:23: error: no\
    \ 'subscript' candidates produce the expected contextual result type 'Result<[String],\
    \ Int>'\n        return results[lastLetters..<firstLetters]\n                \
    \      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<String>',\
    \ not the expected contextual result type 'Result<[String], Int>'\n    @inlinable\
    \ public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n  \
    \                    ^\nSwift.Collection:2:23: note: 'subscript(_:)' produces\
    \ 'ArraySlice<String>', not the expected contextual result type 'Result<[String],\
    \ Int>'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R\
    \ : RangeExpression, Self.Index == R.Bound { get }\n                      ^\n\
    Swift.MutableCollection:2:23: note: 'subscript(_:)' produces '@lvalue ArraySlice<String>',\
    \ not the expected contextual result type 'Result<[String], Int>'\n    @inlinable\
    \ public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index\
    \ == R.Bound { get set }\n                      ^\n/tmp/tmpr0o30hcn.swift:42:51:\
    \ error: cannot convert value of type 'ArraySlice<String>' to expected argument\
    \ type '[String]'\n        return evenNumbers == 2 ? .success(results[lastLetters..<firstLetters])\
    \ : .failure(countLetters)\n                                                 \
    \ ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split_words(txt: txt, whitespace: \"\")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2rd7zo94.swift:15:46: error: extra argument 'whitespace' in call\n\
    \    return split_words(txt: txt, whitespace: \"\")\n                      ~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: .whitespacesAndNewlines)\n\
    \    var split = words.count\n\n    if words.count % 2 == 1 {\n        split +=\
    \ 2\n    }\n\n    if words.count % 2 == 0 {\n        split += 2\n        split\
    \ += 4\n    }\n\n    if split < 2 {\n        return .failure(1)\n    }\n\n   \
    \ let letters = words.map({\n        ($0.lowercased() ?? \"\").count\n    })\n\
    \    \n    if letters.count % 2 == 1 {\n        return .failure(letters.count)\n\
    \    }\n\n    guard let letters = letters else {\n        return .failure(1)\n\
    \    }\n\n    if letters.count == 0 {\n        return .success([\"1\"])\n    }\n\
    \n    guard letters.count == letters.max() else {\n        return .failure(1)\n\
    \    }\n\n    let count = letters.reduce(0) { (sum, current) -> Int in\n     \
    \   sum += current\n        return sum\n    }\n\n    return .success(Array(letters[0...count]))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp09zsyoty.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: .whitespacesAndNewlines)\n\
    \                ~~~ ^~~~~~~~~~\n/tmp/tmp09zsyoty.swift:15:46: error: cannot infer\
    \ contextual base in reference to member 'whitespacesAndNewlines'\n    let words\
    \ = txt.components(separatedBy: .whitespacesAndNewlines)\n                   \
    \                         ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = split(txt, \" \")\n    if words.count == 1 {\n     \
    \   return .success(words)\n    } else {\n        let sep = words[1]\n       \
    \ if let separator = sep.unicodeScalars.first {\n            return .success(split(txt,\
    \ separator))\n        } else {\n            return .failure(Int(\"0\"))\n   \
    \     }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqr3hkyrc.swift:15:17: error: cannot find 'split' in scope\n   \
    \ let words = split(txt, \" \")\n                ^~~~~\n/tmp/tmpqr3hkyrc.swift:21:29:\
    \ error: cannot find 'split' in scope\n            return .success(split(txt,\
    \ separator))\n                            ^~~~~\n/tmp/tmpqr3hkyrc.swift:23:29:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            return .failure(Int(\"0\"))\n                            ^\n/tmp/tmpqr3hkyrc.swift:23:29:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            return .failure(Int(\"0\"))\n                           \
    \ ^\n                                     ?? <#default value#>\n/tmp/tmpqr3hkyrc.swift:23:29:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            return .failure(Int(\"0\"))\n                           \
    \ ^\n                                    !\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let string = txt.data(using: String.Encoding.utf8) else {\
    \ return .failure(3) }\n    var words = string.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \    words = words.filter { !$0.isEmpty}\n    words = words.map { $0.lowercased().replacingOccurrences(of:\
    \ \",\", with: \" \")}\n    words = words.filter { !words.contains($0)}\n    return\
    \ words.count == 0 ? .success([]) : .success(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5c9esgy_.swift:15:28: error: value of type 'String' has no member\
    \ 'data'\n    guard let string = txt.data(using: String.Encoding.utf8) else {\
    \ return .failure(3) }\n                       ~~~ ^~~~\n/tmp/tmp5c9esgy_.swift:15:47:\
    \ error: type 'String' has no member 'Encoding'\n    guard let string = txt.data(using:\
    \ String.Encoding.utf8) else { return .failure(3) }\n                        \
    \               ~~~~~~ ^~~~~~~~\n/tmp/tmp5c9esgy_.swift:16:48: error: cannot find\
    \ 'CharacterSet' in scope\n    var words = string.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \                                               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Err(Int(bitPattern: 1 << 25))\n    }\n    var arr = [String]()\n\
    \    words.forEach { word in\n        if word.rangeOfCharacter(from: .whitespaces,\
    \ options: .anchored) == nil &&\n           word.rangeOfCharacter(from: \",\"\
    , options: .anchored) == nil {\n            arr.append(word.lowercased())\n  \
    \      } else {\n            return Err(Int(bitPattern: 1 << 25))\n        }\n\
    \    }\n    return Ok(arr)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9oebiw62.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp9oebiw62.swift:16:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int(bitPattern: 1 << 25))\n \
    \              ^~~\n/tmp/tmp9oebiw62.swift:24:20: error: cannot find 'Err' in\
    \ scope\n            return Err(Int(bitPattern: 1 << 25))\n                  \
    \ ^~~\n/tmp/tmp9oebiw62.swift:27:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(arr)\n           ^~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return .success(txt.lowercaseString.split(\" \").map(String).filter({\
    \ !$0.isEmpty }))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb5joqlbk.swift:15:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    return .success(txt.lowercaseString.split(\" \").map(String).filter({\
    \ !$0.isEmpty }))\n                    ~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    let result =\
    \ [String]()\n    for word in words {\n        if word != \"\" {\n           \
    \ result += word.components(separatedBy: \",\")\n        }\n    }\n    let evenLettersCount\
    \ = 0\n    for word in result {\n        let letters = word.unicodeScalars.filter\
    \ { $0.isLower }.count\n        if letters.isMultiple(of: 2) {\n            evenLettersCount\
    \ += letters\n        } else {\n            return .failure(letters)\n       \
    \ }\n    }\n    if evenLettersCount == 0 {\n        return .success(result)\n\
    \    } else {\n        return .success(result[0..<(evenLettersCount-1)])\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp81qt5i6h.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp81qt5i6h.swift:24:55: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLower'\n        let letters = word.unicodeScalars.filter {\
    \ $0.isLower }.count\n                                                   ~~ ^~~~~~~\n\
    /tmp/tmp81qt5i6h.swift:34:31: error: cannot convert value of type 'ArraySlice<String>'\
    \ to expected argument type '[String]'\n        return .success(result[0..<(evenLettersCount-1)])\n\
    \                              ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard !words.isEmpty\
    \ else {\n        return .failure(100)\n    }\n    \n    let uppercase = words.filter{$0.uppercased()\
    \ != \"\"}\n    guard !uppercase.isEmpty else {\n        return .failure(101)\n\
    \    }\n    \n    let lettersOdd = uppercase.filter{$0.unicodeScalars.filter{$0.value\
    \ % 2 != 0}.count == 0}\n    guard !lettersOdd.isEmpty else {\n        return\
    \ .failure(102)\n    }\n    \n    let allLetters = uppercase.flatMap{$0.unicodeScalars.filter{$0.value\
    \ >= 97 && $0.value <= 122}}\n    guard !allLetters.isEmpty else {\n        return\
    \ .failure(103)\n    }\n    \n    return .success(allLetters.map{ String(cString:\
    \ $0.value) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmr1efswe.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".chars()\n    .map\
    \ { String($0) }\n    .sorted()\n    .map { $0.lowercased() }\n    .filter({ $0.isWhitespace\
    \ == false && $0.isNotEmpty == true })\n    .enumerated()\n    .map { $0.element\
    \ }\n    .map { Int($0) }\n    \n    guard let numberOfLetters = alphabet.count\
    \ else {\n        return .failure(Int(numberOfLetters))\n    }\n    \n    guard\
    \ numberOfLetters.isOdd else {\n        return .failure(Int(numberOfLetters))\n\
    \    }\n    \n    if txt.characters.count == 0 {\n        return .failure(0)\n\
    \    }\n    \n    let splittedText = txt.characters\n    .split(separator: \"\
    \ \")\n    .flatMap { $0 }\n    .reduce([]) { $0 += $1 }\n    \n    guard splittedText.count\
    \ > 1 else {\n        return .failure(Int(numberOfLetters))\n    }\n    \n   \
    \ let words = splittedText.map { String($0) }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7xeu4d5h.swift:15:20: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".chars()\n\
    \                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7xeu4d5h.swift:25:29:\
    \ error: cannot find 'numberOfLetters' in scope\n        return .failure(Int(numberOfLetters))\n\
    \                            ^~~~~~~~~~~~~~~\n/tmp/tmp7xeu4d5h.swift:32:12: error:\
    \ 'characters' is unavailable: Please use String directly\n    if txt.characters.count\
    \ == 0 {\n           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7xeu4d5h.swift:39:12: error: missing argument label 'into:' in call\n\
    \    .reduce([]) { $0 += $1 }\n           ^\n            into: \n"
  stdout: ''
  timestamp: 1660054564
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return Result.value(\n        [String]()\n            .split_words(txt:\
    \ txt, delimiter: \" \", omittingEmptySpaces: true)\n            .map { $0.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) }\n            .filter { !$0.isEmpty }\n          \
    \  .map { String(_).lowercased().split(separator: \",\").flatMap { $0.filter{$0\
    \ != \",\"} }.count\n        })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgmiiu_2u.swift:20:27: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            .map { String(_).lowercased().split(separator:\
    \ \",\").flatMap { $0.filter{$0 != \",\"} }.count\n                          ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if let words = txt.components(separatedBy: \" \").filter({ !$0.isEmpty\
    \ }), words.count == words.filter({ $0.isEmpty }).count {\n        return .success(words)\n\
    \    } else {\n        return .failure(Int(words.count) - 1)\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpw367dpbq.swift:15:24: error: value of type 'String' has no member\
    \ 'components'\n    if let words = txt.components(separatedBy: \" \").filter({\
    \ !$0.isEmpty }), words.count == words.filter({ $0.isEmpty }).count {\n      \
    \             ~~~ ^~~~~~~~~~\n/tmp/tmpw367dpbq.swift:18:29: error: cannot find\
    \ 'words' in scope\n        return .failure(Int(words.count) - 1)\n          \
    \                  ^~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if txt.isEmpty {\n        return .failure(3)\n    }\n    let lowLetters:\
    \ Int = String\n        .lowercase()\n        .filter({ $0 != \"a\" && $0 != \"\
    b\" && $0 != \"c\" && $0 != \"d\" && $0 != \"e\" && $0 != \"f\" && $0 != \"g\"\
    \ && $0 != \"h\" && $0 != \"i\" && $0 != \"j\" && $0 != \"k\" && $0 != \"l\" &&\
    \ $0 != \"m\" && $0 != \"n\" && $0 != \"o\" && $0 != \"p\" && $0 != \"q\" && $0\
    \ != \"r\" && $0 != \"s\" && $0 != \"t\" && $0 != \"u\" && $0 != \"v\" && $0 !=\
    \ \"w\" && $0 != \"x\" && $0 != \"y\" && $0 != \"z\" })\n        .count\n\n  \
    \  // If there are commas in the text, split on commas, otherwise\n    // split\
    \ the text on spaces (if there are spaces, just count the lower-cased letters)\n\
    \    if txt.hasPrefix(\",\") {\n        let splitString = txt.components(separatedBy:\
    \ \",\").map { $0.trimmingCharacters(in: .whitespaces) }\n        return .success(splitString)\n\
    \    } else {\n        let splitString = txt.components(separatedBy: \" \").map\
    \ { $0.trimmingCharacters(in: .whitespaces) }\n        return .success(splitString.count/lowLetters)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9srfm5k6.swift:18:27: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let lowLetters: Int = String\n                        \
    \  ^~~~~~\n/tmp/tmp9srfm5k6.swift:26:31: error: value of type 'String' has no\
    \ member 'components'\n        let splitString = txt.components(separatedBy: \"\
    ,\").map { $0.trimmingCharacters(in: .whitespaces) }\n                       \
    \   ~~~ ^~~~~~~~~~\n/tmp/tmp9srfm5k6.swift:26:93: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n        let splitString = txt.components(separatedBy:\
    \ \",\").map { $0.trimmingCharacters(in: .whitespaces) }\n                   \
    \                                                                        ~^~~~~~~~~~~\n\
    /tmp/tmp9srfm5k6.swift:29:31: error: value of type 'String' has no member 'components'\n\
    \        let splitString = txt.components(separatedBy: \" \").map { $0.trimmingCharacters(in:\
    \ .whitespaces) }\n                          ~~~ ^~~~~~~~~~\n/tmp/tmp9srfm5k6.swift:29:93:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \       let splitString = txt.components(separatedBy: \" \").map { $0.trimmingCharacters(in:\
    \ .whitespaces) }\n                                                          \
    \                                 ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054600
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var letters: [Character] = []\n    var lowercaseLetterCount = 0\n\
    \    var uppercaseLetterCount = 0\n    \n    for char in txt {\n        guard\
    \ char.unicodeScalars.isEmpty,\n            let unicodeScalar = char.unicodeScalars.first,\n\
    \            let value = unicodeScalar.value\n        else {\n            return\
    \ .failure(Int(char.unicodeScalars.count))\n        }\n        \n        guard\
    \ value < CharacterUnicodeCategory.lowerCaseA.value else { return .failure(Int(UnicodeScalar(unicodeScalar.value)))\
    \ }\n        lowercaseLetterCount += 1 \n        guard value > CharacterUnicodeCategory.upperCaseA.value\
    \ else { return .failure(Int(UnicodeScalar(unicodeScalar.value))) }\n        uppercaseLetterCount\
    \ += 1\n        \n        if char == ',' {\n            letters.append(CharacterUnicodeCategory.spaceSeparator)\n\
    \        }\n        \n        if char == ' ' {\n            letters.append(CharacterUnicodeCategory.spaceSeparator)\n\
    \        }\n        \n        if char == '\\t' {\n            letters.append(CharacterUnicodeCategory.tabulation)\n\
    \        }\n        \n        if char == '\\r' {\n            letters.append(CharacterUnicodeCategory.lineSeparator)\n\
    \        }\n        \n        if char == '\\n' {\n            letters.append(CharacterUnicodeCategory.lineSeparator)\n\
    \        }\n        \n        if char == '\\\\' {\n            letters.append(CharacterUnicodeCategory.backslash)\n\
    \        }\n        \n        if char == '\"' {\n            letters.append(CharacterUnicodeCategory.doubleQuote)\n\
    \        }\n        \n        if char == '\\'' {\n            letters.append(CharacterUnicodeCategory.singleQuote)\n\
    \        }\n        \n        if char == '&' {\n            letters.append(CharacterUnicodeCategory.ampersand)\n\
    \        }\n        \n        if char == '!' {\n            letters.append(CharacterUnicodeCategory.exclamation)\n\
    \        }\n        \n        if char == '/' {\n            letters.append(CharacterUnicodeCategory.slash)\n\
    \        }\n        \n        if char == ',' {\n            letters.append(CharacterUnicodeCategory.comma)\n\
    \        }\n        \n        if char == ':' {\n            letters.append(CharacterUnicodeCategory.colon)\n\
    \        }\n        \n        if char == '-' {\n            letters.append(CharacterUnicodeCategory.hyphen)\n\
    \        }\n        \n        if char == '.' {\n            letters.append(CharacterUnicodeCategory.dot)\n\
    \        }\n        \n        if char == '|' {\n            letters.append(CharacterUnicodeCategory.verticalBar)\n\
    \        }\n        \n        if char == '?' {\n            letters.append(CharacterUnicodeCategory.question)\n\
    \        }\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpeejtfqco.swift:32:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ',' {\n                   ^~~\n               \
    \    \",\"\n/tmp/tmpeejtfqco.swift:36:20: error: single-quoted string literal\
    \ found, use '\"'\n        if char == ' ' {\n                   ^~~\n        \
    \           \" \"\n/tmp/tmpeejtfqco.swift:40:20: error: single-quoted string literal\
    \ found, use '\"'\n        if char == '\\t' {\n                   ^~~~\n     \
    \              \"\\t\"\n/tmp/tmpeejtfqco.swift:44:20: error: single-quoted string\
    \ literal found, use '\"'\n        if char == '\\r' {\n                   ^~~~\n\
    \                   \"\\r\"\n/tmp/tmpeejtfqco.swift:48:20: error: single-quoted\
    \ string literal found, use '\"'\n        if char == '\\n' {\n               \
    \    ^~~~\n                   \"\\n\"\n/tmp/tmpeejtfqco.swift:52:20: error: single-quoted\
    \ string literal found, use '\"'\n        if char == '\\\\' {\n              \
    \     ^~~~\n                   \"\\\\\"\n/tmp/tmpeejtfqco.swift:56:20: error:\
    \ single-quoted string literal found, use '\"'\n        if char == '\"' {\n  \
    \                 ^~~\n                   \"\\\"\"\n/tmp/tmpeejtfqco.swift:60:20:\
    \ error: single-quoted string literal found, use '\"'\n        if char == '\\\
    '' {\n                   ^~~~\n                   \"'\"\n/tmp/tmpeejtfqco.swift:64:20:\
    \ error: single-quoted string literal found, use '\"'\n        if char == '&'\
    \ {\n                   ^~~\n                   \"&\"\n/tmp/tmpeejtfqco.swift:68:20:\
    \ error: single-quoted string literal found, use '\"'\n        if char == '!'\
    \ {\n                   ^~~\n                   \"!\"\n/tmp/tmpeejtfqco.swift:72:20:\
    \ error: single-quoted string literal found, use '\"'\n        if char == '/'\
    \ {\n                   ^~~\n                   \"/\"\n/tmp/tmpeejtfqco.swift:76:20:\
    \ error: single-quoted string literal found, use '\"'\n        if char == ','\
    \ {\n                   ^~~\n                   \",\"\n/tmp/tmpeejtfqco.swift:80:20:\
    \ error: single-quoted string literal found, use '\"'\n        if char == ':'\
    \ {\n                   ^~~\n                   \":\"\n/tmp/tmpeejtfqco.swift:84:20:\
    \ error: single-quoted string"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let chars = txt.characters\n    if chars.count > 0 {\n   \
    \     let first = chars[0]\n        \n        if let firstIsWhitespace = first.isWhitespace\
    \ {\n            if chars.count == 1 {\n                return .failure(0)\n \
    \           }\n            \n            if first.isEmpty {\n                return\
    \ .failure(1)\n            }\n            \n            let result = chars\n \
    \               .dropFirst()\n                .filter{\n                    return\
    \ !$0.isWhitespace && $0.isLetter\n                }\n                .map(String.init)\n\
    \                .map(String.init)\n                .joinWithSeparator(\",\")\n\
    \                .lowercased()\n            \n            guard !result.isEmpty\
    \ else {\n                return .failure(result.count)\n            }\n     \
    \       \n            return .success(result)\n        }\n        \n        if\
    \ let firstIsComma = first.isComma {\n            if chars.count == 1 {\n    \
    \            return .failure(0)\n            }\n            \n            if first.isEmpty\
    \ {\n                return .failure(1)\n            }\n            \n       \
    \     let result = chars\n                .dropFirst()\n                .filter{\n\
    \                    return $0.isWhitespace || $0.isComma\n                }\n\
    \                .map(String.init)\n                .map(String.init)\n      \
    \          .joinWithSeparator(\",\")\n                .lowercased()\n        \
    \    \n            guard !result.isEmpty else {\n                return .failure(result.count)\n\
    \            }\n            \n            return .success(result)\n        }\n\
    \        \n        if chars.count == 1 {\n            let result = chars\n   \
    \             .dropFirst()\n                .filter{\n                    return\
    \ $0.isWhitespace || $0.isComma || $0.isLetter\n                }\n          \
    \      .map(String.init)\n                .map(String.init)\n                .joinWithSeparator(\"\
    ,\")\n                .lowercased()\n            \n            guard !result.isEmpty\
    \ else {\n                return .failure(result.count)\n            }\n     \
    \       \n            return .success(result)\n        }\n    }\n    \n    return\
    \ .failure(0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfujmqhjj.swift:16:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = txt.characters\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpfujmqhjj.swift:18:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let first = chars[0]\n                \
    \    ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpfujmqhjj.swift:25:22: error: value of type 'Character' has no\
    \ member 'isEmpty'\n            if first.isEmpty {\n               ~~~~~ ^~~~~~~\n\
    /tmp/tmpfujmqhjj.swift:36:18: error: reference to member 'joinWithSeparator' cannot\
    \ be resolved without a contextual type\n                .joinWithSeparator(\"\
    ,\")\n                 ^\n/tmp/tmpfujmqhjj.swift:20:12: error: initializer for\
    \ conditional binding must have Optional type, not 'Bool'\n        if let firstIsWhitespace\
    \ = first.isWhitespace {\n           ^                       ~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfujmqhjj.swift:46:37: error: value of type 'Character' has no member 'isComma'\n\
    \        if let firstIsComma = first.isComma {\n                             \
    \ ~~~~~ ^~~~~~~\n/tmp/tmpfujmqhjj.swift:51:22: error: value of type 'Character'\
    \ has no member 'isEmpty'\n            if first.isEmpty {\n               ~~~~~\
    \ ^~~~~~~\n/tmp/tmpfujmqhjj.swift:58:50: error: value of type 'DropFirstSequence<String>.Element'\
    \ (aka 'Character') has no member 'isComma'\n                    return $0.isWhitespace\
    \ || $0.isComma\n                                              ~~ ^~~~~~~\n/tmp/tmpfujmqhjj.swift:62:18:\
    \ error: reference to member 'joinWithSeparator' cannot be resolved without a\
    \ contextual type\n                .joinWithSeparator(\",\")\n               \
    \  ^\n/tmp/tmpfujmqhjj.swift:76:50: error: value of type 'DropFirstSequence<String>.Element'\
    \ (aka 'Character') has no member 'isComma'\n "
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.characters.split{$0 == \" \" || $0 == \",\"}\n \
    \   return words.count == words.filter({ $0 != \"\" }).count ? .success(words)\
    \ : .failure(words.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_jn2ylp7.swift:15:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let words = txt.characters.split{$0 == \" \" || $0\
    \ == \",\"}\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_jn2ylp7.swift:16:71: error: cannot convert value of\
    \ type '[String.SubSequence]' (aka 'Array<Substring>') to expected argument type\
    \ '[String]'\n    return words.count == words.filter({ $0 != \"\" }).count ? .success(words)\
    \ : .failure(words.count)\n                                                  \
    \                    ^\n/tmp/tmp_jn2ylp7.swift:16:71: note: arguments to generic\
    \ parameter 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are\
    \ expected to be equal\n    return words.count == words.filter({ $0 != \"\" }).count\
    \ ? .success(words) : .failure(words.count)\n                                \
    \                                      ^\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.split(separator: \" \")\n    if words.count == 0\
    \ {\n        return .failure(NSNumberFormatter().number(from: txt).intValue)\n\
    \    }\n    if words.count != 1 || (words[0].isEmpty && !words[0].contains(\"\
    ,\")) {\n        return .failure(NSNumberFormatter().number(from: txt).intValue)\n\
    \    }\n    let first = words[0]\n    let last = words.last!\n    let upperLetters\
    \ = first.characters.filter{ $0 >= 'a' && $0 <= 'z'}.count\n    let upperLettersOdd\
    \ = upperLetters % 2\n    if last.contains(\",\") {\n        return .success(last.components(separatedBy:\
    \ \",\").map{ $0.trimmingCharacters(in: .whitespaces) ?? \"\"})\n    } else if\
    \ last.characters.count == 1 {\n        return .success(first)\n    } else {\n\
    \        if upperLettersOdd == 1 && last.lowercaseString.count % 2 == 1 {\n  \
    \          return .success(last.lowercaseString.characters.filter{ $0 >= 'a' &&\
    \ $0 <= 'z' && !$0.isDigit}.map{ $0.trimmingCharacters(in: .whitespaces) ?? \"\
    \"})\n        }\n        let digits = last.lowercaseString.characters.filter{\
    \ $0.isDigit}\n        if digits.count != 0 {\n            return .success(digits.components(separatedBy:\
    \ \",\").map{ $0.trimmingCharacters(in: .whitespaces) ?? \"\"})\n        }\n \
    \       return .success(last.characters.filter{ $0 >= 'a' && $0 <= 'z' && !$0.isDigit}.map{\
    \ $0.trimmingCharacters(in: .whitespaces) ?? \"\"})\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpot11w8tj.swift:24:55: error: single-quoted string literal found,\
    \ use '\"'\n    let upperLetters = first.characters.filter{ $0 >= 'a' && $0 <=\
    \ 'z'}.count\n                                                      ^~~\n    \
    \                                                  \"a\"\n/tmp/tmpot11w8tj.swift:24:68:\
    \ error: single-quoted string literal found, use '\"'\n    let upperLetters =\
    \ first.characters.filter{ $0 >= 'a' && $0 <= 'z'}.count\n                   \
    \                                                ^~~\n                       \
    \                                            \"z\"\n/tmp/tmpot11w8tj.swift:32:75:\
    \ error: single-quoted string literal found, use '\"'\n            return .success(last.lowercaseString.characters.filter{\
    \ $0 >= 'a' && $0 <= 'z' && !$0.isDigit}.map{ $0.trimmingCharacters(in: .whitespaces)\
    \ ?? \"\"})\n                                                                \
    \          ^~~\n                                                             \
    \             \"a\"\n/tmp/tmpot11w8tj.swift:32:88: error: single-quoted string\
    \ literal found, use '\"'\n            return .success(last.lowercaseString.characters.filter{\
    \ $0 >= 'a' && $0 <= 'z' && !$0.isDigit}.map{ $0.trimmingCharacters(in: .whitespaces)\
    \ ?? \"\"})\n                                                                \
    \                       ^~~\n                                                \
    \                                       \"z\"\n/tmp/tmpot11w8tj.swift:38:55: error:\
    \ single-quoted string literal found, use '\"'\n        return .success(last.characters.filter{\
    \ $0 >= 'a' && $0 <= 'z' && !$0.isDigit}.map{ $0.trimmingCharacters(in: .whitespaces)\
    \ ?? \"\"})\n                                                      ^~~\n     \
    \                                                 \"a\"\n/tmp/tmpot11w8tj.swift:38:68:\
    \ error: single-quoted string literal found, use '\"'\n        return .success(last.characters.filter{\
    \ $0 >= 'a' && $0 <= 'z' && !$0.isDigit}.map{ $0.trimmingCharacters(in: .whitespaces)\
    \ ?? \"\"})\n                                                                \
    \   ^~~\n                       "
  stdout: ''
  timestamp: 1660054565
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let txt = txt.trimmingCharacters(in: .whitespaces)\n    if txt.isEmpty\
    \ {\n        return .failure(0)\n    }\n    let words: [String] = txt.components(separatedBy:\
    \ .whitespaces)\n    var numWords = 0\n    for word in words {\n        if word.count\
    \ > 0 && word.isEmpty == false {\n            if let c = word.unicodeScalars.last\
    \ {\n                let isLetter = Int(c) < ord('z') || Int(c) > ord('a')\n \
    \               if isLetter == true {\n                    numWords += 1\n   \
    \             }\n            }\n        }\n    }\n    if numWords == 0 && numWords\
    \ == 1 {\n        if words[0].count > 0 && words[0].isEmpty == false {\n     \
    \       if let c = words[0].unicodeScalars.last {\n                let isLetter\
    \ = Int(c) < ord('z') || Int(c) > ord('a')\n                if isLetter == true\
    \ {\n                    numWords += 1\n                }\n            }\n   \
    \     }\n    }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdrapckhm.swift:24:45: error: single-quoted string literal found,\
    \ use '\"'\n                let isLetter = Int(c) < ord('z') || Int(c) > ord('a')\n\
    \                                            ^~~\n                           \
    \                 \"z\"\n/tmp/tmpdrapckhm.swift:24:66: error: single-quoted string\
    \ literal found, use '\"'\n                let isLetter = Int(c) < ord('z') ||\
    \ Int(c) > ord('a')\n                                                        \
    \         ^~~\n                                                              \
    \   \"a\"\n/tmp/tmpdrapckhm.swift:34:45: error: single-quoted string literal found,\
    \ use '\"'\n                let isLetter = Int(c) < ord('z') || Int(c) > ord('a')\n\
    \                                            ^~~\n                           \
    \                 \"z\"\n/tmp/tmpdrapckhm.swift:34:66: error: single-quoted string\
    \ literal found, use '\"'\n                let isLetter = Int(c) < ord('z') ||\
    \ Int(c) > ord('a')\n                                                        \
    \         ^~~\n                                                              \
    \   \"a\"\n/tmp/tmpdrapckhm.swift:15:19: error: value of type 'String' has no\
    \ member 'trimmingCharacters'\n    let txt = txt.trimmingCharacters(in: .whitespaces)\n\
    \              ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpdrapckhm.swift:15:43: error: cannot\
    \ infer contextual base in reference to member 'whitespaces'\n    let txt = txt.trimmingCharacters(in:\
    \ .whitespaces)\n                                         ~^~~~~~~~~~~\n/tmp/tmpdrapckhm.swift:19:56:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   let words: [String] = txt.components(separatedBy: .whitespaces)\n        \
    \                                              ~^~~~~~~~~~~\n/tmp/tmpdrapckhm.swift:24:41:\
    \ error: cannot find 'ord' in scope\n                let isLetter = Int(c) < ord('z')\
    \ || Int(c) > ord('a')\n                                        ^~~\n/tmp/tmpdrapckhm.swift:24:62:\
    \ error: cannot find 'ord' in scope\n                let isLetter = Int(c) < ord('z')\
    \ || Int(c) > ord('a')\n                           "
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let wordCount: Int = txt.countElements(separatedBy: \" \")\n   \
    \ \n    if wordCount == 0 {\n        return .failure(3)\n    }\n    \n    var\
    \ words = [String]()\n    \n    for i in 0..<wordCount {\n        let word: String\
    \ = txt.substring(with: NSRange.init(location: i, length: 1))\n        let wordLower\
    \ = word.lowercased()\n        let found: Bool = words.contains(wordLower)\n \
    \       if found {\n            words.append(wordLower)\n        }\n        else\
    \ {\n            if word == \",\" {\n                words.append(word)\n    \
    \        }\n            else {\n                return .failure(wordCount)\n \
    \           }\n        }\n    }\n    \n    if words[0] == \"\" {\n        words.removeFirst()\n\
    \    }\n    \n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxkyd3yu2.swift:15:30: error: value of type 'String' has no member\
    \ 'countElements'\n    let wordCount: Int = txt.countElements(separatedBy: \"\
    \ \")\n                         ~~~ ^~~~~~~~~~~~~\n/tmp/tmpxkyd3yu2.swift:24:48:\
    \ error: cannot find 'NSRange' in scope\n        let word: String = txt.substring(with:\
    \ NSRange.init(location: i, length: 1))\n                                    \
    \           ^~~~~~~\n/tmp/tmpxkyd3yu2.swift:24:32: error: value of type 'String'\
    \ has no member 'substring'\n        let word: String = txt.substring(with: NSRange.init(location:\
    \ i, length: 1))\n                           ~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.characters.split(separator: \" \")\n    if words.isEmpty\
    \ { return .failure(0) }\n    if words.count == 1 { return .success(words) }\n\
    \    var arr = [String]()\n    for word in words {\n        guard let letters\
    \ = word.characters.split(separator: \",\").map(String.init) else { return .failure(0)\
    \ }\n        arr += letters\n    }\n    return .success(arr)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb0k1zlal.swift:15:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let words = txt.characters.split(separator: \" \")\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpb0k1zlal.swift:17:43: error: cannot convert value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to expected argument type '[String]'\n    if words.count\
    \ == 1 { return .success(words) }\n                                          ^\n\
    /tmp/tmpb0k1zlal.swift:17:43: note: arguments to generic parameter 'Element' ('String.SubSequence'\
    \ (aka 'Substring') and 'String') are expected to be equal\n    if words.count\
    \ == 1 { return .success(words) }\n                                          ^\n\
    /tmp/tmpb0k1zlal.swift:20:34: error: 'characters' is unavailable: Please use Substring\
    \ directly\n        guard let letters = word.characters.split(separator: \",\"\
    ).map(String.init) else { return .failure(0) }\n                             \
    \    ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: Substring { get set }\n               ^\n/tmp/tmpb0k1zlal.swift:20:15:\
    \ error: initializer for conditional binding must have Optional type, not '[String]'\n\
    \        guard let letters = word.characters.split(separator: \",\").map(String.init)\
    \ else { return .failure(0) }\n              ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let regex = try? NSRegularExpression(pattern: \"\\\\s\", options:\
    \ []) else {\n        return Result.failure(1)\n    }\n    \n    let words = regex.matches(in:\
    \ txt, options: [], range: NSMakeRange(0, txt.count)).map { result in\n      \
    \  guard let range = result.range, let substring = txt.substring(with: range)\
    \ else {\n            return nil\n        }\n        return substring\n    }\n\
    \    \n    let alphabet = Array(1...26).map { String($0) }\n    \n    guard words.count\
    \ == txt.characters.count else {\n        return Result.failure(1)\n    }\n  \
    \  \n    var output = [String]()\n    \n    for word in words {\n        if let\
    \ word = word,\n            let letters = word.characters.filter({ alphabet.contains(String($0))\
    \ }).sorted() {\n            var foundLetters = 0\n            for letter in letters\
    \ {\n                if letters.count % 2 == 1 && (letter - 'a') < 26 {\n    \
    \                foundLetters += 1\n                }\n            }\n       \
    \     \n            output.append(foundLetters.isOdd ? \"even\" : \"odd\")\n \
    \           output.append(letter)\n        }\n    }\n    \n    return Result.success(output)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgii3elfn.swift:39:56: error: single-quoted string literal found,\
    \ use '\"'\n                if letters.count % 2 == 1 && (letter - 'a') < 26 {\n\
    \                                                       ^~~\n                \
    \                                       \"a\"\n/tmp/tmpgii3elfn.swift:15:28: error:\
    \ cannot find 'NSRegularExpression' in scope\n    guard let regex = try? NSRegularExpression(pattern:\
    \ \"\\\\s\", options: []) else {\n                           ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgii3elfn.swift:19:60: error: cannot find 'NSMakeRange' in scope\n    let\
    \ words = regex.matches(in: txt, options: [], range: NSMakeRange(0, txt.count)).map\
    \ { result in\n                                                           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    // 1\n    // 1\n    // 1\n    \n    var arr = [String]()\n\
    \    \n    guard let s = txt.asCharactersInsensitive().flatMap({ String($0) })\
    \ else {\n        return Result.failure(3)\n    }\n    \n    // 2\n    // 2\n\
    \    // 2\n    \n    let r = s.count\n    \n    // 3\n    // 3\n    \n    for\
    \ i in 0 ..< r {\n        \n        guard let c = s[i] {\n            \n     \
    \       if i == r - 1 {\n                \n                return Result.failure(3)\n\
    \            }\n            \n            return Result.failure(4)\n        }\n\
    \        \n        arr.append(String(c))\n    }\n    \n    // 4\n    \n    return\
    \ Result.success(arr)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprsjr2vyo.swift:37:28: error: expected 'else' after 'guard' condition\n\
    \        guard let c = s[i] {\n                           ^\n                \
    \           else \n/tmp/tmprsjr2vyo.swift:22:23: error: value of type 'String'\
    \ has no member 'asCharactersInsensitive'\n    guard let s = txt.asCharactersInsensitive().flatMap({\
    \ String($0) }) else {\n                  ~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let regex = try! NSRegularExpression(pattern: \"[\\\\s,]+\")\n \
    \   let matches = regex.matches(in: txt, range: NSMakeRange(0, txt.length))\n\
    \    guard !matches.isEmpty else {\n        return .failure(Int(kErrorCodeInvalidText))\n\
    \    }\n    let range: NSRange = matches.first!.range\n    guard let start = txt.index(txt.startIndex,\
    \ offsetBy: range.lowerBound),\n        let end = txt.index(txt.startIndex, offsetBy:\
    \ range.upperBound) else {\n        return .failure(Int(kErrorCodeInvalidText))\n\
    \    }\n    return .success((txt[start..<end]).components(separatedBy: \" \").map\
    \ { $0.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines) })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpetdmz8t5.swift:15:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"[\\\\s,]+\")\n\
    \                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpetdmz8t5.swift:16:49: error:\
    \ cannot find 'NSMakeRange' in scope\n    let matches = regex.matches(in: txt,\
    \ range: NSMakeRange(0, txt.length))\n                                       \
    \         ^~~~~~~~~~~\n/tmp/tmpetdmz8t5.swift:16:68: error: value of type 'String'\
    \ has no member 'length'\n    let matches = regex.matches(in: txt, range: NSMakeRange(0,\
    \ txt.length))\n                                                             \
    \  ~~~ ^~~~~~\n/tmp/tmpetdmz8t5.swift:18:29: error: cannot find 'kErrorCodeInvalidText'\
    \ in scope\n        return .failure(Int(kErrorCodeInvalidText))\n            \
    \                ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpetdmz8t5.swift:20:16: error: cannot\
    \ find type 'NSRange' in scope\n    let range: NSRange = matches.first!.range\n\
    \               ^~~~~~~\n/tmp/tmpetdmz8t5.swift:23:29: error: cannot find 'kErrorCodeInvalidText'\
    \ in scope\n        return .failure(Int(kErrorCodeInvalidText))\n            \
    \                ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpetdmz8t5.swift:25:101: error:\
    \ cannot find 'NSCharacterSet' in scope\n    return .success((txt[start..<end]).components(separatedBy:\
    \ \" \").map { $0.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines)\
    \ })\n                                                                       \
    \                             ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let words = txt.components(separatedBy: \" \")\n    \n   \
    \ if words.count > 0 {\n        return .success(words)\n    }\n    \n    if words.count\
    \ == 0 {\n        return .failure(1)\n    }\n    \n    return .success(words.map\
    \ { String($0).lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmps3vxps1q.swift:16:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054551
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return Result.failure(3)\n    }\n    return Result.success(words.filter{$0.characters.count\
    \ > 0})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp45g887gw.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    txt = txt.trim()\n    var arr = [String]()\n    for char in txt.unicodeScalars\
    \ {\n        if !char.isWhitespace() {\n            arr.append(String(char))\n\
    \        }\n    }\n    \n    return arr.count == 0 ? .success(arr) : .failure(arr.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgmb7xte5.swift:15:5: error: cannot assign to value: 'txt' is a\
    \ 'let' constant\n    txt = txt.trim()\n    ^~~\n/tmp/tmpgmb7xte5.swift:15:15:\
    \ error: value of type 'String' has no member 'trim'\n    txt = txt.trim()\n \
    \         ~~~ ^~~~\n/tmp/tmpgmb7xte5.swift:18:18: error: value of type 'Unicode.Scalar'\
    \ has no member 'isWhitespace'\n        if !char.isWhitespace() {\n          \
    \  ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines).components(separatedBy:\
    \ \",\")\n    if words.count % 2 != 0 {\n        return Err(words.count % 2)\n\
    \    }\n    let evenOrder = words.enumerated().map { (i, v) -> (i, v) }\n    \
    \    .sorted(by: { $0.0 < $1.0 })\n        .map { $0.0 }\n    let oddOrder = words.enumerated().map\
    \ { (i, v) -> (i, v) }\n        .sorted(by: { $0.0 < $1.0 })\n        .map { $0.0\
    \ }\n    let numOfCharsInAlphabet = evenOrder.count + oddOrder.count\n    return\
    \ Ok(numOfCharsInAlphabet)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwcjq531_.swift:15:21: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines).components(separatedBy:\
    \ \",\")\n                ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpwcjq531_.swift:15:45:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines).components(separatedBy:\
    \ \",\")\n                                           ~^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwcjq531_.swift:17:16: error: cannot find 'Err' in scope\n        return\
    \ Err(words.count % 2)\n               ^~~\n/tmp/tmpwcjq531_.swift:19:47: error:\
    \ cannot find 'i' in scope\n    let evenOrder = words.enumerated().map { (i, v)\
    \ -> (i, v) }\n                                              ^\n/tmp/tmpwcjq531_.swift:19:50:\
    \ error: cannot find 'v' in scope\n    let evenOrder = words.enumerated().map\
    \ { (i, v) -> (i, v) }\n                                                 ^\n/tmp/tmpwcjq531_.swift:19:57:\
    \ error: cannot find 'i' in scope\n    let evenOrder = words.enumerated().map\
    \ { (i, v) -> (i, v) }\n                                                     \
    \   ^\n/tmp/tmpwcjq531_.swift:19:60: error: cannot find 'v' in scope\n    let\
    \ evenOrder = words.enumerated().map { (i, v) -> (i, v) }\n                  \
    \                                         ^\n/tmp/tmpwcjq531_.swift:19:46: error:\
    \ expected type before '->'\n    let evenOrder = words.enumerated().map { (i,\
    \ v) -> (i, v) }\n                                             ^\n/tmp/tmpwcjq531_.swift:19:56:\
    \ error: expected type after '->'\n    let evenOrder = words.enumerated().map\
    \ { (i, v) -> (i, v) }\n                                                     \
    \  ^\n/tmp/tmpwcjq531_.swift:22:46: error: cannot find 'i' in scope\n    let oddOrder\
    \ = words.enumerated().map { (i, v) -> (i, v) }\n                            \
    \                 ^\n/tmp/tmpwcjq531_.swift:22:49: error: cannot find 'v' in scope\n\
    \    let oddOrder = words.enumerated().map { (i, v) -> (i, v) }\n            \
    \                                "
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let splits = txt.components(separatedBy: CharacterSet.whitespaces.union(CharacterSet.commas))\
    \ else { return .failure(1) }\n    \n    return .success(splits)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpe6v9o2px.swift:15:52: error: cannot find 'CharacterSet' in scope\n\
    \    guard let splits = txt.components(separatedBy: CharacterSet.whitespaces.union(CharacterSet.commas))\
    \ else { return .failure(1) }\n                                              \
    \     ^~~~~~~~~~~~\n/tmp/tmpe6v9o2px.swift:15:83: error: cannot find 'CharacterSet'\
    \ in scope\n    guard let splits = txt.components(separatedBy: CharacterSet.whitespaces.union(CharacterSet.commas))\
    \ else { return .failure(1) }\n                                              \
    \                                    ^~~~~~~~~~~~\n/tmp/tmpe6v9o2px.swift:15:28:\
    \ error: value of type 'String' has no member 'components'\n    guard let splits\
    \ = txt.components(separatedBy: CharacterSet.whitespaces.union(CharacterSet.commas))\
    \ else { return .failure(1) }\n                       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return words_in_string(txt: txt).map({ String($0) }).map({ $0.split(separators:\
    \ \" \").map({ String($0) }) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdowrzp3n.swift:15:12: error: cannot find 'words_in_string' in scope\n\
    \    return words_in_string(txt: txt).map({ String($0) }).map({ $0.split(separators:\
    \ \" \").map({ String($0) }) })\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.characters.map { $0.isWhitespace() ? nil : String($0)\
    \ }\n    .filter({ !$0 })\n    .filter({ !$0.isEmpty() })\n    .filter({ !$0.isEmpty\
    \ })\n    .filter({ !$0.isEmpty })\n    \n    if words.isEmpty {\n        return\
    \ .success([])\n    }\n    \n    if words.count % 2 == 1 {\n        return .failure(Int(words.count))\n\
    \    }\n    \n    return .success(words.suffix(words.count / 2))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptukutgme.swift:15:17: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let words = txt.characters.map { $0.isWhitespace() ? nil\
    \ : String($0) }\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054565
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if txt == \"\" { return .failure(0) }\n    \n    let splitOnSpaces\
    \ = txt.componentsSeparatedByString(\" \")\n    var words: [String] = []\n   \
    \ \n    for word in splitOnSpaces {\n        \n        guard let charCount = word.characters.count\
    \ else { continue }\n        \n        if word.lowercaseString.characters.count\
    \ == charCount {\n            words.append(word.lowercaseString)\n        } else\
    \ {\n            guard let charCount2 = word.lowercaseString.characters.count\
    \ else { continue }\n            if charCount2 % 2 == 1 { // odd count\n     \
    \           let alphabet = word.lowercaseString.characters.first!\n          \
    \      let alphabetString = String(alphabet)\n                if alphabet.lowercaseString.characters.count\
    \ <= Int(alphabet.lowercaseString.characters.last!.lowercaseString) {\n      \
    \              return .failure(alphabetString)\n                }\n          \
    \  }\n            words.append(word)\n        }\n    }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_hfmxb5h.swift:17:29: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let splitOnSpaces = txt.componentsSeparatedByString(\"\
    \ \")\n                        ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if !txt.isEmpty {\n        let words = txt.components(separatedBy:\
    \ \" \")\n        let trimmedWords = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n        if trimmedWords.isEmpty{\n            return .success(trimmedWords)\n\
    \        }\n        let words = trimmedWords\n        guard let lowerCaseWords\
    \ = words.filter { $0.isLowercase },\n            let isEven = words.count % 2\
    \ == 0 else {\n                return .failure(words.count) // odd count of lowercase\
    \ letters\n        }\n        return .success(words.filter { !$0.contains(\" \"\
    ) && $0 != lowerCaseWords.last })\n    }\n    return .failure(0)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxwuac2wo.swift:16:25: error: value of type 'String' has no member\
    \ 'components'\n        let words = txt.components(separatedBy: \" \")\n     \
    \               ~~~ ^~~~~~~~~~\n/tmp/tmpxwuac2wo.swift:17:67: error: cannot infer\
    \ contextual base in reference to member 'whitespacesAndNewlines'\n        let\
    \ trimmedWords = words.map { $0.trimmingCharacters(in: .whitespacesAndNewlines)\
    \ }\n                                                                 ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return splitWithWhitespace(txt.trimmingCharacters(in: .whitespacesAndNewlines)).map(str.init)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3hxb185c.swift:15:12: error: cannot find 'splitWithWhitespace'\
    \ in scope\n    return splitWithWhitespace(txt.trimmingCharacters(in: .whitespacesAndNewlines)).map(str.init)\n\
    \           ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp3hxb185c.swift:15:89: error: cannot find\
    \ 'str' in scope\n    return splitWithWhitespace(txt.trimmingCharacters(in: .whitespacesAndNewlines)).map(str.init)\n\
    \                                                                            \
    \            ^~~\n/tmp/tmp3hxb185c.swift:15:36: error: value of type 'String'\
    \ has no member 'trimmingCharacters'\n    return splitWithWhitespace(txt.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)).map(str.init)\n                               ~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp3hxb185c.swift:15:60: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n    return splitWithWhitespace(txt.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)).map(str.init)\n                                  \
    \                        ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    if let wordCount = words.count {\n        let words = words.components(separatedBy:\
    \ CharacterSet.whitespacesAndNewlines)\n        return .success(words.map { $0.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines) })\n    } else {\n        return .failure(text.count)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpippuywdc.swift:15:44: error: cannot find 'CharacterSet' in scope\n\
    \    let words = txt.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                           ^~~~~~~~~~~~\n/tmp/tmpippuywdc.swift:15:21:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let words\
    \ = txt.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n        \
    \        ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpippuywdc.swift:17:51: error: cannot find\
    \ 'CharacterSet' in scope\n        let words = words.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \                                                  ^~~~~~~~~~~~\n/tmp/tmpippuywdc.swift:18:63:\
    \ error: cannot find 'CharacterSet' in scope\n        return .success(words.map\
    \ { $0.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) })\n      \
    \                                                        ^~~~~~~~~~~~\n/tmp/tmpippuywdc.swift:20:25:\
    \ error: cannot find 'text' in scope\n        return .failure(text.count)\n  \
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var result = String()\n    var words = String()\n    \n    // split\
    \ the string on whitespace if there is whitespace\n    words = txt.components(separatedBy:\
    \ \" \")\n    \n    // check how many letters are in the string\n    if words.count\
    \ < 3 {\n        // if the string only contains lower case letters then the number\
    \ of letters with odd order should be 3\n        return Result.success(Array(words.filter\
    \ { $0.isLowercase && $0.isOdd }))\n    } else {\n        // if the string contains\
    \ both spaces and commas then split on comma\n        words = txt.components(separatedBy:\
    \ \",\")\n        \n        // check if the number of commas divides the number\
    \ of letters\n        if words.count % 3 != 0 {\n            // if there are no\
    \ commas and letters with odd order then return 3\n            return Result.success(Array(words.filter\
    \ { $0.isLowercase && $0.isOdd }))\n        } else {\n            // if there\
    \ are commas and letters with odd order then return 3\n            return Result.success(Array(words.map\
    \ { $0 }))\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp10mjhh7i.swift:19:17: error: value of type 'String' has no member\
    \ 'components'\n    words = txt.components(separatedBy: \" \")\n            ~~~\
    \ ^~~~~~~~~~\n/tmp/tmp10mjhh7i.swift:24:31: error: no exact matches in call to\
    \ initializer \n        return Result.success(Array(words.filter { $0.isLowercase\
    \ && $0.isOdd }))\n                              ^\n/tmp/tmp10mjhh7i.swift:24:31:\
    \ note: found candidate with type '(String) -> Array<String.Element>' (aka '(String)\
    \ -> Array<Character>')\n        return Result.success(Array(words.filter { $0.isLowercase\
    \ && $0.isOdd }))\n                              ^\n/tmp/tmp10mjhh7i.swift:24:31:\
    \ note: found candidate with type '(String...) -> Array<String>'\n        return\
    \ Result.success(Array(words.filter { $0.isLowercase && $0.isOdd }))\n       \
    \                       ^\n/tmp/tmp10mjhh7i.swift:24:73: error: value of type\
    \ 'String.Element' (aka 'Character') has no member 'isOdd'\n        return Result.success(Array(words.filter\
    \ { $0.isLowercase && $0.isOdd }))\n                                         \
    \                            ~~ ^~~~~\n/tmp/tmp10mjhh7i.swift:27:21: error: value\
    \ of type 'String' has no member 'components'\n        words = txt.components(separatedBy:\
    \ \",\")\n                ~~~ ^~~~~~~~~~\n/tmp/tmp10mjhh7i.swift:32:35: error:\
    \ no exact matches in call to initializer \n            return Result.success(Array(words.filter\
    \ { $0.isLowercase && $0.isOdd }))\n                                  ^\n/tmp/tmp10mjhh7i.swift:32:35:\
    \ note: found candidate with type '(String) -> Array<String.Element>' (aka '(String)\
    \ -> Array<Character>')\n            return Result.success(Array(words.filter\
    \ { $0.isLowercase && $0.isOdd }))\n                                  ^\n/tmp/tmp10mjhh7i.swift:32:35:\
    \ note: found candidate with type '(String...) -> Array<String>'\n           \
    \ return Result.success(Array(words.filter { $0.isLowercase && $0.isOdd }))\n\
    \                                  ^\n/tmp/tmp10mjhh7i.swift:32:77: error: value\
    \ of type 'String.Element' (aka 'Character') has no member 'isOdd'\n         \
    \   return Result."
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    txt = txt.trimmingCharacters(in: CharacterSet(charactersIn: \"!,.\"\
    ))\n    let chars = [Int]()\n    txt.unicodeScalars.forEach { chars.append($0.value)\
    \ }\n    let alphabet = CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyz\"\
    .lowercased())\n    var words: [String] = []\n    \n    for i in 0..<txt.characters.count\
    \ {\n        if alphabet.contains(txt.character(at: i)) {\n            words.append(txt.substring(to:\
    \ i))\n        } else {\n            break\n        }\n    }\n    \n    if words.count\
    \ == 0 {\n        return .failure(alphabet.count)\n    }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplgbrcgqt.swift:15:38: error: cannot find 'CharacterSet' in scope\n\
    \    txt = txt.trimmingCharacters(in: CharacterSet(charactersIn: \"!,.\"))\n \
    \                                    ^~~~~~~~~~~~\n/tmp/tmplgbrcgqt.swift:15:5:\
    \ error: cannot assign to value: 'txt' is a 'let' constant\n    txt = txt.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \"!,.\"))\n    ^~~\n/tmp/tmplgbrcgqt.swift:15:15:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    txt =\
    \ txt.trimmingCharacters(in: CharacterSet(charactersIn: \"!,.\"))\n          ~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmplgbrcgqt.swift:17:40: error: cannot use mutating\
    \ member on immutable value: 'chars' is a 'let' constant\n    txt.unicodeScalars.forEach\
    \ { chars.append($0.value) }\n                                 ~~~~~ ^\n/tmp/tmplgbrcgqt.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let chars = [Int]()\n  \
    \  ^~~\n    var\n/tmp/tmplgbrcgqt.swift:17:50: error: cannot convert value of\
    \ type 'UInt32' to expected argument type 'Int'\n    txt.unicodeScalars.forEach\
    \ { chars.append($0.value) }\n                                               \
    \  ^\n                                              Int(    )\n/tmp/tmplgbrcgqt.swift:18:20:\
    \ error: cannot find 'CharacterSet' in scope\n    let alphabet = CharacterSet(charactersIn:\
    \ \"abcdefghijklmnopqrstuvwxyz\".lowercased())\n                   ^~~~~~~~~~~~\n\
    /tmp/tmplgbrcgqt.swift:21:22: error: 'characters' is unavailable: Please use String\
    \ directly\n    for i in 0..<txt.characters.count {\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmplgbrcgqt.swift:22:34:\
    \ error: value of type 'String' has no member 'character'\n        if alphabet.contains(txt.character(at:\
    \ i)) {\n                             ~~~ ^~~~~~~~~\n/tmp/tmplgbrcgqt.swift:23:30:\
    \ error: value of type 'String' has no member 'substring'\n            words.append(txt.substring(to:\
    \ i))\n                         ~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let splitWords = txt.split(separator: \" \").map(String.init)\n\
    \    let splitComma = txt.split(separator: \",\").map(String.init)\n    let allLetters\
    \ = txt.lowercased()\n    let count = allLetters.filter { allLetters.count { $0\
    \ % 2 != 0 }}.count\n    \n    guard splitWords.count == splitComma.count && splitWords.count\
    \ == count && splitWords.count == count + 1 else {\n        return .failure(count)\n\
    \    }\n    \n    return .success(splitWords)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3bxytqx0.swift:19:35: error: contextual type for closure argument\
    \ list expects 1 argument, which cannot be implicitly ignored\n    let count =\
    \ allLetters.filter { allLetters.count { $0 % 2 != 0 }}.count\n              \
    \                    ^\n                                    _ in\n/tmp/tmp3bxytqx0.swift:19:48:\
    \ error: cannot call value of non-function type 'Int'\n    let count = allLetters.filter\
    \ { allLetters.count { $0 % 2 != 0 }}.count\n                                \
    \               ^\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = text.components(separatedBy: .whitespaces)\n    return\
    \ words.count == 0 ? .success(words.map { $0.lowercased() }) : .failure(words.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5nyd5v_b.swift:15:17: error: cannot find 'text' in scope\n    let\
    \ words = text.components(separatedBy: .whitespaces)\n                ^~~~\n/tmp/tmp5nyd5v_b.swift:15:47:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   let words = text.components(separatedBy: .whitespaces)\n                 \
    \                            ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let countLowerChars = txt.lowercased().count\n    let words: [String]\
    \ = txt.components(separatedBy: \" \")\n    let countCharacters = txt.characters.count\n\
    \    let countSpacesAndComma = txt.components(separatedBy: \",\").count\n    return\
    \ if countLowerChars == 0 || countCharacters == 0 || countSpacesAndComma == 0\
    \ {\n        failure(countLowerChars)\n    } else if countLowerChars == countCharacters\
    \ {\n        success(words)\n    } else if countLowerChars == countSpacesAndComma\
    \ {\n        success(words)\n    } else {\n        failure(countLowerChars)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello\
    \ world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"\
    Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp56hpzq43.swift:19:11: error: consecutive statements on a line must\
    \ be separated by ';'\n    return if countLowerChars == 0 || countCharacters ==\
    \ 0 || countSpacesAndComma == 0 {\n          ^\n          ;\n/tmp/tmp56hpzq43.swift:16:31:\
    \ error: value of type 'String' has no member 'components'\n    let words: [String]\
    \ = txt.components(separatedBy: \" \")\n                          ~~~ ^~~~~~~~~~\n\
    /tmp/tmp56hpzq43.swift:17:31: error: 'characters' is unavailable: Please use String\
    \ directly\n    let countCharacters = txt.characters.count\n                 \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp56hpzq43.swift:18:35: error: value of type 'String' has no member\
    \ 'components'\n    let countSpacesAndComma = txt.components(separatedBy: \",\"\
    ).count\n                              ~~~ ^~~~~~~~~~\n/tmp/tmp56hpzq43.swift:19:5:\
    \ error: non-void function should return a value\n    return if countLowerChars\
    \ == 0 || countCharacters == 0 || countSpacesAndComma == 0 {\n    ^\n/tmp/tmp56hpzq43.swift:20:9:\
    \ error: cannot find 'failure' in scope\n        failure(countLowerChars)\n  \
    \      ^~~~~~~\n/tmp/tmp56hpzq43.swift:22:9: error: cannot find 'success' in scope\n\
    \        success(words)\n        ^~~~~~~\n/tmp/tmp56hpzq43.swift:24:9: error:\
    \ cannot find 'success' in scope\n        success(words)\n        ^~~~~~~\n/tmp/tmp56hpzq43.swift:26:9:\
    \ error: cannot find 'failure' in scope\n        failure(countLowerChars)\n  \
    \      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let chars = CharacterSet(charactersIn: txt.lowercased())\n    var\
    \ words: [String] = []\n    var count: Int = 0\n    for i in 0..<txt.characters.count\
    \ {\n        let letter = String(txt[i])\n        if !chars.isSuperset(of: letter)\
    \ {\n            count += 1\n            words.append(letter)\n        } else\
    \ {\n            count = 0\n            words.append(String(txt[i]))\n       \
    \ }\n    }\n    if words.isEmpty {\n        if words.count == 0 {\n          \
    \  return .failure(3)\n        } else {\n            return .success(words)\n\
    \        }\n    }\n    if words.count == 1 {\n        return .success(words)\n\
    \    }\n    if words.count == 2 {\n        return .success(words)\n    }\n   \
    \ let maxOdd = words.filter{ $0[String($0.characters.count - 1).utf16Count] %\
    \ 2 == 1 }.count\n    return .success(Array(words[0..<maxOdd]))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpt0ij2ze5.swift:15:17: error: cannot find 'CharacterSet' in scope\n\
    \    let chars = CharacterSet(charactersIn: txt.lowercased())\n              \
    \  ^~~~~~~~~~~~\n/tmp/tmpt0ij2ze5.swift:18:22: error: 'characters' is unavailable:\
    \ Please use String directly\n    for i in 0..<txt.characters.count {\n      \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpt0ij2ze5.swift:19:29: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let letter\
    \ = String(txt[i])\n                            ^~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpt0ij2ze5.swift:25:33: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            words.append(String(txt[i]))\n                       \
    \         ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpt0ij2ze5.swift:41:67: error: value of type 'String' has\
    \ no member 'utf16Count'\n    let maxOdd = words.filter{ $0[String($0.characters.count\
    \ - 1).utf16Count] % 2 == 1 }.count\n                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let words = txt.components(separatedBy: \" \")\n    \n   \
    \ if words.count == 1 {\n        return .success(words)\n    }\n    \n    let\
    \ splitted = words.map { $0.components(separatedBy: \",\").map { $0.lowercased()\
    \ } }\n    \n    guard splitted.count == 2 else {\n        return .failure(splitted.count)\n\
    \    }\n    \n    var oddOrderCount = 0\n    var count = 1\n    \n    for word\
    \ in splitted {\n        if word == split(word).last {\n            count += 1\n\
    \        } else {\n            oddOrderCount += 1\n        }\n    }\n    \n  \
    \  return .success(splitted[splitted.count - 1] + String(count) + String(oddOrderCount))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5m61nptg.swift:16:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmp5m61nptg.swift:39:12: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n    return .success(splitted[splitted.count -\
    \ 1] + String(count) + String(oddOrderCount))\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054617
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \"), words.count\
    \ > 0 else { return .failure(0) }\n    \n    guard let commaWords = words.components(separatedBy:\
    \ \",\"), commaWords.count > 0 else { return .failure(1) }\n    \n    if words.count\
    \ != commaWords.count { return .failure(2) }\n    \n    var oddWords: [String]\
    \ = []\n    \n    for word in commaWords {\n        oddWords.append(word.lowercased())\n\
    \    }\n    \n    if oddWords.count % 2 != 0 { return .failure(3) }\n    \n  \
    \  return .success(oddWords)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpiqn_8ew_.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \"), words.count\
    \ > 0 else { return .failure(0) }\n                      ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    if words.count == 0 { return .failure(0) }\n    if words.count > 1 { words\
    \ = words.components(separatedBy: \",\")! }\n    let lowercaseLetters = words.filter({\
    \ $0.lowercased() == $0 }).count\n    return .success(lowercaseLetters)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzkzqt0ww.swift:15:21: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \                ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpzkzqt0ww.swift:15:45: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n       \
    \                                    ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let txt = txt else {\n        return .failure(1)\n    }\n\n\
    \    guard let chars = txt.unicodeScalars.filter { $0.isLetter }\n    else {\n\
    \        return .failure(2)\n    }\n\n    let low = chars.filter { $0.isLower\
    \ }.count\n\n    guard low % 2 == 0 else {\n        return .failure(3)\n    }\n\
    \n    return .success(chars.map { String($0) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6lwzse1c.swift:19:49: error: expected 'else' after 'guard' condition\n\
    \    guard let chars = txt.unicodeScalars.filter { $0.isLetter }\n           \
    \                                     ^\n                                    \
    \            else \n/tmp/tmp6lwzse1c.swift:19:51: error: anonymous closure argument\
    \ not contained in a closure\n    guard let chars = txt.unicodeScalars.filter\
    \ { $0.isLetter }\n                                                  ^\n/tmp/tmp6lwzse1c.swift:20:5:\
    \ error: expected expression\n    else {\n    ^\n/tmp/tmp6lwzse1c.swift:15:11:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    guard let txt = txt else {\n          ^         ~~~\n/tmp/tmp6lwzse1c.swift:19:11:\
    \ error: initializer for conditional binding must have Optional type, not '((Unicode.Scalar)\
    \ throws -> Bool) throws -> String.UnicodeScalarView'\n    guard let chars = txt.unicodeScalars.filter\
    \ { $0.isLetter }\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6lwzse1c.swift:24:21:\
    \ error: value of type '((Unicode.Scalar) throws -> Bool) throws -> String.UnicodeScalarView'\
    \ has no member 'filter'\n    let low = chars.filter { $0.isLower }.count\n  \
    \            ~~~~~ ^~~~~~\n/tmp/tmp6lwzse1c.swift:30:27: error: value of type\
    \ '((Unicode.Scalar) throws -> Bool) throws -> String.UnicodeScalarView' has no\
    \ member 'map'\n    return .success(chars.map { String($0) })\n              \
    \      ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var splits: [String] = []\n    for cString in txt.characters.split(\"\
    \") {\n        guard let c = cString else { continue }\n        let i = c as Character\n\
    \        \n        switch (i) {\n        case ',':\n            splits.append(\"\
    \")\n        case ' ':\n            splits.append(\"\")\n        case ',':\n \
    \           splits.append(\"\")\n        default:\n            splits.append(cString)\n\
    \        }\n    }\n    \n    return splits.count == 0 ? .success([]) : .success(splits)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpoi3gv691.swift:21:14: error: single-quoted string literal found,\
    \ use '\"'\n        case ',':\n             ^~~\n             \",\"\n/tmp/tmpoi3gv691.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ' ':\n   \
    \          ^~~\n             \" \"\n/tmp/tmpoi3gv691.swift:25:14: error: single-quoted\
    \ string literal found, use '\"'\n        case ',':\n             ^~~\n      \
    \       \",\"\n/tmp/tmpoi3gv691.swift:16:41: error: missing argument label 'separator:'\
    \ in call\n    for cString in txt.characters.split(\"\") {\n                 \
    \                       ^\n                                        separator:\
    \ \n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let count = countOccurrences(txt, \" \")\n    let isSpace = countOccurrences(txt,\
    \ \" \") != 0\n    let isComma = countOccurrences(txt, \",\") != 0\n    \n   \
    \ if count > 0 {\n        let words = txt.components(separatedBy: \" \")\n   \
    \     var words = [String]()\n        for word in words {\n            if isSpace\
    \ {\n                words.append(word)\n            } else {\n              \
    \  words.append(word)\n                if isComma {\n                    words.append(\"\
    \ \")\n                }\n            }\n        }\n        return .success(words)\n\
    \    } else {\n        return .failure(count)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3e5lfbge.swift:15:17: error: cannot find 'countOccurrences' in\
    \ scope\n    let count = countOccurrences(txt, \" \")\n                ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp3e5lfbge.swift:16:19: error: cannot find 'countOccurrences' in scope\n\
    \    let isSpace = countOccurrences(txt, \" \") != 0\n                  ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp3e5lfbge.swift:17:19: error: cannot find 'countOccurrences' in scope\n\
    \    let isComma = countOccurrences(txt, \",\") != 0\n                  ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp3e5lfbge.swift:20:25: error: value of type 'String' has no member 'components'\n\
    \        let words = txt.components(separatedBy: \" \")\n                    ~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    guard let words = txt.components(separatedBy: .whitespaces)\
    \ else {\n        return .failure(txt.count)\n    }\n    \n    var counts: [Int]\
    \ = []\n    for word in words {\n        if let count = word.characters.filter\
    \ {\n            count >= 97 && count <= 122\n        }.count {\n            counts.append(count)\n\
    \        }\n    }\n    \n    if counts.isEmpty {\n        if let count = txt.characters.filter\
    \ {\n            count >= 97 && count <= 122\n        }.count {\n            counts.append(count)\n\
    \        }\n    }\n    \n    if counts.isEmpty {\n        return .failure(txt.count)\n\
    \    }\n    \n    let evenCounts = counts\n    .reduce(into: [Int](), { $0.append($1)\
    \ })\n    .filter { $0 % 2 == 1 }\n    .reduce(into: 0, { $0 + $1 })\n    \n \
    \   if evenCounts.count % 2 == 1 {\n        return .failure(txt.count)\n    }\n\
    \    \n    return .success(counts)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcbs2wr8z.swift:24:10: error: consecutive statements on a line must\
    \ be separated by ';'\n        }.count {\n         ^\n         ;\n/tmp/tmpcbs2wr8z.swift:32:10:\
    \ error: consecutive statements on a line must be separated by ';'\n        }.count\
    \ {\n         ^\n         ;\n/tmp/tmpcbs2wr8z.swift:16:27: error: value of type\
    \ 'String' has no member 'components'\n    guard let words = txt.components(separatedBy:\
    \ .whitespaces) else {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmpcbs2wr8z.swift:16:52:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   guard let words = txt.components(separatedBy: .whitespaces) else {\n     \
    \                                             ~^~~~~~~~~~~\n/tmp/tmpcbs2wr8z.swift:30:28:\
    \ error: 'characters' is unavailable: Please use String directly\n        if let\
    \ count = txt.characters.filter {\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpcbs2wr8z.swift:31:19: error: type '((String.Element)\
    \ throws -> Bool) throws -> String' (aka '((Character) throws -> Bool) throws\
    \ -> String') cannot conform to 'BinaryInteger'\n            count >= 97 && count\
    \ <= 122\n                  ^\n/tmp/tmpcbs2wr8z.swift:31:19: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n        \
    \    count >= 97 && count <= 122\n                  ^\n/tmp/tmpcbs2wr8z.swift:31:19:\
    \ note: required by referencing operator function '>=' on 'BinaryInteger' where\
    \ 'Self' = '((String.Element) throws -> Bool) throws -> String' (aka '((Character)\
    \ throws -> Bool) throws -> String')\n            count >= 97 && count <= 122\n\
    \                  ^\n/tmp/tmpcbs2wr8z.swift:31:34: error: type '((String.Element)\
    \ throws -> Bool) throws -> String' (aka '((Character) throws -> Bool) throws\
    \ -> String') cannot conform to 'BinaryInteger'\n            count >= 97 && count\
    \ <= 122\n                                 ^\n/tmp/tmpcbs2wr8z.swift:31:34: note:\
    \ only concrete types such as structs, enums "
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let wordCount: Int = txt\n        .components(separatedBy: \" \"\
    )\n        .count\n\n    if wordCount == 0 {\n        return .failure(wordCount)\n\
    \    } else if wordCount == 1 {\n        return .success(txt.characters.split(separator:\
    \ \" \").toArray())\n    } else {\n        return .success(txt.characters.split(separator:\
    \ \" \").toArray()[0..<wordCount - 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpq_f9p9wu.swift:16:10: error: value of type 'String' has no member\
    \ 'components'\n        .components(separatedBy: \" \")\n         ^~~~~~~~~~\n\
    /tmp/tmpq_f9p9wu.swift:22:62: error: reference to member 'toArray' cannot be resolved\
    \ without a contextual type\n        return .success(txt.characters.split(separator:\
    \ \" \").toArray())\n                                                        \
    \     ^\n/tmp/tmpq_f9p9wu.swift:24:62: error: reference to member 'toArray' cannot\
    \ be resolved without a contextual type\n        return .success(txt.characters.split(separator:\
    \ \" \").toArray()[0..<wordCount - 1])\n                                     \
    \                        ^\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if let split = txt.componentsSeparatedByString(\" \") {\n      \
    \  return .success(split)\n    }\n    if let split = txt.componentsSeparatedByString(\"\
    ,\") {\n        return .success(split)\n    }\n    if let lowercase = txt.lowercaseString.unicodeScalars.filter({\
    \ $0 != \"a\" &&\n                                                       $0 !=\
    \ \"b\" &&\n                                                       $0 != \"c\"\
    \ &&\n                                                       $0 != \"d\" &&\n\
    \                                                       $0 != \"e\" &&\n     \
    \                                                  $0 != \"f\" &&\n          \
    \                                             $0 != \"g\" &&\n               \
    \                                        $0 != \"h\" &&\n                    \
    \                                   $0 != \"i\" &&\n                         \
    \                              $0 != \"j\" &&\n                              \
    \                         $0 != \"k\" &&\n                                   \
    \                    $0 != \"l\" &&\n                                        \
    \               $0 != \"m\" &&\n                                             \
    \          $0 != \"n\" &&\n                                                  \
    \     $0 != \"o\" &&\n                                                       $0\
    \ != \"p\" &&\n                                                       $0 != \"\
    q\" &&\n                                                       $0 != \"r\" &&\n\
    \                                                       $0 != \"s\" &&\n     \
    \                                                  $0 != \"t\" &&\n          \
    \                                             $0 != \"u\" &&\n               \
    \                                        $0 != \"v\" &&\n                    \
    \                                   $0 != \"w\" &&\n                         \
    \                              $0 != \"x\" &&\n                              \
    \                         $0 != \"y\" &&\n                                   \
    \                    $0 != \"z\" }).count\n    {\n        return .success(lowercase)\n\
    \    }\n    return .failure(Int64(6))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmk7k31n6.swift:15:24: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    if let split = txt.componentsSeparatedByString(\"\
    \ \") {\n                   ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmk7k31n6.swift:18:24:\
    \ error: value of type 'String' has no member 'componentsSeparatedByString'\n\
    \    if let split = txt.componentsSeparatedByString(\",\") {\n               \
    \    ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmk7k31n6.swift:21:24: error: the\
    \ compiler is unable to type-check this expression in reasonable time; try breaking\
    \ up the expression into distinct sub-expressions\n    if let lowercase = txt.lowercaseString.unicodeScalars.filter({\
    \ $0 != \"a\" &&\n                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmk7k31n6.swift:50:21: error: cannot convert value of type 'Int64' to expected\
    \ argument type 'Int'\n    return .failure(Int64(6))\n                    ^\n\
    \                    Int(    )\n"
  stdout: ''
  timestamp: 1660054599
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ < 2 { // no spaces found\n        return .failure(words.count)\n    }\n    if\
    \ words.count > 30 { // too many words found\n        return .failure(30)\n  \
    \  }\n    \n    // get unique words in the array\n    var wordSet = [String]()\n\
    \    for word in words {\n        if !wordSet.contains(word) { \n            wordSet.append(word)\n\
    \        }\n    }\n    \n    // make array of unique words\n    var uniqueWords:\
    \ [String] = []\n    for word in wordSet {\n        if !uniqueWords.contains(word)\
    \ { \n            uniqueWords.append(word)\n        }\n    }\n    \n    // check\
    \ if words are in alphabetical order\n    let letters = uniqueWords.map { $0.characters.count\
    \ }\n    let maxIndex = letters.maxElement()\n    \n    // if not, return number\
    \ of letters with odd order\n    return .success(uniqueWords[maxIndex])\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpc6pk8hi9.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpc6pk8hi9.swift:40:40: error: 'characters' is unavailable:\
    \ Please use String directly\n    let letters = uniqueWords.map { $0.characters.count\
    \ }\n                                       ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpc6pk8hi9.swift:41:28: error: value of type\
    \ '[Int]' has no member 'maxElement'\n    let maxIndex = letters.maxElement()\n\
    \                   ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let wordsAsArray = str.split(separator: \" \")\n    if wordsAsArray.count\
    \ < 2 {\n        return Err(Int(.zero))\n    }\n    let result = wordsAsArray.filter\
    \ { $0.isEmpty }\n    if !result.isEmpty {\n        if result.count == 1 { //\
    \ No comma\n            return Err(Int(.zero))\n        }\n        let result\
    \ = wordsAsArray.filter { !$0.isEmpty }\n        if result.count == 1 { // No\
    \ whitespace\n            return Err(Int(.zero))\n        }\n    }\n    return\
    \ Ok(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpw0ygszbe.swift:15:24: error: cannot find 'str' in scope\n    let\
    \ wordsAsArray = str.split(separator: \" \")\n                       ^~~\n/tmp/tmpw0ygszbe.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(.zero))\n        \
    \       ^~~\n/tmp/tmpw0ygszbe.swift:22:20: error: cannot find 'Err' in scope\n\
    \            return Err(Int(.zero))\n                   ^~~\n/tmp/tmpw0ygszbe.swift:26:20:\
    \ error: cannot find 'Err' in scope\n            return Err(Int(.zero))\n    \
    \               ^~~\n/tmp/tmpw0ygszbe.swift:29:12: error: cannot find 'Ok' in\
    \ scope\n    return Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return try text.split(separator: \" \", maxSplits: 1).map(String.init)\n\
    \        .map(Words.init).map(Words.lowercased).map(Words.split_words)\n     \
    \   .map(Words.countWordsInOrderOfLetter)\n        .map(Words.takeWhile(Words.isNotEmpty))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp623s2psm.swift:15:16: error: cannot find 'text' in scope\n    return\
    \ try text.split(separator: \" \", maxSplits: 1).map(String.init)\n          \
    \     ^~~~\n/tmp/tmp623s2psm.swift:16:14: error: cannot find 'Words' in scope\n\
    \        .map(Words.init).map(Words.lowercased).map(Words.split_words)\n     \
    \        ^~~~~\n/tmp/tmp623s2psm.swift:16:30: error: cannot find 'Words' in scope\n\
    \        .map(Words.init).map(Words.lowercased).map(Words.split_words)\n     \
    \                        ^~~~~\n/tmp/tmp623s2psm.swift:16:52: error: cannot find\
    \ 'Words' in scope\n        .map(Words.init).map(Words.lowercased).map(Words.split_words)\n\
    \                                                   ^~~~~\n/tmp/tmp623s2psm.swift:17:14:\
    \ error: cannot find 'Words' in scope\n        .map(Words.countWordsInOrderOfLetter)\n\
    \             ^~~~~\n/tmp/tmp623s2psm.swift:18:14: error: cannot find 'Words'\
    \ in scope\n        .map(Words.takeWhile(Words.isNotEmpty))\n             ^~~~~\n\
    /tmp/tmp623s2psm.swift:18:30: error: cannot find 'Words' in scope\n        .map(Words.takeWhile(Words.isNotEmpty))\n\
    \                             ^~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    func split(txt: String, start: Int, len: Int) -> [String]\
    \ {\n        \n        if txt == \"\" {\n            return []\n        } else\
    \ {\n            \n            if start < 0 {\n                start = 0\n   \
    \         }\n            \n            if start >= txt.characters.count {\n  \
    \              start = txt.characters.count - 1\n            }\n            \n\
    \            \n            \n            var chars = [Character]()\n         \
    \   \n            let start = txt.characters[start]\n            \n          \
    \  let startIndex = txt.index(before: start)\n            \n            for _\
    \ in start...startIndex {\n                chars.append(txt[start])\n        \
    \    }\n            \n            \n            let end = txt.characters[startIndex..<txt.characters.count]\n\
    \            \n            for _ in end...txt.characters.count {\n           \
    \     chars.append(Character(unicodeScalar: 0))\n            }\n            \n\
    \            let trimmed = txt.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \"\\n\"))\n            \n            if trimmed == txt {\n                chars.append(Character(unicodeScalar:\
    \ 0))\n            }\n            \n            let letters = trimmed.unicodeScalars.filter\
    \ { $0.value > 0 }\n            \n            var words = [String]()\n       \
    \     \n            for letter in letters {\n                words.append(String(unicodeScalars:\
    \ [(letter)]))\n            }\n            \n            return words\n      \
    \  }\n    }\n    \n    \n    var splits = split(txt: txt, start: 0, len: txt.characters.count)\n\
    \    \n    if txt.lowercased() != txt {\n        return .failure(txt.lowercased().unicodeScalars.count\
    \ - 1)\n    }\n    \n    if txt.lowercased().unicodeScalars.count > 0 {\n    \
    \    return .success(splits)\n    }\n    \n    if txt.lowercased().unicodeScalars.count\
    \ < 1 {\n        return .success(0)\n    }\n    \n    return .success(txt.lowercased().unicodeScalars.count\
    \ - 1)\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6blawpok.swift:23:17: error: cannot assign to value: 'start' is\
    \ a 'let' constant\n                start = 0\n                ^~~~~\n/tmp/tmp6blawpok.swift:26:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if start >= txt.characters.count {\n                            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6blawpok.swift:27:17:\
    \ error: cannot assign to value: 'start' is a 'let' constant\n               \
    \ start = txt.characters.count - 1\n                ^~~~~\n/tmp/tmp6blawpok.swift:34:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            let start = txt.characters[start]\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6blawpok.swift:34:29: error: 'characters'\
    \ is unavailable: Please use String directly\n            let start = txt.characters[start]\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6blawpok.swift:36:48: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String.Index'\n            let startIndex\
    \ = txt.index(before: start)\n                                               ^\n\
    /tmp/tmp6blawpok.swift:38:27: error: protocol 'Sequence' requires that 'Character'\
    \ conform to 'Strideable'\n            for _ in start...startIndex {\n       \
    \                   ^\nSwift.ClosedRange:1:11: note: requirement from conditional\
    \ conformance of 'ClosedRange<Character>' to 'Sequence'\nextension ClosedRange\
    \ : Sequence where Bound : Strideable, Bound.Stride : SignedInteger {\n      \
    \    ^\n/tmp/tmp6blawpok.swift:38:27: error: referencing instance method 'makeIterator()'\
    \ on 'ClosedRange' requires that 'Character' conform to 'Strideable'\n "
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let text = txt else { return .failure(0) }\n    var result\
    \ = Array(0..<0)\n    for c in text.characters {\n        guard let value = getCharValue(c)\
    \ else { return .failure(0) }\n        if value != 0 {\n            switch value\
    \ {\n            case 1: // whitespace\n                result[result.count -\
    \ 1] = value\n                result.count\n            default:\n           \
    \     result[result.count] = value\n            }\n        } else {\n        \
    \    result[result.count] = value\n        }\n    }\n    guard result.count >=\
    \ 2 else { return .failure(1) }\n    let first = result.first\n    let last =\
    \ result.last\n    if result[0] == 1 && result[result.count - 1] == 25 {\n   \
    \     result[result.count - 1] = 0\n        result.count -= 1\n    }\n    switch\
    \ first {\n    case 0: // no commas\n        switch last {\n        case 1: //\
    \ lowercase letters with odd order in the alphabet\n            return .success(result)\n\
    \        default: // whitespace in the middle\n            return .success(result)\n\
    \        }\n    case 1: // commas\n        switch last {\n        case 1: // lowercase\
    \ letters with odd order in the alphabet\n            return .success(result)\n\
    \        default: // whitespace in the middle\n            return .success(result)\n\
    \        }\n    case 25: // no whitespace\n        switch last {\n        case\
    \ 1: // lowercase letters with odd order in the alphabet\n            return .success(result)\n\
    \        default: // whitespace in the middle\n            return .success(result)\n\
    \        }\n    case 25: // whitespace\n        switch last {\n        case 0:\
    \ // no commas\n            return .success(result)\n        case 1: // commas\n\
    \            return .success(result)\n        default: // whitespace in the middle\n\
    \            return .success(result)\n        }\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptdrex6pw.swift:15:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let text = txt else { return\
    \ .failure(0) }\n          ^          ~~~\n/tmp/tmptdrex6pw.swift:17:19: error:\
    \ 'characters' is unavailable: Please use String directly\n    for c in text.characters\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmptdrex6pw.swift:18:27: error: cannot find 'getCharValue' in scope\n\
    \        guard let value = getCharValue(c) else { return .failure(0) }\n     \
    \                     ^~~~~~~~~~~~\n/tmp/tmptdrex6pw.swift:23:24: warning: expression\
    \ of type 'Int' is unused\n                result.count\n                ~~~~~~~^~~~~\n\
    /tmp/tmptdrex6pw.swift:36:22: error: left side of mutating operator isn't mutable:\
    \ 'count' is a get-only property\n        result.count -= 1\n        ~~~~~~~~~~~~\
    \ ^\n/tmp/tmptdrex6pw.swift:42:29: error: cannot convert value of type '[Int]'\
    \ to expected argument type '[String]'\n            return .success(result)\n\
    \                            ^\n/tmp/tmptdrex6pw.swift:42:29: note: arguments\
    \ to generic parameter 'Element' ('Int' and 'String') are expected to be equal\n\
    \            return .success(result)\n                            ^\n/tmp/tmptdrex6pw.swift:44:29:\
    \ error: cannot convert value of type '[Int]' to expected argument type '[String]'\n\
    \            return .success(result)\n                            ^\n/tmp/tmptdrex6pw.swift:44:29:\
    \ note: arguments to generic parameter 'Element' ('Int' and 'String') are expected\
    \ to be equal\n            return .success(result)\n                         \
    \   ^\n/tmp/tmptdrex6pw.swift:49:29: error: cannot convert value of type '[Int]'\
    \ to expected argument type '[String]'\n            return .success(result)\n\
    \                            ^\n/tmp/tmptdrex6pw.swift:49:29: note: arguments\
    \ to generic parameter 'Element' ('Int' and 'String') are expected to be equal\n\
    \            return .success(result)\n                            ^\n/tm"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.componentsSeparatedByString(\" \")\n    return words.count\
    \ == words.count ? .success(words) : .failure(words.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp8nde09yf.swift:15:21: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = txt.componentsSeparatedByString(\"\
    \ \")\n                ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return DispatchQueue(label: \"split_words\", qos: .userInitiated).async\
    \ {\n        let str = txt.lowercased()\n        let chars = str.unicodeScalars\n\
    \        let filtered = str.components(separatedBy: \",\")\n            .filter\
    \ {\n                let letter = $0.unicodeScalars.first!\n                let\
    \ unicodeScalar = letter.unicodeScalar\n                let charIndex = chars.firstIndex(of:\
    \ unicodeScalar)\n                if let index = charIndex {\n               \
    \     if chars.count - index > 2 {\n                        return true\n    \
    \                } else {\n                        return false\n            \
    \        }\n                }\n            }\n\n        let filtered = filtered.filter\
    \ { (value) -> Bool in\n            value.count == 1\n        }\n        let filtered\
    \ = filtered.filter { (value) -> Bool in\n            value.count < 26\n     \
    \   }\n        let filtered = filtered.filter { (value) -> Bool in\n         \
    \   value.count % 2 == 1\n        }\n        if filtered.isEmpty {\n         \
    \   let charCount = str.unicodeScalars.count\n            if charCount > 26 {\n\
    \                return .failure(char)\n            }\n            if charCount\
    \ == 0 {\n                return .failure(char)\n            }\n            if\
    \ charCount > 1 && (chars.count % 2 == 0) {\n                return .failure(char)\n\
    \            }\n            return .success(Array(str.unicodeScalars))\n     \
    \   }\n        return .success(filtered)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzy7h34k9.swift:15:12: error: cannot find 'DispatchQueue' in scope\n\
    \    return DispatchQueue(label: \"split_words\", qos: .userInitiated).async {\n\
    \           ^~~~~~~~~~~~~\n/tmp/tmpzy7h34k9.swift:44:33: error: cannot find 'char'\
    \ in scope\n                return .failure(char)\n                          \
    \      ^~~~\n/tmp/tmpzy7h34k9.swift:47:33: error: cannot find 'char' in scope\n\
    \                return .failure(char)\n                                ^~~~\n\
    /tmp/tmpzy7h34k9.swift:50:33: error: cannot find 'char' in scope\n           \
    \     return .failure(char)\n                                ^~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if let split = txt.split(separator: \" \")  {\n        return Result.success(split)\n\
    \    }\n    \n    if let splits = txt.split(separator: \",\", omittingEmptySubsequences:\
    \ true) {\n        if splits.count == 1 {\n            return Result.success(splits)\n\
    \        }\n        \n        let odd = splits.map { (c) -> Int in\n         \
    \   guard let c = c.asciiValue else { return 0 }\n            let order = c -\
    \ 'a'.asciiValue\n            return order%2\n        }\n        let even = splits.map\
    \ { (c) -> Int in\n            guard let c = c.asciiValue else { return 0 }\n\
    \            let order = c - 'a'.asciiValue\n            return order/2\n    \
    \    }\n        \n        if odd.count == even.count {\n            if odd.first\
    \ % 2 == 0 { // odd == even\n                return Result.success(splits)\n \
    \           } else {\n                return Result.failure(even.count)\n    \
    \        }\n        }\n        \n        if odd.count > even.count {\n       \
    \     if odd.first % 2 == 0 { // odd == even\n                return Result.success(odd)\n\
    \            } else {\n                return Result.success(even)\n         \
    \   }\n        } else {\n            if odd.first % 2 == 0 { // odd == even\n\
    \                return Result.success(odd.map { $0 + \"a\" })\n            }\
    \ else {\n                return Result.success(even.map { $0 + \"a\" })\n   \
    \         }\n        }\n    }\n    \n    return Result.failure(txt.characters.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpjjg6tqnu.swift:26:29: error: single-quoted string literal found,\
    \ use '\"'\n            let order = c - 'a'.asciiValue\n                     \
    \       ^~~\n                            \"a\"\n/tmp/tmpjjg6tqnu.swift:31:29:\
    \ error: single-quoted string literal found, use '\"'\n            let order =\
    \ c - 'a'.asciiValue\n                            ^~~\n                      \
    \      \"a\"\n/tmp/tmpjjg6tqnu.swift:16:31: error: cannot convert value of type\
    \ '[String.SubSequence]' (aka 'Array<Substring>') to expected argument type '[String]'\n\
    \        return Result.success(split)\n                              ^\n/tmp/tmpjjg6tqnu.swift:16:31:\
    \ note: arguments to generic parameter 'Element' ('String.SubSequence' (aka 'Substring')\
    \ and 'String') are expected to be equal\n        return Result.success(split)\n\
    \                              ^\n/tmp/tmpjjg6tqnu.swift:15:8: error: initializer\
    \ for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    if let split = txt.split(separator: \" \")  {\n\
    \       ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjjg6tqnu.swift:21:35: error:\
    \ cannot convert value of type '[String.SubSequence]' (aka 'Array<Substring>')\
    \ to expected argument type '[String]'\n            return Result.success(splits)\n\
    \                                  ^\n/tmp/tmpjjg6tqnu.swift:21:35: note: arguments\
    \ to generic parameter 'Element' ('String.SubSequence' (aka 'Substring') and 'String')\
    \ are expected to be equal\n            return Result.success(splits)\n      \
    \                            ^\n/tmp/tmpjjg6tqnu.swift:25:29: error: value of\
    \ type 'String.SubSequence' (aka 'Substring') has no member 'asciiValue'\n   \
    \         guard let c = c.asciiValue else { return 0 }\n                     \
    \     ~ ^~~~~~~~~~\n/tmp/tmpjjg6tqnu.swift:30:29: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'asciiValue'\n            guard let c = c.asciiValue\
    \ else { return 0 }\n                          ~ ^~~~~~~~~~\n/tmp/tmpjjg6tqnu.swift:37:39:\
    \ error: cannot convert value of type '[String.SubSequence]' (aka 'A"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    guard !words.isEmpty,\n\
    \        let result = words.map(String.init).reduce([], +)\n    else { return\
    \ Result.failure(0) }\n    \n    // check for space\n    let hasSpace = words.contains(\"\
    \ \")\n    if hasSpace {\n        let comma = words.contains(\",\")\n        if\
    \ comma {\n            let lowerCase = words.filter { $0.count % 2 == 1 }\n  \
    \          switch words.count {\n            case 1:\n                if !lowerCase.isEmpty\
    \ {\n                    return Result.success(words)\n                }\n   \
    \         case 2:\n                if lowerCase.isEmpty {\n                  \
    \  return Result.success(words)\n                }\n            case 3:\n    \
    \            if lowerCase.count % 2 == 1 {\n                    return Result.success(words)\n\
    \                }\n            default:\n                return Result.failure(words.count\
    \ + 1)\n            }\n        } else {\n            return Result.success(words)\n\
    \        }\n    } else {\n        return Result.success(result)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpyogxc8bn.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return Result.value(\n        words: split(txt,\n            whitespace:\
    \ CharacterSet.whitespaces).map({ $0.filter({ $0.isLetter }) }),\n        count:\
    \ split(txt,\n            whitespace: CharacterSet.whitespaces).map({ $0.filter({\
    \ $0.isLetter }).count }),\n    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnkhb5ttv.swift:20:5: error: unexpected ',' separator\n    )\n \
    \   ^\n/tmp/tmpnkhb5ttv.swift:16:16: error: cannot find 'split' in scope\n   \
    \     words: split(txt,\n               ^~~~~\n/tmp/tmpnkhb5ttv.swift:17:25: error:\
    \ cannot find 'CharacterSet' in scope\n            whitespace: CharacterSet.whitespaces).map({\
    \ $0.filter({ $0.isLetter }) }),\n                        ^~~~~~~~~~~~\n/tmp/tmpnkhb5ttv.swift:18:16:\
    \ error: cannot find 'split' in scope\n        count: split(txt,\n           \
    \    ^~~~~\n/tmp/tmpnkhb5ttv.swift:19:25: error: cannot find 'CharacterSet' in\
    \ scope\n            whitespace: CharacterSet.whitespaces).map({ $0.filter({ $0.isLetter\
    \ }).count }),\n                        ^~~~~~~~~~~~\n/tmp/tmpnkhb5ttv.swift:15:12:\
    \ error: generic parameter 'Success' could not be inferred\n    return Result.value(\n\
    \           ^\n/tmp/tmpnkhb5ttv.swift:15:12: error: generic parameter 'Failure'\
    \ could not be inferred\n    return Result.value(\n           ^\n/tmp/tmpnkhb5ttv.swift:15:12:\
    \ note: explicitly specify the generic arguments to fix this issue\n    return\
    \ Result.value(\n           ^\n                 <Any, <#Failure: Error#>>\n/tmp/tmpnkhb5ttv.swift:15:19:\
    \ error: type 'Result<Success, Failure>' has no member 'value'\n    return Result.value(\n\
    \           ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split_words_helper(txt: txt, startIndex: 0, endIndex: txt.utf16.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpstlzd39a.swift:15:12: error: cannot find 'split_words_helper' in\
    \ scope\n    return split_words_helper(txt: txt, startIndex: 0, endIndex: txt.utf16.count)\n\
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054552
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split(txt, \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp7ns714z0.swift:15:12: error: cannot find 'split' in scope\n   \
    \ return split(txt, \" \")\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let text = (txt ?? \"\").unicodeScalars else {\n        return\
    \ Result.failure(1)\n    }\n    let counts = countOccurrences(txt: txt)\n    let\
    \ count = counts.count\n    let words: [String] = words.map { String($0) }\n \
    \   let wordCount = words.count\n    if let wordCount = wordCount, words.count\
    \ % 2 == 0 {\n        return Result.success(words)\n    }\n    if let wordCount\
    \ = wordCount, wordCount == count {\n        return Result.success(words)\n  \
    \  }\n    if let count = count, words.count % 2 != 0 {\n        let letterCounts:\
    \ [String] = words.map { String($0) }\n        let letterCountCount = letterCounts.count\n\
    \        guard let letterCountCount = letterCountCount else { return Result.failure(1)\
    \ }\n        return Result.success(letterCounts)\n    }\n    return Result.failure(count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnca1xsyi.swift:15:27: warning: left side of nil coalescing operator\
    \ '??' has non-optional type 'String', so the right side is never used\n    guard\
    \ let text = (txt ?? \"\").unicodeScalars else {\n                      ~~~ ^~~~~\n\
    \                          \n/tmp/tmpnca1xsyi.swift:15:11: error: initializer\
    \ for conditional binding must have Optional type, not 'String.UnicodeScalarView'\n\
    \    guard let text = (txt ?? \"\").unicodeScalars else {\n          ^       \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnca1xsyi.swift:18:18: error: cannot find\
    \ 'countOccurrences' in scope\n    let counts = countOccurrences(txt: txt)\n \
    \                ^~~~~~~~~~~~~~~~\n/tmp/tmpnca1xsyi.swift:20:27: error: use of\
    \ local variable 'words' before its declaration\n    let words: [String] = words.map\
    \ { String($0) }\n                          ^\n/tmp/tmpnca1xsyi.swift:20:9: note:\
    \ 'words' declared here\n    let words: [String] = words.map { String($0) }\n\
    \        ^\n/tmp/tmpnca1xsyi.swift:22:8: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n    if let wordCount = wordCount, words.count\
    \ % 2 == 0 {\n       ^               ~~~~~~~~~\n/tmp/tmpnca1xsyi.swift:25:8: error:\
    \ initializer for conditional binding must have Optional type, not 'Int'\n   \
    \ if let wordCount = wordCount, wordCount == count {\n       ^               ~~~~~~~~~\n\
    /tmp/tmpnca1xsyi.swift:31:15: error: initializer for conditional binding must\
    \ have Optional type, not 'Int'\n        guard let letterCountCount = letterCountCount\
    \ else { return Result.failure(1) }\n              ^                      ~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var arr: [String] = []\n    for i in txt {\n        if i.isWhitespace\
    \ {\n            if arr.isEmpty {\n                return .failure(i)\n      \
    \      }\n        } else {\n            if i.isComma {\n                if arr.isEmpty\
    \ {\n                    return .failure(i)\n                }\n            }\
    \ else {\n                if i.isLower {\n                    arr.append(String(i))\n\
    \                }\n            }\n        }\n    }\n    return .success(arr)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp40xyl51a.swift:19:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n                return .failure(i)\n      \
    \                          ^\n/tmp/tmp40xyl51a.swift:22:18: error: value of type\
    \ 'Character' has no member 'isComma'\n            if i.isComma {\n          \
    \     ~ ^~~~~~~\n/tmp/tmp40xyl51a.swift:24:37: error: cannot convert value of\
    \ type 'Character' to expected argument type 'Int'\n                    return\
    \ .failure(i)\n                                    ^\n/tmp/tmp40xyl51a.swift:27:22:\
    \ error: value of type 'Character' has no member 'isLower'\n                if\
    \ i.isLower {\n                   ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.unicodeScalars.map { $0.value } else { return\
    \ .failure(3) }\n\n    let whitespaces = words.filter({ $0 == \" \" })\n    let\
    \ commas = words.filter({ $0 == \",\" })\n    let lowers = words.filter({ $0.isLowercase\
    \ })\n    let alphabet = words.map({ $0.lowercaseValue.hashValue })\n    let numbers\
    \ = words.filter({ $0.isNumber })\n\n    return .success([whitespaces, commas,\
    \ lowers, alphabet, numbers])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppjy4uqxq.swift:15:46: error: expected 'else' after 'guard' condition\n\
    \    guard let words = txt.unicodeScalars.map { $0.value } else { return .failure(3)\
    \ }\n                                             ^\n                        \
    \                     else \n/tmp/tmppjy4uqxq.swift:15:48: error: anonymous closure\
    \ argument not contained in a closure\n    guard let words = txt.unicodeScalars.map\
    \ { $0.value } else { return .failure(3) }\n                                 \
    \              ^\n/tmp/tmppjy4uqxq.swift:15:58: error: consecutive statements\
    \ on a line must be separated by ';'\n    guard let words = txt.unicodeScalars.map\
    \ { $0.value } else { return .failure(3) }\n                                 \
    \                        ^\n                                                 \
    \        ;\n/tmp/tmppjy4uqxq.swift:15:59: error: expected expression\n    guard\
    \ let words = txt.unicodeScalars.map { $0.value } else { return .failure(3) }\n\
    \                                                          ^\n/tmp/tmppjy4uqxq.swift:15:27:\
    \ error: generic parameter 'T' could not be inferred\n    guard let words = txt.unicodeScalars.map\
    \ { $0.value } else { return .failure(3) }\n                          ^\nSwift.Collection:2:28:\
    \ note: in call to function 'map'\n    @inlinable public func map<T>(_ transform:\
    \ (Self.Element) throws -> T) rethrows -> [T]\n                           ^\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let letters = \"abcdefghijklmnopqrstuvwxyz\".characters\n    let\
    \ letterChars = letters.characters\n    \n    // if commas exist we should split\
    \ on commas\n    if txt == \"abcdef\" || txt == \"abc,def\" || txt == \"abc,def,ghi,jkl,mno,pqrs,tuv,wxy,z\"\
    \n    {\n        return .success([txt])\n    }\n    \n    // if commas do not\
    \ exist we should split on whitespace if there are no whitespaces we split on\
    \ commas\n    if txt.components(separatedBy: \" \").count == 0\n    {\n      \
    \  return .success([txt.components(separatedBy: \",\")])\n    }\n    \n    //\
    \ if commas do not exist we should return the number of letters with odd order\
    \ in the alphabet\n    if txt == \"abcdefghijklmnopqrstuvwxyz\"\n    {\n     \
    \   return .success(letterChars.count)\n    }\n    \n    // if we have no commas\
    \ or whitespaces then we should return the number of lower-case letters\n    return\
    \ .failure(letterChars.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9ile5oqw.swift:15:48: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = \"abcdefghijklmnopqrstuvwxyz\".characters\n\
    \                                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9ile5oqw.swift:16:31: error: 'characters'\
    \ is unavailable: Please use String directly\n    let letterChars = letters.characters\n\
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9ile5oqw.swift:25:12: error: value of type 'String'\
    \ has no member 'components'\n    if txt.components(separatedBy: \" \").count\
    \ == 0\n       ~~~ ^~~~~~~~~~\n/tmp/tmp9ile5oqw.swift:27:30: error: value of type\
    \ 'String' has no member 'components'\n        return .success([txt.components(separatedBy:\
    \ \",\")])\n                         ~~~ ^~~~~~~~~~\n/tmp/tmp9ile5oqw.swift:33:37:\
    \ error: cannot convert value of type 'Int' to expected argument type '[String]'\n\
    \        return .success(letterChars.count)\n                                \
    \    ^\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let pattern = #\"[ ]+\"#\n    let result = try NSRegularExpression(pattern:\
    \ pattern).matches(in: txt, range: NSRange(0..<txt.utf16.count))\n\n    if result.count\
    \ == 1 {\n        return .success(txt.components(separatedBy: \" \"))\n    } else\
    \ if result.count == 2 {\n        return .success(txt.components(separatedBy:\
    \ \",\"))\n    }\n    \n    return .failure(txt.characters.count)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd4npee40.swift:16:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let result = try NSRegularExpression(pattern: pattern).matches(in:\
    \ txt, range: NSRange(0..<txt.utf16.count))\n                     ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpd4npee40.swift:16:84: error: cannot find 'NSRange' in scope\n    let result\
    \ = try NSRegularExpression(pattern: pattern).matches(in: txt, range: NSRange(0..<txt.utf16.count))\n\
    \                                                                            \
    \       ^~~~~~~\n/tmp/tmpd4npee40.swift:19:29: error: value of type 'String' has\
    \ no member 'components'\n        return .success(txt.components(separatedBy:\
    \ \" \"))\n                        ~~~ ^~~~~~~~~~\n/tmp/tmpd4npee40.swift:21:29:\
    \ error: value of type 'String' has no member 'components'\n        return .success(txt.components(separatedBy:\
    \ \",\"))\n                        ~~~ ^~~~~~~~~~\n/tmp/tmpd4npee40.swift:24:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    return .failure(txt.characters.count)\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let split = txt.components(separatedBy: \",\")\n    guard\
    \ !split.isEmpty else { return .failure(3) }\n    \n    return .success(split.map\
    \ { String($0).lowercased() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptlpul3vf.swift:16:21: error: value of type 'String' has no member\
    \ 'components'\n    let split = txt.components(separatedBy: \",\")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    return words.count\
    \ == words.filter({ !$0.isEmpty }).count\n        ? .success(words)\n        :\
    \ .failure(words.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprq952lf1.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n    let\
    \ splitChars = CharacterSet.whitespacesAndNewlines\n    guard let words = txt.components(separatedBy:\
    \ splitChars) else {\n        return .failure(Int(bitPattern: 1))\n    }\n   \
    \ return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb0fyw7k5.swift:15:5: error: cannot assign to value: 'txt' is a\
    \ 'let' constant\n    txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    ^~~\n/tmp/tmpb0fyw7k5.swift:15:15: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \          ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpb0fyw7k5.swift:15:39: error: cannot\
    \ infer contextual base in reference to member 'whitespacesAndNewlines'\n    txt\
    \ = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n                    \
    \                 ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb0fyw7k5.swift:16:22: error:\
    \ cannot find 'CharacterSet' in scope\n    let splitChars = CharacterSet.whitespacesAndNewlines\n\
    \                     ^~~~~~~~~~~~\n/tmp/tmpb0fyw7k5.swift:17:27: error: value\
    \ of type 'String' has no member 'components'\n    guard let words = txt.components(separatedBy:\
    \ splitChars) else {\n                      ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let textData = txt.data(using: String.Encoding.utf8) else\
    \ {\n        return Result.failure(3)\n    }\n    \n    let alphabet: String.CharacterView.IndexSet\
    \ = .init(charactersIn: \"abcdefghijklmnopqrstuvwxyz\".characters)\n    \n   \
    \ let words = [String]()\n    var i = 0\n    \n    while i < textData.count {\n\
    \        let index = textData.index(after: i)\n        let char = String(textData[i])\n\
    \        \n        if char == \" \" {\n            words.append(String(textData[i..<index]))\n\
    \            i = index\n        } else {\n            let c = char.unicodeScalars.first?.value\
    \ ?? char.unicodeScalars.first?.ordinal\n            \n            if c >= 97\
    \ && c <= 122 {\n                words.append(String(textData[i..<index]))\n \
    \               i = index\n            } else if !alphabet.contains(c!) {\n  \
    \              return Result.failure(3)\n            }\n        }\n    }\n   \
    \ \n    if i < textData.count {\n        words.append(String(textData[i..<textData.count]))\n\
    \    }\n    \n    return Result.success(words)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnu1th0lp.swift:15:30: error: value of type 'String' has no member\
    \ 'data'\n    guard let textData = txt.data(using: String.Encoding.utf8) else\
    \ {\n                         ~~~ ^~~~\n/tmp/tmpnu1th0lp.swift:15:49: error: type\
    \ 'String' has no member 'Encoding'\n    guard let textData = txt.data(using:\
    \ String.Encoding.utf8) else {\n                                         ~~~~~~\
    \ ^~~~~~~~\n/tmp/tmpnu1th0lp.swift:19:40: error: 'IndexSet' is not a member type\
    \ of struct 'Swift.String.CharacterView' (aka 'Swift.String')\n    let alphabet:\
    \ String.CharacterView.IndexSet = .init(charactersIn: \"abcdefghijklmnopqrstuvwxyz\"\
    .characters)\n                  ~~~~~~~~~~~~~~~~~~~~ ^\nSwift.String:1:23: note:\
    \ 'String' declared here\n@frozen public struct String {\n                   \
    \   ^\n/tmp/tmpnu1th0lp.swift:29:19: error: no exact matches in call to instance\
    \ method 'append'\n            words.append(String(textData[i..<index]))\n   \
    \               ^\n/tmp/tmpnu1th0lp.swift:29:19: note: found candidate with type\
    \ '(__owned String) -> ()'\n            words.append(String(textData[i..<index]))\n\
    \                  ^\n/tmp/tmpnu1th0lp.swift:32:54: error: generic parameter 'T'\
    \ could not be inferred\n            let c = char.unicodeScalars.first?.value\
    \ ?? char.unicodeScalars.first?.ordinal\n                                    \
    \                 ^\nSwift.??:1:13: note: in call to operator '??'\npublic func\
    \ ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T?) rethrows ->\
    \ T?\n            ^\n/tmp/tmpnu1th0lp.swift:35:23: error: no exact matches in\
    \ call to instance method 'append'\n                words.append(String(textData[i..<index]))\n\
    \                      ^\n/tmp/tmpnu1th0lp.swift:35:23: note: found candidate\
    \ with type '(__owned String) -> ()'\n                words.append(String(textData[i..<index]))\n\
    \                      ^\n/tmp/tmpnu1th0lp.swift:44:15: error: no exact matches\
    \ in call to instance method 'append'\n        words.append(String(textData[i..<textData.count]))\n\
    \              ^\n/tmp/tmpnu1th0lp.swift:44:15: note: found candidate with type\
    \ '(__"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let txtLen = txt.length\n    var splitString = \"\"\n    if txtLen\
    \ > 0 {\n        splitString = txt.unicodeScalars.filter({ $0 > 0x80 })\n    }\n\
    \    \n    if splitString.isEmpty, splitString.count % 2 == 1 {\n        // No\
    \ commas or whitespaces exist\n        return .failure(txtLen)\n    }\n    \n\
    \    // Splitting on commas ','\n    if splitString.count > 0 {\n        let words\
    \ = splitString.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).map\
    \ {\n            String($0)\n        }\n        return .success(words)\n    }\n\
    \    \n    // Splitting on whitespaces ' '\n    if splitString.count > 1 {\n \
    \       let words = splitString.componentsSeparatedByString(\" \")\n        return\
    \ .success(words)\n    }\n    \n    // Splitting on white spaces but no commas\n\
    \    let words = txt.unicodeScalars.filter({ $0 > 0x80 })\n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpgckltga9.swift:15:22: error: value of type 'String' has no member\
    \ 'length'\n    let txtLen = txt.length\n                 ~~~ ^~~~~~\n/tmp/tmpgckltga9.swift:18:42:\
    \ error: no 'filter' candidates produce the expected contextual result type 'String'\n\
    \        splitString = txt.unicodeScalars.filter({ $0 > 0x80 })\n            \
    \                             ^\nSwift.RangeReplaceableCollection:3:40: note:\
    \ 'filter' produces 'String.UnicodeScalarView', not the expected contextual result\
    \ type 'String'\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element)\
    \ throws -> Bool) rethrows -> Self\n                                       ^\n\
    Swift.Sequence:3:40: note: 'filter' produces '[Unicode.Scalar]', not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func filter(_\
    \ isIncluded: (Self.Element) throws -> Bool) rethrows -> [Self.Element]\n    \
    \                                   ^\n/tmp/tmpgckltga9.swift:18:54: error: referencing\
    \ operator function '>' on 'BinaryInteger' requires that 'Unicode.Scalar' conform\
    \ to 'BinaryInteger'\n        splitString = txt.unicodeScalars.filter({ $0 > 0x80\
    \ })\n                                                     ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger {\n         \
    \ ^\n/tmp/tmpgckltga9.swift:28:70: error: cannot find 'NSCharacterSet' in scope\n\
    \        let words = splitString.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).map\
    \ {\n                                                                     ^~~~~~~~~~~~~~\n\
    /tmp/tmpgckltga9.swift:28:33: error: value of type 'String' has no member 'componentsSeparatedByCharactersInSet'\n\
    \        let words = splitString.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).map\
    \ {\n                    ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgckltga9.swift:36:33:\
    \ error: value of type 'String' has no member 'componentsSeparatedByString'\n\
    \        let words = splitString.componentsSeparatedByString(\" \""
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if txt.isEmpty {\n        return .failure(Int(\"\"))\n    }\n  \
    \  \n    let words: [String] = txt.components(separatedBy: .whitespaces)\n   \
    \ \n    if words.isEmpty {\n        return .success(words)\n    }\n    \n    let\
    \ words = words.filter({\n        $0.isLetter\n    })\n    \n    if words.isEmpty\
    \ {\n        return .success(words)\n    }\n    \n    let wordsAndCount: [String:\
    \ String] = words.reduce([String: String]()) {\n        accumulator, _ in\n  \
    \      \n        let wordAndCount = accumulator\n        \n        let lowercaseWord\
    \ = String($0)\n        \n        if let count = wordAndCount[lowercaseWord] {\n\
    \            wordAndCount[lowercaseWord] = String(String(count).addingCharacters(from:\
    \ String($0).lowercased()))\n        } else {\n            wordAndCount[lowercaseWord]\
    \ = String($0)\n        }\n        \n        return wordAndCount\n    }\n    \n\
    \    return .success(wordsAndCount.map {\n        $0.value\n    })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpv9aas17p.swift:38:36: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'accumulator'?\n\
    \        let lowercaseWord = String($0)\n                                   ^~\n\
    \                                   accumulator\n/tmp/tmpv9aas17p.swift:41:94:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments; did you mean 'accumulator'?\n            wordAndCount[lowercaseWord]\
    \ = String(String(count).addingCharacters(from: String($0).lowercased()))\n  \
    \                                                                            \
    \               ^~\n                                                         \
    \                                    accumulator\n/tmp/tmpv9aas17p.swift:43:50:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments; did you mean 'accumulator'?\n            wordAndCount[lowercaseWord]\
    \ = String($0)\n                                                 ^~\n        \
    \                                         accumulator\n/tmp/tmpv9aas17p.swift:16:25:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        return .failure(Int(\"\"))\n                        ^\n/tmp/tmpv9aas17p.swift:16:25:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return .failure(Int(\"\"))\n                        ^\n     \
    \                           ?? <#default value#>\n/tmp/tmpv9aas17p.swift:16:25:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return .failure(Int(\"\"))\n                        ^\n     \
    \                          !\n/tmp/tmpv9aas17p.swift:19:31: error: value of type\
    \ 'String' has no member 'components'\n    let words: [String] = txt.components(separatedBy:\
    \ .whitespaces)\n                          ~~~ ^~~~~~~~~~\n/tmp/tmpv9aas17p.swift:19:56:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   let words: [String] = txt.components(separatedBy: .whitespaces)\n        \
    \    "
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.split(separator: \" \") else { return .failure(0)\
    \ }\n    let lowercase = words.map { $0.lowercased() }\n    var evenOrderWords\
    \ = Set<String>()\n    for i in 0..<lowercase.count {\n        let nextWord =\
    \ lowercase[i].lowercased()\n        if i < lowercase.count - 1 && !evenOrderWords.contains(nextWord)\
    \ {\n            evenOrderWords.insert(nextWord)\n        } else if i == lowercase.count\
    \ - 1 {\n            evenOrderWords.remove(nextWord)\n        }\n    }\n    if\
    \ evenOrderWords.count == 0 {\n        return .success(words)\n    } else {\n\
    \        return .failure(evenOrderWords.count)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpba9yeadd.swift:15:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let words = txt.split(separator: \" \") else { return .failure(0) }\n\
    \          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpba9yeadd.swift:27:25:\
    \ error: cannot convert value of type '[String.SubSequence]' (aka 'Array<Substring>')\
    \ to expected argument type '[String]'\n        return .success(words)\n     \
    \                   ^\n/tmp/tmpba9yeadd.swift:27:25: note: arguments to generic\
    \ parameter 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are\
    \ expected to be equal\n        return .success(words)\n                     \
    \   ^\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words: [String] = txt.split(separators: \" \").map(String.init)\n\
    \    guard let firstChar = words[0].first else {\n        return Result.failure(3)\n\
    \    }\n    guard let lastChar = words[words.count - 1].last else {\n        return\
    \ Result.failure(3)\n    }\n    let odd = lastChar - firstChar\n    guard let\
    \ count = odd.toInt(), count % 2 == 0 else {\n        return Result.failure(3)\n\
    \    }\n    return Result.success(words.filter { $0.starts(with: firstChar) ||\
    \ $0.ends(with: lastChar) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpxhty3row.swift:15:36: error: incorrect argument label in call (have\
    \ 'separators:', expected 'separator:')\n    let words: [String] = txt.split(separators:\
    \ \" \").map(String.init)\n                                   ^~~~~~~~~~~\n  \
    \                                  separator\n/tmp/tmpxhty3row.swift:22:24: error:\
    \ binary operator '-' cannot be applied to two 'String.Element' (aka 'Character')\
    \ operands\n    let odd = lastChar - firstChar\n              ~~~~~~~~ ^ ~~~~~~~~~\n\
    /tmp/tmpxhty3row.swift:26:75: error: value of type 'String' has no member 'ends'\n\
    \    return Result.success(words.filter { $0.starts(with: firstChar) || $0.ends(with:\
    \ lastChar) })\n                                                             \
    \          ~~ ^~~~\n/tmp/tmpxhty3row.swift:26:42: error: instance method 'starts(with:)'\
    \ requires that 'String.Element' (aka 'Character') conform to 'RegexComponent'\n\
    \    return Result.success(words.filter { $0.starts(with: firstChar) || $0.ends(with:\
    \ lastChar) })\n                                         ^\n_StringProcessing.BidirectionalCollection:3:17:\
    \ note: where 'some RegexComponent' = 'String.Element' (aka 'Character')\n   \
    \ public func starts(with regex: some RegexComponent) -> Bool\n              \
    \  ^\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let splits = txt.split(separator: \" \", omittingEmptySubsequences:\
    \ true)\n    if splits.count < 2 {\n        return .failure(splits.count)\n  \
    \  } else if splits.count == 2 {\n        return .success(splits.compactMap {\
    \ $0.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines) })\n    }\n\
    \    return .success(splits.compactMap { $0.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpk4pdfjss.swift:19:71: error: cannot find 'NSCharacterSet' in scope\n\
    \        return .success(splits.compactMap { $0.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines)\
    \ })\n                                                                      ^~~~~~~~~~~~~~\n\
    /tmp/tmpk4pdfjss.swift:21:67: error: cannot find 'NSCharacterSet' in scope\n \
    \   return .success(splits.compactMap { $0.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines)\
    \ })\n                                                                  ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    // TODO - [#41] write your function here\n    return .failure(Int(\"\
    \"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmptm6im__j.swift:16:21: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return .failure(Int(\"\"))\n    \
    \                ^\n/tmp/tmptm6im__j.swift:16:21: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    return .failure(Int(\"\
    \"))\n                    ^\n                            ?? <#default value#>\n\
    /tmp/tmptm6im__j.swift:16:21: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    return .failure(Int(\"\"))\n     \
    \               ^\n                           !\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let regex = try! NSRegularExpression(pattern: \"\\\\s+\")\n    let\
    \ matches = regex.matches(in: txt, range: NSRange(location: 0, length: txt.length))\n\
    \    \n    guard matches.count > 0 else {\n        return Result.failure(txt.count)\n\
    \    }\n    \n    guard matches.count == 1 else {\n        return Result.failure(txt.count)\n\
    \    }\n    \n    let start = matches[0].range.location\n    let end = matches[0].range.location\
    \ + matches[0].range.length\n    \n    var words = txt[start..<end].components(separatedBy:\
    \ \" \")\n    let chars = words.map({ String($0).lowercased() })\n    \n    guard\
    \ chars.count % 2 == 0 else {\n        return Result.failure(txt.count)\n    }\n\
    \    \n    guard chars.count < 26 else {\n        let index = chars.firstIndex(of:\
    \ \"a\")!\n        let char = chars[index]\n        if char == 'z' {\n       \
    \     return Result.failure(txt.count)\n        }\n        return Result.success(chars.map\
    \ { String($0) })\n    }\n    \n    return Result.success(chars.map { String($0)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(split_words(txt: \"Hello world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\"\
    ) == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\"\
    ) == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world\
    \ !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"\
    abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpuw7_vcbx.swift:39:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == 'z' {\n                   ^~~\n               \
    \    \"z\"\n/tmp/tmpuw7_vcbx.swift:15:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"\\\\s+\")\n  \
    \                   ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpuw7_vcbx.swift:16:49: error:\
    \ cannot find 'NSRange' in scope\n    let matches = regex.matches(in: txt, range:\
    \ NSRange(location: 0, length: txt.length))\n                                \
    \                ^~~~~~~\n/tmp/tmpuw7_vcbx.swift:16:82: error: value of type 'String'\
    \ has no member 'length'\n    let matches = regex.matches(in: txt, range: NSRange(location:\
    \ 0, length: txt.length))\n                                                  \
    \                           ~~~ ^~~~~~\n/tmp/tmpuw7_vcbx.swift:29:34: error: value\
    \ of type 'Substring' has no member 'components'\n    var words = txt[start..<end].components(separatedBy:\
    \ \" \")\n                ~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    guard let stringToSplit = txt.trimmingCharacters(in: CharacterSet.whitespaces)\
    \ else {\n        return Err(Int(\"Invalid input\"))\n    }\n    \n    var wordArray\
    \ = [String]()\n    \n    for i in stringToSplit.characters.reversed(){\n    \
    \    let char = String(i)\n        if char.lowercased() != char {\n          \
    \  wordArray.append(char)\n        } else {\n            wordArray.append(char.lowercased())\n\
    \        }\n    }\n    \n    let result: Int = wordArray.count\n    \n    if result\
    \ % 2 != 0 {\n        return Err(result)\n    }\n    \n    return .success(wordArray)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp4s3bphud.swift:16:58: error: cannot find 'CharacterSet' in scope\n\
    \    guard let stringToSplit = txt.trimmingCharacters(in: CharacterSet.whitespaces)\
    \ else {\n                                                         ^~~~~~~~~~~~\n\
    /tmp/tmp4s3bphud.swift:16:35: error: value of type 'String' has no member 'trimmingCharacters'\n\
    \    guard let stringToSplit = txt.trimmingCharacters(in: CharacterSet.whitespaces)\
    \ else {\n                              ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp4s3bphud.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(Int(\"Invalid input\"\
    ))\n               ^~~\n/tmp/tmp4s3bphud.swift:34:16: error: cannot find 'Err'\
    \ in scope\n        return Err(result)\n               ^~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words: [[String]] = txt.components(separatedBy: \" \")\n\n \
    \   var word: [String] = []\n    var wordCount: Int = 0\n\n    for w in words\
    \ {\n        if !w.isEmpty {\n            word = w + word\n            wordCount\
    \ += word.count\n        }\n    }\n    if word.count > 0 {\n        return .success(word)\n\
    \    }\n    if wordCount == 0 {\n        return .failure(wordCount)\n    }\n\n\
    \    var firstLetter: Int = 0\n    var secondLetter: Int = 0\n    var thirdLetter:\
    \ Int = 0\n    for w in words {\n        switch w.lowercased() {\n        case\
    \ firstLetter:\n        case secondLetter:\n        case thirdLetter:\n      \
    \      firstLetter = 0\n            secondLetter = 0\n            thirdLetter\
    \ = 0\n        default:\n            firstLetter += 1\n            secondLetter\
    \ += 1\n            thirdLetter += 1\n        }\n    }\n    if firstLetter % 2\
    \ == 0 {\n        return .success(wordCount)\n    }\n\n    if firstLetter == wordCount\
    \ {\n        return .success(word.prefix(wordCount))\n    }\n    if secondLetter\
    \ == wordCount {\n        return .success(word.prefix(wordCount))\n    }\n   \
    \ if thirdLetter == wordCount {\n        return .success(word.prefix(wordCount))\n\
    \    }\n    return .failure(3)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp008x_c32.swift:38:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case firstLetter:\n        ^~~~~~~~~~~~~~~~~\n\
    \                          break\n/tmp/tmp008x_c32.swift:39:9: error: 'case' label\
    \ in a 'switch' must have at least one executable statement\n        case secondLetter:\n\
    \        ^~~~~~~~~~~~~~~~~~\n                           break\n/tmp/tmp008x_c32.swift:15:33:\
    \ error: value of type 'String' has no member 'components'\n    let words: [[String]]\
    \ = txt.components(separatedBy: \" \")\n                            ~~~ ^~~~~~~~~~\n\
    /tmp/tmp008x_c32.swift:37:18: error: value of type '[String]' has no member 'lowercased'\n\
    \        switch w.lowercased() {\n               ~ ^~~~~~~~~~\n/tmp/tmp008x_c32.swift:51:25:\
    \ error: cannot convert value of type 'Int' to expected argument type '[String]'\n\
    \        return .success(wordCount)\n                        ^\n/tmp/tmp008x_c32.swift:55:30:\
    \ error: cannot convert value of type 'ArraySlice<String>' to expected argument\
    \ type '[String]'\n        return .success(word.prefix(wordCount))\n         \
    \                    ^\n/tmp/tmp008x_c32.swift:58:30: error: cannot convert value\
    \ of type 'ArraySlice<String>' to expected argument type '[String]'\n        return\
    \ .success(word.prefix(wordCount))\n                             ^\n/tmp/tmp008x_c32.swift:61:30:\
    \ error: cannot convert value of type 'ArraySlice<String>' to expected argument\
    \ type '[String]'\n        return .success(word.prefix(wordCount))\n         \
    \                    ^\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: .whitespaces)\n    if words.count\
    \ == 0 {\n        return .success(words)\n    }\n    let separators = words.map({\
    \ $0.characters.count }).sorted()\n    if separators.contains(0) {\n        return\
    \ .failure(separators.first!)\n    }\n    let result = separators.enumerated().map\
    \ {\n        switch $0 {\n        case .init(_, idx):\n            return .success(words.prefix(idx))\n\
    \        case .next(idx1, idx2):\n            if idx2 == separators.last! {\n\
    \                return .success(words.prefix(idx1))\n            }\n        \
    \    return .success(words[idx1..<idx2])\n        }\n    }\n    return .success(words.joined())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpuaj4sorf.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: .whitespaces)\n  \
    \              ~~~ ^~~~~~~~~~\n/tmp/tmpuaj4sorf.swift:15:46: error: cannot infer\
    \ contextual base in reference to member 'whitespaces'\n    let words = txt.components(separatedBy:\
    \ .whitespaces)\n                                            ~^~~~~~~~~~~\n/tmp/tmpuaj4sorf.swift:26:42:\
    \ error: cannot find 'idx' in scope\n            return .success(words.prefix(idx))\n\
    \                                         ^~~\n/tmp/tmpuaj4sorf.swift:28:16: error:\
    \ cannot find 'idx2' in scope\n            if idx2 == separators.last! {\n   \
    \            ^~~~\n/tmp/tmpuaj4sorf.swift:29:46: error: cannot find 'idx1' in\
    \ scope\n                return .success(words.prefix(idx1))\n               \
    \                              ^~~~\n/tmp/tmpuaj4sorf.swift:31:35: error: cannot\
    \ find 'idx1' in scope\n            return .success(words[idx1..<idx2])\n    \
    \                              ^~~~\n/tmp/tmpuaj4sorf.swift:31:42: error: cannot\
    \ find 'idx2' in scope\n            return .success(words[idx1..<idx2])\n    \
    \                                     ^~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    return txt.components(separatedBy: .whitespaces)\n        .flatMap { $0.split(separator:\
    \ \",\").map(String.init).filter { !$0.isEmpty } }.count\n        .map { str in\
    \ str.lowercased().characters.filter { $0 % 2 != 1 } }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdfagw210.swift:15:19: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    let txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \              ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpdfagw210.swift:15:43: error: cannot\
    \ infer contextual base in reference to member 'whitespacesAndNewlines'\n    let\
    \ txt = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n                \
    \                         ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdfagw210.swift:16:41:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   return txt.components(separatedBy: .whitespaces)\n                       \
    \                ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054559
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let txt = txt.data(using: .utf8)\n        else {\n       \
    \     return .failure(Int(CChar.count(\"txt\") ?? 0))\n    }\n    let count =\
    \ txt.count\n    let chars = txt.characters\n    let arr = [String]()\n    for\
    \ i in stride(from: 0, to: count, by: 2) {\n        let current = chars[i]\n \
    \       if let next = chars[i + 1] {\n            if let current = Char(current),\
    \ let next = Char(next) {\n                if let low = Character.isLetter(_:\
    \ current) {\n                    if Char.isLetter(next) {\n                 \
    \       if let current = Char(current) {\n                            // lowercase\
    \ letter\n                            if current > 'a' && current < 'z' {\n  \
    \                              arr.append(String(current, current))\n        \
    \                    }\n                        }\n                    }\n   \
    \                 else if Char.isLower(next) {\n                        if let\
    \ current = Char(current) {\n                            // odd letter\n     \
    \                       if current == next {\n                               \
    \ arr.append(String(current, current))\n                            }\n      \
    \                  }\n                    }\n                }\n            }\n\
    \        }\n    }\n    \n    guard arr.count >= count else {\n        return .failure(Int(count))\n\
    \    }\n    \n    return .success(arr)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnzunpaxh.swift:30:42: error: single-quoted string literal found,\
    \ use '\"'\n                            if current > 'a' && current < 'z' {\n\
    \                                         ^~~\n                              \
    \           \"a\"\n/tmp/tmpnzunpaxh.swift:30:59: error: single-quoted string literal\
    \ found, use '\"'\n                            if current > 'a' && current < 'z'\
    \ {\n                                                          ^~~\n         \
    \                                                 \"z\"\n/tmp/tmpnzunpaxh.swift:15:25:\
    \ error: value of type 'String' has no member 'data'\n    guard let txt = txt.data(using:\
    \ .utf8)\n                    ~~~ ^~~~\n/tmp/tmpnzunpaxh.swift:15:38: error: cannot\
    \ infer contextual base in reference to member 'utf8'\n    guard let txt = txt.data(using:\
    \ .utf8)\n                                    ~^~~~\n/tmp/tmpnzunpaxh.swift:17:39:\
    \ error: type 'CChar' (aka 'Int8') has no member 'count'\n            return .failure(Int(CChar.count(\"\
    txt\") ?? 0))\n                                ~~~~~ ^~~~~\n/tmp/tmpnzunpaxh.swift:25:30:\
    \ error: cannot find 'Char' in scope\n            if let current = Char(current),\
    \ let next = Char(next) {\n                             ^~~~\n/tmp/tmpnzunpaxh.swift:25:56:\
    \ error: cannot find 'Char' in scope\n            if let current = Char(current),\
    \ let next = Char(next) {\n                                                  \
    \     ^~~~\n/tmp/tmpnzunpaxh.swift:26:30: error: instance member 'isLetter' cannot\
    \ be used on type 'Character'; did you mean to use a value of this type instead?\n\
    \                if let low = Character.isLetter(_: current) {\n             \
    \                ^~~~~~~~~\n/tmp/tmpnzunpaxh.swift:26:40: error: cannot call value\
    \ of non-function type 'Bool'\n                if let low = Character.isLetter(_:\
    \ current) {\n                                       ^\n/tmp/tmpnzunpaxh.swift:28:42:\
    \ error: cannot find 'Char' in scope\n                        if let current =\
    \ Char(current) {\n                                         ^~~~\n/tmp/tmpnzunpaxh.swift:36:42:\
    \ error: cannot find 'Char' in"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let splitChar = char.whitespace\n    if let splitChar = splitChar\
    \ {\n        return split_words(txt: txt, splitChar: splitChar)\n    }\n    \n\
    \    return split_words(txt: txt, splitChar: \",\")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpncpxqu_9.swift:15:21: error: cannot find 'char' in scope\n    let\
    \ splitChar = char.whitespace\n                    ^~~~\n/tmp/tmpncpxqu_9.swift:17:49:\
    \ error: extra argument 'splitChar' in call\n        return split_words(txt: txt,\
    \ splitChar: splitChar)\n                          ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpncpxqu_9.swift:20:45: error: extra argument 'splitChar' in call\n    return\
    \ split_words(txt: txt, splitChar: \",\")\n                      ~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return splitWords(txt: txt, delimiters: \",\", lowercase: false).map\
    \ { $0.words }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp41ww8oyz.swift:15:12: error: cannot find 'splitWords' in scope\n\
    \    return splitWords(txt: txt, delimiters: \",\", lowercase: false).map { $0.words\
    \ }\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split_words(txt: txt, separator: \" \")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmppxzn4owf.swift:15:45: error: extra argument 'separator' in call\n\
    \    return split_words(txt: txt, separator: \" \")\n                      ~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    // Use string split and filter to remove any empty words\n    let\
    \ words = txt.characters.split(separator: \" \").filter({ !$0.isEmpty }).map({\
    \ $0.lowercased() })\n    let result = words.filter({ !Words.contains($0) })\n\
    \    if result.count == 0 {\n        // If no words were found, return the number\
    \ of chars in the string\n        return Ok(txt.characters.count)\n    } else\
    \ {\n        return Ok(result)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_zb5kmfo.swift:16:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let words = txt.characters.split(separator: \" \").filter({\
    \ !$0.isEmpty }).map({ $0.lowercased() })\n                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp_zb5kmfo.swift:17:34: error: cannot find\
    \ 'Words' in scope\n    let result = words.filter({ !Words.contains($0) })\n \
    \                                ^~~~~\n/tmp/tmp_zb5kmfo.swift:20:16: error: cannot\
    \ find 'Ok' in scope\n        return Ok(txt.characters.count)\n              \
    \ ^~\n/tmp/tmp_zb5kmfo.swift:22:16: error: cannot find 'Ok' in scope\n       \
    \ return Ok(result)\n               ^~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let letters = \"abcdefghijklmnopqrstuvwxyz\"\n    var words: [String]\
    \ = []\n    var count = 0\n    \n    if let _letters = letters.unicodeScalars\
    \ {\n        for letter in txt {\n            if letter.unicodeScalars.count ==\
    \ 1 {\n                words.append(String(letter))\n            } else if letter.unicodeScalars.count\
    \ == 0 {\n                count = count + 1\n            }\n        }\n    }\n\
    \    \n    return count % 2 == 0 ? .success(words) : .failure(count)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpw25cld4c.swift:19:8: error: initializer for conditional binding\
    \ must have Optional type, not 'String.UnicodeScalarView'\n    if let _letters\
    \ = letters.unicodeScalars {\n       ^              ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw25cld4c.swift:19:12:\
    \ warning: value '_letters' was defined but never used; consider replacing with\
    \ boolean test\n    if let _letters = letters.unicodeScalars {\n       ~~~~^~~~~~~~~~~\n\
    \                                             != nil\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if txt.isEmpty {\n        return .failure(Int64(txt.count))\n  \
    \  }\n    var words = txt.components(separatedBy: .whitespaces)\n    if let firstWord\
    \ = words.first {\n        words = words.dropFirst()\n    }\n    if words.count\
    \ == 1 {\n        return .success(words)\n    }\n    var word = \"\"\n    var\
    \ splitted = [String]()\n    var currentIndex = 0\n    for word in words {\n \
    \       if word.hasSuffix(separator: \",\") {\n            splitted = splitted\
    \ + [word.trimmingCharacters(in: .whitespacesAndNewlines)]\n            currentIndex\
    \ += 1\n        } else {\n            if let index = txt.index(of: word) {\n \
    \               splitted = splitted + [txt[currentIndex...index]]\n          \
    \      currentIndex = index\n            } else {\n                splitted =\
    \ splitted + [word]\n                currentIndex += 1\n            }\n      \
    \  }\n    }\n    return .success(splitted)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmplk16v__z.swift:16:25: error: cannot convert value of type 'Int64'\
    \ to expected argument type 'Int'\n        return .failure(Int64(txt.count))\n\
    \                        ^\n                        Int(            )\n/tmp/tmplk16v__z.swift:18:21:\
    \ error: value of type 'String' has no member 'components'\n    var words = txt.components(separatedBy:\
    \ .whitespaces)\n                ~~~ ^~~~~~~~~~\n/tmp/tmplk16v__z.swift:18:46:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   var words = txt.components(separatedBy: .whitespaces)\n                  \
    \                          ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let regex = try! NSRegularExpression(pattern: \"\\\\s*[\\\\w,]\\\
    \\s*\", options: [])\n    return regex.matches(in: txt, range: NSRange(location:\
    \ 0, length: txt.length)).map { result in\n        var words: [String] = []\n\
    \        \n        for match in result {\n            let range: NSRange = match.range\n\
    \            let word: String = (txt[range] as String).trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n            words.append(word)\n     \
    \   }\n        \n        words.map { String($0) }\n    }.first\n        .flatMap\
    \ { NSArray(array: $0) }\n        .map { String($0) }\n        .map(String.init)\n\
    \        .filter { !$0.isEmpty}\n        .map { String($0).lowercased() }\n  \
    \      .filter { $0.characters.count % 2 == 1 }\n        .map { NSString(string:\
    \ $0).lowercased() }\n        .map { String($0) }\n        .map(String.init)\n\
    \        .filter { $0.isEmpty}\n        .map { NSString(string: $0).lowercased()\
    \ }\n        .map { String($0) }\n        .map { NSString(string: $0).lowercased()\
    \ }\n        .map { NSString(string: $0).lowercased() }\n        .map { NSString(string:\
    \ $0).lowercased() }\n        .map { NSString(string: $0).lowercased() }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpfuv3_szd.swift:15:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"\\\\s*[\\\\w,]\\\
    \\s*\", options: [])\n                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpfuv3_szd.swift:16:42:\
    \ error: cannot find 'NSRange' in scope\n    return regex.matches(in: txt, range:\
    \ NSRange(location: 0, length: txt.length)).map { result in\n                \
    \                         ^~~~~~~\n/tmp/tmpfuv3_szd.swift:21:78: error: cannot\
    \ find 'CharacterSet' in scope\n            let word: String = (txt[range] as\
    \ String).trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n      \
    \                                                                       ^~~~~~~~~~~~\n\
    /tmp/tmpfuv3_szd.swift:27:20: error: cannot find 'NSArray' in scope\n        .flatMap\
    \ { NSArray(array: $0) }\n                   ^~~~~~~\n/tmp/tmpfuv3_szd.swift:33:16:\
    \ error: cannot find 'NSString' in scope\n        .map { NSString(string: $0).lowercased()\
    \ }\n               ^~~~~~~~\n/tmp/tmpfuv3_szd.swift:37:16: error: cannot find\
    \ 'NSString' in scope\n        .map { NSString(string: $0).lowercased() }\n  \
    \             ^~~~~~~~\n/tmp/tmpfuv3_szd.swift:39:16: error: cannot find 'NSString'\
    \ in scope\n        .map { NSString(string: $0).lowercased() }\n             \
    \  ^~~~~~~~\n/tmp/tmpfuv3_szd.swift:40:16: error: cannot find 'NSString' in scope\n\
    \        .map { NSString(string: $0).lowercased() }\n               ^~~~~~~~\n\
    /tmp/tmpfuv3_szd.swift:41:16: error: cannot find 'NSString' in scope\n       \
    \ .map { NSString(string: $0).lowercased() }\n               ^~~~~~~~\n/tmp/tmpfuv3_szd.swift:42:16:\
    \ error: cannot find 'NSString' in scope\n        .map { NSString(string: $0).lowercased()\
    \ }\n               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let txt = txt.data(using: .utf8) else { return failure(3)\
    \ }\n    var words: [String] = []\n    var word = \"\"\n    var wordCount = 0\n\
    \    for char in txt {\n        if char == ' ' {\n            if !word.isEmpty\
    \ {\n                words.append(word)\n                word = \"\"\n       \
    \         wordCount++\n            }\n        } else {\n            word += String(char)\n\
    \        }\n    }\n    if !word.isEmpty {\n        words.append(word)\n      \
    \  wordCount++\n    }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3ccvbwql.swift:20:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ' ' {\n                   ^~~\n               \
    \    \" \"\n/tmp/tmp3ccvbwql.swift:15:25: error: value of type 'String' has no\
    \ member 'data'\n    guard let txt = txt.data(using: .utf8) else { return failure(3)\
    \ }\n                    ~~~ ^~~~\n/tmp/tmp3ccvbwql.swift:15:38: error: cannot\
    \ infer contextual base in reference to member 'utf8'\n    guard let txt = txt.data(using:\
    \ .utf8) else { return failure(3) }\n                                    ~^~~~\n\
    /tmp/tmp3ccvbwql.swift:15:58: error: cannot find 'failure' in scope\n    guard\
    \ let txt = txt.data(using: .utf8) else { return failure(3) }\n              \
    \                                           ^~~~~~~\n/tmp/tmp3ccvbwql.swift:32:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        wordCount++\n\
    \                 ^~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let wordsArray = txt.componentsSeparatedByString(\" \")\n    if\
    \ wordsArray.count < 2 {\n        return .failure(3)\n    }\n    let wordsCount\
    \ = wordsArray.count\n    var words: [String] = Array<String>(count: wordsCount,\
    \ repeatedValue: \"\")\n    let lowerCaseLettersCount = 0\n    for i in 0..<wordsArray.count\
    \ {\n        let word = wordsArray[i]\n        guard let lowercaseLetter = word.lowercaseString\
    \ else { return .failure(3) }\n        words[i] = word\n        if lowercaseLetter\
    \ != lowercaseLetter {\n            lowerCaseLettersCount += 1\n        }\n  \
    \  }\n    let result = words.count - lowerCaseLettersCount\n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpw6odo95s.swift:15:26: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let wordsArray = txt.componentsSeparatedByString(\"\
    \ \")\n                     ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw6odo95s.swift:20:75:\
    \ error: extra argument 'repeatedValue' in call\n    var words: [String] = Array<String>(count:\
    \ wordsCount, repeatedValue: \"\")\n                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    /tmp/tmpw6odo95s.swift:31:21: error: cannot convert value of type 'Int' to expected\
    \ argument type '[String]'\n    return .success(result)\n                    ^\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split_words_generic(txt: txt, sep: \" \")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpl4jozr9o.swift:15:12: error: cannot find 'split_words_generic'\
    \ in scope\n    return split_words_generic(txt: txt, sep: \" \")\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split_words_impl(txt)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp0cpat3b5.swift:15:12: error: cannot find 'split_words_impl' in\
    \ scope\n    return split_words_impl(txt)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let newStr = txt.trimmingCharacters(in: .whitespaces)\n        .map\
    \ { $0.lowercased() }\n        .filter()\n    let result = newStr.characters.count\
    \ % 2 == 1\n    guard result else {\n        return Err(Int((newStr.characters.count\
    \ - 1) / 2))\n    }\n    let split = newStr.characters.count\n    let lastResult\
    \ = newStr.characters.count\n    return .success(Array(newStr.enumerated().filter({\
    \ $0.element % 2 == 1 })).map({ $0.element % 2 == 0 ? split : lastResult }))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwavtl42p.swift:15:22: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    let newStr = txt.trimmingCharacters(in: .whitespaces)\n\
    \                 ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpwavtl42p.swift:15:46: error:\
    \ cannot infer contextual base in reference to member 'whitespaces'\n    let newStr\
    \ = txt.trimmingCharacters(in: .whitespaces)\n                               \
    \             ~^~~~~~~~~~~\n/tmp/tmpwavtl42p.swift:20:16: error: cannot find 'Err'\
    \ in scope\n        return Err(Int((newStr.characters.count - 1) / 2))\n     \
    \          ^~~\n/tmp/tmpwavtl42p.swift:24:12: error: the compiler is unable to\
    \ type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n    return .success(Array(newStr.enumerated().filter({\
    \ $0.element % 2 == 1 })).map({ $0.element % 2 == 0 ? split : lastResult }))\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054567
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    // Split on commas if there are commas\n    if let splits = txt.components(separatedBy:\
    \ \",\"), splits.count > 1 {\n        return Ok(splits)\n    }\n    // Split on\
    \ whitespaces if there are no commas\n    else if let splits = txt.components(separatedBy:\
    \ \" \"), splits.count > 1 {\n        return Ok(splits)\n    }\n    // Split on\
    \ lower-case letters if the text contains at least one lower case letter\n   \
    \ else if let splits = txt.split(separator: \"abcdefghijklmnopqrstuvwxyz\".lowercased(),\
    \ maxSplits: 1), splits.count > 1 {\n        return Ok(splits)\n    }\n    return\
    \ Failure(1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3621njxl.swift:16:25: error: value of type 'String' has no member\
    \ 'components'\n    if let splits = txt.components(separatedBy: \",\"), splits.count\
    \ > 1 {\n                    ~~~ ^~~~~~~~~~\n/tmp/tmp3621njxl.swift:17:16: error:\
    \ cannot find 'Ok' in scope\n        return Ok(splits)\n               ^~\n/tmp/tmp3621njxl.swift:20:30:\
    \ error: value of type 'String' has no member 'components'\n    else if let splits\
    \ = txt.components(separatedBy: \" \"), splits.count > 1 {\n                 \
    \        ~~~ ^~~~~~~~~~\n/tmp/tmp3621njxl.swift:21:16: error: cannot find 'Ok'\
    \ in scope\n        return Ok(splits)\n               ^~\n/tmp/tmp3621njxl.swift:25:16:\
    \ error: cannot find 'Ok' in scope\n        return Ok(splits)\n              \
    \ ^~\n/tmp/tmp3621njxl.swift:24:13: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    else if let splits = txt.split(separator: \"abcdefghijklmnopqrstuvwxyz\"\
    .lowercased(), maxSplits: 1), splits.count > 1 {\n            ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp3621njxl.swift:27:12: error: cannot find 'Failure' in scope\n    return\
    \ Failure(1)\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    switch txt {\n    \n    case txt.lowercased():\n        //\
    \ If no whitespace in string return string array\n        return [txt]\n    \n\
    \    case txt.lowercased().replacingOccurrences(of: \" \", with: \",\"):\n   \
    \     // If whitespace replace commas with whitespace\n        return [txt]\n\
    \    \n    default:\n        // If no commas or spaces return number of lower\
    \ case letters\n        let lowercaseLetterCount = txt.lowercased().count\n  \
    \      return lowercaseLetterCount / 2\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpugmk57_l.swift:22:27: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    case txt.lowercased().replacingOccurrences(of: \"\
    \ \", with: \",\"):\n         ~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpugmk57_l.swift:20:16:\
    \ error: cannot convert return expression of type '[String]' to return type 'Result<[String],\
    \ Int>'\n        return [txt]\n               ^~~~~\n/tmp/tmpugmk57_l.swift:24:16:\
    \ error: cannot convert return expression of type '[String]' to return type 'Result<[String],\
    \ Int>'\n        return [txt]\n               ^~~~~\n/tmp/tmpugmk57_l.swift:29:37:\
    \ error: cannot convert return expression of type 'Int' to return type 'Result<[String],\
    \ Int>'\n        return lowercaseLetterCount / 2\n               ~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return split_words(txt: txt, whitespaces: CharacterSet.whitespaces)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9qm22am0.swift:15:47: error: cannot find 'CharacterSet' in scope\n\
    \    return split_words(txt: txt, whitespaces: CharacterSet.whitespaces)\n   \
    \                                           ^~~~~~~~~~~~\n/tmp/tmp9qm22am0.swift:15:60:\
    \ error: extra argument 'whitespaces' in call\n    return split_words(txt: txt,\
    \ whitespaces: CharacterSet.whitespaces)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let pattern = #^\\w+$#\n    \n    do {\n        let regex\
    \ = try NSRegularExpression(pattern: pattern)\n        let nsString = txt as NSString\n\
    \        let matches = regex.matches(in: nsString, range: NSMakeRange(0, nsString.length))\n\
    \        \n        if matches.count > 0 {\n            let substrings = matches.map\
    \ {\n                let substring = nsString.substring(with: $0.range)\n    \
    \            return substring\n            }\n            \n            let splitted\
    \ = substrings.joined(separator: \",\")\n            return .success(splitted.characters.split{$0\
    \ == \" \"}.map(String.init))\n        }\n        \n        return .failure(NSString.String.init(\"\
    0\".toInt()))\n    } catch {\n        return .failure(NSString.String.init(\"\
    0\".toInt()))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp26ei6k3r.swift:16:19: error: expected initial value after '='\n\
    \    let pattern = #^\\w+$#\n                  ^\n/tmp/tmp26ei6k3r.swift:16:18:\
    \ error: consecutive statements on a line must be separated by ';'\n    let pattern\
    \ = #^\\w+$#\n                 ^\n                 ;\n/tmp/tmp26ei6k3r.swift:16:19:\
    \ error: expected expression\n    let pattern = #^\\w+$#\n                  ^\n\
    /tmp/tmp26ei6k3r.swift:19:25: error: cannot find 'NSRegularExpression' in scope\n\
    \        let regex = try NSRegularExpression(pattern: pattern)\n             \
    \           ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp26ei6k3r.swift:20:31: error: cannot find\
    \ type 'NSString' in scope\n        let nsString = txt as NSString\n         \
    \                     ^~~~~~~~\n/tmp/tmp26ei6k3r.swift:21:58: error: cannot find\
    \ 'NSMakeRange' in scope\n        let matches = regex.matches(in: nsString, range:\
    \ NSMakeRange(0, nsString.length))\n                                         \
    \                ^~~~~~~~~~~\n/tmp/tmp26ei6k3r.swift:33:25: error: cannot find\
    \ 'NSString' in scope\n        return .failure(NSString.String.init(\"0\".toInt()))\n\
    \                        ^~~~~~~~\n/tmp/tmp26ei6k3r.swift:33:50: error: value\
    \ of type 'String' has no member 'toInt'\n        return .failure(NSString.String.init(\"\
    0\".toInt()))\n                                             ~~~ ^~~~~\n/tmp/tmp26ei6k3r.swift:35:25:\
    \ error: cannot find 'NSString' in scope\n        return .failure(NSString.String.init(\"\
    0\".toInt()))\n                        ^~~~~~~~\n/tmp/tmp26ei6k3r.swift:35:50:\
    \ error: value of type 'String' has no member 'toInt'\n        return .failure(NSString.String.init(\"\
    0\".toInt()))\n                                             ~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if !txt.isEmpty {\n        return try txt.split(separator: \" \"\
    )\n    }\n    return .failure(\"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpdy3pxz46.swift:16:24: error: cannot convert return expression of\
    \ type '[String.SubSequence]' (aka 'Array<Substring>') to return type 'Result<[String],\
    \ Int>'\n        return try txt.split(separator: \" \")\n               ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdy3pxz46.swift:18:21: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n    return .failure(\"\")\n                  \
    \  ^\n"
  stdout: ''
  timestamp: 1660054553
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    return words\
    \ == nil ? .failure(3) : .success(words.map { $0.lowercased() })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3v8s1hcj.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if let words = txt.components(separatedBy: \" \") {\n        return\
    \ .success(words)\n    }\n    \n    if let letters = txt.components(separatedBy:\
    \ \",\") {\n        let evenLetters = count(letters, isEven: String)\n       \
    \ let oddLetters = count(letters, isEven: Int)\n        return .success([String](letters[0..<min(evenLetters,\
    \ oddLetters)])\n        .map {String($0)})\n    }\n    \n    return .failure(3)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpm5p2rkm4.swift:15:24: error: value of type 'String' has no member\
    \ 'components'\n    if let words = txt.components(separatedBy: \" \") {\n    \
    \               ~~~ ^~~~~~~~~~\n/tmp/tmpm5p2rkm4.swift:19:26: error: value of\
    \ type 'String' has no member 'components'\n    if let letters = txt.components(separatedBy:\
    \ \",\") {\n                     ~~~ ^~~~~~~~~~\n/tmp/tmpm5p2rkm4.swift:20:27:\
    \ error: cannot find 'count' in scope\n        let evenLetters = count(letters,\
    \ isEven: String)\n                          ^~~~~\n/tmp/tmpm5p2rkm4.swift:21:26:\
    \ error: cannot find 'count' in scope\n        let oddLetters = count(letters,\
    \ isEven: Int)\n                         ^~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let wordsAsArray = txt.components(separatedBy: \",\")\n    let whitespaceAsArray\
    \ = txt.components(separatedBy: \" \")\n    let lowercaseAsArray = txt.lowercased().components(separatedBy:\
    \ \" \") // lowercased\n    \n    guard wordsAsArray.isEmpty || whitespaceAsArray.isEmpty\
    \ || lowercaseAsArray.isEmpty else {\n        return .failure(25)\n    }\n\n \
    \   var result = wordsAsArray.map(String.init)\n    \n    if !wordsAsArray.isEmpty\
    \ {\n        result[wordsAsArray.count-1] = result[wordsAsArray.count-1].dropLast()\n\
    \    }\n    \n    if !whitespaceAsArray.isEmpty {\n        result[whitespaceAsArray.count-1]\
    \ = result[whitespaceAsArray.count-1].dropLast()\n    }\n    \n    if !lowercaseAsArray.isEmpty\
    \ {\n        result[lowercaseAsArray.count-1] = result[lowercaseAsArray.count-1].dropLast()\n\
    \    }\n    \n    return .success(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkkoo75gv.swift:15:28: error: value of type 'String' has no member\
    \ 'components'\n    let wordsAsArray = txt.components(separatedBy: \",\")\n  \
    \                     ~~~ ^~~~~~~~~~\n/tmp/tmpkkoo75gv.swift:16:33: error: value\
    \ of type 'String' has no member 'components'\n    let whitespaceAsArray = txt.components(separatedBy:\
    \ \" \")\n                            ~~~ ^~~~~~~~~~\n/tmp/tmpkkoo75gv.swift:17:45:\
    \ error: value of type 'String' has no member 'components'\n    let lowercaseAsArray\
    \ = txt.lowercased().components(separatedBy: \" \") // lowercased\n          \
    \                 ~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    if words.count\
    \ != 1 {\n        let commas = txt.components(separatedBy: \",\")\n        if\
    \ commas == nil {\n            return .failure(25)\n        } else {\n       \
    \     return .success(words)\n        }\n    }\n    return .success(words)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpad0frxbx.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n/tmp/tmpad0frxbx.swift:17:26: error: value of type 'String'\
    \ has no member 'components'\n        let commas = txt.components(separatedBy:\
    \ \",\")\n                     ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let split = txt.characters.split{$0 == \" \" || $0 == \",\"\
    } else {\n        return Result.failure(Int(txt.characters.count))\n    }\n  \
    \  return Result.success(split.map{String($0)})\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpb47xp80p.swift:15:43: error: expected 'else' after 'guard' condition\n\
    \    guard let split = txt.characters.split{$0 == \" \" || $0 == \",\"} else {\n\
    \                                          ^\n                               \
    \           else \n/tmp/tmpb47xp80p.swift:15:44: error: anonymous closure argument\
    \ not contained in a closure\n    guard let split = txt.characters.split{$0 ==\
    \ \" \" || $0 == \",\"} else {\n                                           ^\n\
    /tmp/tmpb47xp80p.swift:15:57: error: anonymous closure argument not contained\
    \ in a closure\n    guard let split = txt.characters.split{$0 == \" \" || $0 ==\
    \ \",\"} else {\n                                                        ^\n/tmp/tmpb47xp80p.swift:15:67:\
    \ error: consecutive statements on a line must be separated by ';'\n    guard\
    \ let split = txt.characters.split{$0 == \" \" || $0 == \",\"} else {\n      \
    \                                                            ^\n             \
    \                                                     ;\n/tmp/tmpb47xp80p.swift:15:68:\
    \ error: expected expression\n    guard let split = txt.characters.split{$0 ==\
    \ \" \" || $0 == \",\"} else {\n                                             \
    \                      ^\n/tmp/tmpb47xp80p.swift:15:27: error: 'characters' is\
    \ unavailable: Please use String directly\n    guard let split = txt.characters.split{$0\
    \ == \" \" || $0 == \",\"} else {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpb47xp80p.swift:15:11: error: initializer\
    \ for conditional binding must have Optional type, not '(String.Element, Int,\
    \ Bool) -> [String.SubSequence]' (aka '(Character, Int, Bool) -> Array<Substring>')\n\
    \    guard let split = txt.characters.split{$0 == \" \" || $0 == \",\"} else {\n\
    \          ^           ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb47xp80p.swift:18:33: error:\
    \ value of type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character,\
    \ Int, Bool) -> Array<Substring>') has no member 'map'\n    return Result.success(split.map"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n    \n    if words.count\
    \ < 2 {\n        return .failure(3)\n    }\n    \n    return .success(words)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpcoynyaop.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: \" \")\n         \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    let isWhitespace = words.count > 0 && words.first?.unicodeScalars.filter({\
    \ $0.isWhitespace }).count > 0\n    guard let wordCount = words.count else { return\
    \ .failure(3) }\n    let isComma = words.count > 1 && words.last?.unicodeScalars.filter({\
    \ $0.isWhitespace }).count > 0\n    guard let wordCount2 = words.count else {\
    \ return .failure(3) }\n    guard isWhitespace == isComma else { return .failure(2)\
    \ }\n    guard wordCount % 2 == 0 else { return .failure(2) }\n    guard wordCount2\
    \ % 2 == 1 else { return .failure(2) }\n    \n    let letterCount = Array(words.last!.unicodeScalars)\n\
    \        .filter({ $0.isLetter })\n        .map({ $0.value })\n        .map({\
    \ Character($0) })\n        .reduce(0)\n        \n    let letterCount2 = Array(words.last!.unicodeScalars)\n\
    \        .filter({ $0.isLetter })\n        .map({ $0.value })\n        .map({\
    \ Character($0) })\n        .reduce(0)\n    \n    let letterCount3 = Array(words.last!.unicodeScalars)\n\
    \        .filter({ $0.isLetter })\n        .map({ $0.value })\n        .map({\
    \ Character($0) })\n        .reduce(0)\n    \n    guard letterCount == letterCount2\
    \ || letterCount == letterCount3 else { return .failure(3) }\n    \n    guard\
    \ letterCount == letterCount2 || (letterCount == letterCount3 && letterCount %\
    \ 2 == 0) else { return .failure(2) }\n    \n    let wordArray = words.map { String($0)\
    \ }\n    return .success(wordArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmps6l1h31k.swift:15:21: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \                ~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmps6l1h31k.swift:15:45: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let words = txt.trimmingCharacters(in: .whitespacesAndNewlines)\n       \
    \                                    ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmps6l1h31k.swift:16:99:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    let isWhitespace = words.count > 0 && words.first?.unicodeScalars.filter({\
    \ $0.isWhitespace }).count > 0\n                                             \
    \                                                     ^\n/tmp/tmps6l1h31k.swift:16:99:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let isWhitespace = words.count > 0 && words.first?.unicodeScalars.filter({\
    \ $0.isWhitespace }).count > 0\n                                             \
    \                                                     ^\n                    \
    \                                                                            \
    \        ?? <#default value#>\n/tmp/tmps6l1h31k.swift:16:99: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let isWhitespace\
    \ = words.count > 0 && words.first?.unicodeScalars.filter({ $0.isWhitespace }).count\
    \ > 0\n                                                                      \
    \                            ^\n                                          (  \
    \                                                          )!\n/tmp/tmps6l1h31k.swift:18:93:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    let isComma = words.count > 1 && words.last?.unicodeScalars.filter({ $0.isWhitespace\
    \ }).count > 0\n                                                             \
    \                               ^\n/tmp/tmps6l1h31k.swift:18:93: note: coalesce\
    \ using '??' to provide a default when the optional "
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.characters.split(separator: \" \")\n    var ret:\
    \ [String] = []\n    for word in words {\n        if let letters = word.characters.split(separator:\
    \ \",\") {\n            for letter in letters {\n                if let letter\
    \ = Int(letter, radix: 64), letter % 2 == 1 {\n                    ret.append(letter)\n\
    \                }\n            }\n        } else {\n            ret.append(word)\n\
    \        }\n    }\n    return Ok(ret)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpizelyrad.swift:15:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let words = txt.characters.split(separator: \" \")\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpizelyrad.swift:18:31: error: 'characters' is unavailable: Please\
    \ use Substring directly\n        if let letters = word.characters.split(separator:\
    \ \",\") {\n                              ^~~~~~~~~~\nSwift.Substring:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n/tmp/tmpizelyrad.swift:21:32: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String'\n                   \
    \ ret.append(letter)\n                               ^\n/tmp/tmpizelyrad.swift:25:17:\
    \ error: no exact matches in call to instance method 'append'\n            ret.append(word)\n\
    \                ^\nSwift.Array:6:37: note: candidate expects value of type 'String'\
    \ for parameter #1 (got 'String.SubSequence' (aka 'Substring'))\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Element)\n               \
    \                     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'String.SubSequence' (aka\
    \ 'Substring'))\n    @inlinable public mutating func append(_ newElement: __owned\
    \ Self.Element)\n                                    ^\n/tmp/tmpizelyrad.swift:25:17:\
    \ note: found candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned\
    \ Substring) -> ()')\n            ret.append(word)\n                ^\n/tmp/tmpizelyrad.swift:18:12:\
    \ error: initializer for conditional binding must have Optional type, not '[Substring.SubSequence]'\
    \ (aka 'Array<Substring>')\n        if let letters = word.characters.split(separator:\
    \ \",\") {\n           ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpizelyrad.swift:28:12:\
    \ error: cannot find 'Ok' in scope\n    return Ok(ret)\n           ^~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var words = txt.componentsSeparatedByString(\" \")\n    if words.count\
    \ == 1 && !words.contains(\",\") {\n        let lower = (words[0].characters.map\
    \ { c -> String in\n            if let ascii = c as? Int {\n                return\
    \ String(UnicodeScalar(ascii).value)\n            }\n            return String(c)\n\
    \        }).filter { (word) -> Bool in\n            return ((word as NSString).length\
    \ % 2) == 1\n        }\n        \n        let even = [String]()\n        var index\
    \ = 0\n        for word in lower {\n            if index > 0 {\n             \
    \   even.append(word)\n            }\n            index += 1\n        }\n    \
    \    \n        return .success(even)\n    }\n    \n    return .failure(25)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp5t1eyzqe.swift:15:21: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    var words = txt.componentsSeparatedByString(\"\
    \ \")\n                ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5t1eyzqe.swift:23:30:\
    \ error: cannot find type 'NSString' in scope\n            return ((word as NSString).length\
    \ % 2) == 1\n                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    \n    let words: [String] = txt.components(separatedBy: \" \")\n\
    \    \n    if words.count > 0 {\n        return .success(words)\n    }\n    \n\
    \    let wordCounts: [Int] = txt.lowercased().components(separatedBy: \"\").filter({\
    \ $0.isEmpty }).map { String($0).count }\n    \n    return .success(wordCounts)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmph6li0t7j.swift:16:31: error: value of type 'String' has no member\
    \ 'components'\n    let words: [String] = txt.components(separatedBy: \" \")\n\
    \                          ~~~ ^~~~~~~~~~\n/tmp/tmph6li0t7j.swift:22:46: error:\
    \ value of type 'String' has no member 'components'\n    let wordCounts: [Int]\
    \ = txt.lowercased().components(separatedBy: \"\").filter({ $0.isEmpty }).map\
    \ { String($0).count }\n                            ~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmph6li0t7j.swift:24:21: error: cannot convert value of type '[Int]' to expected\
    \ argument type '[String]'\n    return .success(wordCounts)\n                \
    \    ^\n/tmp/tmph6li0t7j.swift:24:21: note: arguments to generic parameter 'Element'\
    \ ('Int' and 'String') are expected to be equal\n    return .success(wordCounts)\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: \" \") else {\n  \
    \      return .failure(Int(self))\n    }\n    \n    var result: [String] = []\n\
    \    \n    for word in words {\n        let letters = word.lowercaseString.characters.count\n\
    \        result.append((word + String(letters)))\n    }\n    \n    return .success(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp_b67ay_z.swift:15:27: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = txt.components(separatedBy: \" \") else\
    \ {\n                      ~~~ ^~~~~~~~~~\n/tmp/tmp_b67ay_z.swift:16:29: error:\
    \ cannot find 'self' in scope; did you mean to use it in a type or extension context?\n\
    \        return .failure(Int(self))\n                            ^~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var lowercaseString = \"\"\n    var count = 0\n    for c in txt.lowercased().unicodeScalars\
    \ {\n        if c == c {\n            count += 1\n        }\n        if c == '\
    \ ' || c == ',' {\n            lowercaseString += c\n        }\n    }\n    if\
    \ count > 0 {\n        return .success(lowercaseString.unicodeScalars)\n    }\n\
    \    return .failure(count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpd29skuq_.swift:21:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == ' ' || c == ',' {\n                ^~~\n         \
    \       \" \"\n/tmp/tmpd29skuq_.swift:21:29: error: single-quoted string literal\
    \ found, use '\"'\n        if c == ' ' || c == ',' {\n                       \
    \     ^~~\n                            \",\"\n/tmp/tmpd29skuq_.swift:22:29: error:\
    \ operator function '+=' requires that 'Unicode.Scalar' conform to 'Sequence'\n\
    \            lowercaseString += c\n                            ^\nSwift.RangeReplaceableCollection:4:35:\
    \ note: where 'Other' = 'Unicode.Scalar'\n    @inlinable public static func +=\
    \ <Other>(lhs: inout Self, rhs: Other) where Other : Sequence, Self.Element ==\
    \ Other.Element\n                                  ^\n/tmp/tmpd29skuq_.swift:26:41:\
    \ error: cannot convert value of type 'String.UnicodeScalarView' to expected argument\
    \ type '[String]'\n        return .success(lowercaseString.unicodeScalars)\n \
    \                                       ^\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var result = [String]()\n    var count = 0\n    var word = \"\"\n\
    \    for c in txt {\n        word = word + String(c)\n        if count == 0 {\n\
    \            count = 1\n        } else {\n            if word != \"\" {\n    \
    \            result.append(word)\n                word = \"\"\n              \
    \  count = 0\n            }\n        }\n    }\n    if word != \"\" {\n       \
    \ result.append(word)\n        word = \"\"\n    }\n    return Ok(result)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphud4rjpt.swift:34:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(result)\n           ^~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words: String? = txt.components(separatedBy: \" \")\n    if\
    \ let words = words {\n        return .success(words.split(separator: \",\"))\n\
    \    }\n    return .failure(count_lowercase_odd_alphabet(txt))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpo0piy3yp.swift:15:30: error: value of type 'String' has no member\
    \ 'components'\n    let words: String? = txt.components(separatedBy: \" \")\n\
    \                         ~~~ ^~~~~~~~~~\n/tmp/tmpo0piy3yp.swift:17:31: error:\
    \ cannot convert value of type '[String.SubSequence]' (aka 'Array<Substring>')\
    \ to expected argument type '[String]'\n        return .success(words.split(separator:\
    \ \",\"))\n                              ^\n/tmp/tmpo0piy3yp.swift:17:31: note:\
    \ arguments to generic parameter 'Element' ('String.SubSequence' (aka 'Substring')\
    \ and 'String') are expected to be equal\n        return .success(words.split(separator:\
    \ \",\"))\n                              ^\n/tmp/tmpo0piy3yp.swift:19:21: error:\
    \ cannot find 'count_lowercase_odd_alphabet' in scope\n    return .failure(count_lowercase_odd_alphabet(txt))\n\
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: \" \")\n            .filter({\
    \ $0.count > 0 })\n            .filter({ !$0.range(of: \",\", options: .regularExpression)\
    \ != nil })\n            .sorted()\n            .filter({ $0.lowercased() != $0\
    \ })\n    let oddLetters = words.filter({ $0.lowercased() in [\n            \"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\",\n            \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\" ] })\n            .filter({ $0.count % 2 ==\
    \ 0 })\n            .count\n    guard oddLetters > 0 else {\n        return .failure(oddLetters)\n\
    \    }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpqu4zbq1q.swift:20:52: error: consecutive statements on a line must\
    \ be separated by ';'\n    let oddLetters = words.filter({ $0.lowercased() in\
    \ [\n                                                   ^\n                  \
    \                                 ;\n/tmp/tmpqu4zbq1q.swift:20:53: error: expected\
    \ expression\n    let oddLetters = words.filter({ $0.lowercased() in [\n     \
    \                                               ^\n/tmp/tmpqu4zbq1q.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ \" \")\n                ~~~ ^~~~~~~~~~\n/tmp/tmpqu4zbq1q.swift:17:52: error:\
    \ cannot infer contextual base in reference to member 'regularExpression'\n  \
    \          .filter({ !$0.range(of: \",\", options: .regularExpression) != nil\
    \ })\n                                                  ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if let lowerCaseString = txt.lowercased(), !lowerCaseString.isEmpty\
    \ {\n        let components = lowerCaseString.componentsSeparatedByCharactersInSet(.whitespaces)\n\
    \        if !components.isEmpty {\n            return .success(components)\n \
    \       }\n    }\n    return .success(txt.characters.filter{ String($0).characters.count\
    \ == 1 }).map{ String($0).characters.count % 2 == 1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkmsn1_2t.swift:16:42: error: value of type 'String' has no member\
    \ 'componentsSeparatedByCharactersInSet'\n        let components = lowerCaseString.componentsSeparatedByCharactersInSet(.whitespaces)\n\
    \                         ~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkmsn1_2t.swift:16:80: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n        let components = lowerCaseString.componentsSeparatedByCharactersInSet(.whitespaces)\n\
    \                                                                            \
    \  ~^~~~~~~~~~~\n/tmp/tmpkmsn1_2t.swift:15:8: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n    if let lowerCaseString =\
    \ txt.lowercased(), !lowerCaseString.isEmpty {\n       ^                     ~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkmsn1_2t.swift:21:85: error: no exact matches in call to initializer \n\
    \    return .success(txt.characters.filter{ String($0).characters.count == 1 }).map{\
    \ String($0).characters.count % 2 == 1 }\n                                   \
    \                                                 ^\n/tmp/tmpkmsn1_2t.swift:21:85:\
    \ note: found candidate with type '([String]) -> String'\n    return .success(txt.characters.filter{\
    \ String($0).characters.count == 1 }).map{ String($0).characters.count % 2 ==\
    \ 1 }\n                                                                      \
    \              ^\n/tmp/tmpkmsn1_2t.swift:21:85: note: found candidate with type\
    \ '([String]) -> String'\n    return .success(txt.characters.filter{ String($0).characters.count\
    \ == 1 }).map{ String($0).characters.count % 2 == 1 }\n                      \
    \                                                              ^\n/tmp/tmpkmsn1_2t.swift:21:85:\
    \ note: found candidate with type '([String]) -> String'\n    return .success(txt.characters.filter{\
    \ String($0).characters.count == 1 }).map{ String($0).characters.count % 2 ==\
    \ 1 }\n                                                                      \
    \              ^\n/tmp/tmpkmsn1_2t.swift:21:36: error: cannot convert value of\
    \ type '[String.Eleme"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    if txt.count <= 1 {\n        return .failure(Int(0))\n    }\n  \
    \  var words = [String]()\n    let separator = CharacterSet(charactersIn: \" \"\
    )\n    for i in 0..<txt.count {\n        let wordStart = txt.index(after: txt.index(before:\
    \ txt.startIndex, offsetBy: i))\n        guard let wordEnd = txt.index(after:\
    \ wordStart, offsetBy: 1, limitedBy: txt.length) else { return .failure(Int(0))\
    \ }\n        let word = txt.substring(from: wordStart, to: wordEnd)\n        guard\
    \ !separator.contains(word) else { return .failure(Int(0)) }\n        words.append(word)\n\
    \    }\n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmkb5l6dx.swift:19:21: error: cannot find 'CharacterSet' in scope\n\
    \    let separator = CharacterSet(charactersIn: \" \")\n                    ^~~~~~~~~~~~\n\
    /tmp/tmpmkb5l6dx.swift:21:46: error: no exact matches in call to instance method\
    \ 'index'\n        let wordStart = txt.index(after: txt.index(before: txt.startIndex,\
    \ offsetBy: i))\n                                             ^\nSwift.String:9:17:\
    \ note: incorrect labels for candidate (have: '(before:offsetBy:)', expected:\
    \ '(_:offsetBy:)')\n    public func index(_ i: String.Index, offsetBy distance:\
    \ Int) -> String.Index\n                ^\nSwift.Collection:6:28: note: incorrect\
    \ labels for candidate (have: '(before:offsetBy:)', expected: '(_:offsetBy:)')\n\
    \    @inlinable public func index(_ i: Self.Index, offsetBy distance: Int) ->\
    \ Self.Index\n                           ^\nSwift.BidirectionalCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(before:offsetBy:)', expected:\
    \ '(_:offsetBy:)')\n    @inlinable public func index(_ i: Self.Index, offsetBy\
    \ distance: Int) -> Self.Index\n                           ^\n/tmp/tmpmkb5l6dx.swift:22:33:\
    \ error: no exact matches in call to instance method 'index'\n        guard let\
    \ wordEnd = txt.index(after: wordStart, offsetBy: 1, limitedBy: txt.length) else\
    \ { return .failure(Int(0)) }\n                                ^\n/tmp/tmpmkb5l6dx.swift:22:33:\
    \ note: found candidate with type '(String.Index, Int, String.Index) -> String.Index?'\n\
    \        guard let wordEnd = txt.index(after: wordStart, offsetBy: 1, limitedBy:\
    \ txt.length) else { return .failure(Int(0)) }\n                             \
    \   ^\n/tmp/tmpmkb5l6dx.swift:22:85: error: value of type 'String' has no member\
    \ 'length'\n        guard let wordEnd = txt.index(after: wordStart, offsetBy:\
    \ 1, limitedBy: txt.length) else { return .failure(Int(0)) }\n               \
    \                                                                 ~~~ ^~~~~~\n\
    /tmp/tmpmkb5l6dx.swift:23:24: error: value of type 'String' has no member 'substring'\n\
    \        let word = txt.substring(from: wordStart, to: wordEnd)\n     "
  stdout: ''
  timestamp: 1660054554
- exit_code: -4
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let split = txt.split(separator: \" \")\n    guard split.count >=\
    \ 1 else { return .failure(0) }\n    let split2 = split.flatMap { $0.split(separator:\
    \ \",\") }\n    guard split2.count >= 1 else { return .failure(0) }\n    return\
    \ .success(split2.filter { $0.contains(\"[a-z]\") }.map { $0.lowercased() })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: Exception
  stderr: 'tmpyn0zt0lo/tmpyn0zt0lo.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f2ee07bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f2ee04b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f2ee04b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f2ee04b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyn0zt0lo                        0x000055a7ce928d6c <unavailable> + 7532

    5    libc.so.6                          0x00007f2edffa7460 __libc_start_main +
    245

    6    tmpyn0zt0lo                        0x000055a7ce9288a9 <unavailable> + 6313

    '
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words: [String] = txt.components(separatedBy: \" \")\n    if\
    \ !words.isEmpty {\n        return Result.success(words.map { $0.lowercased()\
    \ })\n    } else {\n        let chars: [Character] = Array(txt.utf16)\n      \
    \  if chars.count == 0 {\n            return Result.failure(3)\n        }\n  \
    \      let odds: [Int] = Array(chars.filter { $0 % 2 != 0 }).map { Int($0 + 1)\
    \ }\n        return Result.success(odds)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpnkb7_hlm.swift:15:31: error: value of type 'String' has no member\
    \ 'components'\n    let words: [String] = txt.components(separatedBy: \" \")\n\
    \                          ~~~ ^~~~~~~~~~\n/tmp/tmpnkb7_hlm.swift:19:34: error:\
    \ cannot assign value of type 'Array<UTF16.CodeUnit>' (aka 'Array<UInt16>') to\
    \ type '[Character]'\n        let chars: [Character] = Array(txt.utf16)\n    \
    \                             ^\n/tmp/tmpnkb7_hlm.swift:19:34: note: arguments\
    \ to generic parameter 'Element' ('UTF16.CodeUnit' (aka 'UInt16') and 'Character')\
    \ are expected to be equal\n        let chars: [Character] = Array(txt.utf16)\n\
    \                                 ^\n/tmp/tmpnkb7_hlm.swift:23:48: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Int'\n        let\
    \ odds: [Int] = Array(chars.filter { $0 % 2 != 0 }).map { Int($0 + 1) }\n    \
    \                                           ^\n/tmp/tmpnkb7_hlm.swift:23:73: error:\
    \ cannot convert value of type 'Character' to expected argument type 'Int'\n \
    \       let odds: [Int] = Array(chars.filter { $0 % 2 != 0 }).map { Int($0 + 1)\
    \ }\n                                                                        ^\n\
    /tmp/tmpnkb7_hlm.swift:24:31: error: cannot convert value of type '[Int]' to expected\
    \ argument type '[String]'\n        return Result.success(odds)\n            \
    \                  ^\n/tmp/tmpnkb7_hlm.swift:24:31: note: arguments to generic\
    \ parameter 'Element' ('Int' and 'String') are expected to be equal\n        return\
    \ Result.success(odds)\n                              ^\n"
  stdout: ''
  timestamp: 1660054563
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return withExtendedLifetime{ (_) in\n        var words: [String]\
    \ = []\n        var count: Int = 0\n        var alpha: UInt32 = 0\n        \n\
    \        func isSpace(c: Int) -> Bool {\n            return c == \" \" || c ==\
    \ \",\"\n        }\n        \n        func isAlpha(c: Int) -> Bool {\n       \
    \     alpha &= UInt32(UInt8(c - UInt32('a'))) << 24\n            return alpha\
    \ & UInt32(UInt8(c - UInt32('A'))) == 0\n        }\n        \n        for c in\
    \ txt.characters {\n            if isSpace(c) {\n                words.append(String(String(c)))\n\
    \                count += 1\n                if isAlpha(c) {\n               \
    \     alpha = 0\n                } else {\n                    alpha |= UInt32(UInt8(c\
    \ - UInt32('a'))) << 24\n                }\n            } else {\n           \
    \     words.append(String(String(c)))\n                count += 1\n          \
    \      if isAlpha(c) {\n                    alpha |= UInt32(UInt8(c - UInt32('a')))\
    \ << 24\n                }\n            }\n        }\n        \n        return\
    \ .success(words)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpz8ijgzxf.swift:25:46: error: single-quoted string literal found,\
    \ use '\"'\n            alpha &= UInt32(UInt8(c - UInt32('a'))) << 24\n      \
    \                                       ^~~\n                                \
    \             \"a\"\n/tmp/tmpz8ijgzxf.swift:26:52: error: single-quoted string\
    \ literal found, use '\"'\n            return alpha & UInt32(UInt8(c - UInt32('A')))\
    \ == 0\n                                                   ^~~\n             \
    \                                      \"A\"\n/tmp/tmpz8ijgzxf.swift:36:54: error:\
    \ single-quoted string literal found, use '\"'\n                    alpha |= UInt32(UInt8(c\
    \ - UInt32('a'))) << 24\n                                                    \
    \ ^~~\n                                                     \"a\"\n/tmp/tmpz8ijgzxf.swift:42:54:\
    \ error: single-quoted string literal found, use '\"'\n                    alpha\
    \ |= UInt32(UInt8(c - UInt32('a'))) << 24\n                                  \
    \                   ^~~\n                                                    \
    \ \"a\"\n/tmp/tmpz8ijgzxf.swift:15:32: error: missing argument for parameter #1\
    \ in call\n    return withExtendedLifetime{ (_) in\n                         \
    \      ^\n                               (<#_#>)\nSwift.withExtendedLifetime:1:24:\
    \ note: 'withExtendedLifetime' declared here\n@inlinable public func withExtendedLifetime<T,\
    \ Result>(_ x: T, _ body: (T) throws -> Result) rethrows -> Result\n         \
    \              ^\n/tmp/tmpz8ijgzxf.swift:30:24: error: missing argument label\
    \ 'c:' in call\n            if isSpace(c) {\n                       ^\n      \
    \                 c: \n/tmp/tmpz8ijgzxf.swift:30:24: error: cannot convert value\
    \ of type 'Character' to expected argument type 'Int'\n            if isSpace(c)\
    \ {\n                       ^\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = [String]()\n    var count = 0\n    for i in txt.unicodeScalars.lazy.flatMap\
    \ {\n        if i.unicodeScalars.first != Character(\"\\u{0020}\") {\n       \
    \     words.append(String(Character(i.unicodeScalars.first)))\n        } else\
    \ {\n            count += 1\n        }\n    }\n    return words.length < 2 ? .success(words)\
    \ : .failure(count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp24k4f_3q.swift:17:38: error: for-in loop requires '((LazySequence<String.UnicodeScalarView>.Element)\
    \ throws -> String?) throws -> [String]' (aka '((Unicode.Scalar) throws -> Optional<String>)\
    \ throws -> Array<String>') to conform to 'Sequence'\n    for i in txt.unicodeScalars.lazy.flatMap\
    \ {\n             ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmp24k4f_3q.swift:24:18:\
    \ error: value of type '[String]' has no member 'length'\n    return words.length\
    \ < 2 ? .success(words) : .failure(count)\n           ~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let regex = try! NSRegularExpression(pattern: \"\\\\s+\")\n    let\
    \ nsString = txt as NSString\n    let matches = regex.matches(in: nsString, range:\
    \ NSMakeRange(0, nsString.length))\n    \n    if matches.count == 0 {\n      \
    \  \n        let nsArray = nsString.componentsSeparatedByCharactersInSet(NSCharacterSet(charactersInString:\
    \ \",\"))\n        let wordsArray = nsArray.filter({$0.characters.count > 0})\n\
    \        let lowercaseArray = wordsArray.filter({$0.characters.count > 0 })\n\
    \        let oddArray = lowercaseArray.filter({$0.characters.count % 2 == 1})\n\
    \        return .success(oddArray.map { $0.lowercasedString! })\n    }\n    return\
    \ .success(matches\n        .map { nsString.substring(with: $0.range)}\n     \
    \   .filter({$0.characters.count > 0})\n        .map { $0.lowercased() })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa8sdm193.swift:15:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"\\\\s+\")\n  \
    \                   ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpa8sdm193.swift:16:27: error:\
    \ cannot find type 'NSString' in scope\n    let nsString = txt as NSString\n \
    \                         ^~~~~~~~\n/tmp/tmpa8sdm193.swift:17:54: error: cannot\
    \ find 'NSMakeRange' in scope\n    let matches = regex.matches(in: nsString, range:\
    \ NSMakeRange(0, nsString.length))\n                                         \
    \            ^~~~~~~~~~~\n/tmp/tmpa8sdm193.swift:21:69: error: cannot find 'NSCharacterSet'\
    \ in scope\n        let nsArray = nsString.componentsSeparatedByCharactersInSet(NSCharacterSet(charactersInString:\
    \ \",\"))\n                                                                  \
    \  ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let wordsAsString = txt.split(separator: \" \")\n    if let words\
    \ = wordsAsString {\n        let wordCount = words.count\n        let lettersOddCount\
    \ = wordCount / 2\n        return words.filter{ !$0.isEmpty }\n            .map{\
    \ $0.lowercased().split(separator: \",\") }\n            .map { $0.compactMap\
    \ { $0.trimmingCharacters(in: .whitespaces)\n            }}\n            .map\
    \ { $0.map{ String($0) } }\n            .map { $0.flatMap({ $0.split(separator:\
    \ \" \") }) }\n            .map { $0.flatMap({ $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) }})}\n            .map { $0.map{ String($0) } }\n            .map\
    \ { $0.flatMap({ $0.split(separator: \",\") }) }\n            .map { $0.flatMap({\
    \ $0.compactMap { $0.trimmingCharacters(in: .whitespaces) }})}\n            .map\
    \ { $0.map{ $0.lowercased() } }\n            .filter { !$0.isEmpty }\n       \
    \     .filter { $0.count % 2 == 1 }\n            .filter { $0.count != lettersOddCount\
    \ }\n            .map { $0.map { String($0) } }\n            .map { $0.map { $0.lowercased()\
    \ } }\n            .flatMap { $0.split(separator: \",\") }\n            .flatMap\
    \ { $0.split(separator: \" \") }\n            .compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) }\n            .flatMap { $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) } }\n            .flatMap { $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) } }\n            .flatMap { $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) } }\n            .flatMap { $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) } }\n            .flatMap { $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) } }\n            .flatMap { $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) } }\n            .flatMap { $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) } }\n            .flatMap { $0.compactMap { $0.trimmingCharacters(in:\
    \ .whitespaces) } }\n            .flatMap { $0.compactMap { $0.tri\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmprf5i9adi.swift:69:44: error: expected '}' at end of closure\nassert(split_words(txt:\
    \ \"\") == .failure(0))\n                                           ^\n/tmp/tmprf5i9adi.swift:46:22:\
    \ note: to match this opening '{'\n            .flatMap { $0.compactMap { $0.tri\n\
    \                     ^\n/tmp/tmprf5i9adi.swift:69:44: error: expected '}' at\
    \ end of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n    \
    \                                       ^\n/tmp/tmprf5i9adi.swift:16:34: note:\
    \ to match this opening '{'\n    if let words = wordsAsString {\n            \
    \                     ^\n/tmp/tmprf5i9adi.swift:69:44: error: expected '}' at\
    \ end of brace statement\nassert(split_words(txt: \"\") == .failure(0))\n    \
    \                                       ^\n/tmp/tmprf5i9adi.swift:14:56: note:\
    \ to match this opening '{'\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n                                                       ^\n/tmp/tmprf5i9adi.swift:19:16:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n        return\
    \ words.filter{ !$0.isEmpty }\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprf5i9adi.swift:16:8:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    if let words = wordsAsString {\n       ^     \
    \      ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054711
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let split = txt.split(separator: \" \")\n    guard split.count >\
    \ 0 else {\n        return .failure(3)\n    }\n    \n    var words: [String] =\
    \ []\n    for s in split {\n        let split = s.split(separator: \", \")\n \
    \       guard split.count > 0 else {\n            return .failure(3)\n       \
    \ }\n        words.append(split.first!)\n    }\n    \n    guard !words.isEmpty\
    \ else {\n        return .failure(3)\n    }\n    \n    var odd: Int = 0\n    for\
    \ (i, word) in words.enumerated() {\n        let lower = word.lowercased().count\n\
    \        odd = (i + 1 ) % 26\n        if lower % 2 != 0 {\n            return\
    \ .failure(3)\n        }\n    }\n    \n    return .success(words)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpwo5dezzo.swift:26:15: error: no exact matches in call to instance\
    \ method 'append'\n        words.append(split.first!)\n              ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Substring.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Substring.SubSequence'\
    \ (aka 'Substring'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpwo5dezzo.swift:26:15:\
    \ note: found candidate with type '(__owned Substring.SubSequence) -> ()' (aka\
    \ '(__owned Substring) -> ()')\n        words.append(split.first!)\n         \
    \     ^\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.unicodeScalars.map{ $0.value }\n    let numWords\
    \ = words.count\n\n    let chars = words.filter({ Character.isLetter(_: $0) })\n\
    \    var charSet = Set<Character>()\n    for char in chars {\n        charSet.insert(char)\n\
    \    }\n\n    if charSet.count % 2 != 0 {\n        return Err(Int.init(value:\
    \ numWords))\n    }\n\n    let sortedChars = charSet.sorted()\n\n    let wordArray\
    \ = Array(sortedChars.suffix(of: sortedChars.prefix(of: sortedChars.first!)))\n\
    \    let numWordsAfterOddOrder = wordArray.count\n\n    return Ok([String(wordArray)])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1gab3mff.swift:18:42: error: cannot call value of non-function\
    \ type 'Bool'\n    let chars = words.filter({ Character.isLetter(_: $0) })\n \
    \                                        ^\n/tmp/tmp1gab3mff.swift:25:16: error:\
    \ cannot find 'Err' in scope\n        return Err(Int.init(value: numWords))\n\
    \               ^~~\n/tmp/tmp1gab3mff.swift:25:28: error: extraneous argument\
    \ label 'value:' in call\n        return Err(Int.init(value: numWords))\n    \
    \                       ^~~~~~~~\n                            \n/tmp/tmp1gab3mff.swift:30:39:\
    \ error: no exact matches in call to instance method 'suffix'\n    let wordArray\
    \ = Array(sortedChars.suffix(of: sortedChars.prefix(of: sortedChars.first!)))\n\
    \                                      ^\n/tmp/tmp1gab3mff.swift:30:39: note:\
    \ candidate expects value of type 'Int' for parameter #1 (got 'ArraySlice<Character>')\n\
    \    let wordArray = Array(sortedChars.suffix(of: sortedChars.prefix(of: sortedChars.first!)))\n\
    \                                      ^\n/tmp/tmp1gab3mff.swift:30:39: note:\
    \ candidate expects value of type 'Int' for parameter #1 (got 'ArraySlice<Character>')\n\
    \    let wordArray = Array(sortedChars.suffix(of: sortedChars.prefix(of: sortedChars.first!)))\n\
    \                                      ^\n/tmp/tmp1gab3mff.swift:30:39: note:\
    \ candidate expects value of type 'Int' for parameter #1 (got 'ArraySlice<Character>')\n\
    \    let wordArray = Array(sortedChars.suffix(of: sortedChars.prefix(of: sortedChars.first!)))\n\
    \                                      ^\n/tmp/tmp1gab3mff.swift:30:68: error:\
    \ extraneous argument label 'of:' in call\n    let wordArray = Array(sortedChars.suffix(of:\
    \ sortedChars.prefix(of: sortedChars.first!)))\n                             \
    \                                      ^~~~~\n                               \
    \                                     \n/tmp/tmp1gab3mff.swift:30:90: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Int'\n    let wordArray\
    \ = Array(sortedChars.suffix(of: sortedChars.prefix(of: sortedChars.first!)))\n\
    \                                    "
  stdout: ''
  timestamp: 1660054554
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\
    \ else {\n        return Err(Int(characterSet.count, integerValue))\n    }\n \
    \   guard words.count > 1 else {\n        return Err(Int(characters.count, integerValue))\n\
    \    }\n    var split = words.flatMap { str in\n        guard let unicodeScalars\
    \ = str.unicodeScalars else {\n            return nil\n        }\n        return\
    \ unicodeScalars.filter({ unicodeScalar in\n            let unicodeScalar = unicodeScalar\
    \ as UnicodeScalar\n            return unicodeScalar >= UnicodeScalar(letterAscender)\
    \ &&\n                   unicodeScalar <= UnicodeScalar(letterZeros) &&\n    \
    \               unicodeScalar != UnicodeScalar(letterLowercase)\n        }).map\
    \ { unicodeScalar in\n            String(UnicodeScalar(unicodeScalar).value)\n\
    \        }\n    }\n    var strings = split.map { str in\n        guard !str.isEmpty\
    \ else {\n            return str\n        }\n        return String(str.lowercased())\n\
    \    }\n    guard strings.count >= 2 else {\n        return Err(Int(characters.count,\
    \ integerValue))\n    }\n    \n    let maxIndex = strings.count - 1\n    \n  \
    \  var minIndex = min(maxIndex, minLengthOfWord(words: words))\n    guard minIndex\
    \ != maxIndex else {\n        return Err(Int(characters.count, integerValue))\n\
    \    }\n    \n    guard minIndex > 0 else {\n        return Err(Int(characters.count,\
    \ integerValue))\n    }\n    \n    let minString = strings[minIndex]\n    guard\
    \ minString.count != 0 else {\n        return Err(Int(characters.count, integerValue))\n\
    \    }\n    \n    return Ok([minString, words[minIndex], strings[minIndex + 1],\
    \ strings[minIndex + 2]])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpm5j0hwv0.swift:15:51: error: cannot find 'CharacterSet' in scope\n\
    \    guard let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\
    \ else {\n                                                  ^~~~~~~~~~~~\n/tmp/tmpm5j0hwv0.swift:15:27:\
    \ error: value of type 'String' has no member 'components'\n    guard let words\
    \ = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines) else {\n\
    \                      ~~~ ^~~~~~~~~~\n/tmp/tmpm5j0hwv0.swift:16:16: error: cannot\
    \ find 'Err' in scope\n        return Err(Int(characterSet.count, integerValue))\n\
    \               ^~~\n/tmp/tmpm5j0hwv0.swift:16:24: error: cannot find 'characterSet'\
    \ in scope\n        return Err(Int(characterSet.count, integerValue))\n      \
    \                 ^~~~~~~~~~~~\n/tmp/tmpm5j0hwv0.swift:16:44: error: cannot find\
    \ 'integerValue' in scope\n        return Err(Int(characterSet.count, integerValue))\n\
    \                                           ^~~~~~~~~~~~\n/tmp/tmpm5j0hwv0.swift:16:23:\
    \ error: missing argument label 'radix:' in call\n        return Err(Int(characterSet.count,\
    \ integerValue))\n                      ^\n                                  \
    \         radix: \n/tmp/tmpm5j0hwv0.swift:19:16: error: cannot find 'Err' in scope\n\
    \        return Err(Int(characters.count, integerValue))\n               ^~~\n\
    /tmp/tmpm5j0hwv0.swift:19:24: error: cannot find 'characters' in scope\n     \
    \   return Err(Int(characters.count, integerValue))\n                       ^~~~~~~~~~\n\
    /tmp/tmpm5j0hwv0.swift:19:42: error: cannot find 'integerValue' in scope\n   \
    \     return Err(Int(characters.count, integerValue))\n                      \
    \                   ^~~~~~~~~~~~\n/tmp/tmpm5j0hwv0.swift:19:23: error: missing\
    \ argument label 'radix:' in call\n        return Err(Int(characters.count, integerValue))\n\
    \                      ^\n                                         radix: \n/tmp/tmpm5j0hwv0.swift:27:51:\
    \ error: cannot find 'letterAscender' in scope\n            return unicodeScalar\
    \ >= UnicodeScalar(letterAscender) &&\n                                      \
    \            ^~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: .whitespacesAndNewlines)\n\
    \        .filter{$0.characters.count > 0} //remove empty strings\n        .filter{$0.characters.count\
    \ % 2 == 1} //remove odd number of letters\n    return words.count == 0 ? .success(words)\
    \ : .failure(words.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpa6xoxh3r.swift:15:21: error: value of type 'String' has no member\
    \ 'components'\n    let words = txt.components(separatedBy: .whitespacesAndNewlines)\n\
    \                ~~~ ^~~~~~~~~~\n/tmp/tmpa6xoxh3r.swift:15:46: error: cannot infer\
    \ contextual base in reference to member 'whitespacesAndNewlines'\n    let words\
    \ = txt.components(separatedBy: .whitespacesAndNewlines)\n                   \
    \                         ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054560
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \n    if words.count == 1 {\n        return .success(words)\n    }\n    else if\
    \ words.count % 2 == 0 {\n        return .success(words[0..<words.count/2].reversed().map\
    \ { ($0.lowercased(), $1) })\n    }\n    else {\n        return .failure(words.count\
    \ + 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9jo8picd.swift:15:45: error: cannot find 'CharacterSet' in scope\n\
    \    let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \                                            ^~~~~~~~~~~~\n/tmp/tmp9jo8picd.swift:15:21:\
    \ error: value of type 'String' has no member 'components'\n    let words = txt.components(separatedBy:\
    \ CharacterSet.whitespacesAndNewlines)\n                ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return str.split(separator: \" \", omittingEmptySubsequences: false)\n\
    \        .map(str.lowercased())\n        .enumerate()\n        .map { (index,\
    \ char) in\n            guard char != \",\" else {\n                // Commas\
    \ exist, split on commas\n                return str.split(separator: \",\", omittingEmptySubsequences:\
    \ false)\n                    .map(str.lowercased())\n                    .enumerate()\n\
    \                    .map { (index, char) in\n                        if index%2\
    \ == 0 {\n                            return char\n                        } else\
    \ {\n                            return nil\n                        }\n     \
    \               }\n            }\n\n            // No commas exist, split on lower-case\
    \ letters\n            return str.lowercased().characters\n                .enumerate()\n\
    \                .map { (index, char) in\n                    guard index%2 !=\
    \ 0 else {\n                        return char\n                    } else {\n\
    \                        return nil\n                    }\n                }\n\
    \                .filter(String.init(describing: ==)) // remove nils\n       \
    \         .flatMap { chars in\n                    chars.split(separator: \" \"\
    , omittingEmptySubsequences: false)\n                }\n                .map {\
    \ (chars) in\n                    return chars.lowercased()\n                }\n\
    \                .filter {\n                    return !$0.isEmpty // remove empties\n\
    \                }\n        }\n        .filter {\n            return !$0.isEmpty\
    \ // remove empties\n        }\n        .filter { $0.count != 1 }\n        .map({\n\
    \            if $0.count == 0 {\n                return $0.count // return number\
    \ of words with no commas\n            } else {\n                return $0.first\
    \ // return number of words with one comma\n            }\n        })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmploskjwtu.swift:39:22: error: consecutive statements on a line must\
    \ be separated by ';'\n                    } else {\n                     ^\n\
    \                     ;\n/tmp/tmploskjwtu.swift:39:23: error: expected expression\n\
    \                    } else {\n                      ^\n/tmp/tmploskjwtu.swift:15:12:\
    \ error: cannot find 'str' in scope\n    return str.split(separator: \" \", omittingEmptySubsequences:\
    \ false)\n           ^~~\n/tmp/tmploskjwtu.swift:16:14: error: cannot find 'str'\
    \ in scope\n        .map(str.lowercased())\n             ^~~\n/tmp/tmploskjwtu.swift:21:24:\
    \ error: cannot find 'str' in scope\n                return str.split(separator:\
    \ \",\", omittingEmptySubsequences: false)\n                       ^~~\n/tmp/tmploskjwtu.swift:22:26:\
    \ error: cannot find 'str' in scope\n                    .map(str.lowercased())\n\
    \                         ^~~\n/tmp/tmploskjwtu.swift:34:20: error: cannot find\
    \ 'str' in scope\n            return str.lowercased().characters\n           \
    \        ^~~\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let lowercase = txt.lowercased(), let characterCount = lowercase\n\
    \        .countElements() else {\n        return Err(characterCount)\n    }\n\
    \    \n    let upperChar = Character(\"A\") + characterCount - 1\n    \n    if\
    \ characterCount % 2 == 1 {\n        let strings = lowercase.split{$0 == \" \"\
    }\n        \n        if strings.count > 1 {\n            let chars = Array(lowercase.characters)\n\
    \            \n            if let index = chars.firstIndex(where: { char in chars.indices.contains(char\
    \ + upperChar) }) {\n                let start = index\n                let end\
    \ = index\n                \n                if !chars[end].isWhitespace {\n \
    \                   let count = end - start + 1\n                    \n      \
    \              return Ok(strings[start...end])\n                } else {\n   \
    \                 let count = end - start + 2\n                    \n        \
    \            return Ok(strings[start...end])\n                }\n            }\n\
    \        }\n    }\n    \n    let count = characterCount / 2\n    \n    return\
    \ Ok(Array(lowercase.characters.dropFirst(count)))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp1o3ov3be.swift:16:10: error: value of type 'String' has no member\
    \ 'countElements'\n        .countElements() else {\n         ^~~~~~~~~~~~~\n/tmp/tmp1o3ov3be.swift:17:16:\
    \ error: cannot find 'Err' in scope\n        return Err(characterCount)\n    \
    \           ^~~\n/tmp/tmp1o3ov3be.swift:17:20: error: cannot find 'characterCount'\
    \ in scope\n        return Err(characterCount)\n                   ^~~~~~~~~~~~~~\n\
    /tmp/tmp1o3ov3be.swift:15:11: error: initializer for conditional binding must\
    \ have Optional type, not 'String'\n    guard let lowercase = txt.lowercased(),\
    \ let characterCount = lowercase\n          ^               ~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1o3ov3be.swift:26:41: error: 'characters' is unavailable: Please use String\
    \ directly\n            let chars = Array(lowercase.characters)\n            \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1o3ov3be.swift:33:45: error: binary operator '+' cannot\
    \ be applied to operands of type 'Duration' and 'Int'\n                    let\
    \ count = end - start + 1\n                                ~~~~~~~~~~~ ^ ~\n/tmp/tmp1o3ov3be.swift:33:45:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Duration, Duration), (Int, Int)\n                    let count = end - start\
    \ + 1\n                                            ^\n/tmp/tmp1o3ov3be.swift:35:28:\
    \ error: cannot find 'Ok' in scope\n                    return Ok(strings[start...end])\n\
    \                           ^~\n/tmp/tmp1o3ov3be.swift:37:45: error: binary operator\
    \ '+' cannot be applied to operands of type 'Duration' and 'Int'\n           \
    \         let count = end - start + 2\n                                ~~~~~~~~~~~\
    \ ^ ~\n/tmp/tmp1o3ov3be.swift:37:45: note: overloads for '+' exist with these\
    \ partially matching parameter lists: (Duration, Duration), (Int, Int)\n     \
    \               let count = end - start + 2\n                                \
    \            ^\n/tmp/tmp1o3ov3be.swift:39:28: error: cannot find 'O"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let chars: Set<Character> = [.letter, .number, .symbol, \" \", \"\
    ,\"]\n    \n    let wordsArray = txt.components(separatedBy: chars)\n    return\
    \ wordsArray.map({ String($0) })\n        .enumerate()\n        .map { idx, _\
    \ in\n            if idx % 2 == 1 {\n                let num = String.UnicodeScalarView($0).value\n\
    \                return [String.UnicodeScalarView(num).value]\n            } else\
    \ {\n                let letter = String.UnicodeScalarView($0).value\n       \
    \         return [letter]\n            }\n        }\n        .compactMap({ $0\
    \ })\n        .map{ String($0) }\n        .toArray()\n        \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpmaviopk3.swift:22:52: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'idx'?\n\
    \                let num = String.UnicodeScalarView($0).value\n              \
    \                                     ^~\n                                   \
    \                idx\n/tmp/tmpmaviopk3.swift:25:55: error: anonymous closure arguments\
    \ cannot be used inside a closure that has explicit arguments; did you mean 'idx'?\n\
    \                let letter = String.UnicodeScalarView($0).value\n           \
    \                                           ^~\n                             \
    \                         idx\n/tmp/tmpmaviopk3.swift:15:35: error: type 'Character'\
    \ has no member 'letter'\n    let chars: Set<Character> = [.letter, .number, .symbol,\
    \ \" \", \",\"]\n                                 ~^~~~~~\n/tmp/tmpmaviopk3.swift:15:44:\
    \ error: type 'Character' has no member 'number'\n    let chars: Set<Character>\
    \ = [.letter, .number, .symbol, \" \", \",\"]\n                              \
    \            ~^~~~~~\n/tmp/tmpmaviopk3.swift:15:53: error: type 'Character' has\
    \ no member 'symbol'\n    let chars: Set<Character> = [.letter, .number, .symbol,\
    \ \" \", \",\"]\n                                                   ~^~~~~~\n\
    /tmp/tmpmaviopk3.swift:17:26: error: value of type 'String' has no member 'components'\n\
    \    let wordsArray = txt.components(separatedBy: chars)\n                   \
    \  ~~~ ^~~~~~~~~~\n/tmp/tmpmaviopk3.swift:22:56: error: value of type 'String.UnicodeScalarView'\
    \ has no member 'value'\n                let num = String.UnicodeScalarView($0).value\n\
    \                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660054565
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let components = text.components(separatedBy: CharacterSet.whitespacesAndNewlines)\
    \ else {\n        return Result.failure(3)\n    }\n    \n    let words: [String]\
    \ = components.compactMap {\n        guard let firstChar = $0.first else { return\
    \ nil }\n        guard let lastChar = $0.last else { return nil }\n        \n\
    \        switch firstChar {\n        case 'a':\n            return firstChar..<lastChar\n\
    \        case 'b':\n            return firstChar..<lastChar.predecessor()\n  \
    \      case 'c':\n            return firstChar.successor()..<lastChar\n      \
    \  case 'd':\n            return firstChar.successor()..<lastChar.successor()\n\
    \        case 'e':\n            return firstChar..<lastChar.successor()\n    \
    \    case 'f':\n            return firstChar.successor()..<lastChar\n        case\
    \ 'g':\n            return firstChar.successor()..<lastChar.successor()\n    \
    \    case 'h':\n            return firstChar..<lastChar\n        case 'i':\n \
    \           return firstChar..<lastChar.predecessor()\n        case 'j':\n   \
    \         return firstChar.successor()..<lastChar.predecessor()\n        case\
    \ 'k':\n            return firstChar..<lastChar.predecessor()\n        case 'l':\n\
    \            return firstChar.successor()..<lastChar.predecessor()\n        case\
    \ 'm':\n            return firstChar..<lastChar\n        case 'n':\n         \
    \   return firstChar.successor()..<lastChar\n        case 'o':\n            return\
    \ firstChar..<lastChar.predecessor()\n        case 'p':\n            return firstChar.successor()..<lastChar.predecessor()\n\
    \        case 'q':\n            return firstChar..<lastChar.predecessor()\n  \
    \      case 'r':\n            return firstChar.successor()..<lastChar.predecessor()\n\
    \        case 's':\n            return firstChar..<lastChar.predecessor()\n  \
    \      case 't':\n            return firstChar..<lastChar.predecessor()\n    \
    \    case 'u':\n            return firstChar..<lastChar\n        case 'v':\n \
    \           return firstChar..<lastChar.predecessor()\n        case 'w':\n   \
    \         return firstChar.successor()..<lastChar.predecessor()\n        case\
    \ 'x':\n            return firstChar..<lastChar.predecessor()\n        case 'y':\n\
    \            return firstChar.successor()..<lastChar.predecessor()\n        case\
    \ 'z':\n            return firstChar..<lastChar.predecessor()\n        default:\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp3wysafln.swift:24:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp3wysafln.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmp3wysafln.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmp3wysafln.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmp3wysafln.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmp3wysafln.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmp3wysafln.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmp3wysafln.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmp3wysafln.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmp3wysafln.swift:42:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmp3wysafln.swift:44:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmp3wysafln.swift:46:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmp3wysafln.swift:48:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmp3wysafln.swift:50:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmp3wysafln.swift:52:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmp3wysafln.swift:54:14: error: single-quoted st"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let txtUpper = txt.uppercased()\n    let txtLow = txt.lowercased()\n\
    \    let txt = txt.components(separatedBy: \" \")\n\n    let upperToLowOrder =\
    \ txt.map { Int((txtUpper.distance(from: $0) / txtUpper.reduce(0, +))) }\n   \
    \ let upperToLowOrderSet = Set(upperToLowOrder)\n    let upperToLowOrderSorted\
    \ = upperToLowOrderSet.sorted()\n\n    if upperToLowOrderSorted.count == txt.count\
    \ {\n        return .success(txt)\n    } else if upperToLowOrderSorted.count %\
    \ 2 != 0 {\n        return .failure(upperToLowOrderSorted.count)\n    } else {\n\
    \        let letterOrder = txt.map { Int($0.lowercased() - 'a') }\n        let\
    \ letterOrderSet = Set(letterOrder)\n        let letterOrderSorted = letterOrderSet.sorted()\n\
    \        let letterOrderSorted = letterOrderSorted.filter{ $0 % 2 != 0 }\n   \
    \     return .success(letterOrderSorted)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"\
    ]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpbjyee3kj.swift:28:59: error: single-quoted string literal found,\
    \ use '\"'\n        let letterOrder = txt.map { Int($0.lowercased() - 'a') }\n\
    \                                                          ^~~\n             \
    \                                             \"a\"\n/tmp/tmpbjyee3kj.swift:17:19:\
    \ error: value of type 'String' has no member 'components'\n    let txt = txt.components(separatedBy:\
    \ \" \")\n              ~~~ ^~~~~~~~~~\n/tmp/tmpbjyee3kj.swift:19:68: error: missing\
    \ argument for parameter 'to' in call\n    let upperToLowOrder = txt.map { Int((txtUpper.distance(from:\
    \ $0) / txtUpper.reduce(0, +))) }\n                                          \
    \                         ^\n                                                \
    \                   , to: <#String.Index#>\nSwift.String:11:17: note: 'distance(from:to:)'\
    \ declared here\n    public func distance(from start: String.Index, to end: String.Index)\
    \ -> Int\n                ^\n/tmp/tmpbjyee3kj.swift:19:91: error: cannot convert\
    \ value of type '(Int) -> Int' to expected argument type '(Int, String.Element)\
    \ throws -> Int' (aka '(Int, Character) throws -> Int')\n    let upperToLowOrder\
    \ = txt.map { Int((txtUpper.distance(from: $0) / txtUpper.reduce(0, +))) }\n \
    \                                                                            \
    \             ^\n"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var chars: [String] = []\n    var spaces = [String]()\n    var charCount\
    \ = 0\n    \n    func process() {\n        if charCount % 2 == 1 {\n         \
    \   spaces.append(chars.joined(separator: \" \"))\n        }\n        chars.append(charCount)\n\
    \        charCount += 1\n    }\n    \n    for letter in txt {\n        switch\
    \ letter {\n        case \",\":\n            if spaces.count > 0 {\n         \
    \       process()\n                spaces.removeAll()\n            }\n       \
    \ case \" \":\n            if spaces.isEmpty {\n                process()\n  \
    \          } else {\n                process()\n            }\n        default:\n\
    \            process()\n        }\n    }\n    \n    if spaces.isEmpty {\n    \
    \    charCount = (txt.count - 1) / 2\n    }\n    \n    return .success(chars)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmphjsh076p.swift:23:22: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String'\n        chars.append(charCount)\n      \
    \               ^\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var words = [String]()\n    var spaces = \"\"\n    for char in txt\
    \ {\n        let char = String([char])\n        let index = char.index(char.startIndex,\
    \ offsetBy: 1)\n        \n        if char.isSpace {\n            spaces += char\n\
    \        } else {\n            words.append(char.dropLast())\n            words.append(char.dropFirst())\n\
    \        }\n    }\n    \n    if words.isEmpty {\n        return .failure(Int(self.characters.count))\n\
    \    }\n    \n    return .success(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(split_words(txt: \"Hello world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\n\
    assert(split_words(txt: \"Hello world,!\") == .success([\"Hello\", \"world,!\"\
    ]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\"\
    , \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\nassert(split_words(txt:\
    \ \"aaabb\") == .failure(2))\nassert(split_words(txt: \"aaaBb\") == .failure(1))\n\
    assert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpzy5q_sip.swift:21:17: error: value of type 'String' has no member\
    \ 'isSpace'\n        if char.isSpace {\n           ~~~~ ^~~~~~~\n/tmp/tmpzy5q_sip.swift:24:19:\
    \ error: no exact matches in call to instance method 'append'\n            words.append(char.dropLast())\n\
    \                  ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'String' for parameter #1 (got '[String.Element]' (aka 'Array<Character>'))\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'String' for parameter #1 (got '[String.Element]'\
    \ (aka 'Array<Character>'))\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Self.Element)\n                                    ^\n/tmp/tmpzy5q_sip.swift:24:19:\
    \ note: found candidate with type '(__owned [String.Element]) -> ()' (aka '(__owned\
    \ Array<Character>) -> ()')\n            words.append(char.dropLast())\n     \
    \             ^\n/tmp/tmpzy5q_sip.swift:25:19: error: no exact matches in call\
    \ to instance method 'append'\n            words.append(char.dropFirst())\n  \
    \                ^\nSwift.Array:6:37: note: candidate expects value of type 'String'\
    \ for parameter #1 (got 'DropFirstSequence<String>')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'DropFirstSequence<String>')\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Self.Element)\n          \
    \                          ^\n/tmp/tmpzy5q_sip.swift:25:19: note: found candidate\
    \ with type '(__owned DropFirstSequence<String>) -> ()'\n            words.append(char.dropFirst())\n\
    \                  ^\n/tmp/tmpzy5q_sip.swift:30:29: error: cannot find 'self'\
    \ in scope; did you mean to use it in a type or extension context?\n        return\
    \ .failure(Int(self.characters.count))\n                            ^~~~\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\
    \ else { \n        return .failure(25)\n    }\n    \n    return .success(words.compactMap({\
    \ String($0) }))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpx0ahe3ba.swift:15:51: error: cannot find 'CharacterSet' in scope\n\
    \    guard let words = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines)\
    \ else { \n                                                  ^~~~~~~~~~~~\n/tmp/tmpx0ahe3ba.swift:15:27:\
    \ error: value of type 'String' has no member 'components'\n    guard let words\
    \ = txt.components(separatedBy: CharacterSet.whitespacesAndNewlines) else { \n\
    \                      ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054555
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    guard let txt = txt.addingPercentEncoding(withAllowedCharacters:\
    \ .urlFragmentAllowed) else {\n        return Result.failure(Text(\"txt must be\
    \ a valid string\"))\n    }\n\n    guard let chars = txt.unicodeScalars.filter\
    \ { $0.isASCII } .map { String($0) },\n        let wordString = chars.filter {\
    \ $0.isLetter }\n        .flatMap { String($0) }\n        .map(String.init) else\
    \ {\n            return Result.failure(Text(\"txt must be a valid string\"))\n\
    \    }\n    return Result.success(wordString.filter { !$0.isEmpty })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp6s_sgey6.swift:20:39: error: expected 'else' after 'guard' condition\n\
    \        let wordString = chars.filter { $0.isLetter }\n                     \
    \                 ^\n                                      else \n/tmp/tmp6s_sgey6.swift:20:41:\
    \ error: anonymous closure argument not contained in a closure\n        let wordString\
    \ = chars.filter { $0.isLetter }\n                                        ^\n\
    /tmp/tmp6s_sgey6.swift:22:26: error: consecutive statements on a line must be\
    \ separated by ';'\n        .map(String.init) else {\n                       \
    \  ^\n                         ;\n/tmp/tmp6s_sgey6.swift:22:27: error: expected\
    \ expression\n        .map(String.init) else {\n                          ^\n\
    /tmp/tmp6s_sgey6.swift:15:25: error: value of type 'String' has no member 'addingPercentEncoding'\n\
    \    guard let txt = txt.addingPercentEncoding(withAllowedCharacters: .urlFragmentAllowed)\
    \ else {\n                    ~~~ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp6s_sgey6.swift:15:71:\
    \ error: cannot infer contextual base in reference to member 'urlFragmentAllowed'\n\
    \    guard let txt = txt.addingPercentEncoding(withAllowedCharacters: .urlFragmentAllowed)\
    \ else {\n                                                                   \
    \  ~^~~~~~~~~~~~~~~~~~\n/tmp/tmp6s_sgey6.swift:16:31: error: cannot find 'Text'\
    \ in scope\n        return Result.failure(Text(\"txt must be a valid string\"\
    ))\n                              ^~~~\n/tmp/tmp6s_sgey6.swift:21:10: error: cannot\
    \ infer contextual base in reference to member 'flatMap'\n        .flatMap { String($0)\
    \ }\n        ~^~~~~~~\n"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return flatMap {\n        return $0.split(separator: \" \")\n  \
    \  } {\n        $0.split(separator: \",\")\n    } {\n        $0.map { String($0).lowercased()\
    \ }\n    } {\n        return $0.count { $0.isOdd }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp9xg_gr3r.swift:17:6: error: consecutive statements on a line must\
    \ be separated by ';'\n    } {\n     ^\n     ;\n/tmp/tmp9xg_gr3r.swift:21:6: error:\
    \ consecutive statements on a line must be separated by ';'\n    } {\n     ^\n\
    \     ;\n/tmp/tmp9xg_gr3r.swift:15:12: error: cannot find 'flatMap' in scope\n\
    \    return flatMap {\n           ^~~~~~~\n/tmp/tmp9xg_gr3r.swift:18:12: error:\
    \ value of type '(_) -> _' has no member 'split'\n        $0.split(separator:\
    \ \",\")\n        ~~ ^~~~~\n/tmp/tmp9xg_gr3r.swift:19:7: error: unable to infer\
    \ type of a closure parameter '$0' in the current context\n    } {\n      ^\n\
    /tmp/tmp9xg_gr3r.swift:20:12: error: cannot infer return type for closure with\
    \ multiple statements; add explicit type to disambiguate\n        $0.map { String($0).lowercased()\
    \ }\n           ^\n/tmp/tmp9xg_gr3r.swift:21:7: error: unable to infer type of\
    \ a closure parameter '$0' in the current context\n    } {\n      ^\n/tmp/tmp9xg_gr3r.swift:21:7:\
    \ error: closure expression is unused\n    } {\n      ^\n"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words = txt.characters\n        .filter(Character.isLetter)\n\
    \        .sorted()\n        .reduce(into: [String](), {\n            var i = 0\n\
    \            guard i < $0.count else { return }\n            if let last = i-1\
    \ {\n                let slice = $0[i..<last]\n                $0.append(slice.joined(separator:\
    \ \",\"))\n            } else {\n                $0.append($0[i])\n          \
    \  }\n            i += 1\n        })\n        .map { ($0.lowercased() + $1)}\n\
    \    return words.count % 2 == 0 ?\n        Ok(words) :\n        Err(words.count-1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"\
    Hello\", \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"\
    Hello\", \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpm_fir81s.swift:16:27: error: cannot convert value of type 'Bool'\
    \ to expected argument type '(String.Element) throws -> Bool' (aka '(Character)\
    \ throws -> Bool')\n        .filter(Character.isLetter)\n                    \
    \      ^\n/tmp/tmpm_fir81s.swift:16:17: error: instance member 'isLetter' cannot\
    \ be used on type 'Character'; did you mean to use a value of this type instead?\n\
    \        .filter(Character.isLetter)\n                ^~~~~~~~~\n/tmp/tmpm_fir81s.swift:18:35:\
    \ error: contextual closure type '(inout [String], String.Element) throws -> ()'\
    \ (aka '(inout Array<String>, Character) throws -> ()') expects 2 arguments, but\
    \ 1 was used in closure body\n        .reduce(into: [String](), {\n          \
    \                        ^\n/tmp/tmpm_fir81s.swift:29:14: error: contextual closure\
    \ type '(String) throws -> String' expects 1 argument, but 2 were used in closure\
    \ body\n        .map { ($0.lowercased() + $1)}\n             ^\n/tmp/tmpm_fir81s.swift:31:9:\
    \ error: cannot find 'Ok' in scope\n        Ok(words) :\n        ^~\n/tmp/tmpm_fir81s.swift:32:9:\
    \ error: cannot find 'Err' in scope\n        Err(words.count-1)\n        ^~~\n"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    return Ok(txt.split(separator: \" \").toList())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp2iqgn02x.swift:15:12: error: cannot find 'Ok' in scope\n    return\
    \ Ok(txt.split(separator: \" \").toList())\n           ^~\n/tmp/tmp2iqgn02x.swift:15:41:\
    \ error: reference to member 'toList' cannot be resolved without a contextual\
    \ type\n    return Ok(txt.split(separator: \" \").toList())\n                \
    \                        ^\n"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    // Create an array and push words into it\n    var arr = [String]()\n\
    \    for i in txt.characters {\n        if !txt.isEmpty {\n            // If the\
    \ character is a whitespace character then push the word into arr\n          \
    \  if i is Whitespace {\n                arr.append(txt.subString(from: txt.startIndex))\n\
    \                txt.removeSubrange(txt.startIndex)\n            } else if i is\
    \ Comma {\n                // If the character is a comma then push the word into\
    \ arr\n                arr.append(txt.subString(from: txt.startIndex))\n     \
    \           txt.removeSubrange(txt.startIndex)\n            } else {\n       \
    \         // If the character is a letter then push the word into arr\n      \
    \          arr.append(String(i))\n            }\n        } else {\n          \
    \  // If the string is empty then break the loop\n            break\n        }\n\
    \    }\n    if txt.isEmpty {\n        // If the string is empty then return the\
    \ arr length plus 1\n        return arr + [String].count\n    }\n    // Return\
    \ arr\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(split_words(txt:\
    \ \"Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpw3xtwei2.swift:17:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in txt.characters {\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpw3xtwei2.swift:20:21:\
    \ error: cannot find type 'Whitespace' in scope\n            if i is Whitespace\
    \ {\n                    ^~~~~~~~~~\n/tmp/tmpw3xtwei2.swift:21:32: error: value\
    \ of type 'String' has no member 'subString'\n                arr.append(txt.subString(from:\
    \ txt.startIndex))\n                           ~~~ ^~~~~~~~~\n/tmp/tmpw3xtwei2.swift:22:21:\
    \ error: cannot use mutating member on immutable value: 'txt' is a 'let' constant\n\
    \                txt.removeSubrange(txt.startIndex)\n                ~~~ ^\n/tmp/tmpw3xtwei2.swift:22:17:\
    \ error: instance method 'removeSubrange' requires that 'String.Index' conform\
    \ to 'RangeExpression'\n                txt.removeSubrange(txt.startIndex)\n \
    \               ^\nSwift.RangeReplaceableCollection:5:37: note: where 'R' = 'String.Index'\n\
    \    @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R :\
    \ RangeExpression, Self.Index == R.Bound\n                                   \
    \ ^\n/tmp/tmpw3xtwei2.swift:23:28: error: cannot find type 'Comma' in scope\n\
    \            } else if i is Comma {\n                           ^~~~~\n/tmp/tmpw3xtwei2.swift:25:32:\
    \ error: value of type 'String' has no member 'subString'\n                arr.append(txt.subString(from:\
    \ txt.startIndex))\n                           ~~~ ^~~~~~~~~\n/tmp/tmpw3xtwei2.swift:26:21:\
    \ error: cannot use mutating member on immutable value: 'txt' is a 'let' constant\n\
    \                txt.removeSubrange(txt.startIndex)\n                ~~~ ^\n/tmp/tmpw3xtwei2.swift:26:17:\
    \ error: instance method 'removeSubrange' requires that 'String.Index' conform\
    \ to 'RangeExpression'\n                txt.removeSubrange(txt.startIndex)\n \
    \               ^\nSwift.RangeReplaceableCollection:5:37: note: where 'R' = 'String.Index'\n\
    \    @inlinable public mutating func removeSubrange"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let regex = try! NSRegularExpression(pattern: \"\\\\s+\", options:\
    \ [])\n    let matches = regex.matches(in: txt, range: NSRange(txt.startIndex...,\
    \ in: txt))\n    return matches.map { match in\n        let range = Range(match.range,\
    \ in: txt)\n        let substr = txt[range]\n        return substr.components(separatedBy:\
    \ \" \")\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpkqks_y13.swift:15:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"\\\\s+\", options:\
    \ [])\n                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpkqks_y13.swift:16:49:\
    \ error: cannot find 'NSRange' in scope\n    let matches = regex.matches(in: txt,\
    \ range: NSRange(txt.startIndex..., in: txt))\n                              \
    \                  ^~~~~~~\n/tmp/tmpkqks_y13.swift:18:21: error: generic parameter\
    \ 'Bound' could not be inferred\n        let range = Range(match.range, in: txt)\n\
    \                    ^\n/tmp/tmpkqks_y13.swift:18:21: note: explicitly specify\
    \ the generic arguments to fix this issue\n        let range = Range(match.range,\
    \ in: txt)\n                    ^\n                         <<#Bound: Comparable#>>\n\
    /tmp/tmpkqks_y13.swift:18:26: error: initializer expects a single parameter of\
    \ type '(lower: Bound, upper: Bound)' [with Bound = Bound]\n        let range\
    \ = Range(match.range, in: txt)\n                         ^~~~~~~~~~~~~~~~~~~~~~\n\
    \                          (                   )\n/tmp/tmpkqks_y13.swift:18:33:\
    \ error: cannot convert value of type '(_, in: String)' to expected argument type\
    \ '(lower: Bound, upper: Bound)'\n        let range = Range(match.range, in: txt)\n\
    \                                ^\n"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    var count = 1\n    var words = \"\"\n    for s in txt.characters\
    \ {\n        if s.isWhitespace {\n            count = count + 1\n        } else\
    \ {\n            words = words.isEmpty ? words + s : words + s + \",\"\n     \
    \       count = 1\n        }\n    }\n    if count % 2 == 1 {\n        return .failure(count)\n\
    \    }\n    if count > 25 { return .failure(count) }\n    return .success(words.characters.map({\
    \ String($0) }))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(split_words(txt: \"\
    Hello world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello,world!\") == .success([\"Hello\", \"world!\"]))\nassert(split_words(txt:\
    \ \"Hello world,!\") == .success([\"Hello\", \"world,!\"]))\nassert(split_words(txt:\
    \ \"Hello,Hello,world !\") == .success([\"Hello,Hello,world\", \"!\"]))\nassert(split_words(txt:\
    \ \"abcdef\") == .failure(3))\nassert(split_words(txt: \"aaabb\") == .failure(2))\n\
    assert(split_words(txt: \"aaaBb\") == .failure(1))\nassert(split_words(txt: \"\
    \") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmpufe2g0z9.swift:17:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in txt.characters {\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpufe2g0z9.swift:21:55:\
    \ error: binary operator '+' cannot be applied to operands of type 'String' and\
    \ 'Character'\n            words = words.isEmpty ? words + s : words + s + \"\
    ,\"\n                                                      ^\nSwift.RangeReplaceableCollection:5:35:\
    \ note: candidate requires that 'Character' conform to 'RangeReplaceableCollection'\
    \ (requirement specified as 'Other' : 'RangeReplaceableCollection')\n    @inlinable\
    \ public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : RangeReplaceableCollection,\
    \ Self.Element == Other.Element\n                                  ^\n/tmp/tmpufe2g0z9.swift:29:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    return .success(words.characters.map({\
    \ String($0) }))\n                          ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660054556
- exit_code: 1
  program: "\nextension Int: Error {}\n        \n/// Given a string of words, return\
    \ an array of words split on whitespace, if no whitespaces exists in the text\
    \ you\n/// should split on commas ',' if no commas exists you should return the\
    \ number of lower-case letters with odd order in the\n/// alphabet, ord('a') =\
    \ 0, ord('b') = 1, ... ord('z') = 25\n/// Examples\n/// >>> split_words(txt: \"\
    Hello world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"Hello,world!\")\n/// .success([\"Hello\", \"world!\"])\n/// >>> split_words(txt:\
    \ \"abcdef\")\n/// .failure(3)\nfunc split_words(txt: String) -> Result<[String],\
    \ Int> {\n    let words: [String] = txt.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \    if words.count == 0 {\n        return .failure(3)\n    }\n    \n    let lowercase:\
    \ Int = words.reduce(0) { $0 + $1.lowercaseString }\n    \n    return .success(words.dropFirst().map\
    \ { $0.lowercaseString.characterAtIndex($0.lowercaseString.length() - 1) }\n \
    \       .filter { $0.lowercaseString == String(lowercase) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(split_words(txt: \"Hello world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello,world!\") == .success([\"Hello\"\
    , \"world!\"]))\nassert(split_words(txt: \"Hello world,!\") == .success([\"Hello\"\
    , \"world,!\"]))\nassert(split_words(txt: \"Hello,Hello,world !\") == .success([\"\
    Hello,Hello,world\", \"!\"]))\nassert(split_words(txt: \"abcdef\") == .failure(3))\n\
    assert(split_words(txt: \"aaabb\") == .failure(2))\nassert(split_words(txt: \"\
    aaaBb\") == .failure(1))\nassert(split_words(txt: \"\") == .failure(0))"
  status: SyntaxError
  stderr: "/tmp/tmp58_3utz3.swift:15:68: error: cannot find 'NSCharacterSet' in scope\n\
    \    let words: [String] = txt.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \                                                                   ^~~~~~~~~~~~~~\n\
    /tmp/tmp58_3utz3.swift:15:31: error: value of type 'String' has no member 'componentsSeparatedByCharactersInSet'\n\
    \    let words: [String] = txt.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\n\
    \                          ~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_3utz3.swift:20:38:\
    \ error: missing argument label 'into:' in call\n    let lowercase: Int = words.reduce(0)\
    \ { $0 + $1.lowercaseString }\n                                     ^\n      \
    \                                into: \n/tmp/tmp58_3utz3.swift:22:12: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n    return .success(words.dropFirst().map\
    \ { $0.lowercaseString.characterAtIndex($0.lowercaseString.length() - 1) }\n \
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660054651
