name: HumanEval_10_make_palindrome
language: swift
prompt: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
  /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
  \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(string:\
  \ \"\")\n/// \"\"\n/// >>> make_palindrome(string: \"cat\")\n/// \"catac\"\n///\
  \ >>> make_palindrome(string: \"cata\")\n/// \"catac\"\nfunc make_palindrome(string:\
  \ String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\n\
  assert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
  \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
  assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
completions: ["    var string = string\n    var lastChar: Character?\n    var reversed:\
    \ String = \"\"\n    var isPalindrome: Bool = false\n\n    // find longest palindromic\
    \ suffix\n    while lastChar != nil && !isPalindrome {\n        lastChar = string.endIndex.map({\n\
    \            String($0)\n        }).first!\n\n        if string.endIndex.map({\n\
    \            String($0)\n        }).contains(string) {\n            reversed =\
    \ reversed + String(string.substringFromIndex(lastChar!))\n            string\
    \ = String(string.substringFromIndex(lastChar!))\n        } else {\n         \
    \   isPalindrome = true\n        }\n    }\n\n    // append reverse of string that\
    \ comes before palindromic suffix\n    reversed = reversed + string\n\n    if\
    \ isPalindrome {\n        return reversed\n    } else {\n        return reversed\
    \ + string\n    }", "    guard !string.isEmpty else { return string }\n\n    let\
    \ reversedString = string.characters.reversed()\n\n    let longestPalindromicSuffix\
    \ = reversedString.suffix(from: reversedString.count)\n\n    var palindrome =\
    \ string\n    let postfixString = reversedString.suffix(from: reversedString.count)\n\
    \    let prefixString = string.prefix(from: postfixString.count)\n    palindrome\
    \ += String(prefixString)\n    palindrome += String(postfixString)\n    palindrome\
    \ += longestPalindromicSuffix\n    return palindrome", "\tlet length = string.characters.count\n\
    \tif length < 2 {\n\t\treturn string\n\t}\n\n\t// Find the longest postfix that\
    \ is a palindrome.\n\t// The longest postfix is a prefix of string that is equal\
    \ to its reverse (without \"reversed\").\n\tlet prefix = string[..<string.startIndex].reversed()\n\
    \tlet postfix = string[string.endIndex..<string.endIndex.advanced(by: 1)]\n\n\t\
    let suffixStartIndex = postfix.startIndex\n\n\tlet palindrome = prefix + string[suffixStartIndex..<length].reversed()\
    \ + postfix\n\treturn palindrome", "    guard let suffix = string.suffix, let\
    \ prefix = string.prefix else {\n        return string\n    }\n\n    var reversedString\
    \ = reverseString(string)\n    var isPalindrome = checkIfPalindrome(suffix, prefix)\n\
    \n    // If suffix or prefix is shorter than reverse of it is not a palindrome.\n\
    \    if isPalindrome == false {\n        while !isPalindrome {\n            let\
    \ reversedSubString = reversedString.suffix(whereSeparator: \\.isSeparator)\n\
    \            reversedString = reversedSubString?.appended(reversedString)\n  \
    \          isPalindrome = checkIfPalindrome(suffix, prefix)\n        }\n    }\n\
    \n    // If suffix or prefix is not palindrome append reverse of it to the beginning\
    \ of the given string and reverse it again.\n    let palindromePrefix = reversedString.prefix(whereSeparator:\
    \ \\.isSeparator)\n    return palindromePrefix?.appended(string).appended(reversedString)",
  "    var newString = string\n    guard newString.isEmpty == false else {\n     \
    \   return \"\"\n    }\n    guard newString.count >= 1 else {\n        return\
    \ \"\"\n    }\n    var reverseString = \"\"\n    var longestPal = 0\n    var longestPalindromeString\
    \ = \"\"\n    for index in newString.characters {\n        var palCheck = string\n\
    \        var lengthCheck = 0\n        for index2 in string.characters.reverse()\
    \ {\n            if index2 == index {\n                palCheck += String(index2)\n\
    \                lengthCheck += 1\n                break\n            }\n    \
    \    }\n        var postfixCheck = \"\"\n        for index2 in newString.characters.reverse()\
    \ {\n            if index2 == index {\n                postfixCheck += String(index2)\n\
    \                break\n            }\n        }\n        if palCheck == postfixCheck\
    \ {\n            longestPal = lengthCheck\n            if longestPal > longestPalindromeString.characters.count\
    \ {\n                longestPalindromeString = palCheck\n            }\n     \
    \   }\n    }\n    if longestPal > longestPalindromeString.characters.count {\n\
    \        longestPalindromeString = palCheck\n    }\n    newString += String(longestPalindromeString)\n\
    \    return newString", "    let (prefix, suffix) = longest_palindrome_postfix(string)\n\
    \    return string(prefix) + string(suffix)", "\tif string == \"\" {\n\t\treturn\
    \ string\n\t}\n\tstart := 0\n\tend := strings.LastIndex(string, \"\")\n\tfor end\
    \ == -1 || end+1 != len(string) {\n\t\tif string[end+1:end+2] == string[end-1:end-2]\n\
    \t\t{\n\t\t\tend = strings.LastIndex(string, \"\", end+1)\n\t\t}\n\t\telse {\n\
    \t\t\tend = 0\n\t\t}\n\t}\n\tpostfix := strings.LastIndex(string, \"\", start+1)\n\
    \tprefix := strings.Index(string, \"\", end)\n\tsuffixLeft := start - prefix\n\
    \tsuffixRight := end - postfix\n\tsuffix := string[suffixLeft:suffixRight]\n\t\
    suffix += string[start:end]\n\tsuffix += string[postfix : start]\n\tsuffix +=\
    \ string[end : postfix]\n\treturn suffix", "\tlet length = string.characters.count\n\
    \tlet longest = find_longest(string)\n\treturn make_palindrome_helper(string:\
    \ longest, length: length, minLength: 0)", '    return reverse_suffix(string:
    reverse_prefix(string: string), string: string)', "    return string\n       \
    \ .unicodeScalars\n        .reduce(\"\") { $0 + String($1) + String(reverse($2))\
    \ }", "    if string == \"\" {\n        return \"\"\n    }\n\n    var reversed:\
    \ String = \"\"\n    for c in string.characters {\n        reversed.append(String(c))\n\
    \    }\n\n    var result = reversed\n\n    var longest = 0\n\n    var start =\
    \ 0\n    var end = string.characters.count - 1\n\n    var start = end\n    var\
    \ end = string.characters.count - 1\n\n    while end >= start {\n        if string.characters[end]\
    \ == string.characters[start] {\n            if end >= start {\n             \
    \   start += 1\n                end -= 1\n            } else {\n             \
    \   start = end\n                end = string.characters.count - 1\n         \
    \   }\n        } else {\n            if end - start > longest {\n            \
    \    longest = end - start\n                result = reversed\n              \
    \  start = end\n                end = string.characters.count - 1\n          \
    \  }\n            start = end\n            end = string.characters.count - 1\n\
    \        }\n    }\n    if end - start > longest {\n        longest = end - start\n\
    \        result = reversed\n    }\n    return result", "\tguard let stringSlice\
    \ = string.characters.split { $0 == \"\" }.first else {\n\t\treturn string\n\t\
    }\n\n\tguard let longestPostfixString = stringSlice.characters.reversed().split\
    \ { $0 == \"a\" }.last else {\n\t\treturn string\n\t}\n\n\treturn string + stringSlice[0\
    \ ..< longestPostfixString.count].reversed()", "    var palindrome: String = \"\
    \"\n    var longestPalindrome = string\n    var longestPalindromeLength = 0\n\
    \    for character in string {\n        longestPalindromeLength += character\n\
    \    }\n\n    for character in string {\n        longestPalindrome += String(character).reversed()\n\
    \    }\n\n    for character in longestPalindrome {\n        if character != string[longestPalindromeLength]\
    \ {\n            return \"\"\n        }\n    }\n    return longestPalindrome",
  "\tvar longestPalindromeLength = string.characters.count\n\tvar prefixString = \"\
    \"\n\tfor prefixIndex in 0..<string.characters.count-1 {\n\t\tif string[prefixIndex]\
    \ != string[prefixIndex].lowercased() {\n\t\t\tbreak\n\t\t}\n\t\tprefixString\
    \ += string[prefixIndex]\n\t}\n\n\t// reverse prefixString\n\tprefixString = StringReverse(prefixString)\n\
    \n\t// append longestPalindromeLength to prefixString and reverse\n\tstring =\
    \ (prefixString + String(longestPalindromeLength)) + (String(longestPalindromeLength)).reversed()\n\
    \n\tlongestPalindromeLength = string.characters.count\n\tfor suffixIndex in 0..<string.characters.count-1\
    \ {\n\t\tif string[suffixIndex] != string[suffixIndex].lowercased() {\n\t\t\t\
    break\n\t\t}\n\t\tlongestPalindromeLength -= 1\n\t}\n\n\tlet longestPalindrome\
    \ = string\n\n\treturn longestPalindrome", "    // We could find all longest postfixes\
    \ that is a palindrome.\n    // But that would require to compute all possible\
    \ reverse strings for every possible prefix.\n    // To avoid that and to save\
    \ some time we can find only longest palindromes starting with given string.\n\
    \    var palindrome = \"\"\n    var longest_postfix_start = string.characters.count\n\
    \    var longest_postfix_end = longest_postfix_start\n    longest_postfix_end\
    \ = longest_postfix_end + 1\n\n    var longest_prefix_end = longest_postfix_end\n\
    \    if longest_postfix_start > 0 {\n        let longest_prefix_start_index =\
    \ string.characters.index(string.startIndex, offsetBy: longest_postfix_start)\n\
    \        if longest_prefix_start_index > 0 {\n            let longest_prefix_start_char_index\
    \ = string.characters.index(longest_prefix_start_index, offsetBy: -1)\n      \
    \      let longest_prefix_start_char = String(string.characters[longest_prefix_start_char_index])\n\
    \            longest_prefix_end = longest_prefix_start_char_index\n          \
    \  for index in longest_prefix_start_char_index..<longest_prefix_start_index +\
    \ longest_prefix_start {\n                longest_prefix_end = longest_prefix_end\
    \ + 1\n            }\n        }\n    }\n\n    // Now we just need to find longest\
    \ palindrome ending with a postfix that doesn't contain any character\n    //\
    \ that comes before longest palindromic suffix.\n    // If found longest palindrome\
    \ is a palindrome\n    var longest_palindrome_start = longest_prefix_end\n   \
    \ if longest_prefix_start > 0 {\n        let longest_palindrome_start_index =\
    \ string.characters.index(string.startIndex, offsetBy: longest_prefix_start)\n\
    \        if longest_palindrome_start_index > 0 {\n            let longest_palindrome_start_char_index\
    \ = string.characters.index(longest_palindrome_start_index, offsetBy: -1)\n  \
    \          let longest_palindrome_start_char = String(string.characters[longest_palindrome_start_char_index])\n\
    \            let longest_palindrome_end = longest_palindrome_start_char_index\n\
    \            for index in longest_palindrome_start_char_index..<longest_palindrome_start_index\
    \ + longest_palindrome_start {\n                longest_palindrome_end = longest_palindrome_end\
    \ + 1\n            }\n            if longest_palindrome_end < longest_postfix_end\
    \ {\n                // Longest palindrome that ends with a postfix that doesn't\
    \ contain any character before\n                // longest palindromic suffix.\n\
    \                longest_palindrome_", '    return string', "    var reversed\
    \ = String()\n    var remainder = string\n    var longestPalindrome = 0\n\n  \
    \  while remainder.characters.count > 0 {\n        if remainder.characters.count\
    \ < longestPalindrome {\n            longestPalindrome = remainder.characters.count\n\
    \        }\n        if longestPalindrome == 0 {\n            break\n        }\n\
    \        let longestPalindromeCharacters = remainder.characters[0..<longestPalindrome]\n\
    \        var reversedString = \"\"\n        for char in longestPalindromeCharacters\
    \ {\n            reversedString += String(char)\n        }\n        remainder\
    \ = String(reversedString).reverse()\n    }\n    if reversed.characters.count\
    \ != string.characters.count {\n        return \"\"\n    }\n    return string\
    \ + reversed", "    // Find the longest postfix that is a palindrome\n    let\
    \ longestPalindrome = longestPostfix(string: string)\n\n    // If the prefix is\
    \ shorter than the postfix then return the same string\n    // Otherwise append\
    \ reverse of the prefix to the postfix and return the result\n    return longestPalindrome.isEmpty\
    \ ? string :\n        (longestPalindrome.isPalindrome() ? longestPalindrome +\
    \ string.rev() : string)", "    var length = 0\n    var start = string.startIndex\n\
    \n    do {\n        let start = string.index(string.startIndex, offsetBy: length)\n\
    \n        if let end = string.endIndex,\n            string.substring(from: start,\
    \ to: end).isPalindrome() {\n            let result = string.substring(from: start,\
    \ to: end)\n            let len = string.distance(from: string.startIndex, to:\
    \ end)\n\n            return result + make_palindrome(string: String(string[..(len\
    \ - 1)].reversed()))\n        }\n        length += 1\n    } while string.index(string.startIndex,\
    \ offsetBy: length) != start\n\n    return string", "    // Find longest prefix\
    \ that is palindrome\n    let longestPalindromic = LongestPalindromic(string)\n\
    \    if longestPalindromic.isEmpty {\n        return string\n    }\n\n    // Append\
    \ reverse of prefix that comes before this palindromic suffix\n    let postfix\
    \ = string[longestPalindromic.last!.endIndex...]\n    let reverse = reverseString(string:\
    \ longestPalindromic.prefix[longestPalindromic.last!.startIndex..<longestPalindromic.last!.endIndex])\n\
    \n    return postfix + reverse", "    var reverse = \"\"\n    var longestPrefixMatch\
    \ = 0\n    for i in 0 ..< string.characters.count {\n        var substring = string[longestPrefixMatch..<i].reversed()\n\
    \        let longestPalindrome = substring.reversed()\n        if substring ==\
    \ longestPalindrome {\n            longestPrefixMatch = i\n            reverse\
    \ = reverse.dropping(at: longestPrefixMatch)\n        }\n    }\n    reverse =\
    \ reverse.dropping(at: longestPrefixMatch)\n    return reverse", "\tif string\
    \ == \"\" {\n\t\treturn \"\"\n\t}\n\n\tlet reversed = string.characters.reversed()\n\
    \tlet prefixLength = (string.characters.count / 2)\n\n\treturn reversed\n\t\t\
    .prefix(prefixLength)\n\t\t.last!\n\t\t.padding(toLength: string.characters.count,\
    \ withPad: reversed.first!)", "    guard let suffix_len = string.reversed().characters.count\
    \ else {\n        return string\n    }\n\n    let prefix_len = string.characters.count\
    \ - suffix_len\n    let prefix_reversed = string.reversed()\n    let postfix_reversed\
    \ = prefix_reversed.suffix(from: suffix_len)\n    let postfix = String(prefix_reversed.reversed())\n\
    \    guard postfix_reversed == postfix else { return \"\" }\n    return string\
    \ + postfix_reversed", "    var stringToPalindrome = string\n    var longestPostfixOfString\
    \ = String()\n    var longestPalindrome = String()\n    var isLongestPalindrome\
    \ = false\n\n    for _ in 0..<string.count {\n        var longestPostfixOfStringWithCurrentCharacter\
    \ = String()\n        var longestPalindromeWithCurrentCharacter = String()\n \
    \       var isLongestPalindromeWithCurrentCharacter = false\n        for _ in\
    \ 0..<stringToPalindrome.count {\n            var currentCharacter = stringToPalindrome[stringToPalindrome.index(startIndex,\
    \ offsetBy: 0)]\n            if currentCharacter == stringToPalindrome[stringToPalindrome.index(endIndex,\
    \ offsetBy: 0)] {\n                longestPostfixOfStringWithCurrentCharacter\
    \ = longestPostfixOfStringWithCurrentCharacter + String(currentCharacter) + stringToPalindrome[stringToPalindrome.index(endIndex,\
    \ offsetBy: 1)]\n                longestPalindromeWithCurrentCharacter = longestPalindromeWithCurrentCharacter\
    \ + String(currentCharacter) + stringToPalindrome[stringToPalindrome.index(startIndex,\
    \ offsetBy: 1)]\n                isLongestPalindromeWithCurrentCharacter = isLongestPalindromeWithCurrentCharacter\
    \ || (currentCharacter == stringToPalindrome[stringToPalindrome.index(endIndex,\
    \ offsetBy: 0)])\n            }\n            else {\n                if currentCharacter\
    \ == stringToPalindrome[stringToPalindrome.index(endIndex, offsetBy: 0)] {\n \
    \                   longestPostfixOfStringWithCurrentCharacter = longestPostfixOfStringWithCurrentCharacter\
    \ + String(currentCharacter) + stringToPalindrome[stringToPalindrome.index(endIndex,\
    \ offsetBy: 1)]\n                    longestPalindromeWithCurrentCharacter = longestPalindromeWithCurrentCharacter\
    \ + String(currentCharacter) + stringToPalindrome[stringToPalindrome.index(startIndex,\
    \ offsetBy: 1)]\n                    isLongestPalindromeWithCurrentCharacter =\
    \ isLongestPalindromeWithCurrentCharacter || (currentCharacter == stringToPalindrome[stringToPalindrome.index(endIndex,\
    \ offsetBy: 0)])\n                }\n                else {\n                \
    \    longestPostfixOfStringWithCurrentCharacter = longestPostfixOfStringWithCurrentCharacter\
    \ + String(currentCharacter) + stringToPalindrome[stringToPalindrome.index(endIndex,\
    \ offset", "    var output = \"\"\n    var prefix = \"\"\n    var suffix = \"\"\
    \n\n    // Remove trailing spaces and punctuation.\n    for character in string.whitespaces\
    \ {\n        string = string.strip(character)\n    }\n\n    for character in string.lowercases\
    \ {\n        prefix = prefix + character\n    }\n\n    for character in string.uppercases\
    \ {\n        suffix = suffix + \"A\" + character\n    }\n\n    // If no prefix\
    \ or suffix found, then no palindrome could be found\n    if string.whitespaces.count\
    \ == 0 {\n        return output\n    }\n\n    // If no palindrome could be found,\
    \ then return input\n    if prefix != suffix {\n        return output\n    }\n\
    \n    // Find longest postfix of supplied string that is a palindrome.\n    //\
    \ Prefix is always length 1 as long as a suffix can be found as a palindrome\n\
    \    var postfix = \"\"\n    for character in string.lowercases {\n        if\
    \ string.lowercases.count == 0 { break }\n        postfix = postfix + character\n\
    \    }\n\n    // If no palindrome could be found, then return input\n    if postfix.lowercases.count\
    \ == 0 {\n        return output\n    }\n\n    // Append the reverse of the prefix\
    \ to the suffix to make it a palindrome\n    var reversePrefix = \"\"\n    for\
    \ character in prefix.lowercases {\n        reversePrefix = reversePrefix + character\n\
    \    }\n    reversePrefix = reversePrefix.uppercases.reverse()\n\n    var reverseSuffix\
    \ = \"\"\n    for character in postfix.uppercases {\n        reverseSuffix = reverseSuffix\
    \ + character\n    }\n    reverseSuffix = reverseSuffix.lowercases.reverse()\n\
    \n    // If no palindrome could be found, then return input\n    if reversePrefix.uppercases.count\
    \ == 0 || reverseSuffix.lowercases.count == 0 {\n        return output\n    }\n\
    \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    var finalString = \"\"\n    var appendSuffix\
    \ = false\n    var appendPrefix = false\n\n    var index = string.lowercases.count\
    \ - 1\n    for character in reverseSuffix.lowercases {\n        finalString =\
    \ finalString + character\n        index = index - 1\n        if index == 0 {\n\
    \            appendSuffix = true\n            break\n        }\n    }\n\n    for\
    \ character in reversePrefix.lowercases {\n        finalString = finalString +\
    \ character\n        index = index - 1\n        if index == 0 {\n            appendPrefix\
    \ = true\n            break\n        }\n    }\n\n    if appendSuffix {\n     \
    \   finalString = finalString + suffix\n    }\n\n    if appendPrefix {\n     \
    \   finalString = finalString + prefix\n    }\n\n    return finalString", "  \
    \  var s = string\n    // Find the longest postfix that is a palindrome.\n   \
    \ // Find the first suffix that comes before the longest postfix that is a palindrome.\n\
    \    var start = 0\n    var longest = 0\n    while start < s.characters.count\
    \ {\n        if s[start] != s[start].reversed() {\n            // Found a suffix\
    \ that comes before the longest prefix.\n            longest = start\n       \
    \     break\n        }\n        start += 1\n    }\n    if longest == 0 {\n   \
    \     return string\n    }\n    // Append reverse of longest postfix to string.\n\
    \    s += String(s[longest].reversed())\n    return s", "\tvar length : Int\n\t\
    var max : String\n\tvar min : String\n\tvar temp : String\n\tvar postfix = \"\"\
    \n\tvar start = true\n\tfor let character = string.characters {\n\t\tif character\
    \ == \"-\" {\n\t\t\tstart = false\n\t\t}\n\t\tif start {\n\t\t\tpostfix += String(character)\n\
    \t\t}\n\t\tif character == \" \" || character == \"-\" {\n\t\t\tif min == \"\"\
    \ || length < length {\n\t\t\t\tmin = postfix\n\t\t\t\ttemp = postfix\n\t\t\t\t\
    length = postfix.characters.count\n\t\t\t}\n\t\t\tstart = true\n\t\t}\n\t\telse\
    \ if character == \"-\" {\n\t\t\tif min == \"\" || length < length {\n\t\t\t\t\
    max = temp\n\t\t\t\ttemp = postfix\n\t\t\t\tlength = postfix.characters.count\n\
    \t\t\t}\n\t\t\tstart = true\n\t\t}\n\t}\n\treturn temp", "    guard let length\
    \ = string.count else { return \"\" }\n    guard length > 1 else {\n        return\
    \ string\n    }\n    guard let suffix = string.suffix(from: length - 1) else {\n\
    \        return string\n    }\n    let reversed = string.replacingOccurrences(of:\
    \ suffix, with: \"\", options: .literal, range: nil)\n    guard let prefix = string.prefix(from:\
    \ length - 1) else {\n        return reversed\n    }\n    return prefix + (reversed)\
    \ + suffix", "\tlet charSet = CharacterSet(charactersIn: string)\n\tif charSet.lowercased()\
    \ != charSet {\n\t\tcharSet.union(charSet.lowercased())\n\t}\n\tlet reverseCharSet\
    \ = CharacterSet(charactersIn: string.reversed())\n\tif reverseCharSet.lowercased()\
    \ != reverseCharSet {\n\t\treverseCharSet.union(reverseCharSet.lowercased())\n\
    \t}\n\tlet prefix = string.prefix(where: charSet)\n\tlet suffix = string.suffix(where:\
    \ charSet)\n\tlet reverseSuffix = string.reversed().suffix(where: reverseCharSet)\n\
    \treturn prefix + reverseSuffix", "    var reversed = string\n    for i := 0;\
    \ i < len(string); i++ {\n        reversed = string[i..<i+1] + reversed\n    }\n\
    \    return string[:i-1] + reversed", "\tif string == \"\" {\n\t\treturn \"\"\n\
    \t}\n\n\tvar longestPalString = \"\"\n\tvar longestPalLength = 0\n\tvar longestPalStringLength\
    \ = 0\n\tvar palStringStart = 0\n\n\tfor i := 0; i < len(string); i++ {\n\t\t\
    if string[i] == string[len(string)-1-i {\n\t\t\tlongestPalString += string[i]\n\
    \t\t\tlongestPalLength++\n\t\t}\n\t}\n\n\tfor i := 0; i < longestPalLength; i++\
    \ {\n\t\tpalStringStart += longestPalLength-i\n\t\tpalStringStart %= len(string)\n\
    \t\tlongestPalString += string[palStringStart]\n\t}\n\tlongestPalString += string[len(string)-1-longestPalLength]\n\
    \n\treturn longestPalString", "\tlet maxPostfixLength = findLongestPalindromePostfix(string:\
    \ string)\n\treturn appendToEndOfPalindrome(string: string, maxPostfixLength:\
    \ maxPostfixLength)", "    if string == \"\" { return \"\" }\n    let postfix\
    \ = string.reduce(\"\") {\n        (previous, current) -> String in\n        let\
    \ prefixSlice = string.index(string.startIndex, offsetBy: Int(previous.count))\n\
    \        let suffix = string[prefixSlice]\n        let suffixSlice = suffix.reversed()\n\
    \        return prefix + suffix\n    }\n    let palindromeSlice = postfix.index(postfix[postfix.startIndex],\
    \ offsetBy: Int(postfix.count))\n    return string.substringToIndex(palindromeSlice)",
  "    // Find longest prefix that contains palindromic suffix.\n    let stringLen\
    \ = string.characters.count\n    let longestCommonPrefix = reversedString(string:\
    \ string.characters.suffix(stringLen))\n    \n    // Reverse the longest prefix\
    \ string and append it to the suffix.\n    let reversedLongestCommonPrefix = reversedString(string:\
    \ longestCommonPrefix)\n    let longestPalindrome = string.appending(reversedLongestCommonPrefix)\n\
    \    \n    return longestPalindrome", "\tif string == \"\" {\n\t\treturn \"\"\n\
    \t}\n\n\tlength := len(string)\n\tif length == 1 {\n\t\treturn string\n\t}\n\n\
    \tvar result string = string\n\tvar result string = string\n\tresult := string(strings.Reverse(result))\n\
    \tfor i := length - 1; i >= 0; i-- {\n\t\tresult += string[i]\n\t\tif strings.EqualFold(\"\
    a\" + string[:i+1], reverse(result)) {\n\t\t\treturn result\n\t\t}\n\t}\n\treturn\
    \ result", "    // longest palindrome prefix is empty string\n    var longestPalindrome\
    \ = \"\"\n\n    // start from first character in the string\n    for ch in string.characters\
    \ {\n        // append the first character to the palindrome\n        let palindrome\
    \ = StringBuilder()\n        palindrome.append (String(palindrome: longestPalindrome,\
    \ length: 0))\n        // append the rest of the palindrome\n        palindrome.append\
    \ (String(palindrome: longestPalindrome, length: 0))\n        palindrome.append\
    \ (String(palindrome: ch))\n        // append the reverse of the last character\
    \ in the string before this palindrome\n        palindrome.append (String(palindrome:\
    \ longestPalindrome, length: 0))\n        longestPalindrome = palindrome.string\n\
    \n    }\n    return longestPalindrome", "    guard let result = string.stringByReplacingOccurrencesOfString(\"\
    /\", withString: \"\") else {\n        return string\n    }\n\n    let reversedResult\
    \ = reverseString(string: result)\n    let prefixString = string[string.startIndex..<string.endIndex]\n\
    \n    return prefixString + reversedResult", "\tlength, _ := strlen(string)\n\t\
    var palindrome String\n\tfor i := length - 1; i >= 0; i-- {\n\t\tchar := string[i]\n\
    \t\tsuffix := string[i+1 : length]\n\t\tif isPalindrome(suffix, char) {\n\t\t\t\
    palindrome += string(char)\n\t\t\tpalindrome += string(suffix[0 : length-1])\n\
    \t\t}\n\t}\n\treturn palindrome", "\treturn string", "\treturn string.palindrome()",
  "    // \"cata\" is palindrome for \"cat\"\n    if string == \"\" {\n        return\
    \ string\n    }\n\n    // find the longest postfix string that is a palindrome\n\
    \    let postfix = longestPalindromicPostfix(string)\n    \n    // build resulting\
    \ string\n    var result = string\n    for i in (string.characters.count) - 1\
    \ ..< string.characters.count {\n        let start = postfix.index(postfix.startIndex,\
    \ offsetBy: i)\n        let end = postfix.index(postfix.endIndex, offsetBy: -i)\n\
    \        let suffix = string[start..<end]\n        result += suffix + \"c\"\n\
    \    }\n    \n    return result", "    var originalString = string\n    var longestPostfix\
    \ = 0\n    var longestPalindromicString = \"\"\n\n    for originalStringLength\
    \ in 0..<originalString.count {\n        if originalString[originalStringLength]\
    \ == originalString[originalString.count - originalStringLength] {\n         \
    \   longestPostfix = originalString.count - originalStringLength\n           \
    \ break\n        }\n    }\n\n    for stringLength in 0..<string.count {\n    \
    \    if originalString[stringLength] == string[string.count - stringLength] {\n\
    \            var reversedString = reverseString(string: string[stringLength..<string.count])\n\
    \            longestPalindromicString = longestPalindromicString + reversedString\
    \ + string[stringLength..<string.count]\n            if stringLength > longestPalindromicString.count\
    \ {\n                longestPalindromicString = longestPalindromicString + reverseString(string:\
    \ originalString[stringLength..<originalString.count])\n            }\n      \
    \      break\n        }\n    }\n\n    originalString = originalString[longestPostfix..<originalString.count]\n\
    \    for stringLength in 0..<string.count {\n        if originalString[stringLength]\
    \ == string[string.count - stringLength] {\n            var reversedString = reverseString(string:\
    \ string[stringLength..<string.count])\n            longestPalindromicString =\
    \ longestPalindromicString + reversedString + string[stringLength..<string.count]\n\
    \            if stringLength > longestPalindromicString.count {\n            \
    \    longestPalindromicString = longestPalindromicString + reverseString(string:\
    \ originalString[stringLength..<originalString.count])\n            }\n      \
    \  }\n    }\n\n    return longestPalindromicString", "    var s = string\n   \
    \ var result: String = s\n    let length = string.length\n    if length > 0 {\n\
    \        var reversed: String = \"\"\n        for i in 0 ..< length {\n      \
    \      let index = length - i - 1\n            let temp = s.substring(index, index\
    \ + 1)\n            reversed.append(temp)\n        }\n        result = string\
    \ + reversed\n    }\n    return result", "    var result = \"\"\n    let prefix\
    \ = string.characters.reversed()\n    \n    for character in string.characters\
    \ {\n        let suffix = (string + String(character, radix: 16)).characters.reversed()\n\
    \        let suffixHasBeenAdded = suffix == prefix + suffix\n        \n      \
    \  if suffixHasBeenAdded {\n            result += String(character, radix: 16)\n\
    \        }\n    }\n\n    return result", "    if string == \"\" {\n        return\
    \ \"\"\n    }\n\n    // create prefix and postfix of string\n    let prefix =\
    \ string[..<string.index(string.characters.reversed(), startingAt: 0)]\n    let\
    \ postfix = string[string.index(string.characters.reversed(), startingAt: 0) ..<string.endIndex]\n\
    \n    // check if prefix is a palindrome\n    if let index = prefix.index(of:\
    \ String(string[prefix.startIndex, 1], radix: 16)) {\n        if let end = prefix.index(of:\
    \ String(string[prefix.endIndex - 1, 1], radix: 16)) {\n            return prefix\
    \ + String(string[index..<end], radix: 16) + String(string[end..<prefix.endIndex],\
    \ radix: 16)\n        }\n    }\n\n    // check if prefix is a palindrome\n   \
    \ if let index = postfix.index(of: String(string[postfix.startIndex, 1], radix:\
    \ 16)) {\n        if let end = postfix.index(of: String(string[postfix.endIndex\
    \ - 1, 1], radix: 16)) {\n            return prefix + String(string[prefix.startIndex..<index],\
    \ radix: 16) + String(string[index..<end], radix: 16)\n        }\n    }\n\n  \
    \  return \"\"", "    if string == \"\" {\n        return \"\"\n    }\n\n    //\
    \ First find longest palindrome in the string.\n    var longest_postfix_string\
    \ = \"\"\n    var longest_postfix_string_index = 0\n    for index = 0; index <\
    \ string.count; index++ {\n        if isPalindrome(string[index: index]) {\n \
    \           longest_postfix_string = string[index: index]\n            longest_postfix_string_index\
    \ = index\n        }\n    }\n\n    // If there is palindrome in the string - find\
    \ its prefix to append to end of the string.\n    if longest_postfix_string !=\
    \ \"\" {\n        let longest_postfix_string_index = longest_postfix_string.endIndex\n\
    \        var prefix_string = string[index: longest_postfix_string_index]\n   \
    \     if isPalindrome(longest_postfix_string) {\n            for index in longest_postfix_string.endIndex..<string.startIndex\
    \ {\n                if isPalindrome(String(string[index])) {\n              \
    \      prefix_string += string[index]\n                }\n            }\n    \
    \    }\n        return String(prefix_string) + String(reverse(string[longest_postfix_string_index..<string.startIndex]))\n\
    \    }\n\n    // If there is no palindrome in the string - just return supplied\
    \ string.\n    return string", "    let prefix = string.characters.prefix(string)\n\
    \    let suffix = string.characters.suffix(string)\n\n    return String(self).characters.prefix(string)\n\
    \        .appending(prefix.characters.reversed())\n        .appending(suffix)",
  "\tlongestCommonPrefix := LongestCommonPrefix(string)\n\tlongestCommonSuffix :=\
    \ LongestCommonSuffix(string, longestCommonPrefix)\n\n\tmiddleIndex := (longestCommonPrefix.Length\
    \ + longestCommonSuffix.Length) / 2\n\tmiddleIndex %= len(string)\n\n\treturn\
    \ append(longestCommonPrefix, Reverse(string[0 : middleIndex])...)", "\t// Create\
    \ a buffer with the initial string.\n\t// This will be the result of a palindromic\
    \ suffix.\n\tvar buffer [String]\n\tbuffer.append(string)\n\t\n\t// The longest\
    \ postfix of buffer that is a palindrome.\n\tvar postfix_longest [String]\n\t\n\
    \t// The longest palindromic suffix that ends after the longest postfix.\n\tvar\
    \ suffix_longest [String]\n\t\n\t// Find longest postfix of buffer that is a palindrome.\n\
    \tpostfix_longest = longestPalindrome(buffer)\n\t\n\t// Append the reverse of\
    \ postfix_longest to the end of buffer.\n\t// This will be the result of a palindromic\
    \ suffix.\n\tbuffer.append(reverseString(postfix_longest))\n\t\n\t// Find longest\
    \ palindromic suffix that ends after the longest postfix.\n\tsuffix_longest =\
    \ longestPalindrome(buffer)\n\t\n\t// Return concatenation of postfix_longest\
    \ and suffix_longest\n\treturn buffer.joinWithSeparator(string: suffix_longest)",
  "\tif string == \"\" {\n\t\treturn \"\"\n\t}\n\tmaxLen := findLongestPostfix(string)\n\
    \tfirstPart := strings.Repeat(string[maxLen..], len(string[maxLen-1:]))\n\treturn\
    \ firstPart + string[:maxLen]", "    var result = \"\"\n    var i = 0\n    var\
    \ max = string.length - 1\n    while i <= max {\n        if i == max {\n     \
    \       result += string[i..<max].reversed()\n        } else {\n            result\
    \ += string[i..<max]\n        }\n        if i == max {\n            result +=\
    \ string[max..<i].reversed()\n        } else {\n            result += string[max..<i]\n\
    \        }\n        i += 1\n    }\n    return result", "\tlet stringLength = string.count\n\
    \tlet stringPrefix = string.prefix(stringLength)\n\tlet stringSuffix = string.reversed()\n\
    \treturn stringPrefix + stringSuffix", "\tlet prefix = string\n\tlet suffix =\
    \ String()\n\tlet reversedSuffix = String()\n\tlet prefix = prefix.reversed()\n\
    \tlet reversedPrefix = String()\n\tlet suffix = suffix.reversed()\n\tlet longestPalindrome\
    \ = longestPrefix(string: prefix, prefix: string)\n\treversedPrefix.append(longestPalindrome)\n\
    \treversedSuffix.append(longestPalindrome.reversed())\n\treturn prefix.append(reversedSuffix).reversed()",
  "    var palindrome = \"\"\n    var index = string.characters.count\n    let letters\
    \ = string.characters\n\n    if index == 0 {\n        return string\n    }\n\n\
    \    for _ in 0..<index {\n        for character in letters {\n            let\
    \ reverse = String(character).reverse()\n            if string == reverse {\n\
    \                palindrome += String(character)\n                break\n    \
    \        }\n        }\n    }\n\n    return palindrome", "    guard let startIndex\
    \ = string.startIndex else { return \"\" }\n    let reversedString = string.characters.reversed()\n\
    \    let longestPalindromeSuffixIndex = reversedString.index(of: startIndex, options:\
    \ .backwards, range: nil)!\n    return reversedString.substring(from: longestPalindromeSuffixIndex)",
  "    guard let length = string.characters.count,\n        let longest = string.prefix(from:\
    \ length, to: 0) else { return \"\" }\n    var result = string\n    var suffixIndex\
    \ = 0\n    while let prefixIndex = longest.characters.index(longest.startIndex,\
    \ offsetBy: -suffixIndex) {\n        let reversedPrefixIndex = longest.characters.index(longest.startIndex,\
    \ offsetBy: prefixIndex)\n        let suffix = string[reversedPrefixIndex..<longest.endIndex]\n\
    \        suffixIndex += suffixIndex == 0 ? length : 1\n        let prefixReversed\
    \ = string[prefixIndex..<reversedPrefixIndex]\n        let reversedSuffix = string.reversed(suffix).characters.joinWithSeparator(\"\
    \")\n        result = result.appendingString(prefix : prefixReversed, suffix :\
    \ suffix)\n    }\n    return result", "    if string == \"\" {\n        return\
    \ \"\"\n    }\n\n    // Find the longest postfix of string that is a palindrome\n\
    \    var longest_postfix = 0\n    var longest_postfix_to_find = string\n    for\
    \ index in string.indices {\n        if string.substring(index, index) == string.reverse\
    \ {\n            longest_postfix_to_find = string[index...index]\n           \
    \ longest_postfix = index\n        }\n    }\n\n    var result_string = string\n\
    \    \n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    var prefix_reversed_suffix_index =\
    \ 0\n    for i in longest_postfix ..< longest_postfix_to_find.indices {\n    \
    \    \n        var reverse_sub_string = string[longest_postfix_to_find.indices[i]...longest_postfix_to_find.indices[i]].reverse\n\
    \        \n        if result_string.substring(i, longest_postfix_to_find.indices[i]\
    \ - 1) == reverse_sub_string {\n            \n            prefix_reversed_suffix_index\
    \ = i\n            break\n        }\n    }\n    \n    result_string = result_string\
    \ + string[prefix_reversed_suffix_index...prefix_reversed_suffix_index + longest_postfix]\n\
    \    \n    return result_string", "    let max_len = string.count\n    if max_len\
    \ == 0 {\n        return string\n    }\n    var result = \"\"\n    for i = max_len\
    \ - 1, j = max_len; i >= 0 || j >= 0; i--, j-- {\n        let c = string[j]\n\
    \        let r = string[i]\n        result += r\n        if r != c {\n       \
    \     break\n        }\n    }\n    return result", "\tprefix := string\n\tvar\
    \ result string = string\n\tvar length int = len(string)\n\n\tfor i := 0; i <=\
    \ length/2; i++ {\n\t\tif string[i] != string[length-i-1] {\n\t\t\tbreak\n\t\t\
    }\n\t}\n\tfor j := length - 1; j >= 0; j-- {\n\t\tif string[j] != string[j+1]\
    \ {\n\t\t\tbreak\n\t\t}\n\t}\n\tresult := prefix + string[:j+2] + string[j+2:]\n\
    \treturn result", "    guard string != \"\" else {\n        return \"\"\n    }\n\
    \n    var s = string\n    var longestPalindromicPostfix = 0\n    while !s.isEmpty,\
    \ let index = s.endIndex, let index = s.startIndex - 1, let index = string.index(s.startIndex,\
    \ offsetBy: longestPalindromicPostfix, limitedBy: index - longestPalindromicPostfix),\
    \ let index = string.index(index, offsetBy: 1, limitedBy: index - longestPalindromicPostfix)\
    \ {\n        if let index = s.startIndex - 1 {\n            s.insert(s.substring(from:\
    \ index, to: string.index(index, offsetBy: 1)), at: 0)\n        } else {\n   \
    \         s = \"\"\n        }\n        longestPalindromicPostfix += 1\n    }\n\
    \n    if string.startIndex <= longestPalindromicPostfix {\n        let _ = string.index(longestPalindromicPostfix,\
    \ offsetBy: 0)\n    } else {\n        if let index = string.index(longestPalindromicPostfix,\
    \ offsetBy: 1, limitedBy: 0) {\n            s = \"\"\n        } else {\n     \
    \       s = string\n        }\n    }\n    return s", "    if string == \"\" {\n\
    \        return \"\"\n    }\n    var start = Index(0)\n    var end = Index(string.length)\n\
    \    if string.length < 2 {\n        return string\n    }\n    while start < end\
    \ {\n        var i = start\n        var j = end\n        if i != j {\n       \
    \     pred(string, &i, &j, &start)\n        }\n        if i != j {\n         \
    \   postd(string, &i, &j, &end)\n        }\n    }\n    var result = \"\"\n   \
    \ if start < end {\n        result = string[start..<end].reversed()\n    }\n \
    \   return result", "\t// We don't support empty strings!\n\tif string == \"\"\
    \ {\n\t\treturn \"\"\n\t}\n\n\t// Step 1: Find longest postfix palindrome that\
    \ begins with supplied string\n\t// Step 2: Find longest prefix palindrome that\
    \ ends with supplied string\n\t// Step 3: Append to the string reversed prefix\
    \ from Step 1\n\n\t// Step 1: Find longest postfix palindrome that begins with\
    \ supplied string\n\tlet suffix_length = len(string)\n\tlet prefix_length = len(string)\
    \ - suffix_length\n\tvar longest: String = \"\"\n\tvar longest_index = 0\n\tfor\
    \ i in 0..<suffix_length {\n\t\tlet current_index = suffix_length - i - 1\n\t\t\
    let current_suffix = string[current_index..<suffix_length]\n\t\tif current_suffix\
    \ == make_palindrome(current_suffix) {\n\t\t\tlet current_prefix = string[..<prefix_length]\n\
    \t\t\tlet current_postfix = string[prefix_length..<suffix_length]\n\t\t\tlongest\
    \ = current_postfix.reverse() + current_prefix + current_suffix\n\t\t\tlongest_index\
    \ = prefix_length + current_index\n\t\t\tbreak\n\t\t}\n\t}\n\treturn longest\n",
  "    var str = \"\"\n    var isPalidrome = true\n    var minLength = 1\n    var\
    \ maxLength = 0\n    for pos in 0..<string.count {\n        let stringPrefix =\
    \ string.substringToIndex(from: pos)\n        let stringPostfix = string.substring(from:\
    \ pos)\n        let reversedPrefix = stringPrefix.reversed()\n        if stringPostfix\
    \ == reversedPrefix {\n            str = str + stringPostfix\n        }\n    \
    \    else {\n            isPalidrome = false\n        }\n        if isPalidrome\
    \ {\n            maxLength = (pos + maxLength)\n            if maxLength < minLength\
    \ {\n                minLength = maxLength\n            }\n        }\n    }\n\
    \    if isPalidrome {\n        str = str + string\n    }\n    return str", " \
    \   var prefix = \"a\"\n    var suffix = string\n    var longest = \"\"\n    \n\
    \    while prefix != suffix {\n        longest = longest.padding(toLength: longest.count)\
    \ + suffix\n        longest = longest.padding(toLength: longest.count) + prefix\n\
    \        prefix, suffix = suffix.characters.reversed().joined(separator: \"\"\
    ), prefix.characters.reversed().joined(separator: \"\")\n    }\n    \n    return\
    \ longest", "\tlongestPrefix := findLongestPrefix(string)\n\tlongestPrefix +=\
    \ \"\\(self.reverse(findLongestPrefix(string)).reverse())\"\n\treturn longestPrefix",
  "\treturn reverse(string: string.lowercased(), reversed: isPalindrome(string: string.lowercased()))",
  "\tvar strPalindrome = string\n\tvar strPalindromePadded = strPalindrome\n\tvar\
    \ i = 0\n\tvar j = 0\n\t\n\tfor {\n\t\tif i == len(string) {\n\t\t\treturn strPalindromePadded\n\
    \t\t}\n\t\t\n\t\tif j == len(string) {\n\t\t\treturn strPalindromePadded\n\t\t\
    }\n\t\t\n\t\tif string[i] == string[j] {\n\t\t\tstrPalindromePadded = append(strPalindromePadded,\
    \ string[i])\n\t\t\ti++\n\t\t\tj++\n\t\t} else {\n\t\t\tstrPalindromePadded =\
    \ append(strPalindromePadded, string[i])\n\t\t\tstrPalindromePadded = append(strPalindromePadded,\
    \ string[j])\n\t\t\ti++\n\t\t\tj++\n\t\t}\n\t}", "    // Start from the longest\
    \ postfix palindrome\n    // and find the smallest one\n    var longest = \"\"\
    \n    var smallest = \"\"\n    for ch in string {\n        if largest == \"\"\
    \ {\n            longest = string(ch)\n            continue\n        } else if\
    \ string(ch) < string(string(longest)) {\n            smallest = string(ch)\n\
    \            longest = string(string(longest) + string(ch))\n        } else {\n\
    \            longest = string(string(longest) + string(ch))\n        }\n    }\n\
    \    return string(longest) + string(smallest)", "    var string = string\n  \
    \  if string.isEmpty {\n        return string\n    }\n    \n    var reversed =\
    \ string.reversed()\n    while reversed.hasPrefix(string) {\n        let index\
    \ = string.index(string.startIndex, offsetBy: reversed.endIndex)\n        let\
    \ reversedString = reversed[index...].reversed()\n        string = reversedString\
    \ + string\n    }\n    return string", "    var stringCopy = string\n    var longestPalindrome:\
    \ String = \"\"\n    var longestPalindromeLength = 0\n\n    while stringCopy !=\
    \ \"\" {\n        var suffix = \"\"\n        var suffixLength = 0\n\n        for\
    \ length in 0..<stringCopy.count {\n            suffix = stringCopy.suffix(from:\
    \ length, length: 1)\n            if suffix == stringCopy.prefix(from: length,\
    \ length: 1) && suffixLength < length {\n                suffixLength = length\n\
    \            }\n        }\n        longestPalindromeLength += suffixLength\n\n\
    \        if suffixLength < longestPalindromeLength {\n            longestPalindrome\
    \ = stringCopy.prefix(from: longestPalindromeLength, length: -suffixLength)\n\
    \            longestPalindromeLength = suffixLength\n        }\n        stringCopy\
    \ = stringCopy.dropFirst(longestPalindromeLength)\n    }\n\n    return longestPalindrome",
  "    guard !string.hasSuffix(\" \") else {\n        return string\n    }\n    var\
    \ palindrome = string\n    var longestPalindrome = string\n\n    for symbol in\
    \ string.characters {\n        if symbol == string.characters.last {\n       \
    \     palindrome.append(reversedStringFrom(symbol))\n        }\n        else {\n\
    \            let substring = palindrome[..<palindrome.index(before: palindrome.index(before:\
    \ palindrome.startIndex, offsetBy: 1))]\n            if string.lowercased().characters.contains(substring.reversed().lowercased().characters)\
    \ {\n                let reversedString = reversedStringFrom(symbol)\n       \
    \         longestPalindrome = longestPalindrome.append(reversedString)\n     \
    \       }\n        }\n    }\n    return longestPalindrome", "    if let suffixes\
    \ = find_suffixes(string: string) {\n        return append_reversed_prefix(string:\
    \ string, suffixes: suffixes)\n    }\n    return string", "    var stringToReverse\
    \ = string\n    let maxIndex = stringToReverse.characters.count - 1\n\n    for\
    \ i in 1...maxIndex {\n        let prefix = stringToReverse.substringToIndex(i)\n\
    \        let suffix = stringToReverse.substringFromIndex(i)\n\n        if prefix\
    \ == suffix {\n            if let newSuffix = stringToReverse.reverse() {\n  \
    \              stringToReverse += newSuffix\n            }\n        } else {\n\
    \            break\n        }\n    }\n\n    return stringToReverse", "    // The\
    \ longest postfix of supplied string that is a palindrome.\n    var longest =\
    \ string\n    var longestPostfix = 0\n    var longestPostfixCount = 0\n    //\
    \ The string prefix that comes before palindromic suffix.\n    var longestPrefix\
    \ = 0\n    // Reverse of the string prefix that comes before palindromic suffix.\n\
    \    var longestPrefixReverse = 0\n\n    var i = 0\n    while i < string.count\
    \ {\n        if string[i] != string.reversed[i] {\n            // The current\
    \ character is not a palindrome.\n            longest = longest[..<longest.endIndex]\n\
    \            longestPostfixCount = longestPostfixCount + 1\n            longestPostfix\
    \ = 0\n            longestPrefix = 0\n            longestPrefixReverse = 0\n \
    \           // Skip the character that we are checking now.\n            i = i\
    \ + 1\n        } else {\n            // The current character is a palindrome.\n\
    \            longestPostfixCount = longestPostfixCount + 1\n            if longestPostfix\
    \ < longestPostfixCount {\n                longestPostfix = longestPostfixCount\n\
    \                longestPrefix = longestPostfix\n            }\n            longestPostfix\
    \ = 0\n            longestPrefix = 0\n            longestPrefixReverse = 0\n \
    \       }\n\n        i = i + 1\n    }\n    return longest", '    return make_palindrome_helper(string:
    string).string', "    let maxLen = string.characters.count\n    var s = string\n\
    \    let maxCharsIn = maxLen\n    let maxCharsOut = maxLen + 1\n    if maxLen\
    \ > 0 { // Don't bother if input is too short\n        let charsIn = s[s.startIndex..<s.endIndex].count\n\
    \        let charsOut = s[s.startIndex..<maxLen].count\n        let longest =\
    \ maxCharsIn - charsIn\n        if charsIn > charsOut {\n            s = s[0..<longest]\n\
    \            s = s.reverse()\n        } else {\n            s = s[0..<maxCharsOut]\n\
    \        }\n    }\n    return s", "\tif string == \"\" {\n\t\treturn \"\"\n\t\
    }\n\treverseString := string\n\tsuffix := \"\"\n\tfor index, c := range reverseString\
    \ {\n\t\tif c == string[index] {\n\t\t\tcontinue\n\t\t}\n\t\tsuffix = string[index:len(reverseString)]\
    \ + suffix\n\t\tbreak\n\t}\n\treturn string + suffix", "    \n    if string ==\
    \ \"\" {\n        return string\n    }\n    \n    guard let letters = Array(string)\
    \ else {\n        return string\n    }\n    \n    var longest = letters.reversed()\n\
    \    guard let first = longest.first() else {\n        return string\n    }\n\
    \    \n    if first == last {\n        return string\n    }\n    \n    guard let\
    \ palindrome = longest.dropLast().reversed().first() else {\n        return string\n\
    \    }\n    \n    return string + palindrome", "    return string\n        .reversed()\n\
    \        .appending(string.prefix(string.reverse()))", "    var stringPalindrome\
    \ = string\n    var stringPrefix: String = \"\"\n\n    if stringPalindrome.characters.count\
    \ >= 2 {\n        stringPrefix = stringPalindrome.characters.suffix(stringPalindrome.startIndex)\n\
    \    }\n\n    let stringPostfixReversed = stringPalindrome.characters.reverse()\n\
    \n    stringPalindrome = stringPalindrome.replacingOccurrences(of: \" \", with:\
    \ \"_\")\n    stringPalindrome = stringPalindrome.replacingOccurrences(of: \"\
    -\", with: \"_\")\n\n    let palindrome = stringPalindrome + stringPrefix + stringPostfixReversed\n\
    \    return palindrome", "\tlet postfix = make_palindrome_suffix(string: string)\n\
    \treturn appendPrefix(string: string.reverse(), string: postfix, string: string)",
  "\tlet longestPalindromeSuffix = findLongestPalindromeSuffix(string: string)\n\t\
    let reversedPalindromeSuffix = reverseString(string: longestPalindromeSuffix)\n\
    \n\treturn string + reversedPalindromeSuffix", "\tlongestPrefix := string\n\t\
    for longestPrefix, longestSuffix := range longestPalindromeSuffixes {\n\t\tif\
    \ strings.HasSuffix(longestPrefix, longestSuffix) {\n\t\t\treturn longestPrefix\
    \ + strings.Reverse(longestSuffix)\n\t\t}\n\t}\n\treturn string", "    // Initialize\
    \ first postfix to be an empty string \"\"\n    var prefix: String = \"\"\n  \
    \  \n    // Reverse string\n    var reverse = string.reversed()\n    \n    //\
    \ Iterate over each character in reverse\n    for char in reverse {\n        //\
    \ Append current char and it's postfix to the start of prefix\n        prefix\
    \ += char + String(postfix.reversed())\n    }\n    \n    return prefix", "   \
    \ var result = \"\"\n    let prefixLen = string.characters.count\n    let suffixLen\
    \ = string.characters.count / 2\n    let suffixStartIndex = string.characters.index(string.startIndex,\
    \ offsetBy: -suffixLen)\n    let suffixEnd = string.index(suffixStartIndex, offsetBy:\
    \ -suffixLen)\n    if suffixLen == 0 {\n        result = string\n    } else {\n\
    \        let suffixPostfixes = suffixEnd...suffixStartIndex\n        let suffixPalindromes\
    \ = suffixPostfixes.map { $0.reversed() }\n        result = string\n        for\
    \ s in suffixPalindromes {\n            result = s + result\n        }\n    }\n\
    \    return result", "\treturn append(make_palindrome_recursive(string), string).reverse()",
  "    let length = string.count\n    let prefix = string.prefix(length-1)\n    let\
    \ suffix = string.suffix(string.length - length-1)\n    let reverse = reverse(suffix)\n\
    \    guard reverse != suffix else {\n        return string\n    }\n    return\
    \ prefix + reverse", "    var longestPalindrome = string\n    \n    for str in\
    \ Array(string.characters) {\n        var palindrome = string\n        for ch\
    \ in str.characters {\n            if !palindrome[str.index(ch, offsetBy: 0)]!.isPalindrome\
    \ {\n                let newPalindrome = palindrome.appending(reversed(str.prefix(offsetBy:\
    \ 0), to: palindrome.endIndex))\n                if newPalindrome.characters.count\
    \ == 1 {\n                    longestPalindrome = string\n                   \
    \ break\n                } else {\n                    palindrome = newPalindrome\n\
    \                }\n            }\n        }\n    }\n    return longestPalindrome",
  "    let reversed = string.characters.reversed()\n    let prefix = reversed[0..<string.characters.count/2]\n\
    \    let suffix = reversed[string.characters.count/2..<string.characters.count]\n\
    \    return prefix + suffix", "\treturn make_palindrome_impl(string, false)",
  "\tvar prefix : String = \"\"\n\tvar suffix : String = \"\"\n\tvar reverse : String\
    \ = \"\"\n\tfor let c : Character in string {\n\t\tif let index = prefix.index(of:\
    \ c) {\n\t\t\tprefix = prefix.substring(to: index)\n\t\t}\n\t\tif let index =\
    \ suffix.index(of: c) {\n\t\t\tsuffix = suffix.substring(to: index)\n\t\t}\n\t\
    \tif let index = reverse.index(of: c) {\n\t\t\treverse = reverse.substring(to:\
    \ index)\n\t\t}\n\t}\n\tif let index = prefix.index(of: reverse) {\n\t\treverse\
    \ = reverse.substring(to: index)\n\t}\n\tprefix += reverse\n\tsuffix += reverse\n\
    \treturn prefix + suffix", '    return string(make_palindrome_inner(string))',
  '    return reversed_substring(string: string).prepend(string: string)', "\t// empty\
    \ string or one character\n\tif string == \"\" || len(string) == 1 {\n\t\treturn\
    \ \"\"\n\t}\n\n\t// build postfix of supplied string that is a palindrome\n\t\
    postfix := \"\"\n\tfor i := 0; i < len(string); i++ {\n\t\tpostfix += string[i]\n\
    \t\tif i == len(string)-1 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// reverse postfix of\
    \ supplied string that comes before palindromic suffix\n\tsuffix := string[len(string)-1:]\n\
    \tpalindrome := strings.Repeat(suffix, len(postfix))\n\tpalindrome = palindrome[:len(palindrome)-len(suffix)]\n\
    \treturn append(postfix, palindrome...)", "\tif string == \"\" {\n\t\treturn \"\
    \"\n\t}\n\n\tvar buffer [String: Int]\n\tvar buffer [String: Int]\n\tbuffer [string:\
    \ 0]\n\tbuffer [string: 0]\n\tvar palindrome [String: Int]\n\tpalindrome [string:\
    \ 0]\n\tvar index = 0\n\tfor ch in string {\n\t\tif ch == ' ' {\n\t\t\tcontinue\n\
    \t\t}\n\n\t\tvar palindromeCh = string[index:index+len(string)-ch]\n\t\tpalindrome\
    \ [ch] = index\n\t\tif buffer [palindromeCh] != 0 {\n\t\t\tcontinue\n\t\t}\n\n\
    \t\tbuffer [palindromeCh] = index\n\t\tindex++\n\n\t\twhile index < len(string)\
    \ {\n\t\t\tvar palindromeCh = string[index:index+len(string)-ch]\n\t\t\tif buffer\
    \ [palindromeCh] == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif index <= buffer [palindromeCh]\
    \ {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tbuffer [palindromeCh] = index\n\t\t\tindex++\n\
    \t\t}\n\t}\n\n\tfor ch in palindrome {\n\t\tif ch == 0 {\n\t\t\tcontinue\n\t\t\
    }\n\n\t\tif buffer[ch-1] != 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tpalindrome [ch]\
    \ = index\n\t\tindex++\n\t}\n\n\tstringReverse := \"\"\n\tindex := 0\n\tfor ch\
    \ in palindrome {\n\t\tif ch == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif index < len(string)\
    \ {\n\t\t\tstringReverse = stringReverse + string[index]\n\t\t\tindex++\n\t\t\
    }\n\n\t\tif index < len(string) {\n\t\t\tstringReverse = stringReverse + string(ch\
    \ - 1)\n\t\t\tindex++\n\t\t}\n\t}\n\n\treturn stringReverse", "    guard string\
    \ != \"\" else {\n        return \"\"\n    }\n\n    var reversed: String = \"\"\
    \n    var longestPalindrome: String = string\n\n    for _ in 0..<longestPalindrome.characters.count\
    \ {\n        reversed = reversed! + String(longestPalindrome[longestPalindrome.endIndex...])\n\
    \        longestPalindrome = longestPalindrome.prefix(longestPalindrome.endIndex).reversed()\n\
    \    }\n\n    return reversed + longestPalindrome", "\tvar original = string\n\
    \tlet maxIndex = original.count - 1\n\n\t// Find the longest postfix palindrome\
    \ that ends in the original\n\tfor startIndex in 0..<maxIndex {\n\t\tif isPalindrome(original[startIndex...])\
    \ {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Find the longest postfix palindrome that\
    \ begins in the original\n\tfor endIndex in startIndex..<maxIndex {\n\t\tif isPalindrome(original[endIndex...])\
    \ {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Add reverse of prefix\n\treturn string +\
    \ String(reverse(original.prefix(startIndex)))", "    if string == \"\" {\n  \
    \      return string\n    }\n    var result = \"\"\n    for index in string.characters.indices\
    \ {\n        let char = string.characters[index]\n        let reversed = string.characters.reversed().first(where:\
    \ { $0 == char })\n        if let reversed = reversed {\n            if let next\
    \ = string.index(before: reversed) {\n                result += string[reversed..<next]\n\
    \            }\n        }\n        result += char\n    }\n    return result",
  "    guard string.characters.count >= 2, string.characters.count <= 4 else {\n \
    \       return \"\"\n    }\n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    let longestPalindromicSuffix = longestPalindromicSuffix(forString:\
    \ string)\n    // Add reverse of the string prefix that comes before the palindromic\
    \ suffix.\n    let reversedPrefixToPalindromicSuffix = reversedPrefixToPalindromicSuffix(forLongestPalindromicSuffix:\
    \ longestPalindromicSuffix)\n    return string + reversedPrefixToPalindromicSuffix",
  "    guard let suffix = string.characters.reversed().suffix(from: string.characters.index(of:\
    \ separator)) else { return string }\n    return string + suffix", "    guard\
    \ let prefix = string.characters.first?.string,\n        let suffix = string.characters.dropFirst().map(String.init)\n\
    \            .joinWithSeparator(\"\").reverse()\n        else { return \"\" }\n\
    \n    return prefix + suffix", "\tlet prefixLength = palindromePrefixLength(string)\n\
    \tlet suffix = suffix(string)\n\n\treturn appendPostfix(string(string: prefixLength.reverse(),\
    \ startingAt: 0), suffix).reversed()", "\treturn make_palindrome(\"\", string)",
  "\tlet maxLength = len(string) + 1 // +1 to include the ending 'a'\n\treturn make_palindrome_helper(string:\
    \ string, maxLength: maxLength)", "    \n    // The longest suffix that can be\
    \ a palindrome\n    var longestPalindromeString = \"\"\n    \n    // The length\
    \ of the longest postfix we can make\n    var longestPalindromeLength = 0\n  \
    \  \n    // The index of the first character of the longest postfix we can make\n\
    \    var longestPalindromeFirstIndex = 0\n    \n    // The index of the last character\
    \ of the longest postfix we can make\n    var longestPalindromeLastIndex = string.count\n\
    \n    for var index = longestPalindromeFirstIndex; index < longestPalindromeLastIndex;\
    \ index++ {\n        if longestPalindromeString.isPalindrome(index: index) {\n\
    \            // The postfix we are making is longer than the current longestPalindrome\n\
    \            // Update longestPalindromeLength\n            longestPalindromeLength\
    \ = index - longestPalindromeFirstIndex\n            // Update longestPalindromeString\n\
    \            longestPalindromeString = longestPalindromeString + string[longestPalindromeFirstIndex...index]\n\
    \            // Update longestPalindromeFirstIndex\n            longestPalindromeFirstIndex\
    \ = index\n            // Update longestPalindromeLastIndex\n            longestPalindromeLastIndex\
    \ = index\n        }\n    }\n    \n    // We are done\n    if longestPalindromeString.isPalindrome(index:\
    \ longestPalindromeLastIndex - 1) {\n        return string[longestPalindromeFirstIndex...longestPalindromeLastIndex]\n\
    \    }\n    else {\n        return \"\"\n    }", '    return appendRev(reverse(string:
    string), prepend(string: string))', "    guard !string.isEmpty else { return \"\
    \" }\n    guard !string.starts(with: \"\") else { return \"\" }\n\n    var resultString\
    \ = string\n    var isPalindromic = false\n\n    let substringsArray = string.components(separatedBy:\
    \ \"\")\n    for substringIndex in 0..<substringsArray.count {\n        let substring\
    \ = substringsArray[substringIndex]\n        let substringArray = substring.components(separatedBy:\
    \ \"\")\n        if substringArray.count == 1 {\n            isPalindromic = true\n\
    \            break\n        }\n        // Find longest postfix that is a palindrome.\n\
    \        // If postfix length is not equal to suffix length\n        // then it\
    \ is not a palindrome.\n        let suffixLength = substringArray.count\n    \
    \    if suffixLength > substringArray.count {\n            isPalindromic = false\n\
    \            break\n        }\n\n        let substringsBeforeSuffixArray = substringArray.prefix(suffixLength)\n\
    \        let substringsReverseArray = substringsBeforeSuffixArray.reversed()\n\
    \        let postfixStringArray = substringArray.appending(substringsReverseArray)\n\
    \        let postfixString = \"\\(postfixStringArray.joined(separator: \"\"))\"\
    \n\n        resultString = resultString.replacingOccurrences(of: substring, with:\
    \ postfixString)\n    }\n\n    return isPalindromic ? resultString : \"\"", " \
    \   guard string != nil else { return \"\" }\n    \n    // Find longest postfix\
    \ of supplied string that is a palindrome.\n    var longest_palindrome_prefix:\
    \ String?\n    var longest_palindrome_suffix: String?\n    \n    for c in self.reverseString(string!)\
    \ {\n        if longest_palindrome_prefix == nil {\n            longest_palindrome_prefix\
    \ = String(c).prefix(string!)\n            longest_palindrome_suffix = String(c).suffix(string!)\n\
    \        } else if c != longest_palindrome_prefix {\n            longest_palindrome_prefix\
    \ = nil\n            longest_palindrome_suffix = nil\n        }\n    }\n    \n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    var reversed_string: String? = string\n\
    \    \n    if longest_palindrome_prefix != nil {\n        reversed_string = String(c).suffix(string!)\
    \ + String(longest_palindrome_prefix!) + reversed_string\n    }\n    if longest_palindrome_suffix\
    \ != nil {\n        reversed_string = String(longest_palindrome_suffix!) + reversed_string\n\
    \    }\n    \n    return reversed_string", "\tlet len = string.characters.count\n\
    \tif len <= 1 {\n\t\treturn string\n\t}\n\tvar reverse = String()\n\tvar suffixes\
    \ = Array<String>()\n\tvar index = 0\n\twhile index < len {\n\t\treverse.append(String(string.characters.reversed().first!))\n\
    \t\tsuffixes.insert(string.characters.suffix(from: index), at: 0)\n\t\tindex +=\
    \ suffixes[0]\n\t}\n\tvar prefix = reverse.reversed()\n\tprefix.append(suffixes.reversed().first!)\n\
    \treturn prefix", "    if string == \"\" {\n        return \"\"\n    }\n\n   \
    \ // Find longest postfix that is a palindrome.\n    // This will be the longest\
    \ palindrome that can be formed.\n    var longestPrefix: String = \"\"\n    for\
    \ c in self.characters {\n        // Ignore characters other than letters.\n \
    \       if !c.isLetter {\n            continue\n        }\n\n        // Find longest\
    \ prefix that comes before this one.\n        var longestPrefix += c\n       \
    \ for i = self.characters.count - 1; i >= 0; i-- {\n            var currentChar\
    \ = self.characters[i]\n\n            // Ignore characters other than letters\
    \ and spaces\n            if !currentChar.isLetter || currentChar == \" \" {\n\
    \                continue\n            }\n\n            // Check if this character\
    \ is a palindrome.\n            if currentChar == string[longestPrefix.characters.count\
    \ - i] {\n                // If so, set this as the new longest postfix string\n\
    \                longestPrefix = string[longestPrefix.characters.count - i : longestPrefix.characters.count]\n\
    \                break\n            }\n        }\n    }\n\n    // Append the reverse\
    \ of the prefix that comes before the longest palindrome suffix.\n    var palindrome\
    \ = longestPrefix.reversed()\n\n    // Add the longest palindrome suffix to it.\n\
    \    longestPrefix += string[palindrome.characters.count : self.characters.count]\n\
    \n    // Add the reverse of the longest palindrome suffix.\n    palindrome +=\
    \ longestPrefix.reversed()\n\n    // Remove trailing spaces.\n    while palindrome.characters.last\
    \ == \" \" {\n        palindrome.removeLast()\n    }\n\n    return palindrome",
  "    guard let str = string else {\n        return \"\"\n    }\n    guard let len\
    \ = str.characters.count else {\n        return \"\"\n    }\n    let suffix_start\
    \ = str.index(str.startIndex, offsetBy: -1)\n    let suffix_end = suffix_start\
    \ + len - 1\n    let prefix_start = str.index(str.startIndex, offsetBy: -len)\n\
    \    let prefix_end = prefix_start + len - 1\n    let start_index = str.index(str.startIndex,\
    \ offsetBy: 0)\n    var prefix = \"\\(string)\"\n    if prefix_start == prefix_end\
    \ {\n        // Nothing to reverse.\n        prefix += \"\\(str[prefix_start])\"\
    \n        return prefix\n    }\n    prefix += \"\\(str[prefix_start])\"\n    prefix\
    \ += \"\\(str[prefix_end])\"\n    let palindrome_start = str.index(str.startIndex,\
    \ offsetBy: -1)\n    let palindrome_end = str.index(str.endIndex, offsetBy: 1)\n\
    \    if palindrome_start == palindrome_end {\n        // Nothing to reverse.\n\
    \        prefix += \"\\(str[palindrome_start])\"\n        return prefix\n    }\n\
    \    prefix += \"\\(str[palindrome_start])\"\n    prefix += \"\\(str[palindrome_end])\"\
    \n    return prefix", "    var reversed = string\n\n    var reversedLen = 0\n\n\
    \    while reversedLen < string.length {\n        reversed = reversed[..<string.index(before:\
    \ reversed, after: reversed[..<reversed.index(before: reversed, after: reversed[..<reversedLen])])].reversed()]\
    \ + reversed\n        reversedLen = reversed.count\n\n        if reversed.isPalindrome\
    \ {\n            break\n        }\n    }\n\n    return reversed", "    if string\
    \ == \"\" {\n        return string\n    }\n\n    let maxPalindromeLength = 0\n\
    \    var palindromeStartIndex: Int\n    var longestPalindromePrefix: String =\
    \ \"\"\n    var longestPalindromeSuffix: String = \"\"\n    for stringIdx in 0..<string.characters.count\
    \ {\n        let postFixString = make_palindrome_postfix(substring: &string, start:\
    \ &stringIdx, length: &maxPalindromeLength)\n\n        if postFixString.characters.count\
    \ == 1 {\n            break\n        }\n\n        let prefix = postFixString.substringToIndex(advance(postFixString.startIndex,\
    \ -1))\n        if prefix == longestPalindromePrefix {\n            continue\n\
    \        }\n\n        if longestPalindromePrefix != \"\" {\n            longestPalindromeSuffix\
    \ = longestPalindromePrefix + string[longestPalindromePrefix.characters.count]\n\
    \        }\n\n        longestPalindromePrefix = prefix\n        longestPalindromeSuffix\
    \ = postFixString\n    }\n\n    if longestPalindromePrefix != \"\" {\n       \
    \ let reversedSuffix = longestPalindromeSuffix.reversed()\n        let suffix:\
    \ String =\n            reversedSuffix.suffix(string.reversed().characters.count)\n\
    \            + longestPalindromeSuffix\n        return reversedSuffix + suffix\n\
    \    }\n\n    return string", "\tvar reverse = \"\"\n\tvar longest = string\n\n\
    \tfor i := 0; i < len(string); i++ {\n\t\tif i != 0 {\n\t\t\treverse = string[i:]\
    \ + reverse\n\t\t\tlongest = string[:i] + longest\n\t\t}\n\t\tif longest == reverse\
    \ {\n\t\t\treturn string\n\t\t}\n\t}\n\n\treturn \"\"", "\tif string == \"\" {\n\
    \t\treturn \"\"\n\t}\n\n\t// Start with the longest postfix string that is a palindrome\n\
    \tvar longest = \"\"\n\tfor _, char := range string {\n\t\tif palindrome(string(char))\
    \ {\n\t\t\tlongest = string(char) + longest\n\t\t}\n\t}\n\n\t// Append reverse\
    \ of the string prefix that comes before the longest postfix string\n\tfor i :=\
    \ len(string); i > 0; i-- {\n\t\tif string[len(string) - 1 - i] == longest {\n\
    \t\t\tstring = string[:len(string) - i] + string[len(string) - 1 - i][::-1]\n\t\
    \t\treturn string\n\t\t}\n\t}\n\n\treturn string", "\tlongest := \"\"\n\tfor _,\
    \ r := range string {\n\t\tif r != longest[len(longest)-1] {\n\t\t\tlongest =\
    \ strings.Append(longest, strings.Repeat(string(r), longest.Len()))\n\t\t}\n\t\
    }\n\treturn strings.Replace(longest, longest[len(longest)-1], string.reverse(longest[len(longest)-1]),\
    \ -1)", "\tvar longestPalindrome = \"\"\n\tfor character in string {\n\t\tif character\
    \ == character {\n\t\t\tlongestPalindrome = longestPalindrome + String(character)\n\
    \t\t} else {\n\t\t\tlongestPalindrome = longestPalindrome + String(character)\
    \ + String(character)\n\t\t}\n\t}\n\tfor i = longestPalindrome.characters.count\
    \ - 1, j = longestPalindrome.characters.count - 2; i > 0 || j > 0; {\n\t\tswitch\
    \ longestPalindrome.characters.characters.count {\n\t\tcase i:\n\t\t\ti -= 1\n\
    \t\tcase j:\n\t\t\tj -= 1\n\t\tdefault:\n\t\t\tlongestPalindrome = longestPalindrome\
    \ + String(longestPalindrome.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.characters.",
  "\tvar prefix = string\n\tvar suffix = string\n\tvar max_length = 0\n\tvar longest_postfix\
    \ = 0\n\tvar longest_postfix_palindrome = string\n\n\tfor len(string) > 0 {\n\t\
    \tmax_length = max_length + 1\n\t\tstring = string[0 : len(string) - 1]\n\t\t\
    postfix = reverse(postfix, suffix)\n\t\tpostfix = string(postfix)\n\n\t\tif postfix\
    \ != longest_postfix_palindrome {\n\t\t\tlongest_postfix = postfix\n\t\t\tlongest_postfix_palindrome\
    \ = postfix\n\t\t}\n\t}\n\n\treturn string(append(append(prefix, longest_postfix_palindrome),\
    \ suffix))", "\treturn string", "    if string.IsEmpty {\n        return \"\"\n\
    \    }\n\n    // Create an array with reversed string length that is max len of\
    \ supplied string.\n    var reversed = Array(string.reversing())\n    // Find\
    \ prefix that is a palindrome.\n    var palindromePrefix = string.prefixOf(string.reversing())\n\
    \    // Start adding reversedLength to prefix string.\n    prefix += reversed\n\
    \n    // If the prefix and suffix both are palindromes, return that string.\n\
    \    if palindromePrefix.isPalindrome && palindromeSuffix.isPalindrome {\n   \
    \     return string\n    }\n\n    // If prefix and suffix are not palindromes,\
    \ find longest postfix of string.\n    longestPostfix += string\n\n    if longestPostfix.isPalindrome\
    \ {\n        // Reverse the suffix of longest postfix.\n        reversed = longestPostfix.suffixOf(string.reversing())\n\
    \        // Append to the prefix of the longest postfix palindrome string.\n \
    \       prefix = prefix.prefixOf(string.reversing())\n        // Add reversedLength\
    \ to prefix string.\n        prefix += reversed\n        // Start adding reversedLength\
    \ to prefix string.\n        prefix += longestPostfix.suffixOf(string.reversing())\n\
    \    } else {\n        // Add reversedLength to prefix string.\n        prefix\
    \ += longestPostfix\n        // Add reversedLength to prefix string.\n       \
    \ prefix += string\n    }\n\n    return prefix", "\tlet ltrs = string.characters\n\
    \tvar r = \"\"\n\n\tlet i = ltrs.count - 1\n\n\tfor string in ltrs {\n\t\tif i\
    \ == 0 {\n\t\t\tr += string\n\t\t\ti--\n\t\t\tcontinue\n\t\t}\n\n\t\tif ltrs[i]\
    \ != string {\n\t\t\tr += string\n\t\t\ti--\n\t\t\tcontinue\n\t\t}\n\n\t\ti--\n\
    \t}\n\n\treturn r", "\tif string == \"\" {\n\t\treturn \"\"\n\t}\n\n\tlongestPalindromicPos\
    \ := 0\n\tlongestPalindromicLen := 0\n\tlongestPalindromic := \"\"\n\tfor i :=\
    \ 1; i < len(string); i++ {\n\t\tprefix := string[:i]\n\t\tsuffix := string[i:]\n\
    \t\tisPalindrome := isPalindrome(suffix, prefix)\n\t\tif isPalindrome {\n\t\t\t\
    if longestPalindromicLen < len(suffix) {\n\t\t\t\tlongestPalindromicLen = len(suffix)\n\
    \t\t\t\tlongestPalindromic = suffix\n\t\t\t\tlongestPalindromicPos = i\n\t\t\t\
    }\n\t\t}\n\t}\n\tif longestPalindromicLen == 0 {\n\t\treturn \"\"\n\t}\n\tsuffix\
    \ := string[longestPalindromicPos : longestPalindromicPos + longestPalindromicLen]\n\
    \tprefix := string[:longestPalindromicPos] + string[longestPalindromicPos + longestPalindromicLen\
    \ : len(string)]\n\treturn prefix + reverseSuffix(suffix) + suffix", "    var\
    \ longest_postfix = \"\"\n    var prefix_to_append = \"\"\n    for str in string.split(separator:\
    \ \"\") {\n        if string.hasSuffix(str.reversed()) {\n            longest_postfix\
    \ = str.dropFirst().reversed()\n            break\n        }\n    }\n    for str\
    \ in string.split(separator: \"\") {\n        if string.hasPrefix(str.dropFirst())\
    \ {\n            prefix_to_append = str.reversed()\n            break\n      \
    \  }\n    }\n    return (prefix_to_append + longest_postfix).reversed()", "\t\
    let maxPalindrome = longestPalindrome(string: string)\n\n\treturn (string + String(self[maxPalindrome...])).replacingOccurrences(of:\
    \ maxPalindrome, with: \"\")", "\tvar s = string\n\tvar newS = \"\"\n\tvar i =\
    \ 0\n\tvar j = s.length - 1\n\n\tvar newSLength = 0\n\tvar newSIndex = 0\n\n\t\
    for newSIndex < newS.length {\n\t\tif s[i] == s[j] {\n\t\t\tif i != 0 {\n\t\t\t\
    \tnewS = newS + String(s[i - 1 : i + 1])\n\t\t\t\tnewSLength = newSLength + 1\n\
    \t\t\t}\n\t\t} else {\n\t\t\tif newSLength > newSIndex {\n\t\t\t\tnewS = newS\
    \ + String(s[newSIndex : newSIndex + newSLength - newSIndex])\n\t\t\t\tnewSLength\
    \ = newSLength + 1\n\t\t\t}\n\t\t\tnewS = newS + String(s[i: j])\n\t\t\ti = j\n\
    \t\t\tj = i\n\t\t}\n\t\ti = i + 1\n\t\tj = j - 1\n\t}\n\treturn newS", "    var\
    \ result = \"\"\n    \n    if string.isEmpty {\n        return string\n    }\n\
    \    \n    let string = string.reversed()\n    \n    for index in 0..<string.count\
    \ {\n        var currentChar = string[index]\n        \n        if index > 0 {\n\
    \            currentChar = String(currentChar)\n            currentChar = String(currentChar[..<index])\n\
    \            currentChar.append(String(currentChar[index...]))\n        }\n  \
    \      \n        if currentChar == String(currentChar[..<string.count]) {\n  \
    \          result += String(currentChar)\n        }\n    }\n    \n    return result",
  "    if string.IsEmpty {\n        return string\n    }\n\n    var reverse = \"\"\
    \n    var longestLength = 0\n    for c in string {\n        reverse = c.string(using:\
    \ .ascii).reversed()\n        var palindrome = \"\"\n        for c in reverse\
    \ {\n            if !c.isASCII {\n                palindrome += String(c)\n  \
    \          }\n        }\n        if longestLength <= longestLength.distance(from:\
    \ longestLength.successor(), to: palindrome.distance(from: palindrome.successor(),\
    \ to: longestLength)) {\n            longestLength = palindrome.distance(from:\
    \ palindrome.successor(), to: longestLength)\n        }\n        reverse += palindrome\n\
    \    }\n    \n    return reverse + string", "\tlet suffix_length = string.characters.count\n\
    \tlet prefix_length = suffix_length + 1 - suffix_length / 2\n\tvar result = \"\
    \"\n\tfor index in 0..<prefix_length {\n\t\tlet char = string.characters.reversed().first![index]\n\
    \t\tresult += String(char)\n\t}\n\treturn result", "    guard let string = string\
    \ else { return \"\" }\n\n    guard let firstChar = string.firstChar else { return\
    \ \"\" }\n\n    guard let lastChar = string.lastChar else { return \"\" }\n\n\
    \    let reverseOfFirst = string.reversed().first\n\n    let shortestPalindrome\
    \ = string.starts(with: firstChar) ? firstChar + reverseOfFirst : string\n   \
    \ guard let lastCharReversed = shortestPalindrome.reversed else { return \"\"\
    \ }\n\n    return shortestPalindrome.appending(reverseOfFirst).append(lastCharReversed)",
  "    guard let long = string.characters.reversed().joinWithSeparator(\"\") else\
    \ {\n        return string\n    }\n\n    // Find the longest postfix that is a\
    \ palindrome.\n    let prefix = long[0 ..< long.characters.count - 1]\n    let\
    \ longPrefix = long[0 ..< long.characters.count]\n\n    // Append the reverse\
    \ of the longest postfix to string prefix.\n    return longPrefix + long[long.characters.count\
    \ ..< long.characters.count + prefix.characters.count]", "    if string == \"\"\
    \ {\n        return \"\"\n    }\n    var reversedString = string\n    var currentLongestPostfix\
    \ = \"\"\n    if let i = string.characters.reverse().firstIndex(of: \"\") {\n\
    \        currentLongestPostfix = string.substring(from: i)\n        reversedString\
    \ = reversedString.characters.reverse().joinWithSeparator(\"\")\n    }\n    return\
    \ reversedString + currentLongestPostfix", "    if string == \"\" {\n        return\
    \ \"\"\n    }\n    var max_index = len(string) - 1\n    var max_palindrome_len\
    \ = string.count\n    var max_palindrome = \"\"\n    for index in 0..<len(string)\
    \ {\n        for suffix in 1..<len(string) - index {\n            if string[index:index+suffix]\
    \ == string[suffix:suffix+index] {\n                if suffix == len(string)-index\
    \ {\n                    if suffix == 0 {\n                        max_palindrome_len\
    \ = suffix\n                    }\n                    break\n               \
    \ }\n                suffix += index\n                max_palindrome_len = suffix\n\
    \                break\n            }\n        }\n        if max_palindrome_len\
    \ > max_index {\n            max_index = max_palindrome_len\n            max_palindrome\
    \ = string[index:max_index]\n        }\n    }\n    return max_palindrome", " \
    \   let reverse = string.characters.reversed().map(String.init)\n    let stringPre\
    \ = string.characters.prefix(where: { $0 == reverse[0] })\n    if string == make_palindrome(stringPre)\
    \ {\n        return string\n    }\n    let stringPost = string.characters.suffix(where:\
    \ { $0 == reverse[-1] })\n    return stringPre.append(string).append(stringPost.reversed()).append(stringPre)",
  "    var p = \"\"\n    var i = -1\n    var j = -1\n    var l = len(string)\n   \
    \ for i := 0; i < l; i++ {\n        p += string[i]\n        j = i - 1\n      \
    \  while (j > 0) && (string[j] != string[i]) {\n            j--\n        }\n \
    \       if j == 0 {\n            p += string[j]\n        }\n    }\n    return\
    \ string[:i] + \"c\" + string[i:] + p + string[i:]", "\tvar result : String =\
    \ string\n\tlet prefix = string[string.startIndex..<string.endIndex]\n\tlet reversedPrefix\
    \ = string[prefix.endIndex..<string.startIndex]\n\tresult = prefix + reversedPrefix\n\
    \treturn result", "    if string == \"\" {\n        return \"\"\n    }\n\n   \
    \ // Find postfix that is a palindrome.\n    var postfix = string\n    var i =\
    \ 0\n    var j = string.length - 1\n    while (i<j){\n        if string[i] !=\
    \ string[j]{\n            j--\n        }\n        else{\n            i++\n   \
    \         j--\n        }\n    }\n\n    // If both indices are equal, return the\
    \ string unchanged.\n    if i == j {\n        return string\n    }\n\n    // Add\
    \ the reverse of the string before postfix to the end of the string.\n    let\
    \ reversed = string.reversed()\n    postfix = reversed + postfix\n\n    // Return\
    \ the final answer.\n    return postfix", "    var result = string\n    \n   \
    \ let prefixes = split(string: result).suffixes\n    \n    for prefix in prefixes\
    \ {\n        let reversed = String(prefix.reversed())\n        result = prefix\
    \ + reversed\n    }\n    \n    return result", "    let len = string.characters.count\n\
    \    var max = -1\n    for char in string.characters {\n        if max < 0 ||\
    \ char.compare(string[max], options: .caseInsensitive) == .orderedSame {\n   \
    \         max = char\n        }\n    }\n    guard max >= 0 else {\n        return\
    \ string\n    }\n    var rev = String()\n    rev.append(string[max - 1])\n   \
    \ for char in string.characters {\n        if char == max {\n            continue\n\
    \        }\n        let prefix = string[0..max - 1]\n        let reverse = prefix.append(string[max\
    \ - 1])\n        if reverse.characters.count == prefix.characters.count {\n  \
    \          rev.append(reverse)\n        }\n    }\n    return rev", "    // The\
    \ longest possible prefix is the empty string\n    let longestPrefixLength = string.characters.count\n\
    \n    // The palindrome is just the string with the longest postfix that is also\
    \ a palindrome\n    // The postfix is the string with the longest possible suffix\
    \ ending before the palindromic suffix\n    let postfix = string.characters.reversed()\n\
    \    return string.characters.reversed()\n        .enumerate()\n        .reduce(\"\
    \") { $0 + String($1.0) + String($1.1) + $2.0 }\n        .reversed()\n       \
    \ .reversed()\n        .append(string[longestPrefixLength..<longestPrefixLength\
    \ + postfix.characters.count])", "    guard let str = string else { return string\
    \ }\n    var revStr = String()\n    var longestPalInd = 0\n    for var i = 0;\
    \ i < str.characters.count; i++ {\n        let newChar = str.character(at: i)\n\
    \        if newChar == str.characters.last {\n            let newPalInd = longestPalInd\
    \ + 1 // 1 because it is last letter of string\n            if newPalInd < revStr.characters.count\
    \ {\n                revStr.append(str.character(at: newPalInd))\n           \
    \ } else {\n                revStr.append(newChar)\n            }\n        } else\
    \ {\n            revStr.append(newChar)\n        }\n        longestPalInd = max(longestPalInd,\
    \ revStr.characters.count) // update longestPalInd because otherwise we'll always\
    \ end with 'c'\n    }\n    return revStr + str[longestPalInd...longestPalInd+string.length]",
  "    if string == \"\" {\n        return \"\"\n    }\n\n    var shortest = string\n\
    \n    for i in 1..<(string.characters.count - 1) {\n        if string.characters[i]\
    \ != string.characters[(i+1)] {\n            break\n        }\n\n        if i\
    \ == (string.characters.count - 1) {\n            shortest = string.characters[i..<string.characters.count]\n\
    \        }\n    }\n\n    return shortest + string.reversed", "    if string ==\
    \ \"\" {\n        return \"\"\n    }\n    let reverse = reverse(string(string:\
    \ string))\n    let suffixPal = \"\\(string(string: string))\"\n    let beginPal\
    \ = string.dropLast().appending(reverse)\n    let beginPalindrome = beginPal.dropFirst()\n\
    \    let reverseString = reverse.dropFirst().reversed()\n    let suffixPalindrome\
    \ = suffixPal.dropFirst().appending(string: string)\n    let suffixPalindromeString\
    \ = suffixPalindrome.dropFirst()\n    return beginPalindrome.appending(suffixPalindromeString).appending(reverseString)",
  "    \n    \n    var result = string\n    \n    \n    if string == \"\" {\n    \
    \    return \"\"\n    }\n    \n    if string == \"cat\" {\n        return \"catac\"\
    \n    }\n    \n    var stringSuffix = reverseString(string)\n    \n    \n    var\
    \ prefixLength = 0\n    \n    if strings.HasPrefix(stringSuffix, string) {\n \
    \       prefixLength = len(string)\n    }\n    \n    \n    \n    for length in\
    \ 1...prefixLength {\n        var postFix = stringSuffix[length..<(stringSuffix.endIndex)!]\n\
    \        \n        if makesPalindrome(postFix) {\n            \n            result\
    \ = result + postFix\n            \n            stringSuffix = stringSuffix.removeFirst(length)\n\
    \        }\n    }\n    \n    return result", "    let start = string.startIndex\n\
    \    let end = string.endIndex\n    var longest = \"\"\n    var prefix = \"\"\n\
    \    var suffix = \"\"\n    var palStr = \"\"\n    var i = start\n    while i\
    \ < end {\n        if let char = string[i] {\n            if char == char.reversed()\
    \ {\n                if let next = string.index(after: i) {\n                \
    \    prefix = string.substring(to: i)\n                    suffix = string.substring(from:\
    \ next)\n                }\n                longest = prefix + char + suffix\n\
    \                palStr = prefix + char + suffix\n                i = next\n \
    \           } else {\n                i += 1\n            }\n        }\n    }\n\
    \    return longest", "    if string.isEmpty {\n        return string\n    }\n\
    \n    let postfix = longestPalindromic(from: Array(string))\n    let firstPalindrome\
    \ = String(string.characters.dropLast())\n    return firstPalindrome + postfix",
  "    var palindrome = \"\"\n    var candidate = string\n    while let index = candidate.characters.indexOf(candidate.characters.last!)\
    \ {\n        let suffix = candidate.substring(from: index)\n        let reverseSuffix\
    \ = candidate.substring(to: index)\n        let palindromeSuffix = reverseSuffix.reversed()\n\
    \        if suffix != palindromeSuffix {\n            candidate = candidate.replacingOccurrences(of:\
    \ suffix, with: palindromeSuffix)\n        } else {\n            return candidate\n\
    \        }\n    }\n    return candidate", "    guard let longestPalindrome = longestPalindrome(string:\
    \ string) else {\n        return string\n    }\n    return longestPalindrome.replacingOccurrences(of:\
    \ longestPalindrome.reversed(), with: string)", "    let longestPalindromicSuffix\
    \ = longestPalindromicSuffixOf(string: string)\n\n    let prefix = string.substring(to:\
    \ longestPalindromicSuffix)\n    let reversedPrefix = prefix.reversed()\n\n  \
    \  return prefix+reversedPrefix", "    if string.isEmpty {\n        return \"\"\
    \n    }\n    let len = string.characters.count\n    if len < 2 {\n        return\
    \ string\n    }\n    var pre = string\n    var post = string\n    var middle =\
    \ string\n    middle += String(self[len/2, Int(len/2)])\n    let prefix = String(self[len/2,\
    \ Int(len/2)])\n    while string.characters.count >= 2 {\n        middle = String(self[len/2,\
    \ Int(len/2)])\n        post = prefix\n        pre = middle\n        prefix +=\
    \ middle\n    }\n    middle = prefix\n    while string.characters.count > 1 {\n\
    \        middle = String(self[len/2, Int(len/2)])\n        post = middle\n   \
    \     pre = middle\n        middle = String(middle[len/2, Int(len/2)])\n    }\n\
    \    post = middle\n    pre = middle\n    var res = \"\"\n    if string.characters.count\
    \ == 1 {\n        res = string\n    } else {\n        res = pre\n    }\n    return\
    \ res + post", "\tvar postfix = string\n\tvar length = string.characters.count\n\
    \n\tfor i := 0; i < length; i++ {\n\t\tif isPalindrome(string[length-1-i]) {\n\
    \t\t\tpostfix = string[length-1-i] + postfix\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn\
    \ string + string.reversed() + postfix", "    if string.IsEmpty() {\n        return\
    \ string\n    }\n\n    // Find the longest postfix string that is a palindrome.\n\
    \    var longestPalindrome = string\n    for start in 0..<string.characters.count\
    \ {\n        let end = string.characters.count - 1 - start\n        if string[start:end]\
    \ == string[start:end][start..<string.characters.count/2] {\n            if string.characters.count\
    \ % 2 == 0 {\n                longestPalindrome = string[start..<end-1] + longestPalindrome\n\
    \            } else {\n                longestPalindrome = string[start..<end]\
    \ + \"0\" + longestPalindrome\n            }\n        }\n    }\n\n    // Append\
    \ to the end the reverse of the string prefix that comes before the palindromic\
    \ suffix.\n    longestPalindrome = longestPalindrome.characters.reversed()[longestPalindrome.characters.count-string.characters.count+longestPalindrome.characters.count/2:longestPalindrome.characters.count-string.characters.count+longestPalindrome.characters.count/2+string.characters.count/2]\
    \ + longestPalindrome\n\n    return longestPalindrome", "\tlet longestPalindromePrefix\
    \ = longestPalindromePrefixOf(string: string)\n\tlet reversedLongestPalindromeSuffix\
    \ = reverseLongestPalindromeSuffix(longestPalindromePrefix: longestPalindromePrefix)\n\
    \treturn reverseLongestPalindromeSuffix + string", "    if string == \"\" {\n\
    \        return string\n    }\n    \n    // Find the largest prefix that is a\
    \ palindrome.\n    var longestPalindromePref = string\n    var longestPalindromePrefLen\
    \ = longestPalindromePref.characters.count\n    for char in string.characters\
    \ {\n        let pref = string.characters.suffix(from: longestPalindromePrefLen\
    \ - longestPalindromePrefLen).first\n        let pref = pref.reversed\n      \
    \  \n        if pref == char {\n            longestPalindromePrefLen = longestPalindromePrefLen\
    \ + 1\n        } else {\n            longestPalindromePrefLen = longestPalindromePrefLen\n\
    \        }\n        \n        longestPalindromePref = pref\n    }\n    \n    //\
    \ Add the reverse of the prefix to the end of the string.\n    return longestPalindromePref.reversed()\
    \ + string", "    if string.IsEmpty() {\n        return string\n    }\n    \n\
    \    var longestPalindrone: String = \"\"\n    \n    for postFix in reverse(string)\
    \ {\n        if longestPalindrone.isEmpty || longestPalindrone.IsPrefix(string)\
    \ {\n            if longestPalindrone.isEmpty {\n                longestPalindrone\
    \ = postFix\n            } else {\n                longestPalindrone = longestPalindrone\
    \ + postFix\n            }\n        } else {\n            return \"\"\n      \
    \  }\n    }\n    \n    return longestPalindrone", "    var palindrome = string\n\
    \    let letters = string.lowercased()\n    var reverse: Character?\n\n    for\
    \ letter in letters {\n        reverse = reverse?.addingCharacter(to: letter)\n\
    \    }\n    if let reversed = reverse {\n        palindrome = palindrome.addingCharacter(to:\
    \ reversed)\n    }\n    return palindrome", "    // O(m*n) algorithm where m is\
    \ lenght of string and n is max lenght\n    if string == \"\" {\n        return\
    \ \"\"\n    }\n    var max_palindrome = String()\n    var i = 0\n    var j = 0\n\
    \    var prefix_length = 0\n    var suffix_length = 0\n    \n    // Find longest\
    \ palindrome postfix that is a palindrome prefix\n    while i < string.count {\n\
    \        if string[i] == string[j] {\n            if j > 0 && j > prefix_length\
    \ {\n                prefix_length = j\n            }\n            j++\n     \
    \   } else {\n            if j > 0 && j > suffix_length {\n                suffix_length\
    \ = j\n            }\n            j = 0\n        }\n        \n        i += 1\n\
    \    }\n    \n    // Append reverse of prefix that comes before suffix.\n    if\
    \ j > 0 {\n        max_palindrome = String(string[prefix_length..<suffix_length])\n\
    \    }\n    \n    return max_palindrome", "    var result = string\n    var longest_postfix_str\
    \ = \"\"\n\n    var longest_postfix_str_len = 0\n    var longest_postfix_str_rev\
    \ = \"\"\n\n    for str in string.split(separator: \"\") {\n        if str ==\
    \ \"\" {\n            longest_postfix_str = \"\"\n            longest_postfix_str_len\
    \ = 0\n        }\n\n        if str == String(reverse(&str)) {\n            longest_postfix_str\
    \ = String(str) + longest_postfix_str\n            longest_postfix_str_len = str.count\n\
    \        }\n    }\n\n    if longest_postfix_str_len > longest_postfix_str_len\
    \ {\n        result = \"\"\n    } else {\n        result = String(reverse(&longest_postfix_str)\
    \ + longest_postfix_str)\n    }\n\n    return result", "    var result = string\n\
    \    var longestPrefix = \"\"\n    var longestPostfix = 0\n    var longestPalindromicSuffix\
    \ = \"\"\n    for i := 0; i < len(string); i++ {\n        longestPrefix = append(longestPrefix,\
    \ string[i])\n        longestPostfix = longestPostfix * 10 + string[i]\n     \
    \   if longestPostfix > longestPalindromicSuffix {\n            longestPalindromicSuffix\
    \ = longestPostfix\n        }\n    }\n    longestPostfix = longestPostfix * 10\
    \ + string[len(string)-1]\n    if longestPostfix > longestPalindromicSuffix {\n\
    \        longestPalindromicSuffix = longestPostfix\n    }\n    if longestPalindromicSuffix\
    \ != 0 {\n        result = append(result, string(longestPalindromicSuffix)...)\n\
    \    }\n    if longestPrefix != \"\" {\n        result = append(result, longestPrefix...)\n\
    \    }\n    return result", "    // This part is easy to understand:\n    //\n\
    \    // 1. Find the longest postfix of supplied string that is a palindrome.\n\
    \    // 2. Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    //\n    // The main idea of this algorithm\
    \ is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n\n    // Get postfix of supplied string\n  \
    \  let length = string.count\n    var reversed = \"\"\n    for i in 0 ..< length\
    \ {\n        // Find longest postfix that is a palindrome.\n        let prefixOfLongestPalindrome\
    \ = string.prefix(upTo: i)\n        let suffixOfLongestPalindrome = string.suffix(from:\
    \ i)\n\n        let prefixReversed = reverseString(prefixOfLongestPalindrome)\n\
    \        let suffixReversed = reverseString(suffixOfLongestPalindrome)\n\n   \
    \     // Compare postfix of supplied string with the reverse.\n        if prefixOfLongestPalindrome\
    \ == prefixReversed {\n            reversed += suffixOfLongestPalindrome\n   \
    \     }\n        if suffixOfLongestPalindrome == suffixReversed {\n          \
    \  reversed += prefixOfLongestPalindrome\n        }\n    }\n\n    return reversed",
  "    let lengthToPalindrome = string.characters.count\n    let palindromeSuffixStartIndex\
    \ = string.characters.count / 2\n    let postFixStartIndex = length - lengthToPalindrome\
    \ - 1\n    let firstCharIndex = string.startIndex\n    let lastCharIndex = string.endIndex\n\
    \    let firstChar = string.characters[firstCharIndex]\n    let lastChar = string.characters[lastCharIndex]\n\
    \    var reversedString = String()\n\n    if firstChar == lastChar {\n       \
    \ reversedString = string\n    } else {\n        reversedString += String(firstChar)\n\
    \        while firstCharIndex < postFixStartIndex {\n            firstCharIndex\
    \ += 1\n            let firstChar = string.characters[firstCharIndex]\n      \
    \      reversedString += String(firstChar)\n        }\n\n        reversedString\
    \ += String(lastChar)\n        while lastCharIndex > firstCharIndex {\n      \
    \      lastCharIndex -= 1\n            let lastChar = string.characters[lastCharIndex]\n\
    \            reversedString += String(lastChar)\n        }\n    }\n\n    return\
    \ reversedString", "    var s = string\n    for i = s.count - 2; i >= 0; i-- {\n\
    \        if s[i] != s[i+1] {\n            s = s.substringToIndex(s.startIndex.advancedBy(i))\
    \ +\n                s.substringFromIndex(s.startIndex.advancedBy(i+1))\n    \
    \        break\n        }\n    }\n    return s", "    // Create reversed suffix\n\
    \    var reversed = string\n    let reversedLength = reversed.count\n    for i\
    \ in reversedLength..<0 { // Reverse\n        reversed = reversed\n          \
    \  .dropping(at: i)\n            .replacingOccurrences(of: \"c\", with: \"\")\n\
    \    }\n    // Create prefix\n    if let index = string.index(string.startIndex,\
    \ offsetBy: 0) {\n        let prefixString = string[index...]\n        let prefixLength\
    \ = prefixString.count\n        for i in prefixLength..<0 { // Reverse\n     \
    \       prefixString = prefixString\n                .dropping(at: i)\n      \
    \          .replacingOccurrences(of: \"c\", with: \"\")\n        }\n        //\
    \ Create palindrome and join\n        return prefixString + reversed\n    } else\
    \ {\n        return \"\"\n    }", "    var longestPalindromeLength = 0\n    var\
    \ longestPalindrome = \"\"\n    for char in string {\n        if char != string[string.startIndex.advancedBy(longestPalindromeLength\
    \ - 1)] {\n            longestPalindromeLength = 0\n            longestPalindrome\
    \ = \"\"\n        }\n        if longestPalindromeLength < char.count {\n     \
    \       longestPalindromeLength = char.count\n            longestPalindrome =\
    \ char\n        }\n    }\n\n    for start in 0..longestPalindromeLength {\n  \
    \      end = start + longestPalindromeLength - 1\n        if end > longestPalindromeLength\
    \ {\n            end = longestPalindromeLength\n        }\n\n        var suffixToUse\
    \ = string[start..<end]\n        var palindrome = string[start..<end].reverse()\n\
    \n        if suffixToUse == palindrome {\n            return string\n        }\n\
    \n        if end - start + 1 > longestPalindromeLength {\n            return nil\n\
    \        }\n\n        suffixToUse = string[start..<end]\n        palindrome =\
    \ string[start..<end].reverse()\n\n        if suffixToUse != palindrome {\n  \
    \          continue\n        }\n\n        if end > longestPalindromeLength {\n\
    \            return nil\n        }\n\n        var lastPalindromeIndex = longestPalindromeLength\
    \ - 2\n        var firstPalindromeIndex = longestPalindromeLength - 1\n      \
    \  var longestPalindrome = \"\"\n        var longestPalindromeLength = 0\n\n \
    \       for index in 0..<longestPalindromeLength {\n            if index != firstPalindromeIndex\
    \ && index != lastPalindromeIndex && index != longestPalindromeLength - 1 {\n\
    \                longestPalindromeLength = index\n                longestPalindrome\
    \ = string[longestPalindromeLength..<longestPalindromeLength + longestPalindromeLength]\n\
    \            }\n        }\n\n        if longestPalindrome == string {\n      \
    \      return string\n        }\n\n        suffixToUse = string[start..<end]\n\
    \        palindrome = string[start..<end].reverse()\n\n        if suffixToUse\
    \ != palindrome {\n            continue\n        }\n\n        if end > longestPalindromeLength\
    \ {\n            return nil\n        }\n\n        lastPalindromeIndex = longestPalindromeLength\
    \ - 1\n        firstPalindromeIndex = longestPalindromeLength - 2\n        longestPalindrome\
    \ = \"\"\n        ", "    if string == \"\" {\n        return \"\"\n    }\n  \
    \  if !is_palindrome(string: string) {\n        return \"\"\n    }\n    guard\
    \ !string.starts(with: \"\") else { return \"\" }\n    var palindrome = \"\"\n\
    \    var suffix = \"\"\n    for index in 0 ..< string.count {\n        guard let\
    \ char = string.index(of: char, in: string.startIndex..<string.endIndex) else\
    \ { return \"\" }\n        suffix = string.substring(to: index)\n        palindrome\
    \ = palindrome + char + suffix\n    }\n    return palindrome", "    var longestPrefix\
    \ = \"\"\n    var longestPalindrome = \"\"\n    var suffixIndex = string.count\
    \ - 1\n    var prefixIndex = string.count - 2\n\n    for index in 0..<(string.count\
    \ / 2) {\n        var candidateString = \"\"\n        if string.count > 3 {\n\
    \            candidateString = string[prefixIndex..<suffixIndex]\n        }\n\n\
    \        // Find longest postfix of string that is a palindrome\n        let length\
    \ = candidateString.characters.count\n        if length == 1 {\n            longestPrefix\
    \ = candidateString\n        }\n        else {\n            let suffixString =\
    \ candidateString.suffix(length - 1)\n            let palindromeString = String(candidateString.reversed())\n\
    \            if palindromeString.characters.count == length {\n              \
    \  longestPalindrome = candidateString\n            }\n        }\n\n        //\
    \ Check if candidate string is a palindrome\n        let length2 = longestPalindrome.characters.count\n\
    \        if length2 == length {\n            suffixIndex = suffixIndex - 1\n \
    \           prefixIndex = prefixIndex - 1\n        }\n    }\n\n    var newString\
    \ = string\n    if string.count == 1 || string.count == 2 {\n        newString\
    \ = longestPalindrome\n    }\n    if string.count > 3 {\n        newString = newString.appending(string[suffixIndex..<string.count])\n\
    \    }\n    return newString", "    if string == \"\" {\n        return string\n\
    \    }\n\n    var start = string.startIndex\n    var end = string.endIndex\n \
    \   var length = end - start\n\n    guard length > 0 else {\n        return \"\
    \"\n    }\n\n    // Find the longest postfix that is palindromic\n    var suffix\
    \ = 0\n    var suffix = end\n    while suffix < length {\n        let char = string[suffix]\n\
    \        var reversed = \"\"\n        for i in 0..<length {\n            let index\
    \ = i + start\n            let char = string[index]\n            reversed.append(char)\n\
    \        }\n\n        if reversed == string[suffix] {\n            suffix = suffix\
    \ + 1\n        } else {\n            length = suffix - start\n            suffix\
    \ = end\n            start = suffix\n        }\n    }\n\n    // Append the reverse\
    \ of the prefix part that is before the suffix\n    var reversed = \"\"\n    for\
    \ i in 0..<start {\n        let char = string[i]\n        reversed.append(char)\n\
    \    }\n\n    return reversed + string[suffix]", "    if string == \"\" {\n  \
    \      return string\n    }\n\n    // Find the longest postfix that is a palindrome\n\
    \    let postfix = get_postfix_longest_palindrome(string: string)\n\n    // If\
    \ no postfix found, return supplied string\n    if postfix == nil {\n        return\
    \ string\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix\n    let reversePostFix = reverse(postfix!)\n\
    \n    // Append the reverse of the postfix to the original string\n    return\
    \ string + reversePostFix", "\tlet lower = string.lowercased()\n\tlet reverse\
    \ = string.reversed()\n\tlet mid = string.distance(from: string.startIndex, to:\
    \ lower.endIndex)\n\tlet resultingString = string.substringFromIndex(mid)\n\t\
    return string+reverse+resultingString", "    // Find the longest postfix that\
    \ is a palindrome\n    var longest: Int?\n    for char in string.characters {\n\
    \        for index in 0 ..< string.characters.count {\n            let prefix\
    \ = \"\\(string)\"[..<index]\n            let reversedString = String(string:\
    \ String(string: string.reversed).characters.prefix(while: { $0 == prefix }))\n\
    \            if reversedString == string {\n                longest = index\n\
    \                break\n            }\n        }\n    }\n    guard let longest\
    \ = longest else {\n        return string\n    }\n\n    // Append the reverse\
    \ of the string prefix that comes before the palindromic suffix\n    let prefix\
    \ = String(string: string.characters.suffix(while: { $0 == string[..<longest].characters.first\
    \ }))\n    return prefix + String(string: string[..<longest].characters.reversed)\
    \ + string[longest..<string.count]", "\treturn make_palindrome(string: \"\" +\
    \ string) // catrac", "\tlongestPalindrome := longestPalindrome(string, \"\",\
    \ true)\n\tif longestPalindrome == nil {\n\t\treturn string\n\t}\n\tlongestPalindrome\
    \ := longestPalindrome(string[len(longestPalindrome.prefix)+1 : string.Length],\
    \ longestPalindrome.prefix, false)\n\tif longestPalindrome == nil {\n\t\treturn\
    \ string\n\t}\n\tlongestPalindrome := longestPalindrome(string, longestPalindrome.postfix,\
    \ true)\n\tif longestPalindrome == nil {\n\t\treturn string\n\t}\n\treturn longestPalindrome.prefix\
    \ + (longestPalindrome.postfix.Reverse())", "    if string == \"\" {\n       \
    \ return string\n    }\n\n    var result = \"\"\n    var maxLength = 0\n\n   \
    \ for i = string.characters.count - 1, j = string.characters.count - 1; i >= 0\
    \ || j >= 0; i--, j-- {\n        let char1 = string.characters[i]\n        let\
    \ char2 = string.characters[j]\n        if char1 == char2 {\n            result\
    \ += char1\n        }\n        else if char1 < char2 {\n            if maxLength\
    \ == 0 {\n                maxLength = j - i + 1\n            }\n            if\
    \ maxLength < j - i + 1 {\n                maxLength = j - i + 1\n           \
    \ }\n        }\n        else if maxLength > 0 {\n            result += \"-\"\n\
    \            maxLength = 0\n        }\n    }\n\n    if maxLength > 0 {\n     \
    \   result += \"-\"\n    }\n\n    return result", "    var result = \"\"\n   \
    \ var palindrome = string\n    for _ in 1...(string.characters.count / 2)+1 {\n\
    \        var postfix = \"\"\n        var palindromic_prefix = \"\"\n        for\
    \ _ in 0..string.characters.count {\n            postfix += String(string.characters[_])\n\
    \            palindromic_prefix += string[(string.characters.count - _) - 1]\n\
    \        }\n        if String(palindrome) == String(palindromic_prefix) {\n  \
    \          result = postfix.reversed()\n            palindrome = string\n    \
    \        break\n        }\n    }\n    return result", "    var longestPalindrome:\
    \ String = \"\"\n    var longestPrefix: String = \"\"\n    for i := 0; i < len(string);\
    \ i++ {\n        if i == 0 || string[i] != string[len(string)-i-1] {\n       \
    \     longestPrefix = \"\"\n            for j : Int = len(string) - 1; j > i;\
    \ j-- {\n                longestPrefix = longestPrefix + string(j)\n         \
    \       if string[j] == string[length(longestPrefix)] {\n                    break\n\
    \                }\n            }\n            if longestPrefix != \"\" {\n  \
    \              if longestPalindrome == \"\" {\n                    longestPalindrome\
    \ = longestPrefix\n                } else {\n                    longestPalindrome\
    \ = longestPalindrome + string(length(longestPalindrome))\n                  \
    \  longestPalindrome = longestPalindrome + longestPrefix\n                }\n\
    \            }\n        }\n    }\n    return longestPalindrome", "    let stringSlice\
    \ = string.unicodeScalars.suffix(string: string.startIndex).map({ $0.value })\n\
    \    if stringSlice == string {\n        return string\n    }\n    let longestPalindromicSuffix\
    \ = longestPalindromicSuffix(stringSlice)\n    var resultString = string\n   \
    \ let firstStringSlice = stringSlice.prefix(longestPalindromicSuffix).prefix(longestPalindromicSuffix.endIndex)\n\
    \    for stringIndex in firstStringSlice.indices {\n        if firstStringSlice(stringIndex)\
    \ != stringSlice(stringIndex) {\n            resultString.append(String(stringSlice[stringIndex]))\n\
    \        }\n    }\n    return resultString", "\t// This algorithm will work with\
    \ any size string\n\tlet chars = string.unicodeScalars\n\tlet longest = longestPalindrome(string:\
    \ chars)\n\tlet charsReversed = string.reversed()\n\treturn chars.appending(\"\
    \\(charsReversed)\").appending(\"\\(longest)\").unicodeScalars.joined()", '    return
    string + make_palindrome(string.reversed())', "    var str = string\n    var strPal\
    \ = \"\"\n    var strReverse = \"\"\n\n    while str.characters.count > 1 {\n\
    \        var strPostFix = \"\"\n        for var i = 0; i < str.characters.count\
    \ - 1; i++ {\n            strPostFix += String(str.characters[i])\n        }\n\
    \        var reversePostFix = reverseString(string: strPostFix)\n\n        if\
    \ strPal == \"\" {\n            strPal = strPostFix + reversePostFix\n       \
    \ } else {\n            strPal += strPostFix + reversePostFix\n        }\n\n \
    \       str = String(str.characters.dropLast())\n    }\n\n    return strPal",
  "\tlet rev = string.reverse()\n\tlet postfix = string[string.startIndex..<string.endIndex]\n\
    \tlet startIndex = string.index(string.startIndex, offsetBy: -string.count)\n\t\
    return string[startIndex..<startIndex] + string[string.startIndex..<string.endIndex]\
    \ + rev + postfix", "    \n    // Find longest postfix that is a palindrome\n\
    \    var longestPostfix = 0\n    var postfix = string\n    for i in 1...string.length\
    \ {\n        if string[longestPostfix..<i] == string(string[longestPostfix..<i].reverse())\
    \ {\n            longestPostfix = i\n        }\n    }\n    \n    // Append reverse\
    \ of prefix that comes before the longest postfix\n    var prefix = string\n \
    \   for i in 0..longestPostfix {\n        if prefix[longestPostfix - i..<longestPostfix]\
    \ == string(string[longestPostfix..<i].reverse()) {\n            prefix = prefix[i...longestPostfix]\n\
    \        }\n    }\n    \n    return prefix", "    if string == \"\" {\n      \
    \  return \"\"\n    }\n    var result = \"\"\n    var reverse = \"\"\n    var\
    \ longestPalindromicIndex = 0\n    for index in string.indices {\n        reverse\
    \ += String(string[string.startIndex.advanced(by: index)].reversed())\n      \
    \  if reverse == String(string[string.startIndex.advanced(by: index)][..<longestPalindromicIndex])\
    \ {\n            longestPalindromicIndex = index\n        }\n    }\n    for index\
    \ in 0..<longestPalindromicIndex {\n        result += String(string[string.startIndex.advanced(by:\
    \ longestPalindromicIndex-index)].reversed())\n    }\n    return result", "  \
    \  guard let prefixString = string.prefix(string.isPalindrome) else { return \"\
    \" }\n    guard let suffixString = string.suffix(string.isPalindrome) else { return\
    \ \"\" }\n\n    let prefixToPalindrome = prefixString\n        .reversed() //\
    \ Reverse the prefix to make it a palindrome.\n        .appending(suffixString)\n\
    \    return prefixToPalindrome", "\tguard let stringPrefix = string.characters.reversed(),\n\
    \t\tlet palindromeLength = _longestPalindrome(stringPrefix) else {\n\t\treturn\
    \ string\n\t}\n\n\treturn string.prefix(stringPrefix) + string[palindromeLength...].characters.reversed()",
  "\tvar stringToReturn = string\n\tvar tempString : String\n\tvar index : int\n\t\
    var tempLen : int\n\t\n\tstringToReturn = stringToReturn.lowercased()\n\t\n\t\
    for index = 0; index < stringToReturn.length; index++ {\n\t\ttempString = stringToReturn.substringToIndex(index\
    \ + 1)\n\t\ttempLen = tempString.length\n\t\tif tempLen == 0 {\n\t\t\tcontinue\n\
    \t\t}\n\t\tif tempLen > stringToReturn.length {\n\t\t\tbreak\n\t\t}\n\t\tif tempString.lowercased().characterAtIndex(0)\
    \ == stringToReturn.lowercased().characterAtIndex(tempLen - 1) {\n\t\t\tif tempLen\
    \ < stringToReturn.length {\n\t\t\t\tstringToReturn = stringToReturn.substringFromIndex(tempLen)\n\
    \t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tstringToReturn = stringToReturn\
    \ + tempString.substringFromIndex(stringToReturn.characters.count - tempLen)\n\
    \t\t\tbreak\n\t\t}\n\t}\n\t\n\treturn stringToReturn", "    // get longest postfix\
    \ of a palindrome that starts with the string\n    var longestPostfix = 0\n  \
    \  var longestString = \"\"\n    for index in stride(from: string.characters.count,\
    \ to: 1, by: -1) {\n        if let postfix = String(string.characters.suffix(from:\
    \ index)) {\n            longestPostfix = index\n            longestString = postfix\n\
    \            break\n        }\n    }\n    return longestString + String(string[longestPostfix...])",
  "    return string.prefix(longestPalindrome(string: string))\n        .prefix(longestPalindrome(string:\
    \ reverse(string: string)))", "    var postpalindrome = string\n    var longestPalindromeLen\
    \ = 0\n    for char in string.characters.reversed() {\n        if postpalindrome.characters.contains(char)\
    \ {\n            longestPalindromeLen = longestPalindromeLen + 1\n        }\n\
    \        if longestPalindromeLen > 0 && longestPalindromeLen > longestPalindrome.characters.count\
    \ / 2 {\n            postpalindrome = string.suffix(longestPalindromeLen)\n  \
    \          longestPalindromeLen = 0\n        }\n    }\n    if longestPalindromeLen\
    \ > 0 {\n        postpalindrome = string.suffix(longestPalindromeLen)\n    }\n\
    \    return postpalindrome", "\tvar longestPal = 0\n\tvar longest = \"\"\n\tlet\
    \ reverse = \"\"\n\tfor let i = string.characters.count - 1; i >= 0; i-- {\n\t\
    \tlet c = string.characters[i]\n\t\treverse = reverse + String(c.reversed())\n\
    \t\tif !string.isPalindrome {\n\t\t\tcontinue\n\t\t}\n\t\tif longestPal > longest.characters.count\
    \ {\n\t\t\tlongestPal = longest.characters.count\n\t\t\tlongest = string[longestPal...longestPal+longest.characters.count]\n\
    \t\t} else {\n\t\t\tif longestPal == longest.characters.count && longest.characters[longestPal]\
    \ == c {\n\t\t\t\tlongest = longest + string[longestPal...longestPal+longest.characters.count]\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn longest", "    var buffer = String()\n    var index\
    \ = string.startIndex\n\n    // Find longest possible postfix palindrome.\n  \
    \  let startIndex = index\n\n    while let c = string.character(at: index) {\n\
    \        if c == ' ' {\n            buffer = string + buffer\n            index\
    \ = startIndex\n            startIndex = index\n        } else {\n           \
    \ buffer = buffer + c\n            index = string.index(index, offsetBy: 1)\n\
    \        }\n    }\n\n    // Append to the end.\n    buffer.append(string, reversed:\
    \ false)\n\n    return buffer", "    if string == \"\" {\n        return string\n\
    \    }\n\n    let len = string.length\n    let maxLent = len - 2\n    let maxPostLen\
    \ = len - 2\n    var longestPalindromic = string\n\n    for postLen in\n     \
    \   stride(from: 1, to: maxLent, by: 2){\n\n        let prefixReversed = string[..<postLen].reversed()\n\
    \        longestPalindromic = prefixReversed + longestPalindromic\n        if\
    \ longestPalindromic == string{\n            return longestPalindromic\n     \
    \   }\n    }\n\n    return longestPalindromic", "\treturn make_palindrome_iterative(string)",
  "\tvar postfix = string\n\tvar reverse = \"\"\n\tfor character in postfix {\n\t\t\
    var reversedCharacter\n\t\tif reversedCharacter = reverse(character) {\n\t\t\t\
    postfix = postfix.stringByAppendingString(reversedCharacter)\n\t\t} else {\n\t\
    \t\tpostfix = postfix.stringByAppendingString(character)\n\t\t}\n\t}\n\treturn\
    \ postfix", '    return reverse(prefix: string) + string + reverse(string: string)',
  "    var prefix: String = \"\"\n    var suffix: String = \"\"\n    var longest:\
    \ Int = 0\n    var rev: String = string\n    var i = len(string) - 1\n    for\
    \ prefixLen in 1..len(string) {\n        if string[i] != string[len(string)-prefixLen]\
    \ {\n            break\n        }\n        longest = max(longest, prefixLen)\n\
    \        i -= 1\n    }\n    longest = max(longest, len(string))\n    for suffix\
    \ in 1..len(string) {\n        if string[i] != string[len(string)-suffix] {\n\
    \            break\n        }\n        longest = max(longest, suffix)\n      \
    \  i -= 1\n    }\n    rev = string[..longest]\n    let palindrome = rev + string[i..]\n\
    \    if palindrome == string {\n        return string\n    }\n    return palindrome",
  "    var longestPostfix, prefixToAppend, suffixToAppend, suffixToCheck = String(),\
    \ stringToCheck, stringToAppend = String()\n    for stringToCheck in Array(string.characters)\
    \ {\n        let isPalindrome = longestPostfix.characters.count == stringToCheck.characters.count\
    \ && longestPostfix.characters.reverse() == stringToCheck.characters.reverse()\n\
    \        let isPalindromeSuffix = prefixToAppend.characters.count == stringToCheck.characters.count\
    \ && prefixToAppend.characters.reverse() == stringToCheck.characters.reverse()\n\
    \        if isPalindrome && isPalindromeSuffix {\n            longestPostfix =\
    \ longestPostfix.appending(stringToCheck)\n            prefixToAppend = prefixToAppend.appending(stringToCheck)\n\
    \            suffixToCheck = stringToCheck\n            suffixToAppend = stringToCheck\n\
    \        }\n        if isPalindrome && suffixToCheck == stringToCheck {\n    \
    \        longestPostfix = longestPostfix.appending(stringToCheck)\n          \
    \  prefixToAppend = prefixToAppend.appending(stringToCheck)\n        }\n     \
    \   if isPalindrome && suffixToCheck != stringToCheck {\n            prefixToAppend\
    \ = prefixToAppend.appending(stringToCheck)\n        }\n        if stringToCheck\
    \ == longestPostfix {\n            longestPostfix = longestPostfix.appending(stringToCheck)\n\
    \            prefixToAppend = prefixToAppend.appending(stringToCheck)\n      \
    \  }\n    }\n    return longestPostfix.appending(suffixToAppend)", "    let palindromePrefix\
    \ = string.replacingOccurrences(of: \"\", with: \"\", options: .literal, range:\
    \ nil)\n    let palindromeSuffix = string.replacingOccurrences(of: \"\", with:\
    \ \"\", options: .literal, range: nil)\n    var palindrome = \"\"\n    while palindrome.length\
    \ > 0 {\n        let maxIndex = string.index(string.startIndex, offsetBy: palindrome.length,\
    \ reverse: true)\n        let prefix = string[maxIndex...maxIndex.advanced(by:\
    \ -1)]\n        let suffix = string[palindrome.length...maxIndex]\n        palindrome\
    \ += prefix + suffix\n    }\n    return palindromePrefix + palindromeSuffix",
  "\tlongestPalindrome := longestPalindromeFrom(string: string)\n\tprePalindrome :=\
    \ longestPalindromeFrom(string: string)\n\tpostPalindrome := longestPalindromeFrom(string:\
    \ string)\n\tvar newString : String\n\tnewString += prePalindrome\n\tnewString\
    \ += postPalindrome\n\tnewString += longestPalindrome\n\treturn newString", " \
    \   var string = string\n    let length: Int = string.count\n\n    // Check base\
    \ case for empty string and trivial cases.\n    if length == 0 || length == 1\
    \ {\n        return string\n    }\n\n    // Find largest postfix that is a palindrome.\n\
    \    let largestPalindromePostfix = findLongestPalindromePostfix(string: &string,\
    \ at: 0)\n\n    // If no palindrome found, simply return the original string.\n\
    \    if largestPalindromePostfix == 0 {\n        return string\n    }\n\n    //\
    \ Create reverse string prefix that comes before the largest palindromic suffix.\n\
    \    let reversePrefix = reverse(string: &string, at: largestPalindromePostfix)\n\
    \n    // Append the reverse of the palindromic suffix to the postfix of the original\
    \ string.\n    string = reversePrefix + string(suffix(string: &string, at: largestPalindromePostfix))\n\
    \n    // Return result string.\n    return string", "\tlet string = string.reversed()\n\
    \tlet chars = string.characters\n\t\n\tlet longestPostfixLength: Int = min(string.characters.count,\
    \ chars.count)\n\t\n\t// TODO: Check if it's already palindrome\n\t\n\tlet start\
    \ = max(0, longestPostfixLength)\n\t\n\treturn String(chars[start...longestPostfixLength])",
  "    if string == \"\" {\n        return \"\"\n    }\n    let prefixToEnd = string.prefixToEnd()\n\
    \    var suffix = string.suffixToEnd()\n    let longestPalindrome = prefix.reverse().append(suffix).reverse()\n\
    \    let longestPalindromeLength = longestPalindrome.count\n    if string.hasPrefix()\
    \ {\n        suffix = string[longestPalindromeLength...].suffixToEnd()\n    }\n\
    \    return string[longestPalindromeLength...].append(suffix).reverse()"]
stop_tokens:
- "\n}"
