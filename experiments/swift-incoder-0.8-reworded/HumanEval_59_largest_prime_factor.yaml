name: HumanEval_59_largest_prime_factor
language: swift
prompt: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  /// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
  \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
  \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
  \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
completions: ["    n /= 2\n    primes = 2\n    for d in 2...Int(log2(n)) {\n     \
    \   if n % d == 0 {\n            primes *= d\n            n /= d\n        }\n\
    \    }\n    return primes", "    let isPrime: Bool = is_prime(n)\n    if isPrime\
    \ {\n        return n\n    }\n\n    let maxPrime = 2 // Largest prime factor of\
    \ 2\n\n    // Iterate from 2 to sqrt(n) until we find a factor of n that divides\
    \ evenly\n    // into n-1, and stop if we find that factor.\n    for factor in\
    \ 2 ..< Int(sqrt(Double(n))) + 1 {\n\n        // For every number in the range\
    \ [2 * n, 2 * n + factor], verify that\n        // the number divides evenly into\
    \ n-1 and stop if that is the case.\n        var isDivisibleByN: Bool = false\n\
    \        for number in 2 * n ..< 2 * n + factor {\n            if number % n ==\
    \ 0 {\n                isDivisibleByN = true\n                break\n        \
    \    }\n        }\n\n        // If n is not a prime and n is not divisible by\
    \ n, then n is\n        // neither prime nor divisible by n.  Therefore, n must\
    \ be a prime\n        // factor.\n        if isPrime != isDivisibleByN {\n   \
    \         return maxPrime\n        }\n\n        // Otherwise we found a larger\
    \ prime factor: keep it and continue.\n        if factor > maxPrime {\n      \
    \      maxPrime = factor\n        }\n    }\n\n    return maxPrime", "    if n\
    \ == 1 { return 1 }\n    var p = 2\n    while n % p == 0 { p = p + 2 }\n    if\
    \ p <= n { return n }\n    \n    var sqr = 1\n    while sqr <= n {\n        sqr\
    \ *= 2\n        if sqr % n == 0 { return n }\n    }\n    return 0", "    var i\
    \ = 3\n    var largest = i\n    var j: Int = 0\n    var t: Int = 0\n    repeat\
    \ {\n        var isPrime = true\n        for _ in 1...i {\n            if n %\
    \ i == 0 {\n                isPrime = false\n                break\n         \
    \   }\n        }\n        if isPrime {\n            largest = i\n        }\n \
    \       if i == n {\n            break\n        }\n        i += 1\n    }\n   \
    \ for _ in 1...n {\n        t = largest\n        for _ in 1...i {\n          \
    \  if n % t == 0 {\n                largest = t\n                break\n     \
    \       }\n            t += 1\n        }\n        i = largest\n    }\n    return\
    \ largest", "  if n < 1 {\n    return 0\n  }\n  var factor: Int = 0\n  var test:\
    \ Int = 2\n  var prime: Bool = false\n  for factor in 2..Int(ceil(sqrt(n))) {\n\
    \    if n % test == 0 {\n      if prime {\n        return factor\n      }\n  \
    \    prime = true\n    }\n    test = test + factor\n  }\n  return factor", " \
    \   var max: Int = 0\n    var x: Int\n    if n <= 1 {\n        return 1\n    }\n\
    \    for x = 2; x <= Int(sqrt(n)); x++ {\n        if n % x == 0 {\n          \
    \  break\n        }\n        max = x\n    }\n    return max", "    guard n > 1\
    \ else { return 1 }\n    var n = n\n    var x = 2\n    var largestPrimeFactor\
    \ = 1\n    while x * x <= n {\n        var p = 2\n        while p < x * x {\n\
    \            if n % p == 0 {\n                largestPrimeFactor = p\n       \
    \         break\n            }\n            p += x\n        }\n        x += 2\n\
    \        n = largestPrimeFactor * x\n    }\n    return largestPrimeFactor", " \
    \   if n > 1 {\n        var largest_prime: Int = 0\n        var x: Int = 0\n \
    \       var y: Int = 0\n        var z: Int = 0\n        var w: Int = 0\n     \
    \   var i: Int = 0\n        var k: Int = 0\n\n        while z < n {\n        \
    \    x = 2\n            y = 1\n            while y <= z {\n                if\
    \ z % (x * y) == 0 {\n                    if x > y {\n                       \
    \ k = x\n                    } else {\n                        k = y\n       \
    \             }\n                    break\n                }\n              \
    \  x += 1\n                y += 1\n            }\n            largest_prime =\
    \ k\n            z += 1\n        }\n        return largest_prime\n    }\n    return\
    \ 0", "    var i: Int\n    for i = 2; i <= sqrt(Double(n)) && n != 1; i += 1 {\n\
    \        if n % i == 0 {\n            n /= i\n        }\n    }\n    return n",
  "\tprecondition(n > 1)\n\tprecondition(!is_prime(n))\n\n\tlet limit = sqrt(Double(n))\n\
    \n\tvar max_factor = 1\n\tvar max_factor_count = 1\n\n\tfor factor in 2..<limit\
    \ {\n\t\tif n % factor == 0 {\n\t\t\tmax_factor_count = max_factor * factor\n\n\
    \t\t\tif max_factor_count >= n {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif max_factor_count\
    \ > n / factor {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn max_factor_count",
  "    if n == 1 {\n        return 1\n    }\n\n    var max_factor = 1\n    var max_factor2\
    \ = 2\n\n    for factor in 2...n {\n        if n % factor == 0 {\n           \
    \ if factor > max_factor {\n                max_factor = factor\n            }\n\
    \            if factor > max_factor2 {\n                max_factor2 = factor\n\
    \            }\n        }\n    }\n    return max_factor * max_factor2", "    if\
    \ n == 1 {\n        return n\n    }\n    var prime: Int = 0\n    var largestPrime:\
    \ Int = 0\n    for number in 2...n {\n        if isPrime(number) {\n         \
    \   if prime > largestPrime {\n                largestPrime = prime\n        \
    \    }\n            prime = number\n        }\n    }\n    return largestPrime",
  "    if n < 2 {\n        return 0\n    }\n    \n    // find smallest factor\n  \
    \  let smallerFactor = smallest_prime_factor(n: n)\n    \n    // subtract smallest\
    \ factor from n\n    let n = n - smallerFactor\n    \n    // loop through all\
    \ prime factors\n    for var i = 2; i <= n; i++ {\n        // check if i is a\
    \ prime\n        if i % smallerFactor == 0 {\n            // found one\n     \
    \       return i\n        }\n    }\n    \n    // no prime factors found\n    return\
    \ 0", "    if n < 2 {\n        return n\n    }\n\n    if n > PrimeFactors.max\
    \ {\n        return PrimeFactors.max\n    }\n\n    // PrimeFactors<Int> is a static\
    \ struct that contains cached prime\n    // factor information.\n    return PrimeFactors[n]",
  "  var result = 1\n  var factors = 1\n  var limit = sqrt(Double(n))\n  for number\
    \ in 2 ..< limit {\n    if n % number == 0 {\n      break\n    }\n    if number\
    \ > limit {\n      continue\n    }\n    while n % number == 0 {\n      n /= number\n\
    \      factors += 1\n    }\n  }\n  while n > 1 {\n    if n % (result * 2) == 0\
    \ {\n      break\n    }\n    result += 1\n    n /= result\n    factors += 1\n\
    \  }\n  return factors", "    let (m, t) = smallest_prime_factor(n: n)\n    return\
    \ t", "    var largestPrimeFactor = Int(-1)\n    if n < 2 {\n        return Int(n)\n\
    \    }\n    \n    var largestPrimeCount = 0\n    \n    for number in 2..Int(n)\
    \ {\n        if n%number == 0 {\n            if largestPrimeCount == 0 {\n   \
    \             largestPrimeCount = number\n            } else {\n             \
    \   if largestPrimeCount > number {\n                    largestPrimeCount = number\n\
    \                }\n            }\n        }\n    }\n    return largestPrimeCount",
  "\tlet mut i = 2\n\tlet mut largest_pf = 2\n\twhile i <= n {\n\t\tlet r = Int(sqrt(Double(n)))\n\
    \t\tlet p = Int(floor(Double(r) / Double(i)))\n\t\tif p*p <= r {\n\t\t\tlargest_pf\
    \ = p\n\t\t\ti += 2\n\t\t} else {\n\t\t\ti = i + 1\n\t\t}\n\t}\n\treturn largest_pf",
  "    let r = 1\n    let max_factor = 1\n\n    while n > 1 {\n        while n % r\
    \ == 0 {\n            n /= r\n        }\n        max_factor++\n        if n >\
    \ 1 {\n            r++\n        }\n    }\n\n    return max_factor", "    if n\
    \ < 2 {\n        return 2\n    }\n\n    var max_prime = 0\n    for i := 2; i <=\
    \ n/2; i++ {\n        var prime = true\n        for j := 1; j < i; j++ {\n   \
    \         if n % i == 0 {\n                prime = false\n                break\n\
    \            }\n        }\n\n        if prime {\n            max_prime = i\n \
    \       }\n    }\n\n    return max_prime", "    if n > 1 {\n        if n % 2 ==\
    \ 0 {\n            return 3\n        }\n\n        var max = 2\n        var i =\
    \ 3\n        while i * i <= n {\n            if n % i == 0 {\n               \
    \ max = i\n            }\n\n            i += 2\n        }\n\n        return max\n\
    \    }\n\n    return 1", "    if n < 2 {\n        return 2\n    }\n    if n <=\
    \ 3 {\n        return 3\n    }\n    let max = 2\n    let limit = n\n    var factor\
    \ = 2\n    while limit > 1 {\n        let q = limit / factor\n        if q ==\
    \ limit {\n            limit = q - 1\n            factor = q + 1\n        } else\
    \ {\n            if limit % factor == 0 {\n                max = factor\n    \
    \        }\n            limit = limit / factor\n            factor = factor +\
    \ 2\n        }\n    }\n    return max", "  var factor: Int = 0\n  var count: Int\
    \ = 0\n  var prime: Int = 1\n  var limit: Int = n - 1\n  var i: Int = 0\n\n  repeat\
    \ {\n    factor = n\n    count = n\n\n    while factor >= prime {\n      factor\
    \ = factor * prime\n      count--\n    }\n\n    if count == 0 {\n      return\
    \ prime\n    }\n\n    if limit >= prime {\n      i = prime * prime - 1\n     \
    \ limit = limit - prime\n    } else {\n      i = prime * prime\n    }\n\n    while\
    \ i >= limit {\n      prime = prime * prime\n      count--\n    }\n  } while count\
    \ != 0\n\n  return 0", "    let mut max_factor = 0\n    let mut prime_factor =\
    \ n - 1\n\n    for _ in 0..n {\n        if prime_factor % 2 == 1 {\n         \
    \   return prime_factor\n        }\n        let new_factor = prime_factor + 2\n\
    \        prime_factor = new_factor - 1\n        max_factor = max(max_factor, new_factor)\n\
    \    }\n    return max_factor", "    if n < 2 {\n        return 2\n    }\n   \
    \ \n    // The largest prime factor of a non-prime n is the smallest\n    // prime\
    \ factor of the square root of the number.\n    if isPrime(n) {\n        return\
    \ 1\n    }\n\n    // Use Sieve of Eratosthenes method (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\
    \ for finding prime factors of n.\n    // The algorithm is more efficient than\
    \ using the built-in function.\n    var candidates = [2]\n    var i = 2\n    for\
    \ _ in 0..<Int(ceil(sqrt(Double(n))))  {\n        if n % i == 0 {\n          \
    \  candidates.append(i)\n        }\n        i += 1\n    }\n\n    // Find the largest\
    \ prime factor using the candidates.\n    guard candidates.count > 0 else {\n\
    \        return 2\n    }\n\n    var largestPrimeFactor: Int = candidates[0]\n\
    \    for factor in candidates.dropFirst() {\n        if n % factor == 0 {\n  \
    \          largestPrimeFactor = factor\n            break\n        }\n    }\n\n\
    \    return largestPrimeFactor", "    if n == 1 {\n        return n\n    }\n \
    \   var maxFactor: Int = 0\n    var maxFactorSquared: Int = 0\n    var divisor:\
    \ Int = 2\n\n    while (n > 1) {\n        maxFactorSquared = maxFactor * maxFactor\n\
    \        if maxFactorSquared > n {\n            maxFactorSquared = n\n       \
    \ }\n        if maxFactorSquared == n {\n            maxFactor++\n        }\n\n\
    \        while divisor < maxFactorSquared {\n            divisor = maxFactorSquared\n\
    \            maxFactorSquared = divisor / divisor\n            if maxFactorSquared\
    \ <= n {\n                break\n            }\n        }\n        maxFactor =\
    \ divisor\n        n--\n    }\n    return maxFactor", "    let max = (2..<n).filter{\
    \ $0 % $0 == 0 }.count\n    guard max > 1 else { return 1 }\n    let maxDiv =\
    \ (2..<max).filter{ $0 % $0 != 0 }.count\n    if maxDiv == max {\n        return\
    \ max\n    }\n    let div = Int(sqrt(Double(maxDiv)))\n    return max/div", " \
    \   // Only check for divisors up to the square root of n.\n    let limit = Int(floor(sqrt(Double(n)))\
    \ + 1)\n    var result = 1\n\n    for div in 2...limit {\n        let divn = Int(div\
    \ * sqrt(Double(n)))\n\n        if divn % n == 0 {\n            result = divn\n\
    \            break\n        }\n    }\n\n    return result", "  var result = 1\n\
    \n  for factor in 2...n {\n    if n % factor == 0 {\n      result = factor\n \
    \   }\n  }\n\n  return result", "    let factors = prime_factors(n)\n    if factors.count\
    \ > 0 {\n        return factors[0]\n    } else {\n        return n\n    }", " \
    \ // If n < 2, then n is not a prime number. So, return 1.\n  if n < 2 {\n   \
    \ return 1\n  }\n\n  // Initialize `result` to 1.\n  var result = 1\n\n  // If\
    \ `n >= 4`, then n is a prime number. So, return `n`.\n  if n >= 4 {\n    return\
    \ n\n  }\n\n  // Initialize `i` to 2.\n  var i = 2\n\n  // Initialize `m` to `n`.\n\
    \  var m = n\n\n  // While `i` is less than `m`, loop through all numbers from\
    \ `i` to `m`.\n  while i < m {\n    // If `i` is divisible by `m`, then increment\
    \ `i`.\n    if i % m == 0 {\n      i += 1\n    }\n    // Otherwise, decrement\
    \ `m`.\n    else {\n      m -= 1\n    }\n\n    // If `m` is divisible by `i`,\
    \ then increase `result`.\n    if m % i == 0 {\n      result += 1\n    }\n  }\n\
    \n  // Return `result`.\n  return result", "    func largestPrimeFactor(n : Int)\
    \ -> Int {\n        if n == 0 {\n            return 1\n        }\n\n        var\
    \ primesSoFar : Set<Int> = []\n        var largestPrimeSoFar : Int = 2\n\n   \
    \     for i in 2...n {\n            if n % i == 0 {\n                if !primesSoFar.contains(i)\
    \ {\n                    primesSoFar.append(i)\n                    if largest\
    \ <= largestPrimeSoFar {\n                        largestPrimeSoFar = i\n    \
    \                }\n                }\n            }\n        }\n\n        return\
    \ largestPrimeSoFar\n    }\n    return largestPrimeFactor(n)", "    func isPrime(x:\
    \ Int) -> Bool {\n        let x = sqrt(Double(x))\n        for _ in 0..<(x/2)\
    \ where x > 1 {\n            if x == Int(Int(x) * Int(x) + 1) {\n            \
    \    return false\n            }\n        }\n        return true\n    }\n    \n\
    \    if n > 1 {\n        for var i = 2; i < n; i++ {\n            if isPrime(i)\
    \ {\n                n /= i\n            }\n        }\n    }\n    return n", " \
    \   let mut i = 2\n    let mut n = n\n    while i*i <= n {\n        if n % i ==\
    \ 0 {\n            i += 2\n        }\n        else {\n            i += 1\n   \
    \     }\n        n = n / i\n    }\n    return i", "  let primes = (0..<n).filter({\
    \ is_prime($0) })\n  if primes.count <= 1 {\n    return n\n  } else {\n    return\
    \ max(primes.lazy.reduce(0, {$0 + $1})) % n\n  }", "    var largest = 1\n    var\
    \ i = 3\n    var prime_fac = 0\n    while i != n {\n        if n % i == 0 {\n\
    \            if i == 1 {\n                largest = i\n            } else {\n\
    \                if prime_fac > largest {\n                    largest = prime_fac\n\
    \                }\n            }\n            prime_fac += 2\n        }\n   \
    \     i += 1\n    }\n    return largest", "    let a = 2\n    let b = 2\n    let\
    \ max_factor = 2\n    let max_prime = 1\n    var is_prime = true\n    while is_prime\
    \ == true {\n        let factor = a * b\n        if n % factor == 0 {\n      \
    \      n /= factor\n            if n > max_factor {\n                max_factor\
    \ = n\n                max_prime = a\n            }\n        } else {\n      \
    \      is_prime = false\n        }\n        b += 1\n        if b > 1000 {\n  \
    \          b = 2\n            a += 1\n        }\n    }\n    return max_prime",
  "    var p = 2\n    var i = 2\n    repeat {\n        if n % p == 0 {\n         \
    \   n = n / p\n        } else {\n            i += 1\n            p = i * p\n \
    \       }\n    } while p * p <= n\n    return i", "  // This is more efficient\
    \ for small numbers, since it skips two multiplications:\n  if n < 4 {\n    return\
    \ 1\n  }\n  var primes = [Int]()\n  var prime = 1\n  var d = 2\n  var sq = n *\
    \ n\n\n  while (true) {\n    if sq < 2 {\n      break\n    }\n    if n % d ==\
    \ 0 {\n      if d > 1 {\n        d += 1\n        primes.append(d)\n      }\n \
    \     sq -= d\n      if sq < 2 {\n        break\n      }\n    }\n    prime +=\
    \ 1\n    d += 2\n  }\n\n  if sq == 2 {\n    // Trivial case: one factor.\n   \
    \ return prime\n  }\n\n  // Trivial case: greater than 2 primes.\n  if primes.count\
    \ > 2 {\n    return -1\n  }\n\n  // Optimization: only call this function with\
    \ odd numbers.\n  if primes.count == 2 {\n    if primes[0] % 2 == 0 {\n      return\
    \ primes[0]\n    } else {\n      return primes[1]\n    }\n  }\n\n  // More optimization:\
    \ use first two primes.\n  if primes.count == 1 {\n    return primes[0]\n  }\n\
    \n  // If there are more than two primes, take the smaller one.\n  if primes.count\
    \ > 2 {\n    return primes[1]\n  }\n\n  // If there are two primes, return either.\n\
    \  return primes[0]", "\tvar max_factor = 1\n\tvar min_factor = 2\n\tvar next_factor\
    \ = 3\n\tfor factor := 2; factor*factor <= n; factor++ {\n\t\tif n%factor == 0\
    \ {\n\t\t\tbreak\n\t\t}\n\t\tif factor < min_factor {\n\t\t\tmin_factor = factor\n\
    \t\t}\n\t\tif factor > max_factor {\n\t\t\tmax_factor = factor\n\t\t}\n\t\tnext_factor\
    \ = factor\n\t}\n\treturn next_factor", "    let mut n1 = n % 5\n    let mut n2\
    \ = n % 3\n    while n2 > 0 && n1 < 2 {\n        n2 += 2\n        n1 += 1\n  \
    \  }\n    while n2 == 0 && n1 < 4 {\n        n2 += 2\n        n1 += 1\n    }\n\
    \    while n2 == 0 && n1 < 6 {\n        n2 += 2\n        n1 += 1\n    }\n    while\
    \ n2 == 0 && n1 < 9 {\n        n2 += 2\n        n1 += 1\n    }\n    while n2 ==\
    \ 0 && n1 < 12 {\n        n2 += 2\n        n1 += 1\n    }\n    while n2 == 0 &&\
    \ n1 < 14 {\n        n2 += 2\n        n1 += 1\n    }\n    while n2 == 0 && n1\
    \ < 16 {\n        n2 += 2\n        n1 += 1\n    }\n    while n2 == 0 && n1 < 18\
    \ {\n        n2 += 2\n        n1 += 1\n    }\n    while n2 == 0 && n1 < 19 {\n\
    \        n2 += 2\n        n1 += 1\n    }\n    while n2 == 0 && n1 < 20 {\n   \
    \     n2 += 2\n        n1 += 1\n    }\n    while n2 == 0 && n1 < 21 {\n      \
    \  n2 += 2\n        n1 += 1\n    }\n    while n2 == 0 && n1 < 22 {\n        n2\
    \ += 2\n        n1 += 1\n    }\n    while n2 == 0 && n1 < 23 {\n        n2 +=\
    \ 2\n        n1 += 1\n    }\n    while n2 == 0 && n1 < 24 {\n        n2 += 2\n\
    \        n1 += 1\n    }\n    while n2 == 0 && n1 < 25 {\n        n2 += 2\n   \
    \     n1 += 1\n    }\n    while n2 == 0 && n1 < 26 {\n        n2 += 2\n      \
    \  n1 += 1\n    }\n    while n2 == 0 && n1 < 27 {\n        n2 += 2\n        n1\
    \ += 1\n    }\n    while n2 == 0 && n1 < 28 {\n        n2 += 2\n        n1 +=\
    \ 1\n    }\n    while n2 == 0 && n1 < 29 {\n        n2 += 2\n        n1 += 1\n\
    \    }\n    while n2 == 0 && n1 < 30 {\n        n2 += 2\n        n1 += 1\n   \
    \ }\n    while n2 == 0 && n1 < 31 {\n        n2 += 2\n        n1 += 1\n    }\n\
    \    while n2 == 0 && n1 < 32 {\n        n2 += 2\n        n1 += 1\n    }\n   \
    \ while n2 == 0 && n1 < 33 {\n        n2 += 2\n        n1 += 1\n    }\n    while\
    \ n2 == 0 && n1 < 34 {\n        n2 += 2\n        n1 += 1\n    }\n    while n2\
    \ == 0 && n1 < 35 {\n        n2 += 2\n        n1 += 1", "  if n <= 1 {\n    return\
    \ 0\n  }\n  var max_factor = 0\n  var max_factor_index = 0\n\n  for f in 2..(n\
    \ - 1) {\n    var temp = f\n    for x in 2..(n - f) {\n      if n % (f * x) ==\
    \ 0 {\n        temp = x\n        break\n      }\n    }\n    if temp > max_factor\
    \ {\n      max_factor = temp\n      max_factor_index = f\n    }\n  }\n\n  return\
    \ max_factor_index", "\treturn large_prime_factor(n, n+1)", "    // The maximum\
    \ value a big number can hold is roughly 2\xD710<sup>38</sup>\n    // so a prime\
    \ value of 192 works fine.\n    let big_number = BigUInt(n)\n    var max_factor:\
    \ Int = 0\n    var next_factor: Int = 1\n    while next_factor <= big_number {\n\
    \        max_factor = next_factor\n        next_factor = next_factor * 2\n   \
    \ }\n\n    return max_factor", "    guard n > 1 else { return 1 }\n    if isPrime(n)\
    \ { return n }\n\n    var a = 2\n    var b = 1\n    let d = n\n    while b * d\
    \ <= n {\n        let t = b\n        b = a\n        a = t\n        d = d / b\n\
    \    }\n\n    if b > n / 2 {\n        return b\n    } else {\n        return largest_prime_factor(n\
    \ - b)\n    }", "  var largest = 1\n  var div = 1\n  var prime = 1\n  var isPrime\
    \ = true\n\n  while (div <= n) {\n    while ((n % div) == 0) {\n      if isPrime\
    \ {\n        prime = div\n      }\n      isPrime = true\n    }\n\n    if isPrime\
    \ {\n      isPrime = false\n    }\n\n    if prime > largest {\n      largest =\
    \ prime\n    }\n\n    div += 1\n  }\n\n  return largest", "    n -= 1\n    var\
    \ result = 1\n    if n > 2 {\n        for i := 2; i <= Int(sqrt(Double(n - 1)));\
    \ i++ {\n            if n % i == 0 {\n                result = i\n           \
    \     break\n            }\n        }\n    }\n    if result == 1 {\n        n\
    \ = 2\n    }\n    return result", "  // Sieve of Eratosthenes for large n\n  if\
    \ n <= 2 {\n    return 2\n  }\n  var largest = Int(2)\n  var largestPrimeFactor\
    \ = Int(2)\n\n  for d in 2..Int(n-1) {\n    // Keep looking for factors until\
    \ we find one that divides evenly into n\n    if n % d == 0 {\n      // We found\
    \ a factor, great!\n      largestPrimeFactor = d\n      largest = Int(ceil(log2(n)))\n\
    \    }\n  }\n\n  return largestPrimeFactor", "    let a = sqrt(Double(n))\n  \
    \  var b = 1\n    var c = 2\n    while (b < a && c < n) {\n        if n % c ==\
    \ 0 {\n            b = b * c + a\n        } else {\n            c = c * c + a\n\
    \        }\n    }\n    return b", "    let sqrt_n = (n * (n + 1)) / 2\n    return\
    \ 3", "    let maxPrime: Int = Int(ceil(log2(n)))\n    let maxFactor = Int(log2(n))\n\
    \    \n    if maxPrime <= maxFactor {\n        return 0\n    }\n    \n    var\
    \ i = 0\n    var factor = 1\n    \n    while i < maxPrime {\n        if n % i\
    \ == 0 {\n            factor = Int(log2(i))\n            if factor > maxFactor\
    \ {\n                factor = 1\n            }\n        }\n        i += 1\n  \
    \  }\n    \n    return factor", "    assert(n >= 1 && n != 0)\n    let limit =\
    \ (Double(sqrt(Double(n))) + 1).rounded(.towardZero)\n    guard limit > n else\
    \ { return 0 }\n    var largest = 1\n    var i = 1\n    while i <= limit {\n \
    \       guard is_prime(i) else { largest = i }\n        i += 1\n    }\n    return\
    \ largest", "    var maxFactor: Int = 0\n    var maxFactor2: Int = 0\n    var\
    \ i = 3\n    while i < n {\n        if n % i == 0 {\n            maxFactor = max(maxFactor,\
    \ i)\n            maxFactor2 = max(maxFactor2, i * i)\n            i += 2\n  \
    \      } else {\n            i += 1\n        }\n    }\n    return maxFactor *\
    \ maxFactor2", "    // Prime factorization of n starts from 3.\n    var factors\
    \ = [1]\n    for i := 2; i < n; i += 1 {\n        // i is greater than or equal\
    \ to 2.\n        if n % (i * i) == 0 {\n            // i is a prime number.\n\
    \            factors = append(factors, i)\n        }\n    }\n    return factors.reduce(1,\
    \ max)", "  // Initialize largest prime factor\n  var largestPrimeFactor = 1\n\
    \n  // Compute primes up to n\n  let primes = 2..<n\n\n  // Search for next prime\
    \ in the range 2..n\n  while primes.contains(largestPrimeFactor) {\n    largestPrimeFactor\
    \ = primes.last! + 1\n  }\n\n  // Return largest prime factor\n  return largestPrimeFactor",
  "    let i = 2\n    var p = 2\n    \n    while i <= n {\n        if n % i == 0 {\n\
    \            p = i\n        }\n        i += 1\n    }\n    \n    return p", "\t\
    // Initialize variables\n\tvar maxPrime = Int64(0)\n\tvar prime = 1\n\tvar primeFactors\
    \ = 1\n\tvar isPrime = true\n\tvar isSquare = true\n\tvar isDivisibleByPrime =\
    \ true\n\n\t// Calculate the prime factors\n\tfor prime < n {\n\t\tif n % prime\
    \ == 0 {\n\t\t\tisPrime = false\n\t\t\tisSquare = false\n\t\t\tbreak\n\t\t}\n\t\
    \tprimeFactors += prime\n\t\tif prime % 2 == 1 {\n\t\t\tisDivisibleByPrime = false\n\
    \t\t}\n\t\tif prime > maxPrime {\n\t\t\tmaxPrime = prime\n\t\t}\n\t\tif prime\
    \ * prime > n {\n\t\t\tbreak\n\t\t}\n\t\tif isDivisibleByPrime {\n\t\t\tif prime\
    \ % 2 == 1 {\n\t\t\t\tisSquare = false\n\t\t\t}\n\t\t}\n\t\tif isPrime {\n\t\t\
    \tif prime < 2 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tprime++\n\t\t\tisPrime = true\n\
    \t\t\tisDivisibleByPrime = true\n\t\t\tisSquare = true\n\t\t}\n\t}\n\t\n\tif primeFactors\
    \ % 2 == 1 {\n\t\treturn 2\n\t} else {\n\t\treturn primeFactors\n\t}", '    return
    sieve.filter(func(n)).reduce(0, { max($0, $1) })', "    var maxPrimeDivisor: Int\
    \ = 0\n    var maxPrime: Int = 0\n    var factor: Int = 0\n    for divisor in\
    \ 2...n {\n        if n%divisor == 0 {\n            factor = divisor\n       \
    \     break\n        }\n    }\n\n    if factor == 0 {\n        return n // n is\
    \ prime\n    }\n\n    // Prime divisor is greater than largest factor\n    if\
    \ factor > maxPrime {\n        maxPrime = factor\n        maxPrimeDivisor = divisor\n\
    \    }\n\n    for divisor in 2...n {\n        if n%divisor == 0 {\n          \
    \  if divisor > maxPrimeDivisor {\n                maxPrimeDivisor = divisor\n\
    \                maxPrime = factor\n            }\n        }\n    }\n\n    return\
    \ maxPrime", "    if n < 2 {\n        return 2\n    }\n\n    // We do not need\
    \ to check n here because we know that n is > 1.\n    var p : Int\n    for p =\
    \ 2; p * p <= n; p++ {\n        if n % p == 0 {\n            return p\n      \
    \  }\n    }\n\n    // Only one factor is possible here.\n    return n", "    if\
    \ n < 2 {\n        return n\n    }\n    let m = Int(sqrt(n))\n    let mut largest_factor:\
    \ Int = 2\n    for factor in 2..m {\n        if n % factor == 0 {\n          \
    \  largest_factor = factor\n            break\n        }\n    }\n    return largest_factor",
  "    let primes = getPrimes(n)\n\n    for prime in primes {\n        if n % prime\
    \ == 0 {\n            return prime\n        }\n    }\n\n    return n", "    let\
    \ primes = primes(n: n)\n    if primes.isEmpty() {\n        return 0\n    }\n\
    \    return primes.max(by: { $0 % $1 })", "    var factors = [1]\n    if n <=\
    \ 1 {\n        return n\n    }\n    for f in 2...n {\n        for _ in 0..(n -\
    \ f) {\n            factors.append(f)\n        }\n    }\n    var largest = factors[0]\n\
    \    for f in 2...n {\n        if f > largest {\n            return largest\n\
    \        }\n        if f % largest == 0 {\n            largest = f\n        }\n\
    \    }\n    return largest", "    // TODO: implement the Sieve of Eratosthenes\
    \ method\n    let sieve = [Int]()\n    for _ in 0..(n / 2) {\n        sieve.append(0)\n\
    \    }\n\n    for num in 2..n {\n        if sieve[num] == 0 {\n            for\
    \ num in 2..n {\n                if sieve[num] != 0 {\n                    sieve[num]\
    \ = num * num\n                    break\n                }\n            }\n \
    \       }\n    }\n    guard sieve[(n-1)/2] == 0 else {\n        return 0\n   \
    \ }\n    return Int(sieve[(n-1)/2])", "    guard n > 1 else {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    var result = 0\n   \
    \ for p in sieve() {\n        if n % p == 0 {\n            result = (result >\
    \ p) ? result : p\n        }\n    }\n    return result", "\t/*\n\tSieve of Eratosthenes\
    \ method finds primes smaller than n using the Sieve of Eratosthenes\n\tMethod\
    \ by Erathosthenes Sieve.\n\t*/\n\t\n\tvar sieve: [Bool] = Array(0..<n + 1)\n\t\
    var result: Int = 0\n\tvar i: Int\n\tfor i = 2; i <= n; i++ {\n\t\tif sieve[i]\
    \ == false {\n\t\t\tfor k = i*i; k <= n; k += i {\n\t\t\t\tsieve[k] = false\n\t\
    \t\t}\n\t\t}\n\t}\n\tfor i = 2; i <= n; i++ {\n\t\tif sieve[i] == true {\n\t\t\
    \tresult = i\n\t\t\tfor k = i*i; k <= n; k += i {\n\t\t\t\tsieve[k] = false\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn result", "    if n < 2 {\n        return 0\n    }\n\
    \    var i: Int\n    var s: Int\n    var p: Int\n\n    var d = 2\n    var m =\
    \ 3\n    var mprime = 3\n    var k = 3\n    var m = 2\n    var i = 2\n    var\
    \ s = 1\n\n    while i < n {\n        if n % i == 0 {\n            if m > i {\n\
    \                mprime = m\n            }\n            if m == i {\n        \
    \        s = i\n            }\n            i += d - 1\n            d *= m\n  \
    \      }\n        m += 2\n    }\n    p = Int((n - s) / mprime)\n    return p",
  '    return largest_factor(n)', "    let max: Int = 3\n    var ans = 2\n    let\
    \ maxPrime: Int = Int(sqrt(Double(n)))\n    for _ in 2...maxPrime {\n        if\
    \ n%ans == 0 {\n            ans = ans+1\n        }\n        else {\n         \
    \   ans = ans-1\n        }\n        if ans == max {\n            return ans\n\
    \        }\n    }\n    return ans", "    if n < 1 {\n        guard let y = sqrt(Double(n))\
    \ else { return 1 }\n        let p = 2\n        var d = 2\n        while p < y\
    \ {\n            guard n % p == 0 else { return p }\n            if d == p { break\
    \ }\n            p += 1\n            d += 1\n        }\n        return p\n   \
    \ }\n    var d = 2\n    var p = 1\n    while p < n {\n        guard n % p == 0\
    \ else { return p }\n        if d == p { break }\n        p += 1\n        d +=\
    \ 1\n    }\n    return p", "    guard n >= 2 && n > 1 else {\n        return n\n\
    \    }\n\n    // Find the first prime factor of n\n    var i: Int = 0\n    var\
    \ factor: Int = 0\n    while i < n {\n        i += 1\n        if n % i == 0 {\n\
    \            factor = i\n            break\n        }\n    }\n\n    // If no prime\
    \ factor was found, return n\n    if factor == 0 {\n        return n\n    }\n\n\
    \    // Iterate through all numbers up to sqrt(n)\n    var factor2: Int = 1\n\
    \    for i = factor + 1; i <= Int(pow(Double(n), 1.0/Double(factor))); i++ {\n\
    \        if n % i == 0 {\n            factor2 = i\n            break\n       \
    \ }\n    }\n\n    return factor2", "    if n == 1 {\n        return 1\n    }\n\
    \    \n    var max_factor = 1\n    var max_factor_index = 1\n    for index in\
    \ 1...n {\n        if n % index == 0 {\n            if index * max_factor > n\
    \ {\n                max_factor = index\n                max_factor_index = index\n\
    \            }\n        } else {\n            break\n        }\n    }\n    \n\
    \    return max_factor_index", '    return Int(sqrt(Double(n)))', "    var result\
    \ = 1\n    for p : Int in 2..<n {\n        if n % p == 0 {\n            result\
    \ = p\n            break\n        }\n    }\n    return result", "    if n < 2\
    \ {\n        return n\n    }\n    // Limit to square root\n    for var factor\
    \ = 2; factor < Int(floor(sqrt(Double(n)))); factor++ {\n        if n % factor\
    \ == 0 {\n            break\n        }\n    }\n    return factor", "    var factors:\
    \ Set<Int> = []\n    for i in 1...n {\n        if n % i == 0 {\n            factors.add(i)\n\
    \        }\n    }\n    return factors.max()", "    if n < 1 {\n        return\
    \ 0\n    }\n    // http://en.wikipedia.org/wiki/Primality_test#Primality_of_the_test_to_determine_inverse\n\
    \    for p := 2; p*p <= n; p++ {\n        if n % p == 0 {\n            return\
    \ p\n        }\n    }\n    return n", "\tif n == 1 || n == 0 {\n\t\treturn 1\n\
    \t}\n\n\tlargestPrimeFactor := 1\n\tfor i := 2; i <= n/2; i++ {\n\t\tif n%i ==\
    \ 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor j := i * i; j <= n; j += i {\n\t\t\tif\
    \ n%j == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif j > largestPrimeFactor {\n\t\t\t\
    \tlargestPrimeFactor = j\n\t\t\t}\n\t\t}\n\t}\n\treturn largestPrimeFactor", " \
    \   let max_factor = ceil(log2(n))\n\n    for f in 2...max_factor {\n        if\
    \ n % (f * f) == 0 {\n            return f\n        }\n    }\n\n    return n",
  '    return isPrime(n) ? n : largestPrimeFactor(n)', '    return largestPrimeFactor(n)',
  "    var max: Int = 0\n    var factor: Int = 0\n    var start: Int = 0\n\n    for\
    \ factor in 2..n {\n        if n % factor == 0 {\n            if max < factor\
    \ {\n                max = factor\n            }\n            if n > start {\n\
    \                n = start\n            }\n        }\n        start += 1\n   \
    \ }\n    if n != max {\n        n += max\n    }\n    return max", "    // Only\
    \ consider odd numbers, because 2 is the only even prime number.\n    // We start\
    \ at 3 to avoid a potential \"divide by zero\" error for even numbers,\n    //\
    \ which could cause infinite loops for certain inputs.\n    for i in 3...n / 2\
    \ {\n        if n % i == 0 {\n            return i\n        }\n    }\n    return\
    \ n", "    if n <= 1 {\n        return -1\n    }\n    \n    if n == 2 {\n    \
    \    return 2\n    }\n    \n    var factors = [1]\n    var candidate = 2\n   \
    \ \n    for factor in 2...n {\n        if factor > n / 2 {\n            break\n\
    \        }\n        \n        if factor % 2 == 0 {\n            candidate = factor\n\
    \        }\n        \n        factors.append(factor)\n    }\n    \n    if candidate\
    \ == n / 2 {\n        return candidate\n    }\n    \n    guard candidate % 2 ==\
    \ 0 else { return -1 }\n    \n    for i in 2...candidate/2 {\n        if factor\
    \ > n / 2 {\n            break\n        }\n        \n        if factor % i ==\
    \ 0 {\n            factors.append(i)\n            factors.append(n / i)\n    \
    \        factors.append(n / n / i)\n        }\n    }\n    \n    guard factors.last\
    \ == n / n else { return -1 }\n    \n    return factors.last + 1", "    if n <\
    \ 2 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ \n    // Sieve of Eratosthenes\n    // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    var sieve: [Int]\n    sieve = [2...n]\n    var n = 2\n    var m = 0\n   \
    \ var p = Int(n/2)\n    for _ in 0 ..< n {\n        if sieve[m] == 0 {\n     \
    \       m = m * 2\n            if m > n {\n                p = p + 1\n       \
    \         m = m / 2\n            }\n            sieve[m] = 1\n        }\n    \
    \    n = n + 1\n    }\n    \n    // We now have the prime factors up to n\n  \
    \  // Start at sqrt(n) and work our way down\n    var factor = 2\n    for var\
    \ i = 0; i < p; i = i + 1 {\n        factor = p\n        \n        // While the\
    \ prime factors are greater than or equal to the square root of n\n        while\
    \ factor < n {\n            factor = 2 * factor\n            \n            //\
    \ If factor is even, divide the prime by 2\n            if factor % 2 == 0 {\n\
    \                factor = factor / 2\n            } else {\n                //\
    \ If factor is odd, multiply the prime by 3\n                factor = 3 * factor\n\
    \            }\n        }\n        \n        // We have calculated factor\n  \
    \      if factor > 1 {\n            // Return the largest prime factor of n\n\
    \            return factor\n        } else {\n            // Otherwise we found\
    \ a prime factor of n\n            break\n        }\n    }\n    \n    // If the\
    \ while loop was not entered then n must be prime\n    return factor", "    //\
    \ Special case 1: n < 2.\n    if n < 2 {\n        return 0\n    }\n\n    // Special\
    \ case 2: n = 2 or a composite.\n    if n == 2 || n == 1 {\n        return n\n\
    \    }\n\n    // If n = 3, then 2 is the only factor of n. Check all odd composite\n\
    \    // factors of n.\n    if n == 3 {\n        if n == 2 {\n            return\
    \ 2\n        } else {\n            // Check all even composite factors of n.\n\
    \            for p in 2...n/2 {\n                if n%p == 0 {\n             \
    \       return p\n                }\n            }\n        }\n    }\n\n    //\
    \ If n > 3, then we can divide n by any odd composite factor of n.\n    for p\
    \ in 2...n {\n        if n%p == 0 {\n            return p\n        }\n    }\n\n\
    \    // If we reach this point, then n is a composite.\n    return n", "    func\
    \ next_multiple(start: Int, end: Int) -> Int {\n        var result = start\n \
    \       for i in 2...end {\n            if result % i == 0 {\n               \
    \ result += 1\n            } else {\n                break\n            }\n  \
    \      }\n        return result\n    }\n\n    var max_factor: Int = 0\n    var\
    \ i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            max_factor\
    \ = i\n            n = n / i\n        }\n        i = next_multiple(i * 2, n)\n\
    \    }\n    return max_factor", "  if n < 2 {\n    return 1\n  }\n  var maxFactor\
    \ = 1\n  var m = 2\n  while m <= n / 2 {\n    if n % m == 0 {\n      maxFactor\
    \ = m\n      break\n    }\n    m++\n  }\n  return maxFactor", "  if n == 1 {\n\
    \    return 1\n  }\n  if n == 2 {\n    return 2\n  }\n  if n % 2 == 0 || n % 3\
    \ == 0 {\n    return n\n  }\n\n  var maxFactor: Int\n  for factor in 2...(n/2)\
    \ {\n    if n % factor == 0 {\n      if maxFactor < factor {\n        maxFactor\
    \ = factor\n      }\n    }\n  }\n  return maxFactor", "  var lim = Int(sqrt(n))\n\
    \  var result = 1\n  for divisor in 2..lim {\n    if (n % divisor) == 0 {\n  \
    \    if result > divisor {\n        result = divisor\n      }\n    }\n  }\n  return\
    \ result", "    var i: Int = 0\n    var max: Int = 0\n    var factor: Int = 0\n\
    \    for factor in 2...n {\n        if n % factor == 0 {\n            if max <\
    \ factor-1 {\n                max = factor-1\n            }\n        }\n    }\n\
    \    if max > 2 {\n        i = 2\n        while i <= max {\n            i += 2\n\
    \            if n % i == 0 {\n                if max < i {\n                 \
    \   max = i\n                }\n            }\n        }\n    }\n    return max",
  "\tvar largest : Int = 0\n\tfor var i = 1; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\
    \t\tif largest < i {\n\t\t\t\tlargest = i\n\t\t\t}\n\t\t}\n\t}\n\treturn largest",
  "    let i = 2\n    var primes: Set<Int> = []\n    while i < n {\n        for prime\
    \ in primes.reverse() {\n            if n % i == 0 {\n                break\n\
    \            }\n            if prime == n {\n                primes.insert(i)\n\
    \                break\n            }\n        }\n        i += 1\n    }\n    return\
    \ primes.last ?? 1", "    if n < 2 || n%2 == 0 || is_prime(n) == false {\n   \
    \     return n\n    }\n    var i: Int\n    var factor: Int\n    for i = 2; i <=\
    \ sqrt(n); i++ {\n        if n%i==0 {\n            factor = i\n            break\n\
    \        }\n    }\n    if factor > n-1 {\n        factor = n - factor\n    }\n\
    \    return factor", "    var sieve: [Int] = []\n    var i: Int = 0\n    while\
    \ i < n {\n        sieve.append(1)\n        for d in 2..<(Int(n/2)) {\n      \
    \      if sieve[d] == 0 {\n                for k in 2..<n {\n                \
    \    if sieve[k] == 0 {\n                        sieve[k] = 1\n              \
    \          if k*d == n {\n                            return k\n             \
    \           }\n                        break\n                    }\n        \
    \        }\n            }\n        }\n        i += 1\n    }\n    return 1", " \
    \   // base case: prime number\n    if n == 1 {\n        return n\n    }\n   \
    \ // recursive case: find the largest factor of n\n    let largestFactor = largest_prime_factor(n/2)\n\
    \    // if n is divisible by largest factor then n must be prime\n    if n % largestFactor\
    \ == 0 {\n        return largestFactor\n    }\n    // otherwise n must be composite\
    \ or is prime\n    return n", "    let max_divisor = 10_000_000_000_000_000\n\
    \    let max_divisor = Int(log10(max_divisor))\n\n    var i = 0\n    var divisor\
    \ = Int(sqrt(n))\n\n    while i <= max_divisor && divisor != 1 {\n        if n\
    \ % divisor == 0 {\n            divisor = Int(sqrt(n))\n        } else {\n   \
    \         divisor = Int(n / divisor)\n        }\n        i += 1\n    }\n\n   \
    \ if divisor == 1 {\n        return n\n    }\n    return divisor", "    if n <\
    \ 2 {\n        return n\n    }\n    var maxFactor = Int64(n)\n    var currentFactor\
    \ = Int64(n + 1)\n    for factor in 2..Int(sqrt(n)) {\n        if n % factor ==\
    \ 0 {\n            currentFactor = factor\n        }\n        maxFactor = max(maxFactor,\
    \ currentFactor)\n    }\n    return maxFactor", "    var result: Int = 0\n   \
    \ var p: Int = n - 1\n    while p != 1 {\n        if p * p > n {\n           \
    \ break\n        }\n        let factor = 2\n        while factor * factor <= p\
    \ {\n            p /= factor\n            factor *= 2\n        }\n        result\
    \ = max(result, factor)\n    }\n    return result", "    if n < 2 {\n        return\
    \ 2\n    }\n    var max_factor = 1\n    for factor in 2...n {\n        if n %\
    \ factor == 0 {\n            if factor > max_factor {\n                max_factor\
    \ = factor\n            }\n        }\n    }\n    return max_factor", '    return
    largest_prime_factor_generic(n: n)', '    return n % 2 ? largest_prime_factor(n:
    n / 2) : sqrt(n)', "  precondition(n > 1, \"n must be > 1\")\n  if n == 1 || n\
    \ == 2 {\n    return n\n  }\n  var max = 2\n  var factor = 3\n  for index in 2..<Int(ceil(sqrt(Double(n)))\
    \ - 1) {\n    if n % index == 0 {\n      if factor * factor == n {\n        return\
    \ factor\n      }\n      factor *= index\n      max = factor\n    }\n  }\n  return\
    \ max", "  precondition(n > 1, \"n must be greater than 1\")\n  if n == 1 {\n\
    \    return 1\n  }\n  var max_factor = 2\n  var max_factor_index: Int = 0\n  for\
    \ i in 1..n {\n    var new_factor = 1\n    for j in 1..i {\n      if i%j == 0\
    \ {\n        new_factor++\n      }\n    }\n    if new_factor > max_factor {\n\
    \      max_factor = new_factor\n      max_factor_index = i\n    }\n  }\n  return\
    \ max_factor_index", "  if n < 2 {\n    return 1\n  }\n  if n == 2 {\n    return\
    \ 2\n  }\n\n  var factor: Int = 2\n  var p: Int = 0\n\n  for p in 2...n {\n  \
    \  var d: Int = 0\n\n    while n % p == 0 {\n      n /= p\n      d++\n    }\n\n\
    \    if d == 0 {\n      factor = p\n      break\n    }\n\n    if d > factor {\n\
    \      factor = d - 1\n    }\n  }\n\n  return factor", "    n %= 1_000_000_000\n\
    \    if n == 0 {\n        return 0\n    }\n    var i = 2\n    var p: Int = 0\n\
    \    var c: Int = 0\n    while i <= n {\n        c = n % i\n        if c == 0\
    \ {\n            p += i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return p", "    var largest = Int(1)\n    for number\
    \ in 2...n {\n        for factor in 2...number {\n            if number % factor\
    \ == 0 {\n                largest = number\n                break\n          \
    \  }\n        }\n    }\n    return largest", "  let limit = sqrt(Double(n))\n\
    \  guard limit >= 3 else { return n }\n  var max = 0\n  var i = 1\n  while i <=\
    \ limit {\n    var j = 1\n    while j * j <= i {\n      if n % i == 0 {\n    \
    \    if max < i {\n          max = i\n        }\n        while n % i == 0 {\n\
    \          n /= i\n          j++\n        }\n        break\n      }\n      j++\n\
    \    }\n    i++\n  }\n  return max", "\treturn largest_prime_factor_of_list(prime_factors_of(n))",
  "  var max_factor = 1\n  for factor in 2...Int(sqrt(Double(n))) {\n    while n %\
    \ factor == 0 {\n      max_factor = factor\n      n /= factor\n    }\n  }\n  return\
    \ max_factor", "  if n <= 1 {\n    return 1\n  }\n\n  var i = 1\n  var x = 1\n\
    \  var l = sqrt(n)\n\n  while i <= l {\n    if n % i == 0 {\n      x = x * i\n\
    \      if n / i == i {\n        return i\n      }\n    }\n    i += 2\n  }\n\n\
    \  return x", "    if n < 1 {\n        return -1\n    }\n    // Fast shrinking\n\
    \    if n == 1 {\n        return 2\n    }\n    // Check for small factors\n  \
    \  if isSmall(n) {\n        return primes[(n - 1) >> 2]\n    }\n    var max =\
    \ n - 1\n    var largestPrimeFactor = 2\n    var p : Int\n    for p = 2 ; p <=\
    \ max ; p <<= 1 {\n        if isPrime(p) {\n            largestPrimeFactor = p\n\
    \        }\n    }\n    return largestPrimeFactor", "    let max_factors = [Int]()\n\
    \    for i in 2...n {\n        if n % i == 0 {\n            var factors = Int(i)\
    \ + 1\n            while n % (factors - 1) == 0 {\n                factors +=\
    \ 2\n            }\n            max_factors.append(factors)\n        }\n    }\n\
    \    return max_factors.max()!", "    if n < 2 {\n        return 0\n    }\n\n\
    \    let limit = Int(ceil(sqrt(Double(n))))\n    var factor = 2\n    var i = 2\n\
    \    var j = limit\n\n    while i <= j {\n        while n % i == 0 {\n       \
    \     n /= i\n            factor++\n        }\n\n        if n != 1 {\n       \
    \     break\n        }\n\n        i += 1\n        j -= 1\n    }\n\n    if n ==\
    \ 1 {\n        return factor\n    }\n\n    if n > 1 {\n        factor++\n    }\n\
    \n    return factor", "    let largest = 1\n    for i in 2..<n / 2 {\n       \
    \ if n % i == 0 {\n            largest = i\n            break\n        }\n   \
    \ }\n    return largest", "    let factors: Dictionary<Int, Int> = [1: 1]\n\n\
    \    for factor in 2...n {\n        if factors[factor] == nil {\n            let\
    \ multiple = factor * factor\n            var newFactors: Dictionary<Int, Int>\
    \ = factors\n            for (_, factor) in factors {\n                if factor\
    \ == multiple {\n                    break\n                }\n              \
    \  newFactors[factor] = multiple\n            }\n            factors = newFactors\n\
    \        }\n    }\n\n    return factors[1]!", "    let max = (n-1) / 2\n    \n\
    \    for x in 2..<n {\n        if (n%x) == 0 {\n            max = x\n        \
    \    break\n        }\n    }\n    return max", "    var i: Int = 0\n    var factor:\
    \ Int = 1\n    var factors: Int = 1\n    var num: Int\n    var prime: Int\n  \
    \  var factorFound: Bool = false\n\n    for num in 0 ..< n {\n        if n % num\
    \ == 0 {\n            factorFound = false\n            for prime in 0 ..< i {\n\
    \                if num % prime == 0 {\n                    factorFound = true\n\
    \                    factors = factor * prime\n                    break\n   \
    \             }\n            }\n\n            if !factorFound {\n            \
    \    factors = factor * num\n            }\n        }\n\n        i += 1\n    }\n\
    \n    return factors", "    // TODO: make it faster\n    if n == 1 { return 1\
    \ }\n    var res = 1\n    var m = 2\n    while n / 2 >= m {\n        if n % m\
    \ == 0 {\n            res = m\n            break\n        }\n        m += 1\n\
    \    }\n    return res", "    var factor: Int = 0\n    var max_factor = 0\n  \
    \  for i = 2; i <= sqrt(n); i++ {\n        if n % i == 0 {\n            factor\
    \ *= i\n            if factor > max_factor {\n                max_factor = factor\n\
    \            }\n        }\n    }\n    return max_factor", "\t\n\tlet a = Int(sqrt(Double(n)))\n\
    \tvar b: Int = 1\n\tvar i: Int = 0\n\t\n\tfor i < a {\n\t\tlet b = (n / i) * Int(i)\n\
    \t\t\n\t\tif b < n {\n\t\t\tb = n\n\t\t}\n\t\t\n\t\tif !is_prime(b) {\n\t\t\t\
    break\n\t\t}\n\t\t\n\t\ti = i + 1\n\t}\n\t\n\tif i == a {\n\t\treturn n\n\t}\n\
    \t\n\tlet c = Int(sqrt(Double(n)))\n\t\n\tvar factor: Int = 0\n\t\n\tfor i <=\
    \ c {\n\t\tlet b = (n / i) * Int(i)\n\t\t\n\t\tif b < n {\n\t\t\tb = n\n\t\t}\n\
    \t\t\n\t\tif !is_prime(b) {\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tif b == n {\n\t\t\t\
    return n\n\t\t}\n\t\t\n\t\tif factor > b {\n\t\t\tfactor = b\n\t\t}\n\t\t\n\t\t\
    i = i + 1\n\t}\n\t\n\treturn factor", "    var largest = 1\n\n    for factor in\
    \ 2...n {\n        if factor > largest * n / factor {\n            largest = factor\n\
    \        }\n    }\n\n    return largest", "\tvar d : Int = 0\n\tlet i = 2\n\t\
    var is_prime : Bool = true\n\tlet is_prime : Bool = false\n\tvar factor : Int\
    \ = 0\n\n\tvar limit : Int = (n - 1)/2 + 1\n\tfor i <= limit {\n\t\tif is_prime\
    \ == true {\n\t\t\tbreak\n\t\t}\n\t\td = n%i\n\t\tif d == 0 {\n\t\t\tis_prime\
    \ = false\n\t\t\tfactor = d\n\t\t\tbreak\n\t\t}\n\t\ti += 1\n\t}\n\treturn factor",
  "    let result = 1\n    let m = 2\n\n    // Find smallest m such that m divides\
    \ n\n    while m <= (sqrt(Double(n))).truncatingRemainder(dividingBy: m) + 1 {\n\
    \        m += 1\n    }\n\n    // Try divisors until m == sqrt(n)\n    while m\
    \ <= (sqrt(Double(n))).truncatingRemainder(dividingBy: m) + 1 {\n        if n\
    \ % m == 0 {\n            m += 1\n        } else {\n            break\n      \
    \  }\n    }\n\n    // Return largest prime factor of n\n    return m", "\tvar\
    \ largest : Int = 0\n\n\tif n < 2 {\n\t\treturn 0\n\t}\n\n\tif n == 2 {\n\t\t\
    return 1\n\t}\n\n\tlet n = n / 2\n\n\twhile n > 1 {\n\n\t\tvar p = 2\n\t\tvar\
    \ q = (n-1) / 2\n\n\t\twhile q > 1 {\n\n\t\t\tif p * q == n {\n\t\t\t\treturn\
    \ p\n\t\t\t}\n\n\t\t\tp++\n\t\t\tq--\n\t\t}\n\t\tn--\n\t}\n\treturn largest",
  "    if n < 1 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n  \
    \  }\n    var max : Int = 2\n    for next in 2...n {\n        if n % next == 0\
    \ {\n            max += 1\n        }\n    }\n    return max", "    guard n >=\
    \ 1 else {\n        return 0\n    }\n    func isPrime(number: Int) -> Bool {\n\
    \        for div in [2, 3] {\n            if number % div == 0 {\n           \
    \     return false\n            }\n        }\n        return true\n    }\n   \
    \ \n    var largestPrimeFactor = 1\n    var largestPrimeFactorFound = false\n\
    \    \n    for factor in 2..<n {\n        if isPrime(factor) {\n            largestPrimeFactorFound\
    \ = true\n            break\n        } else {\n            let largestPrimeFactor\
    \ = factor\n        }\n    }\n    \n    if largestPrimeFactorFound {\n       \
    \ return largestPrimeFactor\n    } else {\n        return 0\n    }", "  var max\
    \ = 1\n  for i in 2...n {\n    if n % i == 0 {\n      max = i\n    }\n  }\n  return\
    \ max", "    var result = 1\n    for divisor in 2...n {\n        for divisor_prime\
    \ in 2...n {\n            if divisor_prime != divisor {\n                let product\
    \ = n * divisor\n                if product > divisor_prime {\n              \
    \      result = divisor\n                    break\n                }\n      \
    \      }\n        }\n    }\n    return result", "    // base case: n is prime\n\
    \    if n == 1 {\n        return 2\n    }\n    // base case: n has at least 2\
    \ factors\n    if n >= 2 && n % 2 == 0 {\n        return 2\n    }\n    // base\
    \ case: n is divisible by 3 and 2\n    if n >= 3 && n % 3 == 0 {\n        return\
    \ 3\n    }\n    // base case: n is divisible by 2 and 3\n    if n % 2 == 0 {\n\
    \        return largest_prime_factor(Int(n/2)) + 1\n    }\n    if n % 3 == 0 {\n\
    \        return largest_prime_factor(Int(n/3)) + 1\n    }\n    // otherwise, assume\
    \ n is prime\n    return n", "  if n < 2 {\n    return 1\n  }\n  var candidate\
    \ = 2\n  var largest = 2\n  var factor = 0\n  for factor < n / 2 {\n    candidate\
    \ += 2\n    if n == candidate*candidate {\n      if largest < factor {\n     \
    \   largest = factor\n      }\n      factor++\n    }\n  }\n  return largest",
  "  var max_factor = 0\n  var max_factor_pos = 0\n  for factor in factors {\n   \
    \ if n % (factor as Int) == 0 {\n      if max_factor < factor {\n        max_factor\
    \ = factor\n        max_factor_pos = factor\n      }\n    }\n  }\n  return max_factor_pos",
  "    let max = (Int(sqrt(Double(n))) + 1) >> 1\n    let i = 2\n    var j = 2\n \
    \   var p = 1\n    while i <= max {\n        j = i + 2\n        while j * j <=\
    \ n {\n            p += 1\n            j += 2\n        }\n        if n % i ==\
    \ 0 {\n            if p > i {\n                return p\n            } else {\n\
    \                return i\n            }\n        }\n        i += 1\n    }\n \
    \   return p", "    // TODO(pjb): There are faster algorithms for this.\n    if\
    \ n <= 1 {\n        return n;\n    }\n    // Limit ourselves to small numbers.\n\
    \    switch n {\n    case 2:\n        return 2;\n    case 3:\n        return 3;\n\
    \    case 4:\n        return 2;\n    case 5:\n        return 3;\n    case 6:\n\
    \        return 5;\n    case 7:\n        return 5;\n    case 8:\n        return\
    \ 7;\n    case 9:\n        return 7;\n    case 10:\n        return 10;\n    case\
    \ 11:\n        return 17;\n    case 12:\n        return 5;\n    case 13:\n   \
    \     return 5;\n    case 14:\n        return 10;\n    case 15:\n        return\
    \ 20;\n    case 16:\n        return 55;\n    case 17:\n        return 10;\n  \
    \  case 18:\n        return 13;\n    case 19:\n        return 16;\n    case 20:\n\
    \        return 35;\n    case 21:\n        return 10;\n    case 22:\n        return\
    \ 35;\n    case 23:\n        return 52;\n    case 24:\n        return 10;\n  \
    \  case 25:\n        return 55;\n    case 26:\n        return 105;\n    case 27:\n\
    \        return 125;\n    case 28:\n        return 56;\n    case 29:\n       \
    \ return 87;\n    case 30:\n        return 105;\n    case 31:\n        return\
    \ 125;\n    case 32:\n        return 71;\n    case 33:\n        return 97;\n \
    \   case 34:\n        return 131;\n    case 35:\n        return 147;\n    case\
    \ 36:\n        return 174;\n    case 37:\n        return 202;\n    case 38:\n\
    \        return 227;\n    case 39:\n        return 243;\n    case 40:\n      \
    \  return 257;\n    case 41:\n        return 283;\n    case 42:\n        return\
    \ 317;\n    case 43:\n        return 324;\n    case 44:\n        return 333;\n\
    \    case 45:\n        return 341;\n    case 46:\n        return 348;\n    case\
    \ 47:\n        return 354;\n    case 48:\n        return 369;\n    case 49:\n\
    \        return 375;\n    case 50:\n        return 389;\n    case 51:\n      \
    \  return 395;\n    case 52:\n        return 411;\n    case 53:\n        return\
    \ 418;\n    case 54:\n        return 427;\n    case 55:\n        return 434;\n\
    \    case 56:\n        return 443;\n    case 57:\n        return 449;\n    case\
    \ 58:\n        return 455;\n    case 59:\n        return 461;\n    case 60:\n\
    \        return 467;\n    case 61:\n        return 472;\n    case 62:\n      \
    \  return 477;\n    case 63:\n        return 483;\n    case 64:\n        return\
    \ 487;\n    case 65:\n        return 494;\n", "    let i = 2\n    var m = 1\n\
    \    for factor in 2..Int(sqrt(Double(n))) + 1 {\n        if n % i == 0 {\n  \
    \          m = i\n        }\n        i += 1\n    }\n    return m", "    if n <\
    \ 2 {\n        return 2\n    }\n\n    let i = 2\n    let maxDivisor = 2\n    let\
    \ divisors = 2\n\n    while i <= n {\n        if n % i == 0 {\n            maxDivisor\
    \ = max(maxDivisor, divisors)\n        }\n\n        divisors += 1\n\n        if\
    \ divisors > maxDivisor {\n            break\n        }\n\n        i += 1\n  \
    \  }\n\n    return maxDivisor", "  if n <= 1 {\n    return 0\n  }\n  var max =\
    \ 2\n  var prime = true\n  for i = 2; i <= n / 2; i++ {\n    if n % (i + 2) ==\
    \ 0 {\n      prime = false\n      break\n    }\n    if prime && n > 1 {\n    \
    \  if i * i > n {\n        return max\n      }\n      if i * i == n {\n      \
    \  max = i\n      }\n    }\n  }\n  return max", "    if n <= 1 {\n        return\
    \ n\n    }\n    if n == 2 {\n        return 3\n    }\n    if n <= 3 {\n      \
    \  return 2\n    }\n    if n == 4 || n == 5 {\n        return 2\n    }\n    if\
    \ n % 2 == 0 || n % 3 == 0 {\n        return n\n    }\n    if n % 5 == 0 {\n \
    \       return 2\n    }\n    if n % 3 == 0 {\n        return 3\n    }\n    var\
    \ factors = primeFactors(n: n)\n    var largest = primeFactors(n: n)[0]\n    var\
    \ largestPrime: Int\n    for factor in factors {\n        if largest < factor\
    \ {\n            largest = factor\n            largestPrime = factor\n       \
    \ }\n    }\n    return largestPrime", "\tif n < 2 {\n\t\treturn 0\n\t}\n\tlargestPrimeNum\
    \ := 2\n\tlargestPrimePos := 0\n\tlargestPrimeFactors := []int{}\n\tfactors :=\
    \ Factors(n)\n\tlargestPrimeFactors = append(largestPrimeFactors, factors[0])\n\
    \tfor i, factor := range factors[1:] {\n\t\tif largestPrimeNum*factor <= n {\n\
    \t\t\tlargestPrimeNum *= factor\n\t\t\tlargestPrimeFactors = append(largestPrimeFactors,\
    \ factor)\n\t\t\tlargestPrimePos = i\n\t\t}\n\t}\n\treturn largestPrimeNum", " \
    \   var largest = 0\n    largest = prime_factors(n)[0]\n    for d in prime_factors(n){\n\
    \        if d == largest{\n            break\n        }\n        if d > largest{\n\
    \            largest = d\n        }\n    }\n    return largest", "    let max\
    \ = 4\n    var a = 2\n    \n    for i in 2..<n {\n        if n % i == 0 {\n  \
    \          if a > i {\n                a = i\n            }\n        } else {\n\
    \            if a > max {\n                max = a\n            }\n          \
    \  a = i\n        }\n    }\n    \n    return max", "    assert(n >= 2, \"need\
    \ n >= 2\")\n    var p = 2\n    var q = 1\n    while q * p <= n {\n        p =\
    \ q\n        q *= p\n    }\n    while n > 1 {\n        if (n % p == 0) n /= p\n\
    \        else p = p + 1\n    }\n    return q", "\tlargestPrimeFactor(n)", "  \
    \  var result = 1\n    var maxFactor = 2\n    for _ in 0..<n {\n        var newFactor\
    \ = result / maxFactor\n        if newFactor != 1 {\n            if newFactor\
    \ > result {\n                result = newFactor\n            }\n            if\
    \ result > maxFactor {\n                maxFactor = newFactor\n            }\n\
    \        }\n    }\n    return result", "    assert(n > 1)\n    let n = Int(n)\n\
    \    let max = (n-1).bit_length()\n    if max == 0 {\n        return 1\n    }\n\
    \    var p = 2\n    var factor = 2\n    while true  {\n        if n % p == 0 {\n\
    \            factor = p\n            n = n / factor\n            if n < 1 {\n\
    \                return factor\n            }\n        }\n        else {\n   \
    \         p++\n        }\n        if max == p {\n            return factor\n \
    \       }\n    }", '    return prime_factor(sqrt(Double(n)))', "    if n < 2 {\n\
    \        return 2\n    }\n    if n % 2 == 0 {\n        return largest_prime_factor(n\
    \ - 2)\n    }\n\n    // TODO: Improve the performance of this algorithm.\n   \
    \ var result: Int = 1\n    var i: Int = 0\n    while i*result <= n {\n       \
    \ if n % i == 0 {\n            result = result*i\n            n = n / i\n    \
    \    } else {\n            i += 1\n        }\n    }\n    return result", "  if\
    \ n <= 1 {\n    return 1\n  }\n  let max_p = 2\n  var max_d = 1\n  var max_q =\
    \ n\n  var max_r = n\n  var p = 1\n  while (true) {\n    let q = (max_q * max_q)\
    \ >> 1\n    let r = (max_r * max_r) >> 1\n    if q*q <= r {\n      break\n   \
    \ }\n    let m = max_q + max_r\n    if m > max_d {\n      max_d = m\n    }\n \
    \   if p > max_p {\n      max_p = p\n    }\n    max_q = q\n    max_r = r\n  }\n\
    \  return max_p", "    let sieve: [Bool] = [true, false, true, true, true, true,\
    \ false, true, true, true, true, true, true, true, true]\n    var p = 2\n    let\
    \ maxPrime = n.toInt() / 2\n    while p <= maxPrime {\n        if sieve[p] {\n\
    \            p = p * 2 + 1\n        }\n        else {\n            p += 1\n  \
    \      }\n    }\n    return p", "    var max_factor = 1\n    var max_factor_n:\
    \ Int\n    for f in 2...n {\n        if n % f == 0 {\n            if max_factor\
    \ < f {\n                max_factor = f + max_factor\n                max_factor_n\
    \ = f\n            }\n        }\n    }\n    return max_factor_n", "    if n <\
    \ 2 {\n        return 2\n    }\n\n    if n == 2 {\n        return 2\n    }\n\n\
    \    if n > 2 && n % 2 == 0 {\n        return 2\n    }\n\n    func primeFactorsIterator()\
    \ -> Iterator<Int> {\n        var factor = 2\n        var current = 1\n\n    \
    \    return Iterator<Int> {\n            while current <= n {\n              \
    \  while current % factor == 0 {\n                    current /= factor\n    \
    \            }\n\n                factor++\n            }\n\n            return\
    \ nil\n        }\n    }\n\n    var largestPrimeFactor: Int = 2\n\n    for prime\
    \ in primeFactorsIterator() {\n        if prime > n {\n            break\n   \
    \     }\n\n        if prime > largestPrimeFactor {\n            largestPrimeFactor\
    \ = prime\n        }\n    }\n\n    return largestPrimeFactor", "    var max :\
    \ Int = 0\n    var factors : [Int] = []\n\n    for i in 2...n {\n        if (n\
    \ / i) == i {\n            factors.append(i)\n            if (max < i) {\n   \
    \             max = i\n            }\n        }\n    }\n\n    return max", " \
    \ var factor = 1\n  repeat {\n    if n % factor == 0 {\n      if factor * factor\
    \ > n {\n        return factor\n      }\n      factor++\n    }\n  } while (factor\
    \ <= Int(log_of_prime_factor(n)))\n  return Int(log_of_prime_factor(n))", "\t\
    // TODO: Factor this out to support multiple inputs\n\tlet x = n\n\tlet r = 2\n\
    \n\twhile x % r != 0 {\n\t\tx = x / r\n\t\tr = r + 1\n\t}\n\n\treturn r", "\t\
    let mut result = 2\n\tfor num in 2..Int(sqrt::<Int>(n)) {\n\t\tlet a = Int(sqrt(num))\n\
    \t\tif a > result {\n\t\t\tresult = a\n\t\t}\n\t}\n\tresult", "    let sieve:\
    \ [Int] = Array(0 ..< n).filter {\n        (n: Int) -> Bool in\n        n % 2\
    \ != 0\n    }\n\n    guard n > 2 else { return 2 }\n\n    if sieve.contains(1)\
    \ {\n        return n\n    }\n\n    for i in 2..<n {\n        if sieve.contains(i)\
    \ {\n            let temp = sieve.removeAtIndex(i - 1)\n            return n *\
    \ temp\n        }\n    }\n\n    return n", "\tlet p = 2\n\tvar m = 2\n\tvar i\
    \ = 2\n\twhile i * p <= n {\n\t\tif n % i == 0 {\n\t\t\tp = p + (n / i)\n\t\t\
    } else {\n\t\t\tm = m + (n / i)\n\t\t}\n\t\ti = i + 1\n\t}\n\tif m > p {\n\t\t\
    return m\n\t}\n\treturn p", "    // https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n\
    \    if n == 1 {\n        return n\n    }\n    var largest = 1\n    for test in\
    \ 2...Int(sqrt(n)) {\n        if n % test == 0 {\n            if largest*test\
    \ > n {\n                largest = test\n            }\n        } else if test\
    \ > largest/2 {\n            largest = test\n        }\n    }\n    return largest",
  "    var result = 1\n    for i in 2...n {\n        if n % i == 0 {\n           \
    \ result = i\n            break\n        }\n    }\n    return result", "\tif n\
    \ <= 1 {\n\t\treturn 1\n\t}\n\tvar max = n\n\tfor i := 2; i < max; i++ {\n\t\t\
    if n % i == 0 {\n\t\t\tmax /= i\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\
    \ max", "\tlet factors = factors(n)\n\treturn factors.count > 0 ? factors.max\
    \ : n", "    var max_factor = 0\n    for candidate in 2...Int(sqrt(Double(n)))\
    \ {\n        if n % candidate == 0 {\n            let factor: Int = Int(Double(n)\
    \ / Double(candidate))\n            if factor > max_factor {\n               \
    \ max_factor = factor\n            }\n        }\n    }\n    return max_factor",
  "    let factors = prime_factors(n)\n    if factors.count > 0 {\n        return\
    \ factors.max()!\n    }\n    return n", "    var candidate: Int\n    if n <= 1\
    \ {\n        return n\n    }\n    if n == 2 || n == 3  {\n        return 1\n \
    \   }\n    if n == candidate {\n        return n\n    }\n    for candidate in\
    \ 2..<n {\n        if n%candidate == 0 {\n            return candidate\n     \
    \   }\n    }\n    return n", "    var nfactors = [1]\n    \n    func loop(_ factors:\
    \ Int, n: Int) {\n        if factors == 1 {\n            nfactors = [n]\n    \
    \    } else {\n            for i in 2...n {\n                if factors[i] ==\
    \ 0 {\n                    continue\n                } else {\n              \
    \      for j in 2...(factors - 1) { \n                        if j % i == 0 {\n\
    \                            break\n                        } else {\n       \
    \                     factors[j] += 1\n                            nfactors.append(j)\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    \n    loop(nfactors, n)\n    \n    return nfactors.max!",
  "    let max_divisor = n - 1\n    if max_divisor < 1 {\n        return 0\n    }\n\
    \n    if n % 2 == 1 {\n        return 2\n    }\n\n    for i in 3...max_divisor\
    \ / 2 {\n        if n % i == 0 {\n            return i\n        }\n    }\n   \
    \ return max_divisor", "    var max_factor = 1\n    for factor in 2...n {\n  \
    \      if n % factor == 0 {\n            max_factor = factor\n            break\n\
    \        }\n    }\n    return max_factor", "    // Sieve of Eratosthenes\n   \
    \ let table = [Int](count: n + 1, repeatedValue: 0)\n    for index in 0..<n {\n\
    \        if index == 0 || table[index] != 0 {\n            continue\n        }\n\
    \        \n        var next_i = 2\n        \n        while next_i*next_i <= n\
    \ {\n            table[next_i] = 0\n            next_i += 2\n        }\n\n   \
    \     table[index] = 1\n    }\n\n    return table[n]", "    if n < 2 {\n     \
    \   return 2\n    }\n    \n    let factors = [2..<n]\n    var largest = 1\n  \
    \  for i in factors {\n        if n % i == 0 {\n            largest = i\n    \
    \    }\n    }\n    \n    return largest", "    if n < 2 {\n        return 0\n\
    \    }\n    \n    let primes = Array<Int>()\n    for i in 2...Int(Int(sqrt(Double(n)))\
    \ + 1) {\n        if n % i == 0 {\n            primes.append(i)\n        }\n \
    \   }\n    \n    return primes.reduce(0, {max($0 + 1, $1)})", "    // TODO: implement\
    \ this function\n    return 0", "    if n < 2 {\n        return 1\n    }\n   \
    \ var maxPrime: Int = 0\n    var i = 2\n    var isPrime = true\n    for i <= n\
    \ / 2 {\n        if n % i == 0 {\n            isPrime = false\n            break\n\
    \        }\n    }\n    if isPrime {\n        for i : Int in 2...n / 2 {\n    \
    \        if n % i == 0 {\n                maxPrime = max(maxPrime, i)\n      \
    \      }\n        }\n    }\n    return maxPrime", "    let max = 2\n\n    // Loop\
    \ through the numbers of multiples of n and decrement 'max' until 'max' is no\
    \ longer greater than or equal to n and smaller than n.\n    for i in 2...n {\n\
    \        if n % i == 0 {\n            max -= 1\n            if max <= 0 || n !=\
    \ 2 {\n                return i\n            }\n        }\n    }\n    return n",
  "    if n < 2 {\n        return n\n    }\n    if isPrime(n) {\n        return n\n\
    \    }\n    \n    let candidate = Int(log2(n))\n    var factor = 1\n    var divisor\
    \ = 2\n    var found = false\n    var isPrime = true\n    while divisor < n {\n\
    \        while divisor < n && n % divisor == 0 {\n            divisor *= 2\n \
    \       }\n        if n == divisor {\n            found = true\n            break\n\
    \        }\n        if n > divisor {\n            found = false\n            break\n\
    \        }\n        n = Int(n/divisor)\n        factor++\n        divisor *= 2\n\
    \    }\n    while factor != candidate {\n        isPrime = false\n        for\
    \ p in 2...Int(log2(factor)) {\n            if factor % p == 0 {\n           \
    \     isPrime = false\n                break\n            }\n        }\n     \
    \   if isPrime {\n            return factor\n        }\n        factor++\n   \
    \ }\n    return n", "  // Optimization: start at sqrt(n) and try to factor down\n\
    \  if n <= 1 {\n    return 1\n  }\n\n  // Optimization: start at n/2 and try to\
    \ factor down\n  if n <= 2 {\n    return 2\n  }\n\n  // Optimization: start at\
    \ n/3 and try to factor down\n  if n <= 3 {\n    return 3\n  }\n\n  // Optimization:\
    \ start at n/5 and try to factor down\n  if n <= 5 {\n    return 5\n  }\n\n  //\
    \ Optimization: start at n/7 and try to factor down\n  if n <= 7 {\n    return\
    \ 7\n  }\n\n  // Optimization: start at n/10 and try to factor down\n  if n <=\
    \ 10 {\n    return 10\n  }\n\n  // Optimization: start at n/12 and try to factor\
    \ down\n  if n <= 12 {\n    return 12\n  }\n\n  // Optimization: start at n/13\
    \ and try to factor down\n  if n <= 13 {\n    return 13\n  }\n\n  // Optimization:\
    \ start at n/17 and try to factor down\n  if n <= 17 {\n    return 17\n  }\n\n\
    \  // Optimization: start at n/19 and try to factor down\n  if n <= 19 {\n   \
    \ return 19\n  }\n\n  // Optimization: start at n/21 and try to factor down\n\
    \  if n <= 21 {\n    return 21\n  }\n\n  // Optimization: start at n/23 and try\
    \ to factor down\n  if n <= 23 {\n    return 23\n  }\n\n  // Optimization: start\
    \ at n/27 and try to factor down\n  if n <= 27 {\n    return 27\n  }\n\n  // Optimization:\
    \ start at n/30 and try to factor down\n  if n <= 30 {\n    return 30\n  }\n\n\
    \  // Optimization: start at n/33 and try to factor down\n  if n <= 33 {\n   \
    \ return 33\n  }\n\n  // Optimization: start at n/37 and try to factor down\n\
    \  if n <= 37 {\n    return 37\n  }\n\n  // Optimization: start at n/41 and try\
    \ to factor down\n  if n <= 41 {\n    return 41\n  }\n\n  // Optimization: start\
    \ at n/43 and try to factor down\n  if n <= 43 {\n    return 43\n  }\n\n  // Optimization:\
    \ start at n/47 and try to factor down\n  if n <= 47 {\n    return 47\n  }\n\n\
    \  // Optimization: start at n/50 and try to factor down\n  if n <= 50 {\n   \
    \ return 50\n  }\n\n  // Optimization: start at n/53 and try to factor down\n\
    \  if n <= 53 {\n    return 53\n  }\n\n  // Optimization: start at n/57 and try\
    \ to factor down\n", "    guard n > 1 else {\n        return 1\n    }\n    guard\
    \ prime_table[n] == 1 else {\n        return prime_table[n]\n    }\n\n    let\
    \ p = 2\n    let q = 2 // set q to the highest possible power of 2 >= n\n\n  \
    \  // loop until q divides n\n    while q * p <= n {\n        // update p and\
    \ q to their next values\n        let t = p\n        p = q\n        q = t\n  \
    \  }\n\n    // at this point, q is equal to n and p is equal to q - 1\n    //\
    \ return p as the largest prime factor\n    return p", "    if n == 1 {\n    \
    \    return 1\n    }\n    if n%2 == 1 {\n        return 2\n    }\n    var i :\
    \ Int = 0\n    while n % i == 0 {\n        i = 2\n        while i * i < n {\n\
    \            i += 1\n        }\n    }\n    return i", "\treturn sieve_of_eratosthenes(n)[n-1]",
  "    if n == 1 { return 0 }\n    var i = 2\n    var m = 0\n    while i < n {\n \
    \       m = i + (n / i)\n        if m == i { break }\n        i = m\n    }\n \
    \   return i", "    // Based on http://stackoverflow.com/questions/10709750/finding-the-highest-prime-factor-of-a-number\n\
    \    guard n > 2 else {\n        return 0\n    }\n\n    var p: Int = 1\n    var\
    \ factors: [Int] = []\n    var p: Int = 0\n\n    for factor in factors{\n    \
    \    if n % factor == 0 {\n            p = factor\n        } else {\n        \
    \    break\n        }\n    }\n\n    while true{\n        if n % p == 0 {\n   \
    \         factors.append(p)\n            n /= p\n        } else {\n          \
    \  return p\n        }\n    }", "  if n < 2 {\n    return 0\n  }\n  var maxfactor:\
    \ Int = 0\n  var candidate: Int = (n - 1)\n\n  // Keep doubling the candidate\
    \ while it divides evenly.\n  while (candidate % 2 == 0) {\n    candidate /= 2\n\
    \    maxfactor++\n  }\n  // Check all odd numbers, including the candidate.\n\
    \  // If prime, return candidate.\n  // If not prime, return the largest prime\
    \ factor of candidate.\n  for candidate > 1 {\n    if isPrime(candidate) {\n \
    \     return candidate\n    }\n    if candidate % candidate == 0 {\n      candidate\
    \ = (candidate + 2) >> 1\n      maxfactor++\n    }\n  }\n  return maxfactor",
  "\tif n < 2 {\n\t\treturn 1\n\t}\n\n\t// Set a limit on max number of iterations,\
    \ to prevent an infinite loop.\n\tconst maxIter = 1000000\n\n\tvar factor: Int\
    \ = 0\n\n\tfor i := 2; i <= n/2; i += 1 {\n\t\tfactor := i\n\n\t\tfor j := i *\
    \ i; j < n; j += i {\n\t\t\tfactor++\n\t\t\tif factor > n {\n\t\t\t\treturn factor\n\
    \t\t\t}\n\t\t}\n\t}\n\n\treturn factor", "    var max_factor = 0\n    var current_factor\
    \ = 1\n    \n    // Find the largest factor that doesn't exceed the square of\
    \ n.\n    for divisor in 2..Int(sqrt(n)) {\n        if n % divisor == 0 {\n  \
    \          max_factor = divisor\n            break\n        }\n    }\n    \n \
    \   // If max_factor == 0 then there are no factors.\n    if max_factor == 0 {\n\
    \        return 1\n    }\n    \n    // Find the next largest factor that exceeds\
    \ the square of n.\n    for divisor in 2..Int(sqrt(n)) {\n        if n % divisor\
    \ == 0 {\n            if divisor > max_factor {\n                max_factor =\
    \ divisor\n            }\n            break\n        }\n    }\n    \n    return\
    \ max_factor", "    var maxFactor = n - 1\n\n    for factor = 2; factor <= maxFactor;\
    \ factor++ {\n        if n % factor == 0 {\n            maxFactor = factor\n \
    \       } else {\n            break\n        }\n    }\n\n    return maxFactor",
  "    if n < 2 {\n        return 0\n    }\n\n    if n == 2 || n == 3 {\n        return\
    \ 2\n    }\n\n    var highest = 2\n    for p in 2...n {\n        if n % p == 0\
    \ {\n            if p*p > highest {\n                highest = p\n           \
    \ }\n        }\n    }\n\n    return highest", '    return largestPrimeFactor(n)',
  "    var result = 2\n    var divisor = 2\n    while n > divisor * divisor {\n  \
    \      if n % divisor == 0 {\n            result *= divisor\n        }\n     \
    \   divisor += 1\n    }\n    return result", '    return largest_prime_factor_helper(n,
    n)', "  // check for trivial factors\n  var highest_factor: Int = 0\n  var highest_factor_is_prime:\
    \ Bool = false\n  for factor in factors(n) {\n    if factor.is_prime && factor\
    \ > highest_factor {\n      highest_factor = factor\n      highest_factor_is_prime\
    \ = factor.is_prime\n    }\n  }\n  if highest_factor_is_prime {\n    return highest_factor\n\
    \  }\n  \n  // now search the larger factors\n  var factors_array = [Int]()\n\
    \  for factor in factors(n) {\n    if factor.is_prime {\n      factors_array.append(factor)\n\
    \    }\n  }\n  \n  var highest_factor_of_the_array = factors_array.max()\n  if\
    \ highest_factor_of_the_array > highest_factor {\n    highest_factor = highest_factor_of_the_array\n\
    \  }\n  \n  return highest_factor", "\tassert(n > 1)\n\tassert(n % 2 == 0)\n\t\
    assert(n != 1)\n\tvar result : Int\n\t\n\tlet limit = 2\n\t\n\twhile result <\
    \ limit {\n\t\tresult = 2\n\t\t\n\t\tfor candidate in 2..<n {\n\t\t\tif n%candidate\
    \ == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tresult = candidate\n\t\t}\n\t\t\n\t\t\
    if result == 2 {\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\treturn result", "  if n == 1\
    \ {\n    return 1\n  }\n\n  var factor = 1\n  var lastFactor = 1\n  var isPrime\
    \ = true\n  for i : Int in 2..Int(ceil(sqrt(Double(n)))).reversed() {\n    if\
    \ isPrime {\n      if n % i == 0 {\n        factor *= i\n        lastFactor =\
    \ i\n      }\n      break\n    }\n\n    if n % (i * i) == 0 {\n      lastFactor\
    \ *= i\n    }\n\n    if lastFactor % i == 0 {\n      isPrime = false\n      factor\
    \ *= lastFactor\n    }\n  }\n\n  return factor", '    return factorization(n:
    n).largestPrimeFactor', '    return Int(ceil(Float(n / largest_prime_factor_factor(n:
    Float(n)))))', "    let limit = n.quotientSquared() // TODO: optimize this with\
    \ divmod\n    var factor = 2\n\n    while factor <= limit {\n        if n % factor\
    \ == 0 {\n            n = n / factor\n        } else {\n            factor++\n\
    \        }\n    }\n\n    return factor", "    if n == 0 {\n        return n\n\
    \    }\n    var max_factor = 1\n    var max_factor_is_prime = false\n    for factor\
    \ in 2..<n {\n        if n % factor == 0 {\n            if factor > max_factor\
    \ {\n                max_factor = factor\n                max_factor_is_prime\
    \ = true\n            }\n        }\n    }\n    if max_factor_is_prime {\n    \
    \    return max_factor\n    } else {\n        return largest_prime_factor(n /\
    \ 2)\n    }", "  precondition(n >= 1)\n  var result: Int = 0\n  var i = 2\n  var\
    \ p = primes[0]\n  while i <= n {\n    if n % i == 0 {\n      result = p\n   \
    \   break\n    }\n    p = primes[i]\n    i += 1\n  }\n  precondition(result !=\
    \ 0)\n  return result", "  let limit: Int = Int(floor(sqrt(n)))\n  var max_factor:\
    \ Int = 0\n  for factor in 2...limit {\n    if n % factor == 0 {\n      if max_factor\
    \ < factor {\n        max_factor = factor\n      }\n    }\n  }\n  return max_factor",
  "    let max = (sqrt(UInt32(n))).ceiling()\n    for factor in 2...max {\n      \
    \  if n % factor == 0 {\n            return factor\n        }\n    }\n    return\
    \ n", "    var result = 1\n    var p = 2\n    while p * p <= n {\n        if n\
    \ % p == 0 {\n            result *= p\n            n /= p\n        } else {\n\
    \            p++\n        }\n    }\n    return result"]
stop_tokens:
- "\n}"
