language: swift
name: HumanEval_126_is_sorted
results:
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.last == lst.first\
    \ {\n        return true\n    }\n    var last = 0\n    var cur = 0\n    var done\
    \ = false\n    while !done {\n        last = cur\n        cur = lst.firstIndex\n\
    \        while !done && cur != last {\n            if lst.array[cur] < lst.array[last]\
    \ {\n                done = true\n            } else {\n                cur =\
    \ cur + 1\n            }\n        }\n        if done {\n            return true\n\
    \        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnlu278kr.swift:31:19: error: no 'firstIndex' candidates produce\
    \ the expected contextual result type 'Int'\n        cur = lst.firstIndex\n  \
    \                ^\nSwift.Collection:2:28: note: 'firstIndex(of:)' produces '(Int)\
    \ -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>'), not the expected contextual\
    \ result type 'Int'\n    @inlinable public func firstIndex(of element: Self.Element)\
    \ -> Self.Index?\n                           ^\nSwift.Collection:2:28: note: 'firstIndex(where:)'\
    \ produces '((Int) throws -> Bool) throws -> Array<Int>.Index?' (aka '((Int) throws\
    \ -> Bool) throws -> Optional<Int>'), not the expected contextual result type\
    \ 'Int'\n    @inlinable public func firstIndex(where predicate: (Self.Element)\
    \ throws -> Bool) rethrows -> Self.Index?\n                           ^\n/tmp/tmpnlu278kr.swift:33:20:\
    \ error: value of type '[Int]' has no member 'array'\n            if lst.array[cur]\
    \ < lst.array[last] {\n               ~~~ ^~~~~\n/tmp/tmpnlu278kr.swift:33:37:\
    \ error: value of type '[Int]' has no member 'array'\n            if lst.array[cur]\
    \ < lst.array[last] {\n                                ~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    switch lst.count {\n    case\
    \ 0: return true\n    case 1: {\n        if lst[0] == lst[1] {\n            return\
    \ true\n        } else {\n            return false\n        }\n    }\n    case\
    \ 2: {\n        if lst[0] == lst[1] && lst[0] == lst[2] {\n            return\
    \ true\n        } else {\n            return false\n        }\n    }\n    case\
    \ 3: {\n        if lst[0] == lst[1] {\n            if lst[2] == lst[1] && lst[2]\
    \ == lst[3] {\n                return true\n            } else {\n           \
    \     return false\n            }\n        } else {\n            if lst[2] ==\
    \ lst[1] {\n                if lst[2] == lst[3] && lst[2] == lst[4] {\n      \
    \              return true\n                } else {\n                    return\
    \ false\n                }\n            } else {\n                if lst[2] ==\
    \ lst[3] {\n                    if lst[2] == lst[4] && lst[2] == lst[5] {\n  \
    \                      return true\n                    } else {\n           \
    \             return false\n                    }\n                } else {\n\
    \                    if lst[2] == lst[4] {\n                        if lst[2]\
    \ == lst[5] && lst[2] == lst[6] {\n                            return true\n \
    \                       } else {\n                            return false\n \
    \                       }\n                    } else {\n                    \
    \    if lst[2] == lst[5] {\n                            if lst[2] == lst[6] &&\
    \ lst[2] == lst[7] {\n                                return true\n          \
    \                  } else {\n                                return false\n  \
    \                          }\n                        } else {\n             \
    \               if lst[2] == lst[6] {\n                                if lst[2]\
    \ == lst[7] && lst[2] == lst[8] {\n                                    return\
    \ true\n                                } else {\n                           \
    \         return false\n                                }\n                  \
    \          } else {\n                                if lst[2] == lst[7] {\n \
    \                                   if lst[2] == lst[8] && lst[2] == lst[9] {\n\
    \                                        return true\n                       \
    \             } else {\n                                        return false\n\
    \                                    }\n                                } else\
    \ {\n                                    if lst[2] == lst[8] {\n             \
    \                           if lst[2] == lst[9] && lst[2] == lst[10] {\n     \
    \                                       return true\n                        \
    \                } else {\n                                            return\
    \ false\n                                        }\n                         \
    \           } else {\n                                        if lst[2] == lst[9]\
    \ {\n                                            if lst[2] == lst[10] && lst[2]\
    \ == lst[11] {\n                                                return true\n\
    \                                            } else {\n                      \
    \                          return false\n                                    \
    \        }\n                                        } else {\n               \
    \                             if lst[2] == lst[10] {\n                       \
    \                         if lst[2] == lst[11] && lst[2] == lst[12] {\n      \
    \                                              return true\n                 \
    \                               } else {\n                                   \
    \                 return false\n                                             \
    \   }\n                                            } else {\n                \
    \                                if lst[2] == lst[11] {\n                    \
    \                                if lst[2] == lst[12] && lst[2] == lst[13] {\n\
    \                                                        return true\n       \
    \                                             } else {\n                     \
    \                                   return false\n                           \
    \                         }\n                                                }\
    \ else {\n                                                    if lst[2] == lst[12]\
    \ {\n                                                        if lst[2] == lst[13]\
    \ && lst[2] == lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgt_5gfm8.swift:118:94: error: expected '{' after 'if' condition\n\
    \                                                        if lst[2] == lst[13]\
    \ && lst[2] == lst\n                                                         \
    \                                    ^\n/tmp/tmpgt_5gfm8.swift:146:45: error:\
    \ expected '}' at end of brace statement\nassert(is_sorted(lst: [1, 2, 3, 4])\
    \ == true)\n                                            ^\n/tmp/tmpgt_5gfm8.swift:116:56:\
    \ note: to match this opening '{'\n                                          \
    \      } else {\n                                                       ^\n/tmp/tmpgt_5gfm8.swift:146:45:\
    \ error: expected '}' at end of brace statement\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4]) == true)\n                                            ^\n/tmp/tmpgt_5gfm8.swift:109:52:\
    \ note: to match this opening '{'\n                                          \
    \  } else {\n                                                   ^\n/tmp/tmpgt_5gfm8.swift:146:45:\
    \ error: expected '}' at end of brace statement\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4]) == true)\n                                            ^\n/tmp/tmpgt_5gfm8.swift:102:48:\
    \ note: to match this opening '{'\n                                        } else\
    \ {\n                                               ^\n/tmp/tmpgt_5gfm8.swift:146:45:\
    \ error: expected '}' at end of brace statement\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4]) == true)\n                                            ^\n/tmp/tmpgt_5gfm8.swift:95:44:\
    \ note: to match this opening '{'\n                                    } else\
    \ {\n                                           ^\n/tmp/tmpgt_5gfm8.swift:146:45:\
    \ error: expected '}' at end of brace statement\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4]) == true)\n                                            ^\n/tmp/tmpgt_5gfm8.swift:88:40:\
    \ note: to match this opening '{'\n                                } else {\n\
    \                                       ^\n/tmp/tmpgt_5gfm8.swift:146:45: error:\
    \ expected '}' at end of brace statement\nassert(is_sorted(lst: [1, 2, 3, 4])\
    \ == true)\n                      "
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n\n    var lastNumber = lst[0]\n    for number in lst\
    \ {\n        if number != lastNumber {\n            return false\n        }\n\
    \        lastNumber = number\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpga4zueve/tmpga4zueve.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad4e467fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad4e4376b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad4e4376988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4e43757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpga4zueve                        0x000055fc6d0485d7 <unavailable> + 5591

    5    libc.so.6                          0x00002ad4e486b460 __libc_start_main +
    245

    6    tmpga4zueve                        0x000055fc6d048189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  // Initialize sorted flag\n\
    \  var sorted_flag = true\n\n  // Loop through each unique number in array\n \
    \ for num_1 in lst {\n    // Initialize a flag to hold a duplicate value\n   \
    \ var duplicate_flag = false\n\n    // Loop through each unique number in array\n\
    \    for num_2 in lst {\n      // If current number is equal to current duplicate\
    \ number\n      if num_1 == num_2 {\n        // Set duplicate flag to true\n \
    \       duplicate_flag = true\n\n        // Exit loop after setting duplicate\
    \ flag\n        break\n      }\n\n      // If current number is greater than current\
    \ duplicate number\n      if num_1 > num_2 {\n        // Set sorted flag to false\n\
    \        sorted_flag = false\n\n        // Exit loop after setting sorted flag\n\
    \        break\n      }\n    }\n\n    // If duplicate flag is true, break out\
    \ of the loop\n    if duplicate_flag {\n      break\n    }\n  }\n\n  return sorted_flag\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1pgip_9u/tmp1pgip_9u.swift:76: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1208a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab12059ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab12059a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1205997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1pgip_9u                        0x0000561420cd65f6 <unavailable> + 5622

    5    libc.so.6                          0x00002ab120a8f460 __libc_start_main +
    245

    6    tmp1pgip_9u                        0x0000561420cd60d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tguard lst.count > 1 else {\
    \ return true }\n\tlet first = lst[0]\n\tvar lastIndex = lst.count\n\t\n\tfor\
    \ idx in 0..<lst.count {\n\t\tif lst[idx] == first {\n\t\t\tlastIndex = idx -\
    \ 1\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\treturn lastIndex < lst.count && is_sorted(lst.suffix(at:\
    \ lastIndex))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphe8owaj1.swift:34:44: error: missing argument label 'lst:' in call\n\
    \        return lastIndex < lst.count && is_sorted(lst.suffix(at: lastIndex))\n\
    \                                                  ^\n                       \
    \                           lst: \n/tmp/tmphe8owaj1.swift:34:54: error: extraneous\
    \ argument label 'at:' in call\n        return lastIndex < lst.count && is_sorted(lst.suffix(at:\
    \ lastIndex))\n                                                            ^~~~~\n\
    \                                                             \n"
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Array(Set(lst))\n\
    \    return set.count == lst.count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpy2jww4c9/tmpy2jww4c9.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10334aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10331a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b10331a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10331a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2jww4c9                        0x0000556116d25636 <unavailable> + 5686

    5    libc.so.6                          0x00002b103369a460 __libc_start_main +
    245

    6    tmpy2jww4c9                        0x0000556116d25119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted_impl(lst,\
    \ 0, len(lst))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn5f7b0vz.swift:23:12: error: cannot find 'is_sorted_impl' in scope\n\
    \    return is_sorted_impl(lst, 0, len(lst))\n           ^~~~~~~~~~~~~~\n/tmp/tmpn5f7b0vz.swift:23:35:\
    \ error: cannot find 'len' in scope\n    return is_sorted_impl(lst, 0, len(lst))\n\
    \                                  ^~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var set = Set()\n    var\
    \ len = lst.count\n    for number in lst {\n        if set.contains(number) {\n\
    \            return false\n        } else {\n            set.append(number)\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpna0b98y6.swift:23:15: error: generic parameter 'Element' could\
    \ not be inferred\n    var set = Set()\n              ^\n/tmp/tmpna0b98y6.swift:23:15:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var set\
    \ = Set()\n              ^\n                 <<#Element: Hashable#>>\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  // O(1) time | O(n) space\n\
    \  return is_sorted_impl(_native_array_to_indexed_array(lst))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphdg7o_sk.swift:24:10: error: cannot find 'is_sorted_impl' in scope\n\
    \  return is_sorted_impl(_native_array_to_indexed_array(lst))\n         ^~~~~~~~~~~~~~\n\
    /tmp/tmphdg7o_sk.swift:24:25: error: cannot find '_native_array_to_indexed_array'\
    \ in scope\n  return is_sorted_impl(_native_array_to_indexed_array(lst))\n   \
    \                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let s = lst.sorted()\n  \
    \  return s == lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp2qrpu_of/tmp2qrpu_of.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aefbce0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aefbcb03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aefbcb03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aefbcb027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2qrpu_of                        0x0000557173251bcb <unavailable> + 7115

    5    libc.so.6                          0x00002aefbcff8460 __libc_start_main +
    245

    6    tmp2qrpu_of                        0x0000557173251079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var isSorted = true\n   \
    \ var currentIndex = 0\n    for index in 0 ..< lst.count {\n        guard currentIndex\
    \ < lst.count - 1 else {\n            isSorted = false\n            break\n  \
    \      }\n        if lst[currentIndex] > lst[currentIndex + 1] {\n           \
    \ isSorted = false\n            break\n        }\n        currentIndex += 1\n\
    \    }\n    return isSorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpnhzbc45h/tmpnhzbc45h.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3bc540c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3bc237b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3bc237988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3bc2367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnhzbc45h                        0x000056518b06652a <unavailable> + 5418

    5    libc.so.6                          0x00002ac3bc72c460 __libc_start_main +
    245

    6    tmpnhzbc45h                        0x000056518b0661a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(ArrayOf(Int)(lst))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp518_h4q6.swift:23:22: error: cannot find 'ArrayOf' in scope\n \
    \   return is_sorted(ArrayOf(Int)(lst))\n                     ^~~~~~~\n/tmp/tmp518_h4q6.swift:23:22:\
    \ error: missing argument label 'lst:' in call\n    return is_sorted(ArrayOf(Int)(lst))\n\
    \                     ^\n                     lst: \n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ { return false }\n    guard lst.count == 1 || lst.first < lst.last else { return\
    \ false }\n    var found: Int = 0\n    while lst.count > 1 {\n        if lst.first+1\
    \ == lst.last {\n            return false\n        }\n        if lst.first+1 !=\
    \ lst.last {\n            if lst[found] > lst.first+1 {\n                guard\
    \ lst.first > lst.last else { return false }\n                return true\n  \
    \          } else if lst[found] < lst.first+1 {\n                guard lst.last\
    \ < lst.first else { return false }\n                return true\n           \
    \ } else {\n                guard lst.first+1 != lst.last else { return false\
    \ }\n                found += 1\n            }\n        }\n        lst.removeFirst()\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp77uvg8d2.swift:24:33: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    guard lst.count == 1 || lst.first\
    \ < lst.last else { return false }\n                                ^\n/tmp/tmp77uvg8d2.swift:24:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    guard lst.count == 1 || lst.first < lst.last else { return false\
    \ }\n                                ^\n                                     \
    \ ?? <#default value#>\n/tmp/tmp77uvg8d2.swift:24:33: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    guard lst.count\
    \ == 1 || lst.first < lst.last else { return false }\n                       \
    \         ^\n                                     !\n/tmp/tmp77uvg8d2.swift:24:45:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    guard lst.count == 1 || lst.first < lst.last else { return false }\n    \
    \                                        ^\n/tmp/tmp77uvg8d2.swift:24:45: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    guard lst.count == 1 || lst.first < lst.last else { return false }\n    \
    \                                        ^\n                                 \
    \                ?? <#default value#>\n/tmp/tmp77uvg8d2.swift:24:45: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    guard\
    \ lst.count == 1 || lst.first < lst.last else { return false }\n             \
    \                               ^\n                                          \
    \      !\n/tmp/tmp77uvg8d2.swift:27:16: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if lst.first+1 == lst.last {\n\
    \               ^\n/tmp/tmp77uvg8d2.swift:27:16: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        if lst.first+1\
    \ == lst.last {\n               ^\n           (         ?? <#default value#>)\n\
    /tmp/tmp77uvg8d2.swift:27:16: note: force-unwrap using '!' to abort execution\
    \ if the optional value conta"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var i = 0\n    while i <\
    \ lst.count {\n        if lst[i] == lst[i+1] {\n            return false\n   \
    \     }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2a375dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2a3454561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae2a3454286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae2a345413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae2a3453bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae2a3253e83 <unavailable> + 188035

    6    tmp9x_nkevv                        0x000055ec28979ee1 <unavailable> + 7905

    7    tmp9x_nkevv                        0x000055ec28979325 <unavailable> + 4901

    8    libc.so.6                          0x00002ae2a3949460 __libc_start_main +
    245

    9    tmp9x_nkevv                        0x000055ec28979019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tvar prev Int = 0\n\treturn\
    \ is_sorted(lst: lst, prev: &prev)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpad3wlca6.swift:23:11: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var prev Int\
    \ = 0\n                 ^\n/tmp/tmpad3wlca6.swift:23:11: note: join the identifiers\
    \ together\n        var prev Int = 0\n            ~~~~~^~~\n            prevInt\n\
    /tmp/tmpad3wlca6.swift:24:35: error: extra argument 'prev' in call\n        return\
    \ is_sorted(lst: lst, prev: &prev)\n                        ~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let sorted = is_sorted(lst,\
    \ count: lst.count)\n    if sorted {\n        return true\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5wapnu3l.swift:23:44: error: extra argument 'count' in call\n \
    \   let sorted = is_sorted(lst, count: lst.count)\n                          ~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    if lst.count < 2 {\n        return true\n    }\n\
    \    let firstValue = lst[0]\n    for idx in lst.indices {\n        if idx < 0\
    \ {\n            return false\n        }\n        if lst[idx] != firstValue {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpbgg9_8h5/tmpbgg9_8h5.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f9cd5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f9ca56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f9ca56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f9ca557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbgg9_8h5                        0x0000556ac0b685e7 <unavailable> + 5607

    5    libc.so.6                          0x00002b6f9cf4b460 __libc_start_main +
    245

    6    tmpbgg9_8h5                        0x0000556ac0b68199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  // Create dictionary to store\
    \ frequencies of each number\n  var freq: [Int:Int] = [:]\n  for num in lst {\n\
    \    if freq.keys.contains(num) {\n      freq[num] = freq[num] + 1\n    } else\
    \ {\n      freq[num] = 1\n    }\n  }\n\n  // If all numbers have frequency of\
    \ 1, then they are sorted in ascending\n  // order\n  for num in freq.keys {\n\
    \    if freq[num] == 1 {\n      return true\n    }\n  }\n  return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpehh1iak2.swift:27:23: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n      freq[num] = freq[num] + 1\n   \
    \                   ^\n/tmp/tmpehh1iak2.swift:27:23: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n      freq[num]\
    \ = freq[num] + 1\n                      ^\n                  (         ?? <#default\
    \ value#>)\n/tmp/tmpehh1iak2.swift:27:23: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n      freq[num] = freq[num]\
    \ + 1\n                      ^\n                           !\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let len = lst.count\n   \
    \ let first = lst.removeFirst()\n    if len <= 1 {\n        return true\n    }\n\
    \    if first == lst[0] {\n        return is_sorted(lst)\n    }\n    if first\
    \ > lst[0] {\n        return false\n    }\n    for idx in 1..<len {\n        let\
    \ prev = lst[idx-1]\n        let next = lst[idx]\n        if prev == next {\n\
    \            return is_sorted(lst)\n        } else if prev > next {\n        \
    \    return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6swgv7qy.swift:24:21: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    let first = lst.removeFirst()\n      \
    \          ~~~ ^\n/tmp/tmp6swgv7qy.swift:29:26: error: missing argument label\
    \ 'lst:' in call\n        return is_sorted(lst)\n                         ^\n\
    \                         lst: \n/tmp/tmp6swgv7qy.swift:38:30: error: missing\
    \ argument label 'lst:' in call\n            return is_sorted(lst)\n         \
    \                    ^\n                             lst: \n"
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last = Int()\n    for\
    \ cur in lst {\n        if last != cur {\n            return false\n        }\n\
    \        last = cur\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpxrvidwfy/tmpxrvidwfy.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78cc324c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78cc01bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78cc01b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78cc01a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxrvidwfy                        0x000055f56617d45a <unavailable> + 5210

    5    libc.so.6                          0x00002b78cc510460 __libc_start_main +
    245

    6    tmpxrvidwfy                        0x000055f56617d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted {\n       \
    \ return true\n    } else {\n        return lst.count <= 1\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpr_uxkvoz.swift:23:12: error: no 'sorted' candidates produce the\
    \ expected contextual result type 'Bool'\n    if lst.sorted {\n           ^\n\
    Swift.Sequence:2:28: note: found candidate with type '() -> [Int]'\n    @inlinable\
    \ public func sorted() -> [Self.Element]\n                           ^\nSwift.Sequence:2:28:\
    \ note: found candidate with type '((Int, Int) throws -> Bool) throws -> [Int]'\n\
    \    @inlinable public func sorted(by areInIncreasingOrder: (Self.Element, Self.Element)\
    \ throws -> Bool) rethrows -> [Self.Element]\n                           ^\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // Find duplicate indexes\n\
    \    let indexes = lst.enumerated().filter { (idx, elem) in\n        lst.count\
    \ { elem == $0 } > 1\n    }.map { (idx, elem) in\n        idx\n    }\n\n    //\
    \ If there are any duplicates, return false\n    if indexes.count > 0 {\n    \
    \    return false\n    }\n\n    // Otherwise, return true if every index is equal\
    \ to the index of the last element\n    if lst.count == 1 {\n        return true\n\
    \    }\n\n    // Otherwise, return true if every index is less than the index\
    \ of the last element\n    for idx in indexes.reversed() {\n        if idx ==\
    \ lst.count - 1 {\n            return true\n        }\n\n        if lst[idx] <\
    \ lst[idx - 1] {\n            return false\n        }\n    }\n\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzq_0rctc.swift:25:13: error: cannot call value of non-function\
    \ type 'Int'\n        lst.count { elem == $0 } > 1\n            ^\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif lst.len == 0 {\n\t\treturn\
    \ true\n\t}\n\t// if there are two duplicates, then it's not sorted\n\tif lst.count(Double(lst.start))\
    \ != lst.len {\n\t\treturn false\n\t}\n\treturn is_sorted_helper(lst)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbhctyf37.swift:23:9: error: value of type '[Int]' has no member\
    \ 'len'\n        if lst.len == 0 {\n           ~~~ ^~~\n/tmp/tmpbhctyf37.swift:27:9:\
    \ error: cannot call value of non-function type 'Int'\n        if lst.count(Double(lst.start))\
    \ != lst.len {\n               ^\n/tmp/tmpbhctyf37.swift:27:26: error: value of\
    \ type '[Int]' has no member 'start'\n        if lst.count(Double(lst.start))\
    \ != lst.len {\n                            ~~~ ^~~~~\n/tmp/tmpbhctyf37.swift:27:41:\
    \ error: value of type '[Int]' has no member 'len'\n        if lst.count(Double(lst.start))\
    \ != lst.len {\n                                           ~~~ ^~~\n/tmp/tmpbhctyf37.swift:30:9:\
    \ error: cannot find 'is_sorted_helper' in scope\n        return is_sorted_helper(lst)\n\
    \               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    lst = lst.sorted()\n    return\
    \ lst.isEmpty == false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfug4pu0u.swift:23:5: error: cannot assign to value: 'lst' is a\
    \ 'let' constant\n    lst = lst.sorted()\n    ^~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    switch lst.count {\n    case\
    \ 2:\n        return lst[0] > lst[1]\n    case _:\n        return true\n    }\n\
    \n    let set: Set<Int> = Set<Int>(lst)\n    if set.count == lst.count {\n   \
    \     return false\n    }\n    if let first = set.first {\n        for other in\
    \ set.dropFirst() {\n            if other < first {\n                return false\n\
    \            }\n        }\n        return true\n    }\n    return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmplb54fssj/tmplb54fssj.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aae08b00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae087f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aae087f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aae087f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplb54fssj                        0x0000556054da2536 <unavailable> + 5430

    5    libc.so.6                          0x00002aae08cec460 __libc_start_main +
    245

    6    tmplb54fssj                        0x0000556054da2019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var lastIdx: Int = 0\n    var flag = true\n    for\
    \ idx in lst {\n        if idx == lastIdx {\n            flag = false\n      \
    \  } else {\n            lastIdx = idx\n        }\n    }\n    return flag\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpv6btz0il/tmpv6btz0il.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45e9ee9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45e9be0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45e9be0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45e9bdf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv6btz0il                        0x0000564616e7b646 <unavailable> + 5702

    5    libc.so.6                          0x00002b45ea0d5460 __libc_start_main +
    245

    6    tmpv6btz0il                        0x0000564616e7b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let sorted = lst.sort()\n\
    \    if sorted.first != sorted.last { return false }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3aox7rc0.swift:23:22: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    let sorted = lst.sort()\n            \
    \     ~~~ ^\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif lst.len() <= 1 {\n\t\treturn\
    \ true\n\t}\n\tlet set = Set(lst)\n\treturn set.count == lst.count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfiw6sgtb.swift:23:9: error: value of type '[Int]' has no member\
    \ 'len'\n        if lst.len() <= 1 {\n           ~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n\n    if lst.count == 1 {\n        return lst[0] ==\
    \ 0\n    }\n\n    guard lst.count > 1 else {\n        return false\n    }\n\n\
    \    var first = 0\n    var last = lst.count - 1\n\n    var result = true\n\n\
    \    while last > first {\n        if lst[first] < lst[last] {\n            result\
    \ = false\n            break\n        } else {\n            first += 1\n     \
    \   }\n        last -= 1\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpbqijo4ex/tmpbqijo4ex.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0870d58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0870a4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0870a4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0870a4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbqijo4ex                        0x000055d79472839a <unavailable> + 5018

    5    libc.so.6                          0x00002b0870f44460 __libc_start_main +
    245

    6    tmpbqijo4ex                        0x000055d794728019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last_value: Int = 0\n\
    \    return lst.reduce(false) { prev, curr in\n        if prev {\n           \
    \ if curr == last_value {\n                return true\n            } else {\n\
    \                last_value = curr\n            }\n        } else {\n        \
    \    last_value = curr\n        }\n\n        return false\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpvh78wydl/tmpvh78wydl.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba410305c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba40fffcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba40fffc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba40fffb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvh78wydl                        0x000055789823439a <unavailable> + 5018

    5    libc.so.6                          0x00002ba4104f1460 __libc_start_main +
    245

    6    tmpvh78wydl                        0x0000557898234019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.isEmpty == false\
    \ else { return false }\n    var prevValue: Int = 0\n    for value in lst {\n\
    \        if value == prevValue {\n            return false\n        }\n      \
    \  prevValue = value\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpbylym6wo/tmpbylym6wo.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e89b56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e8984db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e8984d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e8984c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbylym6wo                        0x00005612470c7646 <unavailable> + 5702

    5    libc.so.6                          0x00002b0e89d42460 __libc_start_main +
    245

    6    tmpbylym6wo                        0x00005612470c7129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  var sorted = false\n\n  for\
    \ number in lst {\n    if sorted {\n      if number == sorted[0] {\n        sorted\
    \ = true\n      } else {\n        return false\n      }\n    } else {\n      sorted\
    \ = true\n    }\n  }\n  return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphaclsa75.swift:27:26: error: value of type 'Bool' has no subscripts\n\
    \      if number == sorted[0] {\n                   ~~~~~~^\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return false\n    }\n\n    var seenNums: [Int] = []\n    for num in lst\
    \ {\n        if seenNums.contains(num) {\n            return false\n        }\
    \ else {\n            seenNums.append(num)\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpwuct2vac/tmpwuct2vac.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89ef19ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89eee95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89eee95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89eee947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwuct2vac                        0x0000559555d96716 <unavailable> + 5910

    5    libc.so.6                          0x00002b89ef38a460 __libc_start_main +
    245

    6    tmpwuct2vac                        0x0000559555d961f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    \n    // Sorting is O(n log\
    \ n), with n being the size of the list\n    if lst.count == 0 {\n        return\
    \ true\n    }\n    \n    var last: Int?\n    var result: Bool = true\n    var\
    \ lastIndex = lst.count - 1\n    \n    for var index = 0; index < lastIndex; index++\
    \ {\n        if lst[index] != last {\n            last = lst[index]\n        \
    \    result = false\n        } else {\n            result = true\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph2sxbe0s.swift:33:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var index = 0; index < lastIndex; index++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\treturn is_sorted(lst, 0, len(lst))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9rhp8ual.swift:23:27: error: cannot find 'len' in scope\n     \
    \   return is_sorted(lst, 0, len(lst))\n                                 ^~~\n\
    /tmp/tmp9rhp8ual.swift:23:18: error: extra arguments at positions #2, #3 in call\n\
    \        return is_sorted(lst, 0, len(lst))\n                        ^\n/tmp/tmp9rhp8ual.swift:22:6:\
    \ note: 'is_sorted(lst:)' declared here\nfunc is_sorted(lst: [Int]) -> Bool {\n\
    \     ^\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst: lst,\
    \ is_ascending: true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdd7c11jp.swift:23:46: error: extra argument 'is_ascending' in call\n\
    \    return is_sorted(lst: lst, is_ascending: true)\n                    ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660014113
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(ArrayOfInt(lst))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbe7h51s3.swift:23:22: error: cannot find 'ArrayOfInt' in scope\n\
    \    return is_sorted(ArrayOfInt(lst))\n                     ^~~~~~~~~~\n/tmp/tmpbe7h51s3.swift:23:22:\
    \ error: missing argument label 'lst:' in call\n    return is_sorted(ArrayOfInt(lst))\n\
    \                     ^\n                     lst: \n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let len = lst.count\n   \
    \ if len < 2 {\n        return true\n    }\n    var i = 0\n    var count = 0\n\
    \    while i < len {\n        if i == len - 1 {\n            count = count + 1\n\
    \            break\n        }\n        if lst[i] == lst[i + 1] {\n           \
    \ count = count + 1\n        } else {\n            count = 0\n        }\n    \
    \    i = i + 1\n    }\n    return count == len\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpvfmhy05j/tmpvfmhy05j.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad06c75ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad06c455b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad06c455988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad06c4547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvfmhy05j                        0x00005599d9c9b467 <unavailable> + 5223

    5    libc.so.6                          0x00002ad06c94a460 __libc_start_main +
    245

    6    tmpvfmhy05j                        0x00005599d9c9b019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    return\
    \ set.count == lst.count && set.first! < lst.first!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpb7810d0u/tmpb7810d0u.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf78b33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf7882ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf7882a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf788297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb7810d0u                        0x000055b2415b45aa <unavailable> + 5546

    5    libc.so.6                          0x00002aaf78d1f460 __libc_start_main +
    245

    6    tmpb7810d0u                        0x000055b2415b4229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var set = Set<Int>()\n  \
    \  for elt in lst {\n        guard !set.contains(elt) else {\n            return\
    \ false\n        }\n        set.insert(elt)\n    }\n    return set.count == 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzq4wbne3/tmpzq4wbne3.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3037036c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3036d2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3036d2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3036d2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzq4wbne3                        0x000055682e57f5fa <unavailable> + 5626

    5    libc.so.6                          0x00002b3037222460 __libc_start_main +
    245

    6    tmpzq4wbne3                        0x000055682e57f279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif lst.count > 1 {\n\t\tlet\
    \ first = lst[0]\n\t\tif lst.count > 2 {\n\t\t\treturn !is_sorted(\n\t\t\t\tlst.dropFirst().filter\
    \ { $0 == first },\n\t\t\t)\n\t\t}\n\t\treturn !is_sorted(\n\t\t\tlst.dropFirst().filter\
    \ { $0 != first },\n\t\t)\n\t}\n\tif lst.count == 1 {\n\t\treturn true\n\t}\n\t\
    if lst.first! < lst.last! {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpddv344_8.swift:28:4: error: unexpected ',' separator\n        \
    \                )\n                        ^\n/tmp/tmpddv344_8.swift:32:3: error:\
    \ unexpected ',' separator\n                )\n                ^\n/tmp/tmpddv344_8.swift:27:5:\
    \ error: missing argument label 'lst:' in call\n                             \
    \   lst.dropFirst().filter { $0 == first },\n                                ^\n\
    \                                lst: \n/tmp/tmpddv344_8.swift:31:4: error: missing\
    \ argument label 'lst:' in call\n                        lst.dropFirst().filter\
    \ { $0 != first },\n                        ^\n                        lst: \n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // count how many times each\
    \ number shows up\n    var counts = Array(count: lst.count, repeatedValue: 0)\n\
    \    for num in lst {\n        counts[num] += 1\n    }\n\n    // check whether\
    \ all numbers are different\n    for i in 0..<lst.count {\n        if counts[i]\
    \ >= 2 {\n            return false\n        }\n    }\n\n    // check whether all\
    \ numbers are the same\n    for i in 0..<lst.count {\n        if counts[i] !=\
    \ 1 {\n            return false\n        }\n    }\n\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvs926rnz.swift:24:18: error: no exact matches in call to initializer\
    \ \n    var counts = Array(count: lst.count, repeatedValue: 0)\n             \
    \    ^\n/tmp/tmpvs926rnz.swift:24:18: note: candidate has partially matching parameter\
    \ list (repeating: _, count: Int)\n    var counts = Array(count: lst.count, repeatedValue:\
    \ 0)\n                 ^\n/tmp/tmpvs926rnz.swift:24:18: note: candidate has partially\
    \ matching parameter list (repeating: _, count: Int)\n    var counts = Array(count:\
    \ lst.count, repeatedValue: 0)\n                 ^\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    \n    // sort array in ascending\
    \ order\n    \n    // check if all numbers are the same\n    if lst.count == 1\
    \ {\n        return true\n    }\n\n    // check first number\n    if lst[0] !=\
    \ 0 {\n        return false\n    }\n\n    // check rest of array\n    for i in\
    \ 1..<lst.count {\n        if lst[i-1] > lst[i] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpmqe8b9bj/tmpmqe8b9bj.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14dde83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14ddb7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14ddb7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14ddb797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmqe8b9bj                        0x00005583d6c205f7 <unavailable> + 5623

    5    libc.so.6                          0x00002b14de06f460 __libc_start_main +
    245

    6    tmpmqe8b9bj                        0x00005583d6c201a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, is_ascending)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpxzrjxqe3.swift:23:27: error: cannot find 'is_ascending' in scope\n\
    \    return is_sorted(lst, is_ascending)\n                          ^~~~~~~~~~~~\n\
    /tmp/tmpxzrjxqe3.swift:23:27: error: extra argument in call\n    return is_sorted(lst,\
    \ is_ascending)\n                    ~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlst.sortInPlace()\n\tlet count\
    \ = lst.count\n\tif count > 1 {\n\t\treturn false\n\t}\n\tif count == 1 {\n\t\t\
    return true\n\t}\n\t\n\tlet first = lst[0]\n\tlet last = lst[count - 1]\n\treturn\
    \ first < last\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwh4fzvup.swift:23:6: error: value of type '[Int]' has no member\
    \ 'sortInPlace'\n        lst.sortInPlace()\n        ~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count == 1 || lst.count\
    \ == lst.filter { $0 == lst.first }\n        else { return true }\n    let m =\
    \ lst.count\n    let n = lst.first\n    for i in 0..<m {\n        let j = i\n\
    \        while j > 0 && lst[j-1] > lst[j] {\n            lst[j] = lst[j-1]\n \
    \           j--\n        }\n        lst[j] = n\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3nf5t08m.swift:23:53: error: expected 'else' after 'guard' condition\n\
    \    guard lst.count == 1 || lst.count == lst.filter { $0 == lst.first }\n   \
    \                                                 ^\n                        \
    \                            else \n/tmp/tmp3nf5t08m.swift:23:55: error: anonymous\
    \ closure argument not contained in a closure\n    guard lst.count == 1 || lst.count\
    \ == lst.filter { $0 == lst.first }\n                                        \
    \              ^\n/tmp/tmp3nf5t08m.swift:24:9: error: expected expression\n  \
    \      else { return true }\n        ^\n/tmp/tmp3nf5t08m.swift:23:39: error: type\
    \ '((Int) throws -> Bool) throws -> [Int]' cannot conform to 'BinaryInteger'\n\
    \    guard lst.count == 1 || lst.count == lst.filter { $0 == lst.first }\n   \
    \                                   ^\n/tmp/tmp3nf5t08m.swift:23:39: note: only\
    \ concrete types such as structs, enums and classes can conform to protocols\n\
    \    guard lst.count == 1 || lst.count == lst.filter { $0 == lst.first }\n   \
    \                                   ^\n/tmp/tmp3nf5t08m.swift:23:39: note: required\
    \ by operator function '==' where 'Other' = '((Int) throws -> Bool) throws ->\
    \ [Int]'\n    guard lst.count == 1 || lst.count == lst.filter { $0 == lst.first\
    \ }\n                                      ^\n/tmp/tmp3nf5t08m.swift:30:16: error:\
    \ cannot assign through subscript: 'lst' is a 'let' constant\n            lst[j]\
    \ = lst[j-1]\n            ~~~^\n/tmp/tmp3nf5t08m.swift:31:14: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            j--\n            \
    \ ^~\n/tmp/tmp3nf5t08m.swift:33:12: error: cannot assign through subscript: 'lst'\
    \ is a 'let' constant\n        lst[j] = n\n        ~~~^\n/tmp/tmp3nf5t08m.swift:33:18:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        lst[j] = n\n                 ^\n/tmp/tmp3nf5t08m.swift:33:18: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     lst[j] = n\n                 ^\n                   ?? <#default value#>\n\
    /tmp/tmp3nf5t08m.swift:33:18: note: f"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var is_sorted = true\n  \
    \  var last_val = -math.MaxInt32\n    for i in lst {\n        if i != last_val\
    \ {\n            is_sorted = false\n        } else {\n            last_val = i\n\
    \        }\n    }\n    return is_sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0ax2l_x5.swift:24:21: error: cannot find 'math' in scope\n    var\
    \ last_val = -math.MaxInt32\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n\n    if lst.count == 1 {\n        return true\n   \
    \ }\n\n    if lst[0] == lst[1] {\n        return false\n    }\n\n    if lst[0]\
    \ < lst[1] {\n        return true\n    }\n\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpgszsutge/tmpgszsutge.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab249003c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab248cfab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab248cfa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab248cf97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgszsutge                        0x000055a5e0c0e467 <unavailable> + 5223

    5    libc.so.6                          0x00002ab2491ef460 __libc_start_main +
    245

    6    tmpgszsutge                        0x000055a5e0c0e019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 2 {\n    \
    \    return true\n    }\n    if lst.count > 1 {\n        let i = 1\n        while\
    \ i < lst.count && lst[i] == lst[i-1] {\n            i += 1\n        }\n     \
    \   return i != lst.count\n    }\n    for x in lst {\n        if x < lst[0] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwuren5ty.swift:29:15: error: left side of mutating operator isn't\
    \ mutable: 'i' is a 'let' constant\n            i += 1\n            ~ ^\n/tmp/tmpwuren5ty.swift:27:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let i = 1\n        ^~~\n\
    \        var\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.hasDuplicates {\n\
    \        return false\n    }\n    for x in lst {\n        if lst.index(of: x)\
    \ == lst.index(of: (x+1))-1 {\n            return false\n        }\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptuzfplai.swift:23:12: error: value of type '[Int]' has no member\
    \ 'hasDuplicates'\n    if lst.hasDuplicates {\n       ~~~ ^~~~~~~~~~~~~\n/tmp/tmptuzfplai.swift:27:36:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n        if lst.index(of:\
    \ x) == lst.index(of: (x+1))-1 {\n                                   ^\n/tmp/tmptuzfplai.swift:27:36:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if lst.index(of: x) == lst.index(of: (x+1))-1 {\n           \
    \                        ^\n                               (                 \
    \   ?? <#default value#>)\n/tmp/tmptuzfplai.swift:27:36: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        if lst.index(of:\
    \ x) == lst.index(of: (x+1))-1 {\n                                   ^\n     \
    \                                              !\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.count == 1 {\n    return\
    \ true\n  }\n  if lst.count > 1 {\n    return false\n  }\n\n  guard let first\
    \ = lst.first else { return false }\n  if first == lst.last {\n    return true\n\
    \  }\n\n  var sorted = true\n  for item in lst.dropFirst() {\n    if item < first\
    \ {\n      sorted = false\n      break\n    }\n  }\n\n  return sorted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpcj_dfbpm/tmpcj_dfbpm.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5eb9c0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5eb9903b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5eb9903988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5eb99027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcj_dfbpm                        0x00005600588a8777 <unavailable> + 6007

    5    libc.so.6                          0x00002b5eb9df8460 __libc_start_main +
    245

    6    tmpcj_dfbpm                        0x00005600588a8329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, by:\
    \ { $0 < $1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmuidjm0f.swift:23:31: error: extra argument 'by' in call\n    return\
    \ is_sorted(lst, by: { $0 < $1 })\n                    ~~~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet len = lst.count\n\n\tif\
    \ len <= 1 {\n\t\treturn true\n\t}\n\n\tlet maxVal = lst[0]\n\tlet minVal = lst[0]\n\
    \n\tfor ele in lst {\n\t\tif ele == minVal {\n\t\t\tminVal = ele\n\t\t\tcontinue\n\
    \t\t}\n\n\t\tif ele == maxVal {\n\t\t\tmaxVal = ele\n\t\t\tcontinue\n\t\t}\n\n\
    \t\tif ele > maxVal {\n\t\t\treturn false\n\t\t}\n\n\t\tif ele < minVal {\n\t\t\
    \treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3ewn7b4z.swift:34:4: error: cannot assign to value: 'minVal' is\
    \ a 'let' constant\n                        minVal = ele\n                   \
    \     ^~~~~~\n/tmp/tmp3ewn7b4z.swift:30:2: note: change 'let' to 'var' to make\
    \ it mutable\n        let minVal = lst[0]\n        ^~~\n        var\n/tmp/tmp3ewn7b4z.swift:39:4:\
    \ error: cannot assign to value: 'maxVal' is a 'let' constant\n              \
    \          maxVal = ele\n                        ^~~~~~\n/tmp/tmp3ewn7b4z.swift:29:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let maxVal = lst[0]\n\
    \        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, count:\
    \ lst.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpiz4euucg.swift:23:38: error: extra argument 'count' in call\n \
    \   return is_sorted(lst, count: lst.count)\n                    ~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count == 1 else\
    \ {\n        return false\n    }\n    \n    var set = Set<Int>()\n    var lastElementIndex\
    \ = lst.count - 1\n    for index in 0..<lastElementIndex {\n        let element\
    \ = lst[index]\n        set.insert(element)\n    }\n    \n    guard let first\
    \ = set.first else {\n        return false\n    }\n    \n    for _ in 0..<lst.count\
    \ {\n        if lst[0] != first {\n            return false\n        }\n    }\n\
    \    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp9nbyjao4/tmp9nbyjao4.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88890eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8888de1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8888de1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8888de07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9nbyjao4                        0x000055e44e7cc6ba <unavailable> + 5818

    5    libc.so.6                          0x00002b88892d6460 __libc_start_main +
    245

    6    tmp9nbyjao4                        0x000055e44e7cc339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted { return true\
    \ }\n    \n    var last = lst[0]\n    for el in lst[1..] {\n        if el > last\
    \ {\n            return false\n        }\n        last = el\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfxhxmg45.swift:23:12: error: no 'sorted' candidates produce the\
    \ expected contextual result type 'Bool'\n    if lst.sorted { return true }\n\
    \           ^\nSwift.Sequence:2:28: note: found candidate with type '() -> [Int]'\n\
    \    @inlinable public func sorted() -> [Self.Element]\n                     \
    \      ^\nSwift.Sequence:2:28: note: found candidate with type '((Int, Int) throws\
    \ -> Bool) throws -> [Int]'\n    @inlinable public func sorted(by areInIncreasingOrder:\
    \ (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\n  \
    \                         ^\n/tmp/tmpfxhxmg45.swift:26:20: error: cannot find\
    \ operator '..' in scope; did you mean '...'?\n    for el in lst[1..] {\n    \
    \               ^~\n                   ...\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.first! > lst.last! {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpti4jq11e/tmpti4jq11e.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23c34dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23c31d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23c31d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23c31d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpti4jq11e                        0x000055c89490450a <unavailable> + 5386

    5    libc.so.6                          0x00002b23c36ca460 __libc_start_main +
    245

    6    tmpti4jq11e                        0x000055c894904189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n\n    var lastNum = lst[0]\n    for i in lst {\n   \
    \     if i == lastNum {\n            continue\n        } else {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpc1wwak5z/tmpc1wwak5z.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f4066fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f40366b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f40366988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f403657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1wwak5z                        0x000055613a5075d7 <unavailable> + 5591

    5    libc.so.6                          0x00002b0f4085b460 __libc_start_main +
    245

    6    tmpc1wwak5z                        0x000055613a507189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tswitch lst.count {\n\tcase\
    \ 1:\n\t\treturn is_sorted(lst: lst[0], target: 0)\n\tcase 2:\n\t\treturn is_sorted(lst:\
    \ lst[0], target: 1) || is_sorted(lst: lst[1], target: 1)\n\tcase 3:\n\t\treturn\
    \ is_sorted(lst: lst[0], target: 2) || is_sorted(lst: lst[1], target: 2) ||\n\t\
    \t\tis_sorted(lst: lst[2], target: 2)\n\tcase 4:\n\t\treturn is_sorted(lst: lst[0],\
    \ target: 3) || is_sorted(lst: lst[1], target: 3) ||\n\t\t\tis_sorted(lst: lst[2],\
    \ target: 3) || is_sorted(lst: lst[3], target: 3)\n\tcase 5:\n\t\treturn is_sorted(lst:\
    \ lst[0], target: 4) || is_sorted(lst: lst[1], target: 4) ||\n\t\t\tis_sorted(lst:\
    \ lst[2], target: 4) || is_sorted(lst: lst[3], target: 4) ||\n\t\t\tis_sorted(lst:\
    \ lst[4], target: 4)\n\tcase 6:\n\t\treturn is_sorted(lst: lst[0], target: 5)\
    \ || is_sorted(lst: lst[1], target: 5) ||\n\t\t\tis_sorted(lst: lst[2], target:\
    \ 5) || is_sorted(lst: lst[3], target: 5) ||\n\t\t\tis_sorted(lst: lst[4], target:\
    \ 5) || is_sorted(lst: lst[5], target: 5)\n\tcase 7:\n\t\treturn is_sorted(lst:\
    \ lst[0], target: 6) || is_sorted(lst: lst[1], target: 6) ||\n\t\t\tis_sorted(lst:\
    \ lst[2], target: 6) || is_sorted(lst: lst[3], target: 6) ||\n\t\t\tis_sorted(lst:\
    \ lst[4], target: 6) || is_sorted(lst: lst[5], target: 6) ||\n\t\t\tis_sorted(lst:\
    \ lst[6], target: 6)\n\tcase 8:\n\t\treturn is_sorted(lst: lst[0], target: 7)\
    \ || is_sorted(lst: lst[1], target: 7) ||\n\t\t\tis_sorted(lst: lst[2], target:\
    \ 7) || is_sorted(lst: lst[3], target: 7) ||\n\t\t\tis_sorted(lst: lst[4], target:\
    \ 7) || is_sorted(lst: lst[5], target: 7) ||\n\t\t\tis_sorted(lst: lst[6], target:\
    \ 7) || is_sorted(lst: lst[7], target: 7)\n\tcase 9:\n\t\treturn is_sorted(lst:\
    \ lst[0], target: 8) || is_sorted(lst: lst[1], target: 8) ||\n\t\t\tis_sorted(lst:\
    \ lst[2], target: 8) || is_sorted(lst: lst[3], target: 8) ||\n\t\t\tis_sorted(lst:\
    \ lst[4], target: 8) || is_sorted(lst: lst[5], target: 8) ||\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3npumovh.swift:56:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp3npumovh.swift:83:45: error: expected '}' at end of brace statement\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)\n                               \
    \             ^\n/tmp/tmp3npumovh.swift:22:36: note: to match this opening '{'\n\
    func is_sorted(lst: [Int]) -> Bool {\n                                   ^\n/tmp/tmp3npumovh.swift:25:41:\
    \ error: extra argument 'target' in call\n                return is_sorted(lst:\
    \ lst[0], target: 0)\n                                ~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmp3npumovh.swift:25:28: error: cannot convert value of type 'Int' to expected\
    \ argument type '[Int]'\n                return is_sorted(lst: lst[0], target:\
    \ 0)\n                                         ^\n/tmp/tmp3npumovh.swift:27:41:\
    \ error: extra argument 'target' in call\n                return is_sorted(lst:\
    \ lst[0], target: 1) || is_sorted(lst: lst[1], target: 1)\n                  \
    \              ~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmp3npumovh.swift:27:28: error:\
    \ cannot convert value of type 'Int' to expected argument type '[Int]'\n     \
    \           return is_sorted(lst: lst[0], target: 1) || is_sorted(lst: lst[1],\
    \ target: 1)\n                                         ^\n/tmp/tmp3npumovh.swift:27:78:\
    \ error: extra argument 'target' in call\n                return is_sorted(lst:\
    \ lst[0], target: 1) || is_sorted(lst: lst[1], target: 1)\n                  \
    \                                                   ~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmp3npumovh.swift:27:65: error: cannot convert value of type 'Int' to expected\
    \ argument type '[Int]'\n                return is_sorted(lst: lst[0], target:\
    \ 1) || is_sorted(lst: lst[1], target: 1)\n                                  \
    \                                            ^\n/tmp/tmp3npumovh.swift:29:41:\
    \ error: extra argument 'target' in call\n                return is_sorted(lst:\
    \ lst[0], target: 2) || is_sorted(lst: lst[1], target: 2) ||\n               \
    \                 ~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmp3npumovh.swift:29:28: error:\
    \ cannot convert value "
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\treturn is_sorted(lst, lst.count())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo45ubk6c.swift:23:28: error: cannot call value of non-function\
    \ type 'Int'\n        return is_sorted(lst, lst.count())\n                   \
    \               ^    ~~\n                                       \n/tmp/tmpo45ubk6c.swift:23:28:\
    \ error: extra argument in call\n        return is_sorted(lst, lst.count())\n\
    \                        ~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last = lst[0]\n    for\
    \ v in lst {\n        if v < last {\n            return false\n        }\n   \
    \     last = v\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a24027c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a23d1e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0a23d1e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0a23d1e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0a23d1dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0a23b1de83 <unavailable> + 188035

    6    tmpqdr97xkn                        0x0000558ff65acfc2 <unavailable> + 8130

    7    tmpqdr97xkn                        0x0000558ff65ac954 <unavailable> + 6484

    8    libc.so.6                          0x00002b0a24213460 __libc_start_main +
    245

    9    tmpqdr97xkn                        0x0000558ff65ac129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted {\n       \
    \ return true\n    }\n    for i in lst.indices {\n        if lst[i] != i {\n \
    \           return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvxwe5oys.swift:23:12: error: no 'sorted' candidates produce the\
    \ expected contextual result type 'Bool'\n    if lst.sorted {\n           ^\n\
    Swift.Sequence:2:28: note: found candidate with type '() -> [Int]'\n    @inlinable\
    \ public func sorted() -> [Self.Element]\n                           ^\nSwift.Sequence:2:28:\
    \ note: found candidate with type '((Int, Int) throws -> Bool) throws -> [Int]'\n\
    \    @inlinable public func sorted(by areInIncreasingOrder: (Self.Element, Self.Element)\
    \ throws -> Bool) rethrows -> [Self.Element]\n                           ^\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  // find the number of consecutive\
    \ duplicate elements\n  var cnt = 0\n  for i in 0 ..< lst.count {\n    if lst[i]\
    \ == lst[(i + 1)] {\n      cnt++\n    }\n  }\n\n  // return true if there are\
    \ at least 2 duplicate elements\n  return cnt > 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp98l5azan.swift:27:10: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n      cnt++\n         ^~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let result = is_sorted(lst:\
    \ lst, cmp: is_less_than)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkxp4mwyo.swift:23:43: error: cannot find 'is_less_than' in scope\n\
    \    let result = is_sorted(lst: lst, cmp: is_less_than)\n                   \
    \                       ^~~~~~~~~~~~\n/tmp/tmpkxp4mwyo.swift:23:43: error: extra\
    \ argument 'cmp' in call\n    let result = is_sorted(lst: lst, cmp: is_less_than)\n\
    \                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return lst[0] == 0\n    }\n\n    for idx in 0..<lst.count {\n        if\
    \ idx == 0 || lst[idx] != lst[idx-1] {\n            return false\n        }\n\
    \    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzeujmi76/tmpzeujmi76.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b409643dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4096134b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4096134988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40961337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzeujmi76                        0x000055c61f74c52a <unavailable> + 5418

    5    libc.so.6                          0x00002b4096629460 __libc_start_main +
    245

    6    tmpzeujmi76                        0x000055c61f74c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n\n    // Find the first duplicate\n    var first = lst[0]\n\
    \    var dupCount = 0\n    for val in lst {\n        if val == first {\n     \
    \       dupCount += 1\n        } else {\n            first = 0\n            dupCount\
    \ = 0\n        }\n    }\n\n    // If there are dupCounts less than or equal to\
    \ the length of the list,\n    // then this list is not sorted\n    return dupCount\
    \ <= lst.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0e1_84de/tmp0e1_84de.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b417b748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b417b43fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b417b43f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b417b43e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0e1_84de                        0x000055ae8b8cb6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b417b934460 __libc_start_main +
    245

    6    tmp0e1_84de                        0x000055ae8b8cb189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted() {\n     \
    \   return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm7uoin1m.swift:23:12: error: cannot convert value of type '[Int]'\
    \ to expected condition type 'Bool'\n    if lst.sorted() {\n       ~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted() {\n     \
    \   return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpm7uoin1m.swift:23:12: error: cannot convert value of type '[Int]'\
    \ to expected condition type 'Bool'\n    if lst.sorted() {\n       ~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.sorted { $0 != $1 }\
    \ { return false }\n  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkrewehkl.swift:23:10: error: cannot convert value of type '[Int]'\
    \ to expected condition type 'Bool'\n  if lst.sorted { $0 != $1 } { return false\
    \ }\n     ~~~~^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n\n    func isSorted(_ i: Int, _ j: Int) -> Bool {\n\
    \        if i < j {\n            return false\n        }\n\n        return true\n\
    \    }\n\n    for i in 0..<lst.count {\n        for j in (i + 1)..<lst.count {\n\
    \            if isSorted(lst[i], lst[j]) {\n                return false\n   \
    \         }\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp94ytywwl/tmp94ytywwl.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49df1d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49deecbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49deecb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49deeca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp94ytywwl                        0x0000561ade2e0ee3 <unavailable> + 7907

    5    libc.so.6                          0x00002b49df3c0460 __libc_start_main +
    245

    6    tmp94ytywwl                        0x0000561ade2e01a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count <= 1 else\
    \ {\n        return false\n    }\n\n    for idx in 0..<lst.count {\n        if\
    \ idx < lst.count && lst[idx] == lst[idx+1] {\n            return false\n    \
    \    }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af2f83edc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2f80e4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af2f80e4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af2f80e413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af2f80e3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af2f7ee3e83 <unavailable> + 188035

    6    tmp76ycjkz0                        0x00005563d09e41a5 <unavailable> + 8613

    7    tmp76ycjkz0                        0x00005563d09e34b5 <unavailable> + 5301

    8    libc.so.6                          0x00002af2f85d9460 __libc_start_main +
    245

    9    tmp76ycjkz0                        0x00005563d09e31a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet count = lst.count\n\tguard\
    \ count > 1 else { return false }\n\tfor i in 0..<count {\n\t\tif i == count -\
    \ 1 || lst[i] != lst[i+1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpbn1t_il5/tmpbn1t_il5.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae946f48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae946c3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae946c3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae946c3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbn1t_il5                        0x000055b5409e452a <unavailable> + 5418

    5    libc.so.6                          0x00002ae947134460 __libc_start_main +
    245

    6    tmpbn1t_il5                        0x000055b5409e41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var lastElem = lst[0]\n    for elem in lst {\n \
    \       if elem == lastElem {\n            continue\n        }\n        return\
    \ false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpkviqqud_/tmpkviqqud_.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93088e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93085dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93085dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93085db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkviqqud_                        0x0000563988cae5d7 <unavailable> + 5591

    5    libc.so.6                          0x00002b9308ad1460 __libc_start_main +
    245

    6    tmpkviqqud_                        0x0000563988cae189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.count == 0 { return\
    \ true }\n\n  let hashmap: [Hashable: Bool] = [:]\n  for item in lst {\n    if\
    \ !hashmap[item] {\n      hashmap[item] = true\n      return true\n    }\n  }\n\
    \  return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpssq0on76.swift:25:16: error: type 'any Hashable' cannot conform\
    \ to 'Hashable'\n  let hashmap: [Hashable: Bool] = [:]\n               ^\n/tmp/tmpssq0on76.swift:25:16:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n  let hashmap: [Hashable: Bool] = [:]\n               ^\n/tmp/tmpssq0on76.swift:25:17:\
    \ error: use of protocol 'Hashable' as a type must be written 'any Hashable'\n\
    \  let hashmap: [Hashable: Bool] = [:]\n                ^~~~~~~~\n           \
    \     any Hashable\n/tmp/tmpssq0on76.swift:27:16: error: no exact matches in call\
    \ to subscript \n    if !hashmap[item] {\n               ^\n/tmp/tmpssq0on76.swift:27:16:\
    \ note: found candidate with type '(any Hashable) -> Bool?'\n    if !hashmap[item]\
    \ {\n               ^\n/tmp/tmpssq0on76.swift:27:16: note: candidate expects value\
    \ of type 'Range<Dictionary<any Hashable, Bool>.Index>' for parameter #1 (got\
    \ 'Int')\n    if !hashmap[item] {\n               ^\n/tmp/tmpssq0on76.swift:27:16:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    if !hashmap[item] {\n               ^\n/tmp/tmpssq0on76.swift:28:14:\
    \ error: no exact matches in call to subscript \n      hashmap[item] = true\n\
    \             ^\n/tmp/tmpssq0on76.swift:28:14: note: found candidate with type\
    \ '(Range<Dictionary<any Hashable, Bool>.Index>) -> Slice<[any Hashable : Bool]>'\n\
    \      hashmap[item] = true\n             ^\n/tmp/tmpssq0on76.swift:28:14: note:\
    \ found candidate with type '((UnboundedRange_) -> ()) -> Dictionary<any Hashable,\
    \ Bool>.SubSequence' (aka '((UnboundedRange_) -> ()) -> Slice<Dictionary<any Hashable,\
    \ Bool>>')\n      hashmap[item] = true\n             ^\n/tmp/tmpssq0on76.swift:28:23:\
    \ error: cannot assign value of type 'Bool' to subscript of type 'Slice<[any Hashable\
    \ : Bool]>'\n      hashmap[item] = true\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return true\n    }\n    var is_sorted = true\n    var last_index = 0\n \
    \   for index in 0..<lst.count {\n        let value = lst[index]\n        for\
    \ next_index in index..<lst.count {\n            if value == lst[next_index] {\n\
    \                break\n            }\n        }\n        if next_index == lst.count\
    \ {\n            is_sorted = false\n        }\n        last_index = index\n  \
    \  }\n    return is_sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5quhkpn3.swift:35:12: error: cannot find 'next_index' in scope\n\
    \        if next_index == lst.count {\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    return\
    \ set.count == lst.count && set.count == lst.filter({ $0 < $1 }).count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp870gmf1w.swift:24:62: error: contextual closure type '(Int) throws\
    \ -> Bool' expects 1 argument, but 2 were used in closure body\n    return set.count\
    \ == lst.count && set.count == lst.filter({ $0 < $1 }).count\n               \
    \                                              ^\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev: Int = 0\n    for idx in lst {\n      \
    \  if idx == prev {\n            return false\n        }\n        prev = idx\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqkpeslxp/tmpqkpeslxp.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4850c9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4850994b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4850994988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48509937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqkpeslxp                        0x0000556e1a7a5646 <unavailable> + 5702

    5    libc.so.6                          0x00002b4850e89460 __libc_start_main +
    245

    6    tmpqkpeslxp                        0x0000556e1a7a5129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count > 1 else\
    \ {\n        return true\n    }\n    guard lst.contains(Set().union(lst).sort())\
    \ == false else {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7v6o4r1a.swift:26:41: error: value of type 'Set<Int>' has no member\
    \ 'sort'\n    guard lst.contains(Set().union(lst).sort()) == false else {\n  \
    \                     ~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var flag = false\n    if\
    \ lst.count == 0 {\n        return true\n    }\n    var i = lst.count\n    while\
    \ i > 0 {\n        var j = 1\n        if lst.count > i {\n            j = lst.count\n\
    \        }\n        if i > j {\n            flag = false\n            break\n\
    \        }\n        if i >= j {\n            flag = true\n        }\n        i\
    \ /= 2\n    }\n    return flag\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp8lo7r19l/tmp8lo7r19l.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37d46dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37d43d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37d43d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37d43d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8lo7r19l                        0x00005614587ae4a7 <unavailable> + 5287

    5    libc.so.6                          0x00002b37d48cb460 __libc_start_main +
    245

    6    tmp8lo7r19l                        0x00005614587ae059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var count = 0\n    for num\
    \ in lst {\n        if num != lst[count] {\n            return false\n       \
    \ }\n        count += 1\n    }\n    return count == lst.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpsp7hdl7c/tmpsp7hdl7c.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae21d1c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae21cebdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae21cebd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae21cebc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsp7hdl7c                        0x000055b0ade816a6 <unavailable> + 5798

    5    libc.so.6                          0x00002ae21d3b2460 __libc_start_main +
    245

    6    tmpsp7hdl7c                        0x000055b0ade81189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int? = nil\n  \
    \  for el in lst {\n        if last != el {\n            last = el\n        }\n\
    \    }\n    return last == nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp65yo4_1m/tmp65yo4_1m.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afeefa4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afeef745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afeef745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afeef7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp65yo4_1m                        0x0000559ee67e745a <unavailable> + 5210

    5    libc.so.6                          0x00002afeefc3a460 __libc_start_main +
    245

    6    tmp65yo4_1m                        0x0000559ee67e70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var result = true\n    for\
    \ number in lst {\n        guard !lst.isEmpty else { return false }\n        if\
    \ number != lst.rev().first {\n            result = false\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptd0capzp.swift:26:26: error: value of type '[Int]' has no member\
    \ 'rev'\n        if number != lst.rev().first {\n                     ~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    let\
    \ count = lst.count\n    if count < 2 {\n        return true\n    }\n    if count\
    \ == 2 {\n        return set == set\n    }\n    return !set.containsAll(set) &&\
    \ set.count == lst.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpodrh3zep.swift:31:17: error: value of type 'Set<Int>' has no member\
    \ 'containsAll'\n    return !set.containsAll(set) && set.count == lst.count\n\
    \            ~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  let seen = Set<Int>()\n  for\
    \ num in lst {\n    if seen.contains(num) {\n      return false\n    }\n    seen.insert(num)\n\
    \  }\n  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmepasyg6.swift:28:10: error: cannot use mutating member on immutable\
    \ value: 'seen' is a 'let' constant\n    seen.insert(num)\n    ~~~~ ^\n/tmp/tmpmepasyg6.swift:23:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let seen = Set<Int>()\n  ^~~\n\
    \  var\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set<Int>()\n  \
    \  for i in lst {\n        if !set.contains(i) {\n            set.add(i)\n   \
    \     } else {\n            return false\n        }\n    }\n    return set.count\
    \ == lst.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprrs0wr_r.swift:26:17: error: value of type 'Set<Int>' has no member\
    \ 'add'\n            set.add(i)\n            ~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  guard lst.count != 0 else {\
    \ return true }\n\n  var last: Int?\n  for n in lst {\n    if n == last { return\
    \ false }\n    last = n\n  }\n  return true // if last was never set, it must\
    \ be sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpgm05gqu6/tmpgm05gqu6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bc5e5ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bc5b55b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bc5b55988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bc5b547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgm05gqu6                        0x000055f1cd6db646 <unavailable> + 5702

    5    libc.so.6                          0x00002b5bc604a460 __libc_start_main +
    245

    6    tmpgm05gqu6                        0x000055f1cd6db129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let is_same = (\n       \
    \ lst.reduce((acc, val) -> Bool in\n            if val == acc {\n            \
    \    return true\n            }\n            return acc\n        )\n    )\n  \
    \  return is_same\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuaos7awh.swift:24:39: error: expected ',' separator\n        lst.reduce((acc,\
    \ val) -> Bool in\n                                      ^\n                 \
    \                    ,\n/tmp/tmpuaos7awh.swift:24:39: error: expected expression\
    \ in list of expressions\n        lst.reduce((acc, val) -> Bool in\n         \
    \                             ^\n/tmp/tmpuaos7awh.swift:24:21: error: cannot find\
    \ 'acc' in scope\n        lst.reduce((acc, val) -> Bool in\n                 \
    \   ^~~\n/tmp/tmpuaos7awh.swift:24:26: error: cannot find 'val' in scope\n   \
    \     lst.reduce((acc, val) -> Bool in\n                         ^~~\n/tmp/tmpuaos7awh.swift:24:20:\
    \ error: expected type before '->'\n        lst.reduce((acc, val) -> Bool in\n\
    \                   ^\n/tmp/tmpuaos7awh.swift:24:38: error: missing argument for\
    \ parameter #2 in call\n        lst.reduce((acc, val) -> Bool in\n           \
    \                          ^\n                                     , <#(_.Type,\
    \ Int) throws -> _.Type#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n\
    \    @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult:\
    \ (_ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif lst.sorted { return true\
    \ }\n\tvar last: Int = 0\n\tfor idx, val in enumerate(lst) {\n\t\tif idx == 0\
    \ { last = val }\n\t\tif val != last {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjh7g3c5r.swift:25:9: error: expected 'in' after for-each pattern\n\
    \        for idx, val in enumerate(lst) {\n               ^\n/tmp/tmpjh7g3c5r.swift:25:9:\
    \ error: expected Sequence expression for for-each loop\n        for idx, val\
    \ in enumerate(lst) {\n               ^\n/tmp/tmpjh7g3c5r.swift:23:9: error: no\
    \ 'sorted' candidates produce the expected contextual result type 'Bool'\n   \
    \     if lst.sorted { return true }\n               ^\nSwift.Sequence:2:28: note:\
    \ found candidate with type '() -> [Int]'\n    @inlinable public func sorted()\
    \ -> [Self.Element]\n                           ^\nSwift.Sequence:2:28: note:\
    \ found candidate with type '((Int, Int) throws -> Bool) throws -> [Int]'\n  \
    \  @inlinable public func sorted(by areInIncreasingOrder: (Self.Element, Self.Element)\
    \ throws -> Bool) rethrows -> [Self.Element]\n                           ^\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tvar seen = IntSet()\n\tfor\
    \ i := range lst {\n\t\tif !seen.add(i) {\n\t\t\treturn false\n\t\t}\n\t}\n\t\
    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphp1yi4op.swift:24:9: error: expected type\n        for i := range\
    \ lst {\n               ^\n                <#type#>\n/tmp/tmphp1yi4op.swift:24:9:\
    \ error: expected 'in' after for-each pattern\n        for i := range lst {\n\
    \               ^\n/tmp/tmphp1yi4op.swift:24:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := range lst {\n               ^\n/tmp/tmphp1yi4op.swift:23:13:\
    \ error: cannot find 'IntSet' in scope\n        var seen = IntSet()\n        \
    \           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted { return true\
    \ }\n    var hash: [Int: Bool] = [:]\n    for i in lst {\n        if hash[i] {\
    \ return false }\n        hash[i] = true\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp34wlkae2.swift:23:12: error: no 'sorted' candidates produce the\
    \ expected contextual result type 'Bool'\n    if lst.sorted { return true }\n\
    \           ^\nSwift.Sequence:2:28: note: found candidate with type '() -> [Int]'\n\
    \    @inlinable public func sorted() -> [Self.Element]\n                     \
    \      ^\nSwift.Sequence:2:28: note: found candidate with type '((Int, Int) throws\
    \ -> Bool) throws -> [Int]'\n    @inlinable public func sorted(by areInIncreasingOrder:\
    \ (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\n  \
    \                         ^\n/tmp/tmp34wlkae2.swift:26:16: error: value of optional\
    \ type 'Bool?' must be unwrapped to a value of type 'Bool'\n        if hash[i]\
    \ { return false }\n               ^\n/tmp/tmp34wlkae2.swift:26:16: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if hash[i] { return false }\n               ^\n                   ?? <#default\
    \ value#>\n/tmp/tmp34wlkae2.swift:26:16: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if hash[i] { return\
    \ false }\n               ^\n                  !\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count >= 2 else\
    \ { return true }\n    var seen: Set<Int> = []\n    for num in lst {\n       \
    \ if seen.contains(num) { return false }\n        seen.insert(num)\n    }\n  \
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpxko61l4k/tmpxko61l4k.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ac9525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ac921cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ac921c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ac921b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxko61l4k                        0x000056154a12d7b6 <unavailable> + 6070

    5    libc.so.6                          0x00002b8ac9711460 __libc_start_main +
    245

    6    tmpxko61l4k                        0x000056154a12d299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 1 {\n    \
    \    return false\n    }\n    var prev: Int = 0\n    var done = false\n    for\
    \ x in lst {\n        if x == prev {\n            done = true\n        } else\
    \ {\n            if done {\n                return false\n            }\n    \
    \        prev = x\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpnrltkqe_/tmpnrltkqe_.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0318210c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0317f07b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0317f07988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0317f067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnrltkqe_                        0x00005642e4999646 <unavailable> + 5702

    5    libc.so.6                          0x00002b03183fc460 __libc_start_main +
    245

    6    tmpnrltkqe_                        0x00005642e4999129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, 0,\
    \ lst.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2iogkdda.swift:23:21: error: extra arguments at positions #2, #3\
    \ in call\n    return is_sorted(lst, 0, lst.count)\n                    ^\n/tmp/tmp2iogkdda.swift:22:6:\
    \ note: 'is_sorted(lst:)' declared here\nfunc is_sorted(lst: [Int]) -> Bool {\n\
    \     ^\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if len(lst) <= 1 {\n    \
    \    return true\n    }\n    for let i in lst {\n        for j in 0..<lst.count\
    \ {\n            if j == i {\n                continue\n            }\n      \
    \      if lst[j] > i {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqsj1qug8.swift:26:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let i in lst {\n        ^\n/tmp/tmpqsj1qug8.swift:23:8:\
    \ error: cannot find 'len' in scope\n    if len(lst) <= 1 {\n       ^~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    switch lst.count {\n    case\
    \ 0:\n        return true\n    case 1:\n        return lst[0] == lst[0]\n    case\
    \ 2:\n        return lst[0] == lst[1] && lst[1] == lst[1]\n    case 3:\n     \
    \   return lst[0] == lst[1] && lst[1] == lst[2] && lst[0] == lst[1]\n    case\
    \ 4:\n        return lst[0] == lst[1] && lst[1] == lst[2] && lst[0] == lst[2]\
    \ && lst[1] == lst[3]\n    case 5:\n        return lst[0] == lst[1] && lst[1]\
    \ == lst[2] && lst[0] == lst[2] && lst[1] == lst[3] && lst[0] == lst[3]\n    case\
    \ 6:\n        return lst[0] == lst[1] && lst[1] == lst[2] && lst[0] == lst[2]\
    \ && lst[1] == lst[3] && lst[0] == lst[4] && lst[1] == lst[4] && lst[2] == lst[4]\
    \ && lst[3] == lst[4]\n    default:\n        return false\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmphbkvyev4/tmphbkvyev4.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd5bf18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd5bc0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd5bc0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd5bc0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphbkvyev4                        0x000056127f1be467 <unavailable> + 5223

    5    libc.so.6                          0x00002afd5c104460 __libc_start_main +
    245

    6    tmphbkvyev4                        0x000056127f1be019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tsorted.is_sorted(&lst)\n\t\
    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnwlv725u.swift:23:2: error: cannot find 'sorted' in scope\n   \
    \     sorted.is_sorted(&lst)\n        ^~~~~~\n/tmp/tmpnwlv725u.swift:23:19: error:\
    \ cannot pass immutable value as inout argument: 'lst' is a 'let' constant\n \
    \       sorted.is_sorted(&lst)\n                         ^~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, cmp:\
    \ is_sorted_cmp)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpts6cbtwa.swift:23:32: error: cannot find 'is_sorted_cmp' in scope\n\
    \    return is_sorted(lst, cmp: is_sorted_cmp)\n                             \
    \  ^~~~~~~~~~~~~\n/tmp/tmpts6cbtwa.swift:23:32: error: extra argument 'cmp' in\
    \ call\n    return is_sorted(lst, cmp: is_sorted_cmp)\n                    ~~~~~~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count < 1 {\n        return true\n    }\n\
    \    if lst.count > 0 {\n        var prevVal: Int?\n        for v in lst {\n \
    \           if v != prevVal {\n                return false\n            }\n \
    \           prevVal = v\n        }\n        return true\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqnrsm_4_/tmpqnrsm_4_.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6127303c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6126ffab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6126ffa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6126ff97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqnrsm_4_                        0x000055f3104b84aa <unavailable> + 5290

    5    libc.so.6                          0x00002b61274ef460 __libc_start_main +
    245

    6    tmpqnrsm_4_                        0x000055f3104b8129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev: Int = 0\n    for\
    \ val in lst {\n        if val < prev {\n            return false\n        }\n\
    \        prev = val\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzq8y_oy9/tmpzq8y_oy9.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c1eb58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c1e84fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c1e84f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c1e84e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzq8y_oy9                        0x0000561d9cb40c2b <unavailable> + 7211

    5    libc.so.6                          0x00002b5c1ed44460 __libc_start_main +
    245

    6    tmpzq8y_oy9                        0x0000561d9cb400d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last: Int = IntMax\n\
    \    for val in  lst {\n        if val < last {\n            return false\n  \
    \      }\n        last = val\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp164v20hm.swift:23:21: error: cannot find 'IntMax' in scope\n  \
    \  var last: Int = IntMax\n                    ^~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  return is_sorted(lst, false)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptu7kmmej.swift:23:25: error: extra argument in call\n  return is_sorted(lst,\
    \ false)\n                  ~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif lst.count > 1 {\n\t\tlet\
    \ sorted = lst.sorted()\n\t\treturn sorted.count == lst.count\n\t}\n\n\treturn\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpbnur23w2/tmpbnur23w2.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a3218c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a2f0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a2f0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a2f0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbnur23w2                        0x000055ee1c200586 <unavailable> + 5510

    5    libc.so.6                          0x00002b27a3404460 __libc_start_main +
    245

    6    tmpbnur23w2                        0x000055ee1c200069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.len() == 1 {\n   \
    \     return true\n    }\n    var i = 0\n    for val in lst {\n        for val2\
    \ in lst[i..] {\n            if val == val2 {\n                return false\n\
    \            }\n        }\n        i += 1\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg05yxdka.swift:23:12: error: value of type '[Int]' has no member\
    \ 'len'\n    if lst.len() == 1 {\n       ~~~ ^~~\n/tmp/tmpg05yxdka.swift:28:26:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        for\
    \ val2 in lst[i..] {\n                         ^~\n                         ...\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last = lst[0]\n    var\
    \ sorted = true\n    for v in lst {\n        if last == v {\n            sorted\
    \ = false\n        } else {\n            last = v\n        }\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpw3gup1gv/tmpw3gup1gv.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b610c598c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b610c28fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b610c28f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b610c28e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw3gup1gv                        0x00005577c9ee74aa <unavailable> + 5290

    5    libc.so.6                          0x00002b610c784460 __libc_start_main +
    245

    6    tmpw3gup1gv                        0x00005577c9ee7129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    if lst.count == 1 {\n        return true\n    }\n\
    \    if lst[0] != lst[1] {\n        return false\n    }\n    return is_sorted(lst:\
    \ lst.suffix(2))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0jmm6itw/tmp0jmm6itw.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3007b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3007841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3007841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30078407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jmm6itw                        0x000055e0762014c7 <unavailable> + 5319

    5    libc.so.6                          0x00002b3007d36460 __libc_start_main +
    245

    6    tmp0jmm6itw                        0x000055e076201079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    switch lst.count {\n    case\
    \ 0: return true\n    case 1: return lst[0] < lst[1]\n    default:\n        if\
    \ let x = firstIndex(of: lst[0], in: lst) {\n            return x > 0 && is_sorted(lst[1..<x])\n\
    \        }\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg1_roji8.swift:27:20: error: cannot find 'firstIndex' in scope\n\
    \        if let x = firstIndex(of: lst[0], in: lst) {\n                   ^~~~~~~~~~\n\
    /tmp/tmpg1_roji8.swift:28:39: error: missing argument label 'lst:' in call\n \
    \           return x > 0 && is_sorted(lst[1..<x])\n                          \
    \            ^\n                                      lst: \n/tmp/tmpg1_roji8.swift:28:42:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n            return x > 0 && is_sorted(lst[1..<x])\n               \
    \                          ^\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  var seen = [Int]()\n  return\
    \ lst.sorted { l, _ in\n    if seen[l] == nil {\n      seen[l] = 1\n      return\
    \ true\n    }\n    return false\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpi5fus99j.swift:24:14: error: cannot convert return expression of\
    \ type '[Int]' to return type 'Bool'\n  return lst.sorted { l, _ in\n        \
    \ ~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var len = lst.count\n   \
    \ if len <= 1 {\n        return true\n    }\n    var i = 0\n    var j = len -\
    \ 2\n    while i < j {\n        if lst[i] < lst[j] {\n            return false\n\
    \        }\n        i += 1\n        j -= 1\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1lywil4k/tmp1lywil4k.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30d9468c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30d915fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30d915f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30d915e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1lywil4k                        0x000055e9cef20467 <unavailable> + 5223

    5    libc.so.6                          0x00002b30d9654460 __libc_start_main +
    245

    6    tmp1lywil4k                        0x000055e9cef20019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return !is_sorted(lst, equals:\
    \ { $0 == $1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnuj75uzk.swift:23:36: error: extra argument 'equals' in call\n\
    \    return !is_sorted(lst, equals: { $0 == $1 })\n                     ~~~~~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 1 {\n   \
    \     return lst[0] == 0\n    }\n    var hashset = Set<Int>()\n    for v in lst\
    \ {\n        if hashset.contains(v) {\n            return false\n        } else\
    \ {\n            hashset.insert(v)\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpxh_pfc6h/tmpxh_pfc6h.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace29ea6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace29b9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace29b9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace29b9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxh_pfc6h                        0x0000564a11ce665a <unavailable> + 5722

    5    libc.so.6                          0x00002ace2a092460 __libc_start_main +
    245

    6    tmpxh_pfc6h                        0x0000564a11ce62d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var nums: [Int]\n    var\
    \ n = lst.count\n    if n < 2 {\n        return true\n    }\n    nums = Array(lst.map\
    \ { $0 })\n    return checkForDuplicates(nums, n, 0) == n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp49nc4pra.swift:29:12: error: cannot find 'checkForDuplicates' in\
    \ scope\n    return checkForDuplicates(nums, n, 0) == n\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    \n    let isSorted = is_sorted(lst:\
    \ lst[0..<lst.count])\n    \n    return isSorted || is_sorted(lst: lst, startIndex:\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3,\
    \ 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\
    \ == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst:\
    \ [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbo5qetat.swift:24:38: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    let isSorted = is_sorted(lst: lst[0..<lst.count])\n\
    \                                     ^\n/tmp/tmpbo5qetat.swift:26:56: error:\
    \ extra argument 'startIndex' in call\n    return isSorted || is_sorted(lst: lst,\
    \ startIndex: 0)\n                                ~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.isEmpty { return true\
    \ }\n    if lst.count > 1 {\n        return false\n    }\n    var is_sorted =\
    \ true\n    for n in lst {\n        if n != lst.first! {\n            is_sorted\
    \ = false\n            break\n        }\n    }\n    return is_sorted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmprz0s6o1j/tmprz0s6o1j.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ad2b67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ad285eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ad285e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ad285d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprz0s6o1j                        0x00005610fc3b46c7 <unavailable> + 5831

    5    libc.so.6                          0x00002b5ad2d53460 __libc_start_main +
    245

    6    tmprz0s6o1j                        0x00005610fc3b4279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tswitch lst.count {\n\tcase\
    \ 0:\n\t\treturn true\n\tcase 1:\n\t\treturn lst[0] == 0\n\tcase 2:\n\t\treturn\
    \ lst[0] == 0 && lst[1] == lst[0]\n\tdefault:\n\t\tfor i := 0; i < lst.count;\
    \ i++ {\n\t\t\tif i == 0 || lst[i-1] > lst[i] {\n\t\t\t\treturn false\n\t\t\t\
    }\n\t\t}\n\t\treturn true\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpk24riecd.swift:31:10: error: expected type\n                for\
    \ i := 0; i < lst.count; i++ {\n                       ^\n                   \
    \     <#type#>\n/tmp/tmpk24riecd.swift:31:10: error: expected 'in' after for-each\
    \ pattern\n                for i := 0; i < lst.count; i++ {\n                \
    \       ^\n/tmp/tmpk24riecd.swift:31:10: error: expected Sequence expression for\
    \ for-each loop\n                for i := 0; i < lst.count; i++ {\n          \
    \             ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst.slice())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprkeohhyv.swift:23:26: error: value of type '[Int]' has no member\
    \ 'slice'\n    return is_sorted(lst.slice())\n                     ~~~ ^~~~~\n\
    /tmp/tmprkeohhyv.swift:23:22: error: missing argument label 'lst:' in call\n \
    \   return is_sorted(lst.slice())\n                     ^\n                  \
    \   lst: \n"
  stdout: ''
  timestamp: 1660014114
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var firstDuplicate: Int =\
    \ 0\n    var nextIndex: Int = 0\n    for nextIndex in 0..<lst.count {\n      \
    \  if firstDuplicate == nil {\n            firstDuplicate = lst[nextIndex]\n \
    \       } else if lst[nextIndex] == firstDuplicate {\n            return false\n\
    \        } else {\n            firstDuplicate = lst[nextIndex]\n        }\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp5ijp3by4/tmp5ijp3by4.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97686f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97683f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97683f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97683ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ijp3by4                        0x00005588bdc356c6 <unavailable> + 5830

    5    libc.so.6                          0x00002b97688e5460 __libc_start_main +
    245

    6    tmp5ijp3by4                        0x00005588bdc351a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  let dict = lst.reduce(into:\
    \ [String: Int]()) { (res, item) -> Void in\n    res[item.toString()] = item\n\
    \  }\n  return dict.count == lst.count && lst.sorted(by: <#T##(T, T) -> Bool#>{(lhs,\
    \ rhs) -> Bool in return dict[lhs] <= dict[rhs]}).first == nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpptcladm5.swift:26:52: error: editor placeholder in source file\n\
    \  return dict.count == lst.count && lst.sorted(by: <#T##(T, T) -> Bool#>{(lhs,\
    \ rhs) -> Bool in return dict[lhs] <= dict[rhs]}).first == nil\n             \
    \                                      ^\n/tmp/tmpptcladm5.swift:24:14: error:\
    \ value of type 'Int' has no member 'toString'\n    res[item.toString()] = item\n\
    \        ~~~~ ^~~~~~~~\n/tmp/tmpptcladm5.swift:26:58: error: cannot find type\
    \ 'T' in scope\n  return dict.count == lst.count && lst.sorted(by: <#T##(T, T)\
    \ -> Bool#>{(lhs, rhs) -> Bool in return dict[lhs] <= dict[rhs]}).first == nil\n\
    \                                                         ^\n/tmp/tmpptcladm5.swift:26:61:\
    \ error: cannot find type 'T' in scope\n  return dict.count == lst.count && lst.sorted(by:\
    \ <#T##(T, T) -> Bool#>{(lhs, rhs) -> Bool in return dict[lhs] <= dict[rhs]}).first\
    \ == nil\n                                                            ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet set = Set(lst)\n\treturn\
    \ set.count <= 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp9uddragt/tmp9uddragt.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34c0cc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34c09bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34c09ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34c09b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9uddragt                        0x000055ac9dbe04b7 <unavailable> + 5303

    5    libc.so.6                          0x00002b34c0eaf460 __libc_start_main +
    245

    6    tmp9uddragt                        0x000055ac9dbe0069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, fromIndex:\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3,\
    \ 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\
    \ == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst:\
    \ [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9kwvj9qz.swift:23:38: error: extra argument 'fromIndex' in call\n\
    \    return is_sorted(lst, fromIndex: 0)\n                    ~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var i = 0\n    var j = 1\n\
    \    var sorted = false\n    if lst[i] == lst[j] {\n        sorted = true\n  \
    \      i += 1\n        j += 1\n    }\n    if i > j {\n        return sorted\n\
    \    }\n    for k < j {\n        if lst[i] > lst[k] {\n            sorted = true\n\
    \            i += 1\n        } else {\n            j += 1\n        }\n    }\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp38zuidox.swift:34:11: error: expected 'in' after for-each pattern\n\
    \    for k < j {\n          ^\n/tmp/tmp38zuidox.swift:34:11: error: unary operator\
    \ cannot be separated from its operand\n    for k < j {\n          ^~\n      \
    \     \n/tmp/tmp38zuidox.swift:34:11: error: '<' is not a prefix unary operator\n\
    \    for k < j {\n          ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\treturn is_sorted(lst, is_less_than)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6bwgjvz2.swift:23:24: error: cannot find 'is_less_than' in scope\n\
    \        return is_sorted(lst, is_less_than)\n                              ^~~~~~~~~~~~\n\
    /tmp/tmp6bwgjvz2.swift:23:24: error: extra argument in call\n        return is_sorted(lst,\
    \ is_less_than)\n                        ~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.count != 1 {\n    return\
    \ false\n  }\n  var current: Int = 0\n  for i in lst {\n    if current > i {\n\
    \      return false\n    }\n    current = i\n  }\n  return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp67lgnc08/tmp67lgnc08.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b68e9d83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b68e9a7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b68e9a7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b68e9a797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp67lgnc08                        0x000055a536eb1577 <unavailable> + 5495

    5    libc.so.6                          0x00002b68e9f6f460 __libc_start_main +
    245

    6    tmp67lgnc08                        0x000055a536eb1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.count > 1 {\n    return\
    \ false\n  }\n  \n  guard let first = lst.first else {\n    return true\n  }\n\
    \n  for elem in lst {\n    if elem < first {\n      return false\n    }\n  }\n\
    \n  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpa85_adtp/tmpa85_adtp.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aae10320c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae10017b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aae10017988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aae100167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa85_adtp                        0x000055984f01d5d7 <unavailable> + 5591

    5    libc.so.6                          0x00002aae1050c460 __libc_start_main +
    245

    6    tmpa85_adtp                        0x000055984f01d189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    lst = lst.sorted()\n    return\
    \ lst.count == lst.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1ws1kbyi.swift:23:5: error: cannot assign to value: 'lst' is a\
    \ 'let' constant\n    lst = lst.sorted()\n    ^~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.count != 1 {\n    return\
    \ false\n  }\n  guard let first = lst[0] else { return false }\n  if lst.contains(where:\
    \ { (i) in\n    let i = Int(i)\n    return i == first {\n      return true\n \
    \   }\n  }) {\n    return true\n  } else {\n    return false\n  }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfajd5odm.swift:26:9: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n  guard let first = lst[0] else { return\
    \ false }\n        ^           ~~~~~~\n/tmp/tmpfajd5odm.swift:29:17: error: cannot\
    \ call value of non-function type 'Int'\n    return i == first {\n           \
    \     ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    switch lst.count {\n    case\
    \ 0:\n        return true\n    case 1:\n        return lst[0] == 0\n    default:\n\
    \        let lastValue = lst[0]\n        let lastCount = 1\n        var isSorted\
    \ = true\n        for val in lst {\n            if val < lastValue {\n       \
    \         isSorted = false\n                break\n            }\n           \
    \ lastCount += 1\n            lastValue = val\n        }\n        return isSorted\
    \ && lastCount <= 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptgfhxzny.swift:37:23: error: left side of mutating operator isn't\
    \ mutable: 'lastCount' is a 'let' constant\n            lastCount += 1\n     \
    \       ~~~~~~~~~ ^\n/tmp/tmptgfhxzny.swift:30:9: note: change 'let' to 'var'\
    \ to make it mutable\n        let lastCount = 1\n        ^~~\n        var\n/tmp/tmptgfhxzny.swift:38:13:\
    \ error: cannot assign to value: 'lastValue' is a 'let' constant\n           \
    \ lastValue = val\n            ^~~~~~~~~\n/tmp/tmptgfhxzny.swift:29:9: note: change\
    \ 'let' to 'var' to make it mutable\n        let lastValue = lst[0]\n        ^~~\n\
    \        var\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tsorted = false\n\tfor (i, v)\
    \ in\n\t\tlst.enumerated().flatMap { (idx, v) -> (idx, v) in\n\t\t\tif i == 0\
    \ || v != lst[i-1] {\n\t\t\t\tsorted = true\n\t\t\t\treturn (i, v)\n\t\t\t}\n\t\
    \t\treturn nil\n\t\t}\n\t{ return sorted }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8h2ke71n.swift:23:2: error: cannot find 'sorted' in scope\n   \
    \     sorted = false\n        ^~~~~~\n/tmp/tmp8h2ke71n.swift:26:7: error: cannot\
    \ find 'i' in scope\n                        if i == 0 || v != lst[i-1] {\n  \
    \                         ^\n/tmp/tmp8h2ke71n.swift:26:26: error: cannot find\
    \ 'i' in scope\n                        if i == 0 || v != lst[i-1] {\n       \
    \                                       ^\n/tmp/tmp8h2ke71n.swift:27:5: error:\
    \ cannot find 'sorted' in scope\n                                sorted = true\n\
    \                                ^~~~~~\n/tmp/tmp8h2ke71n.swift:28:13: error:\
    \ cannot find 'i' in scope\n                                return (i, v)\n  \
    \                                      ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sort() == lst {\n\
    \        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmvyo3kw3.swift:23:19: error: binary operator '==' cannot be applied\
    \ to operands of type '()' and '[Int]'\n    if lst.sort() == lst {\n       ~~~~~~~~~~\
    \ ^  ~~~\n/tmp/tmpmvyo3kw3.swift:23:19: note: overloads for '==' exist with these\
    \ partially matching parameter lists: ((), ())\n    if lst.sort() == lst {\n \
    \                 ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var has_dupes = false\n\n\
    \    for i := 0; i < len(lst); i++ {\n        j := i\n        for ; j < len(lst);\
    \ j++ {\n            if lst[j] == lst[i] {\n                has_dupes = true\n\
    \                break\n            }\n        }\n\n        if has_dupes {\n \
    \           break\n        }\n\n        if j == i {\n            return false\n\
    \        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9cypwqgu.swift:25:12: error: expected type\n    for i := 0; i <\
    \ len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp9cypwqgu.swift:25:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++\
    \ {\n           ^\n/tmp/tmp9cypwqgu.swift:25:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp9cypwqgu.swift:26:10:\
    \ error: consecutive statements on a line must be separated by ';'\n        j\
    \ := i\n         ^\n         ;\n/tmp/tmp9cypwqgu.swift:26:11: error: expected\
    \ expression\n        j := i\n          ^\n/tmp/tmp9cypwqgu.swift:27:9: error:\
    \ C-style for statement has been removed in Swift 3\n        for ; j < len(lst);\
    \ j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    return\
    \ set.count == lst.count && set.sorted() == true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc9m6_x6x.swift:24:51: error: binary operator '==' cannot be applied\
    \ to operands of type '[Int]' and 'Bool'\n    return set.count == lst.count &&\
    \ set.sorted() == true\n                                     ~~~~~~~~~~~~ ^  ~~~~\n\
    /tmp/tmpc9m6_x6x.swift:24:51: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Bool, Bool)\n    return set.count == lst.count &&\
    \ set.sorted() == true\n                                                  ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.uniquelySorted() {\n\
    \    return true\n  }\n  var j = 0\n  for i in  0...lst.count - 1 {\n    if lst[i]\
    \ > lst[j] {\n      return false\n    }\n    j = j + 1\n  }\n  return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg2c1ulcd.swift:23:10: error: value of type '[Int]' has no member\
    \ 'uniquelySorted'\n  if lst.uniquelySorted() {\n     ~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet set = Set(lst)\n\treturn\
    \ set.count == lst.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpvz56uasj/tmpvz56uasj.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61e3e86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61e3b7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61e3b7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61e3b7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvz56uasj                        0x00005655193965e6 <unavailable> + 5606

    5    libc.so.6                          0x00002b61e4072460 __libc_start_main +
    245

    6    tmpvz56uasj                        0x00005655193960c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let len = lst.count\n   \
    \ guard len >= 1 else {\n        return false\n    }\n    if len == 1 {\n    \
    \    return true\n    }\n    if len == 2 {\n        if lst[0] == lst[1] {\n  \
    \          return true\n        }\n        return false\n    }\n    for i in 0..<len\
    \ - 1 {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp8ab6n9jv/tmp8ab6n9jv.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86fb651c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86fb348b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86fb348988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86fb3477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ab6n9jv                        0x000056433de18a5e <unavailable> + 6750

    5    libc.so.6                          0x00002b86fb83d460 __libc_start_main +
    245

    6    tmp8ab6n9jv                        0x000056433de181a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.sort { $0 < $1 } !=\
    \ lst { return false }\n  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptlb9oqaw.swift:23:10: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n  if lst.sort { $0 < $1 } != lst { return\
    \ false }\n     ~~~ ^\n/tmp/tmptlb9oqaw.swift:23:30: error: cannot convert value\
    \ of type '[Int]' to expected argument type '()'\n  if lst.sort { $0 < $1 } !=\
    \ lst { return false }\n                             ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst.sorted())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbcl0j0r9.swift:23:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst.sorted())\n                     ^\n                \
    \     lst: \n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 || lst.count\
    \ > 1 {\n        return false\n    }\n    var last = 0\n    var idx = 0\n    for\
    \ el in lst {\n        if idx == last {\n            return false\n        }\n\
    \        if el != lst[idx] {\n            return false\n        }\n        last\
    \ = idx\n        idx++\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn4__g8dr.swift:36:12: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        idx++\n           ^~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  return lst.sorted { $0 < $1\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3,\
    \ 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\
    \ == false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst:\
    \ [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpeeymcwk6.swift:23:14: error: cannot convert return expression of\
    \ type '[Int]' to return type 'Bool'\n  return lst.sorted { $0 < $1 }\n      \
    \   ~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted { return true\
    \ }\n\n    for _, b := range lst {\n        // If the current number matches the\
    \ previous number, we return false\n        if lst[b] != (b + 1) {\n         \
    \   return false\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjjx3odzu.swift:25:10: error: expected 'in' after for-each pattern\n\
    \    for _, b := range lst {\n         ^\n/tmp/tmpjjx3odzu.swift:25:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, b := range lst {\n\
    \         ^\n/tmp/tmpjjx3odzu.swift:23:12: error: no 'sorted' candidates produce\
    \ the expected contextual result type 'Bool'\n    if lst.sorted { return true\
    \ }\n           ^\nSwift.Sequence:2:28: note: found candidate with type '() ->\
    \ [Int]'\n    @inlinable public func sorted() -> [Self.Element]\n            \
    \               ^\nSwift.Sequence:2:28: note: found candidate with type '((Int,\
    \ Int) throws -> Bool) throws -> [Int]'\n    @inlinable public func sorted(by\
    \ areInIncreasingOrder: (Self.Element, Self.Element) throws -> Bool) rethrows\
    \ -> [Self.Element]\n                           ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet set = Array(Set(lst))\n\
    \treturn !set.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpr5s903x9/tmpr5s903x9.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4f425cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4f3f53b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4f3f53988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4f3f527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr5s903x9                        0x000055dc12c25676 <unavailable> + 5750

    5    libc.so.6                          0x00002af4f4448460 __libc_start_main +
    245

    6    tmpr5s903x9                        0x000055dc12c25159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var lastIdx = 0\n    for\
    \ idx in lst {\n        if idx == lst[idx - 1] {\n            return false\n \
    \       }\n        if idx == lst[lastIdx] {\n            lastIdx = idx\n     \
    \   }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8259f56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8259c4d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8259c4d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8259c4d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8259c4cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8259a4ce83 <unavailable> + 188035

    6    tmpzidm_lrr                        0x0000564d17d3e07a <unavailable> + 8314

    7    tmpzidm_lrr                        0x0000564d17d3d435 <unavailable> + 5173

    8    libc.so.6                          0x00002b825a142460 __libc_start_main +
    245

    9    tmpzidm_lrr                        0x0000564d17d3d129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    sort_helper(arr: lst, begin:\
    \ 0, end: lst.length)\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvvt1p13y.swift:23:5: error: cannot find 'sort_helper' in scope\n\
    \    sort_helper(arr: lst, begin: 0, end: lst.length)\n    ^~~~~~~~~~~\n/tmp/tmpvvt1p13y.swift:23:46:\
    \ error: value of type '[Int]' has no member 'length'\n    sort_helper(arr: lst,\
    \ begin: 0, end: lst.length)\n                                         ~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // Create an unsorted array\
    \ and find the first index of duplicates\n    var idx = 0\n    for index in 0..<lst.count\
    \ {\n        if idx == lst.count {\n            break\n        }\n        if lst[index]\
    \ == lst[idx] {\n            idx++\n        }\n    }\n    if idx == lst.count\
    \ {\n        return true\n    }\n    // There are duplicate values\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmj2yync_.swift:30:16: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            idx++\n               ^~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.count != 1 {\n    return\
    \ false\n  }\n  let key = lst[0]\n  var index = 0\n  for item in lst {\n    if\
    \ item != key {\n      return false\n    }\n    index++\n  }\n  return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpf3zhkm8i.swift:32:10: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n    index++\n         ^~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.len <= 1 {\n     \
    \   return true\n    }\n    for i in 0..<lst.len - 1 {\n        if lst[i] != lst[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1_wgi8j3.swift:23:12: error: value of type '[Int]' has no member\
    \ 'len'\n    if lst.len <= 1 {\n       ~~~ ^~~\n/tmp/tmp1_wgi8j3.swift:26:22:\
    \ error: value of type '[Int]' has no member 'len'\n    for i in 0..<lst.len -\
    \ 1 {\n                 ~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tguard lst.count >= 2 else {\
    \ return true }\n\tguard lst.count <= 9 else { return false }\n\t\n\tvar prev\
    \ : Int = Int.max\n\tvar last : Int = Int.min\n\tfor index in 0 ..< lst.count\
    \ {\n\t\tif lst[index] == prev { continue }\n\t\t\n\t\tif lst[index] > last {\n\
    \t\t\treturn false\n\t\t}\n\t\tlast = lst[index]\n\t\tprev = lst[index]\n\t}\n\
    \treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpzihh8rz0/tmpzihh8rz0.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba968b44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba96883bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba96883b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba96883a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzihh8rz0                        0x0000556560b7c5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002ba968d30460 __libc_start_main +
    245

    6    tmpzihh8rz0                        0x0000556560b7c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var is_sorted = true\n  \
    \  for val in lst {\n        if val < lst[0] {\n            is_sorted = false\n\
    \        } else {\n            break\n        }\n    }\n    return is_sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpqaisa1tz/tmpqaisa1tz.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b975f14cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b975ee43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b975ee43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b975ee427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqaisa1tz                        0x000055ae3ee80646 <unavailable> + 5702

    5    libc.so.6                          0x00002b975f338460 __libc_start_main +
    245

    6    tmpqaisa1tz                        0x000055ae3ee80129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // sort a copy to avoid modifying\
    \ lst\n    let sortedLst = lst.sorted()\n    return sortedLst == lst\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp1ocudq9c/tmp1ocudq9c.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abe98a30c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe98727b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abe98727988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abe987267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ocudq9c                        0x00005602e0192bcb <unavailable> + 7115

    5    libc.so.6                          0x00002abe98c1c460 __libc_start_main +
    245

    6    tmp1ocudq9c                        0x00005602e0192079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tvar hash: [Int] = []\n\tfor\
    \ i : Int in lst {\n\t\tif let _ = hash.contains(i) {\n\t\t\treturn false\n\t\t\
    }\n\t\thash.append(i)\n\t}\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbflify2k.swift:25:6: error: initializer for conditional binding\
    \ must have Optional type, not 'Bool'\n                if let _ = hash.contains(i)\
    \ {\n                   ^       ~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif len(lst) == 0 {\n\t\treturn\
    \ true\n\t}\n\t// find the max and min element of lst.\n\tmax := lst[0]\n\tfor\
    \ i := range lst {\n\t\tif lst[i] > max {\n\t\t\tmax = lst[i]\n\t\t}\n\t}\n\t\
    min := lst[0]\n\tfor i := range lst {\n\t\tif lst[i] < min {\n\t\t\tmin = lst[i]\n\
    \t\t}\n\t}\n\tdiff := max - min\n\tif diff > 1 {\n\t\treturn false\n\t}\n\t//\
    \ If diff == 1, every elements are equals.\n\t// If diff > 1, sort it.\n\tfor\
    \ _, x := range lst {\n\t\tif x == min {\n\t\t\tcontinue\n\t\t}\n\t\tif x < min\
    \ {\n\t\t\treturn false\n\t\t}\n\t\tif x > max {\n\t\t\treturn false\n\t\t}\n\t\
    }\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpiaq_wltq.swift:27:5: error: consecutive statements on a line must\
    \ be separated by ';'\n        max := lst[0]\n           ^\n           ;\n/tmp/tmpiaq_wltq.swift:27:6:\
    \ error: expected expression\n        max := lst[0]\n            ^\n/tmp/tmpiaq_wltq.swift:28:9:\
    \ error: expected type\n        for i := range lst {\n               ^\n     \
    \           <#type#>\n/tmp/tmpiaq_wltq.swift:28:9: error: expected 'in' after\
    \ for-each pattern\n        for i := range lst {\n               ^\n/tmp/tmpiaq_wltq.swift:28:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := range\
    \ lst {\n               ^\n/tmp/tmpiaq_wltq.swift:34:9: error: expected type\n\
    \        for i := range lst {\n               ^\n                <#type#>\n/tmp/tmpiaq_wltq.swift:34:9:\
    \ error: expected 'in' after for-each pattern\n        for i := range lst {\n\
    \               ^\n/tmp/tmpiaq_wltq.swift:34:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := range lst {\n               ^\n/tmp/tmpiaq_wltq.swift:45:7:\
    \ error: expected 'in' after for-each pattern\n        for _, x := range lst {\n\
    \             ^\n/tmp/tmpiaq_wltq.swift:45:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, x := range lst {\n             ^\n/tmp/tmpiaq_wltq.swift:23:5:\
    \ error: cannot find 'len' in scope\n        if len(lst) == 0 {\n           ^~~\n\
    /tmp/tmpiaq_wltq.swift:27:2: error: generic parameter 'T' could not be inferred\n\
    \        max := lst[0]\n        ^\nSwift.max:1:24: note: in call to function 'max'\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpiaq_wltq.swift:40:5: error: cannot find 'diff'\
    \ in scope\n        if diff > 1 {\n           ^~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst.sorted())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbcl0j0r9.swift:23:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst.sorted())\n                     ^\n                \
    \     lst: \n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let n = lst.count\n    if\
    \ n < 2 {\n        return true\n    }\n    for ind in 0..<n {\n        let item\
    \ = lst[ind]\n        var lastItem = item\n        for _ in 0..<ind {\n      \
    \      lastItem = item\n            item = lst[ind]\n        }\n        if item\
    \ != lastItem {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0pu5ee40.swift:32:13: error: cannot assign to value: 'item' is\
    \ a 'let' constant\n            item = lst[ind]\n            ^~~~\n/tmp/tmp0pu5ee40.swift:28:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let item = lst[ind]\n\
    \        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, true)\
    \ || is_sorted(lst, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcmlixfc6.swift:23:27: error: extra argument in call\n    return\
    \ is_sorted(lst, true) || is_sorted(lst, false)\n                    ~~~~~~^~~~~\n\
    /tmp/tmpcmlixfc6.swift:23:51: error: extra argument in call\n    return is_sorted(lst,\
    \ true) || is_sorted(lst, false)\n                                           \
    \ ~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tvar has_dupes = false\n\tfor\
    \ _, value := range lst {\n\t\tif has_dupes || !is_sorted([]Int{value}) {\n\t\t\
    \treturn false\n\t\t}\n\t\thas_dupes = true\n\t}\n\treturn true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnhwdp7_6.swift:24:7: error: expected 'in' after for-each pattern\n\
    \        for _, value := range lst {\n             ^\n/tmp/tmpnhwdp7_6.swift:24:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, value\
    \ := range lst {\n             ^\n/tmp/tmpnhwdp7_6.swift:25:32: error: expected\
    \ ',' separator\n                if has_dupes || !is_sorted([]Int{value}) {\n\
    \                                             ^\n                            \
    \                 ,\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen: [Int] = lst\n \
    \   var first = 0\n    var last = lst.count - 1\n\n    while first < last {\n\
    \        if seen[first] == seen[first+1] {\n            first += 1\n        }\
    \ else {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpx72jwzny/tmpx72jwzny.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30a7827c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30a751eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30a751e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30a751d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx72jwzny                        0x000055e8d2eac467 <unavailable> + 5223

    5    libc.so.6                          0x00002b30a7a13460 __libc_start_main +
    245

    6    tmpx72jwzny                        0x000055e8d2eac019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let count = lst.count\n \
    \   if count == 0 {\n        return true\n    }\n    if count == 1 {\n       \
    \ return lst.first! < lst.last!\n    }\n    if count > 1 {\n        for (i, value)\
    \ in lst.enumerated() {\n            if i == 0 {\n                if value >=\
    \ lst.first! {\n                    return false\n                }\n        \
    \    } else if value == lst.last! {\n                return false\n          \
    \  } else if value < lst.first! {\n                if i == count - 1 {\n     \
    \               return true\n                } else {\n                    return\
    \ false\n                }\n            } else {\n                if i == count\
    \ - 1 {\n                    return false\n                } else {\n        \
    \            return true\n                }\n            }\n        }\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpf3m1c36x/tmpf3m1c36x.swift:69: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a9c593c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a9c28ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a9c28a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a9c2897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf3m1c36x                        0x000055be3bdcb72a <unavailable> + 5930

    5    libc.so.6                          0x00002b8a9c77f460 __libc_start_main +
    245

    6    tmpf3m1c36x                        0x000055be3bdcb3a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\treturn is_sorted(lst, cmp:\
    \ is_sorted_cmp)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp59__c46m.swift:23:29: error: cannot find 'is_sorted_cmp' in scope\n\
    \        return is_sorted(lst, cmp: is_sorted_cmp)\n                         \
    \          ^~~~~~~~~~~~~\n/tmp/tmp59__c46m.swift:23:29: error: extra argument\
    \ 'cmp' in call\n        return is_sorted(lst, cmp: is_sorted_cmp)\n         \
    \               ~~~~~~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let last = lst[0]\n    for\
    \ x in lst {\n        if x == last {\n            return false\n        }\n  \
    \      last = x\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0ujod8nm.swift:28:9: error: cannot assign to value: 'last' is a\
    \ 'let' constant\n        last = x\n        ^~~~\n/tmp/tmp0ujod8nm.swift:23:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let last = lst[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tis_sorted_impl(lst)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmytigptt.swift:23:2: error: cannot find 'is_sorted_impl' in scope\n\
    \        is_sorted_impl(lst)\n        ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  guard lst.count < 2 else {\
    \ return true }\n  guard lst.count > 1 else {\n    return true\n  }\n  var hashmap\
    \ = Dictionary<Int>()\n  var inMap = Dictionary<Int>()\n  for i in 0 ..< lst.count\
    \ {\n    var key = lst[i]\n    if let oldVal = hashmap[key] {\n      if oldVal\
    \ == i {\n        return false\n      }\n    } else {\n      hashmap[key] = i\n\
    \    }\n    if let oldVal = inMap[key - 1] {\n      if oldVal == i {\n       \
    \ return false\n      }\n    } else {\n      inMap[key - 1] = i\n    }\n  }\n\
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqmwak7v8.swift:27:17: error: generic type 'Dictionary' specialized\
    \ with too few type parameters (got 1, but expected 2)\n  var hashmap = Dictionary<Int>()\n\
    \                ^         ~~~~~\nSwift.Dictionary:1:23: note: generic type 'Dictionary'\
    \ declared here\n@frozen public struct Dictionary<Key, Value> where Key : Hashable\
    \ {\n                      ^\n/tmp/tmpqmwak7v8.swift:28:15: error: generic type\
    \ 'Dictionary' specialized with too few type parameters (got 1, but expected 2)\n\
    \  var inMap = Dictionary<Int>()\n              ^         ~~~~~\nSwift.Dictionary:1:23:\
    \ note: generic type 'Dictionary' declared here\n@frozen public struct Dictionary<Key,\
    \ Value> where Key : Hashable {\n                      ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  var i = 0\n  var len = lst.count\n\
    \n  while (i < len) {\n    var j = i + 1\n    while (j < len) {\n      if lst[i]\
    \ > lst[j] {\n        return false\n      }\n      j++\n    }\n    i++\n  }\n\n\
    \  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg6jl9j1b.swift:32:8: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n      j++\n       ^~\n/tmp/tmpg6jl9j1b.swift:34:6: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n    i++\n     ^~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 || lst.first\
    \ == lst.last { return true }\n    // we do have negative numbers here\n    if\
    \ let x = lst.first, let y = lst.last {\n        if x == y { return true }\n \
    \       if x < y { return false }\n        for pos in 0..<min(lst.count, y-x)\
    \ {\n            if lst[pos] > x {\n                return false\n           \
    \ }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp4d35ik5w/tmp4d35ik5w.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9618c7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9618975b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9618975988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b96189747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4d35ik5w                        0x000055691f04f7b7 <unavailable> + 6071

    5    libc.so.6                          0x00002b9618e6a460 __libc_start_main +
    245

    6    tmp4d35ik5w                        0x000055691f04f369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var firstDuplicateIndex =\
    \ -1\n    for i in lst {\n        for j in lst {\n            if i != j && i ==\
    \ j {\n                firstDuplicateIndex = j\n            }\n        }\n   \
    \ }\n    return firstDuplicateIndex >= 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp13mgvgqu/tmp13mgvgqu.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b289cacdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b289c7c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b289c7c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b289c7c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp13mgvgqu                        0x00005605a73e545a <unavailable> + 5210

    5    libc.so.6                          0x00002b289ccb9460 __libc_start_main +
    245

    6    tmp13mgvgqu                        0x00005605a73e50d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  // This code doesn't work for\
    \ large arrays. It's more efficient to\n  // convert it to an array, sort, and\
    \ then compare the two arrays.\n  guard lst.count > 1 else { return true }\n \
    \ let a = Array(lst)\n  a.sort()\n  return a == a // This is O(n*log(n))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp45_w9836.swift:27:5: error: cannot use mutating member on immutable\
    \ value: 'a' is a 'let' constant\n  a.sort()\n  ~ ^\n/tmp/tmp45_w9836.swift:26:3:\
    \ note: change 'let' to 'var' to make it mutable\n  let a = Array(lst)\n  ^~~\n\
    \  var\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tswitch lst.count {\n\tcase\
    \ 0:\n\t\treturn true\n\tcase 1:\n\t\treturn lst[0] == 0\n\tdefault:\n\t\tlet\
    \ pivot = lst.sort()[0]\n\t\treturn pivot == 0\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4sh12gxi.swift:29:19: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n                let pivot = lst.sort()[0]\n\
    \                            ~~~ ^\n/tmp/tmp4sh12gxi.swift:29:25: error: value\
    \ of type '()' has no subscripts\n                let pivot = lst.sort()[0]\n\
    \                            ~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst.sorted())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbcl0j0r9.swift:23:22: error: missing argument label 'lst:' in call\n\
    \    return is_sorted(lst.sorted())\n                     ^\n                \
    \     lst: \n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    for\
    \ number in lst {\n        if set.contains(number) == false {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpm6wcvmc1/tmpm6wcvmc1.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49ad125c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49ace1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49ace1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49ace1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm6wcvmc1                        0x000055f325c7e6f6 <unavailable> + 5878

    5    libc.so.6                          0x00002b49ad311460 __libc_start_main +
    245

    6    tmpm6wcvmc1                        0x000055f325c7e1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  if lst.len() == 0 {\n    return\
    \ true\n  }\n\n  var prev: Int = 0\n  for cur, _ in lst.enumerated() {\n    if\
    \ cur > prev {\n      return false\n    }\n\n    prev = cur\n  }\n\n  return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe0ncr4gl.swift:28:10: error: expected 'in' after for-each pattern\n\
    \  for cur, _ in lst.enumerated() {\n         ^\n/tmp/tmpe0ncr4gl.swift:28:10:\
    \ error: expected Sequence expression for for-each loop\n  for cur, _ in lst.enumerated()\
    \ {\n         ^\n/tmp/tmpe0ncr4gl.swift:23:10: error: value of type '[Int]' has\
    \ no member 'len'\n  if lst.len() == 0 {\n     ~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\treturn is_sorted(lst, equals:\
    \ equals)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp00ynwswr.swift:23:32: error: cannot find 'equals' in scope\n  \
    \      return is_sorted(lst, equals: equals)\n                               \
    \       ^~~~~~\n/tmp/tmp00ynwswr.swift:23:32: error: extra argument 'equals' in\
    \ call\n        return is_sorted(lst, equals: equals)\n                      \
    \  ~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count > 1 {\n    \
    \    return false\n    }\n    for x in lst {\n        if x < lst[0] {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpaso1rji5/tmpaso1rji5.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3ad8d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3ad5ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3ad5ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3ad5cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaso1rji5                        0x000055a17e3a05d7 <unavailable> + 5591

    5    libc.so.6                          0x00002ba3adac3460 __libc_start_main +
    245

    6    tmpaso1rji5                        0x000055a17e3a0189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  var counts: [Int] = [0]\n \
    \ var has_dup = false // whether we encountered a duplicate number\n  var is_sorted\
    \ = true // is list sorted?\n  var min_val = Int64(math.MinInt64) // the smallest\
    \ number in list\n  var max_val = Int64(math.MaxInt64) // the largest number in\
    \ list\n  var min_idx = 0 // index of smallest number\n  var max_idx = 0 // index\
    \ of largest number\n  for idx, val in enumerate(lst) {\n    counts[idx] = counts[idx]\
    \ + 1\n    if val < min_val {\n      min_val = val\n      min_idx = idx\n    }\n\
    \    if val > max_val {\n      max_val = val\n      max_idx = idx\n    }\n   \
    \ if counts[idx] > 1 {\n      has_dup = true\n    }\n  }\n  guard has_dup || min_val\
    \ == max_val else {\n    return false\n  }\n  for idx in counts {\n    if idx\
    \ == 0 {\n      is_sorted = is_sorted && lst[idx] == min_val\n    } else {\n \
    \     is_sorted = is_sorted && lst[idx] == lst[idx - 1]\n    }\n  }\n  return\
    \ is_sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpr0_xjzjo.swift:30:10: error: expected 'in' after for-each pattern\n\
    \  for idx, val in enumerate(lst) {\n         ^\n/tmp/tmpr0_xjzjo.swift:30:10:\
    \ error: expected Sequence expression for for-each loop\n  for idx, val in enumerate(lst)\
    \ {\n         ^\n/tmp/tmpr0_xjzjo.swift:26:23: error: cannot find 'math' in scope\n\
    \  var min_val = Int64(math.MinInt64) // the smallest number in list\n       \
    \               ^~~~\n/tmp/tmpr0_xjzjo.swift:27:23: error: cannot find 'math'\
    \ in scope\n  var max_val = Int64(math.MaxInt64) // the largest number in list\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tlet sorted = sorted(lst)\n\t\
    if !sorted {\n\t\treturn false\n\t}\n\tvar seen: Set<Int> = Set()\n\tfor item\
    \ in lst {\n\t\tif item == sorted(item) || seen.contains(item) {\n\t\t\treturn\
    \ false\n\t\t}\n\t\tseen.insert(item)\n\t}\n\treturn true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuymipoxm.swift:23:15: error: use of local variable 'sorted' before\
    \ its declaration\n        let sorted = sorted(lst)\n                     ^\n\
    /tmp/tmpuymipoxm.swift:23:6: note: 'sorted' declared here\n        let sorted\
    \ = sorted(lst)\n            ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    let set = Set(lst)\n    return\
    \ set.count == lst.count && set == lst\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzzp1xw85.swift:24:42: error: conflicting arguments to generic parameter\
    \ 'Self' ('Set<Int>' vs. '[Int]')\n    return set.count == lst.count && set ==\
    \ lst\n                                         ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard let lst = lst else\
    \ { return false }\n    let sorted = lst.sorted(by: <)\n    return sorted.count\
    \ == lst.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp65lwtfhl.swift:23:11: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    guard let lst = lst else { return\
    \ false }\n          ^         ~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, lessThan:\
    \ max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3r7htvj0.swift:23:37: error: generic parameter 'T' could not be\
    \ inferred\n    return is_sorted(lst, lessThan: max)\n                       \
    \             ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public\
    \ func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmp3r7htvj0.swift:23:37: error: extra argument 'lessThan' in call\n\
    \    return is_sorted(lst, lessThan: max)\n                    ~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 { return\
    \ true }\n    var last: Int = 0\n    for i in 0 ..< lst.count {\n        if lst[i]\
    \ != last { continue }\n        if i > 0 {\n            if lst[i - 1] == lst[i]\
    \ { return false }\n        }\n        last, i = i, i + 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgccacn5z.swift:30:13: error: consecutive statements on a line must\
    \ be separated by ';'\n        last, i = i, i + 1\n            ^\n           \
    \ ;\n/tmp/tmpgccacn5z.swift:30:13: error: expected expression\n        last, i\
    \ = i, i + 1\n            ^\n/tmp/tmpgccacn5z.swift:30:9: warning: variable is\
    \ unused\n        last, i = i, i + 1\n        ^~~~\n/tmp/tmpgccacn5z.swift:24:9:\
    \ warning: variable 'last' was never mutated; consider changing to 'let' constant\n\
    \    var last: Int = 0\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.hasDuplicates {\n\
    \        return false\n    }\n    if lst.count == 0 {\n        return true\n \
    \   }\n    var min: Int = 0\n    var max = Int((lst.count - 1) * lst.count)\n\
    \    for value in lst {\n        if value < min {\n            min = value\n \
    \       }\n        if value > max {\n            max = value\n        }\n    }\n\
    \    return min <= max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpxbbj_4_x.swift:23:12: error: value of type '[Int]' has no member\
    \ 'hasDuplicates'\n    if lst.hasDuplicates {\n       ~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    switch lst.count {\n    case\
    \ 1:\n        return lst[0] < lst[1]\n    case 2:\n        return lst[0] < lst[1]\
    \ && lst[0] < lst[2]\n    case 3:\n        return lst[0] < lst[1] && lst[0] <\
    \ lst[2] && lst[0] < lst[3]\n    case 4:\n        return lst[0] < lst[1] && lst[0]\
    \ < lst[2] && lst[0] < lst[3] && lst[0] < lst[4]\n    default:\n        let min\
    \ = 0\n        let max = lst.count - 1\n        while min < max {\n          \
    \  let mid = min + ((max - min) / 2)\n            if lst[mid] < lst[min] || lst[mid]\
    \ < lst[max] {\n                min = mid\n            } else {\n            \
    \    max = mid\n            }\n        }\n        return lst[min] < lst[min+1]\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnr5ynlgg.swift:38:17: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n                min = mid\n                ^~~\n/tmp/tmpnr5ynlgg.swift:33:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let min = 0\n      \
    \  ^~~\n        var\n/tmp/tmpnr5ynlgg.swift:40:17: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n                max = mid\n                ^~~\n\
    /tmp/tmpnr5ynlgg.swift:34:9: note: change 'let' to 'var' to make it mutable\n\
    \        let max = lst.count - 1\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    switch lst.count {\n    case\
    \ 1:\n        return true\n    case 2:\n        return lst[0] < lst[1]\n    default:\n\
    \        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpaqa5r2y1/tmpaqa5r2y1.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f2abb2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f2a8a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f2a8a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f2a8a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaqa5r2y1                        0x000055d9d6ac3467 <unavailable> + 5223

    5    libc.so.6                          0x00002b3f2ad9e460 __libc_start_main +
    245

    6    tmpaqa5r2y1                        0x000055d9d6ac3019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tvar cnt : Int = 0\n\tfor i\
    \ : Int in lst {\n\t\tcnt += i\n\t\tif cnt > 1 {\n\t\t\treturn false\n\t\t}\n\t\
    }\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp4w3d0m27/tmp4w3d0m27.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78facd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78fa9c8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78fa9c8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78fa9c77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4w3d0m27                        0x000055fdc470245a <unavailable> + 5210

    5    libc.so.6                          0x00002b78faebd460 __libc_start_main +
    245

    6    tmp4w3d0m27                        0x000055fdc47020d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    return is_sorted(lst, is_less)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4zrq0apw.swift:23:27: error: cannot find 'is_less' in scope\n \
    \   return is_sorted(lst, is_less)\n                          ^~~~~~~\n/tmp/tmp4zrq0apw.swift:23:27:\
    \ error: extra argument in call\n    return is_sorted(lst, is_less)\n        \
    \            ~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013916
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 1 {\n    \
    \    return false\n    }\n    // Create a map of first item and count of items\n\
    \    let map: [Int: Int] = [:]\n    for item in lst {\n        if map.keys.contains(item)\
    \ {\n            // duplicate item found\n            return false\n        }\
    \ else {\n            map[item] = 1\n        }\n    }\n    // At this point we\
    \ know that every item in the array maps to an item\n    // which is not present\
    \ in the map\n    let unsorted = Set<Int>(map.keys)\n    sorted = unsorted.isSorted\
    \ ? unsorted.sorted : []\n    if sorted.count != lst.count {\n        return false\n\
    \    }\n    for idx in lst {\n        if idx < sorted[0] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpclk9ytnx.swift:33:16: error: cannot assign through subscript: 'map'\
    \ is a 'let' constant\n            map[item] = 1\n            ~~~^\n/tmp/tmpclk9ytnx.swift:27:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let map: [Int: Int] = [:]\n\
    \    ^~~\n    var\n/tmp/tmpclk9ytnx.swift:39:5: error: cannot find 'sorted' in\
    \ scope\n    sorted = unsorted.isSorted ? unsorted.sorted : []\n    ^~~~~~\n/tmp/tmpclk9ytnx.swift:39:23:\
    \ error: value of type 'Set<Int>' has no member 'isSorted'\n    sorted = unsorted.isSorted\
    \ ? unsorted.sorted : []\n             ~~~~~~~~ ^~~~~~~~\n/tmp/tmpclk9ytnx.swift:39:43:\
    \ error: result values in '? :' expression have mismatching types '() -> [Int]'\
    \ and '[Int]'\n    sorted = unsorted.isSorted ? unsorted.sorted : []\n       \
    \                          ~~~~~~~~~^~~~~~\n/tmp/tmpclk9ytnx.swift:40:8: error:\
    \ cannot find 'sorted' in scope\n    if sorted.count != lst.count {\n       ^~~~~~\n\
    /tmp/tmpclk9ytnx.swift:44:18: error: cannot find 'sorted' in scope\n        if\
    \ idx < sorted[0] {\n                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var prev:Int = 0\n    for\
    \ i : Int in lst {\n        if i != prev {\n            return false\n       \
    \ }\n        prev = i\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp16am0xt4/tmp16am0xt4.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b865ae44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b865ab3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b865ab3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b865ab3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16am0xt4                        0x000055bdbbede45a <unavailable> + 5210

    5    libc.so.6                          0x00002b865b030460 __libc_start_main +
    245

    6    tmp16am0xt4                        0x000055bdbbede0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var count = 0\n    for num\
    \ in lst {\n        if count > 1 {\n            return false\n        }\n    \
    \    for _n in lst {\n            if num == _n && num <= num {\n             \
    \   return false\n            }\n        }\n        count += 1\n    }\n    return\
    \ count == 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpd9_m9wl3/tmpd9_m9wl3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23fe9cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23fe6c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23fe6c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23fe6c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd9_m9wl3                        0x0000562895b8f45a <unavailable> + 5210

    5    libc.so.6                          0x00002b23febb7460 __libc_start_main +
    245

    6    tmpd9_m9wl3                        0x0000562895b8f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // Check for duplicates\n\
    \    var last: Int?\n    for var i = 0; i < lst.count; i++ {\n        if last?\
    \ == lst[i] {\n            return false\n        }\n        last = lst[i]\n  \
    \  }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmrlok7y5.swift:25:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < lst.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.length <= 1 {\n  \
    \      return true\n    }\n\n    var seen = [Int]()\n    for x in lst {\n    \
    \    if seen[x] == nil {\n            seen[x] = true\n            return false\n\
    \        } else {\n            seen[x] = nil\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_ilg1ivz.swift:23:12: error: value of type '[Int]' has no member\
    \ 'length'\n    if lst.length <= 1 {\n       ~~~ ^~~~~~\n/tmp/tmp_ilg1ivz.swift:29:20:\
    \ warning: comparing non-optional value of type 'Int' to 'nil' always returns\
    \ false\n        if seen[x] == nil {\n           ~~~~~~~ ^  ~~~\n/tmp/tmp_ilg1ivz.swift:30:23:\
    \ error: cannot assign value of type 'Bool' to subscript of type 'Int'\n     \
    \       seen[x] = true\n                      ^~~~\n/tmp/tmp_ilg1ivz.swift:33:23:\
    \ error: 'nil' cannot be assigned to subscript of type 'Int'\n            seen[x]\
    \ = nil\n                      ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    guard lst.count <= 1 else\
    \ {\n        return false\n    }\n\n    var sortedSet: [Int] = []\n\n    for num\
    \ in lst {\n        if !sortedSet.contains(num) {\n            sortedSet.append(num)\n\
    \        }\n    }\n    return sortedSet.count == lst.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpypsjmzpf/tmpypsjmzpf.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc8fef9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc8fbf0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc8fbf0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc8fbef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpypsjmzpf                        0x000055eaa4b11647 <unavailable> + 5703

    5    libc.so.6                          0x00002afc900e5460 __libc_start_main +
    245

    6    tmpypsjmzpf                        0x000055eaa4b111f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    // Sort the list\n    var\
    \ sortedList = lst\n    let count = sortedList.count\n    for i in 0..<count {\n\
    \        for j in 0..<count {\n            // If current value is less than or\
    \ equal to the next one,\n            // then array is not sorted\n          \
    \  if sortedList[i] >= sortedList[j] {\n                return false\n       \
    \     }\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpsmere83g/tmpsmere83g.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5116785c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b511647cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b511647c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b511647b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsmere83g                        0x0000559ee115b52a <unavailable> + 5418

    5    libc.so.6                          0x00002b5116971460 __libc_start_main +
    245

    6    tmpsmere83g                        0x0000559ee115b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count < 2 {\n    \
    \    return true\n    }\n\n    var i = 0\n    var j = 0\n    var count = 0\n\n\
    \    while i < lst.count && j < lst.count {\n        if lst[i] < lst[j] {\n  \
    \          count = count + 1\n            i = i + 1\n        }\n        else if\
    \ lst[i] > lst[j] {\n            count = count + 1\n            j = j + 1\n  \
    \      }\n        else {\n            count = count + 1\n            i = i + 1\n\
    \            j = j + 1\n        }\n    }\n\n    if count > 1 {\n        return\
    \ false\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpvpfbrg3i/tmpvpfbrg3i.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b172d15dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b172ce54b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b172ce54988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b172ce537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvpfbrg3i                        0x00005606b3912467 <unavailable> + 5223

    5    libc.so.6                          0x00002b172d349460 __libc_start_main +
    245

    6    tmpvpfbrg3i                        0x00005606b3912019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif is_sorted_tail(lst) { return\
    \ true }\n\t\n\tvar i : Int = 0\n\tvar prev : Int = lst[0]\n\tfor ; i + 1 < lst.count;\
    \ i += 1  {\n\t\tif lst[i] != prev { \n\t\t\treturn false\n\t\t}\n\t\tprev = lst[i]\n\
    \t}\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp71m3b1v5.swift:27:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for ; i + 1 < lst.count; i += 1  {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp71m3b1v5.swift:23:5: error: cannot find 'is_sorted_tail' in scope\n  \
    \      if is_sorted_tail(lst) { return true }\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted {\n       \
    \ return true\n    }\n    // Find the first index in the array that is different\
    \ from the last\n    let (first, rest) = lst.split_at_index(lst.count - 1)\n \
    \   for rest in lst {\n        if rest < first {\n            return false\n \
    \       }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst:\
    \ [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmse9_nbk.swift:23:12: error: no 'sorted' candidates produce the\
    \ expected contextual result type 'Bool'\n    if lst.sorted {\n           ^\n\
    Swift.Sequence:2:28: note: found candidate with type '() -> [Int]'\n    @inlinable\
    \ public func sorted() -> [Self.Element]\n                           ^\nSwift.Sequence:2:28:\
    \ note: found candidate with type '((Int, Int) throws -> Bool) throws -> [Int]'\n\
    \    @inlinable public func sorted(by areInIncreasingOrder: (Self.Element, Self.Element)\
    \ throws -> Bool) rethrows -> [Self.Element]\n                           ^\n/tmp/tmpmse9_nbk.swift:27:29:\
    \ error: value of type '[Int]' has no member 'split_at_index'\n    let (first,\
    \ rest) = lst.split_at_index(lst.count - 1)\n                        ~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var hashSet = Set<Int>()\n\
    \    var sorted: Set<Int> = Set()\n    for num in lst {\n        if hashSet.contains(num)\
    \ {\n            return false\n        }\n        hashSet.add(num)\n        sorted.insert(num)\n\
    \    }\n    return sorted.count == lst.count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzmwlqgo6.swift:29:17: error: value of type 'Set<Int>' has no member\
    \ 'add'\n        hashSet.add(num)\n        ~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660014116
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var seen = [Int]()\n    for\
    \ val in lst {\n        if seen[val] != nil {\n            return false\n    \
    \    }\n        seen[val] = val\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b16879b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16876b0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b16876b0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b16876b013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b16876afbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b16874afe83 <unavailable> + 188035

    6    tmpyaxtqmoj                        0x0000557cf8024137 <unavailable> + 8503

    7    tmpyaxtqmoj                        0x0000557cf80234e5 <unavailable> + 5349

    8    libc.so.6                          0x00002b1687ba5460 __libc_start_main +
    245

    9    tmpyaxtqmoj                        0x0000557cf80231d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tcnt := counting(lst, 0)\n\t\
    return cnt <= 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5])\
    \ == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph9n6y79k.swift:23:5: error: consecutive statements on a line must\
    \ be separated by ';'\n        cnt := counting(lst, 0)\n           ^\n       \
    \    ;\n/tmp/tmph9n6y79k.swift:23:6: error: expected expression\n        cnt :=\
    \ counting(lst, 0)\n            ^\n/tmp/tmph9n6y79k.swift:23:2: error: cannot\
    \ find 'cnt' in scope\n        cnt := counting(lst, 0)\n        ^~~\n/tmp/tmph9n6y79k.swift:24:9:\
    \ error: cannot find 'cnt' in scope\n        return cnt <= 1\n               ^~~\n"
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif lst.count == 0 {\n\t\treturn\
    \ true\n\t}\n\tfirst := lst[0]\n\tlast := lst[lst.count-1]\n\tfor i := 0; i <\
    \ lst.count; i++ {\n\t\tif lst[i] < first {\n\t\t\treturn false\n\t\t}\n\t\tif\
    \ lst[i] > last {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzysg91p1.swift:26:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        first := lst[0]\n             ^\n             ;\n\
    /tmp/tmpzysg91p1.swift:26:8: error: expected expression\n        first := lst[0]\n\
    \              ^\n/tmp/tmpzysg91p1.swift:28:9: error: expected type\n        for\
    \ i := 0; i < lst.count; i++ {\n               ^\n                <#type#>\n/tmp/tmpzysg91p1.swift:28:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < lst.count;\
    \ i++ {\n               ^\n/tmp/tmpzysg91p1.swift:28:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < lst.count; i++ {\n   \
    \            ^\n/tmp/tmpzysg91p1.swift:26:2: error: cannot find 'first' in scope\n\
    \        first := lst[0]\n        ^~~~~\n"
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.sorted { return true\
    \ }\n    let count = lst.count\n    var i = 0\n    while i < count - 1 {\n   \
    \     if lst[i] == lst[i + 1] {\n            i += 2\n            continue\n  \
    \      }\n        if lst[i] > lst[i + 1] {\n            return false\n       \
    \ }\n        i += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpik3gg1fe.swift:23:12: error: no 'sorted' candidates produce the\
    \ expected contextual result type 'Bool'\n    if lst.sorted { return true }\n\
    \           ^\nSwift.Sequence:2:28: note: found candidate with type '() -> [Int]'\n\
    \    @inlinable public func sorted() -> [Self.Element]\n                     \
    \      ^\nSwift.Sequence:2:28: note: found candidate with type '((Int, Int) throws\
    \ -> Bool) throws -> [Int]'\n    @inlinable public func sorted(by areInIncreasingOrder:\
    \ (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\n  \
    \                         ^\n"
  stdout: ''
  timestamp: 1660014116
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var last = lst[0]\n    for\
    \ value in lst {\n        if value < last {\n            return false\n      \
    \  }\n        last = value\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2,\
    \ 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3e6582c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3e6279561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab3e6279286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab3e627913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab3e6278bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab3e6078e83 <unavailable> + 188035

    6    tmp49x9v2rz                        0x0000559de60e2fc2 <unavailable> + 8130

    7    tmp49x9v2rz                        0x0000559de60e2954 <unavailable> + 6484

    8    libc.so.6                          0x00002ab3e676e460 __libc_start_main +
    245

    9    tmp49x9v2rz                        0x0000559de60e2129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    if lst.count == 0 {\n   \
    \     return true\n    }\n    var prev = 0\n    for x in lst {\n        if x ==\
    \ prev {\n            return false\n        }\n        prev = x\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_sorted(lst: [5]) ==\
    \ true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst:\
    \ [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1,\
    \ 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst: [] as [Int]) == true)\n\
    assert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\n\
    assert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\n\
    assert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp8f15vpfn/tmp8f15vpfn.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e38eafc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e38ba6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e38ba6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e38ba57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8f15vpfn                        0x000055678ad10646 <unavailable> + 5702

    5    libc.so.6                          0x00002b7e3909b460 __libc_start_main +
    245

    6    tmp8f15vpfn                        0x000055678ad10129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n  // Count up how many duplicate\
    \ numbers were found so far.\n  var dupeCount = 0\n  var lastDupe : Int? = nil\n\
    \  for number in lst {\n    if lastDupe != nil && lastDupe == number {\n     \
    \ dupeCount += 1\n    } else {\n      lastDupe = number\n    }\n  }\n\n  // If\
    \ there are not enough numbers in the array to know if sorted,\n  // then return\
    \ false.\n  if dupeCount < 3 {\n    return false\n  }\n\n  // Otherwise, return\
    \ true if the first number is greater than the\n  // second number in the list.\n\
    \  var firstNumber = lst[0]\n  var secondNumber = lst[1]\n  for number in lst\
    \ {\n    if number == firstNumber {\n      firstNumber = number\n    } else {\n\
    \      secondNumber = number\n    }\n  }\n  return firstNumber > secondNumber\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmp0r4m6b4w/tmp0r4m6b4w.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91fbff5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91fbcecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91fbcec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91fbceb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0r4m6b4w                        0x000055c10bca14aa <unavailable> + 5290

    5    libc.so.6                          0x00002b91fc1e1460 __libc_start_main +
    245

    6    tmp0r4m6b4w                        0x000055c10bca1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014116
- exit_code: 1
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n\tif lst.sort != nil && lst.count\
    \ > 1 {\n\t\treturn false\n\t}\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4,\
    \ 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4, 5, 6, 7]) ==\
    \ true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) == false)\nassert(is_sorted(lst:\
    \ [] as [Int]) == true)\nassert(is_sorted(lst: [1]) == true)\nassert(is_sorted(lst:\
    \ [3, 2, 1]) == false)\nassert(is_sorted(lst: [1, 2, 2, 2, 3, 4]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) == false)\nassert(is_sorted(lst: [1,\
    \ 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst: [1, 2, 3, 4]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcqtbdioa.swift:23:9: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n        if lst.sort != nil && lst.count >\
    \ 1 {\n           ~~~ ^\n/tmp/tmpcqtbdioa.swift:23:9: error: cannot reference\
    \ 'mutating' method as function value\n        if lst.sort != nil && lst.count\
    \ > 1 {\n               ^\n"
  stdout: ''
  timestamp: 1660014116
- exit_code: -4
  program: "\n/// Given an array of numbers, return whether or not they are sorted\n\
    /// in ascending order. If array has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(lst: [5])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(lst: [1, 2, 3, 4, 5, 6, 7])\n\
    /// true\n/// >>> is_sorted(lst: [1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(lst:\
    \ [1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(lst: [1, 2, 2, 2, 3, 4])\n\
    /// false\nfunc is_sorted(lst: [Int]) -> Bool {\n    var hasDups = false\n   \
    \ var result = 0\n    for i in lst {\n        if result != i {\n            result\
    \ = i\n            hasDups = true\n        }\n    }\n    return hasDups\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_sorted(lst: [5]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4, 5]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5]) == false)\n\
    assert(is_sorted(lst: [1, 2, 3, 4, 5, 6]) == true)\nassert(is_sorted(lst: [1,\
    \ 2, 3, 4, 5, 6, 7]) == true)\nassert(is_sorted(lst: [1, 3, 2, 4, 5, 6, 7]) ==\
    \ false)\nassert(is_sorted(lst: [] as [Int]) == true)\nassert(is_sorted(lst: [1])\
    \ == true)\nassert(is_sorted(lst: [3, 2, 1]) == false)\nassert(is_sorted(lst:\
    \ [1, 2, 2, 2, 3, 4]) == false)\nassert(is_sorted(lst: [1, 2, 3, 3, 3, 4]) ==\
    \ false)\nassert(is_sorted(lst: [1, 2, 2, 3, 3, 4]) == true)\nassert(is_sorted(lst:\
    \ [1, 2, 3, 4]) == true)"
  status: Exception
  stderr: 'tmpd6zk0fhi/tmpd6zk0fhi.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4df2cf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4df29eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4df29ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4df29e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd6zk0fhi                        0x000055ae8b36e5f6 <unavailable> + 5622

    5    libc.so.6                          0x00002b4df2edf460 __libc_start_main +
    245

    6    tmpd6zk0fhi                        0x000055ae8b36e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014116
