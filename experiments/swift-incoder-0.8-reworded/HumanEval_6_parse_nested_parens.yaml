name: HumanEval_6_parse_nested_parens
language: swift
prompt: "\n/// Input to this function is a string represented multiple groups for\
  \ nested parentheses separated by spaces.\n/// For each of the group, output the\
  \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
  \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
  \ String) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()())\
  \ ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
  \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
  \ \"(()(())((())))\") == [4])"
completions: ["    var count = 0\n    for group in paren_string.unicodeScalars {\n\
    \        if group == '(' {\n            count += 1\n        } else if group ==\
    \ ')' {\n            count -= 1\n        }\n    }\n    return count", "    var\
    \ max_level = 0\n    var levels = [Int]()\n    for sub in split(paren_string)\
    \ {\n        let level = sub\n        if level > max_level {\n            max_level\
    \ = level\n        }\n        if level == max_level {\n            levels.append(level)\n\
    \        }\n    }\n    return levels", "    // Convert string representation of\
    \ parenthesis to an array\n    let chars = paren_string.characters()\n    \n \
    \   // Initialize an array to store result\n    var result = [Int]()\n    \n \
    \   // Initialize a stack for keeping track of nested parenthesis\n    var stack\
    \ = [String]()\n    \n    // Initialize a count variable for keeping track of\
    \ parenthesis\n    var count = 1\n    \n    // Iterate through characters in string\
    \ and keep track of parenthesis\n    for char in chars {\n        // If character\
    \ is an opening parenthesis, append it to the stack\n        if char == \"(\"\
    \ {\n            stack.append(char)\n        }\n        // If character is a closing\
    \ parenthesis, remove the last element from stack\n        else if char == \"\
    )\" {\n            stack.remove(at: stack.count-1)\n        }\n        // If character\
    \ is a space or end of string, add the count of the number of closing parenthesis\n\
    \        else if char == \" \" || char == nil { \n            result.append(Int(count))\
    \ \n            count -= 1\n        }\n    }\n    \n    return result", "    var\
    \ result = [Int]()\n    for parens in paren_string.components(separatedBy: \"\
    \ \") {\n        if parens.contains(\"(\") {\n            if let last = result.last\
    \ {\n                result.remove(at: last)\n            }\n            result.append(1)\n\
    \        } else {\n            result.append(0)\n        }\n    }\n    return\
    \ result", "    var max_level = [0]\n\n    for group_index in 0..<paren_string.characters.count\
    \ {\n        let opening_char = paren_string[group_index : group_index+1]\n  \
    \      if opening_char == \")\" && paren_string[group_index+1 : group_index+2].characters.count\
    \ == 1 {\n            if max_level[0] < 1 {\n                max_level[0] = 1\n\
    \            } else {\n                max_level[0] = max(max_level[0], max_level[0]\
    \ - 1)\n            }\n        }\n    }\n\n    if max_level[0] != 0 {\n      \
    \  max_level[0] = max(max_level[0], max_level[0] + 1)\n    }\n\n    return max_level",
  "    var output = [Int]()\n    var opening = 0\n    for ch in paren_string.characters\
    \ {\n        switch ch {\n        case \")\":\n            opening--\n       \
    \     if opening == 0 {\n                output.append(0)\n            }\n   \
    \     case \")\":\n            opening++\n        }\n    }\n    return output",
  "    var max_levels = [0]\n    var level = 0\n    for _groupString in paren_string.split(\"\
    \ \") {\n        if _groupString.isEmpty() {\n            continue\n        }\n\
    \        var groupLevels = String(_groupString).split(parenRegex).filter{$0 !=\
    \ \"()\"}\n        if groupLevels.count > level {\n            max_levels = [level]\n\
    \        }\n        for _ in 0..<groupLevels.count {\n            level += 1 //\
    \ increment level if we have a non-nested paren\n            max_levels = append(max_levels,\
    \ level)\n        }\n    }\n    return max_levels", "    var level = 1\n\n   \
    \ // Find maximum depth of the parentheses\n    for i in 1 ..< paren_string.count\
    \ {\n        if paren_string[i] == '(' && paren_string[i-1] == ')' {\n       \
    \     level++\n        } else if paren_string[i] == '{' && paren_string[i-1] ==\
    \ '}' {\n            level++\n        } else if paren_string[i] == '[' && paren_string[i-1]\
    \ == ']' {\n            level++\n        } else if paren_string[i] == '<' && paren_string[i-1]\
    \ == '>' {\n            level++\n        } else if paren_string[i] == '(' && paren_string[i-1]\
    \ == ']' {\n            level--\n        } else if paren_string[i] == '{' && paren_string[i-1]\
    \ == '<' {\n            level--\n        } else if paren_string[i] == '<' && paren_string[i-1]\
    \ == '{' {\n            level--\n        }\n    }\n\n    var output = [Int]()\n\
    \    var openingBrackets = 1\n    var closingBrackets = 1\n\n    // Find the deepest\
    \ level of nested parentheses\n    for i in paren_string.characters.reversed().enumerated()\
    \ {\n        let c = i.element\n        if c == ')' {\n            closingBrackets--\n\
    \        } else if c == '(' {\n            openingBrackets++\n        }\n    \
    \    if closingBrackets == 0 {\n            if openingBrackets == 0 {\n      \
    \          output.append(level)\n            }\n            level--\n        }\n\
    \    }\n    return output", "    var levels: [Int] = [Int]()\n    var last_level\
    \ = 0\n    var last_level_end = 0\n    var last_level_start = 0\n    var nested_level\
    \ = 0\n    var num_levels = 0\n    var last_parens = 0\n    var opening_parens\
    \ = 0\n\n    for index in 0..<paren_string.characters.count {\n        let char:\
    \ unichar = paren_string[index] // avoid crash if a character is nil\n       \
    \ if char == '(' || char == '{' || char == '[' || char == '<' {\n            opening_parens\
    \ += 1\n            nested_level += 1 // increase nested level\n        } else\
    \ if char == ')' || char == '}' || char == ']' || char == '>' {\n            nested_level\
    \ -= 1\n            if nested_level == 0 {\n                levels[num_levels]\
    \ = index - last_level_start // last level of nesting of this group\n        \
    \    }\n        } else if opening_parens == 0 { // the first character of the\
    \ group\n            last_level_start = index\n        }\n\n        if char ==\
    \ ')' || char == '>' {\n            opening_parens -= 1\n        }\n\n       \
    \ if opening_parens == 0 && last_level_end == 0 { // last character of the group\n\
    \            last_level_end = index\n        }\n\n        if opening_parens >\
    \ 0 {\n            nested_level += 1 // increase nested level\n        } else\
    \ {\n            nested_level -= 1 // decrease nested level\n        }\n\n   \
    \     if opening_parens > last_parens {\n            last_parens = opening_parens\n\
    \            num_levels += 1\n        }\n    }\n\n    return levels", "    var\
    \ paren_count = 0\n    var max_level = 0\n    var level = 0\n    var paren_stack\
    \ = Set<String>()\n\n    for paren in paren_string.unicodeScalars {\n        if\
    \ paren_stack.contains(paren) {\n            paren_stack.subtract([paren])\n \
    \           paren_count--\n        }\n        else {\n            paren_stack.insert(paren)\n\
    \            paren_count++\n        }\n        if paren_count == 0 {\n       \
    \     level++\n        }\n        if paren_count == max_level {\n            max_level\
    \ = level\n        }\n    }\n    return Array(max_level + 1)", "    var levels\
    \ = [Int]()\n    \n    var max_level = 0\n    var paren_depth = 0\n    for c in\
    \ paren_string.unicodeScalars {\n        if c == '(' {\n            paren_depth\
    \ += 1\n        }\n        else if c == ')' {\n            paren_depth -= 1\n\
    \        }\n        if paren_depth > max_level {\n            max_level = paren_depth\n\
    \        }\n        if paren_depth < 0 {\n            levels.insert(levels.index(levels,\
    \ paren_depth), max_level)\n            max_level = 0\n        }\n    }\n    levels.insert(levels.index(levels,\
    \ paren_depth), max_level)\n    return levels", "    // Convert string to a list\
    \ of parenthesis levels based on input string.\n    var paren_string_list: String\
    \ = \"\\(paren_string)\".components(separatedBy: \" \")\n    var levels = [Int]()\n\
    \    var paren_level = 0\n    for paren_group in paren_string_list.enumerated()\
    \ {\n        var group_size = paren_group.element\n        var paren_level = 0\n\
    \        for paren_item in paren_group.offset(by: paren_group.offset) {\n    \
    \        if paren_item != paren_string_list.count {\n                group_size\
    \ += paren_string_list[paren_item].count\n            }\n            paren_level\
    \ += 1\n        }\n        levels.append(paren_level)\n    }\n    return levels",
  "    var result = [Int]()\n    var levels = [Int]()\n    var opening = 1\n    for\
    \ char in paren_string.characters {\n        if char == \")\" {\n            opening\
    \ = opening * -1\n        }\n        if opening > 0 {\n            levels.append(opening)\n\
    \            opening = 1\n        } else {\n            opening = 1\n        }\n\
    \    }\n    for char in paren_string.characters {\n        switch char {\n   \
    \     case '(':\n            if levels[0] == 0 {\n                result.append(0)\n\
    \            } else {\n                result.append(levels[0])\n            }\n\
    \            levels[0] = levels[0] * -1\n            result.append(levels[0])\n\
    \            levels = levels[1:]\n        default:\n            if levels[0] >\
    \ 0 {\n                result.append(levels[0])\n                levels = levels[1:]\n\
    \            }\n        }\n    }\n    return result", "    var levels = [0]\n\
    \    paren_string.split(\" \").forEach() {\n        if !$0.isEmpty {\n       \
    \     var level = 0\n            var index = 0\n            var i = $0.count\n\
    \            while i > 0 {\n                if paren_string[i] == \")\" {\n  \
    \                  level -= 1\n                    index++\n                 \
    \   i -= 1\n                } else if paren_string[i] == \"(\" {\n           \
    \         level += 1\n                    index++\n                    i -= 1\n\
    \                }\n            }\n            levels.append(level)\n        }\n\
    \    }\n    return levels", "    var nesting_levels = [Int]()\n    let paren_array\
    \ = paren_string.characters\n\n    for paren in paren_array {\n        if paren\
    \ == \"(\" {\n            nesting_levels.append(0)\n        } else if paren ==\
    \ \")\" {\n            let last_level = nesting_levels.popLast()\n           \
    \ if nesting_levels.isEmpty() {\n                nesting_levels.append(last_level)\n\
    \            } else {\n                nesting_levels[nesting_levels.count - 1]\
    \ = last_level\n            }\n        } else {\n            nesting_levels.append(0)\n\
    \        }\n    }\n    return nesting_levels", "\tvar parens = [Int]()\n\tswitch\
    \ paren_string {\n\tcase \"()\":\n\t\tparens = []\n\tcase \"((\", \")(\":\n\t\t\
    parens = []\n\tcase \"()((\", \")()(\":\n\t\tparens = []\n\tcase \"((()))\", \"\
    ()()()\":\n\t\tparens = []\n\tcase \"((()))((()))\", \"()()()()\":\n\t\tparens\
    \ = []\n\tdefault:\n\t\tfor _, c := range paren_string {\n\t\t\tswitch c {\n\t\
    \t\tcase \")\":\n\t\t\t\tif parens[len(parens)-1] > 0 {\n\t\t\t\t\tparens = parens[:len(parens)-1]\n\
    \t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"(\":\n\t\t\t\tparens = append(parens, 0)\n\
    \t\t\tdefault:\n\t\t\t\tparens = append(parens, 1)\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ parens", "    let parens = paren_string.characters\n    var count = [Int]()\n\
    \    \n    for paren in parens {\n        let count = count + [paren.count]\n\
    \        \n        for paren_count in count {\n            if paren_count == paren.count\
    \ {\n                count[paren_count - 1] += 1\n                break\n    \
    \        }\n        }\n    }\n    \n    return count", "    var levels = [Int]()\n\
    \    var current_level = 0\n    var paren_count = 0\n    for index in paren_string.indices(of:\
    \ paren) {\n        paren_count += 1\n        levels.append(current_level)\n \
    \       current_level += 1\n    }\n\n    var result: [Int] = []\n    for index\
    \ in paren_string.indices(of: paren) {\n        levels[paren_count] = index -\
    \ levels[paren_count]\n    }\n\n    for index in 0..<levels[paren_count] {\n \
    \       for paren_index in 0..<levels[paren_count] {\n            if paren_index\
    \ < index {\n                result.append(levels[paren_count])\n            \
    \    break\n            }\n        }\n    }\n\n    return result", "\tvar max_level\
    \ = [Int]()\n\tvar nesting = 1\n\tfor paren in paren_string.characters {\n\t\t\
    if paren == ')' {\n\t\t\tnesting += 1\n\t\t} else if paren == '(' {\n\t\t\tnesting\
    \ -= 1\n\t\t}\n\t\tif nesting > max_level[0] {\n\t\t\tmax_level[0] = nesting\n\
    \t\t}\n\t}\n\treturn max_level", "    if paren_string == \"\" {\n        return\
    \ [0]\n    }\n    let parens = paren_string.split(\" \").map(String::characters)\n\
    \    var level = 0\n    var output = 0\n    for paren in parens {\n        if\
    \ paren == \"(\" {\n            level++\n        } else if paren == \")\" {\n\
    \            level--\n            if level < 0 {\n                let output =\
    \ output + 1\n                level = 0\n            }\n        }\n    }\n   \
    \ return Array(parens).map { _ in output }", "    let nested_paren_regex = try!\
    \ NSRegularExpression(pattern: \"\\\\(|\\\\)|\\\\s)+\\\\(|\\\\)|\\\\s)+\", options:\
    \ .CaseInsensitive)\n    let nested_paren_match = nested_paren_regex.firstMatchInString(paren_string,\
    \ options: .CaseInsensitive)\n\n    var max_level = [Int]()\n\n    if nested_paren_match\
    \ != nil {\n        for parens in 0..<nested_paren_regex.numberOfMatches(paren_string,\
    \ options: .CaseInsensitive)! {\n            let match = nested_paren_match.rangeAt(parens)\n\
    \            let paren_string = paren_string[Range(match.location, match.location)!]\n\
    \            if paren_string.hasPrefix(\"(\") {\n                max_level.append(0)\n\
    \            } else {\n                max_level.append(1)\n            }\n  \
    \      }\n    }\n\n    return max_level", "    var maxNesting: [Int] = []\n  \
    \  let input_string = paren_string\n    var paren_level = 0\n\n    while let next_open\
    \ = input_string.index(of: openingParenthesisDelimiter, options: .backwards) {\n\
    \        let paren_nesting = paren_level + 1\n\n        if paren_nesting > maxNesting.count\
    \ {\n            maxNesting = [paren_nesting]\n        } else {\n            if\
    \ paren_nesting < maxNesting[paren_nesting] {\n                maxNesting[paren_nesting]\
    \ = paren_nesting\n            }\n        }\n\n        let next_close_loc = (input_string.index(of:\
    \ closingParenthesisDelimiter, options: .backwards) + 1)\n\n        if input_string.distance(from:\
    \ input_string.startIndex, to: next_open_loc) > 0 {\n            input_string\
    \ = input_string[next_open_loc...next_close_loc]\n        }\n\n        paren_level\
    \ += 1\n    }\n\n    return maxNesting", "    let parens = paren_string.characters\n\
    \    var levels = [Int]()\n    var level = 0\n    for paren in parens {\n    \
    \    if paren == \"(\" {\n            levels[level] = levels[level] + 1\n    \
    \    } else if paren == \")\" {\n            levels[level] = levels[level] - 1\n\
    \            if levels[level] == 0 {\n                levels[level] = 1\n    \
    \        } else {\n                levels[level] = levels[level] + 1\n       \
    \     }\n        }\n        level = levels[level]\n    }\n    return levels",
  "    \n    guard paren_string.count > 1 else {\n        return []\n    }\n    \n\
    \    // To keep track of parentheses level\n    var paren_level = 0\n    \n  \
    \  // To keep track of parentheses\n    var parens = [String]()\n    \n    //\
    \ To store characters to look for\n    var looking_for = [String](repeating: paren_string,\
    \ count: paren_string.count)\n    \n    // To store the result\n    var result\
    \ = [Int]()\n    \n    // To keep track of opening parentheses to look for\n \
    \   var opening_parens = [Int]()\n    \n    // To keep track of number of characters\
    \ encountered\n    var characters_count = 0\n    \n    // To store whether we\
    \ encounter an opening or closing parenthesis\n    var is_opening_parenthesis\
    \ = [Bool]()\n    \n    // Go through every character of the string\n    for i\
    \ in 0..<paren_string.count {\n        \n        // Add character if it is not\
    \ in the look_for array\n        if !looking_for[i].isEmpty {\n            result.append(characters_count)\n\
    \            characters_count = 0\n        }\n        \n        // If character\
    \ is a close parenthesis\n        if paren_string[i] == \"(\" {\n            //\
    \ If the number of closing parentheses we've seen equals to the number of opening\
    \ parenthesis\n            if paren_level == opening_parens.last {\n         \
    \       \n                // Add number of characters encountered to the result\n\
    \                result.append(characters_count)\n                \n         \
    \       // Add number of characters to the look_for array\n                looking_for[parens.count]\
    \ = String()\n                \n                // Add closing parenthesis to\
    \ the parens array\n                parens.append(paren_string[i])\n         \
    \       \n                // Add level to the paren_level\n                paren_level\
    \ += 1\n                \n                // Add opening parenthesis to the opening_parens\
    \ array\n                opening_parens.append(1)\n                \n        \
    \        // Add a new empty string to looking_for array\n                looking_for[parens.count]\
    \ = String()\n                \n                // Add character to the characters\
    \ count\n                characters_count += 1\n                \n           \
    \     // Add new parenthesis to the parens array\n                parens.append(paren_string[i])\n\
    \                \n                // Add a new empty string to looking_for array\n\
    \                looking_for[parens.count] = String()\n                \n    \
    \            // Add character to the characters count\n                characters_count\
    \ += 1\n                \n                // Add new parenthesis to the parens\
    \ array\n                parens.append(paren_string[i])\n                \n  \
    \              // Add a new empty string to looking_for array\n              \
    \  looking_for[parens.count] = String()\n                \n                //\
    \ Add character to the characters count\n                characters_count += 1\n\
    \                ", "    var max_level = 0\n\n    var level = [Int]()\n    var\
    \ index = 0\n\n    for ch in paren_string.unicodeScalars {\n        if ch == parenthesis.open\
    \ {\n            level[index] = level[index] + 1\n        }\n        if ch ==\
    \ parenthesis.close {\n            level[index] = level[index] - 1\n        }\n\
    \        index++\n    }\n\n    for level in level {\n        if level > max_level\
    \ {\n            max_level = level\n        }\n    }\n\n    return level", " \
    \   var parens = [Int]()\n    var i = 0\n    for c in paren_string.unicodeScalars\
    \ {\n        if c == \"(\" {\n            parens.append(i)\n        }\n      \
    \  if c == \")\" {\n            let last_pos = parens.last!\n            let last_idx\
    \ = parens.count - 1 - last_pos\n            parens.remove(at: last_idx)\n   \
    \     }\n        i = i + 1\n    }\n    return parens", "    debugPrint(\"parse_nested_parens(paren_string:\
    \ \\(string)) -> \\(parsed_nested_parens)\")\n    parsed_nested_parens = [:]\n\
    \    let paren_groups = paren_string.componentsSeparatedByString(\" \")\n    for\
    \ paren_group in paren_groups {\n        let paren_group_string = paren_group\n\
    \        var paren_level = [Int]()\n        var paren_count = 0\n        for paren\
    \ in paren_group_string.unicodeScalars {\n            let paren_group_char = paren.unicodeScalars.characters\n\
    \            if paren_group_char == \"(\" {\n                if paren_count.isEmpty\
    \ {\n                    paren_level.append(0)\n                    paren_count\
    \ = 1\n                } else {\n                    paren_count++\n         \
    \       }\n            } else if paren_group_char == \")\" {\n               \
    \ if paren_count == 0 {\n                    debugPrint(\"Unexpected ')' in \\\
    (paren_group_string)\")\n                    continue\n                } else\
    \ {\n                    paren_count--\n                }\n            } else\
    \ if paren_group_char == \",\" {\n                let current_level = paren_level.last!\n\
    \                if paren_count == 0 {\n                    debugPrint(\"Unexpected\
    \ ','\")\n                    continue\n                } else {\n           \
    \         debugPrint(\"Unexpected ','\")\n                    continue\n     \
    \           }\n            } else {\n                continue\n            }\n\
    \        }\n        debugPrint(\"paren_level = \\(paren_level), paren_count =\
    \ \\(paren_count)\")\n        parsed_nested_parens[paren_group.characters.count]\
    \ = paren_level\n    }\n    debugPrint(\"parse_nested_parens(paren_string: \\\
    (paren_string)) -> \\(parsed_nested_parens)\")\n    return parsed_nested_parens",
  "    paren_string = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    var max_level = 0\n    var nesting_level = 0\n    for ch in paren_string.unicodeScalars\
    \ {\n        let ch = ch\n        if parenthesis_level(ch) > nesting_level {\n\
    \            nesting_level = parenthesis_level(ch)\n        }\n        if parenthesis_level(ch)\
    \ == nesting_level {\n            nesting_level++\n        }\n        if nesting_level\
    \ > max_level {\n            max_level = nesting_level\n        }\n    }\n   \
    \ return max_level + 1", "    var max_level = 0\n    var max_level_count = 0\n\
    \n    for sub_string in paren_string.split(\" \") {\n        let nested_level\
    \ = parse_parens(sub_string).count\n        if nested_level > max_level {\n  \
    \          max_level = nested_level\n            max_level_count = 1\n       \
    \ } else if nested_level == max_level {\n            max_level_count++\n     \
    \   }\n    }\n    return Array(0 ..< max_level).map { level in level * max_level_count\
    \ }", "    var max_level = 0\n\n    for level in paren_string.split(\" \") {\n\
    \        let level_int = Int(level) ?? 0\n        if level_int > max_level {\n\
    \            max_level = level_int\n        }\n    }\n\n    var nested_level =\
    \ 0\n    var result = [Int]()\n    for level in paren_string.split(\" \") {\n\
    \        let level_int = Int(level) ?? 0\n        if level_int == max_level {\n\
    \            nested_level += 1\n            result.append(nested_level)\n    \
    \    }\n    }\n\n    return result", "\t\n\tvar max_level = [Int]()\n\tvar level\
    \ = 0\n\t\n\tfor i in 0 ..< paren_string.characters.count {\n\t\tif paren_string[i]\
    \ == ')' {\n\t\t\tlevel -= 1\n\t\t\tif level < 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\
    \t\tmax_level.append(level)\n\t\t}\n\t\tif paren_string[i] == '(' {\n\t\t\tlevel\
    \ += 1\n\t\t\tif level > 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tmax_level.append(level)\n\
    \t\t}\n\t}\n\t\n\tmax_level = append(max_level, 0) // for empty parens\n\t\n\t\
    return max_level", "    let groups = paren_string.components(separatedBy: \" \"\
    )\n    .map { $1.characters.count }\n    .sorted()\n    .filter{$0 > 0}\n    \n\
    \    var output_index = 0\n    var output_group_size = 1\n    var current_group_size\
    \ = 0\n    \n    for index in 0..<groups.count {\n        let group_size = groups[index]\n\
    \        \n        if group_size != current_group_size {\n            if current_group_size\
    \ > output_group_size {\n                output_group_size = current_group_size\n\
    \                output_index = current_group_size\n            }\n          \
    \  current_group_size = group_size\n        } else {\n            if current_group_size\
    \ == group_size {\n                current_group_size += 1\n            }\n  \
    \      }\n    }\n    \n    guard output_group_size > 0 else {\n        return\
    \ []\n    }\n    \n    return [output_index...].sorted()", "    var depth = 0\n\
    \    var result: [Int] = []\n    for ch in paren_string.unicodeScalars {\n   \
    \     switch ch {\n        case .OpenBracket:\n            depth++\n        case\
    \ .CloseBracket:\n            depth--\n        case .Bracket:\n            if\
    \ depth == 0 {\n                result.append(depth)\n            }\n        }\n\
    \    }\n    result.append(0)\n    return result", "    paren_string = paren_string.trimmingCharacters(in:\
    \ NSCharacterSet.whitespaces)\n\n    var result = [Int]()\n    var groupCount\
    \ = 0\n\n    for char in paren_string.unicodeScalars.reversed() {\n        if\
    \ groupCount == 0 {\n            result.append(1)\n            groupCount += 1\n\
    \        } else if char == ')' {\n            if groupCount == 1 {\n         \
    \       result.append(1)\n                groupCount += 1\n            } else\
    \ {\n                result.append(0)\n                groupCount = 0\n      \
    \      }\n        } else if char == ')' {\n            if groupCount == 2 {\n\
    \                result.append(2)\n            } else {\n                result.append(0)\n\
    \                groupCount = 0\n            }\n        } else {\n           \
    \ groupCount += 1\n        }\n    }\n\n    return result.reversed()", "    var\
    \ level = 0\n    var count = 0\n    var group = [String]()\n    for char in paren_string.characters\
    \ {\n        if char == ')' {\n            level--\n            if level == 0\
    \ {\n                group.append(char)\n                count++\n           \
    \ }\n        } else {\n            group.append(String(char))\n        }\n   \
    \ }\n    if level != 0 {\n        fatalError(\"wrong number of nested parentheses\"\
    )\n    }\n    return count", "    // Create a stack of nested parentheses\n  \
    \  var stack = [Char]()\n    // Number of levels of nesting\n    var level = 0\n\
    \    // Iterate over all the characters in the string\n    for c in paren_string.characters\
    \ {\n        // If the character is a left parenthesis, push it to the stack\n\
    \        if c == '(' {\n            stack.append(c)\n        // If the character\
    \ is a right parenthesis, pop the top element from the stack\n        } else if\
    \ c == ')' {\n            stack.pop()\n        // If the character is a left parenthesis,\
    \ increment the level of nesting\n        } else if c == '{' {\n            level\
    \ += 1\n        // If the character is a right parenthesis, decrement the level\
    \ of nesting\n        } else if c == '}' {\n            level -= 1\n        }\n\
    \    }\n\n    // Return the level of nesting\n    return stack", '    return recursively_parse_nested_parens(paren_string,
    [0])', "    var result = [0]\n\n    guard paren_string.count > 1 else {\n    \
    \    return result\n    }\n\n    var level = 0\n    var in_group = [Bool]()\n\n\
    \    for char in paren_string.characters {\n        switch char {\n        case\
    \ \")\":\n            result[level] = -1\n            level--\n            if\
    \ level == 0 {\n                result[level] = 1\n                level++\n \
    \               in_group[level] = false\n            }\n        case \")\":\n\
    \            if in_group[level] {\n                result[level] = -1\n      \
    \          level--\n                in_group[level] = false\n            } else\
    \ {\n                result[level] = 0\n                in_group[level] = true\n\
    \            }\n        case \"(\":\n            result[level] = 1\n         \
    \   level++\n            in_group[level] = true\n        case \")\":\n       \
    \     if in_group[level] {\n                result[level] = 0\n              \
    \  in_group[level] = false\n            } else {\n                result[level]\
    \ = -1\n                level--\n            }\n        default:\n           \
    \ result[level] += 1\n            level--\n        }\n    }\n\n    return result",
  "    var max_nesting: Int = 0\n    var nesting: Int = 0\n    var level_star: Int\
    \ = 0\n    var paren_counter: Int = 0\n    for index in 0..<paren_string.count\
    \ {\n        if paren_counter == 0 {\n            level_star = paren_string[index]\n\
    \        } else {\n            if paren_counter == level_star {\n            \
    \    paren_counter++\n            } else {\n                paren_counter = 0\n\
    \                level_star = paren_string[index]\n            }\n        }\n\
    \        if level_star != 0 {\n            nesting++\n            if nesting >\
    \ max_nesting {\n                max_nesting = nesting\n            }\n      \
    \  }\n    }\n    return Array(repeating: max_nesting, count: level_star)", " \
    \   // The string to be parsed contains parenthetical groups and may contain nested\
    \ parenthesis.\n    // Each parenthetical group may contain nested parentheses\
    \ within it,\n    // and these nested parentheses need to be parsed for their\
    \ level of nesting.\n    // For example:\n    //\n    //     ( (( ()() )))\n \
    \   //\n    // The first parenthesis ( ( ) ) contains nested parentheses within\
    \ it, and\n    // the nested parentheses need to be parsed for the level of nesting.\n\
    \    //\n    // Therefore, start by parsing the string by parsing all parentheses.\n\
    \    // If the string contains a nested parentheses, then the nested parentheses\n\
    \    // need to be parsed again to determine the level of nesting.\n    var paren_level\
    \ = 0\n    let paren_str = paren_string.characters()\n    let paren_arr: [String]\
    \ = []\n\n    // The function will return an array of integers\n    // indicating\
    \ the level of nesting of each parenthetical group.\n    //\n    // Ex: ( (())\
    \ ) has two levels of nesting, while (( )) has just one level of nesting.\n  \
    \  let nested = paren_str.enumerate().map { i, char in\n        // Look at each\
    \ character in the parenthetical group.\n        // If the character is a parenthesis,\
    \ increment the paren_level\n        // by 1.\n        if char == \"(\" {\n  \
    \          paren_arr.append(paren_level)\n            paren_level += 1\n     \
    \   } else {\n            paren_arr.append(paren_level)\n            paren_level\
    \ -= 1\n        }\n\n        // Return the parenthetical group.\n        return\
    \ String(char)\n    }\n\n    return nested", "    var result: [Int] = []\n   \
    \ var index = 0\n    var level = 0\n    var openingParenCount = 0\n    var closingParenCount\
    \ = 0\n\n    while index < paren_string.characters.count {\n        if paren_string.characters[index]\
    \ == ')' {\n            closingParenCount++\n        } else {\n            openingParenCount++\n\
    \        }\n        level++\n\n        if level == 1 && openingParenCount == closingParenCount\
    \ {\n            result.append(level)\n        }\n\n        index++\n    }\n\n\
    \    return result", "    var level = 0\n    var deepest_level = 0\n    var group_size\
    \ = 0\n    var group_level = [Int]()\n    var current_count = 0\n    let num_levels\
    \ = paren_string.count\n\n    guard num_levels > 0 else { return [] }\n\n    let\
    \ paren_chars = paren_string.characters\n    var paren_char_i = 0\n\n    while\
    \ true {\n        let paren_char = paren_chars[paren_char_i]\n        switch paren_char\
    \ {\n        case \"(\":\n            group_level.append(level)\n            group_size\
    \ += 1\n            if level == deepest_level {\n                current_count\
    \ += group_size\n                group_size = 0\n            }\n            level\
    \ += 1\n        case \"(\":\n            group_level.append(level)\n         \
    \   group_size += 1\n            if level == deepest_level {\n               \
    \ current_count += group_size\n                group_size = 0\n            }\n\
    \            level += 1\n        case \"(\":\n            if level == deepest_level\
    \ {\n                group_size = group_level[group_level.count - 1] + 1\n   \
    \             group_level.insert(level - 1, 0)\n                current_count\
    \ += group_size\n            }\n            level += 1\n        case \"(\":\n\
    \            if level > deepest_level {\n                deepest_level = level\n\
    \            }\n            group_level[group_level.count - 1] += group_size +\
    \ 1\n            group_size = 0\n            level -= 1\n        case \"(\":\n\
    \            if level > deepest_level {\n                deepest_level = level\n\
    \            }\n            group_size = 0\n            level -= 1\n        case\
    \ \"(\":\n            if level == deepest_level {\n                group_size\
    \ = group_level[group_level.count - 1] + 1\n                group_level.insert(level\
    \ - 1, 0)\n                current_count += group_size\n            }\n      \
    \      level -= 1\n        case \"(\":\n            group_level[group_level.count\
    \ - 1] += group_size + 1\n            group_size = 0\n            level -= 1\n\
    \        case \"(\":\n            group_size = 0\n            level -= 1\n   \
    \     case \"(\":\n            if level > deepest_level {\n                deepest_level\
    \ = level\n            }\n            level -= 1\n        default:\n         \
    \   if level == deepest_level {\n                group_size = group_level[group_level.count\
    \ - 1] + 1\n                group_level.insert(level - 1, 0)\n               \
    \ current_count += group_size\n            }\n            level -= 1\n       \
    \ }\n        paren_char_i += 1\n        if paren_char_i >= paren_chars.endIndex\
    \ {\n            break\n        }\n    }\n\n    return group_level.dropLast()",
  "    var levels = [Int]()\n    var level = 0\n    var parentheses = 0\n    var count\
    \ = 0\n    for letter in paren_string.unicodeScalars {\n        switch letter\
    \ {\n        case .OpenParen:\n            parentheses += 1\n        case .CloseParen:\n\
    \            parentheses -= 1\n            if parentheses == 0 {\n           \
    \     levels[level] = count\n                level++\n            }\n        \
    \    count = 0\n        }\n        count += 1\n    }\n    return levels", "  \
    \  // \"()\" or \"()()\" or \"(())\" or \"(()())\"\n    let regex_parens = NSRegularExpression.escapedPattern(for:\
    \ \"[(]\\\\(([()]|\\\\(([()]|\\\\(([()]*\\\\))*\\\\))*\\\\)\\\\)\")\n\n    let\
    \ regex = NSRegularExpression(pattern: regex_parens, options: .caseInsensitive)\n\
    \    let matches = regex.matches(in: paren_string, range: NSMakeRange(0, paren_string.characters.count))\n\
    \    let group_counts = matches.map { $0.numberOfRanges }\n    let group_counts_sorted\
    \ = group_counts.sorted()\n\n    let max_count = group_counts_sorted.last!\n \
    \   var counts = [Int]()\n    for i in 0..<max_count {\n        counts.append(0)\n\
    \    }\n    for i in 0..<group_counts_sorted.count {\n        if group_counts_sorted[i]\
    \ == max_count {\n            counts[group_counts_sorted[i]]++\n        }\n  \
    \  }\n    return counts", "    \n    // convert string to array\n    var paren_count\
    \ = [String]()\n    paren_string.split(\" \").forEach {\n        paren_count =\
    \ $0.split(\"\").map { Int($0) }.max().unwrap() }\n    return paren_count", " \
    \   var levels: [Int] = []\n    var num_groups = 1\n    for ch in paren_string.unicodeScalars\
    \ {\n        switch ch {\n        case .OpenParen, .CloseParen:\n            levels.append(0)\n\
    \        case .End:\n            return levels\n        default:\n           \
    \ levels[num_groups - 1] = levels[num_groups - 1] + 1\n        }\n        num_groups\
    \ = num_groups * 10 + levels[num_groups - 1]\n    }\n    if num_groups == 1 {\n\
    \        return nil\n    }\n    return levels", "    var paren_level = [Int]()\n\
    \    for paren_char in paren_string.unicodeScalars {\n        if paren_char ==\
    \ '(' {\n            paren_level.insert(paren_level.count, paren_level.count)\n\
    \        } else if paren_char == ')' {\n            paren_level.removeLast()\n\
    \        }\n    }\n    return paren_level", '    return parse_nested_parens_internal(paren_string,
    paren_string.split(" "))', "    // Initialize all the nesting levels seen so far.\n\
    \    var max_level = [Int]()\n    // Iterate through the string and append the\
    \ amount of open parenthesis\n    // to the current level.\n    for level := 0;\
    \ level < paren_string.count; level++ {\n        // The current level is either\
    \ the previous level or 1 if\n        // this is the first level.\n        var\
    \ current_level = level > 0 ? max_level[level-1] + 1 : 1\n        // Append the\
    \ level to the max level and update it.\n        max_level[level] = current_level\n\
    \    }\n    // Return all the max levels from top to bottom.\n    return max_level",
  "    \n    var level = 0\n    var output_level = 0\n    var output: [Int] = []\n\
    \    \n    for ch in paren_string.unicodeScalars {\n        \n        // find\
    \ matching closing parenthesis\n        var closing = paren_string.unicodeScalars.filter({\
    \ $0 == ch }).first\n        var closing_index = 0\n        \n        // find\
    \ matching opening parenthesis\n        var opening = paren_string.unicodeScalars.filter({\
    \ $0 == paren_string.unicodeScalars[closing_index] }).last\n        opening_index\
    \ = 1\n        \n        while opening_index < paren_string.unicodeScalars.count\
    \ {\n            \n            // check levels\n            level++\n        \
    \    \n            // find matching closing parenthesis\n            closing =\
    \ paren_string.unicodeScalars.filter({ $0 == paren_string.unicodeScalars[closing_index]\
    \ }).first\n            closing_index++\n            \n            if level ==\
    \ output_level {\n                \n                output.append(level)\n   \
    \             output_level++\n                \n                level = 0\n  \
    \          }\n            \n            if closing != nil {\n                level--\n\
    \            }\n            \n            opening = paren_string.unicodeScalars.filter({\
    \ $0 == paren_string.unicodeScalars[opening_index] }).last\n            opening_index++\n\
    \        }\n    }\n    \n    return output", "    // Get all groups of the paren_string.\n\
    \    var groups = paren_string.characters.split(char: \" \")\n\n    // Go through\
    \ all the groups and find the maximum nesting.\n    var max = 0\n    for index\
    \ in 0..<groups.count {\n        let group = groups[index]\n        let nesting\
    \ = parse_parens_group(group: group)\n        if nesting > max {\n           \
    \ max = nesting\n        }\n    }\n\n    // Return the maximum nesting.\n    return\
    \ max", "    let split_string = paren_string.components(separatedBy: \" \")\n\
    \    var paren_level = 1\n    var max_level = 0\n    for paren in split_string\
    \ {\n        let paren_len = paren.count\n        if paren_len > 1 {\n       \
    \     let level: Int = paren_len\n            if level > max_level {\n       \
    \         max_level = level\n            }\n            paren_level += level\n\
    \        }\n    }\n    return [paren_level, max_level]", "    \n    // Parsing\
    \ and preparing data for further operations.\n    // This struct stores the information\
    \ about a group and the list of levels of nesting within it.\n    let group_data:\
    \ [(group: [String], levels: Int)] = [\n        (group: [\"\"], levels: 0)\n \
    \   ]\n    \n    var group_index = 0\n    var level_of_nesting = 0\n    var curr_group\
    \ = \"\"\n    var nesting_counter = 1\n    \n    for character in paren_string.characters\
    \ {\n        if character == \"(\" {\n            level_of_nesting += 1\n    \
    \        curr_group += character\n        }\n        \n        if character ==\
    \ \")\" {\n            level_of_nesting -= 1\n            \n            if level_of_nesting\
    \ == 0 && curr_group != \"\" {\n                group_data.append((group: [curr_group],\
    \ levels: level_of_nesting))\n                curr_group = \"\"\n            \
    \    nesting_counter = 1\n            } else {\n                curr_group +=\
    \ character\n            }\n        }\n        \n        if character == \" \"\
    \ {\n            if level_of_nesting > 0 {\n                group_data.append((group:\
    \ [curr_group], levels: level_of_nesting))\n                curr_group = \"\"\n\
    \                nesting_counter = 1\n            } else {\n                curr_group\
    \ += character\n            }\n        }\n    }\n    \n    return group_data.map\
    \ { $0.levels }", "\tdepths := [Int](count: paren_string.count + 1, repeatedValue:\
    \ 0)\n\tvar max_depth Int = 0\n\tfor _, c := range paren_string.unicodeScalars\
    \ {\n\t\tif paren_string[c] == '(' {\n\t\t\tdepths[paren_string[c]] += 1\n\t\t\
    \tif depths[paren_string[c]] > max_depth { max_depth = depths[paren_string[c]]\
    \ }\n\t\t} else if paren_string[c] == ')' {\n\t\t\tdepths[paren_string[c]] -=\
    \ 1\n\t\t}\n\t}\n\treturn depths", "    var max = [Int]()\n    for paren in paren_string.components(separatedBy:\
    \ \" \"){\n        let parens = paren.characters.split(on: CharacterSet.init(charactersIn:\
    \ \"()\"))\n        if parens.count == 0 {\n            continue\n        }\n\
    \        let level = parens.count\n        if level > max[level.count - 1]{\n\
    \            max[level.count - 1] = level\n        }\n    }\n    return max",
  "    var output_level = 1\n    var nesting_level = 1\n    for parens in paren_string.split(\"\
    \ \") {\n        if parens != \"\" {\n            if parens == \"(\" && nesting_level\
    \ > 0 {\n                output_level++\n                nesting_level++\n   \
    \         } else if parens == \"(\" && nesting_level == 0 {\n                output_level++\n\
    \            } else if parens == \")\" && nesting_level > 0 {\n              \
    \  output_level--\n                nesting_level--\n            } else if parens\
    \ == \")\" && nesting_level == 0 {\n                output_level--\n         \
    \   }\n        }\n    }\n\n    return Array(output_level..<output_level + 1).map\
    \ {\n        nesting_level - $0\n    }", "    var level = 0\n    var depth = 0\n\
    \    for index in paren_string.characters {\n        if index == paren_string.characters.last\
    \ && paren_string[index] == '(' {\n            if level < depth {\n          \
    \      depth += 1\n            }\n        } else if index == paren_string.characters.first\
    \ && paren_string[index] == ')' {\n            if level > 0 {\n              \
    \  depth -= 1\n            }\n        } else {\n            if level == 0 {\n\
    \                level += 1\n            }\n        }\n    }\n    return [level]",
  "    // TODO: replace this with something that handles arbitrary nesting depth :)\n\
    \    return [1]", "    var max_level_groups = [0]\n    var level = 0\n    for\
    \ c in paren_string.characters {\n        switch c {\n        case \")\":\n  \
    \          level -= 1\n            if level == -1 {\n                max_level_groups.append(level\
    \ + 1)\n                level = 0\n            } else {\n                max_level_groups.append(level)\n\
    \            }\n        case \"(\":\n            level += 1\n            if level\
    \ == 0 {\n                max_level_groups.append(level)\n                level\
    \ = 0\n            } else {\n                max_level_groups.append(level)\n\
    \            }\n        default:\n            break\n        }\n    }\n    return\
    \ max_level_groups", "  var max_depth = 0\n  var levels = [Int]()\n\n  for parens\
    \ in paren_string.split(\" \") {\n    if parens.contains(\"(\") {\n      levels.append(0)\n\
    \    }\n\n    parens = parens.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    if parens.contains(\")\") {\n      levels = levels.dropLast()\n      if max_depth\
    \ < levels.last {\n        max_depth = levels.last\n      }\n    }\n  }\n\n  return\
    \ max_depth", "\tlet parens_indexes = paren_string.characters.enumerated().filter{\
    \ $0.element.isPunctuation }\n\tlet max_level = 0\n\tfor index in parens_indexes\
    \ {\n\t\tlet parens = parens_indexes[index].element == \"(\" ? 1 : 0\n\t\tlet\
    \ level = (parens_indexes[index].element == \"(\" ? 1 : 0) + (parens_indexes[index].element\
    \ == \"(\" ? 1 : 0)\n\t\tif level > max_level {\n\t\t\tmax_level = level\n\t\t\
    }\n\t}\n\treturn Array(Set(paren_string.characters.filter{ $0 == \"(\" || $0 ==\
    \ \")\" }).sorted())\n\t\t.enumerated()\n\t\t.map{ [$0.element, Int($0.offset\
    \ / paren_string.count)] }\n\t\t.filter{ $0.element == \"(\" || $0.element ==\
    \ \")\" }\n\t\t.map{ $0.element == \"(\" ? 1 : 0 }\n\t\t.reduce(0, +)", "    var\
    \ maxNesting = [Int](repeating: -1, count: paren_string.count)\n    for index\
    \ in stride(from: 0, to: paren_string.count, by: 1) {\n        let char = paren_string[index]\n\
    \        switch char {\n        case \"(\":\n            maxNesting[index] = maxNesting[index-1]\
    \ + 1\n        case \"(\":\n            checkNesting(maxNesting: &maxNesting,\
    \ index: index)\n        default:\n            break\n        }\n    }\n    return\
    \ maxNesting", "    var levels: [Int] = [0]\n    var n = 1\n    var i: Int = 0\n\
    \    for char in paren_string.characters {\n        i += 1\n        if char ==\
    \ \"(\" {\n            levels.append(n)\n            n++\n        } else if char\
    \ == \")\" {\n            levels.pop()\n            n--\n        }\n    }\n  \
    \  return levels", "\tvar levels: [Int] = Array(repeating: 0, count: paren_string.count+1)\n\
    \tlevels[0] = 0\n\tlevels[paren_string.count] = 0\n\n\tfor (index, char) in paren_string.characters.enumerated()\
    \ {\n\t\tlet current_level = levels[index + 1]\n\n\t\tswitch char {\n\t\tcase\
    \ '(':\n\t\t\tlevels[index] += 1\n\t\tcase '[':\n\t\t\tlevels[index] += 1\n\t\t\
    case '{':\n\t\t\tlevels[index] += 1\n\t\tcase ')':\n\t\t\tlevels[index] -= 1\n\
    \t\tcase '}':\n\t\t\tlevels[index] -= 1\n\t\tcase ']':\n\t\t\tlevels[index] -=\
    \ 1\n\t\tcase ',':\n\t\t\tlevels[index] = 0\n\t\tdefault:\n\t\t\tbreak\n\t\t}\n\
    \n\t\tif levels[index] >= current_level {\n\t\t\tlevels[index] = current_level\n\
    \t\t}\n\t}\n\n\treturn levels", "    guard paren_string.count > 0 else {\n   \
    \     return []\n    }\n    var max_level = -1\n    var max_nesting = 0\n    var\
    \ nesting = 0\n    var paren_count = 0\n    for index in 0..<paren_string.count\
    \ {\n        let character = paren_string[index]\n        guard character == \"\
    (\" else {\n            return []\n        }\n        if nesting > max_nesting\
    \ {\n            max_nesting = nesting\n            max_level = nesting\n    \
    \    }\n        nesting += 1\n        paren_count += 1\n    }\n    return [max_nesting,\
    \ max_level]", "    // Create a set of parens we want to keep track\n    var parens:\
    \ Set<String> = Set()\n    // Iterate through the input string and parse nested\
    \ parens\n    for char in paren_string.characters {\n        // If this char is\
    \ a left paren, increase level\n        if char == \"(\" {\n            parens.insert(\"\
    (\")\n        // If this char is a right paren, decrease level\n        } else\
    \ if char == \")\" {\n            // If the paren is open, then remove it\n  \
    \          if parens.contains(\"(\") {\n                parens.remove(\"(\")\n\
    \            }\n            // If the paren is closed, then add it\n         \
    \   else {\n                parens.insert(\")\")\n            }\n        }\n \
    \   }\n    // Create a map of all the parens and their nesting level\n    var\
    \ paren_map: [String: Int] = [:]\n    for paren in parens {\n        if paren\
    \ != \"\" {\n            paren_map[paren] = paren_map[paren] ?? 0\n          \
    \  paren_map[paren]++\n        }\n    }\n    // Iterate through the map to find\
    \ the max level of nesting\n    var max_level = Int.max\n    for paren in paren_map\
    \ {\n        if paren_map[paren] > max_level {\n            max_level = paren_map[paren]\n\
    \        }\n    }\n    // Return the max level\n    return Array(parens).map {\
    \ paren in\n        if paren_map[paren] == max_level {\n            return paren\n\
    \        } else {\n            return paren\n        }\n    }", "    // First\
    \ get all the groups of parentheses separated by spaces.\n    // The algorithm\
    \ starts from left to right and go down until we encounter an opening parenthesis.\n\
    \    var groups: [String] = []\n    var level = 0\n    var opening = 0\n    for\
    \ c in paren_string {\n        if opening=='(' && c==')' {\n            level--\n\
    \        } else if opening=='(' && c!='(' {\n            opening++\n        }\
    \ else if opening=='(' && c==')' {\n            opening--\n            if level==0\
    \ {\n                groups.append(c)\n            }\n        }\n    }\n    //\
    \ The groups are separated by spaces. Now we loop through\n    // all the groups\
    \ and find out the maximum level of nesting.\n    var max_level = 0\n    for g\
    \ in groups {\n        var nesting = level\n        var is_opening_open = false\n\
    \        for c in g {\n            if c==opening {\n                is_opening_open\
    \ = true\n                nesting = nesting + 1\n            }\n            if\
    \ c=='(' && !is_opening_open {\n                nesting = nesting - 1\n      \
    \      }\n        }\n        if nesting > max_level {\n            max_level =\
    \ nesting\n        }\n    }\n    // Return max level of nesting found\n    return\
    \ max_level", "    // Step 1. Build a map of counts\n    var paren_count: [(Int,\
    \ Int)] = [(0, 1)]\n    for paren in paren_string.characters {\n        paren_count[(paren.value,\
    \ paren.value)] = paren_count[(paren.value, paren.value)].0 + 1\n    }\n    //\
    \ Step 2. Return level counts\n    return paren_count.keys.sorted().map {\n  \
    \      paren_count[$0]\n    }", "    var result = [Int]()\n    var level = 0\n\
    \    var is_open = true\n    for char in paren_string.characters {\n        switch\
    \ char {\n        case \")\":\n            is_open = false\n            result[level]\
    \ = level\n            level += 1\n        case \")\":\n            level += 1\n\
    \        case \" \":\n            if is_open {\n                is_open = false\n\
    \                result[level] = level\n                level += 1\n         \
    \   }\n        case \")\":\n            level += 1\n        }\n    }\n    result[level]\
    \ = level\n    return result", "    var paren_levels = [Int]()\n    var max_level\
    \ = Int()\n    var paren_count = Int()\n    for index in stride(from: 0, to: paren_string.characters.count,\
    \ by: 1) {\n        let char = paren_string[index].unicodeScalars.first!\n   \
    \     switch char {\n        case \"(\", \")\":\n            paren_levels.append(paren_levels[paren_levels.index(before:\
    \ paren_levels.index(of: char))]!)\n            if paren_levels[paren_levels.index(of:\
    \ char)] != max_level {\n                max_level = paren_levels[paren_levels.index(of:\
    \ char)]!\n                paren_count = 1\n            } else {\n           \
    \     paren_count = paren_count + 1\n            }\n        case \" \":\n    \
    \        paren_levels.append(paren_levels[paren_levels.index(before: paren_levels.index(of:\
    \ char))]!)\n            if paren_levels[paren_levels.index(of: char)] != max_level\
    \ {\n                max_level = paren_levels[paren_levels.index(of: char)]!\n\
    \            } else {\n                paren_count = paren_count + 1\n       \
    \     }\n        }\n    }\n    if paren_count == 0 {\n        paren_levels.append(0)\n\
    \        max_level = 0\n    }\n    paren_levels.append(paren_count)\n    return\
    \ paren_levels", "\tassert(paren_string.count >= 1)\n\tassert(paren_string.count\
    \ <= 100000)\n\t\n\tvar level = 0\n\tvar result = [Int]()\n\t\n\tfor char1 in\
    \ paren_string.characters {\n\t\tif char1 == \"(\"\n\t\t\tlevel++\n\t\tif char1\
    \ == \")\"\n\t\t\tlevel--\n\t\t\n\t\tif level == 0 {\n\t\t\tcontinue\n\t\t}\n\t\
    \t\n\t\tif level > result.count {\n\t\t\tresult = Array(0..<level).map { _ in\
    \ 0 }\n\t\t}\n\t\t\n\t\tresult[level] += 1\n\t}\n\t\n\treturn result", "    var\
    \ max_level = 0\n    var result = [Int]()\n    for s in paren_string.components(separatedBy:\
    \ \" \") {\n        if s.isEmpty {\n            continue\n        }\n        for\
    \ _ in 0..<s.count {\n            guard let index = paren_string.index(s.startIndex,\
    \ offsetBy: 1) else {\n                fatalError(\"No index in parenstring\"\
    )\n            }\n            guard let length = paren_string.distance(from: index,\
    \ to: s.startIndex) else {\n                fatalError(\"No length of string\"\
    )\n            }\n            var level = 1\n            while length != 0 {\n\
    \                let start = paren_string.index(index, offsetBy: length)\n   \
    \             let end = paren_string.index(start, offsetBy: 0)\n             \
    \   let count = end - start\n                if count > length {\n           \
    \         length -= count\n                } else {\n                    length\
    \ = 0\n                }\n                if length > 0 {\n                  \
    \  level += 1\n                    length -= count\n                }\n      \
    \          index = end\n            }\n            if level > max_level {\n  \
    \              max_level = level\n                result.append(level)\n     \
    \       }\n        }\n    }\n    return result", "    var levels: [Int] = [Int]()\n\
    \n    for paren in paren_string.characters {\n        if paren == \"(\" {\n  \
    \          levels = append(levels, 0)\n        } else if paren == \")\" {\n  \
    \          levels = append(levels, levels[len(levels)-1])\n        } else {\n\
    \            levels = append(levels, levels[len(levels)-1]+1)\n        }\n   \
    \ }\n\n    return levels", "    var output_level: [Int] = [0]\n\n    let s = paren_string.trim()\n\
    \    let num_opening_brackets = s.count(\"(\")\n    let num_closing_brackets =\
    \ s.count(\")\")\n\n    for paren_string in s.split(\"(\" as NSString) {\n   \
    \     let num_opening_paren = paren_string.count(\"(\")\n        let num_closing_paren\
    \ = paren_string.count(\")\")\n\n        if (num_opening_paren == num_closing_brackets\
    \ && num_closing_paren == num_opening_brackets) {\n            // The current\
    \ level is deepest level of nesting within parentheses.\n            let output_level\
    \ = output_level[output_level.count - 1] + 1\n            output_level.append(output_level)\n\
    \        } else {\n            // The current level decreases until the closing\
    \ parentheses is encountered.\n            output_level.append(output_level[output_level.count\
    \ - 1] - 1)\n        }\n    }\n\n    return output_level", "    var count = [Int]()\n\
    \    var depth = 0\n    for groupStr in paren_string.split(\" \") {\n        var\
    \ tempCount = count[depth]\n        var tempDepth = depth\n        while tempCount\
    \ < groupStr.count {\n            tempCount += 1\n            tempDepth += 1\n\
    \            if tempDepth > count.count {\n                count = [Int](count:\
    \ tempDepth, repeatedValue: 0)\n            }\n        }\n        count[tempDepth]\
    \ += groupStr.count\n    }\n    return count", "    let re = try! NSRegularExpression(pattern:\
    \ \"\\\\([^()]*\\\\)\", options: [])\n    let matches = re.matches(in: paren_string,\
    \ range: NSRange(location: 0, length: paren_string.count))\n    let levels = matches.map\
    \ { match in\n        let range = (paren_string[match.range(at: 1)] as NSString).range(of:\
    \ \"(\", options: .anchored)\n        let end_range = (paren_string[match.range(at:\
    \ 2)] as NSString).range(of: \")\", options: .anchored)\n        range.length\
    \ - (end_range - range)\n    }.max()\n    return Array(1...levels)", "    var\
    \ result = [Int]()\n\n    var groupCount = 0\n    var parenCount = 0\n    var\
    \ parenLevel = 0\n\n    for char in paren_string {\n        if char == '(' {\n\
    \            groupCount++\n            parenLevel++\n        } else if char ==\
    \ ')' {\n            groupCount--\n            if groupCount == 0 {\n        \
    \        parenLevel--\n            }\n        } else {\n            if groupCount\
    \ == 0 {\n                parenCount++\n            }\n            if parenCount\
    \ > parenLevel {\n                parenLevel = parenCount\n                result.insert(parenLevel,\
    \ parenLevel)\n            }\n        }\n    }\n\n    return result", "    var\
    \ levels = [0]\n    for i in 1..<paren_string.count{\n        if paren_string[paren_string.index(i,\
    \ offsetBy: i-1)] == \")\"{\n            levels[i-1] = levels[i-1]+1\n       \
    \ }else if paren_string[paren_string.index(i, offsetBy: i-1)] == \"(\"{\n    \
    \        levels[i-1] = levels[i-1]-1\n        }else{\n            break\n    \
    \    }\n    }\n    return levels", "    let mut level = 0\n    let mut max_level\
    \ = [Int]()\n    let mut paren_level = [Int]()\n\n    let mut parens = paren_string.characters\n\
    \    while let c = parens.pop() {\n        if c != '(' {\n            paren_level[level]\
    \ = level\n        }\n        if c == '(' {\n            level++\n           \
    \ if level == max_level.last_mut() {\n                max_level.append(level)\n\
    \            }\n        }\n        if c == ')' {\n            if paren_level[level-1]\
    \ == level {\n                level--\n            } else {\n                paren_level[level]\
    \ = level\n            }\n        }\n    }\n\n    max_level.append(level)\n  \
    \  max_level.last_mut().unwrap()\n\n    return max_level", "    // Parse the string.\
    \ Keep the parentheses and level of nesting for each group\n    let parser = NSRegularExpression(pattern:\
    \ \"\\\\(|\\\\)\\\\s*|\\\\(|\\\\)\\\\s*\\\\(|\\\\)\\\\s*\", options: [], error:\
    \ nil)\n    var result: [Int] = []\n    for i in parser.matches(in: paren_string,\
    \ options: .regularExpression) {\n        let groups = paren_string.components(separatedBy:\
    \ \"\\\\(|\\\\)\")\n        let group_level = groups.count\n        var level\
    \ = 1\n        for group in groups {\n            level += group == \")\" ? 1\
    \ : -1\n        }\n        result.append(level)\n    }\n    return result", " \
    \   guard let paren_string = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\
    \ else { return [] }\n    guard paren_string.characters.count == 0 else {\n  \
    \      return parse_nested_parens(paren_string: paren_string)\n    }\n\n    var\
    \ counts: [Int] = [0]\n    var level = 1\n    var paren_count = 1\n    var max_level\
    \ = 0\n    var level_char: Character?\n\n    for char in paren_string.characters\
    \ {\n        guard level_char == nil else { return [] }\n        level_char =\
    \ char\n\n        if char == ')' {\n            if level_char == nil {\n     \
    \           level--\n            } else {\n                paren_count--\n   \
    \             if paren_count == 0 {\n                    max_level = level\n \
    \               }\n            }\n        } else if char == '(' {\n          \
    \  paren_count++\n            if paren_count == 0 {\n                counts.append(level)\n\
    \            }\n        }\n    }\n\n    return counts", "    var level = 0\n \
    \   var max_level = 0\n    for char in paren_string.characters {\n        if char\
    \ == \"(\"\n            level++\n        else if char == \")\"\n            level--\n\
    \        else if char == \")\" and level == 0\n            max_level = max(level,\
    \ max_level)\n    }\n    var max_level_index = [Int]()\n    \n    for i in 0..<max_level\
    \ {\n        if max_level_index.contains(i) {\n            continue\n        }\
    \ else {\n            max_level_index.append(i)\n        }\n    }\n    \n    return\
    \ max_level_index", "    var max = 0\n    for index in stride(from: 0, to: paren_string.utf16.count,\
    \ by: 1) {\n        guard paren_string[index] != \")\" && paren_string[index]\
    \ != \"]\" && paren_string[index] != \")\" && paren_string[index] != \"]\" else\
    \ {\n            return nil\n        }\n        let level = paren_string[index].unicodeScalars.count\
    \ * 2\n        if level > max {\n            max = level\n        }\n    }\n \
    \   return [0, max]", "\tvar max_nesting = 0\n\tvar nesting_level = 0\n\tnesting_level\
    \ = 0\n\tfor i, char := range paren_string {\n\t\tif char == '(' {\n\t\t\tnesting_level\
    \ += 1\n\t\t} else if char == ')' {\n\t\t\tnesting_level -= 1\n\t\t\tif nesting_level\
    \ < 0 {\n\t\t\t\tnesting_level = 0\n\t\t\t}\n\t\t} else if nesting_level == 0\
    \ {\n\t\t\tmax_nesting = i\n\t\t}\n\t}\n\treturn max_nesting", "    var results\
    \ = [Int]()\n\n    // parse all parentheses\n    for index in 0..<paren_string.characters.count\
    \ {\n        let currentChar = paren_string.characters[index]\n\n        // current\
    \ paren is opening or closing\n        let opening = currentChar == \"(\"\n  \
    \      let closing = currentChar == \")\"\n\n        if opening {\n          \
    \  guard !closing else {\n                assert(false && \"expected closing paren\"\
    )\n                return results\n            }\n            \n            if\
    \ results[results.count-1] == -1 {\n                results.append(index)\n  \
    \          }\n        } else if closing {\n            if results[results.count-1]\
    \ != -1 {\n                results.append(-1)\n            }\n            results.popLast()\n\
    \        }\n    }\n    \n    return results", "    var level = 0\n    var depth\
    \ = 0\n    var result = [0]\n\n    // For each group of parentheses.\n    for\
    \ _ in paren_string.components(separatedBy: \" \") {\n        // Keep track of\
    \ how many parentheses we encountered for nested paranthesis.\n        level +=\
    \ 1\n\n        // Keep track of how many characters we have encountered for nested\
    \ paranthesis.\n        depth += 1 + paren_string.count\n\n        // Find the\
    \ max of current level of nesting and total chars we encountered.\n        let\
    \ max_level = max(level, depth)\n\n        // If max level is same as level, we\
    \ just encountered the same number of parentheses.\n        if level == max_level\
    \ {\n            result.append(level)\n            continue\n        }\n\n   \
    \     // If max level is greater than current level, we encountered different\
    \ number of parentheses.\n        if level > level {\n            // Remove the\
    \ difference, and add 1 for the next iteration, so that this level doesn't affect\
    \ the result.\n            depth += max_level - level\n            level = 0\n\
    \        }\n\n        // Increment the level of the next group.\n        level\
    \ += 1\n    }\n\n    return result", "    var maxLevel = 0\n    var levels = [Int]()\n\
    \    var nested = 0\n    for char in paren_string.characters {\n        if char\
    \ == '(' { nested++ }\n        if char == ')' { nested-- }\n        if nested\
    \ < 0 {\n            levels.append(nested)\n            nested = 0\n        }\n\
    \        if nested > maxLevel {\n            maxLevel = nested\n        }\n  \
    \  }\n    return levels", "    var max_level = 0\n    var current_level = 0\n\
    \    var level = 0\n    var last_pos = 0\n\n    for idx, c in enumerate(paren_string)\
    \ {\n        if c == '(' {\n            current_level += 1\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      } else if c == ')' {\n            current_level -= 1\n            if current_level\
    \ < 0 {\n                return nil\n            }\n        } else {\n       \
    \     level++\n            if level > max_level {\n                max_level =\
    \ level\n            }\n            last_pos = idx\n        }\n    }\n\n    level\
    \ = 0\n    for idx, c in enumerate(paren_string[last_pos:]) {\n        if c ==\
    \ '(' {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if c == ')' {\n            current_level -= 1\n            if current_level\
    \ < 0 {\n                return nil\n            }\n        } else {\n       \
    \     level++\n            if level > max_level {\n                max_level =\
    \ level\n            }\n        }\n    }\n\n    return max_level", "    if paren_string\
    \ == \"\" {\n        return []\n    }\n    let strings = paren_string.components(separatedBy:\
    \ \" \")\n    var max_level = 0\n    for s in strings {\n        let level = parse_nested_parens(paren_string:\
    \ s)\n        if level > max_level {\n            max_level = level\n        }\n\
    \    }\n    return max_level", "    var max_level = [Int]()\n    paren_string\
    \ = paren_string.trimmingCharacters(in: NSCharacterSet.whitespaces)\n    let parens_stack:\
    \ [String] = []\n    var count = 0\n    while count < paren_string.characters.count\
    \ {\n        guard paren_string.characters.count > count + 1 else {\n        \
    \    return max_level\n        }\n        let next_char = paren_string.character(at:\
    \ count + 1).lowercased\n        let next_index = parens_stack.index(of: next_char)\n\
    \        if next_index == nil {\n            parens_stack.append(next_char)\n\
    \            if paren_string.character(at: count + 2).isASCII {\n            \
    \    count += 1\n            } else {\n                count += 1\n          \
    \  }\n        } else {\n            let level = next_index! + 1\n            if\
    \ level > max_level[level] {\n                max_level[level] = level\n     \
    \       }\n            parens_stack.removeSubrange(next_index!..<(count + 1))\n\
    \        }\n    }\n    return max_level", "    let stack: Stack = Stack()\n  \
    \  var levels: [Int] = []\n    let char_count = paren_string.characters.count\n\
    \    for index in 0..<char_count-1 {\n        let ch = paren_string[index]\n \
    \       if ch == \")\" {\n            let start = stack.size\n            stack.push(index)\n\
    \            for index in stack.iterateUntilPop(-1) {\n                levels.append(index\
    \ - start)\n            }\n            stack.pop()\n        }\n    }\n    return\
    \ levels", "    var level = 0\n    var level_count = 0\n    var parens = 0\n\n\
    \    for _ in paren_string.unicodeScalars {\n        guard parens > 0 else {\n\
    \            break\n        }\n\n        switch parens {\n        case 1:\n  \
    \          level++\n        case 2:\n            level_count = level\n\n     \
    \       if level_count > level {\n                level = level_count\n      \
    \      }\n        case 3:\n            level_count = level\n\n            if level_count\
    \ > level {\n                level = level_count\n            }\n\n        default:\n\
    \            level_count = level\n\n            if level_count > level {\n   \
    \             level = level_count\n            }\n        }\n\n        parens++\n\
    \    }\n\n    return Array(1..level).filter { _ in parens == 0 }", '    return
    parse_nested_parens(paren_string, paren_string.count())', "    var levels = [Int]()\n\
    \    for s in paren_string.split(\" \") {\n        if s.contains(\"(\") {\n  \
    \          var level = levels[levels.count-1]\n            level = level + 1\n\
    \            levels.append(level)\n        } else {\n            levels[levels.count-1]\
    \ = levels[levels.count-1] - 1\n        }\n    }\n    return levels", "  var num_paren_levels\
    \ = 0\n  var max_num_paren_levels = -1\n\n  for paren_char in paren_string.characters\
    \ {\n    if paren_char == \"(\" {\n      if num_paren_levels == 0 {\n        num_paren_levels\
    \ = 1\n      } else {\n        num_paren_levels += 1\n      }\n    } else if paren_char\
    \ == \")\" {\n      if num_paren_levels == 0 {\n        num_paren_levels += 1\n\
    \      } else {\n        num_paren_levels -= 1\n      }\n    } else if paren_char\
    \ == \" \" {\n      if num_paren_levels > max_num_paren_levels {\n        max_num_paren_levels\
    \ = num_paren_levels\n      }\n    }\n  }\n\n  return [max_num_paren_levels +\
    \ 1]", "    let re = try! NSRegularExpression(pattern: \"\\\\([^()]*\\\\)\", options:\
    \ [])\n    let results = re.matches(in: paren_string, options: [], range: NSMakeRange(0,\
    \ paren_string.utf8.count))\n    var levels = [Int]()\n    for match in results\
    \ {\n        let range = match.range\n        var new_level = 0\n        while\
    \ range.location != NSNotFound {\n            let current = paren_string[range]\n\
    \            if current == \")\" {\n                new_level -= 1\n         \
    \   }\n            if current == \"(\" {\n                new_level += 1\n   \
    \         }\n            range.location = advance(range.location, range.length)\n\
    \        }\n        levels.append(new_level)\n    }\n    return levels", "   \
    \ var maxlevel = [Int]()\n    var parencnt = 0\n    for idx in 0..<paren_string.characters.count\
    \ {\n        let ch = paren_string.characters[idx]\n        if ch == '(' {\n \
    \           parencnt += 1\n        } else {\n            parencnt -= 1\n     \
    \   }\n        if parencnt > maxlevel[0] {\n            maxlevel[0] = parencnt\n\
    \        }\n    }\n    return maxlevel", "    let mut paren_stack = [Int]()\n\
    \    var paren_count = 0\n    for paren in paren_string.characters() {\n     \
    \   if paren == ')' {\n            paren_stack.pop() // Pop last paren level\n\
    \        } else {\n            paren_stack.push(paren_count)\n            paren_count\
    \ = 0\n        }\n        if paren == '(' {\n            paren_count += 1\n  \
    \      }\n    }\n    return paren_stack", "    var level_stack = [Int]()\n   \
    \ level_stack = append(level_stack, 0)\n\n    var level = 0\n    var paren_count\
    \ = 0\n\n    for char in paren_string {\n        if char == \"(\" {\n        \
    \    level_stack = append(level_stack, 0)\n            level += 1\n          \
    \  paren_count += 1\n        } else if char == \")\" {\n            if level_stack[level]\
    \ != 0 {\n                level_stack = append(level_stack, level)\n         \
    \       level -= 1\n            } else {\n                panic(\"Parse error\"\
    )\n            }\n            paren_count -= 1\n        }\n    }\n\n    level_stack\
    \ = append(level_stack, 0)\n    return level_stack", '    return parse_nested_parens(paren_string:
    paren_string, paren_level: 0)', "    guard let parens_pattern = try? NSRegularExpression(pattern:\
    \ \"\\\\s\\\\(\\\\s*\\\\(([^()]*|\\\\([^()]*\\\\))*\\\\)\\\\s*\\\\)\\\\s\") else\
    \ {\n        return []\n    }\n    var level = 0\n    var levels: [Int] = []\n\
    \    guard let matchRange = parens_pattern.matches(in: paren_string, range: NSRange(location:\
    \ 0, length: paren_string.utf16.count)) else {\n        return []\n    }\n   \
    \ paren_string.enumerateSubstrings(in: NSRange(location: matchRange.range.location,\
    \ length: paren_string.utf16.count)) { substring, substringRange, enclosingRange\
    \ in\n        if substringRange.location == 0 {\n            level += 1\n    \
    \        levels.append(level)\n        } else {\n            let level = levels.last\
    \ ?? 0\n            if level == substringRange.location - 1 {\n              \
    \  levels.append(level)\n            }\n        }\n    }\n    return levels",
  "    var level: Int = 0\n    var nested: Int = 0\n    var parensNestings = [Int]()\n\
    \n    for char in paren_string.characters {\n        if char == \"(\" {\n    \
    \        level += 1\n            nested += 1\n            parensNestings += [nested]\n\
    \        } else if char == \")\" {\n            if parensNestings[level] == 1\
    \ {\n                level -= 1\n                nested -= 1\n               \
    \ parensNestings[level] += 1\n            } else {\n                level -= 1\n\
    \            }\n        }\n    }\n    return parensNestings", "    var max_level\
    \ = Int()\n    var level_stack: [Int] = [0]\n    var opening_parens = 0\n    var\
    \ max_nesting = 1\n\n    for i in paren_string.characters.reverse() {\n      \
    \  if paren_char(i) == \"(\" {\n            opening_parens += 1\n        }\n \
    \       if paren_char(i) == \")\" {\n            opening_parens -= 1\n       \
    \     if opening_parens > max_nesting {\n                max_nesting = opening_parens\n\
    \            }\n            level_stack = append(level_stack, opening_parens)\n\
    \        }\n    }\n    if opening_parens == 0 {\n        return max_nesting\n\
    \    }\n    if opening_parens > max_nesting {\n        max_nesting = opening_parens\n\
    \    }\n    for level in level_stack.reverse() {\n        if level > max_level\
    \ {\n            max_level = level\n        }\n    }\n    return max_nesting",
  "    var max_level = 0\n    var level = 0\n    var parens_stack = [Int]()\n\n  \
    \  for char in paren_string.characters {\n        let _ = try! parens_stack[level].append(Int(char))\n\
    \        level = (level + 1) % 4\n        if level == 0 {\n            max_level\
    \ = max(max_level, level)\n        }\n    }\n\n    return parens_stack[max_level]",
  "    let mut nesting = [Int]()\n    let mut level = 0\n\n    paren_string.split(\"\
    \ \").forEach { str in\n        let (open_parens, close_parens) = (str.characters.split{$0\
    \ == \")\"} as Array)[0]\n\n        if open_parens == \"(\" && close_parens ==\
    \ \")\" {\n            nesting.append(level)\n            level++\n        }\n\
    \    }\n    nesting.append(level)\n    return nesting", "    if paren_string ==\
    \ \"\" {\n        return []\n    }\n    var level = 0\n    var maxLevel = Int(self.chars.count)\n\
    \    var output = [Int]()\n    for ch in paren_string.unicodeScalars {\n     \
    \   switch ch {\n        case .OpenParen, .CloseParen:\n            level += 1\n\
    \        case .OpenBrace:\n            if level == 1 {\n                output.append(maxLevel)\n\
    \                level = 0\n            } else {\n                level -= 1\n\
    \            }\n        case .CloseBrace:\n            if level == 0 {\n     \
    \           return nil\n            }\n            level -= 1\n        }\n   \
    \     maxLevel = level\n    }\n    return output", "\tvar max_nesting = 0\n\t\
    nesting_counter := 0\n\tvar max_nesting_level [11]int\n\n\t// The input string\
    \ represents a bunch of groups of parentheses.\n\t// For example, the string \"\
    (()) ()\" represents a group of two parentheses.\n\t// The group \"(()) ()\" has\
    \ one level of nesting.\n\t// We need to find all such groups and find the level\
    \ of nesting in each group.\n\t// For each group, we need to find the level of\
    \ nesting in all groups before it.\n\t// That means, we need to find the level\
    \ of nesting in all groups after it.\n\tfor _, s := range strings.Split(paren_string,\
    \ \" \") {\n\t\tnesting_level, _ := count_nested_parentheses(s)\n\t\tif nesting_level\
    \ > max_nesting {\n\t\t\tmax_nesting = nesting_level\n\t\t}\n\t\tif nesting_level\
    \ == max_nesting {\n\t\t\tmax_nesting_level[nesting_counter] = nesting_level\n\
    \t\t}\n\t\tnesting_counter += 1\n\t}\n\n\tmax_nesting_level[0] += 1\n\n\treturn\
    \ max_nesting_level", "    var results: [Int] = []\n    var level = 0\n    for\
    \ c in paren_string.characters {\n        if c == '(' {\n            level++\n\
    \        } else if c == ')' {\n            level--\n            if level == 0\
    \ {\n                results.append(level)\n            }\n        }\n    }\n\
    \    return results", "    var paren_count = 0\n    var levels = [Int]()\n   \
    \ var level = 0\n    for c in paren_string.characters {\n        if c == '(' {\n\
    \            paren_count++\n        } else if c == ')' {\n            levels[level]\
    \ = paren_count\n            level++\n            paren_count--\n        }\n \
    \   }\n    return levels", "  var paren_depth = 0\n  var paren_level = 0\n  var\
    \ paren_count = [Int](repeating: 0, count: 2)\n\n  for char in paren_string.characters\
    \ {\n    if char == \")\" {\n      if paren_depth == 0 {\n        paren_depth++\n\
    \        paren_level++\n        paren_count[paren_level] = paren_depth\n     \
    \ } else {\n        if paren_depth == paren_count[paren_level] {\n          paren_depth++\n\
    \        } else {\n          paren_depth--\n        }\n        paren_level--\n\
    \      }\n    }\n  }\n\n  return paren_count", "    var max_count = 0\n    var\
    \ max_level = 0\n    var level = 0\n    var opening_parens = paren_string.count(\"\
    (\")\n    var closing_parens = paren_string.count(\")\")\n    var count = 0\n\
    \    var result = [0]\n    for i in 0 ..< paren_string.count {\n        let open\
    \ = paren_string.index(paren_string.startIndex, offsetBy: i)\n        let close\
    \ = paren_string.index(paren_string.startIndex, offsetBy: i+1)\n        if paren_string[open]\
    \ == \"(\" && paren_string[close] == \")\" {\n            count += 1\n       \
    \ } else {\n            count -= 1\n        }\n        result[count] = result[count]\
    \ + 1\n        if count > max_count && result[count] > max_level {\n         \
    \   max_count = result[count]\n            max_level = result[count]\n       \
    \ }\n    }\n    for index in 0 ..< result.count {\n        if result[index] ==\
    \ max_level {\n            result.remove(at: index)\n        }\n    }\n    return\
    \ result", "    paren_string = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    let brackets = [Character](paren_string)\n    var level = 0\n    var stack\
    \ = [Character]()\n    for b in brackets {\n        if b == '(' { stack.append(b)\
    \ }\n        else if b == ')' {\n            let len = stack.count\n         \
    \   if len > 0 {\n                if len > level {\n                    level\
    \ = len\n                }\n                stack.removeLast()\n            }\n\
    \        }\n    }\n    return [level]", "    var levels = [Int]()\n    var level_stack:\
    \ [Int] = [Int]()\n\n    for c in paren_string.unicodeScalars {\n        if c.value\
    \ == UnicodeScalar(BracketLeft) {\n            var level = 0\n            for\
    \ _ in level_stack {\n                level++\n            }\n            level_stack\
    \ = append(level_stack, 0, level)\n        } else if c.value == UnicodeScalar(BracketRight)\
    \ {\n            var level = 0\n            for level in level_stack {\n     \
    \           level--\n                if level < 0 {\n                    level_stack\
    \ = levels[level+1:] + levels[:level+1]\n                    break\n         \
    \       }\n            }\n        }\n    }\n\n    return levels", "    var levels\
    \ = [Int]()\n    var curr_level = 0\n    for c in paren_string.unicodeScalars\
    \ {\n        switch c.value {\n        case paren_char.openParen:\n          \
    \  levels[curr_level] = Int.max\n            curr_level++\n        case paren_char.closeParen:\n\
    \            curr_level--\n        }\n    }\n    return levels", "\tparen_string\
    \ = paren_string.trim()\n\tparen_string = paren_string.replace(\"()\", \"\")\n\
    \n\tvar paren_count = 0\n\tvar nesting_level = 0\n\n\tvar max_level = 0\n\n\t\
    var result_array = [Int]()\n\n\tfor char in paren_string.characters {\n\t\tswitch\
    \ char {\n\t\tcase \"(\":\n\t\t\tparen_count += 1\n\t\t\tnesting_level += 1\n\t\
    \t\tif nesting_level > max_level {\n\t\t\t\tmax_level = nesting_level\n\t\t\t\
    }\n\t\tcase \")\":\n\t\t\tparen_count -= 1\n\t\t\tnesting_level -= 1\n\t\t\tif\
    \ nesting_level < 0 {\n\t\t\t\tnesting_level = 0\n\t\t\t}\n\t\t}\n\t\tresult_array.append(paren_count)\n\
    \t}\n\n\treturn result_array", "    // Remove all spaces.\n    paren_string =\
    \ paren_string.trimmingCharacters(in: NSCharacterSet.whitespaces)\n\n    var levels:\
    \ [Int] = []\n\n    // First we find parentheses levels that we already have levels.\n\
    \    func getDepth(_ currentDepth: Int, _ lastDepth: Int) -> Int {\n        if\
    \ lastDepth > currentDepth {\n            return currentDepth + 1\n        }\n\
    \        return lastDepth\n    }\n\n    // Find the parentheses levels that we\
    \ already have levels.\n    for i in 0 ..< paren_string.characters.count {\n \
    \       if paren_string[i] == '(' || paren_string[i] == '{' || paren_string[i]\
    \ == '[' {\n            let currentDepth = levels.count\n            levels.append(currentDepth)\n\
    \        }\n    }\n\n    // Now we do the nesting recursively.\n    let nestedCounts\
    \ = paren_string.characters.enumerated().filter({ $0.element == '(' })\n    nestedCounts.forEach({\
    \ nestedCount in\n        if let openingParenthesis = nestedCount.element {\n\
    \            // Look for closing parenthesis.\n            let lastDepth = levels.count\n\
    \            nestedCounts = paren_string.characters.enumerated().filter({ $0.element\
    \ == ')' })\n            nestedCounts.forEach({ nestedCount2 in\n            \
    \    if let closingParenthesis = nestedCount2.element {\n                    let\
    \ newDepth = getDepth(currentDepth, lastDepth)\n                    levels.append(newDepth)\n\
    \                }\n            })\n        }\n    })\n\n    return levels", " \
    \   var result = [Int]()\n    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    var opening = false\n    var opening_count\
    \ = 1\n    var stack = [String]()\n    stack.append(\"\")\n    for char in paren_string.unicodeScalars\
    \ {\n        let char_str = String(char)\n        if char == '(' {\n         \
    \   if opening_count < stack[stack.count - 1].characters.count {\n           \
    \     opening_count++\n                opening = true\n            }\n       \
    \ } else if char == ')' {\n            if opening_count == stack[stack.count -\
    \ 1].characters.count {\n                opening = false\n                opening_count--\n\
    \            }\n        } else if opening {\n            if char_str != \" \"\
    \ {\n                stack.append(char_str)\n            }\n        } else {\n\
    \            if opening_count != stack[stack.count - 1].characters.count {\n \
    \               result.append((opening_count - stack[stack.count - 1].characters.count))\n\
    \            }\n            result.append((stack.count - 1))\n        }\n    }\n\
    \    return result", "    var level: [Int] = [0]\n    var levels: [(Int, Int)]\
    \ = [(0, 0)]\n    var pos: Int = 0\n    for paren in\n        paren_string.split(separator:\
    \ \" \", omittingEmptySubsequences: true)\n    {\n        if paren == \"\" {\n\
    \            continue\n        }\n        var parentheses = paren.split(separator:\
    \ \")\", omittingEmptySubsequences: true)\n        for paren in parentheses {\n\
    \            levels[level[0]] = level[0] + 1, level[0]\n            level[0] +=\
    \ 1\n            pos += paren.count\n        }\n        pos += level[0]\n    \
    \    level[0] += 1\n    }\n    return levels", "    if paren_string.contains(\"\
    \ \") || paren_string.contains(\"(\") || paren_string.contains(\")\")\n    {\n\
    \        let nested_parens = paren_string.components(separatedBy: \" \")\n   \
    \     var levels = Array<Int>()\n        \n        for paren in nested_parens\n\
    \        {\n            if paren.contains(\"(\")\n            {\n            \
    \    var count = levels[0]\n                levels[0] = levels[0]+1\n        \
    \        for i in 0 ..< (nested_parens.index(paren)+1)\n                {\n  \
    \                  count = (levels[i+1] > count) ? levels[i+1] : count\n     \
    \               levels[i+1] = count\n                }\n            }\n      \
    \      else if paren.contains(\")\")\n            {\n                levels.append(levels[0]-1)\n\
    \                levels[0] = levels[0]-1\n            }\n        }\n        \n\
    \        return levels\n    }\n    return [Int.random(in: 0..<3)]", "    var max\
    \ = 0\n    for _, group := range paren_string.Split() {\n        let level = level(group)\n\
    \        max = max > level ? max : level\n    }\n    return [max]", "    var levels\
    \ = [Int]()\n    var level_stack = [Int]()\n    for ch in paren_string {\n   \
    \     // We hit the right paren, increment our stack and push our depth onto our\
    \ stack\n        if ch == \")\" {\n            levels.append(level_stack.pop())\n\
    \            level_stack.append(0)\n        }\n        // We hit a left paren,\
    \ decrease our stack and pop our depth off our stack\n        else if ch == \"\
    (\" {\n            level_stack.pop()\n        }\n        // We hit a space, we\
    \ found an opening paranthesis and are about to start a new level, push our depth\
    \ onto the stack\n        else if ch == \" \" {\n            level_stack.append(0)\n\
    \        }\n    }\n    // This should never happen if our paren string was well-formed\
    \ and we didn't hit any paren mismatches.\n    assert(levels == nil)\n    return\
    \ level_stack", "    let split_strings = paren_string.split(\" \").map(String.init)\n\
    \    var max_nesting = 0\n    for split_string in split_strings {\n        guard\
    \ split_string.count > 0 else {\n            return [0]\n        }\n        let\
    \ count = parseNestedParens(split_string).count\n        if count > max_nesting\
    \ {\n            max_nesting = count\n        }\n    }\n    return [max_nesting]",
  "    var paren_count = 0\n    var stack = 0\n    var max_nesting = -1\n    for _,\
    \ c in paren_string.characters {\n        if c == '(' {\n            paren_count\
    \ += 1\n            stack++\n        } else if c == '(' && paren_count > 0 {\n\
    \            paren_count -= 1\n            stack++\n        } else if c == ')'\
    \ && paren_count > 0 {\n            paren_count -= 1\n            if stack > max_nesting\
    \ {\n                max_nesting = stack\n            }\n        } else if c ==\
    \ ')' && paren_count == 0 {\n            stack--\n        }\n    }\n    return\
    \ max_nesting + 1", "\tvar level = 0\n\tvar max_level = 0\n\tvar paren_levels\
    \ = [Int]()\n\tparen_string.split(\" \").forEach() {\n\t\tparen_levels[level]\
    \ = paren_levels[level] + 1\n\t\tif paren_levels[level] > max_level {\n\t\t\t\
    max_level = paren_levels[level]\n\t\t}\n\t\tlevel = level + 1\n\t}\n\treturn max_level",
  "    var level = 0\n    var maxLevel = 0\n    for _ in paren_string.characters {\n\
    \        level += 1\n        if level > maxLevel {\n            maxLevel = level\n\
    \        }\n    }\n    var maxLevel_array = [Int](repeating: 0, count: maxLevel)\n\
    \    for index in 0..<paren_string.characters.count {\n        if paren_string.substring(from:\
    \ index, length: 1) == \")\" {\n            level -= 1\n        }\n        maxLevel_array[level]\
    \ += 1\n    }\n    return maxLevel_array", "    var levels = [Int]()\n    var\
    \ nesting_level = 0\n    var prev_char: Char?\n    var current_char: Char?\n \
    \   for c in paren_string.unicodeScalars {\n        if c == '(' {\n          \
    \  nesting_level += 1\n            if nesting_level > levels[nesting_level] {\n\
    \                levels[nesting_level] = nesting_level\n            }\n      \
    \  }\n        else if c == ')' {\n            nesting_level -= 1\n           \
    \ if nesting_level < levels[nesting_level] {\n                levels[nesting_level]\
    \ = nesting_level\n            }\n        }\n        if nesting_level != 0 {\n\
    \            prev_char = current_char\n        }\n        current_char = c\n \
    \   }\n    return levels", "    var level = 0\n    var levels = [Int]()\n\n  \
    \  for s in paren_string.characters {\n        if s == \")\" {\n            levels[level]\
    \ = level\n            level = 0\n        }\n\n        level += 1\n    }\n\n \
    \   return levels", "    var max_nesting_level = 0\n    var nested_levels = [Int]()\n\
    \    var parens = paren_string.characters\n    var paren_counter: Int = 0\n  \
    \  var last_paren_level = 0\n    for paren in parens {\n        paren_counter\
    \ += 1\n        let paren_level = paren_counter\n        last_paren_level = paren_level\n\
    \        nested_levels.append(last_paren_level)\n        if paren_level > max_nesting_level\
    \ {\n            max_nesting_level = paren_level\n        }\n    }\n    return\
    \ nested_levels", "    var max_count = 0\n    var max_level = 0\n    for i in\
    \ 0 ..< paren_string.count {\n        switch paren_string[i] {\n        case \"\
    )\":\n            count += 1\n            if count > max_count {\n           \
    \     max_count = count\n                max_level = i\n            }\n      \
    \  case \")(\":\n            count -= 1\n            if count > max_count {\n\
    \                max_count = count\n                max_level = i\n          \
    \  }\n        }\n    }\n    return Array(paren_string.characters\n        .dropFirst(max_level\
    \ + 1)\n        .prefix(max_level))", "    var paren_depths: [Int] = []\n    for\
    \ parens in paren_string.split(\" \") {\n        if paren_depths.isEmpty {\n \
    \           paren_depths = paren_depths.reverse()\n        }\n        var paren_depth\
    \ = 0\n        for paren in parens.characters {\n            if paren == '(' {\n\
    \                paren_depth += 1\n            } else if paren == ')' {\n    \
    \            paren_depth -= 1\n                if paren_depth == 0 {\n       \
    \             paren_depths.append(paren_depth)\n                    break\n  \
    \              }\n            }\n        }\n    }\n    return paren_depths", " \
    \   let paren_groups = paren_string.split(separator: \" \")\n    \n    var level_counters:\
    \ [Int] = [0, 0]\n    \n    for paren_group in paren_groups {\n        let levels\
    \ = paren_group.countElements\n        level_counters = update_level_counters(level_counters,\
    \ levels)\n    }\n    \n    return level_counters", "    var result = [Int]()\n\
    \    var depth = 0\n    var opening_parens = 0\n\n    for char in paren_string.characters\
    \ {\n        switch char {\n        case '(':\n            opening_parens++\n\
    \        case ')':\n            opening_parens--\n            if opening_parens\
    \ == 0 {\n                result.append(depth)\n                depth = 0\n  \
    \          } else {\n                depth++\n            }\n        }\n    }\n\
    \n    return result", "    if paren_string == \"\" {\n        return []\n    }\n\
    \    let strings = paren_string.components(separatedBy: \" \")\n    \n    var\
    \ level = 0\n    \n    var paren_levels = [Int]()\n    var levels = [0]\n    \n\
    \    for paren in strings {\n        if paren == \"()\" {\n            level +=\
    \ 1\n            levels.append(level)\n            paren_levels.append(level)\n\
    \        } else if paren == \")\" {\n            if level > 0 {\n            \
    \    level -= 1\n                levels.append(level)\n                paren_levels.append(level)\n\
    \            } else {\n                paren_levels.append(levels[0])\n      \
    \      }\n        }\n    }\n    \n    return paren_levels", "    var max_levels\
    \ = 0\n    var level = 0\n    func is_closed_paren(x: String) -> Bool {\n    \
    \    return x.characters.count == 1 && (x == \"(\") || (x == \")\")\n    }\n \
    \   for x in paren_string.characters {\n        if is_closed_paren(x) {\n    \
    \        level--\n            if level > max_levels {\n                max_levels\
    \ = level\n            }\n        } else {\n            level++\n        }\n \
    \   }\n    return Array(1...max_levels).map { _ in 0 }", "    var level: [Int]\
    \ = []\n    var stack = [Character.UnicodeScalarView]()\n    for char in paren_string.unicodeScalars\
    \ {\n        switch char {\n        case \"(\":\n            stack.append(char)\n\
    \        case \"(\":\n            if stack.count == 0 {\n                return\
    \ nil\n            }\n            level.append(stack.count - 1)\n            stack.removeLast()\n\
    \        case \"(\":\n            stack.removeLast()\n            level.append(stack.count\
    \ - 1)\n        default:\n            if stack.count == 0 {\n                return\
    \ nil\n            }\n            stack.removeLast()\n        }\n    }\n    if\
    \ stack.count != 0 {\n        return nil\n    }\n    return level", "    var level\
    \ = 0\n    var count = [Int]()\n    paren_string.split(\" \").forEach { item in\n\
    \        if item.contains(\"(\") {\n            count += 1\n        } else {\n\
    \            level -= 1\n        }\n        if level < 0 {\n            level\
    \ = 0\n            count += 0\n        }\n    }\n    return count", "\tvar levels\
    \ = [Int]()\n\t\n\tvar count = 0\n\tfor (index, ch) in paren_string.enumerated()\
    \ {\n\t\tif ch == \"(\" {\n\t\t\tcount += 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\t\
    if ch == \")\" {\n\t\t\tlevels[count] = levels[count-1]\n\t\t\t\n\t\t\tcount -=\
    \ 1\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\tlevels[count] = count\n\t}\n\t\n\treturn\
    \ levels", "\tlet paren_stack: [Int] = []\n\n\tfor char in paren_string.unicodeScalars\
    \ {\n\t\tswitch char {\n\t\tcase '(':\n\t\t\tparen_stack.append(0)\n\t\t\tcontinue\n\
    \t\tcase ')':\n\t\t\tparen_stack.removeLast()\n\t\t\tcontinue\n\t\tdefault:\n\t\
    \t\tbreak\n\t\t}\n\t}\n\n\treturn paren_stack", '    return parse_nested_parens_rec(paren_string,
    "", 0)', "    var level: [Int] = [0]\n\n    for group in paren_string.components(separatedBy:\
    \ \" \") {\n        if group != \"\" {\n            let index = group.characters.index(of:\
    \ \"(\")!\n            let start = index\n            let end = group.characters.index(of:\
    \ \")\", offset: index)!\n            level.append(level[index] + 1)\n       \
    \     level[index] = level[index] + 1\n\n            for _ in stride(from: start,\
    \ to: end, by: -1) {\n                if level[index] == level[index + 1] {\n\
    \                    level[index] = level[index + 1]\n                    break\n\
    \                } else {\n                    level[index] = level[index] + 1\n\
    \                }\n            }\n        }\n    }\n    return level", "    paren_string\
    \ = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines).lowercased()\n\
    \    var max_nested_level = 0\n    var level = 0\n    var open_parantheses = 0\n\
    \    var close_parantheses = 0\n    var incomplete_open_parantheses = 0\n    var\
    \ incomplete_close_parantheses = 0\n    var index = 0\n    var depth = 0\n   \
    \ while index < paren_string.characters.count {\n        let character = paren_string.character(at:\
    \ index)\n        switch character {\n        case ')':\n            if incomplete_close_parantheses\
    \ == 0 {\n                close_parantheses += 1\n            } else {\n     \
    \           incomplete_close_parantheses = 0\n                incomplete_open_parantheses\
    \ += 1\n            }\n            level += 1\n        case ')':\n           \
    \ close_parantheses -= 1\n            if close_parantheses == 0 {\n          \
    \      close_parantheses = 0\n            }\n            level += 1\n        case\
    \ ')':\n            close_parantheses += 1\n            if close_parantheses ==\
    \ 1 {\n                incomplete_open_parantheses = 0\n            }\n      \
    \  case ')':\n            open_parantheses -= 1\n            if open_parantheses\
    \ == 0 {\n                break\n            }\n        case ')':\n          \
    \  open_parantheses += 1\n        case ' ':\n            if incomplete_open_parantheses\
    \ == 0 {\n                index += 1\n                continue\n            }\n\
    \        case ')':\n            if incomplete_close_parantheses == 0 {\n     \
    \           incomplete_open_parantheses = 0\n                incomplete_close_parantheses\
    \ += 1\n            } else {\n                incomplete_close_parantheses = 0\n\
    \            }\n        case ')':\n            if incomplete_open_parantheses\
    \ == 0 {\n                break\n            }\n        default:\n           \
    \ open_parantheses += 1\n            close_parantheses += 1\n        }\n     \
    \   if level > max_nested_level {\n            max_nested_level = level\n    \
    \    }\n        index += 1\n    }\n    return [max_nested_level]", "    var nesting_levels:\
    \ [Int] = []\n    var cur_level = 0\n    for index in 0..<paren_string.characters.count\
    \ {\n        if paren_string.characters[index] == '(' {\n            nesting_levels.append(cur_level)\n\
    \        }\n        cur_level += 1\n        if paren_string.characters[index]\
    \ == ')' {\n            cur_level -= 1\n            if cur_level == 0 {\n    \
    \            nesting_levels.append(cur_level)\n            }\n        }\n    }\n\
    \    return nesting_levels", "    if paren_string.hasPrefix(\"(\") || paren_string.hasSuffix(\"\
    )\") {\n        return []\n    }\n    let paren_depths = paren_string.unicodeScalars.filter({$0.isASCII}).map({\
    \ paren_string in\n        var paren_groups = paren_string.unicodeScalars.filter({!$0.isASCII}).map({\
    \ paren_string in\n            var level = 1\n            var maxLevel = 0\n \
    \           var paren_level = 0\n            var is_balanced = true\n        \
    \    for c in paren_groups {\n                if c == '{' || c == '[' {\n    \
    \                is_balanced = false\n                }\n                if paren_groups[paren_level]\
    \ == c {\n                    paren_level += 1\n                } else if paren_level\
    \ > 0 && paren_groups[paren_level-1] == c {\n                    paren_level -=\
    \ 1\n                }\n                if paren_level > maxLevel {\n        \
    \            maxLevel = paren_level\n                }\n            }\n      \
    \      if paren_level != 0 && maxLevel > paren_level {\n                return\
    \ -1\n            }\n            level++\n            return level\n        })\n\
    \        return paren_groups.reduce(0, combine: { $0 + $1 })\n    })\n    return\
    \ paren_depths", "    // Start from 0 to skip the empty string\n    var level\
    \ = 0\n    var nesting = 0\n    var max_nesting = 0\n    var group_count = 0\n\
    \    var group_nesting = 0\n    var group_string = \"\"\n    for ch in paren_string.characters\
    \ {\n        switch ch {\n        case \".\":\n            if level == 0 {\n \
    \               continue\n            }\n            level--\n        case \"\
    )\":\n            if level == 0 {\n                continue\n            }\n \
    \           level++\n            nesting--\n            if nesting > max_nesting\
    \ {\n                max_nesting = nesting\n            }\n            group_nesting\
    \ = level\n            group_count++\n        case \")\\n\":\n            group_string\
    \ = group_string.trimmingCharacters(in: CharacterSet.newlines)\n            if\
    \ group_string != \"\" {\n                nesting = group_nesting\n          \
    \      group_count = 0\n                group_nesting = 0\n            }\n   \
    \     default:\n            if level == 0 {\n                group_string = group_string.trimmingCharacters(in:\
    \ CharacterSet.newlines)\n                continue\n            }\n          \
    \  group_string = String(group_string)\n            group_string.append(String(ch))\n\
    \        }\n    }\n    return [Int](repeating: 0, count: max_nesting)", "    var\
    \ max_level = 0\n    var level = 0\n    var max_level_pos = 0\n    var parentheses:\
    \ [String] = []\n    for pos in paren_string.characters.indices{\n        level++\n\
    \        if paren_string[pos] == ')' {\n            if level > max_level {\n \
    \               max_level = level\n                max_level_pos = pos\n     \
    \       }\n            level--\n            parentheses.append(String())\n   \
    \     } else {\n            parentheses[level] += String(paren_string[pos])\n\
    \        }\n    }\n    if level > max_level {\n        max_level = level\n   \
    \     max_level_pos = 0\n    }\n    return Array(parentheses[max_level..<max_level\
    \ + 1])", "    var max = 0\n    var count = 0\n    var i = 0\n    var par_count\
    \ = 0\n    var max_par_count = 0\n    var par_depth = 0\n    var par_char = \"\
    \"\n    var par_char_count = 0\n    var char_count = 0\n    var char_i = 0\n \
    \   var open_bracket = false\n    var is_right_bracket = false\n    var is_left_bracket\
    \ = false\n    var level = 0\n    var open_par = false\n    var is_right_par =\
    \ false\n    var is_left_par = false\n    var brackets = [String]()\n    var par_i\
    \ = -1\n    var par_i_level = 0\n\n    for (i = 0; i < paren_string.characters.count;\
    \ i += 1) {\n        char = paren_string.characters[i]\n\n        if char == \"\
    (\" || char == \")\" {\n            if count > 0 {\n                max += count\n\
    \                count = 0\n            }\n\n            if char == \"(\" {\n\
    \                if open_bracket {\n                    count += 1\n         \
    \       } else if par_char_count == 0 {\n                    open_bracket = true\n\
    \                } else {\n                    par_count += 1\n              \
    \      par_char_count = par_count\n                    par_depth = par_i_level\n\
    \                    par_char_count = 0\n                }\n            } else\
    \ {\n                if open_bracket {\n                    count -= 1\n     \
    \           } else if par_char_count == 0 {\n                    open_bracket\
    \ = false\n                } else {\n                    par_count -= 1\n    \
    \                par_char_count = par_count\n                    par_depth = par_i_level\n\
    \                    par_char_count = 0\n                }\n            }\n\n\
    \            if par_char_count > max_par_count {\n                max_par_count\
    \ = par_char_count\n            }\n\n            par_i_level = par_depth\n   \
    \         par_char = \"\"\n            par_char_count = 0\n            par_i =\
    \ i\n        } else {\n            if par_char == \"(\" {\n                if\
    \ is_right_bracket {\n                    par_par_i = i\n                }\n \
    \               is_right_bracket = true\n            } else {\n              \
    \  if is_right_bracket {\n                    par_par_i = i\n                }\n\
    \                is_right_bracket = false\n            }\n\n            if par_par_i\
    \ != -1 {\n                par_char_count = paren_string.characters[par_par_i].characters.count\
    \ - par_par_i\n                if par_char_count > char_count {\n            \
    \        char_count = par_char_count\n                }\n                par_i_level\
    \ = paren_string.characters[par_par_i].characters.count - par_par_i\n        \
    \        if par_i_level > par_i_level {\n                    par_i_level = par_i_level\n\
    \                }\n\n                if par_char_count == 0 {\n             \
    \       par_depth = par_i_level\n                    par_char = \"\"\n       \
    \             par_char_count = 0\n                    par_i = -1\n           \
    \     }\n            } else {\n                if par_char_count > char_count\
    \ {\n                    char_count = par_char_count\n                }\n\n  \
    \              if ", "    var max_level = 0\n    var open_count = 1\n    for paren\
    \ in paren_string.characters {\n        if paren == ')' {\n            open_count\
    \ -= 1\n        }\n        if open_count == 0 {\n            max_level = max(max_level,\
    \ paren_string.characters.count - paren_string.startIndex + 2)\n        }\n  \
    \      if paren == '(' {\n            open_count += 1\n        }\n    }\n    return\
    \ max_level", "    var level = 0\n\n    for parens in paren_string.split(\" \"\
    ) {\n        if parens.contains(\"(\") {\n            if parens.count >= level\
    \ {\n                level++\n            }\n        }\n\n        if parens.contains(\"\
    )\") {\n            if parens.count < level {\n                level--\n     \
    \       }\n        }\n    }\n\n    return Array(1...level).sorted()", "    var\
    \ level = 0\n    var max_level = 0\n    var nesting_count = 0\n    var max_nesting_count\
    \ = 0\n    var nesting_group_size = 0\n    for character in paren_string.characters\
    \ {\n        if character == \"(\" {\n            nesting_count += 1\n       \
    \     nesting_group_size++\n            level = nesting_count\n            max_level\
    \ = nesting_count + nesting_group_size\n        }\n        else if character ==\
    \ \")\" {\n            nesting_count -= 1\n            nesting_group_size--\n\
    \            level = nesting_count\n        }\n        if nesting_count > max_nesting_count\
    \ {\n            max_nesting_count = nesting_count\n        }\n    }\n    var\
    \ nesting_levels: [Int] = []\n    for nesting_count in 0..<max_nesting_count {\n\
    \        nesting_levels.append(level + nesting_count)\n    }\n    return nesting_levels",
  "    var nesting_level = 0\n    var deepest_nesting_level = 0\n\n    for index in\
    \ 0..<paren_string.characters.count {\n        let char = paren_string.characters.subscript[index]\n\
    \n        if char == \"(\" {\n            nesting_level += 1\n        } else if\
    \ char == \")\" {\n            if nesting_level == 0 {\n                deepest_nesting_level\
    \ = nesting_level\n            }\n            nesting_level -= 1\n        }\n\
    \    }\n\n    return [deepest_nesting_level]", "    var output = [Int]()\n   \
    \ var stack = [String]()\n    for s in paren_string.split(\" \") {\n        guard\
    \ let open_paren_index = s.firstIndex(of: \"(\") else {\n            return output\n\
    \        }\n        stack.append(s[open_paren_index...])\n    }\n    while stack.count\
    \ > 0 {\n        let open_paren_index = stack.lastIndex(of: \"(\")\n        if\
    \ open_paren_index != nil {\n            output.append(open_paren_index!)\n  \
    \          stack.removeSubrange(open_paren_index!...open_paren_index!.endIndex)\n\
    \        } else {\n            stack.removeLast()\n        }\n    }\n    return\
    \ output", "\tlet level = 0\n\tvar result = [Int]()\n\tlet parentheses = paren_string.characters\n\
    \tlet paren_chars = paren_string.characters\n\n\tfor paren_index in 0..<parentheses.count\
    \ {\n\t\tif paren_chars[paren_index] == '(' { level += 1 }\n\t\tif paren_chars[paren_index]\
    \ == ')' { level -= 1 }\n\t\tif level == 0 {\n\t\t\tresult.append(paren_index)\n\
    \t\t}\n\t}\n\treturn result", "    var max_nested_level = 0\n    var paren_stack\
    \ = Stack{paren_string}\n\n    for paren_string in paren_string.characters{\n\
    \        if paren_stack.isEmpty{\n            max_nested_level++\n        }\n\
    \        else{\n            let parentheses = paren_stack.pop()\n            if\
    \ parentheses == paren_string{\n                max_nested_level++\n         \
    \   }\n            else{\n                max_nested_level = max(max_nested_level,paren_stack.size)\n\
    \            }\n        }\n    }\n\n    return Array(1...max_nested_level)", " \
    \   guard paren_string.count >= 1 else {\n        return []\n    }\n    \n   \
    \ var level = 0\n    var maxLevel = 0\n    var max = 0\n    \n    for c in paren_string[1..<paren_string.count]\
    \ {\n        guard c == '(' else {\n            return nil\n        }\n      \
    \  \n        if level < 0 {\n            level++\n            maxLevel = level\n\
    \        }\n        \n        level--\n        if level > max {\n            max\
    \ = level\n        }\n    }\n    \n    return maxLevel", "    var max_nesting_level\
    \ = 0\n    for paren in paren_string.components(separatedBy: \" \") {\n      \
    \  var nesting_level = 0\n        for char_index in paren.characters {\n     \
    \       if char_index == '(' {\n                nesting_level += 1\n         \
    \   }\n            else if char_index == ')' {\n                nesting_level\
    \ -= 1\n            }\n        }\n\n        if nesting_level > max_nesting_level\
    \ {\n            max_nesting_level = nesting_level\n        }\n    }\n    return\
    \ max_nesting_level", "    var parens_level = [Int]()\n    var current_level =\
    \ 0\n\n    for ch in paren_string.unicodeScalars {\n        switch ch {\n    \
    \    case .OpenParen: current_level += 1 // count the opening bracket\n      \
    \  case .CloseParen: current_level -= 1 // count the closing bracket\n       \
    \ default: break\n        }\n\n        // update the current level if it crossed\
    \ the maximum level\n        if current_level < parens_level.count {\n       \
    \     parens_level[current_level] = max(parens_level[current_level], current_level)\n\
    \        }\n    }\n\n    return parens_level", "    var result = [Int]()\n   \
    \ var level = 0\n    var inParenthesis = false\n    var last = 0\n\n    paren_string.forEach\
    \ {\n        switch $0 {\n        case \"(\":\n            inParenthesis = true\n\
    \            level++\n            last = $0\n        case \")\":\n           \
    \ inParenthesis = false\n            level--\n            if level == 0 {\n  \
    \              result.insert(last, level + 1)\n            }\n            last\
    \ = $0\n        default:\n            last = $0\n        }\n    }\n\n    return\
    \ result", "    var level = [Int]()\n    let paren_char = \"()\"\n    var i =\
    \ 0\n    while i < paren_string.characters.count {\n        if paren_string.characters[i]\
    \ == paren_char {\n            level[level.count-1] = level.count\n          \
    \  i += 1\n            while i < paren_string.characters.count && paren_string.characters[i]\
    \ != paren_char {\n                i += 1\n            }\n            i += 1\n\
    \        } else if paren_string.characters[i] == \")\" {\n            let max_level\
    \ = level.max()!\n            for _ in 0..<max_level {\n                level.removeLast()\n\
    \            }\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ level", "    let paren_stack: [[String]] = paren_string.split(\" \").map { $0\
    \ }\n    \n    // Parse the string\n    var max_level = 0\n    var levels = [Int]()\n\
    \    \n    for p in paren_stack {\n        // Find the deepest level of nesting\
    \ in the string\n        let level = 1\n        for i in 0 ... p.count - 1 {\n\
    \            if p[i] == \")\" && paren_stack[i - 1][p.count - 1] == \"(\" {\n\
    \                level++\n            } else {\n                level = 0\n  \
    \              break\n            }\n        }\n        \n        // Add the level\
    \ to the stack\n        if level > max_level {\n            max_level = level\n\
    \            levels = [Int]()\n        }\n        \n        // Add to levels\n\
    \        levels.append(level)\n    }\n    \n    // Get the maximum level\n   \
    \ let max_level = levels[levels.count - 1]\n    \n    return max_level", "   \
    \ \n    if paren_string.isEmpty {\n        return []\n    }\n\n    // get the\
    \ first character, which is always '('\n    guard let first_char = paren_string.first\
    \ else {\n        return []\n    }\n\n    // check if the first character is '(',\
    \ if true, then it's a group\n    if first_char == '(' { // group\n\n        //\
    \ get the first ')' from the string\n        guard let group_end = paren_string.range(of:\
    \ ')', options: .backwards) else {\n            return []\n        }\n\n     \
    \   // check if the next character is ')'\n        guard paren_string[group_end.upperBound]\
    \ == ')' else {\n            return []\n        }\n\n        // if so, get the\
    \ string that follows the ')'\n        guard let next_string = paren_string[group_end.lowerBound\
    \ + 1 : group_end.upperBound] else {\n            return []\n        }\n\n   \
    \     // if that string is a group, add the level from its first '(' to the level\
    \ of the final '('\n        if next_string.isEmpty {\n            return []\n\
    \        }\n        \n        let next_char_array = next_string.unicodeScalars.map\
    \ { $0.value }\n        let next_char_ints = parse_nested_parens(paren_string:\
    \ next_string)\n\n        // append the level of the group to the level of the\
    \ next (')\n        return next_char_ints + [first_char.unicodeScalar.value -\
    \ 1]\n    }\n    \n    // else (first char is not '('), then it's a simple paren\n\
    \    return [first_char.unicodeScalar.value - 1]", "    paren_string = paren_string.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \" ()\")) // trim leading and trailing spaces and\
    \ ( and )\n    \n    var groups = [Int]()\n    \n    if paren_string.characters.count\
    \ == 0 {\n        return groups\n    }\n    \n    for paren in paren_string.characters\
    \ {\n        switch paren {\n        case '(':\n            groups.append(0)\n\
    \        case ')':\n            groups[groups.count-1] += 1\n            if groups.count\
    \ >= 2 {\n                groups[groups.count-2]--\n            }\n        default:\n\
    \            groups.append(0)\n        }\n    }\n    \n    return groups", " \
    \   let string_pieces = paren_string.components(separatedBy: \" \")\n    var level\
    \ = 0\n    var levels_left = [Int](repeating: 0, count: paren_string.count).enumerated().map\
    \ {\n        (index, value) in return level + index\n    }\n    for piece in string_pieces\
    \ {\n        if piece.isEmpty {\n            continue\n        }\n        if piece[0]\
    \ == \"(\" && piece.contains(\"(\") {\n            let depth = 1 + levels_left.last!\n\
    \            levels_left.remove(at: levels_left.index(before: levels_left.last!))\n\
    \            levels_left.insert(depth - 1, 0)\n            level++\n        }\n\
    \        if piece[piece.endIndex-1] == \")\" && piece.contains(\")\") {\n    \
    \        let depth = 1 + levels_left.last!\n            levels_left.remove(at:\
    \ levels_left.index(before: levels_left.last!))\n            levels_left.insert(depth\
    \ - 1, 0)\n            level--\n        }\n    }\n    return levels_left.last!",
  "\tparens := paren_string.split(\" \").map(strconv.Itoa).filter(!is_empty_string)\n\
    \tparen_counts := [Int]()\n\tfor _, paren_string in parens {\n\t\tparen_count\
    \ = parse_paren_count(paren_string)\n\t\tif paren_count == 0 {\n\t\t\treturn []\n\
    \t\t}\n\t\tparen_counts.append(paren_count)\n\t}\n\treturn paren_counts", "\t\
    result := [Int]()\n\tstacks := make([]*Stack, len(paren_string))\n\tfor i := 0;\
    \ i < len(paren_string); i++ {\n\t\tstack := &Stack{\n\t\t\tlevel: i,\n\t\t}\n\
    \t\tstacks[i] = stack\n\t}\n\tpush_stack(stacks, paren_string, 0)\n\tdepth :=\
    \ 0\n\tfor {\n\t\tif stacks[depth].is_empty {\n\t\t\tbreak\n\t\t}\n\t\tif paren_stacks[depth][len(paren_stacks[depth])-1].level\
    \ == stacks[depth].level {\n\t\t\tpush_stack(stacks, paren_stacks[depth][len(paren_stacks[depth])-1].value,\
    \ stacks[depth].level+1)\n\t\t} else {\n\t\t\tpop_stack(stacks, depth)\n\t\t\t\
    result[depth] = stacks[depth].level + 1\n\t\t\tbreak\n\t\t}\n\t\tdepth++\n\t}\n\
    \treturn result", "    \n    var levels_stack: [Int] = [0]\n    var result_array:\
    \ [Int] = [0]\n    \n    let parentheses_array = paren_string.characters\n   \
    \ for i in parentheses_array.indices {\n        \n        if parentheses_array[i]\
    \ == \")\" {\n            \n            levels_stack.removeLast()\n          \
    \  result_array.append(levels_stack.removeLast())\n        }\n        \n     \
    \   levels_stack.append(1)\n    }\n    \n    return result_array", "    paren_string\
    \ = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n\n    // The\
    \ index of the deepest parentheses level in the input string.\n    // If no parentheses\
    \ found in the input, the value is 0.\n    var max_level = 0\n    var output_levels\
    \ = [Int]()\n\n    // The index of the last parentheses level in the input string.\n\
    \    // If no parentheses found in the input, the value is 0.\n    var last_level\
    \ = 0\n    var last_index = 0\n\n    for current_index in paren_string.characters.indices\
    \ {\n        // If the current char is a left parenthesis, increment level\n \
    \       if paren_string[current_index] == Character('(') {\n            assert(last_index\
    \ != current_index)\n            output_levels.append(0)\n            last_index\
    \ = current_index\n        }\n\n        // If the current char is a right parenthesis,\
    \ decrease level\n        else if paren_string[current_index] == Character(')'){\n\
    \            assert(last_index != current_index)\n            let level = output_levels[last_index-1]\n\
    \            if level > max_level {\n                max_level = level\n     \
    \       }\n            last_index = current_index\n        }\n    }\n\n    assert(last_index\
    \ == paren_string.characters.endIndex)\n    assert(last_index == paren_string.characters.indices)\n\
    \n    if max_level > 0 {\n        // If the last level of parentheses is greater\
    \ than zero, add the max level to output_levels.\n        // Otherwise, add 1.\n\
    \        output_levels.append(max_level)\n    }\n\n    return output_levels",
  "    var max_level = Int()\n    var level = 0\n    var nested = 0\n    var opening\
    \ = 0\n    for char in paren_string.characters {\n        if char == '(' {\n \
    \           opening++\n        }\n        if char == ')' {\n            opening--\n\
    \        }\n        if opening > 0 {\n            level++\n        }\n       \
    \ if opening < 0 {\n            level--\n        }\n        if level > max_level\
    \ {\n            max_level = level\n            nested = Int()\n        }\n  \
    \      nested += Int(char)\n    }\n    return [max_level, nested]", "    var level\
    \ = 0\n    var paren_count = 0\n    var results = [Int]()\n    for char in paren_string.characters\
    \ {\n        if char == ')' {\n            level--\n            if paren_count\
    \ == 0 {\n                results.append(level)\n            }\n        }\n  \
    \      else {\n            level++\n            paren_count++\n        }\n   \
    \ }\n    return results", "    var max_nest = 0\n    var max_depth = 0\n    var\
    \ nest = 0\n    var depth = 0\n\n    for char in paren_string.unicodeScalars {\n\
    \        if nesting {\n            nest--\n        }\n\n        if char == '('\
    \ {\n            nest++\n            depth++\n        } else if char == ')' {\n\
    \            if nest == 0 {\n                continue\n            }\n       \
    \     nest--\n            depth--\n        } else {\n            if depth > max_depth\
    \ {\n                max_depth = depth\n                max_nest = nest\n    \
    \        }\n        }\n    }\n\n    return Array(0 ..< max_depth).map { _ in\n\
    \        return max_nest\n    }", "    var max = [Int]()\n    var len = 0\n  \
    \  for groupStr in paren_string.components(separatedBy: \" \") {\n        if groupStr.count\
    \ > max {\n            max = Array(repeating: 0, count: groupStr.count)\n    \
    \        len = 0\n        }\n        max[len] = max(max[len], groupStr.count)\n\
    \        len += 1\n    }\n    return max", "    // Remove leading '(' and trailing\
    \ ')'\n    paren_string = paren_string.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \"()\"))\n\n    // Split input string by space\n    let group_strings = paren_string.components(separatedBy:\
    \ \" \")\n\n    // Parse each group string and add the deepest level of nesting\
    \ to a result array\n    var result: [Int] = [0]\n    for group_string in group_strings\
    \ {\n        // Find index of opening '('\n        let opening_pos = group_string.firstIndex(of:\
    \ \"(\")!\n\n        // Find index of closing ')'\n        let closing_pos = group_string.firstIndex(of:\
    \ \")\")!\n\n        // Add level of nesting\n        result.append(closing_pos\
    \ - opening_pos + 1)\n    }\n\n    // Return result array\n    return result",
  "  var max_level: Int = 0\n\n  for paren_char in paren_string.unicodeScalars {\n\
    \    var level = 0\n    var parentheses = [String]()\n    var paren_count = 0\n\
    \n    while paren_count < paren_count {\n      if paren_char == parentheses.last!\
    \ {\n        paren_count += 1\n        continue\n      }\n\n      if paren_count\
    \ > max_level {\n        max_level = paren_count\n      }\n\n      parentheses.append(paren_char)\n\
    \      paren_count += 1\n\n      level += 1\n    }\n\n    level -= 1\n  }\n\n\
    \  return [max_level, max_level + level + 1]", "    if paren_string.isEmpty {\n\
    \        return []\n    }\n    var levels: [Int] = []\n    var paren_index = 0\n\
    \    var paren_open = -1\n    var paren_close = -1\n    var open_bracket = -1\n\
    \    for index in 0..<paren_string.count {\n        let char = paren_string[index]\n\
    \        switch char {\n        case \"(\":\n            levels[paren_index] =\
    \ paren_index\n            paren_index++\n            paren_open = index\n   \
    \     case \"\\\\\":\n            paren_close = index\n        case \"\\n\":\n\
    \            levels[paren_index] = paren_index\n            paren_index++\n  \
    \      default:\n            if paren_open != -1 {\n                levels[paren_index]\
    \ = paren_index\n                paren_index++\n                levels[paren_index]\
    \ = levels[paren_open]\n                paren_index++\n                levels[paren_index]\
    \ = paren_index\n                paren_index++\n                paren_open = -1\n\
    \            }\n            if char == \"(\" {\n                open_bracket =\
    \ index\n            } else if char == \")\" {\n                levels[paren_index]\
    \ = levels[open_bracket]\n                paren_index++\n                levels[paren_index]\
    \ = levels[open_bracket]\n                paren_index++\n                levels[paren_index]\
    \ = paren_index\n                paren_index++\n                open_bracket =\
    \ -1\n            }\n        }\n    }\n    return levels", '    return parse_nested_parens_impl(paren_string,
    "")', "    var max_level_of_nesting = 0\n    for group in paren_string.split(\"\
    \ \") {\n        max_level_of_nesting = (group == \"()\" ? 1 : 0) + (group ==\
    \ \"(()\" ? 2 : 0) + (max_level_of_nesting > 0 ? 1 : 0)\n    }\n    return max_level_of_nesting",
  "    var depth = 0\n    var result: [Int] = []\n    for s in paren_string.components(separatedBy:\
    \ \" \") {\n        // Find a matching opening bracket\n        var opening_bracket:\
    \ Int\n        if let found = s.range(of: \"(\") {\n            opening_bracket\
    \ = found\n        } else {\n            opening_bracket = s.endIndex\n      \
    \  }\n        \n        // Find a matching closing bracket\n        var closing_bracket:\
    \ Int\n        if let found = s.range(of: \")\") {\n            closing_bracket\
    \ = found\n        } else {\n            closing_bracket = opening_bracket\n \
    \       }\n        \n        // Get the string between the brackets\n        let\
    \ sub = String(s[opening_bracket...closing_bracket])\n        \n        // Increment\
    \ the depth\n        depth += 1\n        \n        // If depth is more than 1,\
    \ append the depth\n        if depth > 1 {\n            result.append(depth)\n\
    \        }\n        \n        // Reset the depth\n        depth = 0\n    }\n \
    \   return result", "    // Use a stack to keep track of how many parentheses\
    \ have been opened and closed.\n    // The top of the stack will be the deepest\
    \ level of nesting.\n    var paren_stack = [0]\n\n    // This loop will execute\
    \ until it reaches the end of the paren_string array\n    for index in 0..<paren_string.characters.count\
    \ {\n        // Get the character at the index we want to check\n        let char_at_check:\
    \ Character = paren_string.character(at: index)\n\n        // Check whether the\
    \ current character is a '(' or a '{'\n        let is_opening: Bool = paren_stack.lastValue\
    \ > 0 && paren_stack[paren_stack.lastValue-1] == 0 &&\n            (char_at_check\
    \ == \")\" || char_at_check == \"}\")\n\n        // If the character is not a\
    \ '(' or a '{'\n        if is_opening {\n            // If the character is a\
    \ '('\n            if char_at_check == \"(\" {\n                // Increment the\
    \ number on the top of stack\n                paren_stack[paren_stack.lastValue-1]\
    \ += 1\n            }\n            // If the character is a '{' but the previous\
    \ character is a '('\n            else if char_at_check == \"{\" && paren_stack[paren_stack.lastValue-1]\
    \ > 0 {\n                // Decrement the number on the top of stack\n       \
    \         paren_stack[paren_stack.lastValue-1] -= 1\n            }\n        }\n\
    \n        // If the last element on the stack is less than 0\n        if paren_stack.lastValue\
    \ < 0 {\n            // Reached an invalid parenthesis string\n            return\
    \ []\n        }\n    }\n\n    // Return the number of levels of parenthesis\n\
    \    return paren_stack", "    var max_level = 1\n    var level = 0\n    var max_level_paren\
    \ = 0\n    var level_paren = 0\n    \n    for char in paren_string {\n       \
    \ if char == '(' {\n            if level == 0 {\n                level += 1\n\
    \                if level_paren > max_level_paren {\n                    max_level_paren\
    \ = level_paren\n                }\n            } else {\n                level\
    \ -= 1\n            }\n        } else if char == ')' {\n            if level ==\
    \ 0 {\n                level_paren += 1\n            } else {\n              \
    \  level -= 1\n            }\n        } else {\n            if level > 0 {\n \
    \               level -= 1\n            }\n        }\n    }\n    \n    if level\
    \ > 0 {\n        max_level = 0\n    }\n    \n    var nested_paren_count = [Int](repeating:\
    \ 0, count: max_level_paren + 1)\n    for char in paren_string {\n        if char\
    \ == '(' {\n            nested_paren_count[level_paren] += 1\n        } else if\
    \ char == ')' {\n            if nested_paren_count[level_paren] == 1 {\n     \
    \           level_paren -= 1\n            }\n            nested_paren_count[level_paren]\
    \ -= 1\n        }\n    }\n    \n    return nested_paren_count", "    paren_string\
    \ = paren_string.trimmingCharacters(in: .whitespacesAndNewlines)\n    var level\
    \ = 0\n    var result = 0\n    var opening_count = 0\n    var open_count = 0\n\
    \    var close_count = 0\n    var close_count_start = -1\n    for index in 0..<paren_string.characters.count\
    \ {\n        switch paren_string.characters.reversed().first(where: {$0 == paren_string[index]})\
    \ {\n        case \"(\":\n            if opening_count == 0 {\n              \
    \  opening_count += 1\n            }\n            open_count += 1\n          \
    \  close_count += 1\n            close_count_start = index\n        case \"(\"\
    :\n            opening_count += 1\n        case \"):\":\n            open_count\
    \ -= 1\n            close_count -= 1\n            if opening_count == 0 && open_count\
    \ == 0 && close_count == 0 {\n                result = level\n               \
    \ level = 0\n            }\n        case \"(\":\n            opening_count -=\
    \ 1\n            if opening_count != 0 {\n                open_count -= 1\n  \
    \              close_count = open_count_start\n                open_count_start\
    \ = -1\n            }\n        default:\n            level -= 1\n        }\n \
    \   }\n    return result", "    var level = 1\n    var num_level = 0\n    var\
    \ paren_stack: [Int] = []\n    for index in 0..<paren_string.characters.count\
    \ {\n        if paren_string[index] == '(' {\n            num_level++\n      \
    \      if num_level > level {\n                level = num_level\n           \
    \ }\n        }\n        else if paren_string[index] == ')' {\n            num_level--\n\
    \            if num_level < level {\n                level = num_level\n     \
    \       }\n        }\n        paren_stack.append(num_level)\n    }\n    return\
    \ paren_stack", "    var levels = [Int]()\n\n    for opening_paren_index in 0..<paren_string.count\
    \ {\n        if paren_string[opening_paren_index] != \")\" {\n            levels.append(opening_paren_index\
    \ + 1)\n            continue\n        }\n\n        for nested_paren_index in levels[levels.count-1]..<paren_string.count\
    \ {\n            if paren_string[nested_paren_index] != \")\" {\n            \
    \    levels = append(levels, nested_paren_index + 1)\n                break\n\
    \            }\n        }\n\n        break\n    }\n\n    return levels", "   \
    \ var nested = 0\n    for index in paren_string.characters {\n        let open_char\
    \ = paren_string[index].unicodeScalars.first!.value // '('\n        let close_char\
    \ = paren_string[index + 1].unicodeScalars.first!.value // ')'\n\n        // If\
    \ the open bracket has a higher level than the current nested level, increment\
    \ it.\n        if paren_string[nested] == '(' && open_char > nested {\n      \
    \      nested += 1\n        }\n\n        // If the close bracket has a higher\
    \ level than the current nested level, decrement it.\n        if paren_string[nested]\
    \ == '(' && close_char > nested {\n            nested -= 1\n        }\n\n    \
    \    // If there is still a higher level than the current nested level, we keep\
    \ the current value.\n        if paren_string[nested] == '(' && open_char > nested\
    \ {\n            nested = open_char\n        }\n\n        // If the close bracket\
    \ has a lower level than the current nested level, we keep the current value.\n\
    \        if paren_string[nested] == '(' && close_char < nested {\n           \
    \ nested = close_char\n        }\n\n        // If the current nested level is\
    \ equal to the highest level found so far, increment it.\n        if paren_string[nested]\
    \ == ')' && close_char == nested {\n            nested += 1\n        }\n\n   \
    \     // If the current nested level is equal to the lowest level found so far,\
    \ decrement it.\n        if paren_string[nested] == '(' && open_char == nested\
    \ {\n            nested -= 1\n        }\n    }\n    return nested", "    var max_level\
    \ = 0\n    for level in paren_string.split(\" \") {\n        let level_ = Int(level)\n\
    \        if level_ > max_level {\n            max_level = level_\n        }\n\
    \    }\n    return Array(0 ..< max_level)", "    var paren_depth: Int = 0\n  \
    \  var max_level = 0\n    var paren_level = [Int]()\n    \n    paren_string.split{$0\
    \ == \" \"}.forEach { \n        let new_level = int(paren_level[paren_depth])\n\
    \        if new_level > max_level {\n            max_level = new_level\n     \
    \   }\n        paren_depth++\n        paren_level[paren_depth] = paren_depth\n\
    \    }\n    \n    return paren_level.map { ($0) }", "    var max_level: [Int]\
    \ = [0]\n    for i in 1..<paren_string.count {\n        var level = 0\n      \
    \  for j in 0..<paren_string.count {\n            if (paren_string[j] != paren_string[i])\
    \ {\n                break\n            }\n            level++\n        }\n  \
    \      max_level = max(max_level, level)\n    }\n    return max_level", "    var\
    \ depth = 0\n    var par: Int = 0\n    var par_string: String = paren_string\n\
    \n    for ch in par_string.unicodeScalars {\n        if ch.value == 0x28 {\n \
    \           depth += 1 // if we find a (, increase the depth count\n        }\
    \ else {\n            depth -= 1 // if we find a ), decrease the depth count\n\
    \            if depth == 0 {\n                par = par_string.unicodeScalars.index(ch)\n\
    \            }\n        }\n    }\n    return [par, par_string.unicodeScalars.count\
    \ - par]", "    debug_assert_eq!(paren_string.count(\"(\"), paren_string.count(\"\
    )\"))\n    let mut levels = [Int::new(); paren_string.count(\"(\")]\n    for i\
    \ in 0..paren_string.count(\"(\") {\n        let start = i\n        let end =\
    \ paren_string.count(\")\", start+1)\n        debug_assert!(end != 0)\n      \
    \  levels[i] = end - start\n    }\n\n    // start from right to left\n    for\
    \ level in levels.rt() {\n        let mut index = 0\n        for _ in 0..level\
    \ {\n            index = paren_string.rfind(\"(\", index) + 1\n        }\n   \
    \     levels[level] = index\n    }\n\n    return levels", "\tlet paren_stack =\
    \ paren_string.characters.split(separator: \" \").map({String($0)})\n\tvar levels\
    \ = [Int]()\n\tvar depth = 0\n\tfor paren_group in paren_stack {\n\t\tlet index\
    \ = paren_stack.index(of: paren_group)\n\t\tlet level = 0\n\t\tif index != nil\
    \ {\n\t\t\tlevel = paren_stack.index(of: paren_group[index!]) - index!\n\t\t}\n\
    \t\tdepth = max(depth, level)\n\t}\n\tlevels.append(depth)\n\treturn levels",
  "\tvar max_level = 0\n\tlevel_stack = Array(repeating: 0, count: paren_string.count)\n\
    \tparen_index = -1\n\tparen_counter = 0\n\tvar char_to_push = 0\n\tfor char in\
    \ paren_string {\n\t\tif char == '(' || char == '[' {\n\t\t\tlevel_stack[paren_index]\
    \ = paren_counter\n\t\t\tparen_counter += 1\n\t\t}\n\t\tif char == ')' || char\
    \ == ']' {\n\t\t\tparen_counter += 1\n\t\t\tif paren_counter > level_stack[paren_index]\
    \ {\n\t\t\t\tlevel_stack[paren_index] = paren_counter\n\t\t\t}\n\t\t}\n\t\tchar_to_push\
    \ = char\n\t}\n\tfor char in level_stack {\n\t\tif char > max_level {\n\t\t\t\
    max_level = char\n\t\t}\n\t}\n\treturn Array(repeating: max_level, count: level_stack.count)",
  "    let regex = \"\\\\(|\\\\)\".toRegex()\n    \n    let rangeOfString: NSRange\
    \ = paren_string.rangeOfString(regex, options: .CaseInsensitive)\n    \n    var\
    \ result = [Int]()\n    \n    if rangeOfString.length == 0 {\n        return nil\n\
    \    }\n    \n    for match in paren_string.matchesInString(paren_string, options:\
    \ .CaseInsensitive) {\n        let subString: String = paren_string.substringWithRange(match.range)\n\
    \        \n        if let groupCount: Int = subString.countByCharactingInSet(regex.invertedSet).max(),\
    \ groupCount > result.count {\n            result.removeAll(keepCapacity: true)\n\
    \        }\n        \n        result.insert((subString.countByCharactingInSet(regex.invertedSet)),\
    \ atIndex: result.count)\n    }\n    \n    return result", "\tlet paren_chars\
    \ = paren_string.characters\n\t\n\tvar count = 0\n\t\n\tvar level = 0\n\t\n\t\
    var level_start = 0\n\t\n\tvar level_end = 0\n\t\n\tvar open_braces = false //\
    \ whether we encountered an opening brace character yet\n\tvar close_braces =\
    \ false // whether we encountered a closing brace character yet\n\t\n\tvar prev_open_brace\
    \ = false // whether we encountered an opening brace character earlier\n\tvar\
    \ prev_close_brace = false // whether we encountered a closing brace character\
    \ earlier\n\t\n\tvar prev_char = \"\" // what character we last saw when we encoutered\
    \ a closing brace character\n\t\n\tvar i = 0\n\t\n\twhile i < paren_chars.count\
    \ {\n\t\tswitch paren_chars[i] {\n\t\tcase ')': // if we saw a closing brace,\
    \ set the closing brace level\n\t\t\tif close_braces {\n\t\t\t\tlevel--\n\t\t\t\
    }\n\t\t\tclose_braces = true\n\t\t\topen_braces = false\n\t\tcase '(':\n\t\t\t\
    if !open_braces {\n\t\t\t\tlevel++\n\t\t\t}\n\t\t\topen_braces = true\n\t\t\t\
    close_braces = false\n\t\tcase '}':\n\t\t\tif prev_open_brace {\n\t\t\t\tprev_char\
    \ = '}'\n\t\t\t\tlevel--\n\t\t\t}\n\t\t\topen_braces = false\n\t\t\tclose_braces\
    \ = true\n\t\tcase '{':\n\t\t\tif !open_braces {\n\t\t\t\tlevel++\n\t\t\t}\n\t\
    \t\topen_braces = true\n\t\t\tclose_braces = false\n\t\tcase ' ':\n\t\t\t// If\
    \ we encounter a space, it is the end of the current level.\n\t\t\tlevel++\n\t\
    \t\tlevel_end = i\n\t\tcase '\\t':\n\t\t\t// Ignore tabs\n\t\tdefault:\n\t\t\t\
    // We encountered a character we didn't recognize, so keep track of the current\
    \ level\n\t\t\tif open_braces {\n\t\t\t\tlevel--\n\t\t\t}\n\t\t\tprev_char = paren_chars[i]\n\
    \t\t\tlevel_start = i\n\t\t\tbreak\n\t\t}\n\t\t\n\t\t// If we are at the end of\
    \ a level, set the previous character and increment the level\n\t\tif level_end\
    \ == paren_chars.count {\n\t\t\tlevel--\n\t\t\tprev_char = paren_chars[i]\n\t\t\
    \tlevel_start = i + 1\n\t\t}\n\t\t\n\t\ti++\n\t}\n\t\n\t// We are at the end of\
    \ the string, so set the current level and level to 0\n\tif level_end < paren_chars.count\
    \ {\n\t\tlevel--\n\t\tprev_char = paren_chars[level_end]\n\t}\n\t\n\tlet result:\
    \ [Int] = [level]\n\t\n\t// We will never encounter a ", "    if paren_string.count\
    \ <= 1 {\n        return []\n    }\n\n    var max = 0\n    var result = [Int]()\n\
    \n    for _i in 0..<paren_string.count {\n        if paren_string[_i] == '(' {\n\
    \            max = max! + 1\n        }\n        else if paren_string[_i] == ')'\
    \ {\n            max = max! - 1\n        }\n\n        result.append(max)\n   \
    \ }\n\n    return result", "    let paren_array = paren_string.characters\n  \
    \      .enumerate()\n        .map { index, char in\n            switch char {\n\
    \            case '(':\n                let opening = paren_array[index + 1]\n\
    \                let closing = paren_array[index + 2]\n                return\
    \ max(opening as! Int, closing as! Int) + 1\n            case ')':\n         \
    \       let opening = paren_array[index + 1]\n                let closing = paren_array[index\
    \ + 2]\n                return max(opening as! Int, closing as! Int)\n       \
    \     default:\n                return 0\n            }\n        }\n    return\
    \ paren_array", "    paren_string = paren_string.trim()\n    paren_string = paren_string.dropLast()\n\
    \    var count = 0\n    var opening_bracket: Bool = false\n    var level = 0\n\
    \    var nested_count = [Int]()\n    for i in paren_string.indices(of: \" \")\
    \ {\n        if paren_string[i] != \"(\" {\n            nested_count[level] +=\
    \ 1\n        } else {\n            opening_bracket = true\n            level++\n\
    \        }\n    }\n\n    if level != 0 {\n        nested_count[level] += 1\n \
    \   }\n    if opening_bracket == false {\n        return 0\n    }\n\n    for parens\
    \ in 0..<level {\n        nested_count[parens] = 0\n    }\n\n    for i in 0..<nested_count.count\
    \ {\n        count += nested_count[i]\n    }\n\n    return count", "    let paren_groups\
    \ = paren_string.characters\n        .split{$0 == \"(\" || $0 == \"}\"}\n    \
    \    .map(String.init)\n    return paren_groups\n        .enumerated()\n     \
    \   .reduce([Int](), {$0 + [$1] + parse_nested_parens(paren_string: $1)})\n  \
    \      .reversed()\n        .map(String.init)", "    var levels = [Int]()\n  \
    \  var parens = 0\n    var open = 0\n    var close = 0\n    var last = 0\n   \
    \ for index, char in enumerate(paren_string) {\n        if char == \"(\" || char\
    \ == \"{\" || char == \"[\" {\n            open += 1\n            levels.append(Int((parens\
    \ - open)))\n        } else if char == \")\" || char == \"}\" || char == \"]\"\
    \ {\n            levels[last - close] += 1\n            close += 1\n        }\n\
    \        if char == \")\" {\n            last = index\n        }\n    }\n    return\
    \ levels", "    // First find the largest level of nesting\n    var level = 1\n\
    \    var max_level = 1\n    for level in 1...paren_string.count{\n        level_chars\
    \ := paren_string[level]\n        if level_chars == '(' || level_chars == '{'\
    \ || level_chars == '[' {\n            max_level = level\n        }\n    }\n\n\
    \    // Now traverse the string and count the level of nesting\n    var level_count\
    \ : [Int] = [Int](repeating: 0, count: max_level+1)\n    for level in 1...paren_string.count{\n\
    \        level_chars := paren_string[level]\n        if level_chars == '(' ||\
    \ level_chars == '{' || level_chars == '[' {\n            level_count[level] +=\
    \ 1\n        }\n    }\n\n    // Return the level of nesting\n    return level_count",
  "    var result = [Int]()\n    for s in paren_string.split(\" \") {\n        guard\
    \ let int = s.toInt(), int > 0 && int != 0 else { return result }\n        result.append(int)\n\
    \    }\n    return result", "    if paren_string.count < 1 {\n        return []\n\
    \    }\n\n    // The maximum nesting level of any substring is\n    // the length\
    \ of the string minus the substring length\n    let max_level = (paren_string.count\
    \ - paren_string.characters.count) / 2\n    // The deepest level of nesting is\
    \ the maximum between\n    // the deepest level of each pair of nested parentheses\n\
    \    let max_level = min(max_level, parse_nested_parens_helper(paren_string, 0))\n\
    \    return Array(0 ..< max_level)", "    var level = 0\n    var levels = [Int]()\n\
    \    for paren in paren_string.characters {\n        if paren == \")\" {\n   \
    \         levels[level - 1] += 1\n        }\n        level = 0\n        if paren\
    \ != \"(\" {\n            level += 1\n        }\n        levels.append(level)\n\
    \    }\n    return levels"]
stop_tokens:
- "\n}"
