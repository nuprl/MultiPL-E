language: swift
name: HumanEval_21_rescale_to_unit
results:
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var sum: Double = 0\n    for number in numbers {\n      \
    \  sum += number\n    }\n    var scaled: [Double] = []\n    for number in numbers\
    \ {\n        scaled.append(number / sum)\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp8vwn0vmg/tmp8vwn0vmg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b12cc803c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b12cc4fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b12cc4fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b12cc4f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8vwn0vmg                        0x000055c8df9e5603 <unavailable> + 5635

    5    libc.so.6                          0x00002b12cc9ef460 __libc_start_main +
    245

    6    tmp8vwn0vmg                        0x000055c8df9e5209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // Find min and max\n    let maxValue = numbers.max()\n \
    \   let minValue = numbers.min()\n\n    // Apply linear transformation to array\n\
    \    var scaledNumbers = [Double]()\n    for i in 0..<numbers.count {\n      \
    \  let originalNumber = numbers[i]\n        let scaledNumber = originalNumber\
    \ - minValue\n        scaledNumbers.append(scaledNumber)\n    }\n\n    // Return\
    \ scaled array\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6wyn4fpn.swift:15:45: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        let scaledNumber = originalNumber\
    \ - minValue\n                                            ^\n/tmp/tmp6wyn4fpn.swift:9:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let minValue = numbers.min()\n        ^\n    guard\
    \                        else { return <#default value#> }\n/tmp/tmp6wyn4fpn.swift:9:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let minValue = numbers.min()\n                           ^\n    \
    \                             ?? <#default value#>\n/tmp/tmp6wyn4fpn.swift:9:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let minValue = numbers.min()\n                           ^\n    \
    \                            !\n/tmp/tmp6wyn4fpn.swift:15:45: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        let\
    \ scaledNumber = originalNumber - minValue\n                                 \
    \           ^\n                                            (        ?? <#default\
    \ value#>)\n/tmp/tmp6wyn4fpn.swift:15:45: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        let scaledNumber = originalNumber\
    \ - minValue\n                                            ^\n                \
    \                                    !\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map(numbers) { number in\n        number / min(number,\
    \ 1.0)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgw8mxrqy.swift:7:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers) { number in\n           ^~~\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    let minNum = numbers.min()\n\
    \    let maxNum = numbers.max()\n\n    var currentMin: Double = 0.0\n    var currentMax:\
    \ Double = 1.0\n\n    for i in 0..<numbers.count {\n        currentMin = currentMin\n\
    \        currentMax = currentMax\n\n        if numbers[i] < minNum {\n       \
    \     currentMin = minNum\n        }\n\n        if numbers[i] > maxNum {\n   \
    \         currentMax = maxNum\n        }\n\n        rescaled[i] = currentMin +\
    \ (numbers[i] - currentMin) * (currentMax - currentMin) / (currentMax - currentMin)\n\
    \    }\n\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6iejpw4b.swift:15:20: error: assigning a variable to itself\n \
    \       currentMin = currentMin\n        ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp6iejpw4b.swift:16:20:\
    \ error: assigning a variable to itself\n        currentMax = currentMax\n   \
    \     ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp6iejpw4b.swift:18:25: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n        if numbers[i]\
    \ < minNum {\n                        ^\n/tmp/tmp6iejpw4b.swift:18:25: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if numbers[i] < minNum {\n                        ^\n                  \
    \             ?? <#default value#>\n/tmp/tmp6iejpw4b.swift:18:25: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ numbers[i] < minNum {\n                        ^\n                         \
    \     !\n/tmp/tmp6iejpw4b.swift:19:26: error: value of optional type 'Double?'\
    \ must be unwrapped to a value of type 'Double'\n            currentMin = minNum\n\
    \                         ^\n/tmp/tmp6iejpw4b.swift:19:26: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \   currentMin = minNum\n                         ^\n                        \
    \        ?? <#default value#>\n/tmp/tmp6iejpw4b.swift:19:26: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    currentMin = minNum\n                         ^\n                       \
    \        !\n/tmp/tmp6iejpw4b.swift:22:25: error: value of optional type 'Double?'\
    \ must be unwrapped to a value of type 'Double'\n        if numbers[i] > maxNum\
    \ {\n                        ^\n/tmp/tmp6iejpw4b.swift:22:25: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        if\
    \ numbers[i] > maxNum {\n                        ^\n                         \
    \      ?? <#default value#>\n/tmp/tmp6iejpw4b.swift:22:25: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ numbers[i] > maxNum {\n                "
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.count == 1 {\n        return numbers + [0.0]\n\
    \    }\n\n    // Calculate the mean and standard deviation of the input numbers\n\
    \    let mean = numbers.reduce(0, +) / Double(numbers.count)\n    let std = numbers.map{$0.powi(2)\
    \ - mean.powi(2)}.max()\n    return numbers + [Double(std) * 0.5]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphidvx0fd.swift:13:30: error: value of type 'Double' has no member\
    \ 'powi'\n    let std = numbers.map{$0.powi(2) - mean.powi(2)}.max()\n       \
    \                   ~~ ^~~~\n/tmp/tmphidvx0fd.swift:13:45: error: value of type\
    \ 'Double' has no member 'powi'\n    let std = numbers.map{$0.powi(2) - mean.powi(2)}.max()\n\
    \                                       ~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { Double(min(1.0, max(0.0, $0))) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpiwwvr_2e/tmpiwwvr_2e.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2f634ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2f6045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2f6045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2f60447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiwwvr_2e                        0x000055f27938b623 <unavailable> + 5667

    5    libc.so.6                          0x00002ac2f653a460 __libc_start_main +
    245

    6    tmpiwwvr_2e                        0x000055f27938b229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let max_value = max(numbers)\n    let min_value = min(numbers)\n\
    \    var scaled = numbers\n    for i in 0..<numbers.count {\n        scaled[i]\
    \ = scaled[i] / (max_value - min_value)\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp78fa90u5.swift:7:32: error: missing argument for parameter #2 in\
    \ call\n    let max_value = max(numbers)\n                               ^\n \
    \                              , <#[Double]#>\nSwift.max:1:24: note: 'max' declared\
    \ here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp78fa90u5.swift:8:32: error: missing argument\
    \ for parameter #2 in call\n    let min_value = min(numbers)\n               \
    \                ^\n                               , <#[Double]#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmp78fa90u5.swift:11:31:\
    \ error: binary operator '/' cannot be applied to operands of type 'Double' and\
    \ 'Duration'\n        scaled[i] = scaled[i] / (max_value - min_value)\n      \
    \              ~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp78fa90u5.swift:11:31:\
    \ note: overloads for '/' exist with these partially matching parameter lists:\
    \ (Double, Double), (Duration, Duration)\n        scaled[i] = scaled[i] / (max_value\
    \ - min_value)\n                              ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ scaled: [Double] = []\n    for n in numbers {\n        scaled.append((n - min)\
    \ / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4fuyvdf_.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp4fuyvdf_.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for x in numbers {\n   \
    \     let scaledX = min(max(x, Double(0.0)), Double(1.0))\n        rescaled.append(scaledX)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpugkm9sgn/tmpugkm9sgn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b485a205c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4859efcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4859efc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4859efb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpugkm9sgn                        0x0000555bc38426f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b485a3f1460 __libc_start_main +
    245

    6    tmpugkm9sgn                        0x0000555bc38422f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaledNumbers = [Double](repeating: 0.0, count: numbers.count)\n\
    \n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double =\
    \ Double.lowestFiniteMagnitude\n\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n\n    for number in numbers\
    \ {\n        rescaledNumbers[numbers.index(where: { $0 >= min && $0 <= max })]\
    \ = number\n    }\n\n    return rescaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppparyzfm.swift:10:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppparyzfm.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmppparyzfm.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmppparyzfm.swift:18:33:\
    \ error: value of optional type 'Array<Double>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Double>.Index' (aka 'Int')\n        rescaledNumbers[numbers.index(where:\
    \ { $0 >= min && $0 <= max })] = number\n                                ^\n/tmp/tmppparyzfm.swift:18:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        rescaledNumbers[numbers.index(where: { $0 >= min && $0 <= max\
    \ })] = number\n                                ^\n                          \
    \                                               ?? <#default value#>\n/tmp/tmppparyzfm.swift:18:33:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        rescaledNumbers[numbers.index(where: { $0 >= min && $0 <= max\
    \ })] = number\n                                ^\n                          \
    \                                              !\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scale = 1.0\n    for number in numbers {\n        scale\
    \ *= (number + 1.0) / 2.0\n    }\n    return numbers.map { $0 / scale }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpwya9vzaf/tmpwya9vzaf.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c62974c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c6266bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c6266b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c6266a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwya9vzaf                        0x0000558ad18ac613 <unavailable> + 5651

    5    libc.so.6                          0x00002b8c62b60460 __libc_start_main +
    245

    6    tmpwya9vzaf                        0x0000558ad18ac219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty() {\n        return numbers\n    }\n \
    \   var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < min {\n            min = numbers[i]\n\
    \        } else if numbers[i] > max {\n            max = numbers[i]\n        }\n\
    \    }\n    var scale: Double = 1.0 / (max - min)\n    return numbers.map { $0\
    \ * scale }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmptjezp2_v.swift:7:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if numbers.isEmpty() {\n               ^      ~~\n             \
    \         \n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var max: Double = 0\n    var min: Double = Double.max\n \
    \   for number in numbers {\n        max = max(max, number)\n        min = min(min,\
    \ number)\n    }\n    let min = min(min, 0)\n    let max = max(max, 1)\n    var\
    \ scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpi99qt6al.swift:8:30: error: type 'Double' has no member 'max'\n\
    \    var min: Double = Double.max\n                      ~~~~~~ ^~~\n/tmp/tmpi99qt6al.swift:10:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpi99qt6al.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpi99qt6al.swift:13:15: error: cannot call value of non-function type\
    \ 'Double'\n    let min = min(min, 0)\n              ^\n/tmp/tmpi99qt6al.swift:14:15:\
    \ error: cannot call value of non-function type 'Double'\n    let max = max(max,\
    \ 1)\n              ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty { return numbers }\n    let min = min(numbers)\n\
    \    let max = max(numbers)\n    var rescaled: [Double] = []\n    for i in numbers\
    \ {\n        let ratio = (i - min) / (max - min)\n        rescaled.append(ratio)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3g6haqg3.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp3g6haqg3.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.count == 0 || numbers.count == 1 {\n        return\
    \ numbers\n    }\n\n    var scaled = [Double]()\n    var min: Double?\n    var\
    \ max: Double?\n\n    for number in numbers {\n        if min == nil || number\
    \ < min {\n            min = number\n        }\n\n        if max == nil || number\
    \ > max {\n            max = number\n        }\n    }\n\n    if max == nil {\n\
    \        return scaled\n    }\n\n    if min == nil {\n        return scaled\n\
    \    }\n\n    var first: Double?\n    var second: Double?\n\n    for number in\
    \ numbers {\n        if first == nil {\n            first = number\n        }\
    \ else {\n            if number >= first {\n                second--\n       \
    \     } else {\n                second++\n            }\n        }\n\n       \
    \ scaled.append(Double(number) - Double(first) * Double(second) / Double(max -\
    \ min))\n    }\n\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmrmhv3b_.swift:16:35: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        if min == nil || number <\
    \ min {\n                                  ^\n/tmp/tmpmrmhv3b_.swift:16:35: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if min == nil || number < min {\n                                  ^\n\
    \                                      ?? <#default value#>\n/tmp/tmpmrmhv3b_.swift:16:35:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if min == nil || number < min {\n                           \
    \       ^\n                                     !\n/tmp/tmpmrmhv3b_.swift:20:35:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        if max == nil || number > max {\n                        \
    \          ^\n/tmp/tmpmrmhv3b_.swift:20:35: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        if max == nil || number\
    \ > max {\n                                  ^\n                             \
    \         ?? <#default value#>\n/tmp/tmpmrmhv3b_.swift:20:35: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ max == nil || number > max {\n                                  ^\n        \
    \                             !\n/tmp/tmpmrmhv3b_.swift:40:26: error: value of\
    \ optional type 'Double?' must be unwrapped to a value of type 'Double'\n    \
    \        if number >= first {\n                         ^\n/tmp/tmpmrmhv3b_.swift:40:26:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            if number >= first {\n                         ^\n      \
    \                         ?? <#default value#>\n/tmp/tmpmrmhv3b_.swift:40:26:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            if number >= first {\n                         ^\n      \
    \                        !\n/tmp/tmpmrmhv3b_.swift:41:23: error: cannot find operator\
    \ '--' in scope; did you mean '-= 1"
  stdout: ''
  timestamp: 1660013991
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        largest = number if number > largest else\
    \ largest\n        smallest = number if number < smallest else smallest\n    }\n\
    \    var scalingFactor = 1.0 / (largest - smallest)\n    var result = [Double]()\n\
    \    for number in numbers {\n        result.append(scalingFactor * number)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpp63ednwq.swift:10:25: error: consecutive statements on a line must\
    \ be separated by ';'\n        largest = number if number > largest else largest\n\
    \                        ^\n                        ;\n/tmp/tmpp63ednwq.swift:10:46:\
    \ error: unexpected 'else' immediately following 'if' condition\n        largest\
    \ = number if number > largest else largest\n                                \
    \             ^\n/tmp/tmpp63ednwq.swift:10:46: note: remove 'else' to execute\
    \ the braced block of statements when the condition is true\n        largest =\
    \ number if number > largest else largest\n                                  \
    \           ^~~~~\n                                             \n/tmp/tmpp63ednwq.swift:10:51:\
    \ error: expected '{' after 'if' condition\n        largest = number if number\
    \ > largest else largest\n                                                  ^\n\
    /tmp/tmpp63ednwq.swift:11:48: error: unexpected 'else' immediately following 'if'\
    \ condition\n        smallest = number if number < smallest else smallest\n  \
    \                                             ^\n/tmp/tmpp63ednwq.swift:11:48:\
    \ note: remove 'else' to execute the braced block of statements when the condition\
    \ is true\n        smallest = number if number < smallest else smallest\n    \
    \                                           ^~~~~\n                          \
    \                     \n/tmp/tmpp63ednwq.swift:11:53: error: expected '{' after\
    \ 'if' condition\n        smallest = number if number < smallest else smallest\n\
    \                                                    ^\n/tmp/tmpp63ednwq.swift:7:9:\
    \ warning: variable 'smallest' was never mutated; consider changing to 'let' constant\n\
    \    var smallest = numbers[0]\n    ~~~ ^\n    let\n/tmp/tmpp63ednwq.swift:13:9:\
    \ warning: variable 'scalingFactor' was never mutated; consider changing to 'let'\
    \ constant\n    var scalingFactor = 1.0 / (largest - smallest)\n    ~~~ ^\n  \
    \  let\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers: [Double] = []\n    for num in numbers\
    \ {\n        let offset = min(abs(num), 1.0)\n        scaledNumbers.append(num\
    \ - offset)\n    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpavqd43ge/tmpavqd43ge.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2dd5e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2dd2dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2dd2df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2dd2de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpavqd43ge                        0x000056246751e743 <unavailable> + 5955

    5    libc.so.6                          0x00002af2dd7d4460 __libc_start_main +
    245

    6    tmpavqd43ge                        0x000056246751e349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n  var min: Double?\n  var max: Double?\n  numbers.forEach { number\
    \ in\n    if min == nil || number < min {\n      min = number\n    }\n    if max\
    \ == nil || number > max {\n      max = number\n    }\n  }\n\n  var scale: Double?\n\
    \  if let min = min {\n    scale = Double(max - min) / (numbers.count - 1)\n \
    \ }\n  if let max = max {\n    return Array(numbers.map { $0 / (scale ?? 1.0)\
    \ + min })\n  } else {\n    return numbers\n  }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpupoyc1q_.swift:10:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    if min == nil || number < min\
    \ {\n                              ^\n/tmp/tmpupoyc1q_.swift:10:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ if min == nil || number < min {\n                              ^\n         \
    \                         ?? <#default value#>\n/tmp/tmpupoyc1q_.swift:10:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if min == nil || number < min {\n                              ^\n\
    \                                 !\n/tmp/tmpupoyc1q_.swift:20:48: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Double'\n    scale =\
    \ Double(max - min) / (numbers.count - 1)\n                                  \
    \             ^\n                                Double(            )\n/tmp/tmpupoyc1q_.swift:20:20:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    scale = Double(max - min) / (numbers.count - 1)\n            \
    \       ^\n/tmp/tmpupoyc1q_.swift:20:20: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    scale = Double(max - min)\
    \ / (numbers.count - 1)\n                   ^\n                   (   ?? <#default\
    \ value#>)\n/tmp/tmpupoyc1q_.swift:20:20: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    scale = Double(max - min)\
    \ / (numbers.count - 1)\n                   ^\n                      !\n/tmp/tmpupoyc1q_.swift:23:54:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    return Array(numbers.map { $0 / (scale ?? 1.0) + min })\n    \
    \                                                 ^\n/tmp/tmpupoyc1q_.swift:23:54:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return Array(numbers.map { $0 / (scale ?? 1.0) + min })\n       \
    \                                              ^\n                           \
    \                      "
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map({ (value) in\n        let scale = min(max(0.0,\
    \ value), 1)\n        return Double(scale) / Double(max(0.0, value))\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpaqff5fcq/tmpaqff5fcq.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b387f6a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b387f397b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b387f397988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b387f3967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaqff5fcq                        0x000055e753b43623 <unavailable> + 5667

    5    libc.so.6                          0x00002b387f88c460 __libc_start_main +
    245

    6    tmpaqff5fcq                        0x000055e753b43229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n\tswitch numbers.count {\n\tcase 1:\n\t\treturn [numbers[0]]\n\
    \tcase 2:\n\t\tif numbers[0] < numbers[1] {\n\t\t\treturn [numbers[0]]\n\t\t}\n\
    \t\treturn [numbers[1]]\n\tcase 3:\n\t\tif numbers[0] < numbers[1] && numbers[1]\
    \ < numbers[2] {\n\t\t\treturn [numbers[0]]\n\t\t}\n\t\treturn [numbers[1]]\n\t\
    case 4:\n\t\tif numbers[0] < numbers[1] && numbers[1] < numbers[2] && numbers[2]\
    \ < numbers[3] {\n\t\t\treturn [numbers[0]]\n\t\t}\n\t\treturn [numbers[1]]\n\t\
    case 5:\n\t\tif numbers[0] < numbers[1] && numbers[1] < numbers[2] && numbers[2]\
    \ < numbers[3] && numbers[3] < numbers[4] {\n\t\t\treturn [numbers[0]]\n\t\t}\n\
    \t\treturn [numbers[1]]\n\tdefault:\n\t\tpreconditionFailure(\"Too many arguments\"\
    )\n\t}\n\treturn [numbers[0]]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpj12t2r9_/tmpj12t2r9_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba78cda9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba78caa0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba78caa0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba78ca9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj12t2r9_                        0x000055597acf6573 <unavailable> + 5491

    5    libc.so.6                          0x00002ba78cf95460 __libc_start_main +
    245

    6    tmpj12t2r9_                        0x000055597acf6179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var maxValue = 0.0\n    var minValue = 100000000.0\n    for\
    \ value in numbers {\n        if value > maxValue {\n            maxValue = value\n\
    \        } else if value < minValue {\n            minValue = value\n        }\n\
    \    }\n    var rescaledNumbers = [Double](repeating: 0, count: numbers.count)\n\
    \    for value in numbers {\n        let offset = (value - minValue) / (maxValue\
    \ - minValue)\n        rescaledNumbers[numbers.index(value, offset)]++\n    }\n\
    \    return rescaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9s_4w_5b.swift:19:54: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        rescaledNumbers[numbers.index(value, offset)]++\n\
    \                                                     ^~\n/tmp/tmp9s_4w_5b.swift:19:25:\
    \ error: instance method 'index(_:offsetBy:)' requires that 'Double' conform to\
    \ 'BinaryInteger'\n        rescaledNumbers[numbers.index(value, offset)]++\n \
    \                       ^\nSwift.Collection:3:17: note: where 'T' = 'Double'\n\
    \    public func index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where\
    \ T : BinaryInteger\n                ^\n/tmp/tmp9s_4w_5b.swift:19:38: error: missing\
    \ argument label 'offsetBy:' in call\n        rescaledNumbers[numbers.index(value,\
    \ offset)]++\n                                     ^\n                       \
    \                      offsetBy: \n/tmp/tmp9s_4w_5b.swift:19:39: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Array<Double>.Index'\
    \ (aka 'Int')\n        rescaledNumbers[numbers.index(value, offset)]++\n     \
    \                                 ^\n                                      Array<Double>.Index(\
    \ )\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min_val = min(numbers)\n    let max_val = max(numbers)\n\
    \    var result = [Double]()\n    for n in numbers {\n        result.append((n\
    \ - min_val) / (max_val - min_val))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp789zwg78.swift:7:30: error: missing argument for parameter #2 in\
    \ call\n    let min_val = min(numbers)\n                             ^\n     \
    \                        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp789zwg78.swift:8:30: error: missing argument\
    \ for parameter #2 in call\n    let max_val = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { 1 / $0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpyouj00hf/tmpyouj00hf.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b48e7e63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48e7b5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48e7b5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48e7b597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyouj00hf                        0x0000561b278734e3 <unavailable> + 5347

    5    libc.so.6                          0x00002b48e804f460 __libc_start_main +
    245

    6    tmpyouj00hf                        0x0000561b278730e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ min = numbers[0]\n    var max = numbers[0]\n    for number in numbers {\n  \
    \      if number < min {\n            min = number\n        } else if number >\
    \ max {\n            max = number\n        }\n    }\n    var result = [Double]()\n\
    \    for number in numbers {\n        result.append(min + ((number - min) / (max\
    \ - min) * (numbers.count - 1)))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjt9xjv8e.swift:19:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        result.append(min + ((number - min) / (max - min) *\
    \ (numbers.count - 1)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014012
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // sort by absolute value so we can normalize the array without\
    \ having to use abs\n    var sortedNumbers = numbers\n    sortedNumbers.sort(by:\
    \ { abs($0) < abs($1) })\n\n    // scale to the [0,1] range and round the final\
    \ result\n    var rescaledNumbers = sortedNumbers.map { $0 / (1.0 + abs($0)) }\n\
    \    return rescaledNumbers.map { round(100 * $0) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpii2fvadb.swift:13:34: error: cannot find 'round' in scope\n   \
    \ return rescaledNumbers.map { round(100 * $0) }\n                           \
    \      ^~~~~\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.count < 2 { return numbers }\n    var min: Double?\
    \ = nil\n    var max: Double? = nil\n    for number in numbers {\n        if number\
    \ < min { min = number }\n        if number > max { max = number }\n    }\n  \
    \  guard min != nil && max != nil else { return numbers }\n    return [min! /\
    \ max!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx23nhwqb.swift:11:21: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        if number < min { min = number\
    \ }\n                    ^\n/tmp/tmpx23nhwqb.swift:11:21: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        if\
    \ number < min { min = number }\n                    ^\n                     \
    \   ?? <#default value#>\n/tmp/tmpx23nhwqb.swift:11:21: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        if number\
    \ < min { min = number }\n                    ^\n                       !\n/tmp/tmpx23nhwqb.swift:12:21:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        if number > max { max = number }\n                    ^\n\
    /tmp/tmpx23nhwqb.swift:12:21: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        if number > max { max = number }\n\
    \                    ^\n                        ?? <#default value#>\n/tmp/tmpx23nhwqb.swift:12:21:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if number > max { max = number }\n                    ^\n   \
    \                    !\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ minValue = numbers[0]\n    var maxValue = numbers[0]\n    var sum = 0\n    var\
    \ prevSum = 0\n    for value in numbers {\n        sum += value\n        if value\
    \ > maxValue {\n            maxValue = value\n        }\n        if value < minValue\
    \ {\n            minValue = value\n        }\n        if sum == 0 {\n        \
    \    prevSum = value\n        }\n    }\n    if sum != 0 {\n        return Array(numbers.map\
    \ { Double(prevSum / sum) * $0 + Double($1 - prevSum) / sum })\n    }\n    return\
    \ numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmptarsz4ys.swift:13:16: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        sum += value\n               ^\n  \
    \             Int( )\n/tmp/tmptarsz4ys.swift:21:23: error: cannot assign value\
    \ of type 'Double' to type 'Int'\n            prevSum = value\n              \
    \        ^~~~~\n                      Int( )\n/tmp/tmptarsz4ys.swift:25:16: error:\
    \ the compiler is unable to type-check this expression in reasonable time; try\
    \ breaking up the expression into distinct sub-expressions\n        return Array(numbers.map\
    \ { Double(prevSum / sum) * $0 + Double($1 - prevSum) / sum })\n             \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014022
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n\n    let\
    \ maxNumber = max(numbers)\n    let minNumber = min(numbers)\n\n    var rescaledNumbers\
    \ = [Double]()\n    for i in 0..<numbers.count {\n        let value = numbers[i]\n\
    \        rescaledNumbers.append(value / maxNumber)\n    }\n    return rescaledNumbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp69pu8i2u.swift:9:32: error: missing argument for parameter #2 in\
    \ call\n    let maxNumber = max(numbers)\n                               ^\n \
    \                              , <#[Double]#>\nSwift.max:1:24: note: 'max' declared\
    \ here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp69pu8i2u.swift:10:32: error: missing argument\
    \ for parameter #2 in call\n    let minNumber = min(numbers)\n               \
    \                ^\n                               , <#[Double]#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var max_number = numbers[0]\n    var min_number = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_number {\n    \
    \        max_number = numbers[i]\n        }\n        if numbers[i] < min_number\
    \ {\n            min_number = numbers[i]\n        }\n    }\n    return [Double(min_number)\
    \ - Double(min_number) == 0 ? 0 : Double(max_number) - Double(min_number) * Double(numbers.count\
    \ - 1)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpc79w7lzi/tmpc79w7lzi.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adca6068c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adca5d5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adca5d5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adca5d5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc79w7lzi                        0x0000559b2e9736c3 <unavailable> + 5827

    5    libc.so.6                          0x00002adca6254460 __libc_start_main +
    245

    6    tmpc79w7lzi                        0x0000559b2e9732c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { $0 /min(numbers.map { abs($0) }).min()\
    \ + 0.5 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8p9p5846.swift:7:28: error: consecutive statements on a line must\
    \ be separated by ';'\n    return numbers.map { $0 /min(numbers.map { abs($0)\
    \ }).min() + 0.5 }\n                           ^\n                           ;\n\
    /tmp/tmp8p9p5846.swift:7:29: error: '/' is not a prefix unary operator\n    return\
    \ numbers.map { $0 /min(numbers.map { abs($0) }).min() + 0.5 }\n             \
    \               ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var max: Double = 0\n    var min: Double = 1000000000\n \
    \   for n in numbers {\n        max = max(max, n)\n        min = min(min, n)\n\
    \    }\n    if min == 0 {\n        return [1.0]\n    }\n    var scaled = Array(repeating:\
    \ 0.0, count: numbers.count)\n    for i in 0..<numbers.count {\n        scaled[i]\
    \ = numbers[i] - min\n        scaled[i] = scaled[i] * (max - min) / (max - min)\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp2o9n0f37.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        max = max(max, n)\n              ^\n/tmp/tmp2o9n0f37.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        min = min(min,\
    \ n)\n              ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var smallest = Double.MaxValue\n    var largest = Double.MinValue\n\
    \n    for number in numbers {\n        smallest = number < smallest ? number :\
    \ smallest\n        largest = number > largest ? number : largest\n    }\n\n \
    \   return [((largest-smallest)/(numbers.count-1)), ...numbers]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpp_kn9a4w.swift:7:27: error: type 'Double' has no member 'MaxValue'\n\
    \    var smallest = Double.MaxValue\n                   ~~~~~~ ^~~~~~~~\n/tmp/tmpp_kn9a4w.swift:8:26:\
    \ error: type 'Double' has no member 'MinValue'\n    var largest = Double.MinValue\n\
    \                  ~~~~~~ ^~~~~~~~\n/tmp/tmpp_kn9a4w.swift:15:53: error: cannot\
    \ convert value of type 'PartialRangeThrough<[Double]>' to expected element type\
    \ 'Double'\n    return [((largest-smallest)/(numbers.count-1)), ...numbers]\n\
    \                                                    ^\n/tmp/tmpp_kn9a4w.swift:15:32:\
    \ error: cannot convert value of type 'Duration' to expected element type 'Double'\n\
    \    return [((largest-smallest)/(numbers.count-1)), ...numbers]\n           \
    \                    ^\n/tmp/tmpp_kn9a4w.swift:15:53: error: referencing operator\
    \ function '...' on 'Comparable' requires that '[Double]' conform to 'Comparable'\n\
    \    return [((largest-smallest)/(numbers.count-1)), ...numbers]\n           \
    \                                         ^\nSwift.Comparable:1:11: note: where\
    \ 'Self' = '[Double]'\nextension Comparable {\n          ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled_numbers = [Double]()\n    guard numbers.count\
    \ > 1 else { return rescaled_numbers }\n    let min_val = min(numbers)\n    let\
    \ max_val = max(numbers)\n    for i in 0..<numbers.count {\n        rescaled_numbers.append(numbers[i]/max_val-min_val/min_val)\n\
    \    }\n    return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpus8_hiw2.swift:9:30: error: missing argument for parameter #2 in\
    \ call\n    let min_val = min(numbers)\n                             ^\n     \
    \                        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpus8_hiw2.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let max_val = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmpus8_hiw2.swift:12:26: error:\
    \ no exact matches in call to instance method 'append'\n        rescaled_numbers.append(numbers[i]/max_val-min_val/min_val)\n\
    \                         ^\n/tmp/tmpus8_hiw2.swift:12:26: note: found candidate\
    \ with type '(__owned _) -> ()'\n        rescaled_numbers.append(numbers[i]/max_val-min_val/min_val)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double(numbers[0])\n    var max: Double\
    \ = Double(numbers[0])\n    for value in numbers {\n        if value < min {\n\
    \            min = value\n        } else if value > max {\n            max = value\n\
    \        }\n    }\n\n    // The difference between min and max will give us the\
    \ scale we need for the new numbers\n    let scale: Double = max - min\n\n   \
    \ // Apply scale to the numbers\n    var output: [Double] = []\n    for value\
    \ in numbers {\n        // The scaled value\n        let scaledValue = value *\
    \ scale\n        output.append(scaledValue)\n    }\n\n    return output\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp248hhwqd/tmp248hhwqd.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff42eaac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff42ba1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff42ba1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff42ba07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp248hhwqd                        0x00005599c4d9e6a3 <unavailable> + 5795

    5    libc.so.6                          0x00002aff43096460 __libc_start_main +
    245

    6    tmp248hhwqd                        0x00005599c4d9e2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let range = numbers.max() - numbers.min()\n    return numbers.map\
    \ { $0 / (range + 1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpe1f4ij_i.swift:7:31: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    let range = numbers.max() - numbers.min()\n \
    \               ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpe1f4ij_i.swift:7:31: note:\
    \ overloads for '-' exist with these partially matching parameter lists: (Double,\
    \ Double)\n    let range = numbers.max() - numbers.min()\n                   \
    \           ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = numbers.min()\n    let max = numbers.max()\n  \
    \  let scale: Double = max - min\n    let scaled: [Double] = numbers.map { Double($0)\
    \ / scale }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuann1gyf.swift:9:25: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let scale: Double = max - min\n\
    \                        ^\n/tmp/tmpuann1gyf.swift:8:9: note: short-circuit using\
    \ 'guard' to exit this function early if the optional value contains 'nil'\n \
    \   let max = numbers.max()\n        ^\n    guard                   else { return\
    \ <#default value#> }\n/tmp/tmpuann1gyf.swift:8:23: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    let max = numbers.max()\n\
    \                      ^\n                            ?? <#default value#>\n/tmp/tmpuann1gyf.swift:8:23:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max = numbers.max()\n                      ^\n              \
    \             !\n/tmp/tmpuann1gyf.swift:9:25: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let scale: Double = max\
    \ - min\n                        ^\n                        (   ?? <#default value#>)\n\
    /tmp/tmpuann1gyf.swift:9:25: note: force-unwrap using '!' to abort execution if\
    \ the optional value contains 'nil'\n    let scale: Double = max - min\n     \
    \                   ^\n                           !\n/tmp/tmpuann1gyf.swift:9:31:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    let scale: Double = max - min\n                              ^\n\
    /tmp/tmpuann1gyf.swift:7:9: note: short-circuit using 'guard' to exit this function\
    \ early if the optional value contains 'nil'\n    let min = numbers.min()\n  \
    \      ^\n    guard                   else { return <#default value#> }\n/tmp/tmpuann1gyf.swift:7:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let min = numbers.min()\n                      ^\n              \
    \              ?? <#default value#>\n/tmp/tmpuann1gyf.swift:7:23: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let min\
    \ = numbers.min()\n                      ^\n                 "
  stdout: ''
  timestamp: 1660013969
- exit_code: 0
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    \n    // Get minimum and maximum values\n    var minValue:\
    \ Double = Double(Int.max)\n    var maxValue: Double = Double(Int.min)\n    for\
    \ number in numbers {\n        if number < minValue {\n            minValue =\
    \ number\n        }\n        if number > maxValue {\n            maxValue = number\n\
    \        }\n    }\n    \n    // Get scale factor between minimum and maximum values\n\
    \    var scaleFactor: Double = maxValue - minValue\n    \n    // Calculate transformed\
    \ values\n    var transformedValues: [Double] = []\n    for number in numbers\
    \ {\n        let transformedNumber = (number - minValue) / scaleFactor\n     \
    \   transformedValues.append(transformedNumber)\n    }\n    \n    return transformedValues\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013969
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var max = Double(0)\n    var min = Double(0)\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\
    \ else if number < min {\n            min = number\n        }\n    }\n\n    let\
    \ scale = max - min\n    let shift = Double(-1 * (min / scale))\n    let results:\
    \ [Double] = numbers.map { $0 - shift }\n    return results\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpkg2ls67v/tmpkg2ls67v.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea2a52bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea2a222b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea2a222988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea2a2217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkg2ls67v                        0x0000557a31045663 <unavailable> + 5731

    5    libc.so.6                          0x00002aea2a717460 __libc_start_main +
    245

    6    tmpkg2ls67v                        0x0000557a31045269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let max = numbers.max()\n    let min = numbers.min()\n\n\
    \    // Handle edge cases\n    if min == 0.0 {\n        return [0.0]\n    } else\
    \ if max == 0.0 {\n        return ([1.0] + numbers[1..<numbers.count]).map { Double($0)\
    \ }\n    }\n\n    // Handle zero\n    if min == max {\n        if numbers[0] ==\
    \ 0.0 {\n            return []\n        } else {\n            return [0]\n   \
    \     }\n    }\n\n    // Compute delta\n    let delta = max - min\n\n    // Perform\
    \ transform\n    return (0.0 - min) / delta + numbers.map { Double($0) * Double(delta)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0,\
    \ 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0,\
    \ 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25,\
    \ 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0])\
    \ == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0,\
    \ 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxajmcnf3.swift:27:21: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    let delta = max - min\n                ~~~ ^\
    \ ~~~\n/tmp/tmpxajmcnf3.swift:27:21: note: overloads for '-' exist with these\
    \ partially matching parameter lists: (Double, Double)\n    let delta = max -\
    \ min\n                    ^\n/tmp/tmpxajmcnf3.swift:30:12: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n    return (0.0 - min) / delta\
    \ + numbers.map { Double($0) * Double(delta) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013997
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var smallest = min(numbers)\n    var largest = max(numbers)\n\
    \    var size = largest-smallest\n    var factor = 1.0/size\n    var result =\
    \ [Double](repeating: 0.0, count: numbers.count)\n    for number in numbers {\n\
    \        result[numbers.index(of: number)] = number*factor\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8jfboai9.swift:7:31: error: missing argument for parameter #2 in\
    \ call\n    var smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp8jfboai9.swift:8:30: error: missing argument\
    \ for parameter #2 in call\n    var largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmp8jfboai9.swift:13:24: error:\
    \ value of optional type 'Array<Double>.Index?' (aka 'Optional<Int>') must be\
    \ unwrapped to a value of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number*factor\n                       ^\n/tmp/tmp8jfboai9.swift:13:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number*factor\n         \
    \              ^\n                                         ?? <#default value#>\n\
    /tmp/tmp8jfboai9.swift:13:24: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        result[numbers.index(of: number)]\
    \ = number*factor\n                       ^\n                                \
    \        !\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.count < 2 {\n        return numbers\n    }\n \
    \   var smallest = numbers[0]\n    var largest = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        switch numbers[i] {\n        case smallest {\n            largest\
    \ = i\n            break\n        }\n        case largest {\n            smallest\
    \ = i\n            break\n        }\n    }\n    let scale = (largest - smallest)\
    \ / (numbers.count - 1)\n    var result = [Double]()\n    for i in 1..<numbers.count\
    \ {\n        result.append(scale * (numbers[i] - smallest))\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8_3vxpsn.swift:17:10: error: expected ':' after 'case'\n      \
    \  }\n         ^\n/tmp/tmp8_3vxpsn.swift:21:10: error: expected ':' after 'case'\n\
    \        }\n         ^\n/tmp/tmp8_3vxpsn.swift:48:96: error: expected '}' at end\
    \ of brace statement\nassert(rescale_to_unit(numbers: [12.0, 11.0, 15.0, 13.0,\
    \ 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\n                                   \
    \                                                            ^\n/tmp/tmp8_3vxpsn.swift:6:53:\
    \ note: to match this opening '{'\nfunc rescale_to_unit(numbers: [Double]) ->\
    \ [Double] {\n                                                    ^\n/tmp/tmp8_3vxpsn.swift:14:14:\
    \ error: cannot call value of non-function type 'Double'\n        case smallest\
    \ {\n             ^\n/tmp/tmp8_3vxpsn.swift:15:23: error: cannot assign value\
    \ of type 'Int' to type 'Double'\n            largest = i\n                  \
    \    ^\n                      Double( )\n/tmp/tmp8_3vxpsn.swift:18:14: error:\
    \ cannot call value of non-function type 'Double'\n        case largest {\n  \
    \           ^\n/tmp/tmp8_3vxpsn.swift:19:24: error: cannot assign value of type\
    \ 'Int' to type 'Double'\n            smallest = i\n                       ^\n\
    \                       Double( )\n/tmp/tmp8_3vxpsn.swift:23:38: error: binary\
    \ operator '/' cannot be applied to operands of type 'Double' and 'Int'\n    let\
    \ scale = (largest - smallest) / (numbers.count - 1)\n                ~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8_3vxpsn.swift:23:38: note: overloads for '/'\
    \ exist with these partially matching parameter lists: (Double, Double), (Int,\
    \ Int)\n    let scale = (largest - smallest) / (numbers.count - 1)\n         \
    \                            ^\n/tmp/tmp8_3vxpsn.swift:32:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // If less than two elements, just return the array\n   \
    \ if numbers.count < 2 {\n        return numbers\n    }\n\n    // Find min and\
    \ max element\n    var minimum = numbers[0]\n    var maximum = numbers[0]\n  \
    \  for number in numbers {\n        if number < minimum {\n            minimum\
    \ = number\n        }\n        if number > maximum {\n            maximum = number\n\
    \        }\n    }\n\n    // Calculate scale and return\n    return map(numbers)\
    \ { (number) -> Double in\n        let normalized = (number - minimum) / Double(maximum\
    \ - minimum)\n        return normalized.rounded(.up) / Double(maximum - minimum)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpw0rwp8n3.swift:25:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers) { (number) -> Double in\n           ^~~\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty {\n        return []\n    }\n    var max\
    \ = numbers.min()\n    var min = numbers.max()\n    if max - min < 0.001 {\n \
    \       return [Double(max)]\n    }\n    var normalized = [Double]()\n    for\
    \ i in numbers {\n        normalized.append(Double(i)/Double(max-min))\n    }\n\
    \    return normalized\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp554dtd_p.swift:12:12: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    if max - min < 0.001 {\n       ~~~ ^ ~~~\n/tmp/tmp554dtd_p.swift:12:12:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double)\n    if max - min < 0.001 {\n           ^\n/tmp/tmp554dtd_p.swift:13:24:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return [Double(max)]\n                       ^\n/tmp/tmp554dtd_p.swift:13:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return [Double(max)]\n                       ^\n            \
    \               ?? <#default value#>\n/tmp/tmp554dtd_p.swift:13:24: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        return\
    \ [Double(max)]\n                       ^\n                          !\n/tmp/tmp554dtd_p.swift:17:44:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        normalized.append(Double(i)/Double(max-min))\n           \
    \                                ^\n/tmp/tmp554dtd_p.swift:17:44: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     normalized.append(Double(i)/Double(max-min))\n                         \
    \                  ^\n                                           (   ?? <#default\
    \ value#>)\n/tmp/tmp554dtd_p.swift:17:44: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        normalized.append(Double(i)/Double(max-min))\n\
    \                                           ^\n                              \
    \                !\n/tmp/tmp554dtd_p.swift:17:48: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n        normalized.append(Double(i)/Double(max-min))\n\
    \                                               ^\n/tmp/tmp554dtd_p.swift:17:48:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        normalized.append(Double(i)/Double(max-min))\n         "
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let minValue = numbers.min()\n    let maxValue = numbers.max()\n\
    \    let range = (maxValue - minValue).reciprocal()\n    let scaledNumbers = numbers.map\
    \ { $0.roundTo(places: 0).multiplying(by: range) + minValue }\n    return scaledNumbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpywrju2jt.swift:9:27: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    let range = (maxValue - minValue).reciprocal()\n\
    \                 ~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpywrju2jt.swift:9:27: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double)\n\
    \    let range = (maxValue - minValue).reciprocal()\n                        \
    \  ^\n/tmp/tmpywrju2jt.swift:9:39: error: value of type 'Double' has no member\
    \ 'reciprocal'\n    let range = (maxValue - minValue).reciprocal()\n         \
    \       ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpywrju2jt.swift:10:42: error:\
    \ value of type 'Double' has no member 'roundTo'\n    let scaledNumbers = numbers.map\
    \ { $0.roundTo(places: 0).multiplying(by: range) + minValue }\n              \
    \                        ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map(numbers) { x / min(1.0+abs(x), 1.0) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpemj3l8f5.swift:7:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers) { x / min(1.0+abs(x), 1.0) }\n           ^~~\n/tmp/tmpemj3l8f5.swift:7:27:\
    \ error: cannot find 'x' in scope\n    return map(numbers) { x / min(1.0+abs(x),\
    \ 1.0) }\n                          ^\n/tmp/tmpemj3l8f5.swift:7:43: error: cannot\
    \ find 'x' in scope\n    return map(numbers) { x / min(1.0+abs(x), 1.0) }\n  \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var result: [Double] = []\n    numbers.forEach { number in\n\
    \        let min = min(numbers)\n        let max = max(numbers)\n        result.append(number\
    \ - min)\n        result.append(1.0 / max(max - min, 1))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjj30oxis.swift:9:30: error: missing argument for parameter #2 in\
    \ call\n        let min = min(numbers)\n                             ^\n     \
    \                        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpjj30oxis.swift:9:19: error: global function\
    \ 'min' requires that '[Double]' conform to 'Comparable'\n        let min = min(numbers)\n\
    \                  ^\nSwift.min:1:24: note: where 'T' = '[Double]'\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    let\
    \ scale = max - min\n    let result = numbers.map { $0 - min / scale }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp61srhxkd.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp61srhxkd.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp61srhxkd.swift:10:35: error: binary operator '-'\
    \ cannot be applied to operands of type 'Double' and 'Duration'\n    let result\
    \ = numbers.map { $0 - min / scale }\n                               ~~ ^ ~~~~~~~~~~~\n\
    /tmp/tmp61srhxkd.swift:10:35: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (ContinuousClock.Instant, Duration), (Double, Double),\
    \ (Duration, Duration), (SuspendingClock.Instant, Duration)\n    let result =\
    \ numbers.map { $0 - min / scale }\n                                  ^\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let minValue = numbers.min()\n    let maxValue = numbers.max()\n\
    \n    var normalizedNumbers = [Double]()\n    for number in numbers {\n      \
    \  let normalizedNumber = number - minValue\n        normalizedNumbers.append(normalizedNumber)\n\
    \    }\n\n    var sum = 0\n    for number in normalizedNumbers {\n        sum\
    \ += number\n    }\n\n    for number in normalizedNumbers {\n        normalizedNumbers.append(number\
    \ / sum)\n    }\n\n    return normalizedNumbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzl15v78f.swift:12:41: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        let normalizedNumber = number\
    \ - minValue\n                                        ^\n/tmp/tmpzl15v78f.swift:7:9:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n    let minValue = numbers.min()\n        ^\n    guard\
    \                        else { return <#default value#> }\n/tmp/tmpzl15v78f.swift:7:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let minValue = numbers.min()\n                           ^\n    \
    \                             ?? <#default value#>\n/tmp/tmpzl15v78f.swift:7:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let minValue = numbers.min()\n                           ^\n    \
    \                            !\n/tmp/tmpzl15v78f.swift:12:41: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        let\
    \ normalizedNumber = number - minValue\n                                     \
    \   ^\n                                        (        ?? <#default value#>)\n\
    /tmp/tmpzl15v78f.swift:12:41: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let normalizedNumber = number\
    \ - minValue\n                                        ^\n                    \
    \                            !\n/tmp/tmpzl15v78f.swift:18:16: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        sum += number\n\
    \               ^\n               Int(  )\n/tmp/tmpzl15v78f.swift:22:43: error:\
    \ cannot convert value of type 'Int' to expected argument type 'Double'\n    \
    \    normalizedNumbers.append(number / sum)\n                                \
    \          ^\n                                          Double( )\n"
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    var rescaled = [Double]()\n\
    \    for n in numbers {\n        rescaled.append(n - min / max - min / max * n)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjj5jh54p.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpjj5jh54p.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpjj5jh54p.swift:12:51: error: cannot convert value\
    \ of type 'Duration' to expected argument type 'Double'\n        rescaled.append(n\
    \ - min / max - min / max * n)\n                                             \
    \     ^\n/tmp/tmpjj5jh54p.swift:12:27: error: binary operator '-' cannot be applied\
    \ to operands of type 'Double' and 'Duration'\n        rescaled.append(n - min\
    \ / max - min / max * n)\n                        ~ ^ ~~~~~~~~~\n/tmp/tmpjj5jh54p.swift:12:27:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (ContinuousClock.Instant, Duration), (Double, Double), (Duration, Duration),\
    \ (SuspendingClock.Instant, Duration)\n        rescaled.append(n - min / max -\
    \ min / max * n)\n                          ^\n/tmp/tmpjj5jh54p.swift:12:18: error:\
    \ no exact matches in call to instance method 'append'\n        rescaled.append(n\
    \ - min / max - min / max * n)\n                 ^\n/tmp/tmpjj5jh54p.swift:12:18:\
    \ note: found candidate with type '(__owned Double) -> ()'\n        rescaled.append(n\
    \ - min / max - min / max * n)\n                 ^\n/tmp/tmpjj5jh54p.swift:12:18:\
    \ note: found candidate with type '(__owned ContinuousClock.Instant) -> ()'\n\
    \        rescaled.append(n - min / max - min / max * n)\n                 ^\n\
    /tmp/tmpjj5jh54p.swift:12:45: error: cannot convert value of type 'Duration' to\
    \ expected argument type 'Double'\n        rescaled.append(n - min / max - min\
    \ / max * n)\n                      "
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n\tguard numbers.count >= 2 else {\n\t\tfatalError(\"Invalid numbers\"\
    )\n\t}\n\tlet min = min(numbers)\n\tlet max = max(numbers)\n\treturn map(numbers)\
    \ { number in\n\t\tnumber - min / max - min / max\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc0393oto.swift:10:23: error: missing argument for parameter #2\
    \ in call\n        let min = min(numbers)\n                             ^\n  \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpc0393oto.swift:11:23: error: missing argument\
    \ for parameter #2 in call\n        let max = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmpc0393oto.swift:12:9: error:\
    \ cannot find 'map' in scope\n        return map(numbers) { number in\n      \
    \         ^~~\n"
  stdout: ''
  timestamp: 1660013975
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    assert(numbers.count > 1)\n    var min = numbers[0]\n   \
    \ var max = numbers[0]\n    for number in numbers {\n        if number < min {\n\
    \            min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    let interval = (max - min) / 2\n    var newNumbers\
    \ = [Double]()\n    for i in 0..<numbers.count {\n        let number = numbers[i]\n\
    \        newNumbers.append(number * interval)\n    }\n    return newNumbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpm_h9lkuu/tmpm_h9lkuu.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b00f9666c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00f935db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00f935d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00f935c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm_h9lkuu                        0x000056218fa5d883 <unavailable> + 6275

    5    libc.so.6                          0x00002b00f9852460 __libc_start_main +
    245

    6    tmpm_h9lkuu                        0x000056218fa5d489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var newNumbers = numbers.map { $0 }\n    newNumbers.sort()\n\
    \    guard newNumbers.count > 1 && newNumbers.last > newNumbers.first else {\n\
    \        return newNumbers\n    }\n\n    guard let newLast = Double(newNumbers.last),\
    \ let newFirst = Double(newNumbers.first) else {\n        return newNumbers\n\
    \    }\n\n    if newLast == newFirst {\n        return newNumbers\n    }\n\n \
    \   let range = newLast - newFirst\n    newNumbers.forEach() {\n        let newVal\
    \ = $0 - newFirst\n        if newVal > range {\n            newVal -= range\n\
    \        } else if newVal < -range {\n            newVal += range\n        }\n\
    \        $0 = newVal\n    }\n\n    return newNumbers\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3jw0pivj.swift:9:64: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    guard newNumbers.count > 1 &&\
    \ newNumbers.last > newNumbers.first else {\n                                \
    \                               ^\n/tmp/tmp3jw0pivj.swift:9:64: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ guard newNumbers.count > 1 && newNumbers.last > newNumbers.first else {\n  \
    \                                                             ^\n            \
    \                                                         ?? <#default value#>\n\
    /tmp/tmp3jw0pivj.swift:9:64: note: force-unwrap using '!' to abort execution if\
    \ the optional value contains 'nil'\n    guard newNumbers.count > 1 && newNumbers.last\
    \ > newNumbers.first else {\n                                                \
    \               ^\n                                                          \
    \          !\n/tmp/tmp3jw0pivj.swift:9:46: error: value of optional type 'Double?'\
    \ must be unwrapped to a value of type 'Double'\n    guard newNumbers.count >\
    \ 1 && newNumbers.last > newNumbers.first else {\n                           \
    \                  ^\n/tmp/tmp3jw0pivj.swift:9:46: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    guard newNumbers.count\
    \ > 1 && newNumbers.last > newNumbers.first else {\n                         \
    \                    ^\n                                                  ?? <#default\
    \ value#>\n/tmp/tmp3jw0pivj.swift:9:46: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    guard newNumbers.count >\
    \ 1 && newNumbers.last > newNumbers.first else {\n                           \
    \                  ^\n                                                 !\n/tmp/tmp3jw0pivj.swift:13:25:\
    \ error: type '((Double) throws -> Bool) throws -> Double?' cannot conform to\
    \ 'StringProtocol'\n    guard let newLast = Double(newNumbers.last), let newFirst\
    \ = Double(newNumbers.first) else {\n                        ^\n/tmp/tmp3jw0pivj.swift:13:25:\
    \ note: only "
  stdout: ''
  timestamp: 1660013969
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var largest = Double(max(numbers))\n    var smallest = Double(min(numbers))\n\
    \    var scaled: [Double] = []\n    for i in 0..<numbers.count {\n        scaled.append(Double(numbers[i])\
    \ / largest)\n        largest = Double(max(scaled.count))\n    }\n    if smallest\
    \ != 0.0 {\n        for i in 0..<numbers.count {\n            scaled.append(Double(numbers[i])\
    \ / smallest)\n            smallest = Double(min(scaled.count))\n        }\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprxiio13l.swift:7:37: error: missing argument for parameter #2 in\
    \ call\n    var largest = Double(max(numbers))\n                             \
    \       ^\n                                    , <#Substring#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmprxiio13l.swift:8:38:\
    \ error: missing argument for parameter #2 in call\n    var smallest = Double(min(numbers))\n\
    \                                     ^\n                                    \
    \ , <#Substring#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmprxiio13l.swift:12:42: error: missing argument for parameter #2\
    \ in call\n        largest = Double(max(scaled.count))\n                     \
    \                    ^\n                                         , <#Int#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmprxiio13l.swift:17:47:\
    \ error: missing argument for parameter #2 in call\n            smallest = Double(min(scaled.count))\n\
    \                                              ^\n                           \
    \                   , <#Int#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    return\
    \ numbers.map { $0 / (max - min) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpspelgz6w.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpspelgz6w.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count >= 2 else {\n        return []\n    }\n\
    \    var result = numbers[0]\n    for i in 1..<numbers.count {\n        if result-i\
    \ > 0.001 {\n            result = (result + numbers[i]) / 2\n        } else {\n\
    \            result = numbers[i]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppj8fgc68.swift:12:19: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        if result-i > 0.001 {\n        \
    \          ^\n                  Double( )\n/tmp/tmppj8fgc68.swift:18:12: error:\
    \ cannot convert return expression of type 'Double' to return type '[Double]'\n\
    \    return result\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double.infinity\n    var max = Double.infinity\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n\n    var normalized = [Double](repeating: 0, count: numbers.count)\n \
    \   if min < 0 {\n        for number in numbers {\n            if number > 0 {\n\
    \                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (max - min)\n            } else {\n\
    \                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (1 - min)\n            }\n      \
    \  }\n    } else {\n        for number in numbers {\n            if number < 0\
    \ {\n                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (min - max)\n            } else {\n\
    \                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (max - min)\n            }\n    \
    \    }\n    }\n    return normalized\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb2e28b68.swift:22:50: error: value of type 'Int' has no member\
    \ 'advancedBy'\n                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (max - min)\n                   \
    \        ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb2e28b68.swift:22:92: error:\
    \ type '(Int) -> Int' cannot conform to 'FloatingPoint'\n                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (max - min)\n                   \
    \                                                                        ^\n/tmp/tmpb2e28b68.swift:22:92:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (max - min)\n                   \
    \                                                                        ^\n/tmp/tmpb2e28b68.swift:22:92:\
    \ note: required by referencing operator function '+' on 'FloatingPoint' where\
    \ 'Self' = '(Int) -> Int'\n                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (max - min)\n                   \
    \                                                                        ^\n/tmp/tmpb2e28b68.swift:24:50:\
    \ error: value of type 'Int' has no member 'advancedBy'\n                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (1 - min)\n                     \
    \      ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb2e28b68.swift:24:92: error:\
    \ type '(Int) -> Int' cannot conform to 'FloatingPoint'\n                normalized[normalized.startIndex.advancedBy(normalized.startIndex.distance\
    \ + numbers.startIndex.distance)] = number / (1 - min)\n                     \
    \                                                                      ^\n/tmp/tmpb2e28b68.swift:24:92:\
    \ note: only concrete types such as structs, enums and clas"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled = [Double]()\n    for i in 0..<numbers.count\
    \ {\n        let scaled = min(1.0, numbers[i]/numbers[numbers.count - 1])\n  \
    \      rescaled.append(scaled)\n    }\n    return rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpi75eqcuk/tmpi75eqcuk.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba9413b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba9410acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba9410ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba9410ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi75eqcuk                        0x0000560b6b36a7b3 <unavailable> + 6067

    5    libc.so.6                          0x00002ba9415a1460 __libc_start_main +
    245

    6    tmpi75eqcuk                        0x0000560b6b36a3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    assert(numbers.count >= 2)\n    \n    let length = numbers.count\n\
    \    var smallest_number = numbers[0]\n    var largest_number = numbers[0]\n \
    \   for i in 1..length {\n        if smallest_number > numbers[i] {\n        \
    \    smallest_number = numbers[i]\n        }\n        if largest_number < numbers[i]\
    \ {\n            largest_number = numbers[i]\n        }\n    }\n    let fraction\
    \ = (largest_number - smallest_number).reciprocal()\n    var result = [Double](repeating:\
    \ 0.0, count: length)\n    \n    for i in 0..<length {\n        result[i] = numbers[i]\
    \ * fraction\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmph__pq_jv.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..length {\n              ^~\n          \
    \    ...\n/tmp/tmph__pq_jv.swift:20:55: error: value of type 'Double' has no member\
    \ 'reciprocal'\n    let fraction = (largest_number - smallest_number).reciprocal()\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty { return [] }\n    let min = min(numbers)\n\
    \    let max = max(numbers)\n    let step = (max - min) / Double(numbers.count)\n\
    \    var numbers2 = numbers.map { $0 - min }\n    return numbers.map { (double)\
    \ -> Double in\n        let val = double / step + min\n        let result = val\n\
    \        return result < 0 ? 0 : result > 1 ? 1 : result\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkwlffq7d.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpkwlffq7d.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map(numbers, { number in\n        if number < 0 {\n\
    \            return number / 0\n        } else {\n            return 1.0\n   \
    \     }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5sv2epo8.swift:7:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers, { number in\n           ^~~\n/tmp/tmp5sv2epo8.swift:11:20: error:\
    \ cannot convert return expression of type 'Double' to return type 'Int'\n   \
    \         return 1.0\n                   ^~~\n                   Int( )\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { $0 - min(numbers)/max(numbers) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl152tdw4.swift:7:42: error: missing argument for parameter #2 in\
    \ call\n    return numbers.map { $0 - min(numbers)/max(numbers) }\n          \
    \                               ^\n                                         ,\
    \ <#Double#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public func\
    \ min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n\
    /tmp/tmpl152tdw4.swift:7:55: error: missing argument for parameter #2 in call\n\
    \    return numbers.map { $0 - min(numbers)/max(numbers) }\n                 \
    \                                     ^\n                                    \
    \                  , <#Double#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map2(numbers, 0.0, 1.0, 0.0, Double.max)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_uxtimbj.swift:7:12: error: cannot find 'map2' in scope\n    return\
    \ map2(numbers, 0.0, 1.0, 0.0, Double.max)\n           ^~~~\n/tmp/tmp_uxtimbj.swift:7:48:\
    \ error: type 'Double' has no member 'max'\n    return map2(numbers, 0.0, 1.0,\
    \ 0.0, Double.max)\n                                        ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count >= 2 else {\n        return numbers\n\
    \    }\n    var result = numbers[0]\n    numbers.forEach {\n        if it > result\
    \ {\n            result = it\n        }\n    }\n    return Array(numbers.map {\
    \ result + (it - result) / numbers.count })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmptvjbuibe.swift:12:12: error: cannot find 'it' in scope\n      \
    \  if it > result {\n           ^~\n/tmp/tmptvjbuibe.swift:13:22: error: cannot\
    \ find 'it' in scope\n            result = it\n                     ^~\n/tmp/tmptvjbuibe.swift:16:42:\
    \ error: cannot find 'it' in scope\n    return Array(numbers.map { result + (it\
    \ - result) / numbers.count })\n                                         ^~\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled_numbers = [Double]()\n    var i = 0\n    let\
    \ min = numbers[0]\n    let max = numbers[0]\n    for number in numbers {\n  \
    \      rescaled_numbers.append(number - min)\n        rescaled_numbers.append(number\
    \ - max)\n        min = min(number, min)\n        max = max(number, max)\n   \
    \ }\n    return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpir_n18iw.swift:14:9: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n        min = min(number, min)\n        ^~~\n/tmp/tmpir_n18iw.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmpir_n18iw.swift:14:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(number, min)\n              ^\n/tmp/tmpir_n18iw.swift:15:9:\
    \ error: cannot assign to value: 'max' is a 'let' constant\n        max = max(number,\
    \ max)\n        ^~~\n/tmp/tmpir_n18iw.swift:10:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let max = numbers[0]\n    ^~~\n    var\n/tmp/tmpir_n18iw.swift:15:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(number,\
    \ max)\n              ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count >= 2 else { return numbers }\n    var\
    \ normalized = numbers.map { $0 / 2.0 }\n    var smallest: Double = normalized[0]\n\
    \    var largest: Double = normalized[0]\n    for n in normalized {\n        if\
    \ n < smallest { smallest = n }\n        if n > largest { largest = n }\n    }\n\
    \    normalized = normalized.map { $0 - smallest }\n    normalized = normalized.map\
    \ { $1 / largest }\n    return normalized\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5s5qsqo7.swift:16:33: error: contextual closure type '(Double)\
    \ throws -> Double' expects 1 argument, but 2 were used in closure body\n    normalized\
    \ = normalized.map { $1 / largest }\n                                ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count >= 2 else {\n        return []\n    }\n\
    \n    var result: [Double] = []\n    var min: Double = Double(numbers[0])\n  \
    \  var max: Double = Double(numbers[0])\n    for n in numbers {\n        min =\
    \ (n < min) ? n : min\n        max = (n > max) ? n : max\n    }\n\n    for n in\
    \ numbers {\n        result.append(n / max - min)\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpakgj50_h/tmpakgj50_h.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c20463c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c2015ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c2015a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c201597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpakgj50_h                        0x000055945d045703 <unavailable> + 5891

    5    libc.so.6                          0x00002b0c2064f460 __libc_start_main +
    245

    6    tmpakgj50_h                        0x000055945d045309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let maxValue = numbers.max()!\n    var result = numbers.map\
    \ { $0 / maxValue }\n    if result.isEmpty {\n        return result\n    }\n\n\
    \    // If the input values are all different, result will be\n    // [0.0, 1.0,\
    \ ..., 0.0]. Replace any zeros with an appropriate value\n    let minValue = result.min()!\n\
    \    var index = result.index(of: minValue)\n    if index == result.endIndex {\n\
    \        index = 0\n    }\n    result[index] = maxValue\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpofxlfet5.swift:16:24: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    var index = result.index(of: minValue)\n         \
    \              ^\n/tmp/tmpofxlfet5.swift:16:24: note: use 'firstIndex(of:)' instead\n\
    \    var index = result.index(of: minValue)\n                       ^~~~~\n  \
    \                     firstIndex\n/tmp/tmpofxlfet5.swift:20:12: error: value of\
    \ optional type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped\
    \ to a value of type 'Array<Double>.Index' (aka 'Int')\n    result[index] = maxValue\n\
    \           ^\n/tmp/tmpofxlfet5.swift:20:12: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    result[index] = maxValue\n\
    \           ^\n                 ?? <#default value#>\n/tmp/tmpofxlfet5.swift:20:12:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    result[index] = maxValue\n           ^\n                !\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers.first!)\n    var max = Double(numbers.last!)\n\
    \    for number in numbers {\n        guard number > max else { max = number;\
    \ continue}\n        guard number < min else { min = number; continue}\n    }\n\
    \    var result = [Double]()\n    for number in numbers {\n        guard number\
    \ > min && number < max else { continue }\n        result.append ((number - min)\
    \ / (max - min))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp3neez2y7/tmp3neez2y7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d8875ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d88455b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d88455988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d884547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3neez2y7                        0x0000562f5b8cf833 <unavailable> + 6195

    5    libc.so.6                          0x00002b6d8894a460 __libc_start_main +
    245

    6    tmp3neez2y7                        0x0000562f5b8cf439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { number -> Double in\n        let scaled:\
    \ Double = number / numbers.min()\n        return scaled\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1rl7zlgd.swift:8:47: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        let scaled: Double = number\
    \ / numbers.min()\n                                              ^\n/tmp/tmp1rl7zlgd.swift:8:47:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let scaled: Double = number / numbers.min()\n               \
    \                               ^\n                                      (   \
    \          ?? <#default value#>)\n/tmp/tmp1rl7zlgd.swift:8:47: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        let\
    \ scaled: Double = number / numbers.min()\n                                  \
    \            ^\n                                                   !\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map{ x / min(numbers) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4_49ykz9.swift:7:25: error: cannot find 'x' in scope\n    return\
    \ numbers.map{ x / min(numbers) }\n                        ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // Calculate range from min to max\n    let range = (numbers.min()\
    \ + numbers.max()) / 2\n    // Calculate min and max values\n    let minValue\
    \ = numbers.min()\n    let maxValue = numbers.max()\n    // Map between min and\
    \ max\n    let mappedValue = (minValue + (maxValue - minValue) * range) / range\n\
    \    // Scale the mapped min and max values\n    return numbers.map { mappedValue\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0,\
    \ 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0,\
    \ 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25,\
    \ 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0])\
    \ == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0,\
    \ 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpygkjqidk.swift:8:32: error: binary operator '+' cannot be applied\
    \ to two 'Double?' operands\n    let range = (numbers.min() + numbers.max()) /\
    \ 2\n                 ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpygkjqidk.swift:8:32:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Double, Double)\n    let range = (numbers.min() + numbers.max()) / 2\n    \
    \                           ^\n/tmp/tmpygkjqidk.swift:13:45: error: binary operator\
    \ '-' cannot be applied to two 'Double?' operands\n    let mappedValue = (minValue\
    \ + (maxValue - minValue) * range) / range\n                                 \
    \  ~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpygkjqidk.swift:13:45: note: overloads for '-'\
    \ exist with these partially matching parameter lists: (Double, Double)\n    let\
    \ mappedValue = (minValue + (maxValue - minValue) * range) / range\n         \
    \                                   ^\n/tmp/tmpygkjqidk.swift:15:24: error: contextual\
    \ type for closure argument list expects 1 argument, which cannot be implicitly\
    \ ignored\n    return numbers.map { mappedValue }\n                       ^\n\
    \                         _ in\n"
  stdout: ''
  timestamp: 1660013976
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    \n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    let range = max - min\n    let newNumbers = [Double](repeating: 0.0, count:\
    \ numbers.count)\n    \n    for i in 0..<numbers.count {\n        newNumbers[i]\
    \ = ((numbers[i] - min) / range)\n    }\n    \n    return newNumbers\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzs309n6a.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpzs309n6a.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpzs309n6a.swift:14:19: error: cannot assign through\
    \ subscript: 'newNumbers' is a 'let' constant\n        newNumbers[i] = ((numbers[i]\
    \ - min) / range)\n        ~~~~~~~~~~^\n/tmp/tmpzs309n6a.swift:11:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let newNumbers = [Double](repeating:\
    \ 0.0, count: numbers.count)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty { return [] }\n    guard numbers.count\
    \ > 1 else { return numbers }\n    var min = numbers[0]\n    var max = numbers[0]\n\
    \    for number in numbers {\n        if number < min { min = number }\n     \
    \   if number > max { max = number }\n    }\n    let newMin = 0.0\n    let newMax\
    \ = 1.0\n    var newNumbers: [Double] = []\n    for number in numbers {\n    \
    \    let scale = (newMax - newMin) / (number - min)\n        newNumbers.append(scale\
    \ * (number - min) + newMin)\n    }\n    return newNumbers\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpptg7m00n/tmpptg7m00n.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1109bffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11098f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11098f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11098f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpptg7m00n                        0x0000559938760703 <unavailable> + 5891

    5    libc.so.6                          0x00002b1109deb460 __libc_start_main +
    245

    6    tmpptg7m00n                        0x0000559938760309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { $0 / min(numbers) - 1.0 }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8wi3ezsj.swift:7:42: error: missing argument for parameter #2 in\
    \ call\n    return numbers.map { $0 / min(numbers) - 1.0 }\n                 \
    \                        ^\n                                         , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp8wi3ezsj.swift:7:35:\
    \ error: cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \    return numbers.map { $0 / min(numbers) - 1.0 }\n                        \
    \          ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double.leastNormalMagnitude\n    var max = Double.greatestNormalMagnitude\n\
    \    for i in numbers {\n        min = min(min, i)\n        max = max(max, i)\n\
    \    }\n    var result = numbers\n    for i in numbers {\n        result[i] =\
    \ Double((i - min) / (max - min))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxyw4v79a.swift:8:22: error: type 'Double' has no member 'greatestNormalMagnitude'\n\
    \    var max = Double.greatestNormalMagnitude\n              ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxyw4v79a.swift:10:15: error: cannot call value of non-function type 'Double'\n\
    \        min = min(min, i)\n              ^\n/tmp/tmpxyw4v79a.swift:15:16: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    result[i] = Double((i - min) / (max - min))\n               ^\n         \
    \      Int( )\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n\t\n\tvar rescaled: [Double] = []\n\t\n\tfor i in numbers {\n\
    \t\t\n\t\tif i >= 0 {\n\t\t\t\n\t\t\trescaled.append(i)\n\t\t}\n\t\telse {\n\t\
    \t\t\n\t\t\trescaled.append(-i)\n\t\t}\n\t}\n\t\n\treturn rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpbiz_aq5z/tmpbiz_aq5z.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52170c1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5216db8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5216db8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5216db77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbiz_aq5z                        0x000055c5929c7603 <unavailable> + 5635

    5    libc.so.6                          0x00002b52172ad460 __libc_start_main +
    245

    6    tmpbiz_aq5z                        0x000055c5929c7209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    assert(numbers.count >= 2)\n    let min = min(numbers)\n\
    \    let max = max(numbers)\n    var scale: Double\n    if min == max {\n    \
    \    scale = 0.0\n    } else {\n        scale = 1.0 / min(max, min)\n    }\n \
    \   let output = numbers.map { $0 * scale }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp658yy0aj.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp658yy0aj.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return [1.0] }\n\n    var\
    \ min = Double(numbers[0])\n    var max = Double(numbers[0])\n\n    for i in 1..<numbers.count\
    \ {\n        min = min(numbers[i], min)\n        max = max(numbers[i], max)\n\
    \    }\n\n    var min = Double(min / 2.0)\n    var max = Double(max / 2.0)\n \
    \   var diff = (max - min) / (numbers.count - 1)\n\n    var result = numbers.map\
    \ { value -> Double in\n        return (value - min) / diff\n    }\n\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpny64f4zj.swift:13:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(numbers[i], min)\n              ^\n/tmp/tmpny64f4zj.swift:14:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(numbers[i],\
    \ max)\n              ^\n/tmp/tmpny64f4zj.swift:17:9: error: invalid redeclaration\
    \ of 'min'\n    var min = Double(min / 2.0)\n        ^\n/tmp/tmpny64f4zj.swift:9:9:\
    \ note: 'min' previously declared here\n    var min = Double(numbers[0])\n   \
    \     ^\n/tmp/tmpny64f4zj.swift:18:9: error: invalid redeclaration of 'max'\n\
    \    var max = Double(max / 2.0)\n        ^\n/tmp/tmpny64f4zj.swift:10:9: note:\
    \ 'max' previously declared here\n    var max = Double(numbers[0])\n        ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.count < 2 {\n        return numbers\n    }\n \
    \   let min = numbers[0]\n    let max = numbers[0]\n    for number in numbers\
    \ {\n        if number < min {\n            min = number\n        }\n        if\
    \ number > max {\n            max = number\n        }\n    }\n    return numbers.map({\
    \ $0 / (max - min) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_gixbbu1.swift:14:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = number\n            ^~~\n/tmp/tmp_gixbbu1.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmp_gixbbu1.swift:17:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = number\n            ^~~\n/tmp/tmp_gixbbu1.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let sum = numbers.reduce(0.0, {$0 + $1})\n    var scaled:\
    \ [Double] = []\n    for i in numbers {\n        scaled.append(i/sum)\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpujl9ux1y/tmpujl9ux1y.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b839bec1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b839bbb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b839bbb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b839bbb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpujl9ux1y                        0x00005558b0850673 <unavailable> + 5747

    5    libc.so.6                          0x00002b839c0ad460 __libc_start_main +
    245

    6    tmpujl9ux1y                        0x00005558b0850279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { $0 / min(numbers, {$1 > $1})}\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsvv4yq4_.swift:7:29: error: binary operator '/' cannot be applied\
    \ to operands of type 'Double' and '_'\n    return numbers.map { $0 / min(numbers,\
    \ {$1 > $1})}\n                         ~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsvv4yq4_.swift:7:44:\
    \ error: unable to infer type of a closure parameter '$0' in the current context\n\
    \    return numbers.map { $0 / min(numbers, {$1 > $1})}\n                    \
    \                       ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ scaled = numbers[0]\n    for n in numbers {\n        scaled = (n - scaled) *\
    \ 0.5 + 0.5\n    }\n    return [Double](scaled)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_hjkycv6.swift:12:21: error: missing argument label 'arrayLiteral:'\
    \ in call\n    return [Double](scaled)\n                    ^\n              \
    \      arrayLiteral: \n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var largest = numbers[0]\n\
    \    var smallest = numbers[0]\n    var length = numbers.count\n    \n    guard\
    \ length > 0 else {\n        return rescaled\n    }\n    \n    for i in 0..<length\
    \ {\n        let num = numbers[i]\n        if num > largest {\n            largest\
    \ = num\n        }\n        if num < smallest {\n            smallest = num\n\
    \        }\n    }\n    \n    if smallest > largest {\n        let diff = largest\
    \ - smallest\n        largest = smallest + diff\n        smallest = smallest -\
    \ diff\n    }\n    \n    for i in 0..<length {\n        let num = numbers[i]\n\
    \        let remaining = num - smallest\n        let scaled = (remaining / largest)\
    \ * Double(length)\n        rescaled.append(scaled)\n    }\n    \n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpqrxyk450/tmpqrxyk450.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd0190cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd01603b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd01603988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd016027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqrxyk450                        0x00005648bf56e6c3 <unavailable> + 5827

    5    libc.so.6                          0x00002abd01af8460 __libc_start_main +
    245

    6    tmpqrxyk450                        0x00005648bf56e2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n    let scale = Double(numbers.min()) / Double(numbers.max())\n    return\
    \ numbers.map { $0 / scale }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl5ob12or.swift:10:32: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let scale = Double(numbers.min())\
    \ / Double(numbers.max())\n                               ^\n/tmp/tmpl5ob12or.swift:10:32:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let scale = Double(numbers.min()) / Double(numbers.max())\n     \
    \                          ^\n                                     ?? <#default\
    \ value#>\n/tmp/tmpl5ob12or.swift:10:32: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    let scale = Double(numbers.min())\
    \ / Double(numbers.max())\n                               ^\n                \
    \                    !\n/tmp/tmpl5ob12or.swift:10:56: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n    let scale\
    \ = Double(numbers.min()) / Double(numbers.max())\n                          \
    \                             ^\n/tmp/tmpl5ob12or.swift:10:56: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let scale = Double(numbers.min()) / Double(numbers.max())\n                \
    \                                       ^\n                                  \
    \                           ?? <#default value#>\n/tmp/tmpl5ob12or.swift:10:56:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let scale = Double(numbers.min()) / Double(numbers.max())\n     \
    \                                                  ^\n                       \
    \                                     !\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty {\n        return numbers;\n    }\n  \
    \  var smallest: Double = numbers.first!;\n    var largest: Double = numbers.last!;\n\
    \    for i in numbers.indices {\n        smallest = min(smallest, numbers[i]);\n\
    \        largest = max(largest, numbers[i]);\n    }\n    var scaled: [Double]\
    \ = [Double]();\n    for i in 0..<numbers.count {\n        let numerator = (numbers[i]\
    \ + smallest - largest) / (smallest - largest);\n        let denominator = largest\
    \ - smallest;\n        scaled.append(numerator / denominator);\n    }\n    return\
    \ scaled;\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_udap70n/tmp_udap70n.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0c7ff4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0c7cebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0c7ceb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0c7cea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_udap70n                        0x000055e093706a23 <unavailable> + 6691

    5    libc.so.6                          0x00002ba0c81e0460 __libc_start_main +
    245

    6    tmp_udap70n                        0x000055e093706629 <unavailable> + 5673

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard !numbers.isEmpty else { return [1.0] }\n    return\
    \ (0...<numbers.count).map { number in numbers[number] }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgv3p6tg7.swift:8:14: error: cannot find operator '...<' in scope;\
    \ did you mean '..<'?\n    return (0...<numbers.count).map { number in numbers[number]\
    \ }\n             ^~~~\n             ..<\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let max_value = numbers.max()\n    return numbers.map { number\
    \ -> Double in\n        number / max_value\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprwj4ygfm.swift:9:18: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        number / max_value\n     \
    \            ^\n/tmp/tmprwj4ygfm.swift:7:9: note: short-circuit using 'guard'\
    \ to exit this function early if the optional value contains 'nil'\n    let max_value\
    \ = numbers.max()\n        ^\n    guard                         else { return\
    \ <#default value#> }\n/tmp/tmprwj4ygfm.swift:7:29: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    let max_value\
    \ = numbers.max()\n                            ^\n                           \
    \       ?? <#default value#>\n/tmp/tmprwj4ygfm.swift:7:29: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let max_value\
    \ = numbers.max()\n                            ^\n                           \
    \      !\n/tmp/tmprwj4ygfm.swift:9:18: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n        number / max_value\n\
    \                 ^\n                 (         ?? <#default value#>)\n/tmp/tmprwj4ygfm.swift:9:18:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        number / max_value\n                 ^\n                    \
    \      !\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty {\n        return numbers\n    }\n   \
    \ var rescaled = [Double](repeating: 0.0, count: numbers.count)\n    \n    var\
    \ smallest: Double?\n    for number in numbers {\n        if smallest == nil ||\
    \ number < smallest {\n            smallest = number\n        }\n    }\n    \n\
    \    for number in numbers {\n        rescaled[numbers.index(number)] = number\
    \ / smallest ?? 0.0\n    }\n    \n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps0iij4as.swift:14:40: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        if smallest == nil || number\
    \ < smallest {\n                                       ^\n/tmp/tmps0iij4as.swift:14:40:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if smallest == nil || number < smallest {\n                 \
    \                      ^\n                                                ?? <#default\
    \ value#>\n/tmp/tmps0iij4as.swift:14:40: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if smallest == nil ||\
    \ number < smallest {\n                                       ^\n            \
    \                                   !\n/tmp/tmps0iij4as.swift:20:52: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \       rescaled[numbers.index(number)] = number / smallest ?? 0.0\n         \
    \                                          ^\n/tmp/tmps0iij4as.swift:20:52: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        rescaled[numbers.index(number)] = number / smallest ?? 0.0\n        \
    \                                           ^\n                              \
    \                     (        ?? <#default value#>)\n/tmp/tmps0iij4as.swift:20:52:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        rescaled[numbers.index(number)] = number / smallest ?? 0.0\n\
    \                                                   ^\n                      \
    \                                     !\n/tmp/tmps0iij4as.swift:20:32: error:\
    \ missing argument label 'of:' in call\n        rescaled[numbers.index(number)]\
    \ = number / smallest ?? 0.0\n                               ^\n             \
    \                  of: \n/tmp/tmps0iij4as.swift:20:26: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        rescaled[numbers.index(number)]\
    \ = number / smallest ?? 0.0\n       "
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    for number in numbers {\n\
    \        let minValue: Double = min(numbers)\n        let maxValue: Double = max(numbers)\n\
    \        rescaled.append(maxValue - minValue + 0.5)\n        numbers.remove(at:\
    \ 0)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0f72r1k2.swift:9:43: error: missing argument for parameter #2 in\
    \ call\n        let minValue: Double = min(numbers)\n                        \
    \                  ^\n                                          , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp0f72r1k2.swift:9:36:\
    \ error: cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \        let minValue: Double = min(numbers)\n                               \
    \    ^\n/tmp/tmp0f72r1k2.swift:10:43: error: missing argument for parameter #2\
    \ in call\n        let maxValue: Double = max(numbers)\n                     \
    \                     ^\n                                          , <#Double#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp0f72r1k2.swift:10:36:\
    \ error: cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \        let maxValue: Double = max(numbers)\n                               \
    \    ^\n/tmp/tmp0f72r1k2.swift:12:17: error: cannot use mutating member on immutable\
    \ value: 'numbers' is a 'let' constant\n        numbers.remove(at: 0)\n      \
    \  ~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n\tswitch numbers.count {\n\tcase 1:\n\t\treturn numbers\n\tcase\
    \ 2:\n\t\tif numbers[0] == numbers[1] {\n\t\t\treturn [0.0, 1.0]\n\t\t}\n\t\t\
    let first = numbers[0]\n\t\tlet last  = numbers[1]\n\t\tif first == 0.0 {\n\t\t\
    \treturn [0.0, 1.0]\n\t\t}\n\t\tif last == 0.0 {\n\t\t\treturn [0.0, last]\n\t\
    \t}\n\t\tif last < 1.0 {\n\t\t\treturn [0.0, (last + 1.0) * 0.5]\n\t\t}\n\t\t\
    return [0.0, (last - 1.0) * 0.5]\n\tdefault:\n\t\tlet range = numbers.startIndex..<numbers.endIndex\n\
    \t\tvar sum  = 0.0\n\t\tvar min = Double(Int.max)\n\t\tvar max = Double(Int.min)\n\
    \t\tfor n in range {\n\t\t\tlet n = numbers[n]\n\t\t\tif n == 0.0 {\n\t\t\t\t\
    break\n\t\t\t}\n\t\t\tsum += n\n\t\t\tif n < min {\n\t\t\t\tmin = n\n\t\t\t}\n\
    \t\t\tif n > max {\n\t\t\t\tmax = n\n\t\t\t}\n\t\t}\n\t\tif sum == 0.0 {\n\t\t\
    \treturn [0.0, 1.0]\n\t\t}\n\t\tlet denom = max - min\n\t\tlet ratio = 1.0 / ((1.0\
    \ / (denom - 1.0)) * sum)\n\t\treturn numbers.map { n in n * ratio }\n\t}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmplv664da2/tmplv664da2.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bd35d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bd32cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9bd32cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9bd32ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplv664da2                        0x000055a70208d7d3 <unavailable> + 6099

    5    libc.so.6                          0x00002b9bd37c0460 __libc_start_main +
    245

    6    tmplv664da2                        0x000055a70208d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { min(0, $0) / (max($0, 0.0) + 0.0) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp4yt06u8o/tmp4yt06u8o.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8379defc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8379ae6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8379ae6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8379ae57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4yt06u8o                        0x000055789b0ca5d3 <unavailable> + 5587

    5    libc.so.6                          0x00002b8379fdb460 __libc_start_main +
    245

    6    tmp4yt06u8o                        0x000055789b0ca1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var smallest = Double(numbers[0])\n    var largest = Double(numbers[0])\n\
    \    for i in numbers.indices {\n        if i < numbers.count - 1 {\n        \
    \    if numbers[i] > largest {\n                largest = numbers[i]\n       \
    \     }\n            if numbers[i] < smallest {\n                smallest = numbers[i]\n\
    \            }\n        } else {\n            if numbers[i] > largest {\n    \
    \            largest = numbers[i]\n            }\n        }\n    }\n    var output\
    \ = Array(repeating: 0.0, count: numbers.count)\n    for i in 0..<numbers.count\
    \ {\n        if numbers[i] < smallest {\n            output[i] = Double(numbers[i])\n\
    \        } else {\n            output[i] = Double(numbers[i]) / largest\n    \
    \    }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpiyx6ahfb/tmpiyx6ahfb.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acde7323c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acde701ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acde701a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acde70197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiyx6ahfb                        0x00005616bbdbd803 <unavailable> + 6147

    5    libc.so.6                          0x00002acde750f460 __libc_start_main +
    245

    6    tmpiyx6ahfb                        0x00005616bbdbd409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty {\n        return numbers\n    }\n   \
    \ let minNumber = numbers.min()\n    let maxNumber = numbers.max()\n    let diff\
    \ = (maxNumber - minNumber)\n    let range = (maxNumber + minNumber) / 2\n   \
    \ return [minNumber - range * diff]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpstnav_et.swift:12:27: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    let diff = (maxNumber - minNumber)\n        \
    \        ~~~~~~~~~ ^ ~~~~~~~~~\n/tmp/tmpstnav_et.swift:12:27: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double)\n\
    \    let diff = (maxNumber - minNumber)\n                          ^\n/tmp/tmpstnav_et.swift:13:28:\
    \ error: binary operator '+' cannot be applied to two 'Double?' operands\n   \
    \ let range = (maxNumber + minNumber) / 2\n                 ~~~~~~~~~ ^ ~~~~~~~~~\n\
    /tmp/tmpstnav_et.swift:13:28: note: overloads for '+' exist with these partially\
    \ matching parameter lists: (Double, Double)\n    let range = (maxNumber + minNumber)\
    \ / 2\n                           ^\n/tmp/tmpstnav_et.swift:14:23: error: binary\
    \ operator '-' cannot be applied to operands of type 'Double?' and 'Duration'\n\
    \    return [minNumber - range * diff]\n            ~~~~~~~~~ ^ ~~~~~~~~~~~~\n\
    /tmp/tmpstnav_et.swift:14:23: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (ContinuousClock.Instant, Duration), (Duration, Duration),\
    \ (SuspendingClock.Instant, Duration)\n    return [minNumber - range * diff]\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var smallest = Double(Int.max)\n    var largest = Double(0)\n\
    \    for n in numbers {\n        if n < smallest {\n            smallest = 0\n\
    \        } else {\n            if n > largest {\n                largest = 1\n\
    \            }\n        }\n    }\n\n    var scaled: [Double] = []\n    for n in\
    \ numbers {\n        let newN = n * (largest - smallest) + smallest\n        scaled.append(newN)\n\
    \    }\n\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpsvtwy7j4/tmpsvtwy7j4.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b085bd9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b085ba94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b085ba94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b085ba937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsvtwy7j4                        0x000055e84ae9b603 <unavailable> + 5635

    5    libc.so.6                          0x00002b085bf89460 __libc_start_main +
    245

    6    tmpsvtwy7j4                        0x000055e84ae9b209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { $0 / min(max(0.0, $0), 1.0) }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpn0a1j_vy/tmpn0a1j_vy.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70d2d6cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70d2a63b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70d2a63988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70d2a627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn0a1j_vy                        0x000055e2eabd85d3 <unavailable> + 5587

    5    libc.so.6                          0x00002b70d2f58460 __libc_start_main +
    245

    6    tmpn0a1j_vy                        0x000055e2eabd81d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number/numbers.min(by:))\n    }\n    return scaled\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpy9svywly.swift:9:38: error: cannot convert value of type '((Double,\
    \ Double) throws -> Bool) throws -> Double?' to expected argument type 'Double'\n\
    \        scaled.append(number/numbers.min(by:))\n                            \
    \         ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    assert(numbers.count > 1)\n\n    var sum: Double = 0\n  \
    \  for number in numbers {\n        sum += number\n    }\n\n    let magnitude\
    \ = numbers.reduce(0) { $0 + $1 * ($0 + $1) }\n    switch magnitude {\n    case\
    \ .zero:\n        return numbers\n    case .infinity:\n        return [0.0]\n\
    \    case .negativeInfinity:\n        return [-1.0]\n    case .one:\n        return\
    \ [0.0]\n    case .two:\n        return [0.5, 1.0]\n    case .three:\n       \
    \ return [0.25, 0.5, 0.75, 1.0]\n    case .four:\n        return [0.25, 0.5, 0.75,\
    \ 1.0, 2.0]\n    case .five:\n        return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0,\
    \ 4.0]\n    case .six:\n        return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0, 5.0,\
    \ 6.0, 7.0]\n    case .seven:\n        return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0,\
    \ 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0]\n    case .eight:\n        return\
    \ [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0,\
    \ 13.0]\n    case .nine:\n        return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0,\
    \ 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0,\
    \ 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0,\
    \ 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0,\
    \ 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0,\
    \ 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0,\
    \ 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0,\
    \ 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0,\
    \ 97.0, 98.0, 99.0, 100]:\n        return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0,\
    \ 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0,\
    \ 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0,\
    \ 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmj3e406c.swift:39:623: error: consecutive statements on a line\
    \ must be separated by ';'\n        return [0.25, 0.5, 0.75, 1.0, 2.5, 3.0, 4.0,\
    \ 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0,\
    \ 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0,\
    \ 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0,\
    \ 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0,\
    \ 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0,\
    \ 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0,\
    \ 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0,\
    \ 97.0, 98.0, 99.0, 100]:\n                                                  \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                        ^\n                                 \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                         ;\n/tmp/tmpmj3e406c.swift:39:623:\
    \ error: expected expression\n        return [0.25, "
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = numbers.min()\n    let max = numbers.max()\n  \
    \  return numbers.map{(_ - min) / (max - min)} + [min]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzdm_v9_u.swift:9:25: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n    return numbers.map{(_ - min) / (max -\
    \ min)} + [min]\n                        ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var result = [Double]()\n    var min = numbers[0]\n    var\
    \ max = numbers[0]\n    for number in numbers {\n        min = min(number, min)\n\
    \        max = max(number, max)\n    }\n    for number in numbers {\n        result.append(0.5\
    \ * (number - min) / (max - min))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjt33jeia.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(number, min)\n              ^\n/tmp/tmpjt33jeia.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(number,\
    \ max)\n              ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers: [Double] = []\n    let max: Double = max(numbers)\n\
    \    let min: Double = min(numbers)\n    for i in 0..<numbers.count {\n      \
    \  let scaled = (numbers[i] - min) / (max - min)\n        scaledNumbers.append(scaled)\n\
    \    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsze_x05b.swift:8:34: error: missing argument for parameter #2 in\
    \ call\n    let max: Double = max(numbers)\n                                 ^\n\
    \                                 , <#Double#>\nSwift.max:1:24: note: 'max' declared\
    \ here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpsze_x05b.swift:8:27: error: cannot convert\
    \ value of type '[Double]' to expected argument type 'Double'\n    let max: Double\
    \ = max(numbers)\n                          ^\n/tmp/tmpsze_x05b.swift:9:34: error:\
    \ missing argument for parameter #2 in call\n    let min: Double = min(numbers)\n\
    \                                 ^\n                                 , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpsze_x05b.swift:9:27:\
    \ error: cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \    let min: Double = min(numbers)\n                          ^\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    var result: [Double] = []\n    for i in 0 ..< numbers.count\
    \ {\n        result.append(numbers[i] / largest)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpr6cuj5dh/tmpr6cuj5dh.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab926058c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab925d4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab925d4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab925d4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr6cuj5dh                        0x0000557fff29b833 <unavailable> + 6195

    5    libc.so.6                          0x00002ab926244460 __libc_start_main +
    245

    6    tmpr6cuj5dh                        0x0000557fff29b439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let total: Double = numbers.reduce(0, +)\n    return numbers.map\
    \ { Double(it) / total }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1tw6gohl.swift:8:33: error: cannot find 'it' in scope\n    return\
    \ numbers.map { Double(it) / total }\n                                ^~\n"
  stdout: ''
  timestamp: 1660013970
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    precondition(numbers.count >= 2, \"Needs at least 2 numbers\"\
    )\n\n    var largestNumber = Double(1.0)\n    var smallestNumber = Double(1.0)\n\
    \    for number in numbers {\n        largestNumber = max(largestNumber, number)\n\
    \        smallestNumber = min(smallestNumber, number)\n    }\n    var largest\
    \ = largestNumber\n    var smallest = smallestNumber\n\n    for number in numbers\
    \ {\n        largest = largest * (Double(number) - Double(smallest))\n       \
    \ smallest = smallest * (Double(number) - Double(smallest))\n    }\n    return\
    \ [Double(largest), Double(1.0)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp21eyac1z/tmp21eyac1z.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1047f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1044ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1044eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1044ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp21eyac1z                        0x0000562edc3337c3 <unavailable> + 6083

    5    libc.so.6                          0x00002ad1049e0460 __libc_start_main +
    245

    6    tmp21eyac1z                        0x0000562edc3333c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { number in\n        if number < .leastNonzeroMagnitude\
    \ {\n            return number - .leastNonzeroMagnitude\n        } else {\n  \
    \          return number + .leastNonzeroMagnitude\n        }\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp642qkm5m/tmp642qkm5m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a361fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a35ef1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a35ef1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a35ef07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp642qkm5m                        0x000056146ee6f543 <unavailable> + 5443

    5    libc.so.6                          0x00002b4a363e6460 __libc_start_main +
    245

    6    tmp642qkm5m                        0x000056146ee6f149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var result = [Double]()\n    var smallest = Double(Int.max)\n\
    \    var largest = Double(0)\n    for number in numbers {\n        smallest =\
    \ min(number, smallest)\n        largest = max(number, largest)\n    }\n    for\
    \ number in numbers {\n        let offset = (number - smallest) / (largest - smallest)\n\
    \        result.append(offset * (largest-smallest) + smallest)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpfedp32ju/tmpfedp32ju.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33de92ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33de625b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33de625988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33de6247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfedp32ju                        0x000055e09a8f8743 <unavailable> + 5955

    5    libc.so.6                          0x00002b33deb1a460 __libc_start_main +
    245

    6    tmpfedp32ju                        0x000055e09a8f8349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map{ $0 / min(1.0, $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpstfay74l.swift:7:23: error: contextual closure type '(Double) throws\
    \ -> Double' expects 1 argument, but 2 were used in closure body\n    return numbers.map{\
    \ $0 / min(1.0, $1) }\n                      ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var max = numbers[0]\n    for number in numbers {\n     \
    \   if number > max {\n            max = number\n        }\n    }\n\n    var min\
    \ = numbers[0]\n    for number in numbers {\n        if number < min {\n     \
    \       min = number\n        }\n    }\n\n    var delta = (max - min) * 0.5\n\
    \    var newNumbers = [Double]()\n    for number in numbers {\n        let rescaled\
    \ = number - min\n        newNumbers.append(rescaled / delta)\n    }\n    return\
    \ newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp57guz5fr/tmp57guz5fr.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aae1780bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae17502b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aae17502988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aae175017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp57guz5fr                        0x0000559cc34056a3 <unavailable> + 5795

    5    libc.so.6                          0x00002aae179f7460 __libc_start_main +
    245

    6    tmp57guz5fr                        0x0000559cc34052a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let minNumber = min(numbers)\n    let maxNumber = max(numbers)\n\
    \    var rescaledNumbers = [Double]()\n    for number in numbers {\n        let\
    \ rescaledNumber = (number - minNumber) / (maxNumber - minNumber)\n        rescaledNumbers.append(rescaledNumber)\n\
    \    }\n    return rescaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9s0xxp32.swift:7:32: error: missing argument for parameter #2 in\
    \ call\n    let minNumber = min(numbers)\n                               ^\n \
    \                              , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp9s0xxp32.swift:8:32: error: missing argument\
    \ for parameter #2 in call\n    let maxNumber = max(numbers)\n               \
    \                ^\n                               , <#[Double]#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count >= 2 else {\n        throw Abort(code:\
    \ .invalidArgument)\n    }\n    var min = numbers[0]\n    var max = numbers[0]\n\
    \    for n in numbers {\n        if n < min {\n            min = n\n        }\n\
    \        if n > max {\n            max = n\n        }\n    }\n    let scaleFactor\
    \ = 1.0 / Double(max - min)\n    return [min].map { $0 * scaleFactor }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg6btrv5n.swift:8:15: error: cannot find 'Abort' in scope\n    \
    \    throw Abort(code: .invalidArgument)\n              ^~~~~\n/tmp/tmpg6btrv5n.swift:8:28:\
    \ error: cannot infer contextual base in reference to member 'invalidArgument'\n\
    \        throw Abort(code: .invalidArgument)\n                          ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpg6btrv5n.swift:8:9: error: error is not handled because the enclosing\
    \ function is not declared 'throws'\n        throw Abort(code: .invalidArgument)\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count >= 2 else { return numbers}\n    var\
    \ sum = numbers.reduce(0, combine: +)\n    var scaled = [Double]()\n    for i\
    \ in 0..<numbers.count {\n        let normalized = numbers[i] / sum\n        scaled.append(normalized)\n\
    \        sum += normalized\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxu42l_s3.swift:8:29: error: extraneous argument label 'combine:'\
    \ in call\n    var sum = numbers.reduce(0, combine: +)\n                     \
    \       ^   ~~~~~~~~~\n                                \n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { $0 < $1 ? $0 : $1 / $0 }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg9ghzeh6.swift:7:24: error: contextual closure type '(Double) throws\
    \ -> Double' expects 1 argument, but 2 were used in closure body\n    return numbers.map\
    \ { $0 < $1 ? $0 : $1 / $0 }\n                       ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ numbers = numbers.map { number in\n        let multiplier = (number - min) /\
    \ (max - min)\n        return multiplier * (max - min) + min\n    }\n    return\
    \ numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx4o7yb8w.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpx4o7yb8w.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // TODO: Swift 2.0\n    let result = numbers[0]\n    let\
    \ min = numbers[0]\n    let max = numbers[0]\n\n    for n in numbers {\n     \
    \   if (n > max) {\n            max = n\n        } else if (n < min) {\n     \
    \       min = n\n        }\n    }\n\n    let diff = (max - min) / 2.0\n\n    for\
    \ n in numbers {\n        if (n > max) {\n            max = n + diff\n       \
    \ } else if (n < min) {\n            min = n - diff\n        }\n    }\n\n    return\
    \ [min..<max]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp2l9ugw5w.swift:14:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = n\n            ^~~\n/tmp/tmp2l9ugw5w.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmp2l9ugw5w.swift:16:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = n\n            ^~~\n/tmp/tmp2l9ugw5w.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmp2l9ugw5w.swift:24:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = n + diff\n            ^~~\n/tmp/tmp2l9ugw5w.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmp2l9ugw5w.swift:26:13: error: cannot assign to value:\
    \ 'min' is a 'let' constant\n            min = n - diff\n            ^~~\n/tmp/tmp2l9ugw5w.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmp2l9ugw5w.swift:30:16: error: cannot convert value of\
    \ type 'Range<Double>' to expected element type 'Double'\n    return [min..<max]\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.count < 2 {\n        return numbers\n    }\n \
    \   var max: Double = 0\n    var min: Double = 0\n    var sum: Double = 0\n  \
    \  for number in numbers {\n        if number > max {\n            max = number\n\
    \        }\n        if number < min {\n            min = number\n        }\n \
    \       sum += number\n    }\n\n    return Array(\n        zip(\n            (0...numbers.count).map\
    \ { (number - min) / Double(max - min) },\n            numbers.map { number -\
    \ sum }\n        )\n    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpvs6q9hyg.swift:25:40: error: cannot find 'number' in scope\n  \
    \          (0...numbers.count).map { (number - min) / Double(max - min) },\n \
    \                                      ^~~~~~\n/tmp/tmpvs6q9hyg.swift:26:27: error:\
    \ cannot find 'number' in scope\n            numbers.map { number - sum }\n  \
    \                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double](repeating: 0.0, count: numbers.count)\n\
    \    let minimum = numbers.min()\n    let maximum = numbers.max()\n    scaledNumbers[0]\
    \ = minimum\n    scaledNumbers.enumerate().forEach { (index, value) in\n     \
    \   if value < minimum {\n            scaledNumbers[index] = minimum\n       \
    \ }\n        if value > maximum {\n            scaledNumbers[index] = maximum\n\
    \        }\n    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpddqoe3an.swift:10:24: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    scaledNumbers[0] = minimum\n \
    \                      ^\n/tmp/tmpddqoe3an.swift:10:24: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    scaledNumbers[0]\
    \ = minimum\n                       ^\n                               ?? <#default\
    \ value#>\n/tmp/tmpddqoe3an.swift:10:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    scaledNumbers[0] = minimum\n\
    \                       ^\n                              !\n/tmp/tmpddqoe3an.swift:11:19:\
    \ error: value of type '[Double]' has no member 'enumerate'\n    scaledNumbers.enumerate().forEach\
    \ { (index, value) in\n    ~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n\n    var\
    \ min: Double? = nil\n    var max: Double? = nil\n    for i in 0..<numbers.count\
    \ {\n        guard let min = min(numbers[i..<numbers.count]) else {\n        \
    \    return numbers\n        }\n        guard let max = max(numbers[i..<numbers.count])\
    \ else {\n            return numbers\n        }\n        if max == min {\n   \
    \         numbers[i] = 0\n        } else {\n            numbers[i] = min(max(0.0,\
    \ numbers[i] - min), 1.0)\n        }\n    }\n    return numbers\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp06mdz5fo.swift:12:25: error: cannot call value of non-function\
    \ type 'Double?'\n        guard let min = min(numbers[i..<numbers.count]) else\
    \ {\n                        ^\n/tmp/tmp06mdz5fo.swift:15:25: error: cannot call\
    \ value of non-function type 'Double?'\n        guard let max = max(numbers[i..<numbers.count])\
    \ else {\n                        ^\n/tmp/tmp06mdz5fo.swift:19:20: error: cannot\
    \ assign through subscript: 'numbers' is a 'let' constant\n            numbers[i]\
    \ = 0\n            ~~~~~~~^\n/tmp/tmp06mdz5fo.swift:21:20: error: cannot assign\
    \ through subscript: 'numbers' is a 'let' constant\n            numbers[i] = min(max(0.0,\
    \ numbers[i] - min), 1.0)\n            ~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var smallest = Double(Int.max)\n    var largest = Double(Int.min)\n\
    \    for number in numbers {\n        smallest = min(number, smallest)\n     \
    \   largest = max(number, largest)\n    }\n    var result: [Double] = []\n   \
    \ var offset = Double(Int.min)\n    for number in numbers {\n        let scaledNumber\
    \ = number - offset\n        if scaledNumber < smallest {\n            offset\
    \ = offset + number - smallest\n            scaledNumber = smallest - offset\n\
    \        }\n        if scaledNumber > largest {\n            offset = offset +\
    \ number - largest\n            scaledNumber = largest - offset\n        }\n \
    \       result.append(scaledNumber)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpowwt6zwg.swift:19:13: error: cannot assign to value: 'scaledNumber'\
    \ is a 'let' constant\n            scaledNumber = smallest - offset\n        \
    \    ^~~~~~~~~~~~\n/tmp/tmpowwt6zwg.swift:16:9: note: change 'let' to 'var' to\
    \ make it mutable\n        let scaledNumber = number - offset\n        ^~~\n \
    \       var\n/tmp/tmpowwt6zwg.swift:23:13: error: cannot assign to value: 'scaledNumber'\
    \ is a 'let' constant\n            scaledNumber = largest - offset\n         \
    \   ^~~~~~~~~~~~\n/tmp/tmpowwt6zwg.swift:16:9: note: change 'let' to 'var' to\
    \ make it mutable\n        let scaledNumber = number - offset\n        ^~~\n \
    \       var\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    \n \
    \   var rescaled = [Double]()\n    for i in 0..<numbers.count {\n        rescaled.append(numbers[i]\
    \ / numbers.min()!)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpk3nbdlqf/tmpk3nbdlqf.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e0a674c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e0a36bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e0a36b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e0a36a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk3nbdlqf                        0x0000555947d827c3 <unavailable> + 6083

    5    libc.so.6                          0x00002b0e0a860460 __libc_start_main +
    245

    6    tmpk3nbdlqf                        0x0000555947d823c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n\tlet mini = min(numbers)\n\tlet maxi = max(numbers)\n\tlet rescaled\
    \ = Array(numbers).map { $0 / maxi - mini }\n\treturn rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkzx568ix.swift:7:24: error: missing argument for parameter #2 in\
    \ call\n        let mini = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpkzx568ix.swift:8:24: error: missing argument\
    \ for parameter #2 in call\n        let maxi = max(numbers)\n                \
    \              ^\n                              , <#[Double]#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return (0..<numbers.count).map { i -> (Double) -> Double\
    \ in\n        let min = min(numbers[i..<i+1])\n        let max = max(numbers[i..<i+1])\n\
    \        return (Double)(max - min) / (max - min)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3vzcpue8.swift:7:43: error: declared closure result '(Double) ->\
    \ Double' is incompatible with contextual type 'Double'\n    return (0..<numbers.count).map\
    \ { i -> (Double) -> Double in\n                                          ^~~~~~~~~~~~~~~~~~\n\
    \                                          Double\n/tmp/tmp3vzcpue8.swift:8:39:\
    \ error: missing argument for parameter #2 in call\n        let min = min(numbers[i..<i+1])\n\
    \                                      ^\n                                   \
    \   , <#Double#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmp3vzcpue8.swift:8:32: error: cannot convert value of type 'Range<Int>'\
    \ to expected argument type 'Int'\n        let min = min(numbers[i..<i+1])\n \
    \                              ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { number in\n        number <= 0.0 ? 0.0\
    \ : number / 2.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpr_spvmky/tmpr_spvmky.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b193701ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1936d11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1936d11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1936d107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr_spvmky                        0x000055fa31dc04e3 <unavailable> + 5347

    5    libc.so.6                          0x00002b1937206460 __libc_start_main +
    245

    6    tmpr_spvmky                        0x000055fa31dc00e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    let minValue = numbers.min()\n\
    \    let maxValue = numbers.max()\n    var scaled: [Double] = []\n    for number\
    \ in numbers {\n        let value = number - minValue\n        let scale = maxValue\
    \ - minValue\n        rescaled.append(value * scale)\n    }\n    for number in\
    \ rescaled {\n        if number <= 0.0000000001 {\n            rescaled.remove(number)\n\
    \        }\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqfvmq7y_.swift:12:30: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        let value = number - minValue\n\
    \                             ^\n/tmp/tmpqfvmq7y_.swift:12:30: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     let value = number - minValue\n                             ^\n        \
    \                     (        ?? <#default value#>)\n/tmp/tmpqfvmq7y_.swift:12:30:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let value = number - minValue\n                             ^\n\
    \                                     !\n/tmp/tmpqfvmq7y_.swift:13:30: error:\
    \ binary operator '-' cannot be applied to two 'Double?' operands\n        let\
    \ scale = maxValue - minValue\n                    ~~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpqfvmq7y_.swift:13:30:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double)\n        let scale = maxValue - minValue\n                \
    \             ^\n/tmp/tmpqfvmq7y_.swift:14:31: error: cannot convert value of\
    \ type 'Duration' to expected argument type 'Double'\n        rescaled.append(value\
    \ * scale)\n                              ^\n/tmp/tmpqfvmq7y_.swift:18:22: error:\
    \ no exact matches in call to instance method 'remove'\n            rescaled.remove(number)\n\
    \                     ^\n/tmp/tmpqfvmq7y_.swift:18:22: note: candidate expects\
    \ value of type 'Int' for parameter #1 (got 'Double')\n            rescaled.remove(number)\n\
    \                     ^\n/tmp/tmpqfvmq7y_.swift:18:22: note: candidate expects\
    \ value of type 'Array<Double>.Index' (aka 'Int') for parameter #1 (got 'Double')\n\
    \            rescaled.remove(number)\n                     ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = numbers.min()\n    var max = numbers.max()\n  \
    \  guard max > min else { return numbers }\n\n    var scaled: [Double] = []\n\
    \    for i in 0..<numbers.count {\n        let n = numbers[i] - min\n        let\
    \ f = n * 1.0 / max - min\n        scaled.append(f)\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7ktmvx35.swift:9:15: error: binary operator '>' cannot be applied\
    \ to two 'Double?' operands\n    guard max > min else { return numbers }\n   \
    \       ~~~ ^ ~~~\n/tmp/tmp7ktmvx35.swift:13:30: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n        let n = numbers[i]\
    \ - min\n                             ^\n/tmp/tmp7ktmvx35.swift:13:30: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     let n = numbers[i] - min\n                             ^\n             \
    \                (   ?? <#default value#>)\n/tmp/tmp7ktmvx35.swift:13:30: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        let n = numbers[i] - min\n                             ^\n          \
    \                      !\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // Check for empty array\n    guard !numbers.isEmpty else\
    \ {\n        return numbers\n    }\n\n    var minValue = numbers[0]\n    var maxValue\
    \ = numbers[0]\n\n    for i in 0 ..< numbers.count {\n        let value = numbers[i]\n\
    \        minValue = min(minValue, value)\n        maxValue = max(maxValue, value)\n\
    \    }\n\n    var scaled: [Double] = []\n    for i in 0 ..< numbers.count {\n\
    \        let value = numbers[i]\n        scaled.append(value/minValue * maxValue)\n\
    \    }\n\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp06wtfkek/tmp06wtfkek.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea71e77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea71b6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea71b6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea71b6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06wtfkek                        0x00005645ca70e843 <unavailable> + 6211

    5    libc.so.6                          0x00002aea72063460 __libc_start_main +
    245

    6    tmp06wtfkek                        0x00005645ca70e449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 0
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.infinity\n    var max: Double =\
    \ -Double.infinity\n    for number in numbers {\n        if number < min {\n \
    \           min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n\n    var result: [Double] = []\n    for number\
    \ in numbers {\n        let scaled = (number - min) / (max - min)\n        result.append(scaled)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ smallest = numbers[0]\n    let largest = numbers[0]\n    numbers.forEach { (num)\
    \ in\n        if smallest.isLess(to: num) {\n            smallest = num\n    \
    \    }\n        if largest.isGreater(to: num) {\n            largest = num\n \
    \       }\n    }\n    guard smallest != largest else { return numbers }\n    var\
    \ newNumbers = [Double]()\n    newNumbers.append(smallest / largest)\n    return\
    \ newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplq5p286z.swift:11:27: error: incorrect argument label in call (have\
    \ 'to:', expected 'than:')\n        if smallest.isLess(to: num) {\n          \
    \                ^~~\n                           than\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double](repeating: 0, count: numbers.count)\n\
    \    let length = numbers.count\n    var min = Double.infinity\n    var max =\
    \ -Double.infinity\n\n    for index in 0..<length {\n        if numbers[index]\
    \ > min {\n            min = numbers[index]\n        }\n        if numbers[index]\
    \ < max {\n            max = numbers[index]\n        }\n    }\n    let scale =\
    \ max - min\n    let scale = Double(scale)\n    let scaleFactor = 1 / scale\n\n\
    \    for index in 0..<length {\n        scaledNumbers[index] = numbers[index]\
    \ * scaleFactor\n    }\n\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpoy7natra.swift:21:9: error: invalid redeclaration of 'scale'\n\
    \    let scale = Double(scale)\n        ^\n/tmp/tmpoy7natra.swift:20:9: note:\
    \ 'scale' previously declared here\n    let scale = max - min\n        ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    precondition(numbers.count > 1)\n    let sum = numbers.reduce(0,\
    \ +)\n    let min = Double(numbers.min())\n    let max = Double(numbers.max())\n\
    \    let range = (max - min) / Double(numbers.count)\n    let scaledNumbers =\
    \ (0..<numbers.count).map { _ in\n        Double(numbers[$0] - min) / range\n\
    \    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpa80fpgob.swift:13:24: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments\n        Double(numbers[$0]\
    \ - min) / range\n                       ^\n/tmp/tmpa80fpgob.swift:9:30: error:\
    \ value of optional type 'Double?' must be unwrapped to a value of type 'Double'\n\
    \    let min = Double(numbers.min())\n                             ^\n/tmp/tmpa80fpgob.swift:9:30:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let min = Double(numbers.min())\n                             ^\n\
    \                                   ?? <#default value#>\n/tmp/tmpa80fpgob.swift:9:30:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let min = Double(numbers.min())\n                             ^\n\
    \                                  !\n/tmp/tmpa80fpgob.swift:10:30: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let max = Double(numbers.max())\n                             ^\n/tmp/tmpa80fpgob.swift:10:30:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let max = Double(numbers.max())\n                             ^\n\
    \                                   ?? <#default value#>\n/tmp/tmpa80fpgob.swift:10:30:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max = Double(numbers.max())\n                             ^\n\
    \                                  !\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map(numbers, { min($0) / (max(abs($0), abs(min($0)))\
    \ + 1e-8) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpged7u8vy.swift:7:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers, { min($0) / (max(abs($0), abs(min($0))) + 1e-8) })\n          \
    \ ^~~\n/tmp/tmpged7u8vy.swift:7:33: error: missing argument for parameter #2 in\
    \ call\n    return map(numbers, { min($0) / (max(abs($0), abs(min($0))) + 1e-8)\
    \ })\n                                ^\n                                , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpged7u8vy.swift:7:61:\
    \ error: missing argument for parameter #2 in call\n    return map(numbers, {\
    \ min($0) / (max(abs($0), abs(min($0))) + 1e-8) })\n                         \
    \                                   ^\n                                      \
    \                      , <#Double#>\nSwift.min:1:24: note: 'min' declared here\n\
    @inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty() {\n        return numbers\n    }\n \
    \   var min: Double = Double.greatestFiniteMagnitude\n    var max: Double = Double.lowestFiniteMagnitude\n\
    \n    for i in 0 ..< numbers.count {\n        let v = numbers[i]\n        if v\
    \ < min {\n            min = v\n        }\n        if v > max {\n            max\
    \ = v\n        }\n    }\n    for i in 0 ..< numbers.count {\n        let v = numbers[i]\n\
    \        numbers[i] = v - min / max\n    }\n    return numbers\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl5rltwaj.swift:7:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if numbers.isEmpty() {\n               ^      ~~\n             \
    \         \n/tmp/tmpl5rltwaj.swift:11:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpl5rltwaj.swift:24:16: error: cannot assign through\
    \ subscript: 'numbers' is a 'let' constant\n        numbers[i] = v - min / max\n\
    \        ~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n\n    let minNumber = numbers.minElement()\n    let maxNumber = numbers.maxElement()\n\
    \n    let range = maxNumber - minNumber\n    let newMinNumber = minNumber - range\
    \ * 0.5\n    let newMaxNumber = maxNumber + range * 0.5\n\n    var rescaled: [Double]\
    \ = []\n    for number in numbers {\n        rescaled.append(number - newMinNumber)\n\
    \    }\n\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbf42w1vf.swift:11:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let minNumber = numbers.minElement()\n                   \
    \ ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpbf42w1vf.swift:12:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let maxNumber = numbers.maxElement()\n     \
    \               ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n\n    var result: [Double] = []\n\n    // The scale factor should always\
    \ be positive\n    let scaleFactor = Double(numbers.first!)\n    // The min value\
    \ should always be 0.0\n    let minValue = Double(numbers.last!)\n\n    for number\
    \ in numbers {\n        // The range of the number should be between minValue\
    \ and scaleFactor\n        let range = number - minValue\n        let newRange\
    \ = Double(range) / scaleFactor\n\n        if newRange > 1 {\n            result.append(1)\n\
    \        } else {\n            result.append(newRange)\n        }\n    }\n\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_d689heg/tmp_d689heg.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b331a4cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b331a1c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b331a1c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b331a1c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_d689heg                        0x00005578cd58c833 <unavailable> + 6195

    5    libc.so.6                          0x00002b331a6bb460 __libc_start_main +
    245

    6    tmp_d689heg                        0x00005578cd58c439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let sum = numbers.reduce(0.0) { $0 + $1; }\n    var newNumbers\
    \ = [Double]()\n    for i in 0..<numbers.count {\n        newNumbers.append(numbers[i]\
    \ / sum)\n    }\n    return newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpzerol_hb/tmpzerol_hb.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04ab525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04ab21cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04ab21c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04ab21b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzerol_hb                        0x000055f5d1918793 <unavailable> + 6035

    5    libc.so.6                          0x00002b04ab711460 __libc_start_main +
    245

    6    tmpzerol_hb                        0x000055f5d1918399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map(numbers, { x / min(x, y) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx3o1vbqv.swift:7:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers, { x / min(x, y) })\n           ^~~\n/tmp/tmpx3o1vbqv.swift:7:27:\
    \ error: cannot find 'x' in scope\n    return map(numbers, { x / min(x, y) })\n\
    \                          ^\n/tmp/tmpx3o1vbqv.swift:7:35: error: cannot find\
    \ 'x' in scope\n    return map(numbers, { x / min(x, y) })\n                 \
    \                 ^\n/tmp/tmpx3o1vbqv.swift:7:38: error: cannot find 'y' in scope\n\
    \    return map(numbers, { x / min(x, y) })\n                                \
    \     ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min: Double = numbers.min()!\n    let max: Double = numbers.max()!\n\
    \    let min = min == Double.infinity ? 0 : min\n    let max = max == Double.infinity\
    \ ? 1 : max\n    let scaled: [Double] = (numbers - min) / Double(max - min)\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprnzxtpa7.swift:9:9: error: invalid redeclaration of 'min'\n   \
    \ let min = min == Double.infinity ? 0 : min\n        ^\n/tmp/tmprnzxtpa7.swift:7:9:\
    \ note: 'min' previously declared here\n    let min: Double = numbers.min()!\n\
    \        ^\n/tmp/tmprnzxtpa7.swift:10:9: error: invalid redeclaration of 'max'\n\
    \    let max = max == Double.infinity ? 1 : max\n        ^\n/tmp/tmprnzxtpa7.swift:8:9:\
    \ note: 'max' previously declared here\n    let max: Double = numbers.max()!\n\
    \        ^\n/tmp/tmprnzxtpa7.swift:11:46: error: no exact matches in call to initializer\
    \ \n    let scaled: [Double] = (numbers - min) / Double(max - min)\n         \
    \                                    ^\n/tmp/tmprnzxtpa7.swift:11:46: note: found\
    \ candidate with type '(Builtin.FPIEEE64) -> Double'\n    let scaled: [Double]\
    \ = (numbers - min) / Double(max - min)\n                                    \
    \         ^\n/tmp/tmprnzxtpa7.swift:11:46: note: found candidate with type '(Int)\
    \ -> Double'\n    let scaled: [Double] = (numbers - min) / Double(max - min)\n\
    \                                             ^\n/tmp/tmprnzxtpa7.swift:11:46:\
    \ note: found candidate with type '(Float16) -> Double'\n    let scaled: [Double]\
    \ = (numbers - min) / Double(max - min)\n                                    \
    \         ^\n/tmp/tmprnzxtpa7.swift:11:46: note: found candidate with type '(Float)\
    \ -> Double'\n    let scaled: [Double] = (numbers - min) / Double(max - min)\n\
    \                                             ^\n/tmp/tmprnzxtpa7.swift:11:46:\
    \ note: found candidate with type '(Double) -> Double'\n    let scaled: [Double]\
    \ = (numbers - min) / Double(max - min)\n                                    \
    \         ^\n/tmp/tmprnzxtpa7.swift:11:46: note: found candidate with type '(Float80)\
    \ -> Double'\n    let scaled: [Double] = (numbers - min) / Double(max - min)\n\
    \                                             ^\n/tmp/tmprnzxtpa7.swift:11:37:\
    \ error: binary operator '-' cannot be applied to operands of type '[Double]'\
    \ and 'Duration'\n    let scaled: [Double] = (numbers - min) / Double(max - min)\n\
    \                            ~~~~~~~ ^ ~"
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty {\n        return numbers\n    }\n   \
    \ var smallest = numbers[0]\n    var largest = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let n = numbers[i]\n        if n != 0.0 {\n            if smallest\
    \ > n {\n                smallest = n\n            }\n            if largest <\
    \ n {\n                largest = n\n            }\n        }\n    }\n    var scale:\
    \ Double = 1.0 / largest\n    var rescaled: [Double] = []\n    for i in 1..<numbers.count\
    \ {\n        let n = numbers[i]\n        if n != 0.0 {\n            rescaled.append(n\
    \ * scale)\n        }\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp1saulzgx/tmp1saulzgx.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9547f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9544ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9544eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9544ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1saulzgx                        0x0000561fc67ea763 <unavailable> + 5987

    5    libc.so.6                          0x00002ae9549e0460 __libc_start_main +
    245

    6    tmp1saulzgx                        0x0000561fc67ea369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number / max - min)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp767mvzqz.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp767mvzqz.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty { return [] }\n\n    var sum: Double =\
    \ 0.0\n\n    for number in numbers {\n        sum += number\n    }\n\n    let\
    \ rescaled: [Double] = numbers.map { (number) -> Double in\n        number / sum\n\
    \    }\n\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpmyyd2gku/tmpmyyd2gku.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1f7494c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1f718bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1f718b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1f718a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmyyd2gku                        0x00005615d101d663 <unavailable> + 5731

    5    libc.so.6                          0x00002ac1f7680460 __libc_start_main +
    245

    6    tmpmyyd2gku                        0x00005615d101d269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled: [Double] = []\n    var min: Double = Double(1.0)\n\
    \    var max: Double = 0.0\n\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n        rescaled.append(max - number)\n    }\n\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpczjg5q20/tmpczjg5q20.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b71c68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b7195fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b7195f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b7195e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpczjg5q20                        0x0000561694723603 <unavailable> + 5635

    5    libc.so.6                          0x00002b0b71e54460 __libc_start_main +
    245

    6    tmpczjg5q20                        0x0000561694723209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty { return [] }\n    guard numbers.count\
    \ > 1 else { return numbers }\n\n    var smallest = numbers[0]\n    var largest\
    \ = numbers[0]\n\n    for i in 1..<numbers.count {\n        guard smallest > numbers[i]\
    \ else { return numbers }\n        guard largest < numbers[i] else { return numbers\
    \ }\n        if smallest > numbers[i] {\n            largest = numbers[i]\n  \
    \      } else {\n            smallest = numbers[i]\n        }\n    }\n\n    let\
    \ total: Double = smallest + largest\n    var result: [Double] = []\n    for n\
    \ in numbers {\n        result.append(n / total)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpht9sx7ts/tmpht9sx7ts.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a161e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a15ee0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a15ee0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a15edf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpht9sx7ts                        0x000055d212553883 <unavailable> + 6275

    5    libc.so.6                          0x00002b5a163d5460 __libc_start_main +
    245

    6    tmpht9sx7ts                        0x000055d212553489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    \n    for i in 0..<numbers.count\
    \ {\n        scaled.append(0.5 * (numbers[i] + numbers[i]))\n    }\n    \n   \
    \ return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpxtbh4m68/tmpxtbh4m68.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c6e334c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c6e02bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c6e02b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c6e02a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxtbh4m68                        0x000055df933106c3 <unavailable> + 5827

    5    libc.so.6                          0x00002b1c6e520460 __libc_start_main +
    245

    6    tmpxtbh4m68                        0x000055df933102c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 0
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min: Double = numbers.min()!\n    let max: Double = numbers.max()!\n\
    \    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let minNumber = numbers.min()!\n    let maxNumber = numbers.max()!\n\
    \    return numbers.map{number - minNumber}.map{number / maxNumber}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3wjohqnm.swift:9:24: error: cannot find 'number' in scope\n   \
    \ return numbers.map{number - minNumber}.map{number / maxNumber}\n           \
    \            ^~~~~~\n/tmp/tmp3wjohqnm.swift:9:48: error: cannot find 'number'\
    \ in scope\n    return numbers.map{number - minNumber}.map{number / maxNumber}\n\
    \                                               ^~~~~~\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var new_numbers = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for i in 0..<numbers.count {\n        new_numbers[i] = min(max(numbers[i],\
    \ 0), 1.0)\n    }\n    return new_numbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpf9v0rr3m/tmpf9v0rr3m.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b0648c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b033fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b033f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b033e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf9v0rr3m                        0x000055a75a4c4813 <unavailable> + 6163

    5    libc.so.6                          0x00002b71b0834460 __libc_start_main +
    245

    6    tmpf9v0rr3m                        0x000055a75a4c4419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    return\
    \ numbers.map({ x / max })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpli284_wt.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpli284_wt.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpli284_wt.swift:9:26: error: cannot find 'x' in\
    \ scope\n    return numbers.map({ x / max })\n                         ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var largest = numbers[0]\n    var smallest = numbers[0]\n\
    \    for num in numbers {\n        if num > largest {\n            largest = num\n\
    \        } else if smallest == 0.0 && num < smallest {\n            smallest =\
    \ num\n        }\n    }\n    var min: Double\n    if smallest > 0.0 {\n      \
    \  min = -1.0\n    } else {\n        min = 1.0\n    }\n    var max: Double\n \
    \   if largest < 1.0 {\n        max = 1.0\n    } else {\n        max = largest\n\
    \    }\n    var scaled: [Double] = []\n    for num in numbers {\n        scaled.append((num\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpf0cq06pk/tmpf0cq06pk.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aecb0bbbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aecb08b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aecb08b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aecb08b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf0cq06pk                        0x0000562833d6d653 <unavailable> + 5715

    5    libc.so.6                          0x00002aecb0da7460 __libc_start_main +
    245

    6    tmpf0cq06pk                        0x0000562833d6d259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map(numbers, { number in max(number, 0.0) / min(number,\
    \ 1.0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmwf6h576.swift:7:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers, { number in max(number, 0.0) / min(number, 1.0) })\n          \
    \ ^~~\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers != nil else {\n        return nil\n    }\n\n\
    \    guard numbers.count >= 2 else {\n        return nil\n    }\n\n    var smallest\
    \ = Double(numbers[0])\n    var largest = Double(numbers[0])\n    for number in\
    \ numbers {\n        if number < smallest {\n            smallest = number\n \
    \       }\n        if number > largest {\n            largest = number\n     \
    \   }\n    }\n\n    var result = [Double](count: numbers.count, repeatedValue:\
    \ 0.0)\n    for number in numbers {\n        result[0] = number\n        result[1]\
    \ = 1.0\n        let scaledNumber = result[1] * result[0] / smallest\n       \
    \ result[1] = scaledNumber\n        result[0] = largest\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzq_j4rs9.swift:7:19: warning: comparing non-optional value of type\
    \ '[Double]' to 'nil' always returns true\n    guard numbers != nil else {\n \
    \         ~~~~~~~ ^  ~~~\n/tmp/tmpzq_j4rs9.swift:8:16: error: 'nil' is incompatible\
    \ with return type '[Double]'\n        return nil\n               ^\n/tmp/tmpzq_j4rs9.swift:12:16:\
    \ error: 'nil' is incompatible with return type '[Double]'\n        return nil\n\
    \               ^\n/tmp/tmpzq_j4rs9.swift:26:18: error: no exact matches in call\
    \ to initializer \n    var result = [Double](count: numbers.count, repeatedValue:\
    \ 0.0)\n                 ^\n/tmp/tmpzq_j4rs9.swift:26:18: note: candidate has\
    \ partially matching parameter list (repeating: Double, count: Int)\n    var result\
    \ = [Double](count: numbers.count, repeatedValue: 0.0)\n                 ^\n/tmp/tmpzq_j4rs9.swift:26:18:\
    \ note: candidate has partially matching parameter list (repeating: Double, count:\
    \ Int)\n    var result = [Double](count: numbers.count, repeatedValue: 0.0)\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var total = 0.0\n    for value in numbers {\n        total\
    \ += value\n    }\n    var scaled = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for i in 0..<numbers.count {\n        scaled[i] = numbers[i] / total\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmphjvixeta/tmphjvixeta.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3426e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3423d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3423d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3423d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphjvixeta                        0x000055f5c514a893 <unavailable> + 6291

    5    libc.so.6                          0x00002ac3428ce460 __libc_start_main +
    245

    6    tmphjvixeta                        0x000055f5c514a499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = numbers.min()\n    var max: Double = numbers.max()\n\
    \    let range = max - min\n    return numbers.map{ number in\n        let rescaled\
    \ = number - min\n        return min + range * rescaled\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpf8nk9n7k.swift:7:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    var min: Double = numbers.min()\n\
    \                              ^\n/tmp/tmpf8nk9n7k.swift:7:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ var min: Double = numbers.min()\n                              ^\n         \
    \                           ?? <#default value#>\n/tmp/tmpf8nk9n7k.swift:7:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var min: Double = numbers.min()\n                              ^\n\
    \                                   !\n/tmp/tmpf8nk9n7k.swift:8:31: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   var max: Double = numbers.max()\n                              ^\n/tmp/tmpf8nk9n7k.swift:8:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    var max: Double = numbers.max()\n                              ^\n\
    \                                    ?? <#default value#>\n/tmp/tmpf8nk9n7k.swift:8:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var max: Double = numbers.max()\n                              ^\n\
    \                                   !\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.count < 2 {\n        return numbers\n    }\n\n\
    \    // find the smallest value\n    let min: Double = numbers.min()\n\n    //\
    \ find the biggest value\n    let max: Double = numbers.max()\n\n    var output:\
    \ [Double] = []\n    for number in numbers {\n        let newValue = (number -\
    \ min) / (max - min)\n        output.append(newValue)\n    }\n\n    return output\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpk3r63r9y.swift:12:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let min: Double = numbers.min()\n\
    \                              ^\n/tmp/tmpk3r63r9y.swift:12:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let min: Double = numbers.min()\n                              ^\n         \
    \                           ?? <#default value#>\n/tmp/tmpk3r63r9y.swift:12:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let min: Double = numbers.min()\n                              ^\n\
    \                                   !\n/tmp/tmpk3r63r9y.swift:15:31: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let max: Double = numbers.max()\n                              ^\n/tmp/tmpk3r63r9y.swift:15:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                    ?? <#default value#>\n/tmp/tmpk3r63r9y.swift:15:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                   !\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(1.0)\n    var max = Double(1.0)\n    for\
    \ num in numbers {\n        if num < min {\n            min = num\n        }\n\
    \        if num > max {\n            max = num\n        }\n    }\n    var scaled:\
    \ [Double] = []\n    for num in numbers {\n        scaled.append(min + (num -\
    \ min) * (max - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpvqkfrllv/tmpvqkfrllv.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac8888a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac88859fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac88859f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac88859e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvqkfrllv                        0x0000563236992603 <unavailable> + 5635

    5    libc.so.6                          0x00002ac888a94460 __libc_start_main +
    245

    6    tmpvqkfrllv                        0x0000563236992209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count >= 2 else { return numbers}\n    var\
    \ output: [Double] = []\n    var index = 0\n    var minVal = numbers[0]\n    var\
    \ maxVal = numbers[0]\n    for number in numbers {\n        guard number > 0 else\
    \ {\n            return numbers\n        }\n        if number < minVal {\n   \
    \         minVal = number\n        }\n        if number > maxVal {\n         \
    \   maxVal = number\n        }\n    }\n    \n    output.append(0)\n    output.append(maxVal\
    \ - minVal)\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpbpdpdnzj/tmpbpdpdnzj.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4aee866c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4aee55db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4aee55d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4aee55c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbpdpdnzj                        0x00005636c8ae36a3 <unavailable> + 5795

    5    libc.so.6                          0x00002b4aeea52460 __libc_start_main +
    245

    6    tmpbpdpdnzj                        0x00005636c8ae32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled = [Double]()\n    for i in 0 ..< numbers.count\
    \ {\n        rescaled[i] = (numbers[i] - min(numbers)) / (max(numbers) - min(numbers))\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwn4q88st.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        rescaled[i] = (numbers[i] - min(numbers)) / (max(numbers)\
    \ - min(numbers))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014071
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    var\
    \ rescaled_numbers = [Double](repeating: 0.0, count: numbers.count)\n    let largest\
    \ = numbers.max()\n    let smallest = numbers.min()\n    let range = largest -\
    \ smallest\n    var difference: Double = 0.0\n    for number in numbers {\n  \
    \      let current_diff = number - smallest\n        difference = current_diff\
    \ / range\n        rescaled_numbers = rescaled_numbers + [difference * range]\n\
    \    }\n    return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmabdrd5e.swift:11:25: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    let range = largest - smallest\n            \
    \    ~~~~~~~ ^ ~~~~~~~~\n/tmp/tmpmabdrd5e.swift:11:25: note: overloads for '-'\
    \ exist with these partially matching parameter lists: (Double, Double)\n    let\
    \ range = largest - smallest\n                        ^\n/tmp/tmpmabdrd5e.swift:14:37:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        let current_diff = number - smallest\n                   \
    \                 ^\n/tmp/tmpmabdrd5e.swift:14:37: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        let current_diff\
    \ = number - smallest\n                                    ^\n               \
    \                     (        ?? <#default value#>)\n/tmp/tmpmabdrd5e.swift:14:37:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let current_diff = number - smallest\n                      \
    \              ^\n                                            !\n/tmp/tmpmabdrd5e.swift:15:35:\
    \ error: cannot assign value of type 'Duration' to type 'Double'\n        difference\
    \ = current_diff / range\n                     ~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min: Double = numbers.min()\n    let max: Double = numbers.max()\n\
    \    return (0.0 - min) / (max - min)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1s9xt1k2.swift:7:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let min: Double = numbers.min()\n\
    \                              ^\n/tmp/tmp1s9xt1k2.swift:7:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let min: Double = numbers.min()\n                              ^\n         \
    \                           ?? <#default value#>\n/tmp/tmp1s9xt1k2.swift:7:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let min: Double = numbers.min()\n                              ^\n\
    \                                   !\n/tmp/tmp1s9xt1k2.swift:8:31: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let max: Double = numbers.max()\n                              ^\n/tmp/tmp1s9xt1k2.swift:8:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                    ?? <#default value#>\n/tmp/tmp1s9xt1k2.swift:8:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                   !\n/tmp/tmp1s9xt1k2.swift:9:24: error: cannot\
    \ convert return expression of type 'Double' to return type '[Double]'\n    return\
    \ (0.0 - min) / (max - min)\n           ~~~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let zero = numbers[0]\n    let one = numbers[numbers.count\
    \ - 1]\n    var rescaled: [Double] = []\n    for n in numbers {\n        rescaled.append(n\
    \ - zero)\n    }\n    rescaled.reverse()\n    for n in rescaled {\n        n =\
    \ n / one\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpeqxb63dc.swift:15:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = n / one\n        ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for i in numbers {\n        min\
    \ = min(min, i)\n        max = max(max, i)\n    }\n    if min == max {\n     \
    \   return numbers\n    }\n    var rescaled = [Double]()\n    for i in numbers\
    \ {\n        rescaled.append(i / max)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpp_gh6z8e.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_gh6z8e.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, i)\n              ^\n\
    /tmp/tmpp_gh6z8e.swift:11:15: error: cannot call value of non-function type 'Double'\n\
    \        max = max(max, i)\n              ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double.MaxValue\n    var max = Double.MinValue\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    guard min != Double.MaxValue && max != Double.MinValue else\
    \ { return numbers }\n    let minScaled = min / Float(min)\n    let maxScaled\
    \ = max / Float(max)\n    return numbers.map{ $0 / Float(maxScaled) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl8sk0xf6.swift:7:22: error: type 'Double' has no member 'MaxValue'\n\
    \    var min = Double.MaxValue\n              ~~~~~~ ^~~~~~~~\n/tmp/tmpl8sk0xf6.swift:8:22:\
    \ error: type 'Double' has no member 'MinValue'\n    var max = Double.MinValue\n\
    \              ~~~~~~ ^~~~~~~~\n/tmp/tmpl8sk0xf6.swift:13:25: error: type 'Double'\
    \ has no member 'MaxValue'\n    guard min != Double.MaxValue && max != Double.MinValue\
    \ else { return numbers }\n                 ~~~~~~ ^~~~~~~~\n/tmp/tmpl8sk0xf6.swift:13:51:\
    \ error: type 'Double' has no member 'MinValue'\n    guard min != Double.MaxValue\
    \ && max != Double.MinValue else { return numbers }\n                        \
    \                   ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty { return numbers }\n    \n    var smallest:\
    \ Double? = Double.nan\n    var largest: Double? = Double.nan\n    for number\
    \ in numbers {\n        guard let number = number else { continue }\n        \n\
    \        if smallest == Double.nan || number < smallest {\n            smallest\
    \ = number\n        }\n        if largest == Double.nan || number > largest {\n\
    \            largest = number\n        }\n    }\n    \n    var result: [Double]\
    \ = []\n    if let smallestNumber = smallest {\n        for number in numbers\
    \ {\n            if let number = number {\n                let normalizedNumber\
    \ = number / smallestNumber\n                result.append(normalizedNumber)\n\
    \            } else {\n                result.append(0)\n            }\n     \
    \   }\n    }\n    if let largestNumber = largest {\n        for number in numbers\
    \ {\n            if let number = number {\n                let normalizedNumber\
    \ = number / largestNumber\n                result.append(normalizedNumber)\n\
    \            } else {\n                result.append(1)\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpweleebib.swift:12:15: error: initializer for conditional binding\
    \ must have Optional type, not 'Double'\n        guard let number = number else\
    \ { continue }\n              ^            ~~~~~~\n/tmp/tmpweleebib.swift:14:47:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        if smallest == Double.nan || number < smallest {\n       \
    \                                       ^\n/tmp/tmpweleebib.swift:14:47: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if smallest == Double.nan || number < smallest {\n                  \
    \                            ^\n                                             \
    \          ?? <#default value#>\n/tmp/tmpweleebib.swift:14:47: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ smallest == Double.nan || number < smallest {\n                            \
    \                  ^\n                                                      !\n\
    /tmp/tmpweleebib.swift:17:46: error: value of optional type 'Double?' must be\
    \ unwrapped to a value of type 'Double'\n        if largest == Double.nan || number\
    \ > largest {\n                                             ^\n/tmp/tmpweleebib.swift:17:46:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if largest == Double.nan || number > largest {\n            \
    \                                 ^\n                                        \
    \             ?? <#default value#>\n/tmp/tmpweleebib.swift:17:46: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ largest == Double.nan || number > largest {\n                              \
    \               ^\n                                                    !\n/tmp/tmpweleebib.swift:25:16:\
    \ error: initializer for conditional binding must have Optional type, not 'Double'\n\
    \            if let number = number {\n               ^            ~~~~~~\n/tmp/tmpweleebib.swift:35:16:\
    \ error: initializer for conditional binding must have Optional t"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaledNumbers = [Double]()\n    guard numbers.count >=\
    \ 2 else { return scaledNumbers }\n    let smallest = numbers.min()\n    let largest\
    \ = numbers.max()\n\n    var scale = smallest / largest\n    for number in numbers\
    \ {\n        scaledNumbers.append(number * scale)\n        scale *= largest\n\
    \    }\n    return scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl1nflbgb.swift:12:26: error: binary operator '/' cannot be applied\
    \ to two 'Double?' operands\n    var scale = smallest / largest\n            \
    \    ~~~~~~~~ ^ ~~~~~~~\n/tmp/tmpl1nflbgb.swift:12:26: note: overloads for '/'\
    \ exist with these partially matching parameter lists: (Double, Double)\n    var\
    \ scale = smallest / largest\n                         ^\n/tmp/tmpl1nflbgb.swift:15:18:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        scale *= largest\n                 ^\n/tmp/tmpl1nflbgb.swift:15:18:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        scale *= largest\n                 ^\n                      \
    \   ?? <#default value#>\n/tmp/tmpl1nflbgb.swift:15:18: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        scale *=\
    \ largest\n                 ^\n                        !\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { number -> Double in\n        let min\
    \ = min(numbers)\n        let max = max(numbers)\n        return min + (max -\
    \ min) * (number - min) / (max - min)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4mty8_i2.swift:8:30: error: missing argument for parameter #2 in\
    \ call\n        let min = min(numbers)\n                             ^\n     \
    \                        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp4mty8_i2.swift:8:19: error: global function\
    \ 'min' requires that '[Double]' conform to 'Comparable'\n        let min = min(numbers)\n\
    \                  ^\nSwift.min:1:24: note: where 'T' = '[Double]'\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let smallest = numbers.min()\n    let largest = numbers.max()\n\
    \n    // TODO: Make this more accurate by rounding instead of truncating.\n  \
    \  let scale: Double = largest-smallest\n\n    return numbers.map { $0 / (scale\
    \ as Double) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4mu9d_ba.swift:11:25: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let scale: Double = largest-smallest\n\
    \                        ^\n/tmp/tmp4mu9d_ba.swift:8:9: note: short-circuit using\
    \ 'guard' to exit this function early if the optional value contains 'nil'\n \
    \   let largest = numbers.max()\n        ^\n    guard                       else\
    \ { return <#default value#> }\n/tmp/tmp4mu9d_ba.swift:8:27: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    let largest\
    \ = numbers.max()\n                          ^\n                             \
    \   ?? <#default value#>\n/tmp/tmp4mu9d_ba.swift:8:27: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    let largest\
    \ = numbers.max()\n                          ^\n                             \
    \  !\n/tmp/tmp4mu9d_ba.swift:11:25: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    let scale: Double = largest-smallest\n\
    \                        ^\n                        (       ?? <#default value#>)\n\
    /tmp/tmp4mu9d_ba.swift:11:25: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    let scale: Double = largest-smallest\n\
    \                        ^\n                               !\n/tmp/tmp4mu9d_ba.swift:11:33:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    let scale: Double = largest-smallest\n                       \
    \         ^\n/tmp/tmp4mu9d_ba.swift:7:9: note: short-circuit using 'guard' to\
    \ exit this function early if the optional value contains 'nil'\n    let smallest\
    \ = numbers.min()\n        ^\n    guard                        else { return <#default\
    \ value#> }\n/tmp/tmp4mu9d_ba.swift:7:28: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let smallest = numbers.min()\n\
    \                           ^\n                                 ?? <#default value#>\n\
    /tmp/tmp4mu9d_ba.swift:7:28: note: force-unwrap using '!' to abort execution if\
    \ the "
  stdout: ''
  timestamp: 1660013971
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return []\n    }\n\
    \    let smallest = min(numbers)\n    let largest = max(numbers)\n    var scaledNumbers\
    \ = [Double]()\n    for i in 0..<numbers.count {\n        let newNumber = numbers[i]\
    \ - smallest\n        scaledNumbers.append(newNumber / largest)\n    }\n    return\
    \ scaledNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmwxoacjh.swift:10:31: error: missing argument for parameter #2\
    \ in call\n    let smallest = min(numbers)\n                              ^\n\
    \                              , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpmwxoacjh.swift:11:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmpmwxoacjh.swift:15:40: error:\
    \ cannot convert value of type 'Duration' to expected argument type 'Double'\n\
    \        scaledNumbers.append(newNumber / largest)\n                         \
    \              ^\n"
  stdout: ''
  timestamp: 1660013971
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n\
    \n    for i in 1 ..< numbers.count {\n        if min > numbers[i] {\n        \
    \    min = numbers[i]\n        }\n        if max < numbers[i] {\n            max\
    \ = numbers[i]\n        }\n    }\n\n    let range = max - min\n    let scaled\
    \ = numbers.map { $0 - min / range }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp045od9lp/tmp045od9lp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b880a57dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b880a274b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b880a274988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b880a2737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp045od9lp                        0x0000557d00058773 <unavailable> + 6003

    5    libc.so.6                          0x00002b880a769460 __libc_start_main +
    245

    6    tmp045od9lp                        0x0000557d00058379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.leastFiniteMagnitude\n    for number in numbers {\n   \
    \     min = min(min, number)\n        max = max(max, number)\n    }\n    var result:\
    \ [Double] = []\n    for (i, number) in numbers.enumerated() {\n        let delta\
    \ = number-min\n        result.append(min + (max - min)*delta/(i+1))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4nznescf.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4nznescf.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp4nznescf.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmp4nznescf.swift:16:9:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n        result.append(min\
    \ + (max - min)*delta/(i+1))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013999
- exit_code: 0
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = numbers[0]\n    var max = numbers[0]\n\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       } else if number > max {\n            max = number\n        }\n    }\n\
    \n    var scaled: [Double] = []\n\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map(numbers, Double(min(0.0, max(0.0, numbers[indices.min()]))))\
    \ / Double(max(0.0, numbers[indices.max()]))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpt56pj_b3.swift:7:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers, Double(min(0.0, max(0.0, numbers[indices.min()])))) / Double(max(0.0,\
    \ numbers[indices.max()]))\n           ^~~\n/tmp/tmpt56pj_b3.swift:7:58: error:\
    \ cannot find 'indices' in scope\n    return map(numbers, Double(min(0.0, max(0.0,\
    \ numbers[indices.min()])))) / Double(max(0.0, numbers[indices.max()]))\n    \
    \                                                     ^~~~~~~\n/tmp/tmpt56pj_b3.swift:7:103:\
    \ error: cannot find 'indices' in scope\n    return map(numbers, Double(min(0.0,\
    \ max(0.0, numbers[indices.min()])))) / Double(max(0.0, numbers[indices.max()]))\n\
    \                                                                            \
    \                          ^~~~~~~\n/tmp/tmpt56pj_b3.swift:7:77: error: no '/'\
    \ candidates produce the expected contextual result type '[Double]'\n    return\
    \ map(numbers, Double(min(0.0, max(0.0, numbers[indices.min()])))) / Double(max(0.0,\
    \ numbers[indices.max()]))\n                                                 \
    \                           ^\nSwift.Duration:4:24: note: '/' produces 'Duration',\
    \ not the expected contextual result type '[Double]'\n    public static func /\
    \ (lhs: Duration, rhs: Double) -> Duration\n                       ^\nSwift.Double:5:24:\
    \ note: '/' produces 'Double', not the expected contextual result type '[Double]'\n\
    \    public static func / (lhs: Double, rhs: Double) -> Double\n             \
    \          ^\nSwift.FloatingPoint:29:17: note: '/' produces 'Double', not the\
    \ expected contextual result type '[Double]'\n    static func / (lhs: Self, rhs:\
    \ Self) -> Self\n                ^\nSwift.Duration:4:24: note: '/' produces 'Duration',\
    \ not the expected contextual result type '[Double]'\n    public static func /\
    \ (lhs: Duration, rhs: Double) -> Duration\n                       ^\nSwift.Double:5:24:\
    \ note: '/' produces 'Double', not the expected contextual result type '[Double]'\n\
    \    public static func / (lhs: Double, rhs: Double) -> Double\n             \
    \          ^\nSwift.FloatingPoint:29:17: note: '/' produces 'Double', not the"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty { return [] }\n    var min = Double.greatestFiniteMagnitude\n\
    \    var max = Double.lowestFiniteMagnitude\n    for number in numbers {\n   \
    \     min = (min < number) ? min : number\n        max = (max > number) ? max\
    \ : number\n    }\n    let scaledNumbers = numbers.map { number in\n        return\
    \ ((max - min) * (number - min) / Float(max - min) + min)\n    }\n    return scaledNumbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp6tkn8uo3.swift:9:22: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max = Double.lowestFiniteMagnitude\n              ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013979
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n\n    for value in numbers {\n       \
    \ let diff = max - min\n        min = min(min, value)\n        max = max(max,\
    \ value)\n        scaled.append(min+diff*Double((value - min)/diff))\n    }\n\
    \    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpv45oa0ln.swift:13:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, value)\n              ^\n/tmp/tmpv45oa0ln.swift:14:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ value)\n              ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        smallest = min(number, smallest)\n     \
    \   largest = max(number, largest)\n    }\n    return numbers.map { $0 / (largest\
    \ - smallest) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmptvo6kr0_/tmptvo6kr0_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b80125f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80122f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80122f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80122ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptvo6kr0_                        0x000055eeff06c753 <unavailable> + 5971

    5    libc.so.6                          0x00002b80127e5460 __libc_start_main +
    245

    6    tmptvo6kr0_                        0x000055eeff06c359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map({ $0 - $0 < $0 ? $0 - $0 : 0 })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpvrr6h1u_/tmpvrr6h1u_.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e85193c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e84e8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e84e8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e84e897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvrr6h1u_                        0x00005651d05354e3 <unavailable> + 5347

    5    libc.so.6                          0x00002b0e8537f460 __libc_start_main +
    245

    6    tmpvrr6h1u_                        0x00005651d05350e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // Find the max & min in the array\n    var min: Double =\
    \ -1.0\n    var max: Double = 1.0\n    for x in numbers {\n        if x < min\
    \ {\n            min = x\n        }\n        if x > max {\n            max = x\n\
    \        }\n    }\n\n    // Find the midpoint, use as new scale value\n    var\
    \ mid = (min + max) / 2.0\n    var scale = (max - min) / mid\n\n    // Scale all\
    \ the elements\n    var rescaled: [Double] = []\n    for x in numbers {\n    \
    \    rescaled.append(x * scale)\n    }\n\n    return rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpkstc6ju2/tmpkstc6ju2.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab9e232c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab9df29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab9df29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab9df287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkstc6ju2                        0x0000558f4ed36603 <unavailable> + 5635

    5    libc.so.6                          0x00002aab9e41e460 __libc_start_main +
    245

    6    tmpkstc6ju2                        0x0000558f4ed36209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    return\
    \ numbers.map {\n        $0 - min(0.0, $0)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpjgnmwy3f/tmpjgnmwy3f.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fec19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1febe92b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1febe92988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1febe917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjgnmwy3f                        0x000055aa9679e5d3 <unavailable> + 5587

    5    libc.so.6                          0x00002b1fec387460 __libc_start_main +
    245

    6    tmpjgnmwy3f                        0x000055aa9679e1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var result: [Double] = []\n    if numbers.isEmpty { return\
    \ result }\n    \n    let total: Double = numbers.reduce(0, {$0 + $1})\n    \n\
    \    for i in 0..<numbers.count {\n        result.append(numbers[i] / total)\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpsnbzsys1/tmpsnbzsys1.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b94f0abec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b94f07b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b94f07b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94f07b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsnbzsys1                        0x00005599703b37d3 <unavailable> + 6099

    5    libc.so.6                          0x00002b94f0caa460 __libc_start_main +
    245

    6    tmpsnbzsys1                        0x00005599703b33d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var new_numbers = numbers\n    for i in 1...numbers.count\
    \ {\n        new_numbers[i] = new_numbers[i-1] * (numbers.count - i)\n    }\n\
    \    return new_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpgczc3paq.swift:9:60: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Double'\n        new_numbers[i] = new_numbers[i-1]\
    \ * (numbers.count - i)\n                                                    \
    \       ^\n                                            Double(            )\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = min(numbers)\n    let max = max(numbers)\n    var\
    \ result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n    }\n    var currentMax = max\n    for number in result {\n      \
    \  if number > 0 {\n            number /= currentMax\n        }\n        currentMax\
    \ = min(currentMax, number)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpshpbdo49.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpshpbdo49.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min: Double = Double.greatestFiniteMagnitude\n    var\
    \ max: Double = Double.lowestFiniteMagnitude\n    for num in numbers {\n     \
    \   min = num < min ? num : min\n        max = num > max ? num : max\n    }\n\n\
    \    var scaled: [Double] = []\n    for num in numbers {\n        scaled.append((num\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3t5jgaen.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { number in\n        let scaledNumber\
    \ = number / min(numbers)\n        return scaledNumber\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphorvtl20.swift:8:48: error: missing argument for parameter #2 in\
    \ call\n        let scaledNumber = number / min(numbers)\n                   \
    \                            ^\n                                             \
    \  , <#Double#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmphorvtl20.swift:8:41: error: cannot convert value of type '[Double]'\
    \ to expected argument type 'Double'\n        let scaledNumber = number / min(numbers)\n\
    \                                        ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n    \n    let minX = numbers.min()\n    let maxX = numbers.max()\n   \
    \ \n    var result = [Double](repeating: 0.0, count: numbers.count)\n    var factor\
    \ = 0.0\n    for i in 0..<numbers.count {\n        let currentNumber = numbers[i]\n\
    \        factor = currentNumber / minX\n        result[i] = factor\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp462qf03v.swift:18:34: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        factor = currentNumber / minX\n\
    \                                 ^\n/tmp/tmp462qf03v.swift:18:34: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     factor = currentNumber / minX\n                                 ^\n    \
    \                             (    ?? <#default value#>)\n/tmp/tmp462qf03v.swift:18:34:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        factor = currentNumber / minX\n                             \
    \    ^\n                                     !\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count >= 2 else {\n        return numbers\n\
    \    }\n    \n    var min = Double.leastNormalMagnitude\n    var max = Double.greatestNormalMagnitude\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    \n    var new_numbers = [Double](repeating: min, count: numbers.count)\n\
    \    for number in numbers {\n        new_numbers[new_numbers.index(of: number)]\
    \ = number\n    }\n    \n    return new_numbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpa7u_iy4l.swift:12:22: error: type 'Double' has no member 'greatestNormalMagnitude'\n\
    \    var max = Double.greatestNormalMagnitude\n              ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa7u_iy4l.swift:24:33: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        new_numbers[new_numbers.index(of: number)] = number\n \
    \                               ^\n/tmp/tmpa7u_iy4l.swift:24:33: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     new_numbers[new_numbers.index(of: number)] = number\n                  \
    \              ^\n                                                  ?? <#default\
    \ value#>\n/tmp/tmpa7u_iy4l.swift:24:33: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        new_numbers[new_numbers.index(of:\
    \ number)] = number\n                                ^\n                     \
    \                            !\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // The largest number must be positive\n    var maxValue\
    \ = max(numbers)\n    if maxValue == 0.0 { return [1.0] }\n    \n    // The smallest\
    \ number must be positive\n    var minValue = min(numbers)\n    if minValue ==\
    \ 0.0 { return [maxValue] }\n\n    let zero = Double(maxValue)\n    let one =\
    \ Double(minValue)\n    \n    var numberScaled: [Double] = Array()\n    \n   \
    \ for number in numbers {\n        let scaledValue = (number - minValue) / (maxValue\
    \ - minValue)\n        if scaledValue > 1.0 { scaledValue = 1.0 }\n        if\
    \ scaledValue < 0.0 { scaledValue = 0.0 }\n        numberScaled.append(scaledValue)\n\
    \    }\n\n    guard numberScaled.count > 0 else { return [zero] }\n    \n    //\
    \ The largest number must be less than 1\n    if max(numberScaled) > 1.0 { return\
    \ [one] }\n    \n    return numberScaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps1t71psd.swift:8:31: error: missing argument for parameter #2 in\
    \ call\n    var maxValue = max(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.max:1:24: note: 'max' declared\
    \ here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmps1t71psd.swift:12:31: error: missing argument\
    \ for parameter #2 in call\n    var minValue = min(numbers)\n                \
    \              ^\n                              , <#[Double]#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmps1t71psd.swift:30:26:\
    \ error: binary operator '>' cannot be applied to operands of type 'UInt8' and\
    \ 'Double'\n    if max(numberScaled) > 1.0 { return [one] }\n       ~~~~~~~~~~~~~~~~~\
    \ ^ ~~~\n/tmp/tmps1t71psd.swift:30:26: note: overloads for '>' exist with these\
    \ partially matching parameter lists: (Int, Int), (Int16, Int16), (Int32, Int32),\
    \ (Int64, Int64), (Int8, Int8), (TaskPriority, TaskPriority), (UInt, UInt), (UInt16,\
    \ UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8, UInt8)\n    if max(numberScaled)\
    \ > 1.0 { return [one] }\n                         ^\n/tmp/tmps1t71psd.swift:30:24:\
    \ error: missing argument for parameter #2 in call\n    if max(numberScaled) >\
    \ 1.0 { return [one] }\n                       ^\n                       , <#UInt8#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = Double.min\n    var max = Double.max\n    for number\
    \ in numbers {\n        var currentMin = min\n        var currentMax = max\n \
    \       if number > 0 {\n            currentMin = 0\n        }\n        if number\
    \ < 0 {\n            currentMax = 0\n        }\n        min = min(currentMin,\
    \ min)\n        max = max(currentMax, max)\n    }\n    return numbers.map { number\
    \ in\n        return number - min / max\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpi486m9j8.swift:7:22: error: type 'Double' has no member 'min'\n\
    \    var min = Double.min\n              ~~~~~~ ^~~\n/tmp/tmpi486m9j8.swift:8:22:\
    \ error: type 'Double' has no member 'max'\n    var max = Double.max\n       \
    \       ~~~~~~ ^~~\n/tmp/tmpi486m9j8.swift:22:29: error: cannot convert value\
    \ of type 'Duration' to expected argument type 'Double'\n        return number\
    \ - min / max\n                            ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { $0 / min(max($0, Double(0.0)), Double(1.0))\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0,\
    \ 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0,\
    \ 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25,\
    \ 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0])\
    \ == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0,\
    \ 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmplmniepip/tmplmniepip.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83df92fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83df626b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83df626988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83df6257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplmniepip                        0x000055dbe90c55d3 <unavailable> + 5587

    5    libc.so.6                          0x00002b83dfb1b460 __libc_start_main +
    245

    6    tmplmniepip                        0x000055dbe90c51d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var scaled: [Double] = []\n    for i in 0 ..< numbers.count\
    \ {\n        scaled.append(Double(i))\n    }\n    \n    var smallest = Double(numbers[0])\n\
    \    var largest = Double(numbers[numbers.count - 1])\n    \n    for i in 0 ..<\
    \ numbers.count {\n        switch largest.compare(&numbers[i]) {\n        case\
    \ .OrderedAscending: largest = numbers[i] default:\n            smallest = numbers[i]\n\
    \        }\n    }\n    \n    for i in 0 ..< numbers.count {\n        scaled[i]\
    \ -= smallest\n    }\n    \n    for i in 0 ..< numbers.count {\n        scaled[i]\
    \ /= largest\n    }\n    \n    for i in 0 ..< numbers.count {\n        scaled[i]\
    \ = -scaled[i]\n    }\n    \n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyc7kokm3.swift:16:24: error: value of type 'Double' has no member\
    \ 'compare'\n        switch largest.compare(&numbers[i]) {\n               ~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpyc7kokm3.swift:16:32: error: cannot pass immutable value as\
    \ inout argument: 'numbers' is a 'let' constant\n        switch largest.compare(&numbers[i])\
    \ {\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n\n    let xMin = Double(numbers.min()!)\n    let xMax = Double(numbers.max()!)\n\
    \    var scaledNumbers = [Double](repeating: 0.0, count: numbers.count)\n\n  \
    \  for i in 0..<numbers.count {\n        scaledNumbers[i] = numbers[i] / xMax\
    \ - xMin * Double(i) / Double(numbers.count)\n    }\n\n    return scaledNumbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmphyc0ejcl/tmphyc0ejcl.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aedd93a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aedd90a0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aedd90a0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aedd909f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphyc0ejcl                        0x0000559db28fc873 <unavailable> + 6259

    5    libc.so.6                          0x00002aedd9595460 __libc_start_main +
    245

    6    tmphyc0ejcl                        0x0000559db28fc479 <unavailable> + 5241

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: 0
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let min = Double(numbers.min()!)\n    let max = Double(numbers.max()!)\n\
    \    var rescaled: [Double] = []\n    for number in numbers {\n        let newNumber\
    \ = (number - min)/(max - min)\n        rescaled.append(newNumber)\n    }\n  \
    \  return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return map(numbers, &(numbers[0] / max(numbers)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8wsrrvow.swift:7:12: error: cannot find 'map' in scope\n    return\
    \ map(numbers, &(numbers[0] / max(numbers)))\n           ^~~\n/tmp/tmp8wsrrvow.swift:7:51:\
    \ error: missing argument for parameter #2 in call\n    return map(numbers, &(numbers[0]\
    \ / max(numbers)))\n                                                  ^\n    \
    \                                              , <#Double#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmp8wsrrvow.swift:7:44: error:\
    \ cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \    return map(numbers, &(numbers[0] / max(numbers)))\n                     \
    \                      ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var rescaled_numbers: [Double] = []\n    for n in numbers\
    \ {\n        if n <= 0.0 {\n            rescaled_numbers.append(0.0)\n       \
    \ } else {\n            rescaled_numbers.append(1.0 / n)\n        }\n    }\n \
    \   return rescaled_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp9g8cor9m/tmp9g8cor9m.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b121cc46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b121c93db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b121c93d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b121c93c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9g8cor9m                        0x0000562caf913603 <unavailable> + 5635

    5    libc.so.6                          0x00002b121ce32460 __libc_start_main +
    245

    6    tmp9g8cor9m                        0x0000562caf913209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map{($0 - min(numbers) + 1.0) / (max(numbers)\
    \ - min(numbers) + 1.0)}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkvplrtr6.swift:7:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return numbers.map{($0 - min(numbers) + 1.0) / (max(numbers)\
    \ - min(numbers) + 1.0)}\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014165
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    if numbers.isEmpty {\n        return numbers;\n    }\n  \
    \  let max = numbers.max();\n    let min = numbers.min();\n    let delta = max\
    \ - min;\n    let scale: Double = delta / numbers.count;\n    return numbers.map({\
    \ (value: Double) -> Double in\n        value * scale\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpz0sf95rp.swift:12:21: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    let delta = max - min;\n                ~~~ ^\
    \ ~~~\n/tmp/tmpz0sf95rp.swift:12:21: note: overloads for '-' exist with these\
    \ partially matching parameter lists: (Double, Double)\n    let delta = max -\
    \ min;\n                    ^\n/tmp/tmpz0sf95rp.swift:13:31: error: cannot convert\
    \ value of type 'Int' to specified type 'Double'\n    let scale: Double = delta\
    \ / numbers.count;\n                        ~~~~~~^~~~~~~~~~~~~~~\n          \
    \              Double(              )\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let sortedNumbers = numbers.sorted()\n    let smallest =\
    \ sortedNumbers.min()!\n    let largest = sortedNumbers.max()!\n    return sortedNumbers.map({\
    \ $0 / (largest - smallest) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpsqqx7p0o/tmpsqqx7p0o.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af58a79ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af58a495b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af58a495988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af58a4947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsqqx7p0o                        0x000055f0852ed6e3 <unavailable> + 5859

    5    libc.so.6                          0x00002af58a98a460 __libc_start_main +
    245

    6    tmpsqqx7p0o                        0x000055f0852ed2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    guard\
    \ numbers.first >= numbers.last else { return numbers }\n\n    var scaled: [Double]\
    \ = Array(repeating: 0.0, count: numbers.count)\n    scaled[0] = numbers[0]\n\n\
    \    for i in 1..<numbers.count {\n        scaled[i] = scaled[i - 1] + (numbers[i]\
    \ - scaled[i - 1])\n    }\n\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmputrl1on9.swift:8:25: error: binary operator '>=' cannot be applied\
    \ to two 'Double?' operands\n    guard numbers.first >= numbers.last else { return\
    \ numbers }\n          ~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    return numbers.map { x / min(max(x, Double(0.0)), Double(1.0))\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0,\
    \ 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0,\
    \ 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25,\
    \ 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0])\
    \ == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0,\
    \ 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjtiexl7i.swift:7:26: error: cannot find 'x' in scope\n    return\
    \ numbers.map { x / min(max(x, Double(0.0)), Double(1.0)) }\n                \
    \         ^\n/tmp/tmpjtiexl7i.swift:7:38: error: cannot find 'x' in scope\n  \
    \  return numbers.map { x / min(max(x, Double(0.0)), Double(1.0)) }\n        \
    \                             ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    precondition(numbers.count > 0, \"rescale_to_unit: numbers\
    \ array cannot be empty\")\n\n    var max = 0\n    var min = Double.infinity\n\
    \    for i in 0..<numbers.count {\n        let n = numbers[i]\n        max = n\
    \ > max ? n : max\n        min = n < min ? n : min\n    }\n\n    return numbers.map\
    \ { n -> Double in\n        n / max - min * 0.5\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5a2u4qur.swift:13:15: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        max = n > max ? n : max\n         \
    \     ^\n              Int( )\n/tmp/tmp5a2u4qur.swift:13:25: error: result values\
    \ in '? :' expression have mismatching types 'Double' and 'Int'\n        max =\
    \ n > max ? n : max\n                        ^\n                        Int( )\n\
    /tmp/tmp5a2u4qur.swift:18:13: error: cannot convert value of type 'Int' to expected\
    \ argument type 'Double'\n        n / max - min * 0.5\n            ^\n       \
    \     Double( )\n"
  stdout: ''
  timestamp: 1660013973
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    guard numbers.count > 1 else { return numbers }\n    let\
    \ min = min(numbers)\n    let max = max(numbers)\n    guard min >= 0, max <= 1\
    \ else { return numbers }\n    let range = max - min\n    return (0..<numbers.count).map\
    \ { i in\n        numbers[i] - min + range / 2.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsaslwkzc.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpsaslwkzc.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013973
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    var min = numbers.min()\n    var max = numbers.max()\n  \
    \  var diff: Double\n    if min == 0 {\n        min = -1000\n    }\n    if max\
    \ == 0 {\n        max = 1000\n    }\n    diff = max - min\n    var scale: Double\
    \ = 1.0\n    if diff < 1000 {\n        scale = diff / 1000\n    }\n    else {\n\
    \        scale = diff / 1000\n        scale = Double(scale) / Double(max)\n  \
    \      scale = scale * (max - min)\n    }\n    var result = [Double]()\n    for\
    \ number in numbers {\n        result.append(number * scale)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpubb3cnzo.swift:16:16: error: binary operator '-' cannot be applied\
    \ to two 'Double?' operands\n    diff = max - min\n           ~~~ ^ ~~~\n/tmp/tmpubb3cnzo.swift:16:16:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double)\n    diff = max - min\n               ^\n/tmp/tmpubb3cnzo.swift:23:40:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        scale = Double(scale) / Double(max)\n                    \
    \                   ^\n/tmp/tmpubb3cnzo.swift:23:40: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        scale =\
    \ Double(scale) / Double(max)\n                                       ^\n    \
    \                                       ?? <#default value#>\n/tmp/tmpubb3cnzo.swift:23:40:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        scale = Double(scale) / Double(max)\n                       \
    \                ^\n                                          !\n/tmp/tmpubb3cnzo.swift:24:30:\
    \ error: binary operator '-' cannot be applied to two 'Double?' operands\n   \
    \     scale = scale * (max - min)\n                         ~~~ ^ ~~~\n/tmp/tmpubb3cnzo.swift:24:30:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double)\n        scale = scale * (max - min)\n                    \
    \         ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let smallestNumber = min(numbers)\n    let largestNumber\
    \ = max(numbers)\n\n    var scaledArray: [Double] = []\n\n    for number in numbers\
    \ {\n        scaledArray.append(number * (largestNumber - smallestNumber) + smallestNumber)\n\
    \    }\n\n    return scaledArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpmthuhuii.swift:7:37: error: missing argument for parameter #2 in\
    \ call\n    let smallestNumber = min(numbers)\n                              \
    \      ^\n                                    , <#[Double]#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpmthuhuii.swift:8:36:\
    \ error: missing argument for parameter #2 in call\n    let largestNumber = max(numbers)\n\
    \                                   ^\n                                   , <#[Double]#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013972
- exit_code: -4
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    let max: Double = numbers.max()!\n    let min: Double = numbers.min()!\n\
    \    let range = max - min\n    var result: [Double] = []\n    for i in numbers\
    \ {\n        result.append(i * range / max * 0.5)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpqzdao1k0/tmpqzdao1k0.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b62993c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b6268ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b6268a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b626897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqzdao1k0                        0x000055d8f6737793 <unavailable> + 6035

    5    libc.so.6                          0x00002b5b62b7f460 __libc_start_main +
    245

    6    tmpqzdao1k0                        0x000055d8f6737399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013972
- exit_code: 1
  program: "\n/// Given array of numbers (of at least two elements), apply a linear\
    \ transform to that array,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n/// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double])\
    \ -> [Double] {\n    // Find the min and max of the numbers to normalize the values\n\
    \    var max = numbers.max()\n    var min = numbers.min()\n    // Scale the values\
    \ between 0 and 1\n    var normalized = [Double]()\n    for i in 0..<numbers.count\
    \ {\n        // Normalize the value\n        let normalizedVal = numbers[i] -\
    \ min\n        normalized.append(normalizedVal / (max - min))\n    }\n    return\
    \ normalized\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0jn30e9e.swift:14:42: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        let normalizedVal = numbers[i]\
    \ - min\n                                         ^\n/tmp/tmp0jn30e9e.swift:14:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let normalizedVal = numbers[i] - min\n                      \
    \                   ^\n                                         (   ?? <#default\
    \ value#>)\n/tmp/tmp0jn30e9e.swift:14:42: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        let normalizedVal =\
    \ numbers[i] - min\n                                         ^\n             \
    \                               !\n/tmp/tmp0jn30e9e.swift:15:48: error: binary\
    \ operator '-' cannot be applied to two 'Double?' operands\n        normalized.append(normalizedVal\
    \ / (max - min))\n                                           ~~~ ^ ~~~\n/tmp/tmp0jn30e9e.swift:15:48:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double)\n        normalized.append(normalizedVal / (max - min))\n \
    \                                              ^\n"
  stdout: ''
  timestamp: 1660013972
