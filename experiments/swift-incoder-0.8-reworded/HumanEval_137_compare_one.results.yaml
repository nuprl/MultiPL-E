language: swift
name: HumanEval_137_compare_one
results:
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(i), .doubleValue(let\
    \ d):\n        return d > b ? .stringValue(b) : .stringValue(a)\n    case .stringValue(a),\
    \ .intValue(b):\n        return a > b ? .stringValue(b) : .stringValue(a)\n  \
    \  }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvlxk3ekr.swift:23:41: error: 'd' must be bound in every pattern\n\
    \    case .intValue(i), .doubleValue(let d):\n                               \
    \         ^\n/tmp/tmpvlxk3ekr.swift:23:20: error: cannot find 'i' in scope\n \
    \   case .intValue(i), .doubleValue(let d):\n                   ^\n/tmp/tmpvlxk3ekr.swift:25:23:\
    \ error: expression pattern of type 'Value' cannot match values of type 'String'\n\
    \    case .stringValue(a), .intValue(b):\n                      ^\n/tmp/tmpvlxk3ekr.swift:25:23:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case .stringValue(a), .intValue(b):\n             \
    \         ^\n/tmp/tmpvlxk3ekr.swift:25:37: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case .stringValue(a), .intValue(b):\n\
    \                                    ^\n/tmp/tmpvlxk3ekr.swift:24:16: error: cannot\
    \ find 'd' in scope\n        return d > b ? .stringValue(b) : .stringValue(a)\n\
    \               ^\n/tmp/tmpvlxk3ekr.swift:24:18: error: binary operator '>' cannot\
    \ be applied to operands of type '_' and 'Value'\n        return d > b ? .stringValue(b)\
    \ : .stringValue(a)\n               ~ ^ ~\n/tmp/tmpvlxk3ekr.swift:24:37: error:\
    \ cannot convert value of type 'Value' to expected argument type 'String'\n  \
    \      return d > b ? .stringValue(b) : .stringValue(a)\n                    \
    \                ^\n/tmp/tmpvlxk3ekr.swift:24:55: error: cannot convert value\
    \ of type 'Value' to expected argument type 'String'\n        return d > b ? .stringValue(b)\
    \ : .stringValue(a)\n                                                      ^\n\
    /tmp/tmpvlxk3ekr.swift:26:18: error: referencing operator function '>' on 'Comparable'\
    \ requires that 'Value' conform to 'Comparable'\n        return a > b ? .stringValue(b)\
    \ : .stringValue(a)\n                 ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmpvlxk3ekr.swift:26:18:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \        return a > b ? .stringVa"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(_), .intValue(_)):\n\
    \        return .intValue(_)\n    case (.intValue(_), .doubleValue(_)):\n    \
    \    return .doubleValue(_)\n    case (.doubleValue(_), .intValue(_)):\n     \
    \   return .doubleValue(_)\n    case (.doubleValue(_), .doubleValue(_)):\n   \
    \     return .doubleValue(_)\n    case (.stringValue(_), .stringValue(_)):\n \
    \       return .stringValue(_)\n    case (.stringValue(_), .intValue(_)):\n  \
    \      return .stringValue(_)\n    case (.stringValue(_), .doubleValue(_)):\n\
    \        return .stringValue(_)\n    default:\n        return nil\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp1mxl22mv.swift:24:26: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        return .intValue(_)\n           \
    \              ^\n/tmp/tmp1mxl22mv.swift:26:29: error: '_' can only appear in\
    \ a pattern or on the left side of an assignment\n        return .doubleValue(_)\n\
    \                            ^\n/tmp/tmp1mxl22mv.swift:28:29: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n        return .doubleValue(_)\n\
    \                            ^\n/tmp/tmp1mxl22mv.swift:30:29: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n        return .doubleValue(_)\n\
    \                            ^\n/tmp/tmp1mxl22mv.swift:32:29: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n        return .stringValue(_)\n\
    \                            ^\n/tmp/tmp1mxl22mv.swift:34:29: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n        return .stringValue(_)\n\
    \                            ^\n/tmp/tmp1mxl22mv.swift:36:29: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n        return .stringValue(_)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is larger\n    case .intValue(_):\n\
    \        switch b { // b is larger\n        case .intValue(_):\n            return\
    \ .intValue(_)\n        case .doubleValue(_):\n            return .doubleValue(_)\n\
    \        case .stringValue(_):\n            return .stringValue(_)\n        }\n\
    \    case .doubleValue(_):\n        switch b { // b is larger\n        case .intValue(_):\n\
    \            return .doubleValue(_)\n        case .doubleValue(_):\n         \
    \   return .doubleValue(_)\n        case .stringValue(_):\n            return\
    \ .stringValue(_)\n        case .stringValue(_):\n            return .stringValue(_)\n\
    \        }\n    case .stringValue(_):\n        switch b { // b is larger\n   \
    \     case .intValue(_):\n            return .stringValue(_)\n        case .doubleValue(_):\n\
    \            return .stringValue(_)\n        case .stringValue(_):\n         \
    \   return .stringValue(_)\n        case .stringValue(_):\n            return\
    \ .stringValue(_)\n        }\n    }\n    return nil // they're equal\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4hti187e.swift:26:30: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n            return .intValue(_)\n       \
    \                      ^\n/tmp/tmp4hti187e.swift:28:33: error: '_' can only appear\
    \ in a pattern or on the left side of an assignment\n            return .doubleValue(_)\n\
    \                                ^\n/tmp/tmp4hti187e.swift:30:33: error: '_' can\
    \ only appear in a pattern or on the left side of an assignment\n            return\
    \ .stringValue(_)\n                                ^\n/tmp/tmp4hti187e.swift:35:33:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            return .doubleValue(_)\n                                ^\n/tmp/tmp4hti187e.swift:37:33:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            return .doubleValue(_)\n                                ^\n/tmp/tmp4hti187e.swift:39:33:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            return .stringValue(_)\n                                ^\n/tmp/tmp4hti187e.swift:41:33:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            return .stringValue(_)\n                                ^\n/tmp/tmp4hti187e.swift:40:14:\
    \ warning: case is already handled by previous patterns; consider removing it\n\
    \        case .stringValue(_):\n             ^~~~~~~~~~~~~~~\n/tmp/tmp4hti187e.swift:46:33:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            return .stringValue(_)\n                                ^\n/tmp/tmp4hti187e.swift:48:33:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            return .stringValue(_)\n                                ^\n/tmp/tmp4hti187e.swift:50:33:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            return .stringValue(_)\n                                ^\n/tmp/tmp4hti187e.swift:52:33:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \            return .st"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue)\n        case .doubleValue(_):\n            return .intValue(a.doubleValue\
    \ > b.doubleValue)\n        case .stringValue(_):\n            return .intValue(a.stringValue\
    \ > b.stringValue)\n        }\n    case .doubleValue(_):\n        switch b {\n\
    \        case .intValue(_):\n            return .doubleValue(a.doubleValue > b.doubleValue)\n\
    \        case .doubleValue(_):\n            return .intValue(a.doubleValue > b.doubleValue)\n\
    \        case .stringValue(_):\n            return .intValue(a.stringValue > b.stringValue)\n\
    \        }\n    case .stringValue(_):\n        switch b {\n        case .intValue(_):\n\
    \            return .stringValue(a.stringValue > b.stringValue)\n        case\
    \ .doubleValue(_):\n            return .stringValue(a.stringValue > b.stringValue)\n\
    \        case .stringValue(_):\n            return .intValue(a.stringValue > b.stringValue)\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp6eosl0ef.swift:26:41: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n            return .intValue(a.intValue > b.intValue)\n\
    \                                        ^\n/tmp/tmp6eosl0ef.swift:26:30: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue)\n                             ^\n       \
    \                      Value\n/tmp/tmp6eosl0ef.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                        ^\n/tmp/tmp6eosl0ef.swift:26:41:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            return .intValue(a.intValue > b.intValue)\n         \
    \                               ^\n/tmp/tmp6eosl0ef.swift:26:41: note: required\
    \ by referencing operator function '>' on 'Comparable' where 'Self' = '(Int) ->\
    \ Value'\n            return .intValue(a.intValue > b.intValue)\n            \
    \                            ^\n/tmp/tmp6eosl0ef.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue)\n                                          ^\n               \
    \                           Value\n/tmp/tmp6eosl0ef.swift:28:44: error: cannot\
    \ convert value of type 'Bool' to expected argument type 'Int'\n            return\
    \ .intValue(a.doubleValue > b.doubleValue)\n                                 \
    \          ^\n/tmp/tmp6eosl0ef.swift:28:30: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n            return .intValue(a.doubleValue >\
    \ b.doubleValue)\n                             ^\n                           \
    \  Value\n/tmp/tmp6eosl0ef.swift:28:44: error: type '(Double) -> Value' cannot\
    \ conform to 'Comparable'\n            return .intValue(a.doubleValue > b.doubleValue)\n\
    \                                           ^\n/tmp/tmp6eosl0ef.swift:28:44: note:\
    \ only concrete types such as structs, enums and classes can conform to protocols\n\
    \            return "
  stdout: ''
  timestamp: 1660013421
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aIsInt = a.hashValue % Int(1) == Int(0)\n\
    \    let bIsInt = b.hashValue % Int(1) == Int(0)\n    if aIsInt && bIsInt {\n\
    \        return a\n    }\n    \n    if aIsInt {\n        return b\n    }\n   \
    \ \n    if bIsInt {\n        return a\n    }\n    \n    if a.hashValue == b.hashValue\
    \ {\n        return nil\n    }\n    \n    if a.hashValue > b.hashValue {\n   \
    \     return a\n    }\n    \n    return b\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp7wtw6gzc/tmp7wtw6gzc.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab353c72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab353969b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab353969988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3539687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7wtw6gzc                        0x00005566402b0af6 <unavailable> + 6902

    5    libc.so.6                          0x00002ab353e5e460 __libc_start_main +
    245

    6    tmp7wtw6gzc                        0x00005566402b0539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    var a = a\n    var b = b\n    \n   \
    \ if a.isInt {\n        if b.isInt {\n            if a.intValue > b.intValue {\n\
    \                return a\n            } else {\n                return b\n  \
    \          }\n        } else if b.isDouble {\n            if a.intValue > b.doubleValue\
    \ {\n                return a\n            } else {\n                return b\n\
    \            }\n        } else {\n            return nil\n        }\n    } else\
    \ if a.isDouble {\n        if b.isInt {\n            if a.doubleValue > b.intValue\
    \ {\n                return a\n            } else {\n                return b\n\
    \            }\n        } else if b.isDouble {\n            if a.doubleValue >\
    \ b.doubleValue {\n                return a\n            } else {\n          \
    \      return b\n            }\n        } else {\n            return nil\n   \
    \     }\n    } else {\n        if b.isInt {\n            return a\n        } else\
    \ if b.isDouble {\n            return b\n        } else {\n            return\
    \ nil\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpaut4gw3_.swift:26:10: error: value of type 'Value' has no member\
    \ 'isInt'\n    if a.isInt {\n       ~ ^~~~~\n/tmp/tmpaut4gw3_.swift:27:14: error:\
    \ value of type 'Value' has no member 'isInt'\n        if b.isInt {\n        \
    \   ~ ^~~~~\n/tmp/tmpaut4gw3_.swift:28:27: error: binary operator '>' cannot be\
    \ applied to two '(Int) -> Value' operands\n            if a.intValue > b.intValue\
    \ {\n               ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpaut4gw3_.swift:33:21: error:\
    \ value of type 'Value' has no member 'isDouble'\n        } else if b.isDouble\
    \ {\n                  ~ ^~~~~~~~\n/tmp/tmpaut4gw3_.swift:34:27: error: binary\
    \ operator '>' cannot be applied to operands of type '(Int) -> Value' and '(Double)\
    \ -> Value'\n            if a.intValue > b.doubleValue {\n               ~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpaut4gw3_.swift:42:17: error: value of type 'Value'\
    \ has no member 'isDouble'\n    } else if a.isDouble {\n              ~ ^~~~~~~~\n\
    /tmp/tmpaut4gw3_.swift:43:14: error: value of type 'Value' has no member 'isInt'\n\
    \        if b.isInt {\n           ~ ^~~~~\n/tmp/tmpaut4gw3_.swift:44:30: error:\
    \ binary operator '>' cannot be applied to operands of type '(Double) -> Value'\
    \ and '(Int) -> Value'\n            if a.doubleValue > b.intValue {\n        \
    \       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmpaut4gw3_.swift:49:21: error: value\
    \ of type 'Value' has no member 'isDouble'\n        } else if b.isDouble {\n \
    \                 ~ ^~~~~~~~\n/tmp/tmpaut4gw3_.swift:50:30: error: binary operator\
    \ '>' cannot be applied to two '(Double) -> Value' operands\n            if a.doubleValue\
    \ > b.doubleValue {\n               ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmpaut4gw3_.swift:59:14:\
    \ error: value of type 'Value' has no member 'isInt'\n        if b.isInt {\n \
    \          ~ ^~~~~\n/tmp/tmpaut4gw3_.swift:61:21: error: value of type 'Value'\
    \ has no member 'isDouble'\n        } else if b.isDouble {\n                 \
    \ ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case a < b:\n    case .intValue(_\
    \ as! Int): return .doubleValue(Double(a as! Int))\n    case .doubleValue(a as!\
    \ Double): return .intValue(Int((b as Value).doubleValue()))\n    case .stringValue(a\
    \ as! String): return .doubleValue(Double(a as! Double))\n    case .stringValue(b\
    \ as String): return nil\n    default: break\n    }\n    switch b { // case b\
    \ < a:\n    case .intValue(_ as! Int): return .doubleValue(Double(b as! Int))\n\
    \    case .doubleValue(a as! Double): return .intValue(Int((a as Value).doubleValue()))\n\
    \    case .stringValue(a as! String): return .doubleValue(Double(b as! Double))\n\
    \    case .stringValue(b as String): return nil\n    default: break\n    }\n \
    \   return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp39nquvxi.swift:23:20: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n    case .intValue(_ as! Int): return .doubleValue(Double(a\
    \ as! Int))\n                   ^\n/tmp/tmp39nquvxi.swift:24:25: warning: cast\
    \ from 'Value' to unrelated type 'Double' always fails\n    case .doubleValue(a\
    \ as! Double): return .intValue(Int((b as Value).doubleValue()))\n           \
    \           ~ ^   ~~~~~~\n/tmp/tmp39nquvxi.swift:25:25: warning: cast from 'Value'\
    \ to unrelated type 'String' always fails\n    case .stringValue(a as! String):\
    \ return .doubleValue(Double(a as! Double))\n                      ~ ^   ~~~~~~\n\
    /tmp/tmp39nquvxi.swift:26:25: warning: 'as' test is always true\n    case .stringValue(b\
    \ as String): return nil\n                        ^\n/tmp/tmp39nquvxi.swift:26:23:\
    \ error: expression pattern of type 'Value' cannot match values of type 'String'\n\
    \    case .stringValue(b as String): return nil\n                      ^\n/tmp/tmp39nquvxi.swift:26:23:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case .stringValue(b as String): return nil\n      \
    \                ^\n/tmp/tmp39nquvxi.swift:23:61: warning: cast from 'Value' to\
    \ unrelated type 'Int' always fails\n    case .intValue(_ as! Int): return .doubleValue(Double(a\
    \ as! Int))\n                                                          ~ ^   ~~~\n\
    /tmp/tmp39nquvxi.swift:24:55: error: initializer 'init(_:)' requires that 'Value'\
    \ conform to 'BinaryInteger'\n    case .doubleValue(a as! Double): return .intValue(Int((b\
    \ as Value).doubleValue()))\n                                                \
    \      ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n    @inlinable\
    \ public init<T>(_ source: T) where T : BinaryInteger\n                      ^\n\
    /tmp/tmp39nquvxi.swift:24:62: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n    case .doubleValue(a as! Double): return .intValue(Int((b\
    \ as Value).doubleValue()))\n                                                \
    \          ~~~^~~~~~~~~\n                     "
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var best = a\n    switch a {\n    case .intValue(nil),\
    \ _:\n    case .doubleValue(_):\n        best = b\n    default:\n        best\
    \ = b\n    }\n    switch b {\n    case .intValue(Int64.min), _:\n    case .doubleValue(Double(Int64.min)),\
    \ .intValue(Int64.min):\n        best = a\n    case .doubleValue(Double(Int64.max)),\
    \ .intValue(Int64.max):\n        best = b\n    case .stringValue(\"\"), .intValue(0),\
    \ .doubleValue(0):\n        return nil\n    default:\n        return best\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphc9_7hst.swift:24:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case .intValue(nil), _:\n    ^~~~~~~~~~~~~~~~~~~~~~~\n\
    \                            break\n/tmp/tmphc9_7hst.swift:31:5: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n    case .intValue(Int64.min),\
    \ _:\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                                  break\n\
    /tmp/tmphc9_7hst.swift:24:20: warning: type 'Int' is not optional, value can never\
    \ be nil; this is an error in Swift 6\n    case .intValue(nil), _:\n         \
    \          ^\n/tmp/tmphc9_7hst.swift:25:10: warning: case is already handled by\
    \ previous patterns; consider removing it\n    case .doubleValue(_):\n       \
    \  ^~~~~~~~~~~~~~~\n/tmp/tmphc9_7hst.swift:31:26: error: expression pattern of\
    \ type 'Int64' cannot match values of type 'Int'\n    case .intValue(Int64.min),\
    \ _:\n                   ~~~~~~^~~\n/tmp/tmphc9_7hst.swift:32:59: error: expression\
    \ pattern of type 'Int64' cannot match values of type 'Int'\n    case .doubleValue(Double(Int64.min)),\
    \ .intValue(Int64.min):\n                                                    ~~~~~~^~~\n\
    /tmp/tmphc9_7hst.swift:34:59: error: expression pattern of type 'Int64' cannot\
    \ match values of type 'Int'\n    case .doubleValue(Double(Int64.max)), .intValue(Int64.max):\n\
    \                                                    ~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(int(a)), .intValue(int(b)):\n\
    \        return intValue(a) > intValue(b)\n    case .doubleValue(double(a)), .doubleValue(double(b)):\n\
    \        return doubleValue(a) > doubleValue(b)\n    case .stringValue(string(a)),\
    \ .stringValue(string(b)):\n        return stringValue(a) > stringValue(b)\n \
    \   case .boolValue(true), .boolValue(false):\n        return boolValue(a) > boolValue(b)\n\
    \    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdxy4ole5.swift:23:20: error: cannot find 'int' in scope\n    case\
    \ .intValue(int(a)), .intValue(int(b)):\n                   ^~~\n/tmp/tmpdxy4ole5.swift:23:39:\
    \ error: cannot find 'int' in scope\n    case .intValue(int(a)), .intValue(int(b)):\n\
    \                                      ^~~\n/tmp/tmpdxy4ole5.swift:25:23: error:\
    \ cannot find 'double' in scope\n    case .doubleValue(double(a)), .doubleValue(double(b)):\n\
    \                      ^~~~~~\n/tmp/tmpdxy4ole5.swift:25:48: error: cannot find\
    \ 'double' in scope\n    case .doubleValue(double(a)), .doubleValue(double(b)):\n\
    \                                               ^~~~~~\n/tmp/tmpdxy4ole5.swift:27:23:\
    \ error: cannot find 'string' in scope\n    case .stringValue(string(a)), .stringValue(string(b)):\n\
    \                      ^~~~~~\n/tmp/tmpdxy4ole5.swift:27:48: error: cannot find\
    \ 'string' in scope\n    case .stringValue(string(a)), .stringValue(string(b)):\n\
    \                                               ^~~~~~\n/tmp/tmpdxy4ole5.swift:29:11:\
    \ error: type 'Value' has no member 'boolValue'\n    case .boolValue(true), .boolValue(false):\n\
    \         ~^~~~~~~~~\n/tmp/tmpdxy4ole5.swift:29:29: error: type 'Value' has no\
    \ member 'boolValue'\n    case .boolValue(true), .boolValue(false):\n        \
    \                   ~^~~~~~~~~\n/tmp/tmpdxy4ole5.swift:24:16: error: cannot find\
    \ 'intValue' in scope\n        return intValue(a) > intValue(b)\n            \
    \   ^~~~~~~~\n/tmp/tmpdxy4ole5.swift:24:30: error: cannot find 'intValue' in scope\n\
    \        return intValue(a) > intValue(b)\n                             ^~~~~~~~\n\
    /tmp/tmpdxy4ole5.swift:24:28: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n        return intValue(a) > intValue(b)\n \
    \              ~~~~~~~~~~~~^~~~~~~~~~~~~\n/tmp/tmpdxy4ole5.swift:26:16: error:\
    \ cannot find 'doubleValue' in scope\n        return doubleValue(a) > doubleValue(b)\n\
    \               ^~~~~~~~~~~\n/tmp/tmpdxy4ole5.swift:26:33: error: cannot find\
    \ 'doubleValue' in scope\n        return doubleValue(a) > doubleValue(b)\n   \
    \                             ^~~~~~~~~~~\n/tmp/tm"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(v): return\
    \ b == .intValue(v)\n    case .doubleValue(v): return b == .doubleValue(v)\n \
    \   case .stringValue(v): return b == .stringValue(v)\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8aice3w3.swift:23:20: error: cannot find 'v' in scope\n    case\
    \ .intValue(v): return b == .intValue(v)\n                   ^\n/tmp/tmp8aice3w3.swift:24:23:\
    \ error: cannot find 'v' in scope\n    case .doubleValue(v): return b == .doubleValue(v)\n\
    \                      ^\n/tmp/tmp8aice3w3.swift:25:23: error: cannot find 'v'\
    \ in scope\n    case .stringValue(v): return b == .stringValue(v)\n          \
    \            ^\n/tmp/tmp8aice3w3.swift:23:46: error: cannot find 'v' in scope\n\
    \    case .intValue(v): return b == .intValue(v)\n                           \
    \                  ^\n/tmp/tmp8aice3w3.swift:23:33: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n    case .intValue(v): return\
    \ b == .intValue(v)\n                              ~~^~~~~~~~~~~~~~~\n/tmp/tmp8aice3w3.swift:24:52:\
    \ error: cannot find 'v' in scope\n    case .doubleValue(v): return b == .doubleValue(v)\n\
    \                                                   ^\n/tmp/tmp8aice3w3.swift:24:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .doubleValue(v): return b == .doubleValue(v)\n                     \
    \            ~~^~~~~~~~~~~~~~~~~~\n/tmp/tmp8aice3w3.swift:25:52: error: cannot\
    \ find 'v' in scope\n    case .stringValue(v): return b == .stringValue(v)\n \
    \                                                  ^\n/tmp/tmp8aice3w3.swift:25:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .stringValue(v): return b == .stringValue(v)\n                     \
    \            ~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_): return\
    \ b == .intValue(a.intValue)\n    case .doubleValue(_): return b == .doubleValue(a.doubleValue)\n\
    \    case .stringValue(_): return b == .stringValue(a.stringValue)\n    }\n  \
    \  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxrvsz8c5.swift:23:33: error: cannot convert return expression of\
    \ type 'Bool' to return type 'Value?'\n    case .intValue(_): return b == .intValue(a.intValue)\n\
    \                              ~~^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxrvsz8c5.swift:23:48:\
    \ error: cannot convert value of type '(Int) -> Value' to expected argument type\
    \ 'Int'\n    case .intValue(_): return b == .intValue(a.intValue)\n          \
    \                                     ^\n/tmp/tmpxrvsz8c5.swift:23:46: error:\
    \ enum case 'intValue' cannot be used as an instance member\n    case .intValue(_):\
    \ return b == .intValue(a.intValue)\n                                        \
    \     ^\n                                             Value\n/tmp/tmpxrvsz8c5.swift:24:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .doubleValue(_): return b == .doubleValue(a.doubleValue)\n         \
    \                        ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxrvsz8c5.swift:24:54:\
    \ error: cannot convert value of type '(Double) -> Value' to expected argument\
    \ type 'Double'\n    case .doubleValue(_): return b == .doubleValue(a.doubleValue)\n\
    \                                                     ^\n/tmp/tmpxrvsz8c5.swift:24:52:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    case\
    \ .doubleValue(_): return b == .doubleValue(a.doubleValue)\n                 \
    \                                  ^\n                                       \
    \            Value\n/tmp/tmpxrvsz8c5.swift:25:36: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n    case .stringValue(_):\
    \ return b == .stringValue(a.stringValue)\n                                 ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxrvsz8c5.swift:25:54: error: cannot convert value of type '(String) ->\
    \ Value' to expected argument type 'String'\n    case .stringValue(_): return\
    \ b == .stringValue(a.stringValue)\n                                         \
    \            ^\n/tmp/tmpxrvsz8c5.swift:25:52: error: enum case 'stringValue' cannot\
    \ be used as an instance member\n    case .string"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard let aint = a?.intValue as? Int,\n  \
    \      let bint = b?.intValue as? Int,\n        aint == bint else { return nil\
    \ }\n    \n    guard let adouble = a?.doubleValue as? Double,\n        let bdouble\
    \ = b?.doubleValue as? Double,\n        adouble == bdouble else { return nil }\n\
    \    \n    guard let astr = a?.stringValue as? String,\n        let bstr = b?.stringValue\
    \ as? String,\n        aint == Int(bstr) else { return nil }\n    \n    return\
    \ a.stringValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpex1w1unh.swift:22:23: error: cannot use optional chaining on non-optional\
    \ value of type 'Value'\n    guard let aint = a?.intValue as? Int,\n         \
    \            ~^\n                      \n/tmp/tmpex1w1unh.swift:22:23: error:\
    \ enum case 'intValue' cannot be used as an instance member\n    guard let aint\
    \ = a?.intValue as? Int,\n                     ~^\n                     Value\n\
    /tmp/tmpex1w1unh.swift:23:21: error: cannot use optional chaining on non-optional\
    \ value of type 'Value'\n        let bint = b?.intValue as? Int,\n           \
    \        ~^\n                    \n/tmp/tmpex1w1unh.swift:23:21: error: enum case\
    \ 'intValue' cannot be used as an instance member\n        let bint = b?.intValue\
    \ as? Int,\n                   ~^\n                   Value\n/tmp/tmpex1w1unh.swift:26:26:\
    \ error: cannot use optional chaining on non-optional value of type 'Value'\n\
    \    guard let adouble = a?.doubleValue as? Double,\n                        ~^\n\
    \                         \n/tmp/tmpex1w1unh.swift:26:26: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n    guard let adouble = a?.doubleValue\
    \ as? Double,\n                        ~^\n                        Value\n/tmp/tmpex1w1unh.swift:27:24:\
    \ error: cannot use optional chaining on non-optional value of type 'Value'\n\
    \        let bdouble = b?.doubleValue as? Double,\n                      ~^\n\
    \                       \n/tmp/tmpex1w1unh.swift:27:24: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n        let bdouble = b?.doubleValue as?\
    \ Double,\n                      ~^\n                      Value\n/tmp/tmpex1w1unh.swift:30:23:\
    \ error: cannot use optional chaining on non-optional value of type 'Value'\n\
    \    guard let astr = a?.stringValue as? String,\n                     ~^\n  \
    \                    \n/tmp/tmpex1w1unh.swift:30:23: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n    guard let astr = a?.stringValue as?\
    \ String,\n                     ~^\n                     Value\n/tmp/tmpex1w1unh.swift:31:21:\
    \ error: cannot use optional chaining on non-optional valu"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as Value? {\n    case let .intValue(ai):\n\
    \        switch b as Value? {\n        case let .intValue(bi):\n            return\
    \ bi > ai ? b : a\n        case let .doubleValue(ba):\n            return ba >\
    \ ai ? b : a\n        case let .stringValue(sa):\n            return sa > ai ?\
    \ b : a\n        }\n    case let .doubleValue(da):\n        switch b as Value?\
    \ {\n        case let .intValue(bi):\n            return bi > da ? b : a\n   \
    \     case let .doubleValue(ba):\n            return ba > da ? b : a\n       \
    \ case let .stringValue(sa):\n            return sa > da ? b : a\n        }\n\
    \    case let .stringValue(sa):\n        switch b as Value? {\n        case let\
    \ .intValue(bi):\n            return bi > sa ? b : a\n        case let .doubleValue(ba):\n\
    \            return ba > sa ? b : a\n        case let .stringValue(sa):\n    \
    \        return sa > sa ? b : a\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkka8uf6t.swift:28:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n            return ba > ai ? b : a\n      \
    \             ^\n                   Int( )\n/tmp/tmpkka8uf6t.swift:30:20: error:\
    \ cannot convert value of type 'String' to expected argument type 'Int'\n    \
    \        return sa > ai ? b : a\n                   ^\n/tmp/tmpkka8uf6t.swift:24:9:\
    \ error: switch must be exhaustive\n        switch b as Value? {\n        ^\n\
    /tmp/tmpkka8uf6t.swift:24:9: note: add missing case: '.none'\n        switch b\
    \ as Value? {\n        ^\n/tmp/tmpkka8uf6t.swift:35:25: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n            return bi\
    \ > da ? b : a\n                        ^\n                        Int( )\n/tmp/tmpkka8uf6t.swift:39:23:\
    \ error: binary operator '>' cannot be applied to operands of type 'String' and\
    \ 'Double'\n            return sa > da ? b : a\n                   ~~ ^ ~~\n/tmp/tmpkka8uf6t.swift:33:9:\
    \ error: switch must be exhaustive\n        switch b as Value? {\n        ^\n\
    /tmp/tmpkka8uf6t.swift:33:9: note: add missing case: '.none'\n        switch b\
    \ as Value? {\n        ^\n/tmp/tmpkka8uf6t.swift:44:25: error: cannot convert\
    \ value of type 'String' to expected argument type 'Int'\n            return bi\
    \ > sa ? b : a\n                        ^\n/tmp/tmpkka8uf6t.swift:46:23: error:\
    \ binary operator '>' cannot be applied to operands of type 'Double' and 'String'\n\
    \            return ba > sa ? b : a\n                   ~~ ^ ~~\n/tmp/tmpkka8uf6t.swift:42:9:\
    \ error: switch must be exhaustive\n        switch b as Value? {\n        ^\n\
    /tmp/tmpkka8uf6t.swift:42:9: note: add missing case: '.none'\n        switch b\
    \ as Value? {\n        ^\n/tmp/tmpkka8uf6t.swift:22:5: error: switch must be exhaustive\n\
    \    switch a as Value? {\n    ^\n/tmp/tmpkka8uf6t.swift:22:5: note: add missing\
    \ case: '.none'\n    switch a as Value? {\n    ^\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a.variable_type, b.variable_type)\
    \ {\n    case (.integer, .integer):\n        return a.intValue > b.intValue\n\
    \    case (.float, .float):\n        return a.doubleValue > b.doubleValue\n  \
    \  case (.string, .string):\n        return a.stringValue > b.stringValue\n  \
    \  default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpndnebxk4.swift:22:15: error: value of type 'Value' has no member\
    \ 'variable_type'\n    switch (a.variable_type, b.variable_type) {\n         \
    \   ~ ^~~~~~~~~~~~~\n/tmp/tmpndnebxk4.swift:22:32: error: value of type 'Value'\
    \ has no member 'variable_type'\n    switch (a.variable_type, b.variable_type)\
    \ {\n                             ~ ^~~~~~~~~~~~~\n/tmp/tmpndnebxk4.swift:24:27:\
    \ error: binary operator '>' cannot be applied to two '(Int) -> Value' operands\n\
    \        return a.intValue > b.intValue\n               ~~~~~~~~~~ ^ ~~~~~~~~~~\n\
    /tmp/tmpndnebxk4.swift:24:27: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n        return a.intValue > b.intValue\n   \
    \            ~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpndnebxk4.swift:26:30: error: binary\
    \ operator '>' cannot be applied to two '(Double) -> Value' operands\n       \
    \ return a.doubleValue > b.doubleValue\n               ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n\
    /tmp/tmpndnebxk4.swift:26:30: error: cannot convert return expression of type\
    \ 'Bool' to return type 'Value?'\n        return a.doubleValue > b.doubleValue\n\
    \               ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpndnebxk4.swift:28:30: error:\
    \ binary operator '>' cannot be applied to two '(String) -> Value' operands\n\
    \        return a.stringValue > b.stringValue\n               ~~~~~~~~~~~~~ ^\
    \ ~~~~~~~~~~~~~\n/tmp/tmpndnebxk4.swift:28:30: error: cannot convert return expression\
    \ of type 'Bool' to return type 'Value?'\n        return a.stringValue > b.stringValue\n\
    \               ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Check that the given values are convertible\
    \ to the variable type\n    switch a {\n    case .intValue(aInt) where aInt >\
    \ b:\n        return b\n    case .doubleValue(aDouble) where aDouble > b:\n  \
    \      return b\n    case .stringValue(aString) where aString > b {\n        if\
    \ aString == \".\" {\n            return .doubleValue(Double(aString.characters.last\
    \ ?? \"\"))\n        }\n        return b\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjt14i31r.swift:33:6: error: expected ':' after 'case'\n    }\n\
    \     ^\n/tmp/tmpjt14i31r.swift:57:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpjt14i31r.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpjt14i31r.swift:24:20:\
    \ error: cannot find 'aInt' in scope\n    case .intValue(aInt) where aInt > b:\n\
    \                   ^~~~\n/tmp/tmpjt14i31r.swift:24:32: error: cannot find 'aInt'\
    \ in scope\n    case .intValue(aInt) where aInt > b:\n                       \
    \        ^~~~\n/tmp/tmpjt14i31r.swift:24:37: error: binary operator '>' cannot\
    \ be applied to operands of type '_' and 'Value'\n    case .intValue(aInt) where\
    \ aInt > b:\n                               ~~~~ ^ ~\n/tmp/tmpjt14i31r.swift:26:23:\
    \ error: cannot find 'aDouble' in scope\n    case .doubleValue(aDouble) where\
    \ aDouble > b:\n                      ^~~~~~~\n/tmp/tmpjt14i31r.swift:26:38: error:\
    \ cannot find 'aDouble' in scope\n    case .doubleValue(aDouble) where aDouble\
    \ > b:\n                                     ^~~~~~~\n/tmp/tmpjt14i31r.swift:26:46:\
    \ error: binary operator '>' cannot be applied to operands of type '_' and 'Value'\n\
    \    case .doubleValue(aDouble) where aDouble > b:\n                         \
    \            ~~~~~~~ ^ ~\n/tmp/tmpjt14i31r.swift:28:23: error: cannot find 'aString'\
    \ in scope\n    case .stringValue(aString) where aString > b {\n             \
    \         ^~~~~~~\n/tmp/tmpjt14i31r.swift:28:38: error: cannot find 'aString'\
    \ in scope\n    case .stringValue(aString) where aString > b {\n             \
    \                        ^~~~~~~\n/tmp/tmpjt14i31r.swift:29:12: error: cannot\
    \ find 'aString' in scope\n        if aString == \".\" {\n           ^~~~~~~\n\
    /tmp/tmpjt14i31r.swift:30:40: error: cannot find 'aString' in scope\n        \
    \    return .doubleValue(Double(aString.characters.last ?? \"\"))\n          \
    \                             ^~~~~~~\n/tmp/"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a , b.type {\n    case .intValue, .doubleValue:\n\
    \        return b\n    case .stringValue:\n        if a == \"-\" {\n         \
    \   return b\n        }\n        if b == \"-\" {\n            return a\n     \
    \   }\n        \n        let aNumber = NSNumberFormatter().number(from: a)\n \
    \       let bNumber = NSNumberFormatter().number(from: b)\n        \n        guard\
    \ let aDouble = aNumber.doubleValue else { return nil }\n        guard let bDouble\
    \ = bNumber.doubleValue else { return nil }\n        \n        if aDouble < bDouble\
    \ {\n            return a\n        }\n        \n        return b\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8x1zmb2r.swift:22:14: error: expected '{' after 'switch' subject\
    \ expression\n    switch a , b.type {\n             ^\n/tmp/tmp8x1zmb2r.swift:22:13:\
    \ error: consecutive statements on a line must be separated by ';'\n    switch\
    \ a , b.type {\n            ^\n            ;\n/tmp/tmp8x1zmb2r.swift:22:14: error:\
    \ expected expression\n    switch a , b.type {\n             ^\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == .intValue(b) { return a }\n    if\
    \ a == .doubleValue(b) { return a }\n    if a == .stringValue(b) { return a }\n\
    \n    if b == .intValue(a) { return b }\n    if b == .doubleValue(a) { return\
    \ b }\n    if b == .stringValue(a) { return b }\n\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpddmn8gc2.swift:22:23: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n    if a == .intValue(b) { return a }\n   \
    \                   ^\n/tmp/tmpddmn8gc2.swift:23:26: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Double'\n    if a == .doubleValue(b)\
    \ { return a }\n                         ^\n/tmp/tmpddmn8gc2.swift:24:26: error:\
    \ cannot convert value of type 'Value' to expected argument type 'String'\n  \
    \  if a == .stringValue(b) { return a }\n                         ^\n/tmp/tmpddmn8gc2.swift:26:23:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Int'\n\
    \    if b == .intValue(a) { return b }\n                      ^\n/tmp/tmpddmn8gc2.swift:27:26:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \    if b == .doubleValue(a) { return b }\n                         ^\n/tmp/tmpddmn8gc2.swift:28:26:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \    if b == .stringValue(a) { return b }\n                         ^\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_):\n            return a\n        case .intValue(_),\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_), .intValue(_):\n\
    \            return b\n        case .stringValue(_), .doubleValue(_):\n      \
    \      return a\n        default:\n            return nil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpugweujs2.swift:23:24: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        case .intValue(_), .doubleValue(_),\
    \ .stringValue(_):\n                       ^\n/tmp/tmpugweujs2.swift:23:41: error:\
    \ '_' can only appear in a pattern or on the left side of an assignment\n    \
    \    case .intValue(_), .doubleValue(_), .stringValue(_):\n                  \
    \                      ^\n/tmp/tmpugweujs2.swift:23:58: error: '_' can only appear\
    \ in a pattern or on the left side of an assignment\n        case .intValue(_),\
    \ .doubleValue(_), .stringValue(_):\n                                        \
    \                 ^\n/tmp/tmpugweujs2.swift:25:24: error: '_' can only appear\
    \ in a pattern or on the left side of an assignment\n        case .intValue(_),\
    \ .doubleValue(_):\n                       ^\n/tmp/tmpugweujs2.swift:25:41: error:\
    \ '_' can only appear in a pattern or on the left side of an assignment\n    \
    \    case .intValue(_), .doubleValue(_):\n                                   \
    \     ^\n/tmp/tmpugweujs2.swift:27:27: error: '_' can only appear in a pattern\
    \ or on the left side of an assignment\n        case .stringValue(_), .intValue(_):\n\
    \                          ^\n/tmp/tmpugweujs2.swift:27:41: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n        case .stringValue(_),\
    \ .intValue(_):\n                                        ^\n/tmp/tmpugweujs2.swift:29:27:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \        case .stringValue(_), .doubleValue(_):\n                          ^\n\
    /tmp/tmpugweujs2.swift:29:44: error: '_' can only appear in a pattern or on the\
    \ left side of an assignment\n        case .stringValue(_), .doubleValue(_):\n\
    \                                           ^\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // handle case where a is nil\n\
    \    case .intValue(nil):\n        guard let b = b else { // handle case where\
    \ b is nil\n            switch b { // handle case where b is nil\n           \
    \ case .doubleValue(let doubleA):\n                return .doubleValue(max(doubleA,\
    \ .minValue))\n            case .stringValue(let stringA):\n                return\
    \ .stringValue(stringA.max(stringA, .minValue))\n            }\n        }\n  \
    \      return .intValue(nil)\n    case .doubleValue(_):\n        guard let b =\
    \ b else { // handle case where b is nil\n            switch b { // handle case\
    \ where b is nil\n            case .intValue(let intA):\n                return\
    \ .intValue(max(intA, .minValue))\n            case .stringValue(let stringA):\n\
    \                return .stringValue(stringA.max(stringA, .minValue))\n      \
    \      }\n        }\n        return .doubleValue(nil)\n    case .stringValue(_):\n\
    \        guard let b = b else { // handle case where b is nil\n            switch\
    \ b { // handle case where b is nil\n            case .intValue(let intA):\n \
    \               return .intValue(nil)\n            case .doubleValue(let doubleA):\n\
    \                return .doubleValue(max(doubleA, .minValue))\n            }\n\
    \        }\n        return .stringValue(nil)\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzzgd1z64.swift:23:20: warning: type 'Int' is not optional, value\
    \ can never be nil; this is an error in Swift 6\n    case .intValue(nil):\n  \
    \                 ^\n/tmp/tmpzzgd1z64.swift:27:51: error: type 'Double' has no\
    \ member 'minValue'\n                return .doubleValue(max(doubleA, .minValue))\n\
    \                                                 ~^~~~~~~~\n/tmp/tmpzzgd1z64.swift:29:59:\
    \ error: type 'String' has no member 'minValue'\n                return .stringValue(stringA.max(stringA,\
    \ .minValue))\n                                                         ~^~~~~~~~\n\
    /tmp/tmpzzgd1z64.swift:25:13: error: switch must be exhaustive\n            switch\
    \ b { // handle case where b is nil\n            ^\n/tmp/tmpzzgd1z64.swift:25:13:\
    \ note: add missing case: '.intValue(_)'\n            switch b { // handle case\
    \ where b is nil\n            ^\n/tmp/tmpzzgd1z64.swift:24:15: error: initializer\
    \ for conditional binding must have Optional type, not 'Value'\n        guard\
    \ let b = b else { // handle case where b is nil\n              ^       ~\n/tmp/tmpzzgd1z64.swift:32:26:\
    \ error: 'nil' is not compatible with expected argument type 'Int'\n        return\
    \ .intValue(nil)\n                         ^\n/tmp/tmpzzgd1z64.swift:37:45: error:\
    \ type 'Int' has no member 'minValue'\n                return .intValue(max(intA,\
    \ .minValue))\n                                           ~^~~~~~~~\n/tmp/tmpzzgd1z64.swift:39:59:\
    \ error: type 'String' has no member 'minValue'\n                return .stringValue(stringA.max(stringA,\
    \ .minValue))\n                                                         ~^~~~~~~~\n\
    /tmp/tmpzzgd1z64.swift:35:13: error: switch must be exhaustive\n            switch\
    \ b { // handle case where b is nil\n            ^\n/tmp/tmpzzgd1z64.swift:35:13:\
    \ note: add missing case: '.doubleValue(_)'\n            switch b { // handle\
    \ case where b is nil\n            ^\n/tmp/tmpzzgd1z64.swift:34:15: error: initializer\
    \ for conditional binding must have Optional type, not 'Value'\n        guard\
    \ let b = b else { // handle case where b is nil\n              ^       ~\n/tmp/"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aReal, aImag, aFloat, aString: String\
    \ = \"\"\n    var bReal, bImag, bFloat, bString: String = \"\"\n    var aIsNegative:\
    \ Bool\n    var bIsNegative: Bool\n    var aIsPositive: Bool\n    var bIsPositive:\
    \ Bool\n\n    if a.isStringValue {\n        aReal = a.stringValue\n    } else\
    \ {\n        aReal = a.intValue\n    }\n\n    if b.isStringValue {\n        bReal\
    \ = b.stringValue\n    } else {\n        bReal = b.intValue\n    }\n\n    if aReal.isEmpty\
    \ {\n        return nil\n    }\n    if bReal.isEmpty {\n        return nil\n \
    \   }\n\n    aIsNegative = aReal.starts(with: \"-\")\n    if aIsNegative {\n \
    \       aReal = aReal.dropFirst()\n    }\n    bIsNegative = bReal.starts(with:\
    \ \"-\")\n    if bIsNegative {\n        bReal = bReal.dropFirst()\n    }\n   \
    \ aIsPositive = aReal.isEmpty || aReal.starts(with: \",\")\n    bIsPositive =\
    \ bReal.isEmpty || bReal.starts(with: \",\")\n\n    if aReal.isEmpty {\n     \
    \   if bReal.isEmpty || aIsPositive {\n            return b\n        }\n     \
    \   return a\n    }\n\n    if bReal.isEmpty {\n        if aIsPositive {\n    \
    \        return a\n        }\n        return b\n    }\n\n    if aIsNegative !=\
    \ bIsNegative {\n        if aIsNegative {\n            return b\n        }\n \
    \       return a\n    }\n\n    if aIsPositive && !bIsPositive {\n        return\
    \ a\n    }\n    if bIsPositive && !aIsPositive {\n        return b\n    }\n\n\
    \    if aReal.hasSuffix(\" i\") || bReal.hasSuffix(\" i\") {\n        if aReal.hasSuffix(\"\
    \ i\") {\n            aImag = String(aReal.suffix(2))\n            aReal = aReal.dropLast()\n\
    \        }\n        if bReal.hasSuffix(\" i\") {\n            bImag = String(bReal.suffix(2))\n\
    \            bReal = bReal.dropLast()\n        }\n        if aReal.hasSuffix(\"\
    \ f\") || bReal.hasSuffix(\" f\") {\n            if aReal.hasSuffix(\" f\") {\n\
    \                aFloat = String(aReal.suffix(2))\n                aReal = aReal.dropLast()\n\
    \            }\n            if bReal.hasSuffix(\" f\") {\n                bFloat\
    \ = String(bReal.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyo01z4a8.swift:102:38: error: expected member name following '.'\n\
    \                bFloat = String(bReal.\n                                    \
    \ ^\n/tmp/tmpyo01z4a8.swift:103:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpyo01z4a8.swift:102:32: note: to match this opening '('\n          \
    \      bFloat = String(bReal.\n                               ^\n/tmp/tmpyo01z4a8.swift:125:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpyo01z4a8.swift:96:59: note: to match this opening\
    \ '{'\n        if aReal.hasSuffix(\" f\") || bReal.hasSuffix(\" f\") {\n     \
    \                                                     ^\n/tmp/tmpyo01z4a8.swift:125:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpyo01z4a8.swift:87:55: note: to match this opening\
    \ '{'\n    if aReal.hasSuffix(\" i\") || bReal.hasSuffix(\" i\") {\n         \
    \                                             ^\n/tmp/tmpyo01z4a8.swift:125:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpyo01z4a8.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmpyo01z4a8.swift:22:9: error: type annotation\
    \ missing in pattern\n    var aReal, aImag, aFloat, aString: String = \"\"\n \
    \       ^\n/tmp/tmpyo01z4a8.swift:22:16: error: type annotation missing in pattern\n\
    \    var aReal, aImag, aFloat, aString: String = \"\"\n               ^\n/tmp/tmpyo01z4a8.swift:22:23:\
    \ error: type annotation missing in pattern\n    var aReal, aImag, aFloat, aString:\
    \ String = \"\"\n                      ^\n/tmp/tmpyo01z4a8.swift:23:9: error:\
    \ type annotation missing in pattern\n    var bReal, bImag, bFloat, bString: String\
    \ = \"\"\n  "
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as Value, b as Value {\n    case\
    \ let .intValue(aInt), .intValue(bInt):\n        return aInt > bInt ? .intValue(Int)\
    \ : .intValue(Int)\n    case let .doubleValue(aDouble), .doubleValue(bDouble):\n\
    \        return aDouble > bDouble ? .doubleValue(Double) : .doubleValue(Double)\n\
    \    case let .stringValue(aString), .stringValue(bString):\n        if aString\
    \ == bString {\n            return .stringValue(String)\n        } else {\n  \
    \          return .stringValue(aString)\n        }\n    default:\n        return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4upa6fa_.swift:22:22: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as Value, b as Value {\n                     ^\n/tmp/tmp4upa6fa_.swift:22:22:\
    \ error: consecutive statements on a line must be separated by ';'\n    switch\
    \ a as Value, b as Value {\n                     ^\n                     ;\n/tmp/tmp4upa6fa_.swift:22:22:\
    \ error: expected expression\n    switch a as Value, b as Value {\n          \
    \           ^\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    if case let .intValue(i1), let .intValue(i2)\
    \ = a, b where i1 > i2 {\n        return b\n    } else if case let .doubleValue(df1),\
    \ let .doubleValue(df2) = a, b where df1 > df2 {\n        return b\n    } else\
    \ if case let .stringValue(s1), let .stringValue(s2) = a, b where s1 > s2 {\n\
    \        return b\n    } else {\n        return a\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7rwm63g0.swift:23:30: error: variable binding in a condition requires\
    \ an initializer\n    if case let .intValue(i1), let .intValue(i2) = a, b where\
    \ i1 > i2 {\n                             ^\n/tmp/tmp7rwm63g0.swift:23:57: error:\
    \ expected ',' joining parts of a multi-clause condition\n    if case let .intValue(i1),\
    \ let .intValue(i2) = a, b where i1 > i2 {\n                                 \
    \                      ~^~~~~\n                                              \
    \         ,\n/tmp/tmp7rwm63g0.swift:25:41: error: variable binding in a condition\
    \ requires an initializer\n    } else if case let .doubleValue(df1), let .doubleValue(df2)\
    \ = a, b where df1 > df2 {\n                                        ^\n/tmp/tmp7rwm63g0.swift:25:72:\
    \ error: expected ',' joining parts of a multi-clause condition\n    } else if\
    \ case let .doubleValue(df1), let .doubleValue(df2) = a, b where df1 > df2 {\n\
    \                                                                      ~^~~~~\n\
    \                                                                      ,\n/tmp/tmp7rwm63g0.swift:27:40:\
    \ error: variable binding in a condition requires an initializer\n    } else if\
    \ case let .stringValue(s1), let .stringValue(s2) = a, b where s1 > s2 {\n   \
    \                                    ^\n/tmp/tmp7rwm63g0.swift:27:70: error: expected\
    \ ',' joining parts of a multi-clause condition\n    } else if case let .stringValue(s1),\
    \ let .stringValue(s2) = a, b where s1 > s2 {\n                              \
    \                                      ~^~~~~\n                              \
    \                                      ,\n/tmp/tmp7rwm63g0.swift:23:32: error:\
    \ pattern matching in a condition requires the 'case' keyword\n    if case let\
    \ .intValue(i1), let .intValue(i2) = a, b where i1 > i2 {\n                  \
    \             ^\n                               case \n/tmp/tmp7rwm63g0.swift:23:55:\
    \ error: cannot convert value of type 'Value' to expected condition type 'Bool'\n\
    \    if case let .intValue(i1), let .intValue(i2) = a, b where i1 > i2 {\n   \
    \                                                   ^"
  stdout: ''
  timestamp: 1660013421
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is Int\n    case .intValue(_):\n\
    \        if a == b {\n            return nil\n        }\n    case .doubleValue(_):\n\
    \        if a == b {\n            return nil\n        }\n    case .stringValue(_):\n\
    \        if a == b {\n            return nil\n        }\n    }\n    switch b {\
    \ // b is Int\n    case .intValue(_):\n        if b == a {\n            return\
    \ nil\n        }\n    case .doubleValue(_):\n        if b == a {\n           \
    \ return nil\n        }\n    case .stringValue(_):\n        if b == a {\n    \
    \        return nil\n        }\n    }\n    switch a { // a is Double\n    case\
    \ .intValue(_):\n        if a == b {\n            return nil\n        }\n    case\
    \ .doubleValue(_):\n        if a == b {\n            return nil\n        }\n \
    \   case .stringValue(_):\n        if a == b {\n            return nil\n     \
    \   }\n    }\n    switch b { // b is Double\n    case .intValue(_):\n        if\
    \ b == a {\n            return nil\n        }\n    case .doubleValue(_):\n   \
    \     if b == a {\n            return nil\n        }\n    case .stringValue(_):\n\
    \        if b == a {\n            return nil\n        }\n    }\n    switch a {\
    \ // a is String\n    case .intValue(_):\n        if a == b {\n            return\
    \ nil\n        }\n    case .doubleValue(_):\n        if a == b {\n           \
    \ return nil\n        }\n    case .stringValue(_):\n        if a == b {\n    \
    \        return nil\n        }\n    }\n    switch b { // b is String\n    case\
    \ .intValue(_):\n        if b == a {\n            return nil\n        }\n    case\
    \ .doubleValue(_):\n        if b == a {\n            return nil\n        }\n \
    \   case .stringValue(_):\n        if b == a {\n            return nil\n     \
    \   }\n    }\n    return b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp1kphfm96/tmp1kphfm96.swift:129: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adb6bb99c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adb6b890b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adb6b890988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adb6b88f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1kphfm96                        0x000055e596b7301a <unavailable> + 12314

    5    libc.so.6                          0x00002adb6bd85460 __libc_start_main +
    245

    6    tmp1kphfm96                        0x000055e596b71499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a.intValue() < b.intValue() {\n       \
    \ return a\n    } else if a.intValue() == b.intValue() {\n        if a.doubleValue()\
    \ < b.doubleValue() {\n            return a\n        } else if a.doubleValue()\
    \ == b.doubleValue() {\n            if a.stringValue() < b.stringValue() {\n \
    \               return a\n            } else if a.stringValue() == b.stringValue()\
    \ {\n                return nil\n            }\n        }\n    }\n    return b\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppdsvj0w7.swift:22:8: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if a.intValue() < b.intValue() {\n       ^\n    \
    \   Value\n/tmp/tmppdsvj0w7.swift:22:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() {\n                  ^\n    \
    \              <#Int#>\n/tmp/tmppdsvj0w7.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmppdsvj0w7.swift:22:21: error:\
    \ referencing operator function '<' on 'Comparable' requires that 'Value' conform\
    \ to 'Comparable'\n    if a.intValue() < b.intValue() {\n                    ^\n\
    Swift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol Comparable\
    \ : Equatable {\n                ^\n/tmp/tmppdsvj0w7.swift:22:21: note: binary\
    \ operator '<' cannot be synthesized for enums with associated values\n    if\
    \ a.intValue() < b.intValue() {\n                    ^\n/tmp/tmppdsvj0w7.swift:22:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() {\n                      ^\n                      Value\n/tmp/tmppdsvj0w7.swift:22:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() < b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmppdsvj0w7.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmppdsvj0w7.swift:24:26: error: missing argument for parameter\
    \ #1 in call\n    } else if a.intValue() == b.intValue() {\n                 \
    \        ^\n                         <#Int#>\n/tmp/tmppdsvj0w7.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmppdsvj0w7.swift:24:15:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    } else\
    \ if a.intValue() == b.intValue() {\n              ^\n              Value\n/tmp/tmppdsvj0w7.swift:24:31:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    } else\
    \ if a.intValue() == b.intValue() {\n                              ^\n       \
    \                       Value\n/tmp/tmppdsvj0w7.swift:24:42: erro"
  stdout: ''
  timestamp: 1660013422
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .intValue(_):\n            return b\n        case\
    \ .doubleValue(_):\n            return nil\n        case .stringValue(_):\n  \
    \          return a\n        }\n    case .doubleValue(_):\n        switch b {\n\
    \        case .intValue(_):\n            return nil\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b {\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return nil\n\
    \        case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpd4ymcss9/tmpd4ymcss9.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba15b191c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba15ae88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba15ae88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba15ae877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd4ymcss9                        0x0000564179c36d54 <unavailable> + 7508

    5    libc.so.6                          0x00002ba15b37d460 __libc_start_main +
    245

    6    tmpd4ymcss9                        0x0000564179c36499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b)):\n\
    \        return b\n    case (.doubleValue(a), .doubleValue(b)):\n        return\
    \ b\n    case (.stringValue(a), .stringValue(b)):\n        return b\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpd69on2lj.swift:23:21: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case (.intValue(a), .intValue(b)):\n\
    \                    ^\n/tmp/tmpd69on2lj.swift:25:24: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .doubleValue(b)):\n                       ^\n/tmp/tmpd69on2lj.swift:27:24: error:\
    \ expression pattern of type 'Value' cannot match values of type 'String'\n  \
    \  case (.stringValue(a), .stringValue(b)):\n                       ^\n/tmp/tmpd69on2lj.swift:27:24:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case (.stringValue(a), .stringValue(b)):\n        \
    \               ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var a = a.intValue\n    var b = b.intValue\n\
    \    if b > a {\n        (a, b) = (b, a)\n    }\n    if a == b {\n        return\
    \ nil\n    }\n    return b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppl6w30n1.swift:22:13: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    var a = a.intValue\n            ^\n            Value\n\
    /tmp/tmppl6w30n1.swift:23:13: error: enum case 'intValue' cannot be used as an\
    \ instance member\n    var b = b.intValue\n            ^\n            Value\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var result = a\n    switch result {\n    case\
    \ .intValue(let aInt), .doubleValue(let aDouble), .stringValue(let aString):\n\
    \        if let bInt = b.intValue, let bDouble = b.doubleValue, let bString =\
    \ b.stringValue {\n            if aInt == bInt && aDouble == bDouble && aString\
    \ == bString {\n                return nil\n            }\n        }\n    }\n\
    \    if result != b {\n        return b\n    }\n    return a\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbh322qqr.swift:24:48: error: 'aDouble' must be bound in every pattern\n\
    \    case .intValue(let aInt), .doubleValue(let aDouble), .stringValue(let aString):\n\
    \                                               ^\n/tmp/tmpbh322qqr.swift:24:24:\
    \ error: 'aInt' must be bound in every pattern\n    case .intValue(let aInt),\
    \ .doubleValue(let aDouble), .stringValue(let aString):\n                    \
    \   ^\n/tmp/tmpbh322qqr.swift:24:75: error: 'aString' must be bound in every pattern\n\
    \    case .intValue(let aInt), .doubleValue(let aDouble), .stringValue(let aString):\n\
    \                                                                          ^\n\
    /tmp/tmpbh322qqr.swift:24:24: error: 'aInt' must be bound in every pattern\n \
    \   case .intValue(let aInt), .doubleValue(let aDouble), .stringValue(let aString):\n\
    \                       ^\n/tmp/tmpbh322qqr.swift:25:23: error: enum case 'intValue'\
    \ cannot be used as an instance member\n        if let bInt = b.intValue, let\
    \ bDouble = b.doubleValue, let bString = b.stringValue {\n                   \
    \   ^\n                      Value\n/tmp/tmpbh322qqr.swift:25:49: error: enum\
    \ case 'doubleValue' cannot be used as an instance member\n        if let bInt\
    \ = b.intValue, let bDouble = b.doubleValue, let bString = b.stringValue {\n \
    \                                               ^\n                          \
    \                      Value\n/tmp/tmpbh322qqr.swift:25:78: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n        if let bInt = b.intValue, let\
    \ bDouble = b.doubleValue, let bString = b.stringValue {\n                   \
    \                                                          ^\n               \
    \                                                              Value\n/tmp/tmpbh322qqr.swift:26:32:\
    \ error: cannot find 'aDouble' in scope\n            if aInt == bInt && aDouble\
    \ == bDouble && aString == bString {\n                               ^~~~~~~\n\
    /tmp/tmpbh322qqr.swift:26:54: error: cannot find 'aString' in scope\n        \
    \    if aInt == bInt && aDouble == bDouble && aString == bString {\n         \
    \           "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue: Value?\n    if a.intValue != nil\
    \ {\n        aValue = a.intValue!\n    }\n    if a.doubleValue != nil {\n    \
    \    aValue = a.doubleValue!\n    }\n    if a.stringValue != nil {\n        aValue\
    \ = a.stringValue!\n    }\n    \n    var bValue: Value?\n    if b.intValue !=\
    \ nil {\n        bValue = b.intValue!\n    }\n    if b.doubleValue != nil {\n\
    \        bValue = b.doubleValue!\n    }\n    if b.stringValue != nil {\n     \
    \   bValue = b.stringValue!\n    }\n\n    if let aValue = aValue, let bValue =\
    \ bValue {\n        switch (aValue, bValue) {\n        case (Int?(b), Int?(a)):\n\
    \            return b\n        case (Double?(b), Double?(a)):\n            return\
    \ b\n        case (String?(b), String?(a)):\n            return b\n        default:\n\
    \            if aValue == bValue {\n                return b\n            }\n\
    \            \n            return nil\n        }\n    }\n    \n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwb_2u5y_.swift:23:8: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if a.intValue != nil {\n       ^\n       Value\n\
    /tmp/tmpwb_2u5y_.swift:24:28: error: cannot assign value of type '(Int) -> Value'\
    \ to type 'Value'\n        aValue = a.intValue!\n                 ~~~~~~~~~~^\n\
    /tmp/tmpwb_2u5y_.swift:24:18: error: enum case 'intValue' cannot be used as an\
    \ instance member\n        aValue = a.intValue!\n                 ^\n        \
    \         Value\n/tmp/tmpwb_2u5y_.swift:24:28: error: cannot force unwrap value\
    \ of non-optional type '(Int) -> Value'\n        aValue = a.intValue!\n      \
    \           ~~~~~~~~~~^\n                           \n/tmp/tmpwb_2u5y_.swift:26:8:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ a.doubleValue != nil {\n       ^\n       Value\n/tmp/tmpwb_2u5y_.swift:27:31:\
    \ error: cannot assign value of type '(Double) -> Value' to type 'Value'\n   \
    \     aValue = a.doubleValue!\n                 ~~~~~~~~~~~~~^\n/tmp/tmpwb_2u5y_.swift:27:18:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  aValue = a.doubleValue!\n                 ^\n                 Value\n/tmp/tmpwb_2u5y_.swift:27:31:\
    \ error: cannot force unwrap value of non-optional type '(Double) -> Value'\n\
    \        aValue = a.doubleValue!\n                 ~~~~~~~~~~~~~^\n          \
    \                    \n/tmp/tmpwb_2u5y_.swift:29:8: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n    if a.stringValue != nil {\n      \
    \ ^\n       Value\n/tmp/tmpwb_2u5y_.swift:30:31: error: cannot assign value of\
    \ type '(String) -> Value' to type 'Value'\n        aValue = a.stringValue!\n\
    \                 ~~~~~~~~~~~~~^\n/tmp/tmpwb_2u5y_.swift:30:18: error: enum case\
    \ 'stringValue' cannot be used as an instance member\n        aValue = a.stringValue!\n\
    \                 ^\n                 Value\n/tmp/tmpwb_2u5y_.swift:30:31: error:\
    \ cannot force unwrap value of non-optional type '(String) -> Value'\n       \
    \ aValue = a.stringValue!\n                 ~~~~~~~~~~~~~^\n                 \
    \             \n/tmp/tmpwb_2u5y_.swift:34:"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(x): return\
    \ b == .intValue(x)\n    case .doubleValue(x): return b == .doubleValue(x)\n \
    \   case .stringValue(x): return b == .stringValue(x)\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpw943nuzc.swift:23:20: error: cannot find 'x' in scope\n    case\
    \ .intValue(x): return b == .intValue(x)\n                   ^\n/tmp/tmpw943nuzc.swift:24:23:\
    \ error: cannot find 'x' in scope\n    case .doubleValue(x): return b == .doubleValue(x)\n\
    \                      ^\n/tmp/tmpw943nuzc.swift:25:23: error: cannot find 'x'\
    \ in scope\n    case .stringValue(x): return b == .stringValue(x)\n          \
    \            ^\n/tmp/tmpw943nuzc.swift:23:46: error: cannot find 'x' in scope\n\
    \    case .intValue(x): return b == .intValue(x)\n                           \
    \                  ^\n/tmp/tmpw943nuzc.swift:23:33: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n    case .intValue(x): return\
    \ b == .intValue(x)\n                              ~~^~~~~~~~~~~~~~~\n/tmp/tmpw943nuzc.swift:24:52:\
    \ error: cannot find 'x' in scope\n    case .doubleValue(x): return b == .doubleValue(x)\n\
    \                                                   ^\n/tmp/tmpw943nuzc.swift:24:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .doubleValue(x): return b == .doubleValue(x)\n                     \
    \            ~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpw943nuzc.swift:25:52: error: cannot\
    \ find 'x' in scope\n    case .stringValue(x): return b == .stringValue(x)\n \
    \                                                  ^\n/tmp/tmpw943nuzc.swift:25:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .stringValue(x): return b == .stringValue(x)\n                     \
    \            ~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let a_type = a.dynamicType.conformingToType()\n\
    \    let b_type = b.dynamicType.conformingToType()\n    switch a_type {\n    case\
    \ Int.self, _ where b_type == Double.self:\n        // intValue is always faster\
    \ than doubleValue\n        return b.intValue(a.intValue)\n    case Double.self,\
    \ _ where b_type == Int.self:\n        // doubleValue is always faster than intValue\n\
    \        return b.doubleValue(a.doubleValue)\n    case _ where b_type == Double.self:\n\
    \        // doubleValue is always faster than stringValue\n        return b.doubleValue(a.stringValue)\n\
    \    case _ where b_type == Int.self:\n        // intValue is always faster than\
    \ stringValue\n        return b.intValue(a.stringValue)\n    case String.self,\
    \ _ where a_type == String.self:\n        // stringValue is always faster than\
    \ doubleValue\n        return a.stringValue(b.stringValue)\n    case _ where a_type\
    \ == String.self:\n        // stringValue is always faster than intValue\n   \
    \     return a.stringValue(b.intValue)\n    default:\n        return nil\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbxwvjtso.swift:22:20: error: value of type 'Value' has no member\
    \ 'dynamicType'\n    let a_type = a.dynamicType.conformingToType()\n         \
    \        ~ ^~~~~~~~~~~\n/tmp/tmpbxwvjtso.swift:23:20: error: value of type 'Value'\
    \ has no member 'dynamicType'\n    let b_type = b.dynamicType.conformingToType()\n\
    \                 ~ ^~~~~~~~~~~\n/tmp/tmpbxwvjtso.swift:27:16: error: enum case\
    \ 'intValue' cannot be used as an instance member\n        return b.intValue(a.intValue)\n\
    \               ^\n               Value\n/tmp/tmpbxwvjtso.swift:27:29: error:\
    \ cannot convert value of type '(Int) -> Value' to expected argument type 'Int'\n\
    \        return b.intValue(a.intValue)\n                            ^\n/tmp/tmpbxwvjtso.swift:27:27:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        return\
    \ b.intValue(a.intValue)\n                          ^\n                      \
    \    Value\n/tmp/tmpbxwvjtso.swift:30:16: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        return b.doubleValue(a.doubleValue)\n\
    \               ^\n               Value\n/tmp/tmpbxwvjtso.swift:30:32: error:\
    \ cannot convert value of type '(Double) -> Value' to expected argument type 'Double'\n\
    \        return b.doubleValue(a.doubleValue)\n                               ^\n\
    /tmp/tmpbxwvjtso.swift:30:30: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n        return b.doubleValue(a.doubleValue)\n          \
    \                   ^\n                             Value\n/tmp/tmpbxwvjtso.swift:33:32:\
    \ error: cannot convert value of type '(String) -> Value' to expected argument\
    \ type 'Double'\n        return b.doubleValue(a.stringValue)\n               \
    \                ^\n/tmp/tmpbxwvjtso.swift:33:16: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n        return b.doubleValue(a.stringValue)\n\
    \               ^\n               Value\n/tmp/tmpbxwvjtso.swift:33:30: error:\
    \ enum case 'stringValue' cannot be used as an instance member\n        return\
    \ b.doubleValue(a.stringValue)\n                             ^\n             \
    \               "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return nil\n        case .stringValue(_):\n  \
    \          if let aString = String(a), let bString = String(b) {\n           \
    \     return aString > bString ? .stringValue(aString) : .stringValue(bString)\n\
    \            } else {\n                return .intValue(a)\n            }\n  \
    \      }\n    case .doubleValue(_):\n        switch b {\n        case .intValue(_):\n\
    \            return nil\n        case .doubleValue(_):\n            return a\n\
    \        case .stringValue(_):\n            if let aString = String(a), let bString\
    \ = String(b) {\n                return aString > bString ? .stringValue(aString)\
    \ : .stringValue(bString)\n            } else {\n                return .doubleValue(a)\n\
    \            }\n        }\n    case .stringValue(_):\n        switch b {\n   \
    \     case .intValue(_):\n            return nil\n        case .doubleValue(_):\n\
    \            return nil\n        case .stringValue(_):\n            return a\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpn0zsnlpz.swift:30:30: error: no exact matches in call to initializer\
    \ \n            if let aString = String(a), let bString = String(b) {\n      \
    \                       ^\nSwift.String:4:23: note: candidate requires that 'Value'\
    \ conform to 'LosslessStringConvertible' (requirement specified as 'T' : 'LosslessStringConvertible')\n\
    \    @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible\n\
    \                      ^\nSwift.String:2:12: note: candidate requires that 'Value'\
    \ conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n\
    \    public init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where\
    \ T : BinaryInteger\n           ^\nSwift.String:4:12: note: candidate requires\
    \ that 'Value' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n\
    \    public init<S>(_ characters: S) where S : Sequence, S.Element == Character\n\
    \           ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires\
    \ that 'Value' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:6:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n/tmp/tmpn0zsnlpz.swift:30:55: error: no exact\
    \ matches in call to initializer \n            if let aString = String(a), let\
    \ bString = String(b) {\n                                                    \
    \  ^\nSwift.String:4:23: note: candidate requires that 'Value' conform to 'LosslessStringConvertible'\
    \ (requirement specified as 'T' : 'LosslessStringConvertible')\n    @inlinable\
    \ public init<T>(_ value: T) where T : LosslessStringConvertible\n           \
    \           ^\nSwift.String:2:12: note: candidate requires that 'Value' conform\
    \ to 'BinaryInteger' (requirement specified a"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as ValueType, b.valueType {\n   \
    \ case .intValue(let i): return if i > b { b }\n    case .doubleValue(let d):\
    \ return if d > a { a }\n    case .stringValue(let s): return if s > a { a }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp17jyekv9.swift:22:26: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as ValueType, b.valueType {\n                     \
    \    ^\n/tmp/tmp17jyekv9.swift:22:26: error: consecutive statements on a line\
    \ must be separated by ';'\n    switch a as ValueType, b.valueType {\n       \
    \                  ^\n                         ;\n/tmp/tmp17jyekv9.swift:22:26:\
    \ error: expected expression\n    switch a as ValueType, b.valueType {\n     \
    \                    ^\n/tmp/tmp17jyekv9.swift:22:17: error: cannot find type\
    \ 'ValueType' in scope\n    switch a as ValueType, b.valueType {\n           \
    \     ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b)):\n\
    \        if a > b {\n            return a\n        }\n        return b\n    case\
    \ (.intValue(a), .doubleValue(b)):\n        if a > b {\n            return a\n\
    \        }\n        return b\n    case (.doubleValue(a), .doubleValue(b)):\n \
    \       if a > b {\n            return a\n        }\n        return b\n    case\
    \ (.stringValue(a), .stringValue(b)):\n        if a > b {\n            return\
    \ a\n        }\n        return b\n    case (.stringValue(a), .intValue(b)):\n\
    \        return nil\n    case (.intValue(a), .stringValue(b)):\n        return\
    \ nil\n    case (.stringValue(a), .stringValue(b)):\n        return nil\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpek5yf51m.swift:23:21: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case (.intValue(a), .intValue(b)):\n\
    \                    ^\n/tmp/tmpek5yf51m.swift:28:21: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Int'\n    case (.intValue(a), .doubleValue(b)):\n\
    \                    ^\n/tmp/tmpek5yf51m.swift:33:24: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .doubleValue(b)):\n                       ^\n/tmp/tmpek5yf51m.swift:38:24: error:\
    \ expression pattern of type 'Value' cannot match values of type 'String'\n  \
    \  case (.stringValue(a), .stringValue(b)):\n                       ^\n/tmp/tmpek5yf51m.swift:38:24:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case (.stringValue(a), .stringValue(b)):\n        \
    \               ^\n/tmp/tmpek5yf51m.swift:43:24: error: expression pattern of\
    \ type 'Value' cannot match values of type 'String'\n    case (.stringValue(a),\
    \ .intValue(b)):\n                       ^\n/tmp/tmpek5yf51m.swift:43:24: note:\
    \ overloads for '~=' exist with these partially matching parameter lists: (Substring,\
    \ String)\n    case (.stringValue(a), .intValue(b)):\n                       ^\n\
    /tmp/tmpek5yf51m.swift:45:21: error: expression pattern of type 'Value' cannot\
    \ match values of type 'Int'\n    case (.intValue(a), .stringValue(b)):\n    \
    \                ^\n/tmp/tmpek5yf51m.swift:47:24: error: expression pattern of\
    \ type 'Value' cannot match values of type 'String'\n    case (.stringValue(a),\
    \ .stringValue(b)):\n                       ^\n/tmp/tmpek5yf51m.swift:47:24: note:\
    \ overloads for '~=' exist with these partially matching parameter lists: (Substring,\
    \ String)\n    case (.stringValue(a), .stringValue(b)):\n                    \
    \   ^\n/tmp/tmpek5yf51m.swift:24:14: error: binary operator '>' cannot be applied\
    \ to two 'Value' operands\n        if a > b {\n           ~ ^ ~\n/tmp/tmpek5yf51m.swift:24:14:\
    \ note: binary operator '>' cannot be synthesized for enums with associate"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // swiftlint:disable:this line_length\n\
    \    case .intValue(nil): return nil\n    case .doubleValue(nil): return nil\n\
    \    case .stringValue(nil): return nil\n    case .intValue(_), .doubleValue(_),\
    \ .stringValue(_): return nil\n    default:\n        switch b {\n        case\
    \ .intValue(nil): return nil\n        case .doubleValue(nil): return nil\n   \
    \     case .stringValue(nil): return nil\n        case .intValue(_), .doubleValue(_),\
    \ .stringValue(_): return nil\n        default:\n            if a < b {\n    \
    \            return a\n            } else {\n                return b\n      \
    \      }\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdtwhna5_.swift:23:20: warning: type 'Int' is not optional, value\
    \ can never be nil; this is an error in Swift 6\n    case .intValue(nil): return\
    \ nil\n                   ^\n/tmp/tmpdtwhna5_.swift:24:23: warning: type 'Double'\
    \ is not optional, value can never be nil; this is an error in Swift 6\n    case\
    \ .doubleValue(nil): return nil\n                      ^\n/tmp/tmpdtwhna5_.swift:25:23:\
    \ warning: type 'String' is not optional, value can never be nil; this is an error\
    \ in Swift 6\n    case .stringValue(nil): return nil\n                      ^\n\
    /tmp/tmpdtwhna5_.swift:29:24: warning: type 'Int' is not optional, value can never\
    \ be nil; this is an error in Swift 6\n        case .intValue(nil): return nil\n\
    \                       ^\n/tmp/tmpdtwhna5_.swift:30:27: warning: type 'Double'\
    \ is not optional, value can never be nil; this is an error in Swift 6\n     \
    \   case .doubleValue(nil): return nil\n                          ^\n/tmp/tmpdtwhna5_.swift:31:27:\
    \ warning: type 'String' is not optional, value can never be nil; this is an error\
    \ in Swift 6\n        case .stringValue(nil): return nil\n                   \
    \       ^\n/tmp/tmpdtwhna5_.swift:34:18: error: binary operator '<' cannot be\
    \ applied to two 'Value' operands\n            if a < b {\n               ~ ^\
    \ ~\n/tmp/tmpdtwhna5_.swift:34:18: note: binary operator '<' cannot be synthesized\
    \ for enums with associated values\n            if a < b {\n                 ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(aVal):\n  \
    \      switch b {\n        case .intValue(bVal):\n            return aVal > bVal\
    \ ? .intValue(aVal) : .intValue(bVal)\n        case .doubleValue(_):\n       \
    \     return nil\n        }\n    case .doubleValue(aVal):\n        switch b {\n\
    \        case .intValue(bVal):\n            return nil\n        case .doubleValue(bVal):\n\
    \            return aVal > bVal ? .doubleValue(aVal) : .doubleValue(bVal)\n  \
    \      case .stringValue(_):\n            return nil\n        }\n    case .stringValue(aVal):\n\
    \        switch b {\n        case .intValue(_):\n            return nil\n    \
    \    case .doubleValue(_):\n            return nil\n        case .stringValue(bVal):\n\
    \            return aVal > bVal ? .stringValue(aVal) : .stringValue(bVal)\n  \
    \      }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9t78su3y.swift:23:20: error: cannot find 'aVal' in scope\n    case\
    \ .intValue(aVal):\n                   ^~~~\n/tmp/tmp9t78su3y.swift:30:23: error:\
    \ cannot find 'aVal' in scope\n    case .doubleValue(aVal):\n                \
    \      ^~~~\n/tmp/tmp9t78su3y.swift:39:23: error: cannot find 'aVal' in scope\n\
    \    case .stringValue(aVal):\n                      ^~~~\n/tmp/tmp9t78su3y.swift:25:24:\
    \ error: cannot find 'bVal' in scope\n        case .intValue(bVal):\n        \
    \               ^~~~\n/tmp/tmp9t78su3y.swift:26:20: error: cannot find 'aVal'\
    \ in scope\n            return aVal > bVal ? .intValue(aVal) : .intValue(bVal)\n\
    \                   ^~~~\n/tmp/tmp9t78su3y.swift:26:27: error: cannot find 'bVal'\
    \ in scope\n            return aVal > bVal ? .intValue(aVal) : .intValue(bVal)\n\
    \                          ^~~~\n/tmp/tmp9t78su3y.swift:26:44: error: cannot find\
    \ 'aVal' in scope\n            return aVal > bVal ? .intValue(aVal) : .intValue(bVal)\n\
    \                                           ^~~~\n/tmp/tmp9t78su3y.swift:26:62:\
    \ error: cannot find 'bVal' in scope\n            return aVal > bVal ? .intValue(aVal)\
    \ : .intValue(bVal)\n                                                        \
    \     ^~~~\n/tmp/tmp9t78su3y.swift:32:24: error: cannot find 'bVal' in scope\n\
    \        case .intValue(bVal):\n                       ^~~~\n/tmp/tmp9t78su3y.swift:34:27:\
    \ error: cannot find 'bVal' in scope\n        case .doubleValue(bVal):\n     \
    \                     ^~~~\n/tmp/tmp9t78su3y.swift:35:20: error: cannot find 'aVal'\
    \ in scope\n            return aVal > bVal ? .doubleValue(aVal) : .doubleValue(bVal)\n\
    \                   ^~~~\n/tmp/tmp9t78su3y.swift:35:27: error: cannot find 'bVal'\
    \ in scope\n            return aVal > bVal ? .doubleValue(aVal) : .doubleValue(bVal)\n\
    \                          ^~~~\n/tmp/tmp9t78su3y.swift:35:47: error: cannot find\
    \ 'aVal' in scope\n            return aVal > bVal ? .doubleValue(aVal) : .doubleValue(bVal)\n\
    \                                              ^~~~\n/tmp/tmp9t78su3y.swift:35:68:\
    \ error: cannot find 'bVal' in scope\n            return aVal > bVal ? ."
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   return a.intValue > b.intValue ? a : b\n    case .doubleValue(_):\n      \
    \  return a.doubleValue > b.doubleValue ? a : b\n    case .stringValue(_):\n \
    \       return a.stringValue > b.stringValue ? a : b\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplfneeyrl.swift:24:16: error: enum case 'intValue' cannot be used\
    \ as an instance member\n        return a.intValue > b.intValue ? a : b\n    \
    \           ^\n               Value\n/tmp/tmplfneeyrl.swift:24:27: error: type\
    \ '(Int) -> Value' cannot conform to 'Comparable'\n        return a.intValue >\
    \ b.intValue ? a : b\n                          ^\n/tmp/tmplfneeyrl.swift:24:27:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        return a.intValue > b.intValue ? a : b\n                \
    \          ^\n/tmp/tmplfneeyrl.swift:24:27: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n        return\
    \ a.intValue > b.intValue ? a : b\n                          ^\n/tmp/tmplfneeyrl.swift:24:29:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        return\
    \ a.intValue > b.intValue ? a : b\n                            ^\n           \
    \                 Value\n/tmp/tmplfneeyrl.swift:26:16: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n        return a.doubleValue > b.doubleValue\
    \ ? a : b\n               ^\n               Value\n/tmp/tmplfneeyrl.swift:26:30:\
    \ error: type '(Double) -> Value' cannot conform to 'Comparable'\n        return\
    \ a.doubleValue > b.doubleValue ? a : b\n                             ^\n/tmp/tmplfneeyrl.swift:26:30:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        return a.doubleValue > b.doubleValue ? a : b\n          \
    \                   ^\n/tmp/tmplfneeyrl.swift:26:30: note: required by referencing\
    \ operator function '>' on 'Comparable' where 'Self' = '(Double) -> Value'\n \
    \       return a.doubleValue > b.doubleValue ? a : b\n                       \
    \      ^\n/tmp/tmplfneeyrl.swift:26:32: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        return a.doubleValue > b.doubleValue\
    \ ? a : b\n                               ^\n                               Value\n\
    /tmp/tmplfneeyrl.swift:28:16: error: enum case 'stringValue' cannot be used as\
    \ an instance member"
  stdout: ''
  timestamp: 1660013422
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_): return\
    \ b\n    case .doubleValue(_): return b\n    case .stringValue(_): return b\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpmwp84lgq/tmpmwp84lgq.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0c01dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0bfed5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0bfed5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0bfed47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmwp84lgq                        0x000055caf127201a <unavailable> + 12314

    5    libc.so.6                          0x00002ac0c03ca460 __libc_start_main +
    245

    6    tmpmwp84lgq                        0x000055caf1270499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(x), .intValue(y)):\n\
    \        return x > y ? .intValue(y) : .intValue(x)\n    case (.doubleValue(x),\
    \ .doubleValue(y)):\n        return x < y ? .doubleValue(y) : .doubleValue(x)\n\
    \    case (.stringValue(x), .stringValue(y)):\n        return x < y ? .stringValue(y)\
    \ : .stringValue(x)\n    default:\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi0lmlsfm.swift:23:21: error: cannot find 'x' in scope\n    case\
    \ (.intValue(x), .intValue(y)):\n                    ^\n/tmp/tmpi0lmlsfm.swift:23:35:\
    \ error: cannot find 'y' in scope\n    case (.intValue(x), .intValue(y)):\n  \
    \                                ^\n/tmp/tmpi0lmlsfm.swift:25:24: error: cannot\
    \ find 'x' in scope\n    case (.doubleValue(x), .doubleValue(y)):\n          \
    \             ^\n/tmp/tmpi0lmlsfm.swift:25:41: error: cannot find 'y' in scope\n\
    \    case (.doubleValue(x), .doubleValue(y)):\n                              \
    \          ^\n/tmp/tmpi0lmlsfm.swift:27:24: error: cannot find 'x' in scope\n\
    \    case (.stringValue(x), .stringValue(y)):\n                       ^\n/tmp/tmpi0lmlsfm.swift:27:41:\
    \ error: cannot find 'y' in scope\n    case (.stringValue(x), .stringValue(y)):\n\
    \                                        ^\n/tmp/tmpi0lmlsfm.swift:24:16: error:\
    \ cannot find 'x' in scope\n        return x > y ? .intValue(y) : .intValue(x)\n\
    \               ^\n/tmp/tmpi0lmlsfm.swift:24:20: error: cannot find 'y' in scope\n\
    \        return x > y ? .intValue(y) : .intValue(x)\n                   ^\n/tmp/tmpi0lmlsfm.swift:24:34:\
    \ error: cannot find 'y' in scope\n        return x > y ? .intValue(y) : .intValue(x)\n\
    \                                 ^\n/tmp/tmpi0lmlsfm.swift:24:49: error: cannot\
    \ find 'x' in scope\n        return x > y ? .intValue(y) : .intValue(x)\n    \
    \                                            ^\n/tmp/tmpi0lmlsfm.swift:26:16:\
    \ error: cannot find 'x' in scope\n        return x < y ? .doubleValue(y) : .doubleValue(x)\n\
    \               ^\n/tmp/tmpi0lmlsfm.swift:26:20: error: cannot find 'y' in scope\n\
    \        return x < y ? .doubleValue(y) : .doubleValue(x)\n                  \
    \ ^\n/tmp/tmpi0lmlsfm.swift:26:37: error: cannot find 'y' in scope\n        return\
    \ x < y ? .doubleValue(y) : .doubleValue(x)\n                                \
    \    ^\n/tmp/tmpi0lmlsfm.swift:26:55: error: cannot find 'x' in scope\n      \
    \  return x < y ? .doubleValue(y) : .doubleValue(x)\n                        \
    \                              ^\n/tmp/tmpi0lmlsfm.swift:28:16: error: cannot"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(niA), .doubleValue(niB),\
    \ .stringValue(niC):\n        return b\n    case .intValue(nfA), .doubleValue(nfB),\
    \ .stringValue(nfC):\n        return a\n    default:\n        return nil\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvmvggddg.swift:23:20: error: cannot find 'niA' in scope\n    case\
    \ .intValue(niA), .doubleValue(niB), .stringValue(niC):\n                   ^~~\n\
    /tmp/tmpvmvggddg.swift:23:39: error: cannot find 'niB' in scope\n    case .intValue(niA),\
    \ .doubleValue(niB), .stringValue(niC):\n                                    \
    \  ^~~\n/tmp/tmpvmvggddg.swift:23:58: error: cannot find 'niC' in scope\n    case\
    \ .intValue(niA), .doubleValue(niB), .stringValue(niC):\n                    \
    \                                     ^~~\n/tmp/tmpvmvggddg.swift:25:20: error:\
    \ cannot find 'nfA' in scope\n    case .intValue(nfA), .doubleValue(nfB), .stringValue(nfC):\n\
    \                   ^~~\n/tmp/tmpvmvggddg.swift:25:39: error: cannot find 'nfB'\
    \ in scope\n    case .intValue(nfA), .doubleValue(nfB), .stringValue(nfC):\n \
    \                                     ^~~\n/tmp/tmpvmvggddg.swift:25:58: error:\
    \ cannot find 'nfC' in scope\n    case .intValue(nfA), .doubleValue(nfB), .stringValue(nfC):\n\
    \                                                         ^~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case .intValue(v as!\
    \ Int):\n        return .intValue(v)\n    case .doubleValue(v as! Double):\n \
    \       return .doubleValue(v)\n    case .stringValue(v as! String):\n       \
    \ return .stringValue(v)\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplefnckos.swift:23:20: error: cannot find 'v' in scope\n    case\
    \ .intValue(v as! Int):\n                   ^\n/tmp/tmplefnckos.swift:23:11: error:\
    \ value of tuple type '(Value, Value)' has no member 'intValue'\n    case .intValue(v\
    \ as! Int):\n         ~^~~~~~~~\n/tmp/tmplefnckos.swift:25:23: error: cannot find\
    \ 'v' in scope\n    case .doubleValue(v as! Double):\n                      ^\n\
    /tmp/tmplefnckos.swift:25:11: error: value of tuple type '(Value, Value)' has\
    \ no member 'doubleValue'\n    case .doubleValue(v as! Double):\n         ~^~~~~~~~~~~\n\
    /tmp/tmplefnckos.swift:27:23: error: cannot find 'v' in scope\n    case .stringValue(v\
    \ as! String):\n                      ^\n/tmp/tmplefnckos.swift:27:11: error:\
    \ value of tuple type '(Value, Value)' has no member 'stringValue'\n    case .stringValue(v\
    \ as! String):\n         ~^~~~~~~~~~~\n/tmp/tmplefnckos.swift:24:26: error: cannot\
    \ find 'v' in scope\n        return .intValue(v)\n                         ^\n\
    /tmp/tmplefnckos.swift:26:29: error: cannot find 'v' in scope\n        return\
    \ .doubleValue(v)\n                            ^\n/tmp/tmplefnckos.swift:28:29:\
    \ error: cannot find 'v' in scope\n        return .stringValue(v)\n          \
    \                  ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let aValue = a?.intValue, bValue = b?.intValue\
    \ {\n        if aValue > bValue {\n            return a\n        }\n        if\
    \ aValue < bValue {\n            return b\n        }\n    }\n\n    if let aValue\
    \ = a?.doubleValue, bValue = b?.doubleValue {\n        if aValue > bValue {\n\
    \            return a\n        }\n        if aValue < bValue {\n            return\
    \ b\n        }\n    }\n\n    if let aValue = a?.stringValue, bValue = b?.stringValue\
    \ {\n        if aValue > bValue {\n            return a\n        }\n        if\
    \ aValue < bValue {\n            return b\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpewb0btwx.swift:22:34: error: expected 'let' in conditional\n  \
    \  if let aValue = a?.intValue, bValue = b?.intValue {\n                     \
    \            ^\n                                 let \n/tmp/tmpewb0btwx.swift:31:37:\
    \ error: expected 'let' in conditional\n    if let aValue = a?.doubleValue, bValue\
    \ = b?.doubleValue {\n                                    ^\n                \
    \                    let \n/tmp/tmpewb0btwx.swift:40:37: error: expected 'let'\
    \ in conditional\n    if let aValue = a?.stringValue, bValue = b?.stringValue\
    \ {\n                                    ^\n                                 \
    \   let \n/tmp/tmpewb0btwx.swift:22:22: error: cannot use optional chaining on\
    \ non-optional value of type 'Value'\n    if let aValue = a?.intValue, bValue\
    \ = b?.intValue {\n                    ~^\n                     \n/tmp/tmpewb0btwx.swift:22:22:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ aValue = a?.intValue, bValue = b?.intValue {\n                    ~^\n     \
    \               Value\n/tmp/tmpewb0btwx.swift:22:44: error: cannot use optional\
    \ chaining on non-optional value of type 'Value'\n    if let aValue = a?.intValue,\
    \ bValue = b?.intValue {\n                                          ~^\n     \
    \                                      \n/tmp/tmpewb0btwx.swift:22:44: error:\
    \ enum case 'intValue' cannot be used as an instance member\n    if let aValue\
    \ = a?.intValue, bValue = b?.intValue {\n                                    \
    \      ~^\n                                          Value\n/tmp/tmpewb0btwx.swift:31:22:\
    \ error: cannot use optional chaining on non-optional value of type 'Value'\n\
    \    if let aValue = a?.doubleValue, bValue = b?.doubleValue {\n             \
    \       ~^\n                     \n/tmp/tmpewb0btwx.swift:31:22: error: enum case\
    \ 'doubleValue' cannot be used as an instance member\n    if let aValue = a?.doubleValue,\
    \ bValue = b?.doubleValue {\n                    ~^\n                    Value\n\
    /tmp/tmpewb0btwx.swift:31:47: error: cannot use optional chaining on non-optional\
    \ value of type 'Value'\n    if let aVa"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a < b {\n        return b\n    } else if\
    \ a > b {\n        return a\n    } else {\n        return nil\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnhwelf10.swift:22:10: error: binary operator '<' cannot be applied\
    \ to two 'Value' operands\n    if a < b {\n       ~ ^ ~\n/tmp/tmpnhwelf10.swift:22:10:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a < b {\n         ^\n/tmp/tmpnhwelf10.swift:24:17: error: binary operator\
    \ '>' cannot be applied to two 'Value' operands\n    } else if a > b {\n     \
    \         ~ ^ ~\n/tmp/tmpnhwelf10.swift:24:17: note: binary operator '>' cannot\
    \ be synthesized for enums with associated values\n    } else if a > b {\n   \
    \             ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(x), .intValue(y))\
    \ where x > y:\n        return .intValue(x)\n    case (.intValue(x), .intValue(y))\
    \ where x == y:\n        return nil\n    case (.doubleValue(x), .doubleValue(y))\
    \ where x > y:\n        return .doubleValue(x)\n    case (.doubleValue(x), .doubleValue(y))\
    \ where x == y:\n        return nil\n    case (.stringValue(x), .stringValue(y))\
    \ where x > y:\n        return .stringValue(x)\n    case (.stringValue(x), .stringValue(y))\
    \ where x == y:\n        return nil\n    default:\n        return nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2js1uqdl.swift:23:21: error: cannot find 'x' in scope\n    case\
    \ (.intValue(x), .intValue(y)) where x > y:\n                    ^\n/tmp/tmp2js1uqdl.swift:23:35:\
    \ error: cannot find 'y' in scope\n    case (.intValue(x), .intValue(y)) where\
    \ x > y:\n                                  ^\n/tmp/tmp2js1uqdl.swift:23:45: error:\
    \ cannot find 'x' in scope\n    case (.intValue(x), .intValue(y)) where x > y:\n\
    \                                            ^\n/tmp/tmp2js1uqdl.swift:23:49:\
    \ error: cannot find 'y' in scope\n    case (.intValue(x), .intValue(y)) where\
    \ x > y:\n                                                ^\n/tmp/tmp2js1uqdl.swift:25:21:\
    \ error: cannot find 'x' in scope\n    case (.intValue(x), .intValue(y)) where\
    \ x == y:\n                    ^\n/tmp/tmp2js1uqdl.swift:25:35: error: cannot\
    \ find 'y' in scope\n    case (.intValue(x), .intValue(y)) where x == y:\n   \
    \                               ^\n/tmp/tmp2js1uqdl.swift:25:45: error: cannot\
    \ find 'x' in scope\n    case (.intValue(x), .intValue(y)) where x == y:\n   \
    \                                         ^\n/tmp/tmp2js1uqdl.swift:25:50: error:\
    \ cannot find 'y' in scope\n    case (.intValue(x), .intValue(y)) where x == y:\n\
    \                                                 ^\n/tmp/tmp2js1uqdl.swift:27:24:\
    \ error: cannot find 'x' in scope\n    case (.doubleValue(x), .doubleValue(y))\
    \ where x > y:\n                       ^\n/tmp/tmp2js1uqdl.swift:27:41: error:\
    \ cannot find 'y' in scope\n    case (.doubleValue(x), .doubleValue(y)) where\
    \ x > y:\n                                        ^\n/tmp/tmp2js1uqdl.swift:27:51:\
    \ error: cannot find 'x' in scope\n    case (.doubleValue(x), .doubleValue(y))\
    \ where x > y:\n                                                  ^\n/tmp/tmp2js1uqdl.swift:27:55:\
    \ error: cannot find 'y' in scope\n    case (.doubleValue(x), .doubleValue(y))\
    \ where x > y:\n                                                      ^\n/tmp/tmp2js1uqdl.swift:29:24:\
    \ error: cannot find 'x' in scope\n    case (.doubleValue(x), .doubleValue(y))\
    \ where x == y:\n                       ^\n/tmp/tmp2js1uqdl.swift:29:41: error"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aTyped = a as? Int\n    let bTyped = b\
    \ as? Int\n    let aFloat = aTyped ?? a as? Double\n    let bFloat = bTyped ??\
    \ b as? Double\n    \n    if let aInt = aFloat, let bInt = bFloat {\n        let\
    \ aDiff = Int(aInt - bInt)\n        switch aDiff {\n        case 0...0:\n    \
    \        return nil\n        case 1...0:\n            return aTyped\n        case\
    \ 0...1:\n            return bTyped\n        case 1...1:\n            return .intValue(aInt\
    \ - bInt)\n        }\n    }\n    \n    if let aString = aTyped, let bString =\
    \ bTyped {\n        if aString == bString {\n            return aString\n    \
    \    }\n        if let aDouble = aString, let bDouble = bString {\n          \
    \  switch Double(aDouble) - Double(bDouble) {\n            case 0...0:\n     \
    \           return nil\n            case 1...0:\n                return .stringValue(aString)\n\
    \            case 0...1:\n                return .stringValue(bString)\n     \
    \       case 1...1:\n                return .doubleValue(aDouble - bDouble)\n\
    \            }\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcd394b4g.swift:22:20: warning: cast from 'Value' to unrelated type\
    \ 'Int' always fails\n    let aTyped = a as? Int\n                 ~ ^   ~~~\n\
    /tmp/tmpcd394b4g.swift:23:20: warning: cast from 'Value' to unrelated type 'Int'\
    \ always fails\n    let bTyped = b as? Int\n                 ~ ^   ~~~\n/tmp/tmpcd394b4g.swift:24:30:\
    \ error: cannot convert value of type 'Double?' to expected argument type 'Int'\n\
    \    let aFloat = aTyped ?? a as? Double\n                             ^\n/tmp/tmpcd394b4g.swift:25:30:\
    \ error: cannot convert value of type 'Double?' to expected argument type 'Int'\n\
    \    let bFloat = bTyped ?? b as? Double\n                             ^\n/tmp/tmpcd394b4g.swift:28:21:\
    \ error: no exact matches in call to initializer \n        let aDiff = Int(aInt\
    \ - bInt)\n                    ^\n/tmp/tmpcd394b4g.swift:28:21: note: found candidate\
    \ with type '(Float16) -> Int'\n        let aDiff = Int(aInt - bInt)\n       \
    \             ^\n/tmp/tmpcd394b4g.swift:28:21: note: found candidate with type\
    \ '(Float) -> Int'\n        let aDiff = Int(aInt - bInt)\n                   \
    \ ^\n/tmp/tmpcd394b4g.swift:28:21: note: found candidate with type '(Double) ->\
    \ Int'\n        let aDiff = Int(aInt - bInt)\n                    ^\n/tmp/tmpcd394b4g.swift:28:21:\
    \ note: found candidate with type '(Float80) -> Int'\n        let aDiff = Int(aInt\
    \ - bInt)\n                    ^\n/tmp/tmpcd394b4g.swift:28:21: note: found candidate\
    \ with type '(Builtin.Int64) -> Int'\n        let aDiff = Int(aInt - bInt)\n \
    \                   ^\n/tmp/tmpcd394b4g.swift:28:21: note: found candidate with\
    \ type '(Builtin.Word) -> Int'\n        let aDiff = Int(aInt - bInt)\n       \
    \             ^\n/tmp/tmpcd394b4g.swift:28:21: note: found candidate with type\
    \ '(String) -> Int?'\n        let aDiff = Int(aInt - bInt)\n                 \
    \   ^\n/tmp/tmpcd394b4g.swift:33:20: error: cannot convert return expression of\
    \ type 'Int?' to return type 'Value?'\n            return aTyped\n           \
    \        ^~~~~~\n/tmp/tmpcd394b4g.swift:35:20: error: cannot convert return expression\
    \ of type 'Int?' to return type 'Value?'"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as Value.Type {\n        case .intValue:\n\
    \            switch b as Value.Type {\n                case .intValue:\n     \
    \               return b\n                case .stringValue:\n               \
    \     let aAsInt = Int(a.stringValue)!\n                    let bAsInt = Int(b.stringValue)!\n\
    \                    return aAsInt > bAsInt ? b : a\n            }\n        case\
    \ .doubleValue:\n            switch b as Value.Type {\n                case .intValue:\n\
    \                    let aAsDouble = a.doubleValue\n                    let bAsDouble\
    \ = b.doubleValue\n                    return aAsDouble > bAsDouble ? b : a\n\
    \                case .stringValue:\n                    let aAsDouble = Double(a.stringValue)!\n\
    \                    let bAsDouble = Double(b.stringValue)!\n                \
    \    return aAsDouble > bAsDouble ? b : a\n            }\n        case .stringValue:\n\
    \            switch b as Value.Type {\n                case .intValue:\n     \
    \               let aAsString = a.stringValue\n                    let bAsString\
    \ = b.stringValue\n                    return aAsString > bAsString ? b : a\n\
    \                case .doubleValue:\n                    let aAsString = a.stringValue\n\
    \                    let bAsString = b.stringValue\n                    return\
    \ aAsString > bAsString ? b : a\n                case .stringValue:\n        \
    \            let aAsString = a.stringValue\n                    let bAsString\
    \ = b.stringValue\n                    return aAsString > bAsString ? b : a\n\
    \            }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprpwvca0s.swift:22:14: error: cannot convert value of type 'Value'\
    \ to type 'Value.Type' in coercion\n    switch a as Value.Type {\n           ~~^~~~~~~~~~~~~\n\
    /tmp/tmprpwvca0s.swift:24:22: error: cannot convert value of type 'Value' to type\
    \ 'Value.Type' in coercion\n            switch b as Value.Type {\n           \
    \        ~~^~~~~~~~~~~~~\n/tmp/tmprpwvca0s.swift:28:34: error: type '(String)\
    \ -> Value' cannot conform to 'StringProtocol'\n                    let aAsInt\
    \ = Int(a.stringValue)!\n                                 ^\n/tmp/tmprpwvca0s.swift:28:34:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n                    let aAsInt = Int(a.stringValue)!\n          \
    \                       ^\n/tmp/tmprpwvca0s.swift:28:34: note: required by initializer\
    \ 'init(_:radix:)' where 'S' = '(String) -> Value'\n                    let aAsInt\
    \ = Int(a.stringValue)!\n                                 ^\n/tmp/tmprpwvca0s.swift:28:38:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n      \
    \              let aAsInt = Int(a.stringValue)!\n                            \
    \         ^\n                                     Value\n/tmp/tmprpwvca0s.swift:29:34:\
    \ error: type '(String) -> Value' cannot conform to 'StringProtocol'\n       \
    \             let bAsInt = Int(b.stringValue)!\n                             \
    \    ^\n/tmp/tmprpwvca0s.swift:29:34: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n                    let bAsInt =\
    \ Int(b.stringValue)!\n                                 ^\n/tmp/tmprpwvca0s.swift:29:34:\
    \ note: required by initializer 'init(_:radix:)' where 'S' = '(String) -> Value'\n\
    \                    let bAsInt = Int(b.stringValue)!\n                      \
    \           ^\n/tmp/tmprpwvca0s.swift:29:38: error: enum case 'stringValue' cannot\
    \ be used as an instance member\n                    let bAsInt = Int(b.stringValue)!\n\
    \                                     ^\n                                    \
    \ Value\n/tmp/tmprpwvca0s.swift:33:22: error: cannot convert value of type 'V"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let aint = Int(a) {\n        if let bint\
    \ = Int(b) {\n            return aint > bint ? .intValue(aint) : .intValue(bint)\n\
    \        }\n    }\n    \n    if let adouble = Double(a) {\n        if let bdouble\
    \ = Double(b) {\n            return adouble > bdouble ? .doubleValue(adouble)\
    \ : .doubleValue(bdouble)\n        }\n    }\n    \n    if let astring = String(a)\
    \ {\n        if let bstring = String(b) {\n            return astring > bstring\
    \ ? .stringValue(astring) : .stringValue(bstring)\n        }\n    }\n    \n  \
    \  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpk9tgvt85.swift:22:19: error: initializer 'init(_:radix:)' requires\
    \ that 'Value' conform to 'StringProtocol'\n    if let aint = Int(a) {\n     \
    \             ^\nSwift.FixedWidthInteger:2:23: note: where 'S' = 'Value'\n   \
    \ @inlinable public init?<S>(_ text: S, radix: Int = 10) where S : StringProtocol\n\
    \                      ^\n/tmp/tmpk9tgvt85.swift:23:23: error: initializer 'init(_:radix:)'\
    \ requires that 'Value' conform to 'StringProtocol'\n        if let bint = Int(b)\
    \ {\n                      ^\nSwift.FixedWidthInteger:2:23: note: where 'S' =\
    \ 'Value'\n    @inlinable public init?<S>(_ text: S, radix: Int = 10) where S\
    \ : StringProtocol\n                      ^\n/tmp/tmpk9tgvt85.swift:28:22: error:\
    \ initializer 'init(_:)' requires that 'Value' conform to 'StringProtocol'\n \
    \   if let adouble = Double(a) {\n                     ^\nSwift.Double:2:23: note:\
    \ where 'S' = 'Value'\n    @inlinable public init?<S>(_ text: S) where S : StringProtocol\n\
    \                      ^\n/tmp/tmpk9tgvt85.swift:29:26: error: initializer 'init(_:)'\
    \ requires that 'Value' conform to 'StringProtocol'\n        if let bdouble =\
    \ Double(b) {\n                         ^\nSwift.Double:2:23: note: where 'S'\
    \ = 'Value'\n    @inlinable public init?<S>(_ text: S) where S : StringProtocol\n\
    \                      ^\n/tmp/tmpk9tgvt85.swift:34:22: error: no exact matches\
    \ in call to initializer \n    if let astring = String(a) {\n                \
    \     ^\nSwift.String:4:23: note: candidate requires that 'Value' conform to 'LosslessStringConvertible'\
    \ (requirement specified as 'T' : 'LosslessStringConvertible')\n    @inlinable\
    \ public init<T>(_ value: T) where T : LosslessStringConvertible\n           \
    \           ^\nSwift.String:2:12: note: candidate requires that 'Value' conform\
    \ to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    public\
    \ init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where T : BinaryInteger\n\
    \           ^\nSwift.String:4:12: note: candidate requires that 'Value' conform\
    \ to 'Sequence' (requirement specified as 'S' : 'Sequence')\n    public init"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(nil), .doubleValue(nil),\
    \ .stringValue(nil):\n        return nil\n    case .intValue(_):\n        if let\
    \ b = b.doubleValue() {\n            return .doubleValue(a.doubleValue() > b ?\
    \ 1 : -1)\n        } else {\n            return .intValue(a.intValue() > b.intValue()\
    \ ? 1 : -1)\n        }\n    case .doubleValue(_):\n        if let a = a.doubleValue()\
    \ {\n            return .doubleValue(a.doubleValue() > b ? 1 : -1)\n        }\
    \ else {\n            return .doubleValue(b.doubleValue() > a.doubleValue() ?\
    \ 1 : -1)\n        }\n    case .stringValue(_):\n        if let a = a.doubleValue()\
    \ {\n            return .stringValue(a.doubleValue() > b ? a.stringValue() : b.stringValue())\n\
    \        } else {\n            return .stringValue(b.doubleValue() > a.doubleValue()\
    \ ? b.stringValue() : a.stringValue())\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfr6qje47.swift:23:20: warning: type 'Int' is not optional, value\
    \ can never be nil; this is an error in Swift 6\n    case .intValue(nil), .doubleValue(nil),\
    \ .stringValue(nil):\n                   ^\n/tmp/tmpfr6qje47.swift:23:39: warning:\
    \ type 'Double' is not optional, value can never be nil; this is an error in Swift\
    \ 6\n    case .intValue(nil), .doubleValue(nil), .stringValue(nil):\n        \
    \                              ^\n/tmp/tmpfr6qje47.swift:23:58: warning: type\
    \ 'String' is not optional, value can never be nil; this is an error in Swift\
    \ 6\n    case .intValue(nil), .doubleValue(nil), .stringValue(nil):\n        \
    \                                                 ^\n/tmp/tmpfr6qje47.swift:26:34:\
    \ error: missing argument for parameter #1 in call\n        if let b = b.doubleValue()\
    \ {\n                                 ^\n                                 <#Double#>\n\
    /tmp/tmpfr6qje47.swift:4:10: note: 'doubleValue' declared here\n    case doubleValue(Double)\n\
    \         ^\n/tmp/tmpfr6qje47.swift:26:20: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        if let b = b.doubleValue() {\n      \
    \             ^\n                   Value\n/tmp/tmpfr6qje47.swift:27:49: error:\
    \ binary operator '>' cannot be applied to operands of type 'Value' and '_'\n\
    \            return .doubleValue(a.doubleValue() > b ? 1 : -1)\n             \
    \                   ~~~~~~~~~~~~~~~ ^ ~\n/tmp/tmpfr6qje47.swift:27:47: error:\
    \ missing argument for parameter #1 in call\n            return .doubleValue(a.doubleValue()\
    \ > b ? 1 : -1)\n                                              ^\n           \
    \                                   <#Double#>\n/tmp/tmpfr6qje47.swift:4:10: note:\
    \ 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmpfr6qje47.swift:29:41:\
    \ error: missing argument for parameter #1 in call\n            return .intValue(a.intValue()\
    \ > b.intValue() ? 1 : -1)\n                                        ^\n      \
    \                                  <#Int#>\n/tmp/tmpfr6qje47.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n    "
  stdout: ''
  timestamp: 1660013422
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Int\n    case .intValue(_):\n\
    \        switch b { // Int\n        case .intValue(_):\n            return a\n\
    \        case .doubleValue(_):\n            return b\n        case .stringValue(_):\n\
    \            return nil\n        }\n    case .doubleValue(_):\n        switch\
    \ b { // Double\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return nil\n        }\n    case .stringValue(_):\n        switch b {\
    \ // String\n        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return nil\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmps2i6_krk/tmps2i6_krk.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c69f60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c69c57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c69c57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c69c567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps2i6_krk                        0x000055ffb2c82a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b0c6a14c460 __libc_start_main +
    245

    6    tmps2i6_krk                        0x000055ffb2c82499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let a_is_int = a.intValue != nil\n    let\
    \ b_is_int = b.intValue != nil\n    guard a_is_int && b_is_int else {\n      \
    \  return nil\n    }\n    let a_is_double = a.doubleValue != nil\n    let b_is_double\
    \ = b.doubleValue != nil\n    guard a_is_double && b_is_double else {\n      \
    \  return nil\n    }\n    let a_is_string = a.stringValue != nil\n    let b_is_string\
    \ = b.stringValue != nil\n    guard a_is_string && b_is_string else {\n      \
    \  return nil\n    }\n    if a_is_string {\n        if let a_string_int = Int(a.stringValue!)\
    \ {\n            return b_is_int ? .intValue(a_string_int) : .doubleValue(b_is_double\
    \ ? Double(a_string_int as String) : Double(a_string_int as String))\n       \
    \ }\n        if let a_string_double = Double(a.stringValue!) {\n            return\
    \ b_is_int ? .intValue(a_string_double) : .doubleValue(a_string_double)\n    \
    \    }\n    }\n    if a_is_int {\n        if let a_int_double = a.intValue as?\
    \ Double {\n            return b_is_double ? .doubleValue(a_int_double) : .intValue(b_is_double\
    \ ? Double(a_int_double as String) : Int(a_int_double as String))\n        }\n\
    \        if let a_int_string = a.intValue as? String {\n            if let a_int_string\
    \ = Int(a_int_string) {\n                return b_is_double ? .doubleValue(a_int_string)\
    \ : .intValue(b_is_double ? Double(a_int_string) : Int(a_int_string))\n      \
    \      }\n        }\n    }\n    if a_is_double {\n        if let a_double_string\
    \ = a.doubleValue as? String {\n            if let a_double_string = Double(a_double_string)\
    \ {\n                return b_is_string ? .stringValue(a_double_string) : .doubleValue(a_double_string)\n\
    \            }\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9eaxo95v.swift:22:20: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    let a_is_int = a.intValue != nil\n              \
    \     ^\n                   Value\n/tmp/tmp9eaxo95v.swift:23:20: error: enum case\
    \ 'intValue' cannot be used as an instance member\n    let b_is_int = b.intValue\
    \ != nil\n                   ^\n                   Value\n/tmp/tmp9eaxo95v.swift:27:23:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    let\
    \ a_is_double = a.doubleValue != nil\n                      ^\n              \
    \        Value\n/tmp/tmp9eaxo95v.swift:28:23: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n    let b_is_double = b.doubleValue != nil\n\
    \                      ^\n                      Value\n/tmp/tmp9eaxo95v.swift:32:23:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n    let\
    \ a_is_string = a.stringValue != nil\n                      ^\n              \
    \        Value\n/tmp/tmp9eaxo95v.swift:33:23: error: enum case 'stringValue' cannot\
    \ be used as an instance member\n    let b_is_string = b.stringValue != nil\n\
    \                      ^\n                      Value\n/tmp/tmp9eaxo95v.swift:38:31:\
    \ error: type '(String) -> Value' cannot conform to 'StringProtocol'\n       \
    \ if let a_string_int = Int(a.stringValue!) {\n                              ^\n\
    /tmp/tmp9eaxo95v.swift:38:31: note: only concrete types such as structs, enums\
    \ and classes can conform to protocols\n        if let a_string_int = Int(a.stringValue!)\
    \ {\n                              ^\n/tmp/tmp9eaxo95v.swift:38:31: note: required\
    \ by initializer 'init(_:radix:)' where 'S' = '(String) -> Value'\n        if\
    \ let a_string_int = Int(a.stringValue!) {\n                              ^\n\
    /tmp/tmp9eaxo95v.swift:38:35: error: enum case 'stringValue' cannot be used as\
    \ an instance member\n        if let a_string_int = Int(a.stringValue!) {\n  \
    \                                ^\n                                  Value\n\
    /tmp/tmp9eaxo95v.swift:38:48: error: cannot force unwrap value of non-optional\
    \ type '(String) -> Value'\n        if let a"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as? Value {\n    case let .intValue(valueA):\n\
    \        switch b as? Value {\n        case let .intValue(valueB):\n         \
    \   return valueA > valueB ? a : b\n        case let .doubleValue(valueB):\n \
    \           return valueA > valueB ? a : b\n        case let .stringValue(valueB):\n\
    \            return valueA > valueB ? a : b\n        }\n    case let .doubleValue(valueA):\n\
    \        switch b as? Value {\n        case let .intValue(valueB):\n         \
    \   return valueA > valueB ? a : b\n        case let .doubleValue(valueB):\n \
    \           return valueA > valueB ? a : b\n        case let .stringValue(valueB):\n\
    \            return valueA > valueB ? a : b\n        }\n    case let .stringValue(valueA):\n\
    \        switch b as? Value {\n        case let .intValue(valueB):\n         \
    \   return valueA > valueB ? a : b\n        case let .doubleValue(valueB):\n \
    \           return valueA > valueB ? a : b\n        case let .stringValue(valueB):\n\
    \            return valueA > valueB ? a : b\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpn3pzsodg.swift:22:14: warning: conditional cast from 'Value' to\
    \ 'Value' always succeeds\n    switch a as? Value {\n             ^\n/tmp/tmpn3pzsodg.swift:24:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpn3pzsodg.swift:28:29: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n           \
    \ return valueA > valueB ? a : b\n                            ^\n            \
    \                Int(  )\n/tmp/tmpn3pzsodg.swift:30:29: error: cannot convert\
    \ value of type 'String' to expected argument type 'Int'\n            return valueA\
    \ > valueB ? a : b\n                            ^\n/tmp/tmpn3pzsodg.swift:24:9:\
    \ error: switch must be exhaustive\n        switch b as? Value {\n        ^\n\
    /tmp/tmpn3pzsodg.swift:24:9: note: add missing case: '.none'\n        switch b\
    \ as? Value {\n        ^\n/tmp/tmpn3pzsodg.swift:33:18: warning: conditional cast\
    \ from 'Value' to 'Value' always succeeds\n        switch b as? Value {\n    \
    \             ^\n/tmp/tmpn3pzsodg.swift:35:20: error: cannot convert value of\
    \ type 'Double' to expected argument type 'Int'\n            return valueA > valueB\
    \ ? a : b\n                   ^\n                   Int(  )\n/tmp/tmpn3pzsodg.swift:39:27:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'String'\n            return valueA > valueB ? a : b\n                   ~~~~~~\
    \ ^ ~~~~~~\n/tmp/tmpn3pzsodg.swift:33:9: error: switch must be exhaustive\n  \
    \      switch b as? Value {\n        ^\n/tmp/tmpn3pzsodg.swift:33:9: note: add\
    \ missing case: '.none'\n        switch b as? Value {\n        ^\n/tmp/tmpn3pzsodg.swift:42:18:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        switch\
    \ b as? Value {\n                 ^\n/tmp/tmpn3pzsodg.swift:44:20: error: cannot\
    \ convert value of type 'String' to expected argument type 'Int'\n           \
    \ return valueA > valueB ? a : b\n                   ^\n/tmp/tmpn3pzsodg.swift:46:27:\
    \ error: binary operator '>' cannot be applied to operands of type 'String' and\
    \ 'Double'\n "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b)):\n\
    \        return a\n    case (.doubleValue(a), .doubleValue(b)):\n        return\
    \ a\n    case (.stringValue(a), .stringValue(b)):\n        return a\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp45083vm6.swift:23:21: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case (.intValue(a), .intValue(b)):\n\
    \                    ^\n/tmp/tmp45083vm6.swift:25:24: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .doubleValue(b)):\n                       ^\n/tmp/tmp45083vm6.swift:27:24: error:\
    \ expression pattern of type 'Value' cannot match values of type 'String'\n  \
    \  case (.stringValue(a), .stringValue(b)):\n                       ^\n/tmp/tmp45083vm6.swift:27:24:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case (.stringValue(a), .stringValue(b)):\n        \
    \               ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var val1: Value\n    var val2: Value\n   \
    \ \n    switch (val1, val2) {\n    case (nil, nil):\n        return nil\n    \n\
    \    case (let _ as IntValue, _ as DoubleValue):\n        return .doubleValue(a.value)\
    \ < .doubleValue(b.value) ? a : b\n        \n    case (let _ as IntValue, _ as\
    \ StringValue):\n        return .stringValue(a.value) < .stringValue(b.value)\
    \ ? a : b\n        \n    case (_ as DoubleValue, let _ as IntValue):\n       \
    \ return .doubleValue(a.value) < .intValue(b.value) ? a : b\n        \n    case\
    \ (_ as DoubleValue, let _ as StringValue):\n        return .stringValue(a.value)\
    \ < .stringValue(b.value) ? a : b\n        \n    case (_ as StringValue, let _\
    \ as IntValue):\n        return .stringValue(a.value) < .intValue(b.value) ? a\
    \ : b\n        \n    case (_ as StringValue, let _ as StringValue):\n        return\
    \ .stringValue(a.value) < .stringValue(b.value) ? a : b\n        \n    default:\n\
    \        fatalError(\"Unexpected case\")\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpztytnb0n.swift:26:11: warning: type 'Value' is not optional, value\
    \ can never be nil; this is an error in Swift 6\n    case (nil, nil):\n      \
    \    ^\n/tmp/tmpztytnb0n.swift:26:16: warning: type 'Value' is not optional, value\
    \ can never be nil; this is an error in Swift 6\n    case (nil, nil):\n      \
    \         ^\n/tmp/tmpztytnb0n.swift:29:11: warning: 'let' pattern has no effect;\
    \ sub-pattern didn't bind any variables\n    case (let _ as IntValue, _ as DoubleValue):\n\
    \          ^~~ ~~~~~~~~~~~~~\n          \n/tmp/tmpztytnb0n.swift:29:20: error:\
    \ cannot find type 'IntValue' in scope\n    case (let _ as IntValue, _ as DoubleValue):\n\
    \                   ^~~~~~~~\n/tmp/tmpztytnb0n.swift:32:11: warning: 'let' pattern\
    \ has no effect; sub-pattern didn't bind any variables\n    case (let _ as IntValue,\
    \ _ as StringValue):\n          ^~~ ~~~~~~~~~~~~~\n          \n/tmp/tmpztytnb0n.swift:32:20:\
    \ error: cannot find type 'IntValue' in scope\n    case (let _ as IntValue, _\
    \ as StringValue):\n                   ^~~~~~~~\n/tmp/tmpztytnb0n.swift:35:29:\
    \ warning: 'let' pattern has no effect; sub-pattern didn't bind any variables\n\
    \    case (_ as DoubleValue, let _ as IntValue):\n                           \
    \ ^~~~~~~~~~~~~~~~~\n                            \n/tmp/tmpztytnb0n.swift:35:16:\
    \ error: cannot find type 'DoubleValue' in scope\n    case (_ as DoubleValue,\
    \ let _ as IntValue):\n               ^~~~~~~~~~~\n/tmp/tmpztytnb0n.swift:38:29:\
    \ warning: 'let' pattern has no effect; sub-pattern didn't bind any variables\n\
    \    case (_ as DoubleValue, let _ as StringValue):\n                        \
    \    ^~~~~~~~~~~~~~~~~~~~\n                            \n/tmp/tmpztytnb0n.swift:38:16:\
    \ error: cannot find type 'DoubleValue' in scope\n    case (_ as DoubleValue,\
    \ let _ as StringValue):\n               ^~~~~~~~~~~\n/tmp/tmpztytnb0n.swift:41:29:\
    \ warning: 'let' pattern has no effect; sub-pattern didn't bind any variables\n\
    \    case (_ as StringValue, let _ as IntValue):\n                           \
    \ ^~~~~~~~~~~~~~~~~\n                            \n/tmp/tmpztytnb0n.swift:41:16:\
    \ error: cannot find "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as Value? {\n    case .intValue(n)\
    \ as Int:\n        switch b as Value? {\n        case .intValue(n) as Int:\n \
    \           return n > b\n        case .stringValue(b) as Int:\n            return\
    \ n < a\n        case .doubleValue(b) as Int:\n            return n < b\n    \
    \    }\n    case .doubleValue(n) as Double:\n        switch b as Value? {\n  \
    \      case .intValue(n) as Int:\n            return n > b\n        case .stringValue(b)\
    \ as Int:\n            return n < a\n        case .doubleValue(b) as Int:\n  \
    \          return n < b\n        }\n    case .stringValue(n) as String:\n    \
    \    switch b as Value? {\n        case .intValue(n) as Int:\n            return\
    \ n > b\n        case .stringValue(b) as Int:\n            return n < a\n    \
    \    case .doubleValue(b) as Int:\n            return n < b\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpo8b7k2jo.swift:23:20: error: cannot find 'n' in scope\n    case\
    \ .intValue(n) as Int:\n                   ^\n/tmp/tmpo8b7k2jo.swift:23:23: warning:\
    \ cast from 'Value' to unrelated type 'Int' always fails\n    case .intValue(n)\
    \ as Int:\n                      ^~ ~~~\n/tmp/tmpo8b7k2jo.swift:23:20: error:\
    \ cannot find 'n' in scope\n    case .intValue(n) as Int:\n                  \
    \ ^\n/tmp/tmpo8b7k2jo.swift:23:11: error: type 'Int' has no member 'intValue'\n\
    \    case .intValue(n) as Int:\n         ~^~~~~~~~\n/tmp/tmpo8b7k2jo.swift:32:23:\
    \ error: cannot find 'n' in scope\n    case .doubleValue(n) as Double:\n     \
    \                 ^\n/tmp/tmpo8b7k2jo.swift:32:26: warning: cast from 'Value'\
    \ to unrelated type 'Double' always fails\n    case .doubleValue(n) as Double:\n\
    \                         ^~ ~~~~~~\n/tmp/tmpo8b7k2jo.swift:32:23: error: cannot\
    \ find 'n' in scope\n    case .doubleValue(n) as Double:\n                   \
    \   ^\n/tmp/tmpo8b7k2jo.swift:32:11: error: type 'Double' has no member 'doubleValue'\n\
    \    case .doubleValue(n) as Double:\n         ~^~~~~~~~~~~\n/tmp/tmpo8b7k2jo.swift:41:23:\
    \ error: cannot find 'n' in scope\n    case .stringValue(n) as String:\n     \
    \                 ^\n/tmp/tmpo8b7k2jo.swift:41:26: warning: cast from 'Value'\
    \ to unrelated type 'String' always fails\n    case .stringValue(n) as String:\n\
    \                         ^~ ~~~~~~\n/tmp/tmpo8b7k2jo.swift:41:23: error: cannot\
    \ find 'n' in scope\n    case .stringValue(n) as String:\n                   \
    \   ^\n/tmp/tmpo8b7k2jo.swift:41:11: error: reference to member 'stringValue'\
    \ cannot be resolved without a contextual type\n    case .stringValue(n) as String:\n\
    \          ^\n/tmp/tmpo8b7k2jo.swift:25:24: error: cannot find 'n' in scope\n\
    \        case .intValue(n) as Int:\n                       ^\n/tmp/tmpo8b7k2jo.swift:25:27:\
    \ warning: cast from 'Value' to unrelated type 'Int' always fails\n        case\
    \ .intValue(n) as Int:\n                          ^~ ~~~\n/tmp/tmpo8b7k2jo.swift:25:24:\
    \ error: cannot find 'n' in scope\n        case .intValue(n) as Int:\n       \
    \                ^\n/tmp/tmpo8b7k2jo.sw"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a.intValue() < b.intValue() {\n       \
    \ return a\n    } else if a.intValue() > b.intValue() {\n        return b\n  \
    \  } else if a.doubleValue() < b.doubleValue() {\n        return a\n    } else\
    \ if a.doubleValue() > b.doubleValue() {\n        return b\n    } else {\n   \
    \     return a\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphwpt4uoy.swift:22:8: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if a.intValue() < b.intValue() {\n       ^\n    \
    \   Value\n/tmp/tmphwpt4uoy.swift:22:19: error: missing argument for parameter\
    \ #1 in call\n    if a.intValue() < b.intValue() {\n                  ^\n    \
    \              <#Int#>\n/tmp/tmphwpt4uoy.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmphwpt4uoy.swift:22:21: error:\
    \ referencing operator function '<' on 'Comparable' requires that 'Value' conform\
    \ to 'Comparable'\n    if a.intValue() < b.intValue() {\n                    ^\n\
    Swift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol Comparable\
    \ : Equatable {\n                ^\n/tmp/tmphwpt4uoy.swift:22:21: note: binary\
    \ operator '<' cannot be synthesized for enums with associated values\n    if\
    \ a.intValue() < b.intValue() {\n                    ^\n/tmp/tmphwpt4uoy.swift:22:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if a.intValue()\
    \ < b.intValue() {\n                      ^\n                      Value\n/tmp/tmphwpt4uoy.swift:22:34:\
    \ error: missing argument for parameter #1 in call\n    if a.intValue() < b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmphwpt4uoy.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmphwpt4uoy.swift:24:26: error: missing argument for parameter\
    \ #1 in call\n    } else if a.intValue() > b.intValue() {\n                  \
    \       ^\n                         <#Int#>\n/tmp/tmphwpt4uoy.swift:3:10: note:\
    \ 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmphwpt4uoy.swift:24:15:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    } else\
    \ if a.intValue() > b.intValue() {\n              ^\n              Value\n/tmp/tmphwpt4uoy.swift:24:28:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    } else if a.intValue() > b.intValue() {\n     \
    \                      ^\nSwift.Comparable:1:17: note: where 'Se"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aDouble = a\n    let bDouble = b\n   \
    \ let aInt = a\n    \n    if aDouble.doubleValue() >= bDouble.doubleValue() {\n\
    \        return aDouble\n    } else {\n        return bDouble\n    }\n    \n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmptwblumdx.swift:26:8: error: enum case 'doubleValue' cannot be used\
    \ as an instance member\n    if aDouble.doubleValue() >= bDouble.doubleValue()\
    \ {\n       ^~~~~~~\n       Value\n/tmp/tmptwblumdx.swift:26:28: error: missing\
    \ argument for parameter #1 in call\n    if aDouble.doubleValue() >= bDouble.doubleValue()\
    \ {\n                           ^\n                           <#Double#>\n/tmp/tmptwblumdx.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmptwblumdx.swift:26:30: error: referencing operator function '>=' on 'Comparable'\
    \ requires that 'Value' conform to 'Comparable'\n    if aDouble.doubleValue()\
    \ >= bDouble.doubleValue() {\n                             ^\nSwift.Comparable:1:17:\
    \ note: where 'Self' = 'Value'\npublic protocol Comparable : Equatable {\n   \
    \             ^\n/tmp/tmptwblumdx.swift:26:30: note: binary operator '>=' cannot\
    \ be synthesized for enums with associated values\n    if aDouble.doubleValue()\
    \ >= bDouble.doubleValue() {\n                             ^\n/tmp/tmptwblumdx.swift:26:33:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ aDouble.doubleValue() >= bDouble.doubleValue() {\n                         \
    \       ^~~~~~~\n                                Value\n/tmp/tmptwblumdx.swift:26:53:\
    \ error: missing argument for parameter #1 in call\n    if aDouble.doubleValue()\
    \ >= bDouble.doubleValue() {\n                                               \
    \     ^\n                                                    <#Double#>\n/tmp/tmptwblumdx.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a < b ? .intValue : a > b ? .doubleValue\
    \ : .stringValue {\n    case .intValue(let aInt), .intValue(let bInt):\n     \
    \   return aInt.compare(bInt)\n    case .doubleValue(let aDouble), .doubleValue(let\
    \ bDouble):\n        return aDouble.compare(bDouble)\n    case .stringValue(let\
    \ aString), .stringValue(let bString):\n        return aString.compare(bString)\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcqi6vbwu.swift:23:45: error: 'bInt' must be bound in every pattern\n\
    \    case .intValue(let aInt), .intValue(let bInt):\n                        \
    \                    ^\n/tmp/tmpcqi6vbwu.swift:23:24: error: 'aInt' must be bound\
    \ in every pattern\n    case .intValue(let aInt), .intValue(let bInt):\n     \
    \                  ^\n/tmp/tmpcqi6vbwu.swift:25:54: error: 'bDouble' must be bound\
    \ in every pattern\n    case .doubleValue(let aDouble), .doubleValue(let bDouble):\n\
    \                                                     ^\n/tmp/tmpcqi6vbwu.swift:25:27:\
    \ error: 'aDouble' must be bound in every pattern\n    case .doubleValue(let aDouble),\
    \ .doubleValue(let bDouble):\n                          ^\n/tmp/tmpcqi6vbwu.swift:27:54:\
    \ error: 'bString' must be bound in every pattern\n    case .stringValue(let aString),\
    \ .stringValue(let bString):\n                                               \
    \      ^\n/tmp/tmpcqi6vbwu.swift:27:27: error: 'aString' must be bound in every\
    \ pattern\n    case .stringValue(let aString), .stringValue(let bString):\n  \
    \                        ^\n/tmp/tmpcqi6vbwu.swift:22:14: error: referencing operator\
    \ function '<' on 'Comparable' requires that 'Value' conform to 'Comparable'\n\
    \    switch a < b ? .intValue : a > b ? .doubleValue : .stringValue {\n      \
    \       ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpcqi6vbwu.swift:22:14: note:\
    \ binary operator '<' cannot be synthesized for enums with associated values\n\
    \    switch a < b ? .intValue : a > b ? .doubleValue : .stringValue {\n      \
    \       ^\n/tmp/tmpcqi6vbwu.swift:22:21: error: cannot infer contextual base in\
    \ reference to member 'intValue'\n    switch a < b ? .intValue : a > b ? .doubleValue\
    \ : .stringValue {\n                   ~^~~~~~~~\n/tmp/tmpcqi6vbwu.swift:22:34:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    switch a < b ? .intValue : a > b ? .doubleValue\
    \ : .stringValue {\n                                 ^\nSwift.Comparable:1:17:\
    \ note: where 'S"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a.intValue < b.intValue {\n        return\
    \ a\n    } else if b.intValue < a.intValue {\n        return b\n    } else if\
    \ a.doubleValue < b.doubleValue {\n        return a\n    } else if b.doubleValue\
    \ < a.doubleValue {\n        return b\n    } else if a.stringValue < b.stringValue\
    \ {\n        return a\n    } else if b.stringValue < a.stringValue {\n       \
    \ return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp051ov4js.swift:22:19: error: binary operator '<' cannot be applied\
    \ to two '(Int) -> Value' operands\n    if a.intValue < b.intValue {\n       ~~~~~~~~~~\
    \ ^ ~~~~~~~~~~\n/tmp/tmp051ov4js.swift:24:26: error: binary operator '<' cannot\
    \ be applied to two '(Int) -> Value' operands\n    } else if b.intValue < a.intValue\
    \ {\n              ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp051ov4js.swift:26:29: error:\
    \ binary operator '<' cannot be applied to two '(Double) -> Value' operands\n\
    \    } else if a.doubleValue < b.doubleValue {\n              ~~~~~~~~~~~~~ ^\
    \ ~~~~~~~~~~~~~\n/tmp/tmp051ov4js.swift:28:29: error: binary operator '<' cannot\
    \ be applied to two '(Double) -> Value' operands\n    } else if b.doubleValue\
    \ < a.doubleValue {\n              ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmp051ov4js.swift:30:29:\
    \ error: binary operator '<' cannot be applied to two '(String) -> Value' operands\n\
    \    } else if a.stringValue < b.stringValue {\n              ~~~~~~~~~~~~~ ^\
    \ ~~~~~~~~~~~~~\n/tmp/tmp051ov4js.swift:32:29: error: binary operator '<' cannot\
    \ be applied to two '(String) -> Value' operands\n    } else if b.stringValue\
    \ < a.stringValue {\n              ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard let aIsInt = a.isInt, let bIsInt = b.isInt\
    \ else {\n        if a.isDouble && b.isDouble {\n            return a.doubleValue\
    \ < b.doubleValue\n        }\n        if a.isDouble || b.isDouble {\n        \
    \    return a.isDouble ? a < b : b < a\n        }\n        if a.isString && b.isString\
    \ {\n            return a.stringValue < b.stringValue\n        }\n        if a.isString\
    \ || b.isString {\n            return a.isString ? a < b : b < a\n        }\n\
    \        return nil\n    }\n    \n    if aIsInt != bIsInt { return nil }\n   \
    \ if aIsInt {\n        if a.isInt {\n            return a.intValue > b.intValue\n\
    \        } else {\n            return b.intValue > a.intValue\n        }\n   \
    \ }\n    \n    if a.isDouble {\n        if b.isDouble {\n            return a.doubleValue\
    \ > b.doubleValue\n        } else {\n            return b.doubleValue > a.doubleValue\n\
    \        }\n    }\n    \n    if b.isDouble {\n        if a.isDouble {\n      \
    \      return a.doubleValue > b.doubleValue\n        } else {\n            return\
    \ b.doubleValue > a.doubleValue\n        }\n    }\n    \n    if a.isString {\n\
    \        if b.isString {\n            return a.stringValue > b.stringValue\n \
    \       } else {\n            return b.stringValue > a.stringValue\n        }\n\
    \    }\n    \n    if b.isString {\n        if a.isString {\n            return\
    \ a.stringValue > b.stringValue\n        } else {\n            return b.stringValue\
    \ > a.stringValue\n        }\n    }\n    \n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjxawnfgm.swift:22:26: error: value of type 'Value' has no member\
    \ 'isInt'\n    guard let aIsInt = a.isInt, let bIsInt = b.isInt else {\n     \
    \                  ~ ^~~~~\n/tmp/tmpjxawnfgm.swift:22:48: error: value of type\
    \ 'Value' has no member 'isInt'\n    guard let aIsInt = a.isInt, let bIsInt =\
    \ b.isInt else {\n                                             ~ ^~~~~\n/tmp/tmpjxawnfgm.swift:23:14:\
    \ error: value of type 'Value' has no member 'isDouble'\n        if a.isDouble\
    \ && b.isDouble {\n           ~ ^~~~~~~~\n/tmp/tmpjxawnfgm.swift:23:28: error:\
    \ value of type 'Value' has no member 'isDouble'\n        if a.isDouble && b.isDouble\
    \ {\n                         ~ ^~~~~~~~\n/tmp/tmpjxawnfgm.swift:24:34: error:\
    \ binary operator '<' cannot be applied to two '(Double) -> Value' operands\n\
    \            return a.doubleValue < b.doubleValue\n                   ~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~\n/tmp/tmpjxawnfgm.swift:24:34: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n            return a.doubleValue\
    \ < b.doubleValue\n                   ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpjxawnfgm.swift:26:14:\
    \ error: value of type 'Value' has no member 'isDouble'\n        if a.isDouble\
    \ || b.isDouble {\n           ~ ^~~~~~~~\n/tmp/tmpjxawnfgm.swift:26:28: error:\
    \ value of type 'Value' has no member 'isDouble'\n        if a.isDouble || b.isDouble\
    \ {\n                         ~ ^~~~~~~~\n/tmp/tmpjxawnfgm.swift:27:22: error:\
    \ value of type 'Value' has no member 'isDouble'\n            return a.isDouble\
    \ ? a < b : b < a\n                   ~ ^~~~~~~~\n/tmp/tmpjxawnfgm.swift:27:31:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \            return a.isDouble ? a < b : b < a\n                   ~~~~~~~~~~~^~~~~~~~~~~~~~~\n\
    /tmp/tmpjxawnfgm.swift:27:35: error: referencing operator function '<' on 'Comparable'\
    \ requires that 'Value' conform to 'Comparable'\n            return a.isDouble\
    \ ? a < b : b < a\n                                  ^\nSwift.Comparable:1:17:\
    \ note: where 'Self' = 'Value'\npublic protocol Comparable : Equat"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let aIntValue = a.intValue, bIntValue =\
    \ b.intValue {\n        if aIntValue > bIntValue {\n            return a\n   \
    \     } else {\n            return b\n        }\n    } else if let aDoubleValue\
    \ = a.doubleValue, bDoubleValue = b.doubleValue {\n        if aDoubleValue > bDoubleValue\
    \ {\n            return a\n        } else {\n            return b\n        }\n\
    \    } else if let aStringValue = a.stringValue, bStringValue = b.stringValue\
    \ {\n        if aStringValue > bStringValue {\n            return a\n        }\
    \ else {\n            return b\n        }\n    } else {\n        return nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnjgumy39.swift:22:36: error: expected 'let' in conditional\n  \
    \  if let aIntValue = a.intValue, bIntValue = b.intValue {\n                 \
    \                  ^\n                                   let \n/tmp/tmpnjgumy39.swift:28:49:\
    \ error: expected 'let' in conditional\n    } else if let aDoubleValue = a.doubleValue,\
    \ bDoubleValue = b.doubleValue {\n                                           \
    \     ^\n                                                let \n/tmp/tmpnjgumy39.swift:34:49:\
    \ error: expected 'let' in conditional\n    } else if let aStringValue = a.stringValue,\
    \ bStringValue = b.stringValue {\n                                           \
    \     ^\n                                                let \n/tmp/tmpnjgumy39.swift:22:24:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ aIntValue = a.intValue, bIntValue = b.intValue {\n                       ^\n\
    \                       Value\n/tmp/tmpnjgumy39.swift:22:48: error: enum case\
    \ 'intValue' cannot be used as an instance member\n    if let aIntValue = a.intValue,\
    \ bIntValue = b.intValue {\n                                               ^\n\
    \                                               Value\n/tmp/tmpnjgumy39.swift:28:34:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    } else\
    \ if let aDoubleValue = a.doubleValue, bDoubleValue = b.doubleValue {\n      \
    \                           ^\n                                 Value\n/tmp/tmpnjgumy39.swift:28:64:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    } else\
    \ if let aDoubleValue = a.doubleValue, bDoubleValue = b.doubleValue {\n      \
    \                                                         ^\n                \
    \                                               Value\n/tmp/tmpnjgumy39.swift:34:34:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n    } else\
    \ if let aStringValue = a.stringValue, bStringValue = b.stringValue {\n      \
    \                           ^\n                                 Value\n/tmp/tmpnjgumy39.swift:34:64:\
    \ error: enum case 'stringValue' cannot"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue:\n        switch\
    \ b {\n        case .intValue:\n            return a\n        case .doubleValue:\n\
    \            return b\n        case .stringValue:\n            let a = a.stringValue\n\
    \            let b = b.stringValue\n            if a == b {\n                return\
    \ nil\n            }\n            if a.isEmpty {\n                return b\n \
    \           }\n            if b.isEmpty {\n                return a\n        \
    \    }\n            let aArray = a.characters.split(\",\")\n            let bArray\
    \ = b.characters.split(\",\")\n            if aArray.count == bArray.count {\n\
    \                for index in 0..<bArray.count {\n                    if aArray[index]\
    \ != bArray[index] {\n                        return self\n                  \
    \  }\n                }\n            } else {\n                return self\n \
    \           }\n        }\n    case .doubleValue:\n        switch b {\n       \
    \ case .intValue:\n            return a\n        case .doubleValue:\n        \
    \    return b\n        case .stringValue:\n            let a = a.stringValue\n\
    \            let b = b.stringValue\n            if a.isEmpty {\n             \
    \   return b\n            }\n            if b.isEmpty {\n                return\
    \ a\n            }\n            let aArray = a.characters.split(\",\")\n     \
    \       let bArray = b.characters.split(\",\")\n            if aArray.count ==\
    \ bArray.count {\n                for index in 0..<bArray.count {\n          \
    \          if aArray[index] != bArray[index] {\n                        return\
    \ self\n                    }\n                }\n            } else {\n     \
    \           return self\n            }\n        }\n    case .stringValue:\n  \
    \      let a = a.stringValue\n        let b = b.stringValue\n        if a == b\
    \ {\n            return self\n        }\n        if a.isEmpty {\n            return\
    \ b\n        }\n        if b.isEmpty {\n            return a\n        }\n    \
    \    let aArray = a.characters.split(\",\")\n        let bArray = b.characters.split(\"\
    ,\")\n        if aArray.count == bArray.count {\n            for index in 0..<bArray.count\
    \ {\n                if aArray[index] != bArray[index] {\n                   \
    \ return self\n                }\n            }\n        } else {\n          \
    \  return self\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4llplz9a.swift:30:21: error: enum case 'stringValue' cannot be\
    \ used as an instance member\n            let a = a.stringValue\n            \
    \        ^\n                    Value\n/tmp/tmp4llplz9a.swift:31:21: error: enum\
    \ case 'stringValue' cannot be used as an instance member\n            let b =\
    \ b.stringValue\n                    ^\n                    Value\n/tmp/tmp4llplz9a.swift:50:24:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n                return self\n                       ^~~~\n/tmp/tmp4llplz9a.swift:60:21:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n      \
    \      let a = a.stringValue\n                    ^\n                    Value\n\
    /tmp/tmp4llplz9a.swift:61:21: error: enum case 'stringValue' cannot be used as\
    \ an instance member\n            let b = b.stringValue\n                    ^\n\
    \                    Value\n/tmp/tmp4llplz9a.swift:77:24: error: cannot find 'self'\
    \ in scope; did you mean to use it in a type or extension context?\n         \
    \       return self\n                       ^~~~\n/tmp/tmp4llplz9a.swift:81:17:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n      \
    \  let a = a.stringValue\n                ^\n                Value\n/tmp/tmp4llplz9a.swift:82:17:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n      \
    \  let b = b.stringValue\n                ^\n                Value\n/tmp/tmp4llplz9a.swift:84:20:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n            return self\n                   ^~~~\n/tmp/tmp4llplz9a.swift:101:20:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n            return self\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var a_double: Double?\n    var b_double: Double?\n\
    \    \n    if let a = a.doubleValue {\n        a_double = a\n    }\n    if let\
    \ b = b.doubleValue {\n        b_double = b\n    }\n    \n    switch a {\n   \
    \ case .intValue(a):\n        switch b {\n        case .intValue(b): // Ints compare\
    \ as equal.\n        case .doubleValue(b_double): // Int and Double compare as\
    \ equal.\n        case .stringValue(b_double!): // Double and String compare as\
    \ equal.\n        case .stringValue(b_double!): // Double and String compare as\
    \ equal.\n            return b\n        default:\n            return nil\n   \
    \     }\n    case .doubleValue(a_double!):\n        switch b {\n        case .intValue(b_double!):\
    \ // Double and Int compare as equal.\n            return b\n        case .doubleValue(b):\
    \ // Double compares less than Int.\n            return b\n        case .stringValue(b_double!):\
    \ // Double compares less than Double.\n            return b\n        case .stringValue(b_double!):\
    \ // Double compares less than String.\n            return b\n        default:\n\
    \            return nil\n        }\n    case .stringValue(a):\n        switch\
    \ b {\n        case .intValue(b_double!): // String and Int compare as equal.\n\
    \            return b\n        case .doubleValue(b): // String compares less than\
    \ Int.\n            return b\n        case .stringValue(b_double!): // String\
    \ compares less than Double.\n            return b\n        default:\n       \
    \     return nil\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp1l_liyta.swift:35:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case .intValue(b): // Ints compare\
    \ as equal.\n        ^~~~~~~~~~~~~~~~~~\n                           break\n/tmp/tmp1l_liyta.swift:36:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case .doubleValue(b_double): // Int and Double compare as equal.\n  \
    \      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                                     break\n\
    /tmp/tmp1l_liyta.swift:37:9: error: 'case' label in a 'switch' must have at least\
    \ one executable statement\n        case .stringValue(b_double!): // Double and\
    \ String compare as equal.\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n          \
    \                            break\n/tmp/tmp1l_liyta.swift:25:16: error: enum\
    \ case 'doubleValue' cannot be used as an instance member\n    if let a = a.doubleValue\
    \ {\n               ^\n               Value\n/tmp/tmp1l_liyta.swift:28:16: error:\
    \ enum case 'doubleValue' cannot be used as an instance member\n    if let b =\
    \ b.doubleValue {\n               ^\n               Value\n/tmp/tmp1l_liyta.swift:33:20:\
    \ error: expression pattern of type 'Value' cannot match values of type 'Int'\n\
    \    case .intValue(a):\n                   ^\n/tmp/tmp1l_liyta.swift:56:23: error:\
    \ expression pattern of type 'Value' cannot match values of type 'String'\n  \
    \  case .stringValue(a):\n                      ^\n/tmp/tmp1l_liyta.swift:56:23:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case .stringValue(a):\n                      ^\n/tmp/tmp1l_liyta.swift:35:24:\
    \ error: expression pattern of type 'Value' cannot match values of type 'Int'\n\
    \        case .intValue(b): // Ints compare as equal.\n                      \
    \ ^\n/tmp/tmp1l_liyta.swift:37:35: error: expression pattern of type 'Double'\
    \ cannot match values of type 'String'\n        case .stringValue(b_double!):\
    \ // Double and String compare as equal.\n                                  ^\n\
    /tmp/tmp1l_liyta.swift:37:35: note: overloads for '~=' exist with these pa"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let a = a.intValue,\n        let b = b.doubleValue,\n\
    \        !(a.isNaN && b.isNaN),\n        !(a.isInfinite && b.isInfinite),\n  \
    \      !(a.isNaN && b.isNaN),\n        !(a.isInfinite && b.isInfinite),\n    \
    \    !(a.doubleValue == b.doubleValue) {\n        return a\n    } else if let\
    \ a = a.doubleValue,\n        let b = b.intValue,\n        !(a.isNaN && b.isNaN),\n\
    \        !(a.isInfinite && b.isInfinite),\n        !(a.isNaN && b.isNaN),\n  \
    \      !(a.isInfinite && b.isInfinite),\n        !(a.intValue == b.intValue) {\n\
    \        return a\n    } else if let a = a.stringValue,\n        let b = b.stringValue,\n\
    \        !(a.isNaN && b.isNaN),\n        !(a.isInfinite && b.isInfinite),\n  \
    \      !(a.isNaN && b.isNaN),\n        !(a.isInfinite && b.isInfinite),\n    \
    \    !(a.stringValue == b.stringValue) {\n        return a\n    } else {\n   \
    \     return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp14eeoy6l.swift:22:16: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if let a = a.intValue,\n               ^\n      \
    \         Value\n/tmp/tmp14eeoy6l.swift:23:17: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n        let b = b.doubleValue,\n     \
    \           ^\n                Value\n/tmp/tmp14eeoy6l.swift:30:23: error: enum\
    \ case 'doubleValue' cannot be used as an instance member\n    } else if let a\
    \ = a.doubleValue,\n                      ^\n                      Value\n/tmp/tmp14eeoy6l.swift:31:17:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        let\
    \ b = b.intValue,\n                ^\n                Value\n/tmp/tmp14eeoy6l.swift:38:23:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n    } else\
    \ if let a = a.stringValue,\n                      ^\n                      Value\n\
    /tmp/tmp14eeoy6l.swift:39:17: error: enum case 'stringValue' cannot be used as\
    \ an instance member\n        let b = b.stringValue,\n                ^\n    \
    \            Value\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_): return\
    \ b == .intValue(a) ? .intValue(b) : nil\n    case .doubleValue(_): return b ==\
    \ .doubleValue(a) ? .doubleValue(b) : nil\n    case .stringValue(_): return b\
    \ == .stringValue(a) ? .stringValue(b) : nil\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmlasxpnl.swift:23:46: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n    case .intValue(_): return b == .intValue(a)\
    \ ? .intValue(b) : nil\n                                             ^\n/tmp/tmpmlasxpnl.swift:23:61:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Int'\n\
    \    case .intValue(_): return b == .intValue(a) ? .intValue(b) : nil\n      \
    \                                                      ^\n/tmp/tmpmlasxpnl.swift:24:52:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \    case .doubleValue(_): return b == .doubleValue(a) ? .doubleValue(b) : nil\n\
    \                                                   ^\n/tmp/tmpmlasxpnl.swift:24:70:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \    case .doubleValue(_): return b == .doubleValue(a) ? .doubleValue(b) : nil\n\
    \                                                                     ^\n/tmp/tmpmlasxpnl.swift:25:52:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \    case .stringValue(_): return b == .stringValue(a) ? .stringValue(b) : nil\n\
    \                                                   ^\n/tmp/tmpmlasxpnl.swift:25:70:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \    case .stringValue(_): return b == .stringValue(a) ? .stringValue(b) : nil\n\
    \                                                                     ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n        case (let .intValue(aValue),\
    \ let .doubleValue(bValue)) where aValue > bValue:\n            return .doubleValue(bValue)\n\
    \        case (let .intValue(aValue), let .stringValue(bValue)) where aValue >\
    \ bValue:\n            return .stringValue(bValue)\n        case (let .stringValue(aValue),\
    \ let .stringValue(bValue)) where aValue > bValue:\n            return .stringValue(bValue)\n\
    \        case (let .stringValue(aValue), let .doubleValue(bValue)) where aValue\
    \ < bValue:\n            return .intValue(aValue)\n        case (let .intValue(aValue),\
    \ let .stringValue(bValue)) where aValue < bValue:\n            return nil\n \
    \       default:\n            return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5zm74gpv.swift:23:77: error: binary operator '>' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n        case (let .intValue(aValue),\
    \ let .doubleValue(bValue)) where aValue > bValue:\n                         \
    \                                            ~~~~~~ ^ ~~~~~~\n/tmp/tmp5zm74gpv.swift:23:77:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        case (let .intValue(aValue), let .doubleValue(bValue)) where\
    \ aValue > bValue:\n                                                         \
    \                   ^\n/tmp/tmp5zm74gpv.swift:25:77: error: binary operator '>'\
    \ cannot be applied to operands of type 'Int' and 'String'\n        case (let\
    \ .intValue(aValue), let .stringValue(bValue)) where aValue > bValue:\n      \
    \                                                               ~~~~~~ ^ ~~~~~~\n\
    /tmp/tmp5zm74gpv.swift:25:77: note: overloads for '>' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        case (let .intValue(aValue), let\
    \ .stringValue(bValue)) where aValue > bValue:\n                             \
    \                                               ^\n/tmp/tmp5zm74gpv.swift:29:80:\
    \ error: binary operator '<' cannot be applied to operands of type 'String' and\
    \ 'Double'\n        case (let .stringValue(aValue), let .doubleValue(bValue))\
    \ where aValue < bValue:\n                                                   \
    \                     ~~~~~~ ^ ~~~~~~\n/tmp/tmp5zm74gpv.swift:29:80: note: overloads\
    \ for '<' exist with these partially matching parameter lists: (String, String)\n\
    \        case (let .stringValue(aValue), let .doubleValue(bValue)) where aValue\
    \ < bValue:\n                                                                \
    \               ^\n/tmp/tmp5zm74gpv.swift:31:77: error: binary operator '<' cannot\
    \ be applied to operands of type 'Int' and 'String'\n        case (let .intValue(aValue),\
    \ let .stringValue(bValue)) where aValue < bValue:\n                         \
    \                                            ~~~~~~ ^ ~~~~~~\n/tmp/tmp5zm74gpv.swift:31:77:\
    \ note: overl"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue = a\n    var bValue = b\n    if\
    \ aValue is String && bValue is String {\n        if aValue < bValue { return\
    \ aValue }\n        if aValue > bValue { return bValue }\n        return nil\n\
    \    }\n    if aValue is Int && bValue is Double {\n        if aValue < bValue\
    \ { return aValue }\n        if aValue > bValue { return bValue }\n        return\
    \ nil\n    }\n    if aValue is Double && bValue is Int {\n        if aValue <\
    \ bValue { return aValue }\n        if aValue > bValue { return bValue }\n   \
    \     return nil\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5wh4de0i.swift:24:15: warning: cast from 'Value' to unrelated type\
    \ 'String' always fails\n    if aValue is String && bValue is String {\n     \
    \  ~~~~~~ ^  ~~~~~~\n/tmp/tmp5wh4de0i.swift:24:35: warning: cast from 'Value'\
    \ to unrelated type 'String' always fails\n    if aValue is String && bValue is\
    \ String {\n                           ~~~~~~ ^  ~~~~~~\n/tmp/tmp5wh4de0i.swift:25:19:\
    \ error: binary operator '<' cannot be applied to two 'Value' operands\n     \
    \   if aValue < bValue { return aValue }\n           ~~~~~~ ^ ~~~~~~\n/tmp/tmp5wh4de0i.swift:25:19:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \        if aValue < bValue { return aValue }\n                  ^\n/tmp/tmp5wh4de0i.swift:26:19:\
    \ error: binary operator '>' cannot be applied to two 'Value' operands\n     \
    \   if aValue > bValue { return bValue }\n           ~~~~~~ ^ ~~~~~~\n/tmp/tmp5wh4de0i.swift:26:19:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \        if aValue > bValue { return bValue }\n                  ^\n/tmp/tmp5wh4de0i.swift:29:15:\
    \ warning: cast from 'Value' to unrelated type 'Int' always fails\n    if aValue\
    \ is Int && bValue is Double {\n       ~~~~~~ ^  ~~~\n/tmp/tmp5wh4de0i.swift:29:32:\
    \ warning: cast from 'Value' to unrelated type 'Double' always fails\n    if aValue\
    \ is Int && bValue is Double {\n                        ~~~~~~ ^  ~~~~~~\n/tmp/tmp5wh4de0i.swift:30:19:\
    \ error: binary operator '<' cannot be applied to two 'Value' operands\n     \
    \   if aValue < bValue { return aValue }\n           ~~~~~~ ^ ~~~~~~\n/tmp/tmp5wh4de0i.swift:30:19:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \        if aValue < bValue { return aValue }\n                  ^\n/tmp/tmp5wh4de0i.swift:31:19:\
    \ error: binary operator '>' cannot be applied to two 'Value' operands\n     \
    \   if aValue > bValue { return bValue }\n           ~~~~~~ ^ ~~~~~~\n/tmp/tmp5wh4de0i.swift:31:19:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \        if aValue > bValue { ret"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aIsInt = (a.type == .intValue) || (a.type\
    \ == .stringValue)\n    let bIsInt = (b.type == .intValue) || (b.type == .stringValue)\n\
    \    if aIsInt && !bIsInt { return .intValue(Int(a.intValue) > Int(b.intValue))\
    \ }\n    else if aIsInt && bIsInt { return nil }\n    else if !aIsInt && bIsInt\
    \ { return nil }\n\n    let aIsDouble = (a.type == .doubleValue) || (a.type ==\
    \ .stringValue)\n    let bIsDouble = (b.type == .doubleValue) || (b.type == .stringValue)\n\
    \    if aIsDouble && !bIsDouble { return .doubleValue(Double(a.doubleValue) >\
    \ Double(b.doubleValue)) }\n    else if aIsDouble && bIsDouble { return nil }\n\
    \    else if !aIsDouble && bIsDouble { return nil }\n\n    let aIsString = (a.type\
    \ == .stringValue) || (a.type == .intValue)\n    let bIsString = (b.type == .stringValue)\
    \ || (b.type == .intValue)\n    if aIsString && !bIsString { return .stringValue(a.stringValue\
    \ > b.stringValue) }\n    else if aIsString && bIsString { return nil }\n    else\
    \ if !aIsString && bIsString { return nil }\n    \n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppyw5x06n.swift:22:21: error: value of type 'Value' has no member\
    \ 'type'\n    let aIsInt = (a.type == .intValue) || (a.type == .stringValue)\n\
    \                  ~ ^~~~\n/tmp/tmppyw5x06n.swift:22:46: error: value of type\
    \ 'Value' has no member 'type'\n    let aIsInt = (a.type == .intValue) || (a.type\
    \ == .stringValue)\n                                           ~ ^~~~\n/tmp/tmppyw5x06n.swift:23:21:\
    \ error: value of type 'Value' has no member 'type'\n    let bIsInt = (b.type\
    \ == .intValue) || (b.type == .stringValue)\n                  ~ ^~~~\n/tmp/tmppyw5x06n.swift:23:46:\
    \ error: value of type 'Value' has no member 'type'\n    let bIsInt = (b.type\
    \ == .intValue) || (b.type == .stringValue)\n                                \
    \           ~ ^~~~\n/tmp/tmppyw5x06n.swift:24:61: error: cannot convert value\
    \ of type 'Bool' to expected argument type 'Int'\n    if aIsInt && !bIsInt { return\
    \ .intValue(Int(a.intValue) > Int(b.intValue)) }\n                           \
    \                                 ^\n/tmp/tmppyw5x06n.swift:24:45: error: type\
    \ '(Int) -> Value' cannot conform to 'BinaryInteger'\n    if aIsInt && !bIsInt\
    \ { return .intValue(Int(a.intValue) > Int(b.intValue)) }\n                  \
    \                          ^\n/tmp/tmppyw5x06n.swift:24:45: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n    if aIsInt\
    \ && !bIsInt { return .intValue(Int(a.intValue) > Int(b.intValue)) }\n       \
    \                                     ^\n/tmp/tmppyw5x06n.swift:24:45: note: required\
    \ by initializer 'init(_:)' where 'T' = '(Int) -> Value'\n    if aIsInt && !bIsInt\
    \ { return .intValue(Int(a.intValue) > Int(b.intValue)) }\n                  \
    \                          ^\n/tmp/tmppyw5x06n.swift:24:49: error: enum case 'intValue'\
    \ cannot be used as an instance member\n    if aIsInt && !bIsInt { return .intValue(Int(a.intValue)\
    \ > Int(b.intValue)) }\n                                                ^\n  \
    \                                              Value\n/tmp/tmppyw5x06n.swift:24:63:\
    \ error: type '(Int) -> Value' cannot conform to 'BinaryInteger'"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let floatA = Float(a.doubleValue)\n    let\
    \ floatB = Float(b.doubleValue)\n    if floatA == floatB {\n        if let a =\
    \ a.stringValue, let b = b.stringValue {\n            switch a {\n           \
    \ case b:\n                return a\n            case _:\n                return\
    \ b\n            }\n        } else if let a = a.intValue, let b = b.intValue {\n\
    \            switch a {\n            case b:\n                return a\n     \
    \       case _:\n                return b\n            }\n        } else {\n \
    \           return nil\n        }\n    } else {\n        return nil\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7xz6qvx0.swift:22:18: error: no exact matches in call to initializer\
    \ \n    let floatA = Float(a.doubleValue)\n                 ^\n/tmp/tmp7xz6qvx0.swift:22:18:\
    \ note: found candidate with type '(@escaping (Double) -> Value) -> Float?'\n\
    \    let floatA = Float(a.doubleValue)\n                 ^\n/tmp/tmp7xz6qvx0.swift:22:18:\
    \ note: found candidate with type '(@escaping (Double) -> Value) -> Float'\n \
    \   let floatA = Float(a.doubleValue)\n                 ^\n/tmp/tmp7xz6qvx0.swift:23:18:\
    \ error: no exact matches in call to initializer \n    let floatB = Float(b.doubleValue)\n\
    \                 ^\n/tmp/tmp7xz6qvx0.swift:23:18: note: found candidate with\
    \ type '(@escaping (Double) -> Value) -> Float?'\n    let floatB = Float(b.doubleValue)\n\
    \                 ^\n/tmp/tmp7xz6qvx0.swift:23:18: note: found candidate with\
    \ type '(@escaping (Double) -> Value) -> Float'\n    let floatB = Float(b.doubleValue)\n\
    \                 ^\n/tmp/tmp7xz6qvx0.swift:25:20: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n        if let a = a.stringValue, let\
    \ b = b.stringValue {\n                   ^\n                   Value\n/tmp/tmp7xz6qvx0.swift:25:43:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n      \
    \  if let a = a.stringValue, let b = b.stringValue {\n                       \
    \                   ^\n                                          Value\n/tmp/tmp7xz6qvx0.swift:32:27:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        }\
    \ else if let a = a.intValue, let b = b.intValue {\n                         \
    \ ^\n                          Value\n/tmp/tmp7xz6qvx0.swift:32:47: error: enum\
    \ case 'intValue' cannot be used as an instance member\n        } else if let\
    \ a = a.intValue, let b = b.intValue {\n                                     \
    \         ^\n                                              Value\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 > b: return v1\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 < b: return nil\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 == b: return v1\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 == b: return nil\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 != b: return nil\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 != b: return v1\n    default: return nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpammx98yo.swift:23:20: error: cannot find 'v1' in scope\n    case\
    \ .intValue(v1), .doubleValue(v1), .stringValue(v1) where v1 > b: return v1\n\
    \                   ^~\n/tmp/tmpammx98yo.swift:23:38: error: cannot find 'v1'\
    \ in scope\n    case .intValue(v1), .doubleValue(v1), .stringValue(v1) where v1\
    \ > b: return v1\n                                     ^~\n/tmp/tmpammx98yo.swift:23:56:\
    \ error: cannot find 'v1' in scope\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 > b: return v1\n                                 \
    \                      ^~\n/tmp/tmpammx98yo.swift:23:66: error: cannot find 'v1'\
    \ in scope\n    case .intValue(v1), .doubleValue(v1), .stringValue(v1) where v1\
    \ > b: return v1\n                                                           \
    \      ^~\n/tmp/tmpammx98yo.swift:23:69: error: binary operator '>' cannot be\
    \ applied to operands of type '_' and 'Value'\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 > b: return v1\n                                 \
    \                                ~~ ^ ~\n/tmp/tmpammx98yo.swift:24:20: error:\
    \ cannot find 'v1' in scope\n    case .intValue(v1), .doubleValue(v1), .stringValue(v1)\
    \ where v1 < b: return nil\n                   ^~\n/tmp/tmpammx98yo.swift:24:38:\
    \ error: cannot find 'v1' in scope\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 < b: return nil\n                                \
    \     ^~\n/tmp/tmpammx98yo.swift:24:56: error: cannot find 'v1' in scope\n   \
    \ case .intValue(v1), .doubleValue(v1), .stringValue(v1) where v1 < b: return\
    \ nil\n                                                       ^~\n/tmp/tmpammx98yo.swift:24:66:\
    \ error: cannot find 'v1' in scope\n    case .intValue(v1), .doubleValue(v1),\
    \ .stringValue(v1) where v1 < b: return nil\n                                \
    \                                 ^~\n/tmp/tmpammx98yo.swift:24:69: error: binary\
    \ operator '<' cannot be applied to operands of type '_' and 'Value'\n    case\
    \ .intValue(v1), .doubleValue(v1), .stringValue(v1) where v1 < b: return nil\n\
    \                                       "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch b {\n    case .intValue(b):\n     \
    \   if a == .intValue(b) {\n            return nil\n        }\n        return\
    \ a\n    case .doubleValue(b):\n        if a == .doubleValue(b) {\n          \
    \  return nil\n        }\n        return a\n    case .stringValue(b):\n      \
    \  if a == .stringValue(b) {\n            return nil\n        }\n        return\
    \ a\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5yvk9zq1.swift:23:20: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case .intValue(b):\n                \
    \   ^\n/tmp/tmp5yvk9zq1.swift:28:23: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Double'\n    case .doubleValue(b):\n          \
    \            ^\n/tmp/tmp5yvk9zq1.swift:33:23: error: expression pattern of type\
    \ 'Value' cannot match values of type 'String'\n    case .stringValue(b):\n  \
    \                    ^\n/tmp/tmp5yvk9zq1.swift:33:23: note: overloads for '~='\
    \ exist with these partially matching parameter lists: (Substring, String)\n \
    \   case .stringValue(b):\n                      ^\n/tmp/tmp5yvk9zq1.swift:24:27:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Int'\n\
    \        if a == .intValue(b) {\n                          ^\n/tmp/tmp5yvk9zq1.swift:29:30:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \        if a == .doubleValue(b) {\n                             ^\n/tmp/tmp5yvk9zq1.swift:34:30:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \        if a == .stringValue(b) {\n                             ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as! Eq.Element {\n    case .intValue:\n\
    \        switch b as! Eq.Element {\n        case .intValue: return a\n       \
    \ case .doubleValue: return b\n        case .stringValue: return nil\n       \
    \ }\n    case .doubleValue:\n        switch b as! Eq.Element {\n        case .intValue:\
    \ return a\n        case .doubleValue: return b\n        case .stringValue: return\
    \ nil\n        }\n    case .stringValue:\n        switch b as! Eq.Element {\n\
    \        case .intValue: return a\n        case .doubleValue: return b\n     \
    \   case .stringValue: return nil\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpc2bdhvxl.swift:22:18: error: cannot find type 'Eq' in scope\n \
    \   switch a as! Eq.Element {\n                 ^~\n/tmp/tmpc2bdhvxl.swift:24:22:\
    \ error: cannot find type 'Eq' in scope\n        switch b as! Eq.Element {\n \
    \                    ^~\n/tmp/tmpc2bdhvxl.swift:30:22: error: cannot find type\
    \ 'Eq' in scope\n        switch b as! Eq.Element {\n                     ^~\n\
    /tmp/tmpc2bdhvxl.swift:36:22: error: cannot find type 'Eq' in scope\n        switch\
    \ b as! Eq.Element {\n                     ^~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aReal: Double\n    let bReal: Double\n\
    \    switch (a.doubleValue, b.realValue) {\n    case (nil, b.realValue):\n   \
    \     return nil\n    case (nil, a.doubleValue):\n        return nil\n    case\
    \ (false, true):\n        return nil\n    case (true, false):\n        return\
    \ nil\n    case (false, false):\n        return nil\n    case (true, true):\n\
    \        return a\n    case (false, true):\n        return b\n    case (true,\
    \ false):\n        return a\n    case (false, false):\n        return b\n    case\
    \ (true, true):\n        return a\n    default:\n        aReal = a.realValue\n\
    \        bReal = b.realValue\n        if aReal > bReal {\n            return a\n\
    \        } else if aReal < bReal {\n            return b\n        } else {\n \
    \           return a\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp70v795s5.swift:24:13: error: enum case 'doubleValue' cannot be\
    \ used as an instance member\n    switch (a.doubleValue, b.realValue) {\n    \
    \        ^\n            Value\n/tmp/tmp70v795s5.swift:24:30: error: value of type\
    \ 'Value' has no member 'realValue'\n    switch (a.doubleValue, b.realValue) {\n\
    \                           ~ ^~~~~~~~~\n/tmp/tmp70v795s5.swift:46:19: error:\
    \ value of type 'Value' has no member 'realValue'\n        aReal = a.realValue\n\
    \                ~ ^~~~~~~~~\n/tmp/tmp70v795s5.swift:47:19: error: value of type\
    \ 'Value' has no member 'realValue'\n        bReal = b.realValue\n           \
    \     ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(value):\n \
    \       if let b = b as? Value {\n            switch b {\n            case .intValue(value):\n\
    \                return value\n            case .doubleValue(value):\n       \
    \         return value\n            case .stringValue(value):\n              \
    \  return value\n            }\n        }\n        return nil\n    case .doubleValue(value):\n\
    \        if let b = b as? Value {\n            switch b {\n            case .intValue(value):\n\
    \                return value\n            case .doubleValue(value):\n       \
    \         return value\n            case .stringValue(value):\n              \
    \  return value\n            }\n        }\n        return nil\n    case .stringValue(value):\n\
    \        if let b = b as? Value {\n            switch b {\n            case .intValue(value):\n\
    \                return value\n            case .doubleValue(value):\n       \
    \         return value\n            case .stringValue(value):\n              \
    \  return value\n            }\n        }\n        return nil\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfrw0y6mh.swift:23:20: error: cannot find 'value' in scope\n   \
    \ case .intValue(value):\n                   ^~~~~\n/tmp/tmpfrw0y6mh.swift:35:23:\
    \ error: cannot find 'value' in scope\n    case .doubleValue(value):\n       \
    \               ^~~~~\n/tmp/tmpfrw0y6mh.swift:47:23: error: cannot find 'value'\
    \ in scope\n    case .stringValue(value):\n                      ^~~~~\n/tmp/tmpfrw0y6mh.swift:24:22:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        if\
    \ let b = b as? Value {\n                     ^\n/tmp/tmpfrw0y6mh.swift:26:28:\
    \ error: cannot find 'value' in scope\n            case .intValue(value):\n  \
    \                         ^~~~~\n/tmp/tmpfrw0y6mh.swift:28:31: error: cannot find\
    \ 'value' in scope\n            case .doubleValue(value):\n                  \
    \            ^~~~~\n/tmp/tmpfrw0y6mh.swift:30:31: error: cannot find 'value' in\
    \ scope\n            case .stringValue(value):\n                             \
    \ ^~~~~\n/tmp/tmpfrw0y6mh.swift:27:24: error: cannot find 'value' in scope\n \
    \               return value\n                       ^~~~~\n/tmp/tmpfrw0y6mh.swift:29:24:\
    \ error: cannot find 'value' in scope\n                return value\n        \
    \               ^~~~~\n/tmp/tmpfrw0y6mh.swift:31:24: error: cannot find 'value'\
    \ in scope\n                return value\n                       ^~~~~\n/tmp/tmpfrw0y6mh.swift:36:22:\
    \ warning: conditional cast from 'Value' to 'Value' always succeeds\n        if\
    \ let b = b as? Value {\n                     ^\n/tmp/tmpfrw0y6mh.swift:38:28:\
    \ error: cannot find 'value' in scope\n            case .intValue(value):\n  \
    \                         ^~~~~\n/tmp/tmpfrw0y6mh.swift:40:31: error: cannot find\
    \ 'value' in scope\n            case .doubleValue(value):\n                  \
    \            ^~~~~\n/tmp/tmpfrw0y6mh.swift:42:31: error: cannot find 'value' in\
    \ scope\n            case .stringValue(value):\n                             \
    \ ^~~~~\n/tmp/tmpfrw0y6mh.swift:39:24: error: cannot find 'value' in scope\n \
    \               return value\n                       ^~~~~\n/tmp/tmpfrw0y6mh.swift:41:24:\
    \ error: cannot find 'valu"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   guard b.intValue() != nil else { return nil }\n        return .intValue(b.intValue()!)\n\
    \    case .doubleValue(_):\n        guard b.doubleValue() != nil else { return\
    \ nil }\n        return .doubleValue(b.doubleValue()!)\n    case .stringValue(_):\n\
    \        guard b.stringValue() != nil else { return nil }\n        return .stringValue(b.stringValue()!)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2qxq9_ic.swift:24:26: error: missing argument for parameter #1\
    \ in call\n        guard b.intValue() != nil else { return nil }\n           \
    \              ^\n                         <#Int#>\n/tmp/tmp2qxq9_ic.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp2qxq9_ic.swift:24:15:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        guard\
    \ b.intValue() != nil else { return nil }\n              ^\n              Value\n\
    /tmp/tmp2qxq9_ic.swift:25:38: error: cannot convert value of type 'Value' to expected\
    \ argument type 'Int'\n        return .intValue(b.intValue()!)\n             \
    \                        ^\n/tmp/tmp2qxq9_ic.swift:25:26: error: enum case 'intValue'\
    \ cannot be used as an instance member\n        return .intValue(b.intValue()!)\n\
    \                         ^\n                         Value\n/tmp/tmp2qxq9_ic.swift:25:37:\
    \ error: missing argument for parameter #1 in call\n        return .intValue(b.intValue()!)\n\
    \                                    ^\n                                    <#Int#>\n\
    /tmp/tmp2qxq9_ic.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmp2qxq9_ic.swift:25:38: error: cannot force unwrap value of\
    \ non-optional type 'Value'\n        return .intValue(b.intValue()!)\n       \
    \                  ~~~~~~~~~~~~^\n                                     \n/tmp/tmp2qxq9_ic.swift:27:15:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  guard b.doubleValue() != nil else { return nil }\n              ^\n       \
    \       Value\n/tmp/tmp2qxq9_ic.swift:27:29: error: missing argument for parameter\
    \ #1 in call\n        guard b.doubleValue() != nil else { return nil }\n     \
    \                       ^\n                            <#Double#>\n/tmp/tmp2qxq9_ic.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmp2qxq9_ic.swift:28:44: error: cannot convert value of type 'Value' to expected\
    \ argument type 'Double'\n        return .doubleValue(b.doubleValue()!)\n    \
    \                                    "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)):\n        return a > b ? a : b\n    case let (.doubleValue(a),\
    \ .doubleValue(b)):\n        return a.compare(b) == .orderedDescending\n    case\
    \ let (.stringValue(a), .stringValue(b)):\n        return a.compare(b) == .orderedAscending\n\
    \    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp37nznndo.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp37nznndo.swift:26:29: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n        return a.compare(b)\
    \ == .orderedDescending\n               ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp37nznndo.swift:26:18:\
    \ error: value of type 'Double' has no member 'compare'\n        return a.compare(b)\
    \ == .orderedDescending\n               ~ ^~~~~~~\n/tmp/tmp37nznndo.swift:28:29:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \        return a.compare(b) == .orderedAscending\n               ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp37nznndo.swift:28:18: error: value of type 'String' has no member 'compare'\n\
    \        return a.compare(b) == .orderedAscending\n               ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b)):\n\
    \        return b\n    case (.doubleValue(a), .doubleValue(b)):\n        return\
    \ a\n    case (.stringValue(a), .stringValue(b)):\n        return a\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsz4onk36.swift:23:21: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case (.intValue(a), .intValue(b)):\n\
    \                    ^\n/tmp/tmpsz4onk36.swift:25:24: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .doubleValue(b)):\n                       ^\n/tmp/tmpsz4onk36.swift:27:24: error:\
    \ expression pattern of type 'Value' cannot match values of type 'String'\n  \
    \  case (.stringValue(a), .stringValue(b)):\n                       ^\n/tmp/tmpsz4onk36.swift:27:24:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case (.stringValue(a), .stringValue(b)):\n        \
    \               ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var maxA = a\n    var maxB = b\n\n    if a.doubleValue()\
    \ > b.doubleValue() {\n        maxA = b\n        maxB = a\n    }\n    if a.intValue()\
    \ > b.intValue() {\n        maxA = b\n        maxB = a\n    }\n    if a.stringValue()\
    \ > b.stringValue() {\n        maxA = b\n        maxB = a\n    }\n    if a.stringValue()\
    \ == b.stringValue() {\n        if a.intValue() == b.intValue() {\n          \
    \  if a.doubleValue() == b.doubleValue() {\n                return a\n       \
    \     } else {\n                return b\n            }\n        }\n        return\
    \ nil\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvuquh_dk.swift:25:8: error: enum case 'doubleValue' cannot be used\
    \ as an instance member\n    if a.doubleValue() > b.doubleValue() {\n       ^\n\
    \       Value\n/tmp/tmpvuquh_dk.swift:25:22: error: missing argument for parameter\
    \ #1 in call\n    if a.doubleValue() > b.doubleValue() {\n                   \
    \  ^\n                     <#Double#>\n/tmp/tmpvuquh_dk.swift:4:10: note: 'doubleValue'\
    \ declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmpvuquh_dk.swift:25:24:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.doubleValue() > b.doubleValue() {\n      \
    \                 ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic\
    \ protocol Comparable : Equatable {\n                ^\n/tmp/tmpvuquh_dk.swift:25:24:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \    if a.doubleValue() > b.doubleValue() {\n                       ^\n/tmp/tmpvuquh_dk.swift:25:40:\
    \ error: missing argument for parameter #1 in call\n    if a.doubleValue() > b.doubleValue()\
    \ {\n                                       ^\n                              \
    \         <#Double#>\n/tmp/tmpvuquh_dk.swift:4:10: note: 'doubleValue' declared\
    \ here\n    case doubleValue(Double)\n         ^\n/tmp/tmpvuquh_dk.swift:25:26:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ a.doubleValue() > b.doubleValue() {\n                         ^\n          \
    \               Value\n/tmp/tmpvuquh_dk.swift:29:8: error: enum case 'intValue'\
    \ cannot be used as an instance member\n    if a.intValue() > b.intValue() {\n\
    \       ^\n       Value\n/tmp/tmpvuquh_dk.swift:29:19: error: missing argument\
    \ for parameter #1 in call\n    if a.intValue() > b.intValue() {\n           \
    \       ^\n                  <#Int#>\n/tmp/tmpvuquh_dk.swift:3:10: note: 'intValue'\
    \ declared here\n    case intValue(Int)\n         ^\n/tmp/tmpvuquh_dk.swift:29:21:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.intValue() > b.intValue() {\n            \
    \        ^"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   return b == .intValue(a.intValue())\n    case .doubleValue(_):\n        return\
    \ b == .doubleValue(a.doubleValue())\n    case .stringValue(_):\n        return\
    \ b == .stringValue(a.stringValue())\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmja9xgrz.swift:24:18: error: cannot convert return expression of\
    \ type 'Bool' to return type 'Value?'\n        return b == .intValue(a.intValue())\n\
    \               ~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmja9xgrz.swift:24:33: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Int'\n     \
    \   return b == .intValue(a.intValue())\n                                ^\n/tmp/tmpmja9xgrz.swift:24:42:\
    \ error: missing argument for parameter #1 in call\n        return b == .intValue(a.intValue())\n\
    \                                         ^\n                                \
    \         <#Int#>\n/tmp/tmpmja9xgrz.swift:3:10: note: 'intValue' declared here\n\
    \    case intValue(Int)\n         ^\n/tmp/tmpmja9xgrz.swift:24:31: error: enum\
    \ case 'intValue' cannot be used as an instance member\n        return b == .intValue(a.intValue())\n\
    \                              ^\n                              Value\n/tmp/tmpmja9xgrz.swift:26:18:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \        return b == .doubleValue(a.doubleValue())\n               ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmja9xgrz.swift:26:36: error: cannot convert value of type 'Value' to expected\
    \ argument type 'Double'\n        return b == .doubleValue(a.doubleValue())\n\
    \                                   ^\n/tmp/tmpmja9xgrz.swift:26:34: error: enum\
    \ case 'doubleValue' cannot be used as an instance member\n        return b ==\
    \ .doubleValue(a.doubleValue())\n                                 ^\n        \
    \                         Value\n/tmp/tmpmja9xgrz.swift:26:48: error: missing\
    \ argument for parameter #1 in call\n        return b == .doubleValue(a.doubleValue())\n\
    \                                               ^\n                          \
    \                     <#Double#>\n/tmp/tmpmja9xgrz.swift:4:10: note: 'doubleValue'\
    \ declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmpmja9xgrz.swift:28:18:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \        return b == .stringValue(a.stringValue())\n               ~~^~~~~~~~~"
  stdout: ''
  timestamp: 1660013422
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return nil\n        }\n    case .doubleValue(_):\n        switch b {\n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return nil\n\
    \        }\n    case .stringValue(_):\n        switch b {\n        case .intValue(_):\n\
    \            return nil\n        case .doubleValue(_):\n            return b\n\
    \        case .stringValue(_):\n            return nil\n        }\n    }\n   \
    \ return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpvy934aze/tmpvy934aze.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae51d156c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae51ce4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae51ce4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae51ce4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvy934aze                        0x000055653e1d4a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ae51d342460 __libc_start_main +
    245

    6    tmpvy934aze                        0x000055653e1d4499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n        case .intValue(n): \n\
    \            if b == .intValue(n) { return .intValue(n) }\n            else {\
    \ return nil }\n        case .doubleValue(d): \n            if b == .doubleValue(d)\
    \ { return .doubleValue(d) }\n            else { return nil }\n        case .stringValue(v):\
    \ \n            if b == .stringValue(v) { return .stringValue(v) }\n         \
    \   else { return nil }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpgh2c5hy3.swift:23:24: error: cannot find 'n' in scope\n       \
    \ case .intValue(n): \n                       ^\n/tmp/tmpgh2c5hy3.swift:26:27:\
    \ error: cannot find 'd' in scope\n        case .doubleValue(d): \n          \
    \                ^\n/tmp/tmpgh2c5hy3.swift:29:27: error: cannot find 'v' in scope\n\
    \        case .stringValue(v): \n                          ^\n/tmp/tmpgh2c5hy3.swift:24:31:\
    \ error: cannot find 'n' in scope\n            if b == .intValue(n) { return .intValue(n)\
    \ }\n                              ^\n/tmp/tmpgh2c5hy3.swift:24:53: error: cannot\
    \ find 'n' in scope\n            if b == .intValue(n) { return .intValue(n) }\n\
    \                                                    ^\n/tmp/tmpgh2c5hy3.swift:27:34:\
    \ error: cannot find 'd' in scope\n            if b == .doubleValue(d) { return\
    \ .doubleValue(d) }\n                                 ^\n/tmp/tmpgh2c5hy3.swift:27:59:\
    \ error: cannot find 'd' in scope\n            if b == .doubleValue(d) { return\
    \ .doubleValue(d) }\n                                                        \
    \  ^\n/tmp/tmpgh2c5hy3.swift:30:34: error: cannot find 'v' in scope\n        \
    \    if b == .stringValue(v) { return .stringValue(v) }\n                    \
    \             ^\n/tmp/tmpgh2c5hy3.swift:30:59: error: cannot find 'v' in scope\n\
    \            if b == .stringValue(v) { return .stringValue(v) }\n            \
    \                                              ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a is greater\n    case .intValue(aVal):\n\
    \        switch b { // b is greater\n        case .intValue(bVal):\n         \
    \   return .intValue(aVal > bVal ? aVal : bVal) // a is greater\n        case\
    \ .doubleValue(bVal):\n            return .doubleValue(aVal > bVal ? aVal : bVal)\
    \ // a is greater\n        case .stringValue(bVal):\n            return .stringValue(aVal\
    \ > bVal ? aVal : bVal) // a is greater\n        }\n    case .doubleValue(aVal):\n\
    \        switch b { // b is greater\n        case .intValue(bVal):\n         \
    \   return .doubleValue(aVal > bVal ? aVal : bVal) // a is greater\n        case\
    \ .doubleValue(bVal):\n            return .doubleValue(aVal > bVal ? aVal : bVal)\
    \ // a is greater\n        case .stringValue(bVal):\n            return .doubleValue(aVal\
    \ > bVal ? aVal : bVal) // a is greater\n        case .stringValue(bVal):\n  \
    \          return .doubleValue(aVal > bVal ? aVal : bVal) // a is greater\n  \
    \      }\n    case .stringValue(aVal):\n        switch b { // b is greater\n \
    \       case .intValue(bVal):\n            return .stringValue(aVal > bVal ? aVal\
    \ : bVal) // a is greater\n        case .doubleValue(bVal):\n            return\
    \ .stringValue(aVal > bVal ? aVal : bVal) // a is greater\n        case .stringValue(bVal):\n\
    \            return .stringValue(aVal > bVal ? aVal : bVal) // a is greater\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpm4g05ncz.swift:23:20: error: cannot find 'aVal' in scope\n    case\
    \ .intValue(aVal):\n                   ^~~~\n/tmp/tmpm4g05ncz.swift:32:23: error:\
    \ cannot find 'aVal' in scope\n    case .doubleValue(aVal):\n                \
    \      ^~~~\n/tmp/tmpm4g05ncz.swift:43:23: error: cannot find 'aVal' in scope\n\
    \    case .stringValue(aVal):\n                      ^~~~\n/tmp/tmpm4g05ncz.swift:25:24:\
    \ error: cannot find 'bVal' in scope\n        case .intValue(bVal):\n        \
    \               ^~~~\n/tmp/tmpm4g05ncz.swift:27:27: error: cannot find 'bVal'\
    \ in scope\n        case .doubleValue(bVal):\n                          ^~~~\n\
    /tmp/tmpm4g05ncz.swift:29:27: error: cannot find 'bVal' in scope\n        case\
    \ .stringValue(bVal):\n                          ^~~~\n/tmp/tmpm4g05ncz.swift:26:30:\
    \ error: cannot find 'aVal' in scope\n            return .intValue(aVal > bVal\
    \ ? aVal : bVal) // a is greater\n                             ^~~~\n/tmp/tmpm4g05ncz.swift:26:37:\
    \ error: cannot find 'bVal' in scope\n            return .intValue(aVal > bVal\
    \ ? aVal : bVal) // a is greater\n                                    ^~~~\n/tmp/tmpm4g05ncz.swift:26:44:\
    \ error: cannot find 'aVal' in scope\n            return .intValue(aVal > bVal\
    \ ? aVal : bVal) // a is greater\n                                           ^~~~\n\
    /tmp/tmpm4g05ncz.swift:26:51: error: cannot find 'bVal' in scope\n           \
    \ return .intValue(aVal > bVal ? aVal : bVal) // a is greater\n              \
    \                                    ^~~~\n/tmp/tmpm4g05ncz.swift:28:33: error:\
    \ cannot find 'aVal' in scope\n            return .doubleValue(aVal > bVal ? aVal\
    \ : bVal) // a is greater\n                                ^~~~\n/tmp/tmpm4g05ncz.swift:28:40:\
    \ error: cannot find 'bVal' in scope\n            return .doubleValue(aVal > bVal\
    \ ? aVal : bVal) // a is greater\n                                       ^~~~\n\
    /tmp/tmpm4g05ncz.swift:28:47: error: cannot find 'aVal' in scope\n           \
    \ return .doubleValue(aVal > bVal ? aVal : bVal) // a is greater\n           \
    \                                   ^~~~\n/tmp/tmpm4g05ncz.swift:28:54: er"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(_), .intValue(_)):\n\
    \        return .intValue(_)\n    case (.doubleValue(_), .doubleValue(_)):\n \
    \       return .doubleValue(_)\n    case (.stringValue(_), .stringValue(_)):\n\
    \        return .stringValue(_)\n    default:\n        return nil\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp68ejkstr.swift:24:26: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        return .intValue(_)\n           \
    \              ^\n/tmp/tmp68ejkstr.swift:26:29: error: '_' can only appear in\
    \ a pattern or on the left side of an assignment\n        return .doubleValue(_)\n\
    \                            ^\n/tmp/tmp68ejkstr.swift:28:29: error: '_' can only\
    \ appear in a pattern or on the left side of an assignment\n        return .stringValue(_)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(nif let i)\
    \ -> if nif.abs(i) == nif.abs(nif b) return nif i else nil\n    case .doubleValue(nif\
    \ let d) -> if nif.abs(d) == nif.abs(nif b) return nif d else nil\n    case .stringValue(nif\
    \ let s) -> if nif.abs(s) > nif.abs(nif b) return nil else s\n    }\n    \n  \
    \  switch b {\n    case .intValue(nif let i) -> if nif.abs(i) == nif.abs(nif a)\
    \ return nif i else nil\n    case .doubleValue(nif let d) -> if nif.abs(d) ==\
    \ nif.abs(nif a) return nif d else nil\n    case .stringValue(nif let s) -> if\
    \ nif.abs(s) > nif.abs(nif a) return nil else s\n    }\n    \n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppmb4_bve.swift:23:24: error: expected ',' separator\n    case .intValue(nif\
    \ let i) -> if nif.abs(i) == nif.abs(nif b) return nif i else nil\n          \
    \             ^\n                      ,\n/tmp/tmppmb4_bve.swift:23:34: error:\
    \ expected pattern\n    case .intValue(nif let i) -> if nif.abs(i) == nif.abs(nif\
    \ b) return nif i else nil\n                                 ^\n/tmp/tmppmb4_bve.swift:23:34:\
    \ error: expected ':' after 'case'\n    case .intValue(nif let i) -> if nif.abs(i)\
    \ == nif.abs(nif b) return nif i else nil\n                                 ^\n\
    /tmp/tmppmb4_bve.swift:23:63: error: expected ',' separator\n    case .intValue(nif\
    \ let i) -> if nif.abs(i) == nif.abs(nif b) return nif i else nil\n          \
    \                                                    ^\n                     \
    \                                        ,\n/tmp/tmppmb4_bve.swift:23:66: error:\
    \ expected '{' after 'if' condition\n    case .intValue(nif let i) -> if nif.abs(i)\
    \ == nif.abs(nif b) return nif i else nil\n                                  \
    \                               ^\n/tmp/tmppmb4_bve.swift:24:27: error: expected\
    \ ',' separator\n    case .doubleValue(nif let d) -> if nif.abs(d) == nif.abs(nif\
    \ b) return nif d else nil\n                          ^\n                    \
    \     ,\n/tmp/tmppmb4_bve.swift:24:37: error: expected pattern\n    case .doubleValue(nif\
    \ let d) -> if nif.abs(d) == nif.abs(nif b) return nif d else nil\n          \
    \                          ^\n/tmp/tmppmb4_bve.swift:24:37: error: expected ':'\
    \ after 'case'\n    case .doubleValue(nif let d) -> if nif.abs(d) == nif.abs(nif\
    \ b) return nif d else nil\n                                    ^\n/tmp/tmppmb4_bve.swift:24:66:\
    \ error: expected ',' separator\n    case .doubleValue(nif let d) -> if nif.abs(d)\
    \ == nif.abs(nif b) return nif d else nil\n                                  \
    \                               ^\n                                          \
    \                      ,\n/tmp/tmppmb4_bve.swift:24:69: error: expected '{' after\
    \ 'if' condition\n    case .doubleValue(nif let d) -> if nif.abs(d) == nif.abs"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n    default:\n        return nil\n    }\n\n    switch b { case\
    \ .intValue(_), .doubleValue(_), .stringValue(_)\n    default:\n        return\
    \ nil\n    }\n\n    // Both are ints\n    switch a { case .intValue($0), .intValue($1),\
    \ .intValue($2), .intValue($3), .intValue($4), .intValue($5), .intValue($6), .intValue($7),\
    \ .intValue($8), .intValue($9)\n    default:\n        return nil\n    }\n\n  \
    \  // Both are doubles\n    switch b { case .doubleValue($0), .doubleValue($1),\
    \ .doubleValue($2), .doubleValue($3), .doubleValue($4), .doubleValue($5), .doubleValue($6),\
    \ .doubleValue($7), .doubleValue($8), .doubleValue($9)\n    default:\n       \
    \ return nil\n    }\n\n    // Both are strings\n    switch a { case .stringValue($0),\
    \ .stringValue($1), .stringValue($2), .stringValue($3), .stringValue($4), .stringValue($5),\
    \ .stringValue($6), .stringValue($7), .stringValue($8), .stringValue($9)\n   \
    \ default:\n        return nil\n    }\n\n    // Both are doubles and strings\n\
    \    switch b { case .doubleValue($0), .doubleValue($1), .doubleValue($2), .doubleValue($3),\
    \ .doubleValue($4), .doubleValue($5), .doubleValue($6), .doubleValue($7), .doubleValue($8),\
    \ .doubleValue($9), .stringValue($0), .stringValue($1), .stringValue($2), .stringValue($3),\
    \ .stringValue($4), .stringValue($5), .stringValue($6), .stringValue($7), .stringValue($8),\
    \ .stringValue($9), .stringValue($0), .stringValue($1), .stringValue($2), .stringValue($3),\
    \ .stringValue($4), .stringValue($5), .stringValue($6), .stringValue($7), .stringValue($8),\
    \ .stringValue($9)\n    default:\n        return nil\n    }\n\n    // Both are\
    \ ints, doubles and strings\n    switch a { case .intValue($0), .doubleValue($1),\
    \ .stringValue($2), .intValue($3), .doubleValue($4), .stringValue($5), .intValue($6),\
    \ .doubleValue($7), .stringValue($8), .intValue($9), .stringValue($0), .string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsv95o5mp.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpsv95o5mp.swift:27:67:\
    \ error: expected ':' after 'case'\n    switch b { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n                                                          \
    \        ^\n/tmp/tmpsv95o5mp.swift:33:31: error: anonymous closure argument not\
    \ contained in a closure\n    switch a { case .intValue($0), .intValue($1), .intValue($2),\
    \ .intValue($3), .intValue($4), .intValue($5), .intValue($6), .intValue($7), .intValue($8),\
    \ .intValue($9)\n                              ^\n/tmp/tmpsv95o5mp.swift:33:46:\
    \ error: anonymous closure argument not contained in a closure\n    switch a {\
    \ case .intValue($0), .intValue($1), .intValue($2), .intValue($3), .intValue($4),\
    \ .intValue($5), .intValue($6), .intValue($7), .intValue($8), .intValue($9)\n\
    \                                             ^\n/tmp/tmpsv95o5mp.swift:33:61:\
    \ error: anonymous closure argument not contained in a closure\n    switch a {\
    \ case .intValue($0), .intValue($1), .intValue($2), .intValue($3), .intValue($4),\
    \ .intValue($5), .intValue($6), .intValue($7), .intValue($8), .intValue($9)\n\
    \                                                            ^\n/tmp/tmpsv95o5mp.swift:33:76:\
    \ error: anonymous closure argument not contained in a closure\n    switch a {\
    \ case .intValue($0), .intValue($1), .intValue($2), .intValue($3), .intValue($4),\
    \ .intValue($5), .intValue($6), .intValue($7), .intValue($8), .intValue($9)\n\
    \                                                                           ^\n\
    /tmp/tmpsv95o5mp.swift:33:91: error: anonymous closure argument not contained\
    \ in a closure\n    switch a { case .intValue($0), .intValue($1), .intValue($2),\
    \ .intValue($3), .intValue($4), .intValue($5), .intValue($6), .intValue($7), .intValue($8),\
    \ .intValue($9)\n                                                            \
    \                              ^\n/tmp/tmpsv95o5mp.swift:33:106: error: anon"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let aInt = a.intValue(), let bInt = b.intValue()\
    \ {\n        if aInt > bInt {\n            return a\n        } else if aInt <\
    \ bInt {\n            return b\n        } else {\n            return nil\n   \
    \     }\n    } else if let aDouble = a.doubleValue(), let bDouble = b.doubleValue()\
    \ {\n        if aDouble > bDouble {\n            return a\n        } else if aDouble\
    \ < bDouble {\n            return b\n        } else {\n            return nil\n\
    \        }\n    } else if let aString = a.stringValue(), let bString = b.stringValue()\
    \ {\n        if aString > bString {\n            return a\n        } else if aString\
    \ < bString {\n            return b\n        } else {\n            return nil\n\
    \        }\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmporu78g3m.swift:22:30: error: missing argument for parameter #1\
    \ in call\n    if let aInt = a.intValue(), let bInt = b.intValue() {\n       \
    \                      ^\n                             <#Int#>\n/tmp/tmporu78g3m.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmporu78g3m.swift:22:19:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ aInt = a.intValue(), let bInt = b.intValue() {\n                  ^\n      \
    \            Value\n/tmp/tmporu78g3m.swift:22:55: error: missing argument for\
    \ parameter #1 in call\n    if let aInt = a.intValue(), let bInt = b.intValue()\
    \ {\n                                                      ^\n               \
    \                                       <#Int#>\n/tmp/tmporu78g3m.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmporu78g3m.swift:22:44:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ aInt = a.intValue(), let bInt = b.intValue() {\n                           \
    \                ^\n                                           Value\n/tmp/tmporu78g3m.swift:30:29:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    } else\
    \ if let aDouble = a.doubleValue(), let bDouble = b.doubleValue() {\n        \
    \                    ^\n                            Value\n/tmp/tmporu78g3m.swift:30:43:\
    \ error: missing argument for parameter #1 in call\n    } else if let aDouble\
    \ = a.doubleValue(), let bDouble = b.doubleValue() {\n                       \
    \                   ^\n                                          <#Double#>\n\
    /tmp/tmporu78g3m.swift:4:10: note: 'doubleValue' declared here\n    case doubleValue(Double)\n\
    \         ^\n/tmp/tmporu78g3m.swift:30:60: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n    } else if let aDouble = a.doubleValue(),\
    \ let bDouble = b.doubleValue() {\n                                          \
    \                 ^\n                                                        \
    \   Value\n/tmp/tmporu78g3m.swift:30:74: error: missing argument for pa"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .intValue(_):\n            return a\n        case\
    \ .stringValue(_):\n            guard let a = a.stringValue, b = b.stringValue\
    \ else {\n                return nil\n            }\n            if a == b {\n\
    \                return nil\n            }\n            let numeric = a.components(separatedBy:\
    \ CharacterSet.decimalDigits.inverted).reduce(0) { (result, next) -> Int? in\n\
    \                let result = Int(next.unicodeScalars.first!)\n              \
    \  if result < result {\n                    return result\n                }\n\
    \                return result\n            }\n            guard let bNumeric\
    \ = b.components(separatedBy: CharacterSet.decimalDigits.inverted).reduce(0) {\
    \ (result, next) -> Int? in\n                let result = Int(next.unicodeScalars.first!)\n\
    \                if result < result {\n                    return result\n   \
    \             }\n                return result\n            }\n            return\
    \ numeric < bNumeric ? .intValue(a) : .stringValue(b)\n        }\n    case .doubleValue(_):\n\
    \        switch b {\n        case .intValue(_):\n            return nil\n    \
    \    case .stringValue(_):\n            guard let a = a.stringValue, b = b.stringValue\
    \ else {\n                return nil\n            }\n            if a == b {\n\
    \                return nil\n            }\n            let numeric = a.components(separatedBy:\
    \ CharacterSet.decimalDigits.inverted).reduce(0) { (result, next) -> Int? in\n\
    \                let result = Int(next.unicodeScalars.first!)\n              \
    \  if result < result {\n                    return result\n                }\n\
    \                return result\n            }\n            guard let bNumeric\
    \ = b.components(separatedBy: CharacterSet.decimalDigits.inverted).reduce(0) {\
    \ (result, next) -> Int? in\n                let result = Int(next.unicodeScalars.first!)\n\
    \                if result < result {\n                    return result\n   \
    \             }\n                return result\n            }\n            return\
    \ numeric < bNumeric ? .intValue(a) : .stringValue(b)\n        }\n    case .stringValue(_):\n\
    \        guard let a = a.stringValue, b = b.stringValue else {\n            return\
    \ nil\n        }\n        if a == b {\n            return nil\n        }\n   \
    \     return a < b ? .stringValue(a) : .stringValue(b)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpal_d1nyc.swift:28:42: error: expected 'let' in conditional\n  \
    \          guard let a = a.stringValue, b = b.stringValue else {\n           \
    \                              ^\n                                         let\
    \ \n/tmp/tmpal_d1nyc.swift:41:107: error: expected 'else' after 'guard' condition\n\
    \            guard let bNumeric = b.components(separatedBy: CharacterSet.decimalDigits.inverted).reduce(0)\
    \ { (result, next) -> Int? in\n                                              \
    \                                                            ^\n             \
    \                                                                            \
    \                 else \n/tmp/tmpal_d1nyc.swift:41:131: error: consecutive statements\
    \ on a line must be separated by ';'\n            guard let bNumeric = b.components(separatedBy:\
    \ CharacterSet.decimalDigits.inverted).reduce(0) { (result, next) -> Int? in\n\
    \                                                                            \
    \                                                      ^\n                   \
    \                                                                            \
    \                                   ;\n/tmp/tmpal_d1nyc.swift:41:132: error: expected\
    \ expression\n            guard let bNumeric = b.components(separatedBy: CharacterSet.decimalDigits.inverted).reduce(0)\
    \ { (result, next) -> Int? in\n                                              \
    \                                                                            \
    \         ^\n/tmp/tmpal_d1nyc.swift:55:42: error: expected 'let' in conditional\n\
    \            guard let a = a.stringValue, b = b.stringValue else {\n         \
    \                                ^\n                                         let\
    \ \n/tmp/tmpal_d1nyc.swift:68:107: error: expected 'else' after 'guard' condition\n\
    \            guard let bNumeric = b.components(separatedBy: CharacterSet.decimalDigits.inverted).reduce(0)\
    \ { (result, next) -> Int? in\n                                              \
    \                                                            ^\n             \
    \                    "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var a = a\n    var b = b\n    if let aInt\
    \ = a.intValue() {\n        if let bInt = b.intValue() {\n            if aInt\
    \ > bInt { return .intValue(bInt) }\n            if aInt == bInt { return .intValue(aInt)\
    \ }\n            return nil\n        }\n        if let bDouble = b.doubleValue()\
    \ {\n            if aInt > bDouble { return .doubleValue(bDouble) }\n        \
    \    if aInt == bDouble { return .doubleValue(aInt) }\n            return nil\n\
    \        }\n        if let bString = b.stringValue() {\n            if aInt >\
    \ bString { return .stringValue(bString) }\n            if aInt == bString { return\
    \ .stringValue(aInt) }\n            return nil\n        }\n    }\n    if let aDouble\
    \ = a.doubleValue() {\n        if let bInt = b.intValue() {\n            if aDouble\
    \ > bInt { return .intValue(bInt) }\n            if aDouble == bInt { return .intValue(aDouble)\
    \ }\n            return nil\n        }\n        if let bDouble = b.doubleValue()\
    \ {\n            if aDouble > bDouble { return .doubleValue(bDouble) }\n     \
    \       if aDouble == bDouble { return .doubleValue(aDouble) }\n            return\
    \ nil\n        }\n        if let bString = b.stringValue() {\n            if aDouble\
    \ > bString { return .stringValue(bString) }\n            if aDouble == bString\
    \ { return .stringValue(aDouble) }\n            return nil\n        }\n    }\n\
    \    if let aString = a.stringValue() {\n        if let bInt = b.intValue() {\n\
    \            if aString > bInt { return .intValue(bInt) }\n            if aString\
    \ == bInt { return .intValue(aString) }\n            return nil\n        }\n \
    \       if let bDouble = b.doubleValue() {\n            if aString > bDouble {\
    \ return .doubleValue(bDouble) }\n            if aString == bDouble { return .doubleValue(aString)\
    \ }\n            return nil\n        }\n        if let bString = b.stringValue()\
    \ {\n            if aString > bString { return .stringValue(bString) }\n     \
    \       if aString == bString { return .stringValue(aString) }\n            return\
    \ nil\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvppmdb28.swift:24:19: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if let aInt = a.intValue() {\n                  ^\n\
    \                  Value\n/tmp/tmpvppmdb28.swift:24:30: error: missing argument\
    \ for parameter #1 in call\n    if let aInt = a.intValue() {\n               \
    \              ^\n                             <#Int#>\n/tmp/tmpvppmdb28.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpvppmdb28.swift:25:34:\
    \ error: missing argument for parameter #1 in call\n        if let bInt = b.intValue()\
    \ {\n                                 ^\n                                 <#Int#>\n\
    /tmp/tmpvppmdb28.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmpvppmdb28.swift:25:23: error: enum case 'intValue' cannot\
    \ be used as an instance member\n        if let bInt = b.intValue() {\n      \
    \                ^\n                      Value\n/tmp/tmpvppmdb28.swift:30:26:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  if let bDouble = b.doubleValue() {\n                         ^\n          \
    \               Value\n/tmp/tmpvppmdb28.swift:30:40: error: missing argument for\
    \ parameter #1 in call\n        if let bDouble = b.doubleValue() {\n         \
    \                              ^\n                                       <#Double#>\n\
    /tmp/tmpvppmdb28.swift:4:10: note: 'doubleValue' declared here\n    case doubleValue(Double)\n\
    \         ^\n/tmp/tmpvppmdb28.swift:35:26: error: enum case 'stringValue' cannot\
    \ be used as an instance member\n        if let bString = b.stringValue() {\n\
    \                         ^\n                         Value\n/tmp/tmpvppmdb28.swift:35:40:\
    \ error: missing argument for parameter #1 in call\n        if let bString = b.stringValue()\
    \ {\n                                       ^\n                              \
    \         <#String#>\n/tmp/tmpvppmdb28.swift:5:10: note: 'stringValue' declared\
    \ here\n    case stringValue(String)\n         ^\n/tmp/tmpvppmdb28.swift:41:36:\
    \ error: missing argument for parameter #1 in call\n    if let aDouble = a."
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue = a\n    var bValue = b\n    \n\
    \    if aValue.doubleValue() < bValue.doubleValue() {\n        aValue = bValue\n\
    \    }\n    \n    if aValue.doubleValue() >= bValue.doubleValue() {\n        if\
    \ aValue.stringValue().toInt() != bValue.stringValue().toInt() {\n           \
    \ return nil\n        }\n    }\n    \n    return aValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpi2heygxw.swift:25:27: error: missing argument for parameter #1\
    \ in call\n    if aValue.doubleValue() < bValue.doubleValue() {\n            \
    \              ^\n                          <#Double#>\n/tmp/tmpi2heygxw.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmpi2heygxw.swift:25:8: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n    if aValue.doubleValue() < bValue.doubleValue() {\n \
    \      ^~~~~~\n       Value\n/tmp/tmpi2heygxw.swift:25:29: error: referencing\
    \ operator function '<' on 'Comparable' requires that 'Value' conform to 'Comparable'\n\
    \    if aValue.doubleValue() < bValue.doubleValue() {\n                      \
    \      ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmpi2heygxw.swift:25:29: note:\
    \ binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if aValue.doubleValue() < bValue.doubleValue() {\n                      \
    \      ^\n/tmp/tmpi2heygxw.swift:25:31: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n    if aValue.doubleValue() < bValue.doubleValue()\
    \ {\n                              ^~~~~~\n                              Value\n\
    /tmp/tmpi2heygxw.swift:25:50: error: missing argument for parameter #1 in call\n\
    \    if aValue.doubleValue() < bValue.doubleValue() {\n                      \
    \                           ^\n                                              \
    \   <#Double#>\n/tmp/tmpi2heygxw.swift:4:10: note: 'doubleValue' declared here\n\
    \    case doubleValue(Double)\n         ^\n/tmp/tmpi2heygxw.swift:29:8: error:\
    \ enum case 'doubleValue' cannot be used as an instance member\n    if aValue.doubleValue()\
    \ >= bValue.doubleValue() {\n       ^~~~~~\n       Value\n/tmp/tmpi2heygxw.swift:29:27:\
    \ error: missing argument for parameter #1 in call\n    if aValue.doubleValue()\
    \ >= bValue.doubleValue() {\n                          ^\n                   \
    \       <#Double#>\n/tmp/tmpi2heygxw.swift:4:10: note: 'doubleValue' declared\
    \ here\n    case doubleValue(Double)\n         ^\n/"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(aInt):\n  \
    \      switch b {\n        case .intValue(bInt):\n            if aInt > bInt {\n\
    \                return b\n            }\n            else if aInt == bInt {\n\
    \                return nil\n            }\n            else if aInt == -1 {\n\
    \                return .intValue(-1)\n            }\n            else if bInt\
    \ == -1 {\n                return .intValue(-1)\n            }\n            else\
    \ if aInt == bInt {\n                if let double = Double(aInt) {\n        \
    \            return .doubleValue(double)\n                }\n                else\
    \ {\n                    return .intValue(aInt)\n                }\n         \
    \   }\n            else {\n                return .intValue(aInt)\n          \
    \  }\n        case .doubleValue(aDouble):\n            if b == .doubleValue(Double(aDouble))\
    \ {\n                return nil\n            }\n            else if aDouble >\
    \ b {\n                return .doubleValue(aDouble)\n            }\n         \
    \   else if aDouble == b {\n                return .doubleValue(aDouble)\n   \
    \         }\n            else {\n                return .intValue(aInt)\n    \
    \        }\n        case .stringValue(aString):\n            if b == .stringValue(aString)\
    \ {\n                return nil\n            }\n            else if aString >\
    \ b {\n                return .stringValue(aString)\n            }\n         \
    \   else if aString == b {\n                return .stringValue(aString)\n   \
    \         }\n            else {\n                return .intValue(aInt)\n    \
    \        }\n        default:\n            return nil\n        }\n    case .doubleValue(aDouble):\n\
    \        switch b {\n        case .intValue(bInt):\n            if aDouble > bInt\
    \ {\n                return b\n            }\n            else if aDouble == bInt\
    \ {\n                return nil\n            }\n            else if aDouble ==\
    \ -1 {\n                return .doubleValue(-1)\n            }\n            else\
    \ if bDouble == -1 {\n                return .doubleValue(-1)\n            }\n\
    \            else if aDouble == bInt {\n                if let double = Double(aDouble)\
    \ {\n                    return .doubleValue(double)\n                }\n    \
    \            else {\n                    return .intValue(aInt)\n            \
    \    }\n            }\n            else {\n                return .doubleValue(aDouble)\n\
    \            }\n        case .doubleValue(bDouble):\n            if b == .doubleValue(bDouble)\
    \ {\n                return nil\n            }\n            else if aDouble >\
    \ b {\n                return .doubleValue(aDouble)\n            }\n         \
    \   else if aDouble == b {\n                return .doubleValue(aDouble)\n   \
    \         }\n            else {\n                return .intValue(aInt)\n    \
    \        }\n        case .stringValue(bString):\n            if b == .stringValue(bString)\
    \ {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpehh2aiy7.swift:141:66: error: expected '}' at end of 'switch' statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpehh2aiy7.swift:79:18:\
    \ note: to match this opening '{'\n        switch b {\n                 ^\n/tmp/tmpehh2aiy7.swift:141:66:\
    \ error: expected '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpehh2aiy7.swift:22:14: note: to match this opening\
    \ '{'\n    switch a {\n             ^\n/tmp/tmpehh2aiy7.swift:141:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpehh2aiy7.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmpehh2aiy7.swift:23:20: error: cannot find 'aInt'\
    \ in scope\n    case .intValue(aInt):\n                   ^~~~\n/tmp/tmpehh2aiy7.swift:78:23:\
    \ error: cannot find 'aDouble' in scope\n    case .doubleValue(aDouble):\n   \
    \                   ^~~~~~~\n/tmp/tmpehh2aiy7.swift:25:24: error: cannot find\
    \ 'bInt' in scope\n        case .intValue(bInt):\n                       ^~~~\n\
    /tmp/tmpehh2aiy7.swift:49:27: error: cannot find 'aDouble' in scope\n        case\
    \ .doubleValue(aDouble):\n                          ^~~~~~~\n/tmp/tmpehh2aiy7.swift:62:27:\
    \ error: cannot find 'aString' in scope\n        case .stringValue(aString):\n\
    \                          ^~~~~~~\n/tmp/tmpehh2aiy7.swift:26:16: error: cannot\
    \ find 'aInt' in scope\n            if aInt > bInt {\n               ^~~~\n/tmp/tmpehh2aiy7.swift:26:23:\
    \ error: cannot find 'bInt' in scope\n            if aInt > bInt {\n         \
    \             ^~~~\n/tmp/tmpehh2aiy7.swift:29:21: error: cannot find 'aInt' in\
    \ scope\n            else if aInt == bInt {\n                    ^~~~\n/tmp/tmpehh2aiy7.swift:29:29:\
    \ error: cannot find 'bInt' "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aFloat = a?.doubleValue\n    let bFloat\
    \ = b?.doubleValue\n    \n    if aFloat != nil && bFloat != nil {\n        if\
    \ aFloat! < bFloat! {\n            return a\n        } else {\n            return\
    \ b\n        }\n    } else {\n        if a == b {\n            return nil\n  \
    \      } else {\n            return a\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpw59ixsxt.swift:22:19: error: cannot use optional chaining on non-optional\
    \ value of type 'Value'\n    let aFloat = a?.doubleValue\n                 ~^\n\
    \                  \n/tmp/tmpw59ixsxt.swift:22:19: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n    let aFloat = a?.doubleValue\n    \
    \             ~^\n                 Value\n/tmp/tmpw59ixsxt.swift:23:19: error:\
    \ cannot use optional chaining on non-optional value of type 'Value'\n    let\
    \ bFloat = b?.doubleValue\n                 ~^\n                  \n/tmp/tmpw59ixsxt.swift:23:19:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    let\
    \ bFloat = b?.doubleValue\n                 ~^\n                 Value\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var big = a // a is always larger\n    if\
    \ let bv = b.intValue, va = a.intValue, va! >= bv {\n        big = b\n    }\n\
    \    if let bv = b.doubleValue, va = a.doubleValue, va! >= bv {\n        big =\
    \ b\n    }\n    if let bv = b.stringValue, va = a.stringValue, va! >= bv {\n \
    \       big = b\n    }\n    return big\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpy047ex9z.swift:23:29: error: expected 'let' in conditional\n  \
    \  if let bv = b.intValue, va = a.intValue, va! >= bv {\n                    \
    \        ^\n                            let \n/tmp/tmpy047ex9z.swift:26:32: error:\
    \ expected 'let' in conditional\n    if let bv = b.doubleValue, va = a.doubleValue,\
    \ va! >= bv {\n                               ^\n                            \
    \   let \n/tmp/tmpy047ex9z.swift:29:32: error: expected 'let' in conditional\n\
    \    if let bv = b.stringValue, va = a.stringValue, va! >= bv {\n            \
    \                   ^\n                               let \n/tmp/tmpy047ex9z.swift:23:17:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ bv = b.intValue, va = a.intValue, va! >= bv {\n                ^\n         \
    \       Value\n/tmp/tmpy047ex9z.swift:23:34: error: enum case 'intValue' cannot\
    \ be used as an instance member\n    if let bv = b.intValue, va = a.intValue,\
    \ va! >= bv {\n                                 ^\n                          \
    \       Value\n/tmp/tmpy047ex9z.swift:26:17: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n    if let bv = b.doubleValue, va = a.doubleValue,\
    \ va! >= bv {\n                ^\n                Value\n/tmp/tmpy047ex9z.swift:26:37:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ let bv = b.doubleValue, va = a.doubleValue, va! >= bv {\n                  \
    \                  ^\n                                    Value\n/tmp/tmpy047ex9z.swift:29:17:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n    if\
    \ let bv = b.stringValue, va = a.stringValue, va! >= bv {\n                ^\n\
    \                Value\n/tmp/tmpy047ex9z.swift:29:37: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n    if let bv = b.stringValue, va = a.stringValue,\
    \ va! >= bv {\n                                    ^\n                       \
    \             Value\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a <-> b {\n    case .intValue(_):\n\
    \        return b\n    case .doubleValue(_):\n        return a\n    case .stringValue(_):\n\
    \        return a\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdishab3c.swift:22:14: error: cannot find operator '<->' in scope\n\
    \    switch a <-> b {\n             ^~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // TODO: add support for structs\n\
    \    case .intValue(i):\n        return .doubleValue(max(i, b))\n    case .doubleValue(db):\n\
    \        return .intValue(min(db, Double.max))\n    case .stringValue(s):\n  \
    \      let db2 = Double(s)\n        if db2 == db {\n            return .doubleValue(max(db,\
    \ b))\n        } else {\n            return .intValue(min(db, db2))\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpy0veuz_l.swift:23:20: error: cannot find 'i' in scope\n    case\
    \ .intValue(i):\n                   ^\n/tmp/tmpy0veuz_l.swift:25:23: error: cannot\
    \ find 'db' in scope\n    case .doubleValue(db):\n                      ^~\n/tmp/tmpy0veuz_l.swift:27:23:\
    \ error: cannot find 's' in scope\n    case .stringValue(s):\n               \
    \       ^\n/tmp/tmpy0veuz_l.swift:24:33: error: cannot find 'i' in scope\n   \
    \     return .doubleValue(max(i, b))\n                                ^\n/tmp/tmpy0veuz_l.swift:24:36:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \        return .doubleValue(max(i, b))\n                                   ^\n\
    /tmp/tmpy0veuz_l.swift:26:30: error: cannot find 'db' in scope\n        return\
    \ .intValue(min(db, Double.max))\n                             ^~\n/tmp/tmpy0veuz_l.swift:26:41:\
    \ error: type 'Double' has no member 'max'\n        return .intValue(min(db, Double.max))\n\
    \                                 ~~~~~~ ^~~\n/tmp/tmpy0veuz_l.swift:28:26: error:\
    \ cannot find 's' in scope\n        let db2 = Double(s)\n                    \
    \     ^\n/tmp/tmpy0veuz_l.swift:29:19: error: cannot find 'db' in scope\n    \
    \    if db2 == db {\n                  ^~\n/tmp/tmpy0veuz_l.swift:30:37: error:\
    \ cannot find 'db' in scope\n            return .doubleValue(max(db, b))\n   \
    \                                 ^~\n/tmp/tmpy0veuz_l.swift:30:41: error: cannot\
    \ convert value of type 'Value' to expected argument type 'Double'\n         \
    \   return .doubleValue(max(db, b))\n                                        ^\n\
    /tmp/tmpy0veuz_l.swift:32:34: error: cannot find 'db' in scope\n            return\
    \ .intValue(min(db, db2))\n                                 ^~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    guard let bValue = aValue.compare(bValue)\
    \ else {\n        return nil\n    }\n    \n    return bValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkpfjzyzd.swift:23:24: error: cannot find 'aValue' in scope\n  \
    \  guard let bValue = aValue.compare(bValue) else {\n                       ^~~~~~\n\
    /tmp/tmpkpfjzyzd.swift:23:39: error: cannot find 'bValue' in scope\n    guard\
    \ let bValue = aValue.compare(bValue) else {\n                               \
    \       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let (max1, max2) = (a.doubleValue(), b.doubleValue())\n\
    \    if max1 == max2 {\n        if a.doubleValue() == b.doubleValue() {\n    \
    \        // If the numbers are the same, compare the strings.\n            return\
    \ (a.stringValue(), b.stringValue())\n        } else {\n            // If the\
    \ numbers are different, return nil.\n            return nil\n        }\n    }\
    \ else {\n        // If the numbers are different, return the larger one.\n  \
    \      return max1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpod1j14cr.swift:22:39: error: missing argument for parameter #1\
    \ in call\n    let (max1, max2) = (a.doubleValue(), b.doubleValue())\n       \
    \                               ^\n                                      <#Double#>\n\
    /tmp/tmpod1j14cr.swift:4:10: note: 'doubleValue' declared here\n    case doubleValue(Double)\n\
    \         ^\n/tmp/tmpod1j14cr.swift:22:25: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n    let (max1, max2) = (a.doubleValue(), b.doubleValue())\n\
    \                        ^\n                        Value\n/tmp/tmpod1j14cr.swift:22:56:\
    \ error: missing argument for parameter #1 in call\n    let (max1, max2) = (a.doubleValue(),\
    \ b.doubleValue())\n                                                       ^\n\
    \                                                       <#Double#>\n/tmp/tmpod1j14cr.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmpod1j14cr.swift:22:42: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n    let (max1, max2) = (a.doubleValue(), b.doubleValue())\n\
    \                                         ^\n                                \
    \         Value\n/tmp/tmpod1j14cr.swift:24:12: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n        if a.doubleValue() == b.doubleValue()\
    \ {\n           ^\n           Value\n/tmp/tmpod1j14cr.swift:24:26: error: missing\
    \ argument for parameter #1 in call\n        if a.doubleValue() == b.doubleValue()\
    \ {\n                         ^\n                         <#Double#>\n/tmp/tmpod1j14cr.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmpod1j14cr.swift:24:31: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n        if a.doubleValue() == b.doubleValue() {\n      \
    \                        ^\n                              Value\n/tmp/tmpod1j14cr.swift:24:45:\
    \ error: missing argument for parameter #1 in call\n        if a.doubleValue()\
    \ == b.doubleValue() {\n                                            ^\n      \
    \                                    "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    let a: Int, b: Int, stringA: String?\n\
    \    \n    if let intAInt = a.intValue {\n        a = intAInt\n    }\n    \n \
    \   if let intBInt = b.intValue {\n        b = intBInt\n    }\n    \n    if let\
    \ doubleA = a.doubleValue {\n        a = doubleA\n    }\n    \n    if let doubleB\
    \ = b.doubleValue {\n        b = doubleB\n    }\n    \n    if let stringAString\
    \ = a.stringValue {\n        stringA = stringAString\n    }\n    \n    if let\
    \ stringBString = b.stringValue {\n        stringB = stringBString\n    }\n  \
    \  \n    if a == b {\n        return a\n    }\n    \n    if a < b {\n        return\
    \ a\n    }\n    \n    if a == Double.leastNonzeroMagnitude || b == Double.leastNonzeroMagnitude\
    \ {\n        return a\n    }\n    \n    if a > b {\n        return b\n    }\n\
    \    \n    if stringA != nil && stringB != nil {\n        if stringA.intValue\
    \ < stringB.intValue {\n            return a\n        }\n        \n        if\
    \ stringA.intValue > stringB.intValue {\n            return b\n        }\n   \
    \     \n        return nil\n    }\n    \n    if stringA == nil && stringB != nil\
    \ {\n        if stringB.intValue > b.intValue {\n            return a\n      \
    \  }\n        \n        return b\n    }\n    \n    if stringA != nil && stringB\
    \ == nil {\n        if stringA.intValue < a.intValue {\n            return b\n\
    \        }\n        \n        return a\n    }\n    \n    if stringA == nil &&\
    \ stringB == nil {\n        return nil\n    }\n    \n    return a\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnf1qeod1.swift:25:24: error: value of type 'Int' has no member\
    \ 'intValue'\n    if let intAInt = a.intValue {\n                     ~ ^~~~~~~~\n\
    /tmp/tmpnf1qeod1.swift:29:24: error: value of type 'Int' has no member 'intValue'\n\
    \    if let intBInt = b.intValue {\n                     ~ ^~~~~~~~\n/tmp/tmpnf1qeod1.swift:33:24:\
    \ error: value of type 'Int' has no member 'doubleValue'\n    if let doubleA =\
    \ a.doubleValue {\n                     ~ ^~~~~~~~~~~\n/tmp/tmpnf1qeod1.swift:37:24:\
    \ error: value of type 'Int' has no member 'doubleValue'\n    if let doubleB =\
    \ b.doubleValue {\n                     ~ ^~~~~~~~~~~\n/tmp/tmpnf1qeod1.swift:41:30:\
    \ error: value of type 'Int' has no member 'stringValue'\n    if let stringAString\
    \ = a.stringValue {\n                           ~ ^~~~~~~~~~~\n/tmp/tmpnf1qeod1.swift:45:30:\
    \ error: value of type 'Int' has no member 'stringValue'\n    if let stringBString\
    \ = b.stringValue {\n                           ~ ^~~~~~~~~~~\n/tmp/tmpnf1qeod1.swift:46:9:\
    \ error: cannot find 'stringB' in scope\n        stringB = stringBString\n   \
    \     ^~~~~~~\n/tmp/tmpnf1qeod1.swift:50:16: error: cannot convert return expression\
    \ of type 'Int' to return type 'Value?'\n        return a\n               ^\n\
    /tmp/tmpnf1qeod1.swift:54:16: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a\n               ^\n/tmp/tmpnf1qeod1.swift:57:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \    if a == Double.leastNonzeroMagnitude || b == Double.leastNonzeroMagnitude\
    \ {\n                   ^\n            Int(                        )\n/tmp/tmpnf1qeod1.swift:57:57:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \    if a == Double.leastNonzeroMagnitude || b == Double.leastNonzeroMagnitude\
    \ {\n                                                        ^\n             \
    \                                    Int(                        )\n/tmp/tmpnf1qeod1.swift:58:16:\
    \ error: cannot convert return expression of type 'Int' to return type 'Value?'\n\
    \        return a\n  "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var biggest: Value?\n\n    var aFloat = a\n\
    \    var bFloat = b\n    if let aString = a.stringValue, let bString = b.stringValue\
    \ {\n        if aString == bString {\n            return aFloat\n        }\n \
    \       if aString == \".\" {\n            aFloat = .intValue(Double(aString.unicodeScalars.first!))\n\
    \        }\n        if bString == \".\" {\n            bFloat = .intValue(Double(bString.unicodeScalars.first!))\n\
    \        }\n        return nil\n    }\n\n    if let aInt = a.intValue, let bInt\
    \ = b.intValue {\n        if aInt > bInt {\n            biggest = a\n        }\n\
    \        else if aInt < bInt {\n            biggest = b\n        }\n        else\
    \ { return nil }\n    }\n    if let aDouble = a.doubleValue, let bDouble = b.doubleValue\
    \ {\n        if aDouble > bDouble {\n            biggest = a\n        }\n    \
    \    else if aDouble < bDouble {\n            biggest = b\n        }\n       \
    \ else { return nil }\n    }\n\n    return biggest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpco5hdi3g.swift:26:22: error: enum case 'stringValue' cannot be\
    \ used as an instance member\n    if let aString = a.stringValue, let bString\
    \ = b.stringValue {\n                     ^\n                     Value\n/tmp/tmpco5hdi3g.swift:26:51:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n    if\
    \ let aString = a.stringValue, let bString = b.stringValue {\n               \
    \                                   ^\n                                      \
    \            Value\n/tmp/tmpco5hdi3g.swift:39:19: error: enum case 'intValue'\
    \ cannot be used as an instance member\n    if let aInt = a.intValue, let bInt\
    \ = b.intValue {\n                  ^\n                  Value\n/tmp/tmpco5hdi3g.swift:39:42:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ aInt = a.intValue, let bInt = b.intValue {\n                               \
    \          ^\n                                         Value\n/tmp/tmpco5hdi3g.swift:48:22:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ let aDouble = a.doubleValue, let bDouble = b.doubleValue {\n               \
    \      ^\n                     Value\n/tmp/tmpco5hdi3g.swift:48:51: error: enum\
    \ case 'doubleValue' cannot be used as an instance member\n    if let aDouble\
    \ = a.doubleValue, let bDouble = b.doubleValue {\n                           \
    \                       ^\n                                                  Value\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n        case .intValue(aInt):\n\
    \            switch b {\n                case .intValue(bInt):\n             \
    \       return bInt\n                case .doubleValue(bDouble):\n           \
    \         return bDouble\n                case .stringValue(bString):\n      \
    \              if let aString = aInt as? String, bString = bInt as? String, aString\
    \ < bString {\n                        return .intValue(bInt)\n              \
    \      } else if aString == bString, let bDouble = bInt as? Double {\n       \
    \                 return .doubleValue(bDouble)\n                    }\n      \
    \              return .stringValue(bString)\n            }\n        case .doubleValue(aDouble):\n\
    \            switch b {\n                case .intValue(bInt):\n             \
    \       return bInt\n                case .doubleValue(bDouble):\n           \
    \         return bDouble\n                case .stringValue(bString):\n      \
    \              if let aDouble = aInt as? Double, bDouble = bInt as? Double, aDouble\
    \ < bDouble {\n                        return .intValue(bInt)\n              \
    \      } else if aDouble == bDouble, let bInt = bInt as? Int {\n             \
    \           return .doubleValue(bDouble)\n                    }\n            \
    \        return .stringValue(bString)\n            }\n        case .stringValue(aString):\n\
    \            switch b {\n                case .intValue(bInt):\n             \
    \       return bInt\n                case .doubleValue(bDouble):\n           \
    \         return bDouble\n                case .stringValue(bString):\n      \
    \              if let aString = aInt as? String, bString = bInt as? String, aString\
    \ < bString {\n                        return .intValue(bInt)\n              \
    \      } else if aString == bString, let bInt = bInt as? Int {\n             \
    \           return .doubleValue(bDouble)\n                    }\n            \
    \        return .stringValue(bString)\n            }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkhzq6oax.swift:30:55: error: expected 'let' in conditional\n  \
    \                  if let aString = aInt as? String, bString = bInt as? String,\
    \ aString < bString {\n                                                      ^\n\
    \                                                      let \n/tmp/tmpkhzq6oax.swift:44:55:\
    \ error: expected 'let' in conditional\n                    if let aDouble = aInt\
    \ as? Double, bDouble = bInt as? Double, aDouble < bDouble {\n               \
    \                                       ^\n                                  \
    \                    let \n/tmp/tmpkhzq6oax.swift:58:55: error: expected 'let'\
    \ in conditional\n                    if let aString = aInt as? String, bString\
    \ = bInt as? String, aString < bString {\n                                   \
    \                   ^\n                                                      let\
    \ \n/tmp/tmpkhzq6oax.swift:23:24: error: cannot find 'aInt' in scope\n       \
    \ case .intValue(aInt):\n                       ^~~~\n/tmp/tmpkhzq6oax.swift:37:27:\
    \ error: cannot find 'aDouble' in scope\n        case .doubleValue(aDouble):\n\
    \                          ^~~~~~~\n/tmp/tmpkhzq6oax.swift:51:27: error: cannot\
    \ find 'aString' in scope\n        case .stringValue(aString):\n             \
    \             ^~~~~~~\n/tmp/tmpkhzq6oax.swift:25:32: error: cannot find 'bInt'\
    \ in scope\n                case .intValue(bInt):\n                          \
    \     ^~~~\n/tmp/tmpkhzq6oax.swift:27:35: error: cannot find 'bDouble' in scope\n\
    \                case .doubleValue(bDouble):\n                               \
    \   ^~~~~~~\n/tmp/tmpkhzq6oax.swift:29:35: error: cannot find 'bString' in scope\n\
    \                case .stringValue(bString):\n                               \
    \   ^~~~~~~\n/tmp/tmpkhzq6oax.swift:26:28: error: cannot find 'bInt' in scope\n\
    \                    return bInt\n                           ^~~~\n/tmp/tmpkhzq6oax.swift:28:28:\
    \ error: cannot find 'bDouble' in scope\n                    return bDouble\n\
    \                           ^~~~~~~\n/tmp/tmpkhzq6oax.swift:30:38: error: cannot\
    \ find 'aInt' in scope\n                    i"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(intValue(a)) case\
    \ .doubleValue(doubleValue(a)) case .stringValue(stringValue(a)) }\n    switch\
    \ b { case .intValue(intValue(b)) case .doubleValue(doubleValue(b)) case .stringValue(stringValue(b))\
    \ }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvkhy90_h.swift:22:44: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(intValue(a)) case .doubleValue(doubleValue(a)) case .stringValue(stringValue(a))\
    \ }\n                                           ^\n/tmp/tmpvkhy90_h.swift:22:78:\
    \ error: expected ':' after 'case'\n    switch a { case .intValue(intValue(a))\
    \ case .doubleValue(doubleValue(a)) case .stringValue(stringValue(a)) }\n    \
    \                                                                         ^\n\
    /tmp/tmpvkhy90_h.swift:22:112: error: expected ':' after 'case'\n    switch a\
    \ { case .intValue(intValue(a)) case .doubleValue(doubleValue(a)) case .stringValue(stringValue(a))\
    \ }\n                                                                        \
    \                                       ^\n/tmp/tmpvkhy90_h.swift:23:44: error:\
    \ expected ':' after 'case'\n    switch b { case .intValue(intValue(b)) case .doubleValue(doubleValue(b))\
    \ case .stringValue(stringValue(b)) }\n                                      \
    \     ^\n/tmp/tmpvkhy90_h.swift:23:78: error: expected ':' after 'case'\n    switch\
    \ b { case .intValue(intValue(b)) case .doubleValue(doubleValue(b)) case .stringValue(stringValue(b))\
    \ }\n                                                                        \
    \     ^\n/tmp/tmpvkhy90_h.swift:23:112: error: expected ':' after 'case'\n   \
    \ switch b { case .intValue(intValue(b)) case .doubleValue(doubleValue(b)) case\
    \ .stringValue(stringValue(b)) }\n                                           \
    \                                                                    ^\n/tmp/tmpvkhy90_h.swift:22:31:\
    \ error: cannot find 'intValue' in scope\n    switch a { case .intValue(intValue(a))\
    \ case .doubleValue(doubleValue(a)) case .stringValue(stringValue(a)) }\n    \
    \                          ^~~~~~~~\n/tmp/tmpvkhy90_h.swift:22:62: error: cannot\
    \ find 'doubleValue' in scope\n    switch a { case .intValue(intValue(a)) case\
    \ .doubleValue(doubleValue(a)) case .stringValue(stringValue(a)) }\n         \
    \                                                    ^~~~~~~~~~~\n/tmp/tmpvkhy90_h.swift:22:96:\
    \ error: "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b)):\n\
    \        return .intValue(a)\n    case (.doubleValue(a), .doubleValue(b)):\n \
    \       return .doubleValue(a)\n    case (.stringValue(a), .stringValue(b)):\n\
    \        if a == \"1\" || b == \"1\" {\n            return .stringValue(\"1\"\
    )\n        } else if a.isEmpty || b.isEmpty {\n            return .stringValue(\"\
    \")\n        } else {\n            if let a = a.stringValue, let b = b.stringValue\
    \ {\n                if a.isEmpty || b.isEmpty {\n                    return .stringValue(\"\
    \")\n                } else {\n                    guard let aNum = Double(a),\
    \ let bNum = Double(b) else {\n                        fatalError(\"Incompatible\
    \ types (use Double instead)\")\n                    }\n                    if\
    \ aNum > bNum {\n                        return .stringValue(a)\n            \
    \        } else if aNum < bNum {\n                        return .stringValue(b)\n\
    \                    }\n                }\n            }\n        }\n    case\
    \ (.intValue(a), .stringValue(b)):\n        return .stringValue(\"\")\n    case\
    \ (.doubleValue(a), .intValue(b)):\n        return .intValue(a)\n    case (.stringValue(a),\
    \ .doubleValue(b)):\n        return .doubleValue(a)\n    }\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpznx0f70d.swift:23:21: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case (.intValue(a), .intValue(b)):\n\
    \                    ^\n/tmp/tmpznx0f70d.swift:25:24: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .doubleValue(b)):\n                       ^\n/tmp/tmpznx0f70d.swift:27:24: error:\
    \ expression pattern of type 'Value' cannot match values of type 'String'\n  \
    \  case (.stringValue(a), .stringValue(b)):\n                       ^\n/tmp/tmpznx0f70d.swift:27:24:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case (.stringValue(a), .stringValue(b)):\n        \
    \               ^\n/tmp/tmpznx0f70d.swift:48:21: error: expression pattern of\
    \ type 'Value' cannot match values of type 'Int'\n    case (.intValue(a), .stringValue(b)):\n\
    \                    ^\n/tmp/tmpznx0f70d.swift:50:24: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .intValue(b)):\n                       ^\n/tmp/tmpznx0f70d.swift:52:24: error:\
    \ expression pattern of type 'Value' cannot match values of type 'String'\n  \
    \  case (.stringValue(a), .doubleValue(b)):\n                       ^\n/tmp/tmpznx0f70d.swift:52:24:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case (.stringValue(a), .doubleValue(b)):\n        \
    \               ^\n/tmp/tmpznx0f70d.swift:24:26: error: cannot convert value of\
    \ type 'Value' to expected argument type 'Int'\n        return .intValue(a)\n\
    \                         ^\n/tmp/tmpznx0f70d.swift:26:29: error: cannot convert\
    \ value of type 'Value' to expected argument type 'Double'\n        return .doubleValue(a)\n\
    \                            ^\n/tmp/tmpznx0f70d.swift:28:14: error: referencing\
    \ operator function '==' on 'StringProtocol' requires that 'Value' conform to\
    \ 'StringProtocol'\n        if a == \"1\" || b == \"1\" {\n             ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Value'\nextension StringProtocol"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // Switch the types of the parameters\n\
    \    case .intValue(nilValue): return b\n    case .doubleValue(nilValue): return\
    \ nil\n    case .stringValue(stringValue):\n        if let n = Double(stringValue),\
    \ let x = a, let y = b {\n            return x.doubleValue() <= n && y.doubleValue()\
    \ <= n ? x : y\n        }\n        return nil\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8zpfk0cr.swift:23:20: error: cannot find 'nilValue' in scope\n\
    \    case .intValue(nilValue): return b\n                   ^~~~~~~~\n/tmp/tmp8zpfk0cr.swift:24:23:\
    \ error: cannot find 'nilValue' in scope\n    case .doubleValue(nilValue): return\
    \ nil\n                      ^~~~~~~~\n/tmp/tmp8zpfk0cr.swift:25:23: error: cannot\
    \ find 'stringValue' in scope\n    case .stringValue(stringValue):\n         \
    \             ^~~~~~~~~~~\n/tmp/tmp8zpfk0cr.swift:26:27: error: cannot find 'stringValue'\
    \ in scope\n        if let n = Double(stringValue), let x = a, let y = b {\n \
    \                         ^~~~~~~~~~~\n/tmp/tmp8zpfk0cr.swift:27:36: error: binary\
    \ operator '<=' cannot be applied to operands of type 'Value' and '_'\n      \
    \      return x.doubleValue() <= n && y.doubleValue() <= n ? x : y\n         \
    \          ~~~~~~~~~~~~~~~ ^  ~\n/tmp/tmp8zpfk0cr.swift:27:60: error: binary operator\
    \ '<=' cannot be applied to operands of type 'Value' and '_'\n            return\
    \ x.doubleValue() <= n && y.doubleValue() <= n ? x : y\n                     \
    \                      ~~~~~~~~~~~~~~~ ^  ~\n/tmp/tmp8zpfk0cr.swift:27:34: error:\
    \ missing argument for parameter #1 in call\n            return x.doubleValue()\
    \ <= n && y.doubleValue() <= n ? x : y\n                                 ^\n \
    \                                <#Double#>\n/tmp/tmp8zpfk0cr.swift:4:10: note:\
    \ 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmp8zpfk0cr.swift:27:58:\
    \ error: missing argument for parameter #1 in call\n            return x.doubleValue()\
    \ <= n && y.doubleValue() <= n ? x : y\n                                     \
    \                    ^\n                                                     \
    \    <#Double#>\n/tmp/tmp8zpfk0cr.swift:4:10: note: 'doubleValue' declared here\n\
    \    case doubleValue(Double)\n         ^\n/tmp/tmp8zpfk0cr.swift:26:41: error:\
    \ initializer for conditional binding must have Optional type, not 'Value'\n \
    \       if let n = Double(stringValue), let x = a, let y = b {\n             \
    \                           ^       ~\n/tmp/tmp8zpfk0cr.swift:26:52: error: initial"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(aValue),\
    \ .intValue(bValue)):\n        return aValue > bValue ? .intValue(1) : .intValue(-1)\n\
    \    case (.doubleValue(aValue), .doubleValue(bValue)):\n        return aValue\
    \ > bValue ? .doubleValue(1) : .doubleValue(-1)\n    case (.stringValue(aValue),\
    \ .stringValue(bValue)):\n        return aValue > bValue ? .stringValue(\"1\"\
    ) : .stringValue(\"-1\")\n    default:\n        return nil\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpw8ufyv8a.swift:23:21: error: cannot find 'aValue' in scope\n  \
    \  case (.intValue(aValue), .intValue(bValue)):\n                    ^~~~~~\n\
    /tmp/tmpw8ufyv8a.swift:23:40: error: cannot find 'bValue' in scope\n    case (.intValue(aValue),\
    \ .intValue(bValue)):\n                                       ^~~~~~\n/tmp/tmpw8ufyv8a.swift:25:24:\
    \ error: cannot find 'aValue' in scope\n    case (.doubleValue(aValue), .doubleValue(bValue)):\n\
    \                       ^~~~~~\n/tmp/tmpw8ufyv8a.swift:25:46: error: cannot find\
    \ 'bValue' in scope\n    case (.doubleValue(aValue), .doubleValue(bValue)):\n\
    \                                             ^~~~~~\n/tmp/tmpw8ufyv8a.swift:27:24:\
    \ error: cannot find 'aValue' in scope\n    case (.stringValue(aValue), .stringValue(bValue)):\n\
    \                       ^~~~~~\n/tmp/tmpw8ufyv8a.swift:27:46: error: cannot find\
    \ 'bValue' in scope\n    case (.stringValue(aValue), .stringValue(bValue)):\n\
    \                                             ^~~~~~\n/tmp/tmpw8ufyv8a.swift:24:16:\
    \ error: cannot find 'aValue' in scope\n        return aValue > bValue ? .intValue(1)\
    \ : .intValue(-1)\n               ^~~~~~\n/tmp/tmpw8ufyv8a.swift:24:25: error:\
    \ cannot find 'bValue' in scope\n        return aValue > bValue ? .intValue(1)\
    \ : .intValue(-1)\n                        ^~~~~~\n/tmp/tmpw8ufyv8a.swift:26:16:\
    \ error: cannot find 'aValue' in scope\n        return aValue > bValue ? .doubleValue(1)\
    \ : .doubleValue(-1)\n               ^~~~~~\n/tmp/tmpw8ufyv8a.swift:26:25: error:\
    \ cannot find 'bValue' in scope\n        return aValue > bValue ? .doubleValue(1)\
    \ : .doubleValue(-1)\n                        ^~~~~~\n/tmp/tmpw8ufyv8a.swift:28:16:\
    \ error: cannot find 'aValue' in scope\n        return aValue > bValue ? .stringValue(\"\
    1\") : .stringValue(\"-1\")\n               ^~~~~~\n/tmp/tmpw8ufyv8a.swift:28:25:\
    \ error: cannot find 'bValue' in scope\n        return aValue > bValue ? .stringValue(\"\
    1\") : .stringValue(\"-1\")\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(b): return\
    \ .intValue(b)\n    case .doubleValue(b): return .doubleValue(b)\n    case .stringValue(b):\
    \ return .stringValue(b)\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjyxq2w7l.swift:23:20: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case .intValue(b): return .intValue(b)\n\
    \                   ^\n/tmp/tmpjyxq2w7l.swift:24:23: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case .doubleValue(b):\
    \ return .doubleValue(b)\n                      ^\n/tmp/tmpjyxq2w7l.swift:25:23:\
    \ error: expression pattern of type 'Value' cannot match values of type 'String'\n\
    \    case .stringValue(b): return .stringValue(b)\n                      ^\n/tmp/tmpjyxq2w7l.swift:25:23:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case .stringValue(b): return .stringValue(b)\n    \
    \                  ^\n/tmp/tmpjyxq2w7l.swift:23:41: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n    case .intValue(b): return\
    \ .intValue(b)\n                                        ^\n/tmp/tmpjyxq2w7l.swift:24:47:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \    case .doubleValue(b): return .doubleValue(b)\n                          \
    \                    ^\n/tmp/tmpjyxq2w7l.swift:25:47: error: cannot convert value\
    \ of type 'Value' to expected argument type 'String'\n    case .stringValue(b):\
    \ return .stringValue(b)\n                                              ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(b):\n     \
    \   return a\n    case .doubleValue(b):\n        return a\n    case .stringValue(b):\n\
    \        return a\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsgdfw3_0.swift:23:20: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case .intValue(b):\n                \
    \   ^\n/tmp/tmpsgdfw3_0.swift:25:23: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Double'\n    case .doubleValue(b):\n          \
    \            ^\n/tmp/tmpsgdfw3_0.swift:27:23: error: expression pattern of type\
    \ 'Value' cannot match values of type 'String'\n    case .stringValue(b):\n  \
    \                    ^\n/tmp/tmpsgdfw3_0.swift:27:23: note: overloads for '~='\
    \ exist with these partially matching parameter lists: (Substring, String)\n \
    \   case .stringValue(b):\n                      ^\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let a_type = a.dynamicType\n    let b_type\
    \ = b.dynamicType\n    switch a_type {\n    case IntType:\n        guard let value\
    \ = a.intValue else {\n            return nil\n        }\n        return b.intValue\
    \ > value ? a : b\n    case DoubleType:\n        guard let value = a.doubleValue\
    \ else {\n            return nil\n        }\n        return b.doubleValue > value\
    \ ? a : b\n    case StringType:\n        guard let value = a.stringValue else\
    \ {\n            return nil\n        }\n        return b.stringValue > value ?\
    \ a : b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpeugn1q_2.swift:22:20: error: value of type 'Value' has no member\
    \ 'dynamicType'\n    let a_type = a.dynamicType\n                 ~ ^~~~~~~~~~~\n\
    /tmp/tmpeugn1q_2.swift:23:20: error: value of type 'Value' has no member 'dynamicType'\n\
    \    let b_type = b.dynamicType\n                 ~ ^~~~~~~~~~~\n/tmp/tmpeugn1q_2.swift:25:10:\
    \ error: cannot find 'IntType' in scope\n    case IntType:\n         ^~~~~~~\n\
    /tmp/tmpeugn1q_2.swift:30:10: error: cannot find 'DoubleType' in scope\n    case\
    \ DoubleType:\n         ^~~~~~~~~~\n/tmp/tmpeugn1q_2.swift:35:10: error: cannot\
    \ find 'StringType' in scope\n    case StringType:\n         ^~~~~~~~~~\n/tmp/tmpeugn1q_2.swift:26:27:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        guard\
    \ let value = a.intValue else {\n                          ^\n               \
    \           Value\n/tmp/tmpeugn1q_2.swift:29:27: error: binary operator '>' cannot\
    \ be applied to operands of type '(Int) -> Value' and '_'\n        return b.intValue\
    \ > value ? a : b\n               ~~~~~~~~~~ ^ ~~~~~\n/tmp/tmpeugn1q_2.swift:31:27:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  guard let value = a.doubleValue else {\n                          ^\n     \
    \                     Value\n/tmp/tmpeugn1q_2.swift:34:30: error: binary operator\
    \ '>' cannot be applied to operands of type '(Double) -> Value' and '_'\n    \
    \    return b.doubleValue > value ? a : b\n               ~~~~~~~~~~~~~ ^ ~~~~~\n\
    /tmp/tmpeugn1q_2.swift:36:27: error: enum case 'stringValue' cannot be used as\
    \ an instance member\n        guard let value = a.stringValue else {\n       \
    \                   ^\n                          Value\n/tmp/tmpeugn1q_2.swift:39:30:\
    \ error: binary operator '>' cannot be applied to operands of type '(String) ->\
    \ Value' and '_'\n        return b.stringValue > value ? a : b\n             \
    \  ~~~~~~~~~~~~~ ^ ~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(aInt): return\
    \ b == .intValue(aInt) ? nil : a\n    case .doubleValue(aDouble): return b ==\
    \ .doubleValue(aDouble) ? nil : a\n    case .stringValue(aString): return b ==\
    \ .stringValue(aString) ? nil : a\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzst1d93r.swift:23:20: error: cannot find 'aInt' in scope\n    case\
    \ .intValue(aInt): return b == .intValue(aInt) ? nil : a\n                   ^~~~\n\
    /tmp/tmpzst1d93r.swift:24:23: error: cannot find 'aDouble' in scope\n    case\
    \ .doubleValue(aDouble): return b == .doubleValue(aDouble) ? nil : a\n       \
    \               ^~~~~~~\n/tmp/tmpzst1d93r.swift:25:23: error: cannot find 'aString'\
    \ in scope\n    case .stringValue(aString): return b == .stringValue(aString)\
    \ ? nil : a\n                      ^~~~~~~\n/tmp/tmpzst1d93r.swift:23:49: error:\
    \ cannot find 'aInt' in scope\n    case .intValue(aInt): return b == .intValue(aInt)\
    \ ? nil : a\n                                                ^~~~\n/tmp/tmpzst1d93r.swift:24:58:\
    \ error: cannot find 'aDouble' in scope\n    case .doubleValue(aDouble): return\
    \ b == .doubleValue(aDouble) ? nil : a\n                                     \
    \                    ^~~~~~~\n/tmp/tmpzst1d93r.swift:25:58: error: cannot find\
    \ 'aString' in scope\n    case .stringValue(aString): return b == .stringValue(aString)\
    \ ? nil : a\n                                                         ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // Compare a and b as double values, not as\
    \ strings containing doubles.\n    // This allows for precision loss from double\
    \ math, but only if the doubles\n    // are exactly representable.\n    switch\
    \ a as? Double {\n    case let as as Double:\n        switch b as? Double {\n\
    \        case is < as: return a\n        case is > as: return nil\n        case\
    \ is == as: return b\n        case is == as: break\n        }\n    case let as\
    \ as String:\n        switch b as? Double {\n        case is < as: return a\n\
    \        case is > as: return nil\n        case is == as: return b\n        case\
    \ is == as: break\n        }\n    case let as as Int:\n        switch b as? Double\
    \ {\n        case is < as: return a\n        case is > as: return nil\n      \
    \  case is == as: return b\n        case is == as: break\n        }\n    case\
    \ let as as Float:\n        switch b as? Double {\n        case is < as: return\
    \ a\n        case is > as: return nil\n        case is == as: return b\n     \
    \   case is == as: break\n        }\n    }\n    \n    // If a and b are both strings\
    \ with no decimal points, treat them as\n    // equal, since they both contain\
    \ no decimal points. Return nil if they\n    // are equal.\n    switch a as? String,\
    \ b as? String {\n    case (.same, .same):\n        return nil\n    case (.same,\
    \ .same):\n        return nil\n    case (.hasSuffix(separator: \".\"), b hasSuffix(separator:\
    \ \".\")):\n        return nil\n    case (a hasSuffix(separator: \",\"), b hasSuffix(separator:\
    \ \",\")):\n        return nil\n    case (.hasSuffix(separator: \",\"), b hasSuffix(separator:\
    \ \".\")):\n        return nil\n    case (.hasSuffix(separator: \",\"), a hasSuffix(separator:\
    \ \",\")):\n        return nil\n    case (.hasSuffix(separator: \",\"), b hasSuffix(separator:\
    \ \",\")):\n        return nil\n    default:\n        return a\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7y1xap4m.swift:26:14: error: expected pattern\n    case let as\
    \ as Double:\n             ^\n/tmp/tmp7y1xap4m.swift:26:14: error: expected ':'\
    \ after 'case'\n    case let as as Double:\n             ^\n/tmp/tmp7y1xap4m.swift:26:14:\
    \ error: expected expression\n    case let as as Double:\n             ^\n/tmp/tmp7y1xap4m.swift:28:17:\
    \ error: expected type\n        case is < as: return a\n                ^\n/tmp/tmp7y1xap4m.swift:28:17:\
    \ error: expected ':' after 'case'\n        case is < as: return a\n         \
    \       ^\n/tmp/tmp7y1xap4m.swift:28:17: error: unary operator cannot be separated\
    \ from its operand\n        case is < as: return a\n                ^~\n     \
    \            \n/tmp/tmp7y1xap4m.swift:28:19: error: expected expression\n    \
    \    case is < as: return a\n                  ^\n/tmp/tmp7y1xap4m.swift:29:17:\
    \ error: expected type\n        case is > as: return nil\n                ^\n\
    /tmp/tmp7y1xap4m.swift:29:17: error: expected ':' after 'case'\n        case is\
    \ > as: return nil\n                ^\n/tmp/tmp7y1xap4m.swift:29:17: error: unary\
    \ operator cannot be separated from its operand\n        case is > as: return\
    \ nil\n                ^~\n                 \n/tmp/tmp7y1xap4m.swift:29:19: error:\
    \ expected expression\n        case is > as: return nil\n                  ^\n\
    /tmp/tmp7y1xap4m.swift:30:17: error: expected type\n        case is == as: return\
    \ b\n                ^\n/tmp/tmp7y1xap4m.swift:30:17: error: expected ':' after\
    \ 'case'\n        case is == as: return b\n                ^\n/tmp/tmp7y1xap4m.swift:30:17:\
    \ error: unary operator cannot be separated from its operand\n        case is\
    \ == as: return b\n                ^ ~\n                  \n/tmp/tmp7y1xap4m.swift:30:20:\
    \ error: expected expression\n        case is == as: return b\n              \
    \     ^\n/tmp/tmp7y1xap4m.swift:31:17: error: expected type\n        case is ==\
    \ as: break\n                ^\n/tmp/tmp7y1xap4m.swift:31:17: error: expected\
    \ ':' after 'case'\n        case is == as: break\n                ^\n/tmp/tmp7y1xap4m.swift:31:17:\
    \ error: unary operator cannot be separated from its operand\n     "
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if case .intValue(aVal) = a {\n        switch\
    \ b {\n        case .intValue(bVal), .doubleValue(bVal):\n            return bVal\n\
    \        case .stringValue(bVal):\n            return bVal.compare(aVal)\n   \
    \     default:\n            return nil\n        }\n    } else if case .doubleValue(aVal)\
    \ = a {\n        switch b {\n        case .intValue(bVal), .doubleValue(bVal):\n\
    \            return aVal\n        case .stringValue(bVal):\n            return\
    \ aVal.compare(bVal)\n        default:\n            return nil\n        }\n  \
    \  } else {\n        if case .stringValue(aVal) = a {\n            if case .stringValue(bVal)\
    \ = b {\n                return aVal\n            } else {\n                return\
    \ nil\n            }\n        } else {\n            if case .stringValue(bVal)\
    \ = a {\n                return bVal\n            } else {\n                return\
    \ nil\n            }\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprt192fjk.swift:22:23: error: cannot find 'aVal' in scope\n    if\
    \ case .intValue(aVal) = a {\n                      ^~~~\n/tmp/tmprt192fjk.swift:24:24:\
    \ error: cannot find 'bVal' in scope\n        case .intValue(bVal), .doubleValue(bVal):\n\
    \                       ^~~~\n/tmp/tmprt192fjk.swift:24:44: error: cannot find\
    \ 'bVal' in scope\n        case .intValue(bVal), .doubleValue(bVal):\n       \
    \                                    ^~~~\n/tmp/tmprt192fjk.swift:26:27: error:\
    \ cannot find 'bVal' in scope\n        case .stringValue(bVal):\n            \
    \              ^~~~\n/tmp/tmprt192fjk.swift:25:20: error: cannot find 'bVal' in\
    \ scope\n            return bVal\n                   ^~~~\n/tmp/tmprt192fjk.swift:27:20:\
    \ error: cannot find 'bVal' in scope\n            return bVal.compare(aVal)\n\
    \                   ^~~~\n/tmp/tmprt192fjk.swift:27:33: error: cannot find 'aVal'\
    \ in scope\n            return bVal.compare(aVal)\n                          \
    \      ^~~~\n/tmp/tmprt192fjk.swift:31:33: error: cannot find 'aVal' in scope\n\
    \    } else if case .doubleValue(aVal) = a {\n                               \
    \ ^~~~\n/tmp/tmprt192fjk.swift:33:24: error: cannot find 'bVal' in scope\n   \
    \     case .intValue(bVal), .doubleValue(bVal):\n                       ^~~~\n\
    /tmp/tmprt192fjk.swift:33:44: error: cannot find 'bVal' in scope\n        case\
    \ .intValue(bVal), .doubleValue(bVal):\n                                     \
    \      ^~~~\n/tmp/tmprt192fjk.swift:35:27: error: cannot find 'bVal' in scope\n\
    \        case .stringValue(bVal):\n                          ^~~~\n/tmp/tmprt192fjk.swift:34:20:\
    \ error: cannot find 'aVal' in scope\n            return aVal\n              \
    \     ^~~~\n/tmp/tmprt192fjk.swift:36:20: error: cannot find 'aVal' in scope\n\
    \            return aVal.compare(bVal)\n                   ^~~~\n/tmp/tmprt192fjk.swift:36:33:\
    \ error: cannot find 'bVal' in scope\n            return aVal.compare(bVal)\n\
    \                                ^~~~\n/tmp/tmprt192fjk.swift:41:30: error: cannot\
    \ find 'aVal' in scope\n        if case .stringValue(aVal) = a {\n           \
    \                  ^~~~\n/tmp/t"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(aValue),\
    \ .intValue(bValue)):\n        if aValue > bValue { return b }\n        if aValue\
    \ < bValue { return a }\n        return nil\n\n    case (.doubleValue(aValue),\
    \ .doubleValue(bValue)):\n        if aValue > bValue { return b }\n        if\
    \ aValue < bValue { return a }\n        return nil\n\n    case (.stringValue(aValue),\
    \ .stringValue(bValue)):\n        if aValue > bValue { return b }\n        if\
    \ aValue < bValue { return a }\n        return nil\n    }\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvux2vt_q.swift:23:21: error: cannot find 'aValue' in scope\n  \
    \  case (.intValue(aValue), .intValue(bValue)):\n                    ^~~~~~\n\
    /tmp/tmpvux2vt_q.swift:23:40: error: cannot find 'bValue' in scope\n    case (.intValue(aValue),\
    \ .intValue(bValue)):\n                                       ^~~~~~\n/tmp/tmpvux2vt_q.swift:28:24:\
    \ error: cannot find 'aValue' in scope\n    case (.doubleValue(aValue), .doubleValue(bValue)):\n\
    \                       ^~~~~~\n/tmp/tmpvux2vt_q.swift:28:46: error: cannot find\
    \ 'bValue' in scope\n    case (.doubleValue(aValue), .doubleValue(bValue)):\n\
    \                                             ^~~~~~\n/tmp/tmpvux2vt_q.swift:33:24:\
    \ error: cannot find 'aValue' in scope\n    case (.stringValue(aValue), .stringValue(bValue)):\n\
    \                       ^~~~~~\n/tmp/tmpvux2vt_q.swift:33:46: error: cannot find\
    \ 'bValue' in scope\n    case (.stringValue(aValue), .stringValue(bValue)):\n\
    \                                             ^~~~~~\n/tmp/tmpvux2vt_q.swift:24:12:\
    \ error: cannot find 'aValue' in scope\n        if aValue > bValue { return b\
    \ }\n           ^~~~~~\n/tmp/tmpvux2vt_q.swift:24:21: error: cannot find 'bValue'\
    \ in scope\n        if aValue > bValue { return b }\n                    ^~~~~~\n\
    /tmp/tmpvux2vt_q.swift:25:12: error: cannot find 'aValue' in scope\n        if\
    \ aValue < bValue { return a }\n           ^~~~~~\n/tmp/tmpvux2vt_q.swift:25:21:\
    \ error: cannot find 'bValue' in scope\n        if aValue < bValue { return a\
    \ }\n                    ^~~~~~\n/tmp/tmpvux2vt_q.swift:29:12: error: cannot find\
    \ 'aValue' in scope\n        if aValue > bValue { return b }\n           ^~~~~~\n\
    /tmp/tmpvux2vt_q.swift:29:21: error: cannot find 'bValue' in scope\n        if\
    \ aValue > bValue { return b }\n                    ^~~~~~\n/tmp/tmpvux2vt_q.swift:30:12:\
    \ error: cannot find 'aValue' in scope\n        if aValue < bValue { return a\
    \ }\n           ^~~~~~\n/tmp/tmpvux2vt_q.swift:30:21: error: cannot find 'bValue'\
    \ in scope\n        if aValue < bValue { return a }\n                    ^~~~~~\n\
    /tmp/tmpvux2vt_q.swift:34:12: error: cannot find 'aValu"
  stdout: ''
  timestamp: 1660013422
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_): return\
    \ b\n    case .doubleValue(_): return b\n    case .stringValue(_): return b\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpmwp84lgq/tmpmwp84lgq.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0c01dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0bfed5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0bfed5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0bfed47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmwp84lgq                        0x000055caf127201a <unavailable> + 12314

    5    libc.so.6                          0x00002ac0c03ca460 __libc_start_main +
    245

    6    tmpmwp84lgq                        0x000055caf1270499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(i): return\
    \ b == .intValue(i)\n    case .doubleValue(d): return b == .doubleValue(d) ||\
    \ b == .intValue(0)\n    case .stringValue(s): return b == .stringValue(s) ||\
    \ b == .intValue(0)\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp32wjrejq.swift:23:20: error: cannot find 'i' in scope\n    case\
    \ .intValue(i): return b == .intValue(i)\n                   ^\n/tmp/tmp32wjrejq.swift:24:23:\
    \ error: cannot find 'd' in scope\n    case .doubleValue(d): return b == .doubleValue(d)\
    \ || b == .intValue(0)\n                      ^\n/tmp/tmp32wjrejq.swift:25:23:\
    \ error: cannot find 's' in scope\n    case .stringValue(s): return b == .stringValue(s)\
    \ || b == .intValue(0)\n                      ^\n/tmp/tmp32wjrejq.swift:23:46:\
    \ error: cannot find 'i' in scope\n    case .intValue(i): return b == .intValue(i)\n\
    \                                             ^\n/tmp/tmp32wjrejq.swift:23:33:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .intValue(i): return b == .intValue(i)\n                           \
    \   ~~^~~~~~~~~~~~~~~\n/tmp/tmp32wjrejq.swift:24:52: error: cannot find 'd' in\
    \ scope\n    case .doubleValue(d): return b == .doubleValue(d) || b == .intValue(0)\n\
    \                                                   ^\n/tmp/tmp32wjrejq.swift:24:55:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .doubleValue(d): return b == .doubleValue(d) || b == .intValue(0)\n\
    \                                 ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp32wjrejq.swift:25:52: error: cannot find 's' in scope\n    case .stringValue(s):\
    \ return b == .stringValue(s) || b == .intValue(0)\n                         \
    \                          ^\n/tmp/tmp32wjrejq.swift:25:55: error: cannot convert\
    \ return expression of type 'Bool' to return type 'Value?'\n    case .stringValue(s):\
    \ return b == .stringValue(s) || b == .intValue(0)\n                         \
    \        ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var result: Value?\n    switch a as Value?\
    \ {\n    case .intValue(_):\n        switch b as Value? {\n        case .intValue(_):\n\
    \            result = a\n        case .doubleValue(let b):\n            if b >\
    \ a {\n                result = a\n            } else {\n                result\
    \ = b\n            }\n        case .stringValue(let b):\n            if b > a\
    \ {\n                result = a\n            } else {\n                result\
    \ = b\n            }\n        case nil:\n            result = b\n        }\n \
    \   case .doubleValue(let a):\n        switch b as Value? {\n        case .intValue(_):\n\
    \            if a > b {\n                result = b\n            } else {\n  \
    \              result = a\n            }\n        case .doubleValue(let b):\n\
    \            if b > a {\n                result = a\n            } else {\n  \
    \              result = b\n            }\n        case .stringValue(let b):\n\
    \            if b > a {\n                result = a\n            } else {\n  \
    \              result = b\n            }\n        case nil:\n            result\
    \ = a\n        }\n    case .stringValue(let a):\n        switch b as Value? {\n\
    \        case .intValue(_):\n            if a > b {\n                result =\
    \ b\n            } else {\n                result = a\n            }\n       \
    \ case .doubleValue(let b):\n            if b > a {\n                result =\
    \ a\n            } else {\n                result = b\n            }\n       \
    \ case .stringValue(let b):\n            if b > a {\n                result =\
    \ a\n            } else {\n                result = b\n            }\n       \
    \ case nil:\n            result = a\n        }\n    default:\n        result =\
    \ a\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjjf7kqom.swift:29:20: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Double'\n            if b > a {\n               \
    \    ^\n/tmp/tmpjjf7kqom.swift:32:24: error: cannot assign value of type 'Double'\
    \ to type 'Value?'\n                result = b\n                       ^\n/tmp/tmpjjf7kqom.swift:35:18:\
    \ error: operator function '>' requires that 'Value' conform to 'StringProtocol'\n\
    \            if b > a {\n                 ^\nSwift.StringProtocol:5:35: note:\
    \ where 'RHS' = 'Value'\n    @inlinable public static func > <RHS>(lhs: Self,\
    \ rhs: RHS) -> Bool where RHS : StringProtocol\n                             \
    \     ^\n/tmp/tmpjjf7kqom.swift:38:24: error: cannot assign value of type 'String'\
    \ to type 'Value?'\n                result = b\n                       ^\n/tmp/tmpjjf7kqom.swift:46:20:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \            if a > b {\n                   ^\n/tmp/tmpjjf7kqom.swift:49:24: error:\
    \ cannot assign value of type 'Double' to type 'Value?'\n                result\
    \ = a\n                       ^\n/tmp/tmpjjf7kqom.swift:53:24: error: cannot assign\
    \ value of type 'Double' to type 'Value?'\n                result = a\n      \
    \                 ^\n/tmp/tmpjjf7kqom.swift:55:24: error: cannot assign value\
    \ of type 'Double' to type 'Value?'\n                result = b\n            \
    \           ^\n/tmp/tmpjjf7kqom.swift:58:18: error: binary operator '>' cannot\
    \ be applied to operands of type 'String' and 'Double'\n            if b > a {\n\
    \               ~ ^ ~\n/tmp/tmpjjf7kqom.swift:59:24: error: cannot assign value\
    \ of type 'Double' to type 'Value?'\n                result = a\n            \
    \           ^\n/tmp/tmpjjf7kqom.swift:61:24: error: cannot assign value of type\
    \ 'String' to type 'Value?'\n                result = b\n                    \
    \   ^\n/tmp/tmpjjf7kqom.swift:64:20: error: cannot assign value of type 'Double'\
    \ to type 'Value?'\n            result = a\n                   ^\n/tmp/tmpjjf7kqom.swift:69:18:\
    \ error: operator function '>' requires that 'Value' conform to 'StringProtoc"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as! Value, b as! Value {\n    case\
    \ .intValue:\n        if a.intValue > b.intValue {\n            return a\n   \
    \     } else if a.intValue < b.intValue {\n            return b\n        } else\
    \ {\n            return nil\n        }\n    case .doubleValue:\n        if a.doubleValue\
    \ > b.doubleValue {\n            return a\n        } else if a.doubleValue < b.doubleValue\
    \ {\n            return b\n        } else {\n            return nil\n        }\n\
    \    case .stringValue:\n        if a.stringValue > b.stringValue {\n        \
    \    return a\n        } else if a.stringValue < b.stringValue {\n           \
    \ return b\n        } else {\n            return nil\n        }\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_xgflm_w.swift:22:23: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmp_xgflm_w.swift:22:23: error: consecutive statements on a line must be\
    \ separated by ';'\n    switch a as! Value, b as! Value {\n                  \
    \    ^\n                      ;\n/tmp/tmp_xgflm_w.swift:22:23: error: expected\
    \ expression\n    switch a as! Value, b as! Value {\n                      ^\n\
    /tmp/tmp_xgflm_w.swift:22:14: warning: forced cast of 'Value' to same type has\
    \ no effect\n    switch a as! Value, b as! Value {\n             ^~~~~~~~~\n \
    \            \n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // a will be in one of the cases,\
    \ e.g. .intValue(Int)\n        case .intValue(n): return b == .intValue(n) ? .intValue(Int)\
    \ : nil\n        case .doubleValue(n): return b == .doubleValue(n) ? .doubleValue(Double)\
    \ : nil\n        case .stringValue(n): return b == .stringValue(n) ? .stringValue(String)\
    \ : nil\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpn2opjzdx.swift:23:24: error: cannot find 'n' in scope\n       \
    \ case .intValue(n): return b == .intValue(n) ? .intValue(Int) : nil\n       \
    \                ^\n/tmp/tmpn2opjzdx.swift:24:27: error: cannot find 'n' in scope\n\
    \        case .doubleValue(n): return b == .doubleValue(n) ? .doubleValue(Double)\
    \ : nil\n                          ^\n/tmp/tmpn2opjzdx.swift:25:27: error: cannot\
    \ find 'n' in scope\n        case .stringValue(n): return b == .stringValue(n)\
    \ ? .stringValue(String) : nil\n                          ^\n/tmp/tmpn2opjzdx.swift:23:50:\
    \ error: cannot find 'n' in scope\n        case .intValue(n): return b == .intValue(n)\
    \ ? .intValue(Int) : nil\n                                                 ^\n\
    /tmp/tmpn2opjzdx.swift:23:65: error: cannot convert value of type 'Int.Type' to\
    \ expected argument type 'Int'\n        case .intValue(n): return b == .intValue(n)\
    \ ? .intValue(Int) : nil\n                                                   \
    \             ^\n/tmp/tmpn2opjzdx.swift:24:56: error: cannot find 'n' in scope\n\
    \        case .doubleValue(n): return b == .doubleValue(n) ? .doubleValue(Double)\
    \ : nil\n                                                       ^\n/tmp/tmpn2opjzdx.swift:24:74:\
    \ error: cannot convert value of type 'Double.Type' to expected argument type\
    \ 'Double'\n        case .doubleValue(n): return b == .doubleValue(n) ? .doubleValue(Double)\
    \ : nil\n                                                                    \
    \     ^\n/tmp/tmpn2opjzdx.swift:25:56: error: cannot find 'n' in scope\n     \
    \   case .stringValue(n): return b == .stringValue(n) ? .stringValue(String) :\
    \ nil\n                                                       ^\n/tmp/tmpn2opjzdx.swift:25:74:\
    \ error: cannot convert value of type 'String.Type' to expected argument type\
    \ 'String'\n        case .stringValue(n): return b == .stringValue(n) ? .stringValue(String)\
    \ : nil\n                                                                    \
    \     ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let bInt = b.intValue {\n        if let\
    \ aInt = a.intValue {\n            if aInt > bInt {\n                return a\n\
    \            }\n            if aInt == bInt {\n                return nil\n  \
    \          }\n        }\n    }\n    \n    if let bDouble = b.doubleValue {\n \
    \       if let aDouble = a.doubleValue {\n            if aDouble > bDouble {\n\
    \                return a\n            }\n            if aDouble == bDouble {\n\
    \                return nil\n            }\n        }\n    }\n    \n    if let\
    \ bString = b.stringValue {\n        if let aString = a.stringValue {\n      \
    \      if aString > bString {\n                return a\n            }\n     \
    \       if aString == bString {\n                return nil\n            }\n \
    \       }\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdj2wxktg.swift:22:19: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if let bInt = b.intValue {\n                  ^\n\
    \                  Value\n/tmp/tmpdj2wxktg.swift:23:23: error: enum case 'intValue'\
    \ cannot be used as an instance member\n        if let aInt = a.intValue {\n \
    \                     ^\n                      Value\n/tmp/tmpdj2wxktg.swift:33:22:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ let bDouble = b.doubleValue {\n                     ^\n                    \
    \ Value\n/tmp/tmpdj2wxktg.swift:34:26: error: enum case 'doubleValue' cannot be\
    \ used as an instance member\n        if let aDouble = a.doubleValue {\n     \
    \                    ^\n                         Value\n/tmp/tmpdj2wxktg.swift:44:22:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n    if\
    \ let bString = b.stringValue {\n                     ^\n                    \
    \ Value\n/tmp/tmpdj2wxktg.swift:45:26: error: enum case 'stringValue' cannot be\
    \ used as an instance member\n        if let aString = a.stringValue {\n     \
    \                    ^\n                         Value\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var larger: Value?\n    var smaller: Value?\n\
    \    \n    switch a {\n    case .intValue(_):\n        switch b {\n        case\
    \ .intValue(_):\n            return nil\n        case .doubleValue(_):\n     \
    \       smaller = a\n        case .stringValue(_):\n            smaller = a\n\
    \        }\n    case .doubleValue(_):\n        switch b {\n        case .intValue(_):\n\
    \            smaller = a\n        case .doubleValue(_):\n            larger =\
    \ a\n        case .stringValue(_):\n            smaller = a\n        }\n    case\
    \ .stringValue(_):\n        switch b {\n        case .intValue(_):\n         \
    \   smaller = a\n        case .doubleValue(_):\n            larger = a\n     \
    \   case .stringValue(_):\n            larger = a\n        }\n    }\n    \n  \
    \  switch b {\n    case .intValue(_):\n        switch a {\n        case .intValue(_):\n\
    \            return nil\n        case .doubleValue(_):\n            smaller =\
    \ b\n        case .stringValue(_):\n            smaller = b\n        }\n    case\
    \ .doubleValue(_):\n        switch a {\n        case .intValue(_):\n         \
    \   smaller = b\n        case .doubleValue(_):\n            larger = b\n     \
    \   case .stringValue(_):\n            smaller = b\n        }\n    case .stringValue(_):\n\
    \        switch a {\n        case .intValue(_):\n            smaller = b\n   \
    \     case .doubleValue(_):\n            larger = b\n        case .stringValue(_):\n\
    \            larger = b\n        }\n    }\n    \n    if smaller != nil && larger\
    \ != nil {\n        switch smaller {\n        case .intValue(_):\n           \
    \ return larger\n        case .doubleValue(_):\n            return larger\n  \
    \      case .stringValue(_):\n            return larger\n        }\n    }\n  \
    \  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpg1rhl0t9.swift:86:9: error: switch must be exhaustive\n       \
    \ switch smaller {\n        ^\n/tmp/tmpg1rhl0t9.swift:86:9: note: add missing\
    \ case: '.none'\n        switch smaller {\n        ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(aval), .doubleValue(aval),\
    \ .stringValue(aval) where aval == b }\n    case .intValue(aval), .doubleValue(aval),\
    \ .stringValue(aval),\n         .intValue(bval), .doubleValue(bval), .stringValue(bval)\n\
    \         where aval == b\n    {\n        return b\n    }\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyrdrp_az.swift:22:93: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(aval), .doubleValue(aval), .stringValue(aval) where aval\
    \ == b }\n                                                                   \
    \                         ^\n/tmp/tmpyrdrp_az.swift:23:5: error: 'case' label\
    \ can only appear inside a 'switch' statement\n    case .intValue(aval), .doubleValue(aval),\
    \ .stringValue(aval),\n    ^\n/tmp/tmpyrdrp_az.swift:22:31: error: cannot find\
    \ 'aval' in scope\n    switch a { case .intValue(aval), .doubleValue(aval), .stringValue(aval)\
    \ where aval == b }\n                              ^~~~\n/tmp/tmpyrdrp_az.swift:22:51:\
    \ error: cannot find 'aval' in scope\n    switch a { case .intValue(aval), .doubleValue(aval),\
    \ .stringValue(aval) where aval == b }\n                                     \
    \             ^~~~\n/tmp/tmpyrdrp_az.swift:22:71: error: cannot find 'aval' in\
    \ scope\n    switch a { case .intValue(aval), .doubleValue(aval), .stringValue(aval)\
    \ where aval == b }\n                                                        \
    \              ^~~~\n/tmp/tmpyrdrp_az.swift:22:83: error: cannot find 'aval' in\
    \ scope\n    switch a { case .intValue(aval), .doubleValue(aval), .stringValue(aval)\
    \ where aval == b }\n                                                        \
    \                          ^~~~\n/tmp/tmpyrdrp_az.swift:22:77: warning: 'where'\
    \ only applies to the second pattern match in this case\n    switch a { case .intValue(aval),\
    \ .doubleValue(aval), .stringValue(aval) where aval == b }\n                 \
    \                                        ~~~~~~~~~~~~~~~~~~ ^     ~~~~~~~~~\n\
    /tmp/tmpyrdrp_az.swift:22:58: note: disambiguate by adding a line break between\
    \ them if this is desired\n    switch a { case .intValue(aval), .doubleValue(aval),\
    \ .stringValue(aval) where aval == b }\n                                     \
    \                    ^\n/tmp/tmpyrdrp_az.swift:22:38: note: duplicate the 'where'\
    \ on both patterns to check both patterns\n    switch a { case .intValue(aval),\
    \ .doubleValue(aval), .stringValue(aval) where aval == b }\n        "
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as? Int, b as? Int, a as? Double,\
    \ b as? Double {\n    case (_, let b, _), (_, _, let a), (_, _, _, _), let a =\
    \ a, let b = b:\n        return a > b ? a : b\n    case let a = a as? String,\
    \ let b = b as? String:\n        return a > b ? a : b\n    case (_, let b, _),\
    \ (_, _, let a):\n        return a < b ? a : b\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpatus6tfk.swift:22:21: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as? Int, b as? Int, a as? Double, b as? Double {\n\
    \                    ^\n/tmp/tmpatus6tfk.swift:22:21: error: consecutive statements\
    \ on a line must be separated by ';'\n    switch a as? Int, b as? Int, a as? Double,\
    \ b as? Double {\n                    ^\n                    ;\n/tmp/tmpatus6tfk.swift:22:21:\
    \ error: expected expression\n    switch a as? Int, b as? Int, a as? Double, b\
    \ as? Double {\n                    ^\n/tmp/tmpatus6tfk.swift:22:14: warning:\
    \ cast from 'Value' to unrelated type 'Int' always fails\n    switch a as? Int,\
    \ b as? Int, a as? Double, b as? Double {\n           ~ ^   ~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var lv = a\n    var rv = b\n    if a.hashValue\
    \ < b.hashValue {\n        lv = b\n        rv = a\n    }\n    if lv.hashValue\
    \ == rv.hashValue {\n        if lv.intValue < rv.intValue {\n            return\
    \ lv\n        } else {\n            return rv\n        }\n    } else {\n     \
    \   if lv.doubleValue < rv.doubleValue {\n            return lv\n        } else\
    \ {\n            return rv\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0w1g_g99.swift:29:24: error: binary operator '<' cannot be applied\
    \ to two '(Int) -> Value' operands\n        if lv.intValue < rv.intValue {\n \
    \          ~~~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmp0w1g_g99.swift:35:27: error: binary\
    \ operator '<' cannot be applied to two '(Double) -> Value' operands\n       \
    \ if lv.doubleValue < rv.doubleValue {\n           ~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b))\
    \ if b > a => .intValue(b)\n    case (.doubleValue(a), .doubleValue(b)) if b >\
    \ a => .doubleValue(b)\n    case (.stringValue(a), .stringValue(b)) if b > a =>\
    \ .stringValue(b)\n    case (.stringValue(a), .stringValue(b)) if b > a => .stringValue(b)\n\
    \    default: return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpne4_bfj6.swift:23:39: error: expected ':' after 'case'\n    case\
    \ (.intValue(a), .intValue(b)) if b > a => .intValue(b)\n                    \
    \                  ^\n/tmp/tmpne4_bfj6.swift:23:63: error: expected '{' after\
    \ 'if' condition\n    case (.intValue(a), .intValue(b)) if b > a => .intValue(b)\n\
    \                                                              ^\n/tmp/tmpne4_bfj6.swift:24:45:\
    \ error: expected ':' after 'case'\n    case (.doubleValue(a), .doubleValue(b))\
    \ if b > a => .doubleValue(b)\n                                            ^\n\
    /tmp/tmpne4_bfj6.swift:24:72: error: expected '{' after 'if' condition\n    case\
    \ (.doubleValue(a), .doubleValue(b)) if b > a => .doubleValue(b)\n           \
    \                                                            ^\n/tmp/tmpne4_bfj6.swift:25:45:\
    \ error: expected ':' after 'case'\n    case (.stringValue(a), .stringValue(b))\
    \ if b > a => .stringValue(b)\n                                            ^\n\
    /tmp/tmpne4_bfj6.swift:25:72: error: expected '{' after 'if' condition\n    case\
    \ (.stringValue(a), .stringValue(b)) if b > a => .stringValue(b)\n           \
    \                                                            ^\n/tmp/tmpne4_bfj6.swift:26:45:\
    \ error: expected ':' after 'case'\n    case (.stringValue(a), .stringValue(b))\
    \ if b > a => .stringValue(b)\n                                            ^\n\
    /tmp/tmpne4_bfj6.swift:26:72: error: expected '{' after 'if' condition\n    case\
    \ (.stringValue(a), .stringValue(b)) if b > a => .stringValue(b)\n           \
    \                                                            ^\n/tmp/tmpne4_bfj6.swift:23:21:\
    \ error: expression pattern of type 'Value' cannot match values of type 'Int'\n\
    \    case (.intValue(a), .intValue(b)) if b > a => .intValue(b)\n            \
    \        ^\n/tmp/tmpne4_bfj6.swift:24:24: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Double'\n    case (.doubleValue(a), .doubleValue(b))\
    \ if b > a => .doubleValue(b)\n                       ^\n/tmp/tmpne4_bfj6.swift:25:24:\
    \ error: expression pattern of type 'Value' cannot match values of t"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch b {\n    case .stringValue:\n     \
    \   if a.stringValue < b.stringValue {\n            return a\n        } else {\n\
    \            return b\n        }\n    case .intValue:\n        if a.intValue <\
    \ b.intValue {\n            return a\n        } else {\n            return b\n\
    \        }\n    case .doubleValue:\n        if a.doubleValue < b.doubleValue {\n\
    \            return a\n        } else {\n            return b\n        }\n   \
    \ }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_gf6emk6.swift:24:26: error: binary operator '<' cannot be applied\
    \ to two '(String) -> Value' operands\n        if a.stringValue < b.stringValue\
    \ {\n           ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmp_gf6emk6.swift:30:23: error:\
    \ binary operator '<' cannot be applied to two '(Int) -> Value' operands\n   \
    \     if a.intValue < b.intValue {\n           ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmp_gf6emk6.swift:36:26:\
    \ error: binary operator '<' cannot be applied to two '(Double) -> Value' operands\n\
    \        if a.doubleValue < b.doubleValue {\n           ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(x): return\
    \ b == .intValue(x) ? a : nil\n    case .doubleValue(x): return b == .doubleValue(x)\
    \ ? a : nil\n    case .stringValue(x): return b == .stringValue(x) ? a : nil\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5763ngxl.swift:23:20: error: cannot find 'x' in scope\n    case\
    \ .intValue(x): return b == .intValue(x) ? a : nil\n                   ^\n/tmp/tmp5763ngxl.swift:24:23:\
    \ error: cannot find 'x' in scope\n    case .doubleValue(x): return b == .doubleValue(x)\
    \ ? a : nil\n                      ^\n/tmp/tmp5763ngxl.swift:25:23: error: cannot\
    \ find 'x' in scope\n    case .stringValue(x): return b == .stringValue(x) ? a\
    \ : nil\n                      ^\n/tmp/tmp5763ngxl.swift:23:46: error: cannot\
    \ find 'x' in scope\n    case .intValue(x): return b == .intValue(x) ? a : nil\n\
    \                                             ^\n/tmp/tmp5763ngxl.swift:24:52:\
    \ error: cannot find 'x' in scope\n    case .doubleValue(x): return b == .doubleValue(x)\
    \ ? a : nil\n                                                   ^\n/tmp/tmp5763ngxl.swift:25:52:\
    \ error: cannot find 'x' in scope\n    case .stringValue(x): return b == .stringValue(x)\
    \ ? a : nil\n                                                   ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b))\
    \ as (Value, Value):\n        return b\n    case (.intValue(a), .doubleValue(b))\
    \ as (Value, Value):\n        return a\n    case (.doubleValue(a), .doubleValue(b))\
    \ as (Value, Value):\n        return a\n    case (.stringValue(a), .stringValue(b))\
    \ as (Value, Value):\n        return b\n    case (.stringValue(a), .doubleValue(b))\
    \ as (Value, Value):\n        return a\n    case (.doubleValue(a), .intValue(b))\
    \ as (Value, Value):\n        return nil\n    default:\n        return nil\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpscrlbzo9.swift:23:39: warning: 'as' test is always true\n    case\
    \ (.intValue(a), .intValue(b)) as (Value, Value):\n                          \
    \            ^\n/tmp/tmpscrlbzo9.swift:23:21: error: expression pattern of type\
    \ 'Value' cannot match values of type 'Int'\n    case (.intValue(a), .intValue(b))\
    \ as (Value, Value):\n                    ^\n/tmp/tmpscrlbzo9.swift:25:42: warning:\
    \ 'as' test is always true\n    case (.intValue(a), .doubleValue(b)) as (Value,\
    \ Value):\n                                         ^\n/tmp/tmpscrlbzo9.swift:25:21:\
    \ error: expression pattern of type 'Value' cannot match values of type 'Int'\n\
    \    case (.intValue(a), .doubleValue(b)) as (Value, Value):\n               \
    \     ^\n/tmp/tmpscrlbzo9.swift:27:45: warning: 'as' test is always true\n   \
    \ case (.doubleValue(a), .doubleValue(b)) as (Value, Value):\n               \
    \                             ^\n/tmp/tmpscrlbzo9.swift:27:24: error: expression\
    \ pattern of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .doubleValue(b)) as (Value, Value):\n                       ^\n/tmp/tmpscrlbzo9.swift:29:45:\
    \ warning: 'as' test is always true\n    case (.stringValue(a), .stringValue(b))\
    \ as (Value, Value):\n                                            ^\n/tmp/tmpscrlbzo9.swift:29:24:\
    \ error: expression pattern of type 'Value' cannot match values of type 'String'\n\
    \    case (.stringValue(a), .stringValue(b)) as (Value, Value):\n            \
    \           ^\n/tmp/tmpscrlbzo9.swift:29:24: note: overloads for '~=' exist with\
    \ these partially matching parameter lists: (Substring, String)\n    case (.stringValue(a),\
    \ .stringValue(b)) as (Value, Value):\n                       ^\n/tmp/tmpscrlbzo9.swift:31:45:\
    \ warning: 'as' test is always true\n    case (.stringValue(a), .doubleValue(b))\
    \ as (Value, Value):\n                                            ^\n/tmp/tmpscrlbzo9.swift:31:24:\
    \ error: expression pattern of type 'Value' cannot match values of type 'String'\n\
    \    case (.stringValue(a), .doubleValue(b)) as (Value, Value):\n            \
    \           ^\n/tmp/tmpscrlbzo9.swif"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(nil), .doubleValue(nil),\
    \ .stringValue(nil):\n        return nil\n    case .intValue(value):\n       \
    \ return .intValue(b)\n    case .doubleValue(value):\n        return .doubleValue(b)\n\
    \    case .stringValue(value):\n        return .stringValue(b)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4aezru0p.swift:23:20: warning: type 'Int' is not optional, value\
    \ can never be nil; this is an error in Swift 6\n    case .intValue(nil), .doubleValue(nil),\
    \ .stringValue(nil):\n                   ^\n/tmp/tmp4aezru0p.swift:23:39: warning:\
    \ type 'Double' is not optional, value can never be nil; this is an error in Swift\
    \ 6\n    case .intValue(nil), .doubleValue(nil), .stringValue(nil):\n        \
    \                              ^\n/tmp/tmp4aezru0p.swift:23:58: warning: type\
    \ 'String' is not optional, value can never be nil; this is an error in Swift\
    \ 6\n    case .intValue(nil), .doubleValue(nil), .stringValue(nil):\n        \
    \                                                 ^\n/tmp/tmp4aezru0p.swift:25:20:\
    \ error: cannot find 'value' in scope\n    case .intValue(value):\n          \
    \         ^~~~~\n/tmp/tmp4aezru0p.swift:27:23: error: cannot find 'value' in scope\n\
    \    case .doubleValue(value):\n                      ^~~~~\n/tmp/tmp4aezru0p.swift:29:23:\
    \ error: cannot find 'value' in scope\n    case .stringValue(value):\n       \
    \               ^~~~~\n/tmp/tmp4aezru0p.swift:26:26: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n        return .intValue(b)\n\
    \                         ^\n/tmp/tmp4aezru0p.swift:28:29: error: cannot convert\
    \ value of type 'Value' to expected argument type 'Double'\n        return .doubleValue(b)\n\
    \                            ^\n/tmp/tmp4aezru0p.swift:30:29: error: cannot convert\
    \ value of type 'Value' to expected argument type 'String'\n        return .stringValue(b)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return b\n        }\n    case .doubleValue(_):\n        switch b {\n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b {\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return b\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpnn74ox97/tmpnn74ox97.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b659d4a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b659d1a0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b659d1a0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b659d19f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnn74ox97                        0x00005558d239fa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b659d695460 __libc_start_main +
    245

    6    tmpnn74ox97                        0x00005558d239f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_): return b ==\
    \ .intValue(a)\n    case .doubleValue(_): return b == .doubleValue(a)\n    case\
    \ .stringValue(_): return b == .stringValue(a)\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpti5qlunj.swift:22:44: error: cannot convert return expression of\
    \ type 'Bool' to return type 'Value?'\n    switch a { case .intValue(_): return\
    \ b == .intValue(a)\n                                         ~~^~~~~~~~~~~~~~~\n\
    /tmp/tmpti5qlunj.swift:22:57: error: cannot convert value of type 'Value' to expected\
    \ argument type 'Int'\n    switch a { case .intValue(_): return b == .intValue(a)\n\
    \                                                        ^\n/tmp/tmpti5qlunj.swift:23:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .doubleValue(_): return b == .doubleValue(a)\n                     \
    \            ~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpti5qlunj.swift:23:52: error: cannot\
    \ convert value of type 'Value' to expected argument type 'Double'\n    case .doubleValue(_):\
    \ return b == .doubleValue(a)\n                                              \
    \     ^\n/tmp/tmpti5qlunj.swift:24:36: error: cannot convert return expression\
    \ of type 'Bool' to return type 'Value?'\n    case .stringValue(_): return b ==\
    \ .stringValue(a)\n                                 ~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpti5qlunj.swift:24:52:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \    case .stringValue(_): return b == .stringValue(a)\n                     \
    \                              ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(b):\n     \
    \   if let b = b, b.isKind(of: Int) { return b }\n    case .doubleValue(b):\n\
    \        if let b = b, b.isKind(of: Double) { return b }\n    case .stringValue(b):\n\
    \        if let b = b, b.isKind(of: String) {\n            if b == \"?\" { return\
    \ b }\n            do {\n                let doubleb = Double(b)\n           \
    \     return b\n            }\n            catch let err {\n                return\
    \ nil\n            }\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpahxk1m5n.swift:23:20: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case .intValue(b):\n                \
    \   ^\n/tmp/tmpahxk1m5n.swift:25:23: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Double'\n    case .doubleValue(b):\n          \
    \            ^\n/tmp/tmpahxk1m5n.swift:27:23: error: expression pattern of type\
    \ 'Value' cannot match values of type 'String'\n    case .stringValue(b):\n  \
    \                    ^\n/tmp/tmpahxk1m5n.swift:27:23: note: overloads for '~='\
    \ exist with these partially matching parameter lists: (Substring, String)\n \
    \   case .stringValue(b):\n                      ^\n/tmp/tmpahxk1m5n.swift:24:25:\
    \ error: value of type 'Value' has no member 'isKind'\n        if let b = b, b.isKind(of:\
    \ Int) { return b }\n                      ~ ^~~~~~\n/tmp/tmpahxk1m5n.swift:24:12:\
    \ error: initializer for conditional binding must have Optional type, not 'Value'\n\
    \        if let b = b, b.isKind(of: Int) { return b }\n           ^       ~\n\
    /tmp/tmpahxk1m5n.swift:26:25: error: value of type 'Value' has no member 'isKind'\n\
    \        if let b = b, b.isKind(of: Double) { return b }\n                   \
    \   ~ ^~~~~~\n/tmp/tmpahxk1m5n.swift:26:12: error: initializer for conditional\
    \ binding must have Optional type, not 'Value'\n        if let b = b, b.isKind(of:\
    \ Double) { return b }\n           ^       ~\n/tmp/tmpahxk1m5n.swift:28:25: error:\
    \ value of type 'Value' has no member 'isKind'\n        if let b = b, b.isKind(of:\
    \ String) {\n                      ~ ^~~~~~\n/tmp/tmpahxk1m5n.swift:29:18: error:\
    \ referencing operator function '==' on 'StringProtocol' requires that 'Value'\
    \ conform to 'StringProtocol'\n            if b == \"?\" { return b }\n      \
    \           ^\nSwift.StringProtocol:1:11: note: where 'Self' = 'Value'\nextension\
    \ StringProtocol {\n          ^\n/tmp/tmpahxk1m5n.swift:31:31: error: no exact\
    \ matches in call to initializer \n                let doubleb = Double(b)\n \
    \                             ^\nSwift.Double:2:23: note: candidate requires that\
    \ 'Value' conform to 'StringProtocol' (requireme"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let intVal = a.intValue, let doubleVal\
    \ = b.doubleValue {\n        switch intVal {\n        case .intValue(intVal):\
    \ return intVal > doubleVal ? .intValue(Int8(intVal)) : .doubleValue(Double(doubleVal))\n\
    \        case .doubleValue(doubleVal): return intVal > doubleVal ? .intValue(Int8(intVal))\
    \ : .doubleValue(Double(doubleVal))\n        default:\n            return .stringValue(String(intVal.description))\n\
    \        }\n    } else if let stringVal = a.stringValue, let stringVal2 = b.stringValue\
    \ {\n        return .stringValue(String(stringVal.description)) > .stringValue(String(stringVal2.description))\
    \ ? .stringValue(String(stringVal2.description)) : .stringValue(String(stringVal.description))\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpt7hkcqbk.swift:22:21: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if let intVal = a.intValue, let doubleVal = b.doubleValue\
    \ {\n                    ^\n                    Value\n/tmp/tmpt7hkcqbk.swift:22:49:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ let intVal = a.intValue, let doubleVal = b.doubleValue {\n                 \
    \                               ^\n                                          \
    \      Value\n/tmp/tmpt7hkcqbk.swift:29:31: error: enum case 'stringValue' cannot\
    \ be used as an instance member\n    } else if let stringVal = a.stringValue,\
    \ let stringVal2 = b.stringValue {\n                              ^\n        \
    \                      Value\n/tmp/tmpt7hkcqbk.swift:29:63: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n    } else if let stringVal = a.stringValue,\
    \ let stringVal2 = b.stringValue {\n                                         \
    \                     ^\n                                                    \
    \          Value\n/tmp/tmpt7hkcqbk.swift:30:17: error: reference to member 'stringValue'\
    \ cannot be resolved without a contextual type\n        return .stringValue(String(stringVal.description))\
    \ > .stringValue(String(stringVal2.description)) ? .stringValue(String(stringVal2.description))\
    \ : .stringValue(String(stringVal.description))\n                ^\n/tmp/tmpt7hkcqbk.swift:30:63:\
    \ error: reference to member 'stringValue' cannot be resolved without a contextual\
    \ type\n        return .stringValue(String(stringVal.description)) > .stringValue(String(stringVal2.description))\
    \ ? .stringValue(String(stringVal2.description)) : .stringValue(String(stringVal.description))\n\
    \                                                              ^\n"
  stdout: ''
  timestamp: 1660013431
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return nil\n        }\n    case .doubleValue(_):\n        switch b {\n\
    \        case .intValue(_):\n            return b\n        case .doubleValue(_):\n\
    \            return a\n        case .stringValue(_):\n            return nil\n\
    \        }\n    case .stringValue(_):\n        switch b {\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return nil\n\
    \        case .stringValue(_):\n            return a\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpzwcxsrh7/tmpzwcxsrh7.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac23b70cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac23b403b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac23b403988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac23b4027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzwcxsrh7                        0x00005619312cfa56 <unavailable> + 6742

    5    libc.so.6                          0x00002ac23b8f8460 __libc_start_main +
    245

    6    tmpzwcxsrh7                        0x00005619312cf499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .doubleValue(_):\n            if a.doubleValue()\
    \ < b.doubleValue() {\n                return a\n            } else if a.doubleValue()\
    \ == b.doubleValue() {\n                return a\n            }\n        case\
    \ .stringValue(_):\n            if a.stringValue() < b.stringValue() {\n     \
    \           return a\n            } else if a.stringValue() == b.stringValue()\
    \ {\n                return a\n            }\n        }\n    case .doubleValue(_):\n\
    \        switch b {\n        case .intValue(_):\n            if a.doubleValue()\
    \ < b.intValue() {\n                return a\n            } else if a.doubleValue()\
    \ == b.doubleValue() {\n                return a\n            }\n        case\
    \ .stringValue(_):\n            if a.stringValue() < b.stringValue() {\n     \
    \           return a\n            } else if a.stringValue() == b.stringValue()\
    \ {\n                return a\n            }\n        }\n    case .stringValue(_):\n\
    \        switch b {\n        case .intValue(_):\n            if a.stringValue()\
    \ < b.intValue() {\n                return a\n            } else if a.stringValue()\
    \ == b.stringValue() {\n                return a\n            }\n        case\
    \ .doubleValue(_):\n            if a.stringValue() < b.doubleValue() {\n     \
    \           return a\n            } else if a.stringValue() == b.stringValue()\
    \ {\n                return a\n            }\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp6wvrrgex.swift:26:30: error: missing argument for parameter #1\
    \ in call\n            if a.doubleValue() < b.doubleValue() {\n              \
    \               ^\n                             <#Double#>\n/tmp/tmp6wvrrgex.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmp6wvrrgex.swift:26:16: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n            if a.doubleValue() < b.doubleValue() {\n   \
    \            ^\n               Value\n/tmp/tmp6wvrrgex.swift:26:32: error: referencing\
    \ operator function '<' on 'Comparable' requires that 'Value' conform to 'Comparable'\n\
    \            if a.doubleValue() < b.doubleValue() {\n                        \
    \       ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic protocol\
    \ Comparable : Equatable {\n                ^\n/tmp/tmp6wvrrgex.swift:26:32: note:\
    \ binary operator '<' cannot be synthesized for enums with associated values\n\
    \            if a.doubleValue() < b.doubleValue() {\n                        \
    \       ^\n/tmp/tmp6wvrrgex.swift:26:34: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n            if a.doubleValue() < b.doubleValue()\
    \ {\n                                 ^\n                                 Value\n\
    /tmp/tmp6wvrrgex.swift:26:48: error: missing argument for parameter #1 in call\n\
    \            if a.doubleValue() < b.doubleValue() {\n                        \
    \                       ^\n                                               <#Double#>\n\
    /tmp/tmp6wvrrgex.swift:4:10: note: 'doubleValue' declared here\n    case doubleValue(Double)\n\
    \         ^\n/tmp/tmp6wvrrgex.swift:28:23: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n            } else if a.doubleValue() == b.doubleValue()\
    \ {\n                      ^\n                      Value\n/tmp/tmp6wvrrgex.swift:28:37:\
    \ error: missing argument for parameter #1 in call\n            } else if a.doubleValue()\
    \ == b.doubleValue() {\n                                    ^\n              \
    \                      <#Double#>\n/tmp/tmp6wvrrgex.swift:4:10: note: 'dou"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (intValue(a), intValue(b)):\n\
    \        return a\n    case (doubleValue(a), doubleValue(b)):\n        return\
    \ a\n    case (stringValue(a), stringValue(b)):\n        return a\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwzcigptz.swift:23:11: error: cannot find 'intValue' in scope\n\
    \    case (intValue(a), intValue(b)):\n          ^~~~~~~~\n/tmp/tmpwzcigptz.swift:25:11:\
    \ error: cannot find 'doubleValue' in scope\n    case (doubleValue(a), doubleValue(b)):\n\
    \          ^~~~~~~~~~~\n/tmp/tmpwzcigptz.swift:27:11: error: cannot find 'stringValue'\
    \ in scope\n    case (stringValue(a), stringValue(b)):\n          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(x), .intValue(y))\
    \ if x > y else {\n        return .intValue(x)\n    }\n    case (.doubleValue(x),\
    \ .doubleValue(y)) if x > y else {\n        return .doubleValue(x)\n    }\n  \
    \  case (.stringValue(x), .stringValue(y)) if x > y else {\n        return .stringValue(x)\n\
    \    }\n    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpits63ean.swift:23:39: error: expected ':' after 'case'\n    case\
    \ (.intValue(x), .intValue(y)) if x > y else {\n                             \
    \         ^\n/tmp/tmpits63ean.swift:23:48: error: unexpected 'else' immediately\
    \ following 'if' condition\n    case (.intValue(x), .intValue(y)) if x > y else\
    \ {\n                                               ^\n/tmp/tmpits63ean.swift:23:48:\
    \ note: remove 'else' to execute the braced block of statements when the condition\
    \ is true\n    case (.intValue(x), .intValue(y)) if x > y else {\n           \
    \                                    ^~~~~\n                                 \
    \              \n/tmp/tmpits63ean.swift:26:45: error: expected ':' after 'case'\n\
    \    case (.doubleValue(x), .doubleValue(y)) if x > y else {\n               \
    \                             ^\n/tmp/tmpits63ean.swift:26:54: error: unexpected\
    \ 'else' immediately following 'if' condition\n    case (.doubleValue(x), .doubleValue(y))\
    \ if x > y else {\n                                                     ^\n/tmp/tmpits63ean.swift:26:54:\
    \ note: remove 'else' to execute the braced block of statements when the condition\
    \ is true\n    case (.doubleValue(x), .doubleValue(y)) if x > y else {\n     \
    \                                                ^~~~~\n                     \
    \                                \n/tmp/tmpits63ean.swift:29:45: error: expected\
    \ ':' after 'case'\n    case (.stringValue(x), .stringValue(y)) if x > y else\
    \ {\n                                            ^\n/tmp/tmpits63ean.swift:29:54:\
    \ error: unexpected 'else' immediately following 'if' condition\n    case (.stringValue(x),\
    \ .stringValue(y)) if x > y else {\n                                         \
    \            ^\n/tmp/tmpits63ean.swift:29:54: note: remove 'else' to execute the\
    \ braced block of statements when the condition is true\n    case (.stringValue(x),\
    \ .stringValue(y)) if x > y else {\n                                         \
    \            ^~~~~\n                                                     \n/tmp/tmpits63ean.swift:23:21:\
    \ error: cannot find 'x' in scope\n    case (.intValue(x), "
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(aInt):\n  \
    \      switch b {\n        case .doubleValue(bDouble):\n            if aInt ==\
    \ bDouble {\n                return nil\n            } else {\n              \
    \  return .doubleValue(bDouble)\n            }\n        case .stringValue(bString):\n\
    \            if aInt < bInt {\n                return .intValue(aInt)\n      \
    \      } else {\n                return .stringValue(bString)\n            }\n\
    \        }\n    case .doubleValue(aDouble):\n        switch b {\n        case\
    \ .intValue(bInt):\n            if aDouble == bInt {\n                return nil\n\
    \            } else {\n                return .doubleValue(bDouble)\n        \
    \    }\n        case .stringValue(bString):\n            if aDouble < bDouble\
    \ {\n                return .doubleValue(aDouble)\n            } else {\n    \
    \            return .stringValue(bString)\n            }\n        }\n    case\
    \ .stringValue(aString):\n        switch b {\n        case .intValue(bInt):\n\
    \            if aString == bInt {\n                return nil\n            } else\
    \ {\n                return .stringValue(bString)\n            }\n        case\
    \ .doubleValue(bDouble):\n            if aString < bString {\n               \
    \ return .stringValue(aString)\n            } else {\n                return .doubleValue(bDouble)\n\
    \            }\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnl3o6o4l.swift:23:20: error: cannot find 'aInt' in scope\n    case\
    \ .intValue(aInt):\n                   ^~~~\n/tmp/tmpnl3o6o4l.swift:38:23: error:\
    \ cannot find 'aDouble' in scope\n    case .doubleValue(aDouble):\n          \
    \            ^~~~~~~\n/tmp/tmpnl3o6o4l.swift:53:23: error: cannot find 'aString'\
    \ in scope\n    case .stringValue(aString):\n                      ^~~~~~~\n/tmp/tmpnl3o6o4l.swift:25:27:\
    \ error: cannot find 'bDouble' in scope\n        case .doubleValue(bDouble):\n\
    \                          ^~~~~~~\n/tmp/tmpnl3o6o4l.swift:31:27: error: cannot\
    \ find 'bString' in scope\n        case .stringValue(bString):\n             \
    \             ^~~~~~~\n/tmp/tmpnl3o6o4l.swift:26:16: error: cannot find 'aInt'\
    \ in scope\n            if aInt == bDouble {\n               ^~~~\n/tmp/tmpnl3o6o4l.swift:26:24:\
    \ error: cannot find 'bDouble' in scope\n            if aInt == bDouble {\n  \
    \                     ^~~~~~~\n/tmp/tmpnl3o6o4l.swift:29:37: error: cannot find\
    \ 'bDouble' in scope\n                return .doubleValue(bDouble)\n         \
    \                           ^~~~~~~\n/tmp/tmpnl3o6o4l.swift:32:16: error: cannot\
    \ find 'aInt' in scope\n            if aInt < bInt {\n               ^~~~\n/tmp/tmpnl3o6o4l.swift:32:23:\
    \ error: cannot find 'bInt' in scope\n            if aInt < bInt {\n         \
    \             ^~~~\n/tmp/tmpnl3o6o4l.swift:33:34: error: cannot find 'aInt' in\
    \ scope\n                return .intValue(aInt)\n                            \
    \     ^~~~\n/tmp/tmpnl3o6o4l.swift:35:37: error: cannot find 'bString' in scope\n\
    \                return .stringValue(bString)\n                              \
    \      ^~~~~~~\n/tmp/tmpnl3o6o4l.swift:40:24: error: cannot find 'bInt' in scope\n\
    \        case .intValue(bInt):\n                       ^~~~\n/tmp/tmpnl3o6o4l.swift:46:27:\
    \ error: cannot find 'bString' in scope\n        case .stringValue(bString):\n\
    \                          ^~~~~~~\n/tmp/tmpnl3o6o4l.swift:41:16: error: cannot\
    \ find 'aDouble' in scope\n            if aDouble == bInt {\n               ^~~~~~~\n\
    /tmp/tmpnl3o6o4l.swift:41:27: error: cannot find 'bInt' in scope\n      "
  stdout: ''
  timestamp: 1660013423
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var v = a\n    switch b {\n    case .intValue(let\
    \ bInt):\n        if v == .intValue(bInt) {\n            return nil\n        }\n\
    \    case .doubleValue(let bDouble):\n        if v == .doubleValue(bDouble) {\n\
    \            return nil\n        }\n    case .stringValue(let bString):\n    \
    \    if v == .stringValue(bString) {\n            return nil\n        }\n    }\n\
    \    return v\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp4b6_9clh/tmp4b6_9clh.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad82624fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad825f46b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad825f46988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad825f457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4b6_9clh                        0x000055e535ae6a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ad82643b460 __libc_start_main +
    245

    6    tmp4b6_9clh                        0x000055e535ae6499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(nil, b):\n\
    \        return b\n    case .doubleValue(a, nil):\n        return a\n    case\
    \ .stringValue(a, b, nil):\n        return b\n    case .stringValue(nil, a, nil):\n\
    \        return a\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe9yigca8.swift:23:19: error: tuple pattern cannot match values\
    \ of the non-tuple type 'Int'\n    case .intValue(nil, b):\n                 \
    \ ^\n/tmp/tmpe9yigca8.swift:23:20: warning: type '<<error type>>' is not optional,\
    \ value can never be nil; this is an error in Swift 6\n    case .intValue(nil,\
    \ b):\n                   ^\n/tmp/tmpe9yigca8.swift:25:22: error: tuple pattern\
    \ cannot match values of the non-tuple type 'Double'\n    case .doubleValue(a,\
    \ nil):\n                     ^\n/tmp/tmpe9yigca8.swift:27:22: error: tuple pattern\
    \ cannot match values of the non-tuple type 'String'\n    case .stringValue(a,\
    \ b, nil):\n                     ^\n/tmp/tmpe9yigca8.swift:29:22: error: tuple\
    \ pattern cannot match values of the non-tuple type 'String'\n    case .stringValue(nil,\
    \ a, nil):\n                     ^\n/tmp/tmpe9yigca8.swift:29:23: warning: type\
    \ '<<error type>>' is not optional, value can never be nil; this is an error in\
    \ Swift 6\n    case .stringValue(nil, a, nil):\n                      ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var a = a\n    var b = b\n    if let aInt\
    \ = a.intValue() {\n        if let bInt = b.intValue() {\n            return aInt\
    \ > bInt ? .intValue(aInt) : .intValue(bInt)\n        }\n        \n    }\n   \
    \ if let aDouble = a.doubleValue() {\n        if let bDouble = b.doubleValue()\
    \ {\n            return aDouble > bDouble ? .doubleValue(aDouble) : .doubleValue(bDouble)\n\
    \        }\n        \n    }\n    if let aString = a.stringValue() {\n        if\
    \ let bString = b.stringValue() {\n            return aString > bString ? .stringValue(aString)\
    \ : .stringValue(bString)\n        }\n        \n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7kkvnvp6.swift:24:30: error: missing argument for parameter #1\
    \ in call\n    if let aInt = a.intValue() {\n                             ^\n\
    \                             <#Int#>\n/tmp/tmp7kkvnvp6.swift:3:10: note: 'intValue'\
    \ declared here\n    case intValue(Int)\n         ^\n/tmp/tmp7kkvnvp6.swift:24:19:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ aInt = a.intValue() {\n                  ^\n                  Value\n/tmp/tmp7kkvnvp6.swift:25:23:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        if\
    \ let bInt = b.intValue() {\n                      ^\n                      Value\n\
    /tmp/tmp7kkvnvp6.swift:25:34: error: missing argument for parameter #1 in call\n\
    \        if let bInt = b.intValue() {\n                                 ^\n  \
    \                               <#Int#>\n/tmp/tmp7kkvnvp6.swift:3:10: note: 'intValue'\
    \ declared here\n    case intValue(Int)\n         ^\n/tmp/tmp7kkvnvp6.swift:30:36:\
    \ error: missing argument for parameter #1 in call\n    if let aDouble = a.doubleValue()\
    \ {\n                                   ^\n                                  \
    \ <#Double#>\n/tmp/tmp7kkvnvp6.swift:4:10: note: 'doubleValue' declared here\n\
    \    case doubleValue(Double)\n         ^\n/tmp/tmp7kkvnvp6.swift:30:22: error:\
    \ enum case 'doubleValue' cannot be used as an instance member\n    if let aDouble\
    \ = a.doubleValue() {\n                     ^\n                     Value\n/tmp/tmp7kkvnvp6.swift:31:40:\
    \ error: missing argument for parameter #1 in call\n        if let bDouble = b.doubleValue()\
    \ {\n                                       ^\n                              \
    \         <#Double#>\n/tmp/tmp7kkvnvp6.swift:4:10: note: 'doubleValue' declared\
    \ here\n    case doubleValue(Double)\n         ^\n/tmp/tmp7kkvnvp6.swift:31:26:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  if let bDouble = b.doubleValue() {\n                         ^\n          \
    \               Value\n/tmp/tmp7kkvnvp6.swift:36:36: error: missing argument for\
    \ parameter #1 in call\n    if let aString = a.stringValue() {\n        "
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b){\n    case (.intValue(x), .intValue(y))\
    \ if x > y -> return .intValue(x)\n    case (.intValue(x), .intValue(y)) if x\
    \ == y -> return .intValue(x)\n    case (.intValue(x), .doubleValue(y)) if x >\
    \ y -> return .intValue(x)\n    case (.doubleValue(x), .doubleValue(y)) if x >\
    \ y -> return .doubleValue(x)\n    case (.doubleValue(x), .doubleValue(y)) if\
    \ x == y -> return .doubleValue(x)\n    case (.doubleValue(x), .stringValue(y))\
    \ if x > y -> return .doubleValue(x)\n    case (.stringValue(x), .stringValue(y))\
    \ if x > y -> return .stringValue(x)\n    case (.stringValue(x), .intValue(y))\
    \ if x > y -> return .stringValue(x)\n    case (.stringValue(x), .doubleValue(y))\
    \ if x > y -> return .stringValue(x)\n    case (.doubleValue(x), .intValue(y))\
    \ if x > y -> return .doubleValue(x)\n    case (.intValue(x), .intValue(y)) if\
    \ x == y -> return .intValue(x)\n    case (.intValue(x), .stringValue(y)) if x\
    \ == y -> return .intValue(x)\n    case (.stringValue(x), .stringValue(y)) if\
    \ x == y -> return .stringValue(x)\n    case (.stringValue(x), .doubleValue(y))\
    \ if x == y -> return .stringValue(x)\n    case (.stringValue(x), .intValue(y))\
    \ if x == y -> return .stringValue(x)\n    case (.doubleValue(x), .intValue(y))\
    \ if x == y -> return .doubleValue(x)\n    case (.intValue(x), .intValue(y)) if\
    \ x == y -> return .intValue(x)\n    case (.stringValue(x), .stringValue(y)) if\
    \ x == y -> return .stringValue(x)\n    case (.doubleValue(x), .stringValue(y))\
    \ if x == y -> return .doubleValue(x)\n    case (.doubleValue(x), .intValue(y))\
    \ if x == y -> return .doubleValue(x)\n    case (.intValue(x), .intValue(y)) if\
    \ x == y -> return .intValue(x)\n    case (.doubleValue(x), .doubleValue(y)) if\
    \ x == y -> return .doubleValue(x)\n    case (.stringValue(x), .doubleValue(y))\
    \ if x == y -> return .stringValue(x)\n    case (.stringValue(x), .intValue(y))\
    \ if x == y -> return .stringValue(x)\n    case (.stringValue(x), .doubleValue(y))\
    \ if x == y -> return .stringValue(x)\n    case (.doubleValue(x), .intValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppa5fbkjq.swift:23:39: error: expected ':' after 'case'\n    case\
    \ (.intValue(x), .intValue(y)) if x > y -> return .intValue(x)\n             \
    \                         ^\n/tmp/tmppa5fbkjq.swift:23:51: error: expected expression\
    \ after operator\n    case (.intValue(x), .intValue(y)) if x > y -> return .intValue(x)\n\
    \                                                  ^\n/tmp/tmppa5fbkjq.swift:24:39:\
    \ error: expected ':' after 'case'\n    case (.intValue(x), .intValue(y)) if x\
    \ == y -> return .intValue(x)\n                                      ^\n/tmp/tmppa5fbkjq.swift:24:52:\
    \ error: expected expression after operator\n    case (.intValue(x), .intValue(y))\
    \ if x == y -> return .intValue(x)\n                                         \
    \          ^\n/tmp/tmppa5fbkjq.swift:25:42: error: expected ':' after 'case'\n\
    \    case (.intValue(x), .doubleValue(y)) if x > y -> return .intValue(x)\n  \
    \                                       ^\n/tmp/tmppa5fbkjq.swift:25:54: error:\
    \ expected expression after operator\n    case (.intValue(x), .doubleValue(y))\
    \ if x > y -> return .intValue(x)\n                                          \
    \           ^\n/tmp/tmppa5fbkjq.swift:26:45: error: expected ':' after 'case'\n\
    \    case (.doubleValue(x), .doubleValue(y)) if x > y -> return .doubleValue(x)\n\
    \                                            ^\n/tmp/tmppa5fbkjq.swift:26:57:\
    \ error: expected expression after operator\n    case (.doubleValue(x), .doubleValue(y))\
    \ if x > y -> return .doubleValue(x)\n                                       \
    \                 ^\n/tmp/tmppa5fbkjq.swift:27:45: error: expected ':' after 'case'\n\
    \    case (.doubleValue(x), .doubleValue(y)) if x == y -> return .doubleValue(x)\n\
    \                                            ^\n/tmp/tmppa5fbkjq.swift:27:58:\
    \ error: expected expression after operator\n    case (.doubleValue(x), .doubleValue(y))\
    \ if x == y -> return .doubleValue(x)\n                                      \
    \                   ^\n/tmp/tmppa5fbkjq.swift:28:45: error: expected ':' after\
    \ 'case'\n    case (.doubleValue(x), .stringValue(y)) if x > y -> return .doubleVa"
  stdout: ''
  timestamp: 1660013423
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_):\n        switch\
    \ b { case .intValue(_):\n            return a\n        default:\n           \
    \ return b\n        }\n    case .doubleValue(_):\n        switch b { case .doubleValue(_):\n\
    \            return a\n        default:\n            return b\n        }\n   \
    \ case .stringValue(_):\n        switch b { case .stringValue(_):\n          \
    \  return a\n        default:\n            return b\n        }\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpwr5qn0vm/tmpwr5qn0vm.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b551ee24c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b551eb1bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b551eb1b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b551eb1a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwr5qn0vm                        0x00005563d09fba56 <unavailable> + 6742

    5    libc.so.6                          0x00002b551f010460 __libc_start_main +
    245

    6    tmpwr5qn0vm                        0x00005563d09fb499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .doubleValue(let value):\n            return .intValue(value)\n\
    \        case .stringValue(let value):\n            return .stringValue(String(value).deletingCommas())\n\
    \        }\n    case .doubleValue(_):\n        switch b {\n        case .intValue(let\
    \ value):\n            return .doubleValue(value)\n        case .stringValue(let\
    \ value):\n            return .stringValue(String(value).deletingCommas())\n \
    \       }\n    case .stringValue(_):\n        switch b {\n        case .intValue(let\
    \ value):\n            return .stringValue(value)\n        case .doubleValue(let\
    \ value):\n            return .doubleValue(value)\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpaam1r7k1.swift:26:30: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n            return .intValue(value)\n     \
    \                        ^\n                             Int( )\n/tmp/tmpaam1r7k1.swift:28:47:\
    \ error: value of type 'String' has no member 'deletingCommas'\n            return\
    \ .stringValue(String(value).deletingCommas())\n                             \
    \   ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpaam1r7k1.swift:24:9: error: switch must\
    \ be exhaustive\n        switch b {\n        ^\n/tmp/tmpaam1r7k1.swift:24:9: note:\
    \ add missing case: '.intValue(_)'\n        switch b {\n        ^\n/tmp/tmpaam1r7k1.swift:33:33:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \            return .doubleValue(value)\n                                ^\n \
    \                               Double( )\n/tmp/tmpaam1r7k1.swift:35:47: error:\
    \ value of type 'String' has no member 'deletingCommas'\n            return .stringValue(String(value).deletingCommas())\n\
    \                                ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpaam1r7k1.swift:31:9:\
    \ error: switch must be exhaustive\n        switch b {\n        ^\n/tmp/tmpaam1r7k1.swift:31:9:\
    \ note: add missing case: '.doubleValue(_)'\n        switch b {\n        ^\n/tmp/tmpaam1r7k1.swift:40:33:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String'\n\
    \            return .stringValue(value)\n                                ^\n/tmp/tmpaam1r7k1.swift:38:9:\
    \ error: switch must be exhaustive\n        switch b {\n        ^\n/tmp/tmpaam1r7k1.swift:38:9:\
    \ note: add missing case: '.stringValue(_)'\n        switch b {\n        ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let a_intValue = a.intValue, let b_intValue\
    \ = b.intValue {\n        if a_intValue > b_intValue {\n            return a\n\
    \        }\n    }\n    if let a_doubleValue = a.doubleValue, let b_doubleValue\
    \ = b.doubleValue {\n        if a_doubleValue > b_doubleValue {\n            return\
    \ a\n        }\n    }\n    if let a_stringValue = a.stringValue, let b_stringValue\
    \ = b.stringValue {\n        if a_stringValue > b_stringValue {\n            return\
    \ a\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp11etl2xn.swift:22:25: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    if let a_intValue = a.intValue, let b_intValue =\
    \ b.intValue {\n                        ^\n                        Value\n/tmp/tmp11etl2xn.swift:22:54:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ a_intValue = a.intValue, let b_intValue = b.intValue {\n                   \
    \                                  ^\n                                       \
    \              Value\n/tmp/tmp11etl2xn.swift:27:28: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n    if let a_doubleValue = a.doubleValue,\
    \ let b_doubleValue = b.doubleValue {\n                           ^\n        \
    \                   Value\n/tmp/tmp11etl2xn.swift:27:63: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n    if let a_doubleValue = a.doubleValue,\
    \ let b_doubleValue = b.doubleValue {\n                                      \
    \                        ^\n                                                 \
    \             Value\n/tmp/tmp11etl2xn.swift:32:28: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n    if let a_stringValue = a.stringValue,\
    \ let b_stringValue = b.stringValue {\n                           ^\n        \
    \                   Value\n/tmp/tmp11etl2xn.swift:32:63: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n    if let a_stringValue = a.stringValue,\
    \ let b_stringValue = b.stringValue {\n                                      \
    \                        ^\n                                                 \
    \             Value\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    switch a where a.isKindOfClass(Double),\
    \ b.isKindOfClass(Double) {\n    case true:\n        if let a = a.doubleValue,\
    \ b = b.doubleValue {\n            return .doubleValue(max(min(a, b), Double.infinity))\n\
    \        }\n    case false:\n        if let a = a.intValue, b = b.intValue {\n\
    \            return .intValue(max(min(a, b), Int32.max))\n        }\n    case\
    \ nil:\n        if let a = a.stringValue, b = b.stringValue {\n            return\
    \ .stringValue(max(min(a, b), b.hasDecimalSeparator)\n                ? b.stringValue.stringByReplacingOccurrencesOfString(\"\
    ,\", withString: \"\")\n                : b.stringValue)\n        }\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0cnvksr5.swift:23:14: error: expected '{' after 'switch' subject\
    \ expression\n    switch a where a.isKindOfClass(Double), b.isKindOfClass(Double)\
    \ {\n             ^\n/tmp/tmp0cnvksr5.swift:23:13: error: consecutive statements\
    \ on a line must be separated by ';'\n    switch a where a.isKindOfClass(Double),\
    \ b.isKindOfClass(Double) {\n            ^\n            ;\n/tmp/tmp0cnvksr5.swift:23:14:\
    \ error: expected expression\n    switch a where a.isKindOfClass(Double), b.isKindOfClass(Double)\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch b {\n    case .intValue(_), .doubleValue(_),\
    \ .stringValue(_), .stringEqualsIgnoreCase(_):\n        return a\n    case .intEqualsIgnoreCase(_),\
    \ .doubleEqualsIgnoreCase(_), .stringEqualsIgnoreCase(_):\n        return nil\n\
    \    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv4f7o0ye.swift:23:82: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n    case .intValue(_), .doubleValue(_), .stringValue(_),\
    \ .stringEqualsIgnoreCase(_):\n                                              \
    \                                   ^\n/tmp/tmpv4f7o0ye.swift:25:31: error: '_'\
    \ can only appear in a pattern or on the left side of an assignment\n    case\
    \ .intEqualsIgnoreCase(_), .doubleEqualsIgnoreCase(_), .stringEqualsIgnoreCase(_):\n\
    \                              ^\n/tmp/tmpv4f7o0ye.swift:25:59: error: '_' can\
    \ only appear in a pattern or on the left side of an assignment\n    case .intEqualsIgnoreCase(_),\
    \ .doubleEqualsIgnoreCase(_), .stringEqualsIgnoreCase(_):\n                  \
    \                                        ^\n/tmp/tmpv4f7o0ye.swift:25:87: error:\
    \ '_' can only appear in a pattern or on the left side of an assignment\n    case\
    \ .intEqualsIgnoreCase(_), .doubleEqualsIgnoreCase(_), .stringEqualsIgnoreCase(_):\n\
    \                                                                            \
    \          ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a <? b where a == b {\n    case let\
    \ .intValue(aValue):\n        return .intValue(aValue)\n    case let .doubleValue(aValue):\n\
    \        return .doubleValue(aValue)\n    case let .stringValue(aValue):\n   \
    \     if let bValue = b.stringValue {\n            return .stringValue(aValue\
    \ > bValue ? aValue : bValue)\n        } else {\n            return .stringValue(\"\
    0\")\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfgukvdkk.swift:22:19: error: expected '{' after 'switch' subject\
    \ expression\n    switch a <? b where a == b {\n                  ^\n/tmp/tmpfgukvdkk.swift:22:18:\
    \ error: consecutive statements on a line must be separated by ';'\n    switch\
    \ a <? b where a == b {\n                 ^\n                 ;\n/tmp/tmpfgukvdkk.swift:22:19:\
    \ error: expected expression\n    switch a <? b where a == b {\n             \
    \     ^\n/tmp/tmpfgukvdkk.swift:22:14: error: cannot find operator '<?' in scope\n\
    \    switch a <? b where a == b {\n             ^~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a.doubleValue() > b.doubleValue() {\n \
    \       return b\n    } else if a.doubleValue() < b.doubleValue() {\n        return\
    \ a\n    }\n\n    if a.intValue() > b.intValue() {\n        return b\n    } else\
    \ if a.intValue() < b.intValue() {\n        return a\n    }\n\n    if a.stringValue()\
    \ > b.stringValue() {\n        return b\n    } else if a.stringValue() < b.stringValue()\
    \ {\n        return a\n    }\n\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3p05hz57.swift:22:8: error: enum case 'doubleValue' cannot be used\
    \ as an instance member\n    if a.doubleValue() > b.doubleValue() {\n       ^\n\
    \       Value\n/tmp/tmp3p05hz57.swift:22:22: error: missing argument for parameter\
    \ #1 in call\n    if a.doubleValue() > b.doubleValue() {\n                   \
    \  ^\n                     <#Double#>\n/tmp/tmp3p05hz57.swift:4:10: note: 'doubleValue'\
    \ declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmp3p05hz57.swift:22:24:\
    \ error: referencing operator function '>' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.doubleValue() > b.doubleValue() {\n      \
    \                 ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic\
    \ protocol Comparable : Equatable {\n                ^\n/tmp/tmp3p05hz57.swift:22:24:\
    \ note: binary operator '>' cannot be synthesized for enums with associated values\n\
    \    if a.doubleValue() > b.doubleValue() {\n                       ^\n/tmp/tmp3p05hz57.swift:22:40:\
    \ error: missing argument for parameter #1 in call\n    if a.doubleValue() > b.doubleValue()\
    \ {\n                                       ^\n                              \
    \         <#Double#>\n/tmp/tmp3p05hz57.swift:4:10: note: 'doubleValue' declared\
    \ here\n    case doubleValue(Double)\n         ^\n/tmp/tmp3p05hz57.swift:22:26:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ a.doubleValue() > b.doubleValue() {\n                         ^\n          \
    \               Value\n/tmp/tmp3p05hz57.swift:24:29: error: missing argument for\
    \ parameter #1 in call\n    } else if a.doubleValue() < b.doubleValue() {\n  \
    \                          ^\n                            <#Double#>\n/tmp/tmp3p05hz57.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmp3p05hz57.swift:24:15: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n    } else if a.doubleValue() < b.doubleValue() {\n    \
    \          ^\n              Value\n/tmp/tmp3p05hz57.swift:24:31: error: referencing\
    \ operator function '<' on 'Comparable' requires that 'Value' confor"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a === b {\n        return nil\n    }\n\n\
    \    let floatA = a?.floatValue\n    let floatB = b?.floatValue\n    switch floatA,\
    \ floatB {\n    case (nil, nil):\n        return nil\n    case (let floatA, let\
    \ floatB), (_, let floatB):\n        if floatA < floatB {\n            return\
    \ .intValue(floatA)\n        }\n        return .doubleValue(max(floatA, floatB))\n\
    \    case (_, let floatA), (_, let floatB):\n        if floatA > floatB {\n  \
    \          return .intValue(floatA)\n        }\n        return .doubleValue(min(floatA,\
    \ floatB))\n    case (_, let floatA), (_, let floatB), (_, let floatB):\n    \
    \    if floatA < floatB {\n            return .doubleValue(max(floatA, floatB))\n\
    \        }\n        if floatA > floatB {\n            return .doubleValue(min(floatA,\
    \ floatB))\n        }\n        return .intValue(floatA)\n    case (_, let floatA),\
    \ (_, let floatB), (_, let floatB), (_, let floatB):\n        if floatA < floatB\
    \ {\n            return .intValue(floatA)\n        }\n        if floatA > floatB\
    \ {\n            return .intValue(floatA)\n        }\n        return .doubleValue(max(floatA,\
    \ floatB))\n    case (_, let floatA), (_, let floatB), (_, let floatB), (_, let\
    \ floatB), (_, let floatB):\n        if floatA < floatB {\n            return\
    \ .intValue(floatA)\n        }\n        if floatA > floatB {\n            return\
    \ .intValue(floatA)\n        }\n        if floatA < floatB {\n            return\
    \ .intValue(floatA)\n        }\n        if floatA > floatB {\n            return\
    \ .intValue(floatA)\n        }\n        return .doubleValue(min(floatA, floatB))\n\
    \    case (_, let floatA), (_, let floatB), (_, let floatB), (_, let floatB),\
    \ (_, let floatB), (_, let floatB):\n        if floatA < floatB {\n          \
    \  return .intValue(floatA)\n        }\n        if floatA > floatB {\n       \
    \     return .intValue(floatA)\n        }\n        if floatA < floatB {\n    \
    \        return .intValue(floatA)\n        }\n        if floatA > floatB {\n \
    \           return .intValue(floatA)\n        }\n        if floatA < floatB {\n\
    \            return .intValue(floatA)\n        }\n        return .doubleValue(max(floatA,\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp1ewt80ij.swift:28:18: error: expected '{' after 'switch' subject\
    \ expression\n    switch floatA, floatB {\n                 ^\n/tmp/tmp1ewt80ij.swift:28:18:\
    \ error: consecutive statements on a line must be separated by ';'\n    switch\
    \ floatA, floatB {\n                 ^\n                 ;\n/tmp/tmp1ewt80ij.swift:28:18:\
    \ error: expected expression\n    switch floatA, floatB {\n                 ^\n\
    /tmp/tmp1ewt80ij.swift:110:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmp1ewt80ij.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmp1ewt80ij.swift:22:8:\
    \ error: argument type 'Value' expected to be an instance of a class or class-constrained\
    \ type\n    if a === b {\n       ^\n/tmp/tmp1ewt80ij.swift:22:14: error: argument\
    \ type 'Value' expected to be an instance of a class or class-constrained type\n\
    \    if a === b {\n             ^\n/tmp/tmp1ewt80ij.swift:26:19: error: cannot\
    \ use optional chaining on non-optional value of type 'Value'\n    let floatA\
    \ = a?.floatValue\n                 ~^\n                  \n/tmp/tmp1ewt80ij.swift:26:21:\
    \ error: value of type 'Value' has no member 'floatValue'\n    let floatA = a?.floatValue\n\
    \                 ~~ ^~~~~~~~~~\n/tmp/tmp1ewt80ij.swift:27:19: error: cannot use\
    \ optional chaining on non-optional value of type 'Value'\n    let floatB = b?.floatValue\n\
    \                 ~^\n                  \n/tmp/tmp1ewt80ij.swift:27:21: error:\
    \ value of type 'Value' has no member 'floatValue'\n    let floatB = b?.floatValue\n\
    \                 ~~ ^~~~~~~~~~\n/tmp/tmp1ewt80ij.swift:91:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // Convert one value to the other of the same\
    \ type\n    let converted_a = a.dynamicType === b.dynamicType ? a.intValue(b)\
    \ : a.doubleValue(b)\n    // Determine if the values are equal\n    return converted_a.compare(b.dynamicType\
    \ == Double.self ? b.doubleValue(a) : b.doubleValue(a))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9ifd7yaf.swift:23:25: error: value of type 'Value' has no member\
    \ 'dynamicType'\n    let converted_a = a.dynamicType === b.dynamicType ? a.intValue(b)\
    \ : a.doubleValue(b)\n                      ~ ^~~~~~~~~~~\n/tmp/tmp9ifd7yaf.swift:23:43:\
    \ error: value of type 'Value' has no member 'dynamicType'\n    let converted_a\
    \ = a.dynamicType === b.dynamicType ? a.intValue(b) : a.doubleValue(b)\n     \
    \                                   ~ ^~~~~~~~~~~\n/tmp/tmp9ifd7yaf.swift:23:68:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Int'\n\
    \    let converted_a = a.dynamicType === b.dynamicType ? a.intValue(b) : a.doubleValue(b)\n\
    \                                                                   ^\n/tmp/tmp9ifd7yaf.swift:23:57:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    let converted_a\
    \ = a.dynamicType === b.dynamicType ? a.intValue(b) : a.doubleValue(b)\n     \
    \                                                   ^\n                      \
    \                                  Value\n/tmp/tmp9ifd7yaf.swift:23:87: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Double'\n  \
    \  let converted_a = a.dynamicType === b.dynamicType ? a.intValue(b) : a.doubleValue(b)\n\
    \                                                                            \
    \          ^\n/tmp/tmp9ifd7yaf.swift:23:73: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n    let converted_a = a.dynamicType === b.dynamicType\
    \ ? a.intValue(b) : a.doubleValue(b)\n                                       \
    \                                 ^\n                                        \
    \                                Value\n/tmp/tmp9ifd7yaf.swift:25:34: error: value\
    \ of type 'Value' has no member 'dynamicType'\n    return converted_a.compare(b.dynamicType\
    \ == Double.self ? b.doubleValue(a) : b.doubleValue(a))\n                    \
    \           ~ ^~~~~~~~~~~\n/tmp/tmp9ifd7yaf.swift:25:77: error: cannot convert\
    \ value of type 'Value' to expected argument type 'Double'\n    return converted_a.compare(b.dynamicType\
    \ == Double.self ? b.doubleVal"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let a_int = a.intValue()\n    let b_int =\
    \ b.intValue()\n    let a_double = a.doubleValue()\n    let b_double = b.doubleValue()\n\
    \    let a_int_str = a.stringValue()\n    let b_int_str = b.stringValue()\n  \
    \  \n    switch {\n    case a_int > b_int:\n        return .intValue(b_int)\n\
    \    case a_int < b_int:\n        return .intValue(a_int)\n    case a_double >\
    \ b_double:\n        return .doubleValue(b_double)\n    case a_double < b_double:\n\
    \        return .doubleValue(a_double)\n    case a_int_str > b_int_str:\n    \
    \    return .stringValue(b_int_str)\n    case a_int_str < b_int_str:\n       \
    \ return .stringValue(a_int_str)\n    default:\n        return nil\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpepbgl40a.swift:29:12: error: expected expression in 'switch' statement\n\
    \    switch {\n           ^\n/tmp/tmpepbgl40a.swift:22:17: error: enum case 'intValue'\
    \ cannot be used as an instance member\n    let a_int = a.intValue()\n       \
    \         ^\n                Value\n/tmp/tmpepbgl40a.swift:22:28: error: missing\
    \ argument for parameter #1 in call\n    let a_int = a.intValue()\n          \
    \                 ^\n                           <#Int#>\n/tmp/tmpepbgl40a.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpepbgl40a.swift:23:28:\
    \ error: missing argument for parameter #1 in call\n    let b_int = b.intValue()\n\
    \                           ^\n                           <#Int#>\n/tmp/tmpepbgl40a.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpepbgl40a.swift:23:17:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    let b_int\
    \ = b.intValue()\n                ^\n                Value\n/tmp/tmpepbgl40a.swift:24:20:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    let\
    \ a_double = a.doubleValue()\n                   ^\n                   Value\n\
    /tmp/tmpepbgl40a.swift:24:34: error: missing argument for parameter #1 in call\n\
    \    let a_double = a.doubleValue()\n                                 ^\n    \
    \                             <#Double#>\n/tmp/tmpepbgl40a.swift:4:10: note: 'doubleValue'\
    \ declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmpepbgl40a.swift:25:34:\
    \ error: missing argument for parameter #1 in call\n    let b_double = b.doubleValue()\n\
    \                                 ^\n                                 <#Double#>\n\
    /tmp/tmpepbgl40a.swift:4:10: note: 'doubleValue' declared here\n    case doubleValue(Double)\n\
    \         ^\n/tmp/tmpepbgl40a.swift:25:20: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n    let b_double = b.doubleValue()\n        \
    \           ^\n                   Value\n/tmp/tmpepbgl40a.swift:26:21: error:\
    \ enum case 'stringValue' cannot be used as an instance member\n    let a_int_str\
    \ = a.stringValue()"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b)):\n\
    \        return .intValue(a)\n    case (.intValue(a), .doubleValue(b)):\n    \
    \    return .doubleValue(a)\n    case (.intValue(a), .stringValue(b)):\n     \
    \   return .stringValue(a)\n    case (.doubleValue(a), .doubleValue(b)):\n   \
    \     return .doubleValue(a)\n    case (.doubleValue(a), .stringValue(b)):\n \
    \       return .stringValue(a)\n    case (.stringValue(a), .stringValue(b)):\n\
    \        return .stringValue(a)\n    case (.stringValue(a), .intValue(b)):\n \
    \       return .intValue(a)\n    case (nil, nil):\n        return nil\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpp5g_q1o8.swift:23:21: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case (.intValue(a), .intValue(b)):\n\
    \                    ^\n/tmp/tmpp5g_q1o8.swift:25:21: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Int'\n    case (.intValue(a), .doubleValue(b)):\n\
    \                    ^\n/tmp/tmpp5g_q1o8.swift:27:21: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Int'\n    case (.intValue(a), .stringValue(b)):\n\
    \                    ^\n/tmp/tmpp5g_q1o8.swift:29:24: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .doubleValue(b)):\n                       ^\n/tmp/tmpp5g_q1o8.swift:31:24: error:\
    \ expression pattern of type 'Value' cannot match values of type 'Double'\n  \
    \  case (.doubleValue(a), .stringValue(b)):\n                       ^\n/tmp/tmpp5g_q1o8.swift:33:24:\
    \ error: expression pattern of type 'Value' cannot match values of type 'String'\n\
    \    case (.stringValue(a), .stringValue(b)):\n                       ^\n/tmp/tmpp5g_q1o8.swift:33:24:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case (.stringValue(a), .stringValue(b)):\n        \
    \               ^\n/tmp/tmpp5g_q1o8.swift:35:24: error: expression pattern of\
    \ type 'Value' cannot match values of type 'String'\n    case (.stringValue(a),\
    \ .intValue(b)):\n                       ^\n/tmp/tmpp5g_q1o8.swift:35:24: note:\
    \ overloads for '~=' exist with these partially matching parameter lists: (Substring,\
    \ String)\n    case (.stringValue(a), .intValue(b)):\n                       ^\n\
    /tmp/tmpp5g_q1o8.swift:37:11: warning: type 'Value' is not optional, value can\
    \ never be nil; this is an error in Swift 6\n    case (nil, nil):\n          ^\n\
    /tmp/tmpp5g_q1o8.swift:37:16: warning: type 'Value' is not optional, value can\
    \ never be nil; this is an error in Swift 6\n    case (nil, nil):\n          \
    \     ^\n/tmp/tmpp5g_q1o8.swift:24:26: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n        return ."
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(i), .doubleValue(d),\
    \ .stringValue(str): \n        return .doubleValue(max(i, d)) \n    case .stringValue(str):\
    \ \n        return .stringValue(max(str, b))\n    case nil: \n        return nil\
    \ \n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpm3lqdr84.swift:23:20: error: cannot find 'i' in scope\n    case\
    \ .intValue(i), .doubleValue(d), .stringValue(str): \n                   ^\n/tmp/tmpm3lqdr84.swift:23:37:\
    \ error: cannot find 'd' in scope\n    case .intValue(i), .doubleValue(d), .stringValue(str):\
    \ \n                                    ^\n/tmp/tmpm3lqdr84.swift:23:54: error:\
    \ cannot find 'str' in scope\n    case .intValue(i), .doubleValue(d), .stringValue(str):\
    \ \n                                                     ^~~\n/tmp/tmpm3lqdr84.swift:25:23:\
    \ error: cannot find 'str' in scope\n    case .stringValue(str): \n          \
    \            ^~~\n/tmp/tmpm3lqdr84.swift:27:10: warning: type 'Value' is not optional,\
    \ value can never be nil; this is an error in Swift 6\n    case nil: \n      \
    \   ^\n/tmp/tmpm3lqdr84.swift:24:33: error: cannot find 'i' in scope\n       \
    \ return .doubleValue(max(i, d)) \n                                ^\n/tmp/tmpm3lqdr84.swift:24:36:\
    \ error: cannot find 'd' in scope\n        return .doubleValue(max(i, d)) \n \
    \                                  ^\n/tmp/tmpm3lqdr84.swift:26:33: error: cannot\
    \ find 'str' in scope\n        return .stringValue(max(str, b))\n            \
    \                    ^~~\n/tmp/tmpm3lqdr84.swift:26:38: error: cannot convert\
    \ value of type 'Value' to expected argument type 'String'\n        return .stringValue(max(str,\
    \ b))\n                                     ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(aInt), .doubleValue(aDouble),\
    \ .stringValue(aString)\n    case .intValue(bInt), .doubleValue(bDouble), .stringValue(bString)\n\
    \    default:\n        guard a == b else { return nil }\n    }\n    return a\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpirdaee80.swift:22:82: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(aInt), .doubleValue(aDouble), .stringValue(aString)\n   \
    \                                                                            \
    \  ^\n/tmp/tmpirdaee80.swift:23:71: error: expected ':' after 'case'\n    case\
    \ .intValue(bInt), .doubleValue(bDouble), .stringValue(bString)\n            \
    \                                                          ^\n/tmp/tmpirdaee80.swift:22:31:\
    \ error: cannot find 'aInt' in scope\n    switch a { case .intValue(aInt), .doubleValue(aDouble),\
    \ .stringValue(aString)\n                              ^~~~\n/tmp/tmpirdaee80.swift:22:51:\
    \ error: cannot find 'aDouble' in scope\n    switch a { case .intValue(aInt),\
    \ .doubleValue(aDouble), .stringValue(aString)\n                             \
    \                     ^~~~~~~\n/tmp/tmpirdaee80.swift:22:74: error: cannot find\
    \ 'aString' in scope\n    switch a { case .intValue(aInt), .doubleValue(aDouble),\
    \ .stringValue(aString)\n                                                    \
    \                     ^~~~~~~\n/tmp/tmpirdaee80.swift:23:20: error: cannot find\
    \ 'bInt' in scope\n    case .intValue(bInt), .doubleValue(bDouble), .stringValue(bString)\n\
    \                   ^~~~\n/tmp/tmpirdaee80.swift:23:40: error: cannot find 'bDouble'\
    \ in scope\n    case .intValue(bInt), .doubleValue(bDouble), .stringValue(bString)\n\
    \                                       ^~~~~~~\n/tmp/tmpirdaee80.swift:23:63:\
    \ error: cannot find 'bString' in scope\n    case .intValue(bInt), .doubleValue(bDouble),\
    \ .stringValue(bString)\n                                                    \
    \          ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var a: Value\n    var b: Value\n    switch\
    \ a {\n    case .intValue(_):\n        guard let i = (a as? Int) else {\n    \
    \        return nil\n        }\n        a = .intValue(b)\n        b = .intValue(i)\n\
    \    case .doubleValue(_):\n        guard let d = (a as? Double) else {\n    \
    \        return nil\n        }\n        a = .doubleValue(b)\n        b = .doubleValue(a)\n\
    \    case .stringValue(_):\n        guard let s = (a as? String) else {\n    \
    \        return nil\n        }\n        a = .stringValue(b)\n        b = .stringValue(a)\n\
    \    }\n    if a != b {\n        return nil\n    }\n    return a\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphow3ko39.swift:26:26: warning: cast from 'Value' to unrelated type\
    \ 'Int' always fails\n        guard let i = (a as? Int) else {\n             \
    \          ~ ^   ~~~\n/tmp/tmphow3ko39.swift:29:23: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n        a = .intValue(b)\n\
    \                      ^\n/tmp/tmphow3ko39.swift:32:26: warning: cast from 'Value'\
    \ to unrelated type 'Double' always fails\n        guard let d = (a as? Double)\
    \ else {\n                       ~ ^   ~~~~~~\n/tmp/tmphow3ko39.swift:35:26: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Double'\n  \
    \      a = .doubleValue(b)\n                         ^\n/tmp/tmphow3ko39.swift:36:26:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \        b = .doubleValue(a)\n                         ^\n/tmp/tmphow3ko39.swift:38:26:\
    \ warning: cast from 'Value' to unrelated type 'String' always fails\n       \
    \ guard let s = (a as? String) else {\n                       ~ ^   ~~~~~~\n/tmp/tmphow3ko39.swift:41:26:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \        a = .stringValue(b)\n                         ^\n/tmp/tmphow3ko39.swift:42:26:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \        b = .stringValue(a)\n                         ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   if a.intValue() < b.intValue() {\n            return a\n        }\n      \
    \  return b\n    case .doubleValue(_):\n        if a.doubleValue() < b.doubleValue()\
    \ {\n            return a\n        }\n        return b\n    case .stringValue(_):\n\
    \        if a.stringValue() < b.stringValue() {\n            return a\n      \
    \  }\n        return b\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfftwr724.swift:24:23: error: missing argument for parameter #1\
    \ in call\n        if a.intValue() < b.intValue() {\n                      ^\n\
    \                      <#Int#>\n/tmp/tmpfftwr724.swift:3:10: note: 'intValue'\
    \ declared here\n    case intValue(Int)\n         ^\n/tmp/tmpfftwr724.swift:24:12:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        if\
    \ a.intValue() < b.intValue() {\n           ^\n           Value\n/tmp/tmpfftwr724.swift:24:25:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n        if a.intValue() < b.intValue() {\n        \
    \                ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic\
    \ protocol Comparable : Equatable {\n                ^\n/tmp/tmpfftwr724.swift:24:25:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \        if a.intValue() < b.intValue() {\n                        ^\n/tmp/tmpfftwr724.swift:24:38:\
    \ error: missing argument for parameter #1 in call\n        if a.intValue() <\
    \ b.intValue() {\n                                     ^\n                   \
    \                  <#Int#>\n/tmp/tmpfftwr724.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmpfftwr724.swift:24:27: error:\
    \ enum case 'intValue' cannot be used as an instance member\n        if a.intValue()\
    \ < b.intValue() {\n                          ^\n                          Value\n\
    /tmp/tmpfftwr724.swift:29:12: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n        if a.doubleValue() < b.doubleValue() {\n       \
    \    ^\n           Value\n/tmp/tmpfftwr724.swift:29:26: error: missing argument\
    \ for parameter #1 in call\n        if a.doubleValue() < b.doubleValue() {\n \
    \                        ^\n                         <#Double#>\n/tmp/tmpfftwr724.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmpfftwr724.swift:29:28: error: referencing operator function '<' on 'Comparable'\
    \ requires that 'Value' conform to 'Comparable'\n        if a.doubleValue() <\
    \ b."
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == .intValue(b) {\n        return .intValue(b);\n\
    \    } else if a == .doubleValue(b) {\n        return .doubleValue(b);\n    }\
    \ else if a == .stringValue(b) {\n        if let str = b.stringValue {\n     \
    \       guard str.count >= a.stringValue.count else { return nil }\n         \
    \   var newStr = str\n            if str.count == a.stringValue.count {\n    \
    \            for i in 0..<a.stringValue.count {\n                    if str.index(after:\
    \ a.stringValue[i]) == nil {\n                        newStr = newStr.substring(0,\
    \ newStr.index(before: newStr.endIndex))\n                        break;\n   \
    \                 }\n                }\n            }\n            return .stringValue(newStr);\n\
    \        }\n    }\n    return nil;\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5gtt8t41.swift:22:23: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n    if a == .intValue(b) {\n              \
    \        ^\n/tmp/tmp5gtt8t41.swift:23:26: error: cannot convert value of type\
    \ 'Value' to expected argument type 'Int'\n        return .intValue(b);\n    \
    \                     ^\n/tmp/tmp5gtt8t41.swift:24:33: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Double'\n    } else if a == .doubleValue(b)\
    \ {\n                                ^\n/tmp/tmp5gtt8t41.swift:25:29: error: cannot\
    \ convert value of type 'Value' to expected argument type 'Double'\n        return\
    \ .doubleValue(b);\n                            ^\n/tmp/tmp5gtt8t41.swift:26:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \    } else if a == .stringValue(b) {\n                                ^\n/tmp/tmp5gtt8t41.swift:27:22:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n      \
    \  if let str = b.stringValue {\n                     ^\n                    \
    \ Value\n/tmp/tmp5gtt8t41.swift:28:46: error: value of type '(String) -> Value'\
    \ has no member 'count'\n            guard str.count >= a.stringValue.count else\
    \ { return nil }\n                               ~~~~~~~~~~~~~ ^~~~~\n/tmp/tmp5gtt8t41.swift:30:43:\
    \ error: value of type '(String) -> Value' has no member 'count'\n           \
    \ if str.count == a.stringValue.count {\n                            ~~~~~~~~~~~~~\
    \ ^~~~~\n/tmp/tmp5gtt8t41.swift:31:30: error: enum case 'stringValue' cannot be\
    \ used as an instance member\n                for i in 0..<a.stringValue.count\
    \ {\n                             ^\n                             Value\n/tmp/tmp5gtt8t41.swift:31:44:\
    \ error: value of type '(String) -> Value' has no member 'count'\n           \
    \     for i in 0..<a.stringValue.count {\n                             ~~~~~~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a <-> b {\n    case .intValue:\n  \
    \      return a.intValue\n    case .doubleValue:\n        return a.doubleValue\n\
    \    case .stringValue:\n        return a.stringValue\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpckrt7wh6.swift:22:14: error: cannot find operator '<->' in scope\n\
    \    switch a <-> b {\n             ^~~\n/tmp/tmpckrt7wh6.swift:24:16: error:\
    \ enum case 'intValue' cannot be used as an instance member\n        return a.intValue\n\
    \               ^\n               Value\n/tmp/tmpckrt7wh6.swift:24:18: error:\
    \ cannot convert return expression of type '(Int) -> Value' to return type 'Value?'\n\
    \        return a.intValue\n               ~~^~~~~~~~\n/tmp/tmpckrt7wh6.swift:26:16:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  return a.doubleValue\n               ^\n               Value\n/tmp/tmpckrt7wh6.swift:26:18:\
    \ error: cannot convert return expression of type '(Double) -> Value' to return\
    \ type 'Value?'\n        return a.doubleValue\n               ~~^~~~~~~~~~~\n\
    /tmp/tmpckrt7wh6.swift:28:16: error: enum case 'stringValue' cannot be used as\
    \ an instance member\n        return a.stringValue\n               ^\n       \
    \        Value\n/tmp/tmpckrt7wh6.swift:28:18: error: cannot convert return expression\
    \ of type '(String) -> Value' to return type 'Value?'\n        return a.stringValue\n\
    \               ~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Test edge cases\n    switch a {\n\
    \    case .intValue(aValue):\n        return b == .intValue(bValue) ? .intValue(aValue)\
    \ : nil\n    case .doubleValue(aValue):\n        return b == .doubleValue(bValue)\
    \ ? .doubleValue(aValue) : nil\n    case .stringValue(aValue):\n        return\
    \ b == .stringValue(bValue) ? .stringValue(aValue) : nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjofw52wj.swift:24:20: error: cannot find 'aValue' in scope\n  \
    \  case .intValue(aValue):\n                   ^~~~~~\n/tmp/tmpjofw52wj.swift:26:23:\
    \ error: cannot find 'aValue' in scope\n    case .doubleValue(aValue):\n     \
    \                 ^~~~~~\n/tmp/tmpjofw52wj.swift:28:23: error: cannot find 'aValue'\
    \ in scope\n    case .stringValue(aValue):\n                      ^~~~~~\n/tmp/tmpjofw52wj.swift:25:31:\
    \ error: cannot find 'bValue' in scope\n        return b == .intValue(bValue)\
    \ ? .intValue(aValue) : nil\n                              ^~~~~~\n/tmp/tmpjofw52wj.swift:25:51:\
    \ error: cannot find 'aValue' in scope\n        return b == .intValue(bValue)\
    \ ? .intValue(aValue) : nil\n                                                \
    \  ^~~~~~\n/tmp/tmpjofw52wj.swift:27:34: error: cannot find 'bValue' in scope\n\
    \        return b == .doubleValue(bValue) ? .doubleValue(aValue) : nil\n     \
    \                            ^~~~~~\n/tmp/tmpjofw52wj.swift:27:57: error: cannot\
    \ find 'aValue' in scope\n        return b == .doubleValue(bValue) ? .doubleValue(aValue)\
    \ : nil\n                                                        ^~~~~~\n/tmp/tmpjofw52wj.swift:29:34:\
    \ error: cannot find 'bValue' in scope\n        return b == .stringValue(bValue)\
    \ ? .stringValue(aValue) : nil\n                                 ^~~~~~\n/tmp/tmpjofw52wj.swift:29:57:\
    \ error: cannot find 'aValue' in scope\n        return b == .stringValue(bValue)\
    \ ? .stringValue(aValue) : nil\n                                             \
    \           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b { return nil }\n    if a.intValue\
    \ < b.intValue { return b }\n    if a.intValue > b.intValue { return a }\n   \
    \ if a.doubleValue < b.doubleValue { return b }\n    if a.doubleValue > b.doubleValue\
    \ { return a }\n    if a.stringValue < b.stringValue { return b }\n    if a.stringValue\
    \ > b.stringValue { return a }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmph149ii9o.swift:23:19: error: binary operator '<' cannot be applied\
    \ to two '(Int) -> Value' operands\n    if a.intValue < b.intValue { return b\
    \ }\n       ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmph149ii9o.swift:24:19: error: binary\
    \ operator '>' cannot be applied to two '(Int) -> Value' operands\n    if a.intValue\
    \ > b.intValue { return a }\n       ~~~~~~~~~~ ^ ~~~~~~~~~~\n/tmp/tmph149ii9o.swift:25:22:\
    \ error: binary operator '<' cannot be applied to two '(Double) -> Value' operands\n\
    \    if a.doubleValue < b.doubleValue { return b }\n       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n\
    /tmp/tmph149ii9o.swift:26:22: error: binary operator '>' cannot be applied to\
    \ two '(Double) -> Value' operands\n    if a.doubleValue > b.doubleValue { return\
    \ a }\n       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n/tmp/tmph149ii9o.swift:27:22: error:\
    \ binary operator '<' cannot be applied to two '(String) -> Value' operands\n\
    \    if a.stringValue < b.stringValue { return b }\n       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n\
    /tmp/tmph149ii9o.swift:28:22: error: binary operator '>' cannot be applied to\
    \ two '(String) -> Value' operands\n    if a.stringValue > b.stringValue { return\
    \ a }\n       ~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    }\n \
    \   if a.doubleValue() < b.doubleValue() {\n        return a\n    } else if a.doubleValue()\
    \ > b.doubleValue() {\n        return b\n    }\n    if a.stringValue() < b.stringValue()\
    \ {\n        return a\n    } else if a.stringValue() > b.stringValue() {\n   \
    \     return b\n    }\n    if a.intValue() < b.intValue() {\n        return a\n\
    \    } else if a.intValue() > b.intValue() {\n        return b\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9bu4ih__.swift:25:8: error: enum case 'doubleValue' cannot be used\
    \ as an instance member\n    if a.doubleValue() < b.doubleValue() {\n       ^\n\
    \       Value\n/tmp/tmp9bu4ih__.swift:25:22: error: missing argument for parameter\
    \ #1 in call\n    if a.doubleValue() < b.doubleValue() {\n                   \
    \  ^\n                     <#Double#>\n/tmp/tmp9bu4ih__.swift:4:10: note: 'doubleValue'\
    \ declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmp9bu4ih__.swift:25:24:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n    if a.doubleValue() < b.doubleValue() {\n      \
    \                 ^\nSwift.Comparable:1:17: note: where 'Self' = 'Value'\npublic\
    \ protocol Comparable : Equatable {\n                ^\n/tmp/tmp9bu4ih__.swift:25:24:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    if a.doubleValue() < b.doubleValue() {\n                       ^\n/tmp/tmp9bu4ih__.swift:25:26:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ a.doubleValue() < b.doubleValue() {\n                         ^\n          \
    \               Value\n/tmp/tmp9bu4ih__.swift:25:40: error: missing argument for\
    \ parameter #1 in call\n    if a.doubleValue() < b.doubleValue() {\n         \
    \                              ^\n                                       <#Double#>\n\
    /tmp/tmp9bu4ih__.swift:4:10: note: 'doubleValue' declared here\n    case doubleValue(Double)\n\
    \         ^\n/tmp/tmp9bu4ih__.swift:27:29: error: missing argument for parameter\
    \ #1 in call\n    } else if a.doubleValue() > b.doubleValue() {\n            \
    \                ^\n                            <#Double#>\n/tmp/tmp9bu4ih__.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmp9bu4ih__.swift:27:15: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n    } else if a.doubleValue() > b.doubleValue() {\n    \
    \          ^\n              Value\n/tmp/tmp9bu4ih__.swift:27:31: error: referencing\
    \ operator function '>' on 'Comparable' requires that 'Value' confor"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(int(a)):\n\
    \        if let b = b.intValue(int(a)) {\n            return b\n        }\n  \
    \  case .doubleValue(double(a)):\n        if let b = b.doubleValue(double(a))\
    \ {\n            return b\n        }\n    case .stringValue(string(a)):\n    \
    \    if let b = b.stringValue(string(a)) {\n            return b\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0_s85qwa.swift:23:20: error: cannot find 'int' in scope\n    case\
    \ .intValue(int(a)):\n                   ^~~\n/tmp/tmp0_s85qwa.swift:27:23: error:\
    \ cannot find 'double' in scope\n    case .doubleValue(double(a)):\n         \
    \             ^~~~~~\n/tmp/tmp0_s85qwa.swift:31:23: error: cannot find 'string'\
    \ in scope\n    case .stringValue(string(a)):\n                      ^~~~~~\n\
    /tmp/tmp0_s85qwa.swift:24:31: error: cannot find 'int' in scope\n        if let\
    \ b = b.intValue(int(a)) {\n                              ^~~\n/tmp/tmp0_s85qwa.swift:24:20:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        if\
    \ let b = b.intValue(int(a)) {\n                   ^\n                   Value\n\
    /tmp/tmp0_s85qwa.swift:28:34: error: cannot find 'double' in scope\n        if\
    \ let b = b.doubleValue(double(a)) {\n                                 ^~~~~~\n\
    /tmp/tmp0_s85qwa.swift:28:20: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n        if let b = b.doubleValue(double(a)) {\n        \
    \           ^\n                   Value\n/tmp/tmp0_s85qwa.swift:32:34: error:\
    \ cannot find 'string' in scope\n        if let b = b.stringValue(string(a)) {\n\
    \                                 ^~~~~~\n/tmp/tmp0_s85qwa.swift:32:20: error:\
    \ enum case 'stringValue' cannot be used as an instance member\n        if let\
    \ b = b.stringValue(string(a)) {\n                   ^\n                   Value\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(_), .doubleValue(_),\
    \ .stringValue(_): return b\n    default: return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp0041y5fc/tmp0041y5fc.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24acde9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24acae0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24acae0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24acadf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0041y5fc                        0x000055aded35101a <unavailable> + 12314

    5    libc.so.6                          0x00002b24acfd5460 __libc_start_main +
    245

    6    tmp0041y5fc                        0x000055aded34f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as! Value {\n    case .intValue(n):\
    \ switch b as! Value {\n    case .intValue(n): return n > n ? .intValue(n) : .intValue(0)\n\
    \    case .stringValue(n): return b == .intValue(n) ? .intValue(n) : nil\n   \
    \ }\n    case .doubleValue(d): switch b as! Value {\n    case .doubleValue(d):\
    \ return d > d ? .doubleValue(d) : .doubleValue(0)\n    case .stringValue(n):\
    \ return b == .doubleValue(d) ? .doubleValue(d) : nil\n    }\n    case .stringValue(n):\
    \ return b == .stringValue(n) ? .stringValue(n) : nil\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmps4zbp8x1.swift:22:14: warning: forced cast of 'Value' to same type\
    \ has no effect\n    switch a as! Value {\n             ^~~~~~~~~~\n         \
    \    \n/tmp/tmps4zbp8x1.swift:23:20: error: cannot find 'n' in scope\n    case\
    \ .intValue(n): switch b as! Value {\n                   ^\n/tmp/tmps4zbp8x1.swift:27:23:\
    \ error: cannot find 'd' in scope\n    case .doubleValue(d): switch b as! Value\
    \ {\n                      ^\n/tmp/tmps4zbp8x1.swift:31:23: error: cannot find\
    \ 'n' in scope\n    case .stringValue(n): return b == .stringValue(n) ? .stringValue(n)\
    \ : nil\n                      ^\n/tmp/tmps4zbp8x1.swift:23:33: warning: forced\
    \ cast of 'Value' to same type has no effect\n    case .intValue(n): switch b\
    \ as! Value {\n                                ^~~~~~~~~~\n                  \
    \              \n/tmp/tmps4zbp8x1.swift:24:20: error: cannot find 'n' in scope\n\
    \    case .intValue(n): return n > n ? .intValue(n) : .intValue(0)\n         \
    \          ^\n/tmp/tmps4zbp8x1.swift:25:23: error: cannot find 'n' in scope\n\
    \    case .stringValue(n): return b == .intValue(n) ? .intValue(n) : nil\n   \
    \                   ^\n/tmp/tmps4zbp8x1.swift:24:31: error: cannot find 'n' in\
    \ scope\n    case .intValue(n): return n > n ? .intValue(n) : .intValue(0)\n \
    \                             ^\n/tmp/tmps4zbp8x1.swift:24:35: error: cannot find\
    \ 'n' in scope\n    case .intValue(n): return n > n ? .intValue(n) : .intValue(0)\n\
    \                                  ^\n/tmp/tmps4zbp8x1.swift:24:49: error: cannot\
    \ find 'n' in scope\n    case .intValue(n): return n > n ? .intValue(n) : .intValue(0)\n\
    \                                                ^\n/tmp/tmps4zbp8x1.swift:25:49:\
    \ error: cannot find 'n' in scope\n    case .stringValue(n): return b == .intValue(n)\
    \ ? .intValue(n) : nil\n                                                ^\n/tmp/tmps4zbp8x1.swift:25:64:\
    \ error: cannot find 'n' in scope\n    case .stringValue(n): return b == .intValue(n)\
    \ ? .intValue(n) : nil\n                                                     \
    \          ^\n/tmp/tmps4zbp8x1.swift:27:36: warning: forced cast of 'Value' to\
    \ same t"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(i): return\
    \ b == .intValue(i)\n    case .doubleValue(l): return b == .doubleValue(l)\n \
    \   case .stringValue(s): return b == .stringValue(s)\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp1pb0_h7t.swift:23:20: error: cannot find 'i' in scope\n    case\
    \ .intValue(i): return b == .intValue(i)\n                   ^\n/tmp/tmp1pb0_h7t.swift:24:23:\
    \ error: cannot find 'l' in scope\n    case .doubleValue(l): return b == .doubleValue(l)\n\
    \                      ^\n/tmp/tmp1pb0_h7t.swift:25:23: error: cannot find 's'\
    \ in scope\n    case .stringValue(s): return b == .stringValue(s)\n          \
    \            ^\n/tmp/tmp1pb0_h7t.swift:23:46: error: cannot find 'i' in scope\n\
    \    case .intValue(i): return b == .intValue(i)\n                           \
    \                  ^\n/tmp/tmp1pb0_h7t.swift:23:33: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n    case .intValue(i): return\
    \ b == .intValue(i)\n                              ~~^~~~~~~~~~~~~~~\n/tmp/tmp1pb0_h7t.swift:24:52:\
    \ error: cannot find 'l' in scope\n    case .doubleValue(l): return b == .doubleValue(l)\n\
    \                                                   ^\n/tmp/tmp1pb0_h7t.swift:24:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .doubleValue(l): return b == .doubleValue(l)\n                     \
    \            ~~^~~~~~~~~~~~~~~~~~\n/tmp/tmp1pb0_h7t.swift:25:52: error: cannot\
    \ find 's' in scope\n    case .stringValue(s): return b == .stringValue(s)\n \
    \                                                  ^\n/tmp/tmp1pb0_h7t.swift:25:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .stringValue(s): return b == .stringValue(s)\n                     \
    \            ~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let aIsDouble = a\n        as? ValueType\
    \ else { return nil }\n    if let bIsDouble = b\n        as? ValueType else {\
    \ return nil }\n    \n    var a: Value\n    var b: Value\n    \n    switch a.type\
    \ {\n    case .intValue:\n        a = aIsDouble\n        b = bIsDouble\n    case\
    \ .doubleValue:\n        a = aIsDouble\n        b = bIsDouble\n    case .stringValue:\n\
    \        a = aIsDouble\n        b = bIsDouble\n    }\n    \n    switch b.type\
    \ {\n    case .intValue:\n        a = a\n        b = bIsDouble\n    case .doubleValue:\n\
    \        a = a\n        b = bIsDouble\n    case .stringValue:\n        a = a\n\
    \        b = b\n    }\n    \n    if a == b {\n        return a\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpucwwcp6d.swift:23:23: error: unexpected 'else' immediately following\
    \ 'if' condition\n        as? ValueType else { return nil }\n                \
    \      ^\n/tmp/tmpucwwcp6d.swift:23:23: note: remove 'else' to execute the braced\
    \ block of statements when the condition is true\n        as? ValueType else {\
    \ return nil }\n                      ^~~~~\n                      \n/tmp/tmpucwwcp6d.swift:25:23:\
    \ error: unexpected 'else' immediately following 'if' condition\n        as? ValueType\
    \ else { return nil }\n                      ^\n/tmp/tmpucwwcp6d.swift:25:23:\
    \ note: remove 'else' to execute the braced block of statements when the condition\
    \ is true\n        as? ValueType else { return nil }\n                      ^~~~~\n\
    \                      \n/tmp/tmpucwwcp6d.swift:23:13: error: cannot find type\
    \ 'ValueType' in scope\n        as? ValueType else { return nil }\n          \
    \  ^~~~~~~~~\n/tmp/tmpucwwcp6d.swift:25:13: error: cannot find type 'ValueType'\
    \ in scope\n        as? ValueType else { return nil }\n            ^~~~~~~~~\n\
    /tmp/tmpucwwcp6d.swift:30:14: error: value of type 'Value' has no member 'type'\n\
    \    switch a.type {\n           ~ ^~~~\n/tmp/tmpucwwcp6d.swift:32:13: error:\
    \ cannot find 'aIsDouble' in scope\n        a = aIsDouble\n            ^~~~~~~~~\n\
    /tmp/tmpucwwcp6d.swift:33:13: error: cannot find 'bIsDouble' in scope\n      \
    \  b = bIsDouble\n            ^~~~~~~~~\n/tmp/tmpucwwcp6d.swift:35:13: error:\
    \ cannot find 'aIsDouble' in scope\n        a = aIsDouble\n            ^~~~~~~~~\n\
    /tmp/tmpucwwcp6d.swift:36:13: error: cannot find 'bIsDouble' in scope\n      \
    \  b = bIsDouble\n            ^~~~~~~~~\n/tmp/tmpucwwcp6d.swift:38:13: error:\
    \ cannot find 'aIsDouble' in scope\n        a = aIsDouble\n            ^~~~~~~~~\n\
    /tmp/tmpucwwcp6d.swift:39:13: error: cannot find 'bIsDouble' in scope\n      \
    \  b = bIsDouble\n            ^~~~~~~~~\n/tmp/tmpucwwcp6d.swift:42:14: error:\
    \ value of type 'Value' has no member 'type'\n    switch b.type {\n          \
    \ ~ ^~~~\n/tmp/tmpucwwcp6d.swift:44:11: error: assigning a variable to itself\n\
    \        a = a\n        ~ ^ ~\n/tmp/tmpucwwcp"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(i):\n     \
    \   if b == .intValue(i) {\n            return i\n        } else if b == .doubleValue(d)\
    \ {\n            return d\n        } else if b == .stringValue(str) {\n      \
    \      if str == \"nan\" {\n                return .stringValue(str)\n       \
    \     } else if str == \"inf\" {\n                return .stringValue(\"\\(-\\\
    Double.infinity)\")\n            } else if str == \"-inf\" {\n               \
    \ return .stringValue(\"\\(-\\Double.minusInfinity)\")\n            } else {\n\
    \                return .stringValue(str)\n            }\n        } else if b\
    \ == nil { return nil }\n    case .doubleValue(db):\n        if a == .doubleValue(db)\
    \ { return db }\n        if a == .intValue(i) { return nil }\n        if a ==\
    \ .stringValue(str) {\n            if str == \"nan\" { return .stringValue(str)\
    \ }\n            if str == \"inf\" { return .stringValue(\"\\(-\\Double.infinity)\"\
    ) }\n            if str == \"-inf\" { return .stringValue(\"\\(-\\Double.minusInfinity)\"\
    ) }\n            if str == \"-nan\" { return .stringValue(\"\\(-\\Double.nan)\"\
    ) }\n            if str == \"0\" { return .stringValue(\"0.0\") }\n          \
    \  if str == \"-0\" { return .stringValue(\"-0.0\") }\n            if str == \"\
    1\" { return .stringValue(\"1.0\") }\n            if str == \"-1\" { return .stringValue(\"\
    -1.0\") }\n            if str == \"2\" { return .stringValue(\"2.0\") }\n    \
    \        if str == \"-2\" { return .stringValue(\"-2.0\") }\n            if str\
    \ == \"3\" { return .stringValue(\"3.0\") }\n            if str == \"-3\" { return\
    \ .stringValue(\"-3.0\") }\n            if str == \"4\" { return .stringValue(\"\
    4.0\") }\n            if str == \"-4\" { return .stringValue(\"-4.0\") }\n   \
    \         if str == \"5\" { return .stringValue(\"5.0\") }\n            if str\
    \ == \"-5\" { return .stringValue(\"-5.0\") }\n            if str == \"6\" { return\
    \ .stringValue(\"6.0\") }\n            if str == \"-6\" { return .stringValue(\"\
    -6.0\") }\n            if str == \"7\" { return .stringValue(\"7.0\") }\n    \
    \        if str == \"-7\" { return .stringValue(\"-7.0\") }\n            if str\
    \ == \"8\" { return .stringValue(\"8.0\") }\n            if str == \"-8\" { return\
    \ .stringValue(\"-8.0\") }\n            if str == \"9\" { return .stringValue(\"\
    9.0\") }\n            if str == \"-9\" { return .stringValue(\"-9.0\") }\n   \
    \         if str == \"10\" { return .stringValue(\"10.0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpntntrcso.swift:67:50: error: unterminated string literal\n    \
    \        if str == \"10\" { return .stringValue(\"10.0\n                     \
    \                            ^\n/tmp/tmpntntrcso.swift:90:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpntntrcso.swift:42:35: note: to match this opening '{'\n\
    \        if a == .stringValue(str) {\n                                  ^\n/tmp/tmpntntrcso.swift:90:66:\
    \ error: expected '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpntntrcso.swift:22:14: note: to match this opening\
    \ '{'\n    switch a {\n             ^\n/tmp/tmpntntrcso.swift:90:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpntntrcso.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmpntntrcso.swift:23:20: error: cannot find 'i' in\
    \ scope\n    case .intValue(i):\n                   ^\n/tmp/tmpntntrcso.swift:39:23:\
    \ error: cannot find 'db' in scope\n    case .doubleValue(db):\n             \
    \         ^~\n/tmp/tmpntntrcso.swift:24:27: error: cannot find 'i' in scope\n\
    \        if b == .intValue(i) {\n                          ^\n/tmp/tmpntntrcso.swift:25:20:\
    \ error: cannot find 'i' in scope\n            return i\n                   ^\n\
    /tmp/tmpntntrcso.swift:26:37: error: cannot find 'd' in scope\n        } else\
    \ if b == .doubleValue(d) {\n                                    ^\n/tmp/tmpntntrcso.swift:27:20:\
    \ error: cannot find 'd' in scope\n            return d\n                   ^\n\
    /tmp/tmpntntrcso.swift:28:37: error: cannot find 'str' in scope\n        } else\
    \ if b == .stringValue(str) {\n                                    ^~~\n/tmp/tmpntntrcso.swift:"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(a), .intValue(b)):\n\
    \        return a\n    case (.doubleValue(a), .doubleValue(b)):\n        return\
    \ a\n    case (.stringValue(a), .stringValue(b)):\n        return a\n    case\
    \ (_, _):\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp6c07tf1f.swift:23:21: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case (.intValue(a), .intValue(b)):\n\
    \                    ^\n/tmp/tmp6c07tf1f.swift:25:24: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (.doubleValue(a),\
    \ .doubleValue(b)):\n                       ^\n/tmp/tmp6c07tf1f.swift:27:24: error:\
    \ expression pattern of type 'Value' cannot match values of type 'String'\n  \
    \  case (.stringValue(a), .stringValue(b)):\n                       ^\n/tmp/tmp6c07tf1f.swift:27:24:\
    \ note: overloads for '~=' exist with these partially matching parameter lists:\
    \ (Substring, String)\n    case (.stringValue(a), .stringValue(b)):\n        \
    \               ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    }\n \
    \   \n    if let a = a.doubleValue() {\n        if let b = b.doubleValue() {\n\
    \            if a > b {\n                return a\n            } else {\n    \
    \            return b\n            }\n        }\n    }\n    \n    if let a = a.intValue()\
    \ {\n        if let b = b.intValue() {\n            if a > b {\n             \
    \   return a\n            } else {\n                return b\n            }\n\
    \        }\n    }\n    \n    if let a = a.stringValue() {\n        if let b =\
    \ b.stringValue() {\n            if a == b {\n                return a\n     \
    \       } else {\n                return nil\n            }\n        }\n    }\n\
    \    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5zteeyvp.swift:26:30: error: missing argument for parameter #1\
    \ in call\n    if let a = a.doubleValue() {\n                             ^\n\
    \                             <#Double#>\n/tmp/tmp5zteeyvp.swift:4:10: note: 'doubleValue'\
    \ declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmp5zteeyvp.swift:26:16:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ let a = a.doubleValue() {\n               ^\n               Value\n/tmp/tmp5zteeyvp.swift:27:20:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  if let b = b.doubleValue() {\n                   ^\n                   Value\n\
    /tmp/tmp5zteeyvp.swift:27:34: error: missing argument for parameter #1 in call\n\
    \        if let b = b.doubleValue() {\n                                 ^\n  \
    \                               <#Double#>\n/tmp/tmp5zteeyvp.swift:4:10: note:\
    \ 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmp5zteeyvp.swift:36:27:\
    \ error: missing argument for parameter #1 in call\n    if let a = a.intValue()\
    \ {\n                          ^\n                          <#Int#>\n/tmp/tmp5zteeyvp.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmp5zteeyvp.swift:36:16:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ a = a.intValue() {\n               ^\n               Value\n/tmp/tmp5zteeyvp.swift:37:31:\
    \ error: missing argument for parameter #1 in call\n        if let b = b.intValue()\
    \ {\n                              ^\n                              <#Int#>\n\
    /tmp/tmp5zteeyvp.swift:3:10: note: 'intValue' declared here\n    case intValue(Int)\n\
    \         ^\n/tmp/tmp5zteeyvp.swift:37:20: error: enum case 'intValue' cannot\
    \ be used as an instance member\n        if let b = b.intValue() {\n         \
    \          ^\n                   Value\n/tmp/tmp5zteeyvp.swift:46:30: error: missing\
    \ argument for parameter #1 in call\n    if let a = a.stringValue() {\n      \
    \                       ^\n                             <#String#>\n/tmp/tmp5zteeyvp.swift:5:10:\
    \ note: 'stringValue' de"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let av = a.intValue\n    let bv = b.intValue\n\
    \    if av > bv {\n        return b\n    } else if bv > av {\n        return a\n\
    \    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppglk0g9b.swift:22:14: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    let av = a.intValue\n             ^\n           \
    \  Value\n/tmp/tmppglk0g9b.swift:23:14: error: enum case 'intValue' cannot be\
    \ used as an instance member\n    let bv = b.intValue\n             ^\n      \
    \       Value\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a is IntValue {\n        return b is IntValue\
    \ ? a : b\n    } else if b is IntValue {\n        return a\n    } else if a is\
    \ DoubleValue {\n        return b is DoubleValue ? a : b\n    } else if b is DoubleValue\
    \ {\n        return a\n    } else if a is StringValue {\n        return b is StringValue\
    \ ? a : b\n    } else if b is StringValue {\n        return nil\n    } else {\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmparelo9r4.swift:22:13: error: cannot find type 'IntValue' in scope\n\
    \    if a is IntValue {\n            ^~~~~~~~\n/tmp/tmparelo9r4.swift:23:21: error:\
    \ cannot find type 'IntValue' in scope\n        return b is IntValue ? a : b\n\
    \                    ^~~~~~~~\n/tmp/tmparelo9r4.swift:24:20: error: cannot find\
    \ type 'IntValue' in scope\n    } else if b is IntValue {\n                  \
    \ ^~~~~~~~\n/tmp/tmparelo9r4.swift:26:20: error: cannot find type 'DoubleValue'\
    \ in scope\n    } else if a is DoubleValue {\n                   ^~~~~~~~~~~\n\
    /tmp/tmparelo9r4.swift:27:21: error: cannot find type 'DoubleValue' in scope\n\
    \        return b is DoubleValue ? a : b\n                    ^~~~~~~~~~~\n/tmp/tmparelo9r4.swift:28:20:\
    \ error: cannot find type 'DoubleValue' in scope\n    } else if b is DoubleValue\
    \ {\n                   ^~~~~~~~~~~\n/tmp/tmparelo9r4.swift:30:20: error: cannot\
    \ find type 'StringValue' in scope\n    } else if a is StringValue {\n       \
    \            ^~~~~~~~~~~\n/tmp/tmparelo9r4.swift:31:21: error: cannot find type\
    \ 'StringValue' in scope\n        return b is StringValue ? a : b\n          \
    \          ^~~~~~~~~~~\n/tmp/tmparelo9r4.swift:32:20: error: cannot find type\
    \ 'StringValue' in scope\n    } else if b is StringValue {\n                 \
    \  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue: Value = a.value\n    var bValue:\
    \ Value = b.value\n    if aValue is IntValue {\n        if bValue is DoubleValue\
    \ {\n            aValue = bValue\n        }\n        else if bValue is StringValue\
    \ {\n            aValue = .intValue(Int(bValue.stringValue))\n        }\n    }\n\
    \    else if aValue is DoubleValue {\n        if bValue is IntValue {\n      \
    \      aValue = bValue\n        }\n        else if bValue is StringValue {\n \
    \           aValue = .doubleValue(Double(bValue.stringValue))\n        }\n   \
    \ }\n    else if aValue is StringValue {\n        if bValue is IntValue {\n  \
    \          aValue = .stringValue(bValue.stringValue)\n        }\n        else\
    \ if bValue is DoubleValue {\n            aValue = .stringValue(bValue.stringValue)\n\
    \        }\n    }\n    \n    if aValue == bValue {\n        return nil\n    }\n\
    \    \n    return aValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfcdqkemf.swift:22:27: error: value of type 'Value' has no member\
    \ 'value'\n    var aValue: Value = a.value\n                        ~ ^~~~~\n\
    /tmp/tmpfcdqkemf.swift:23:27: error: value of type 'Value' has no member 'value'\n\
    \    var bValue: Value = b.value\n                        ~ ^~~~~\n/tmp/tmpfcdqkemf.swift:24:18:\
    \ error: cannot find type 'IntValue' in scope\n    if aValue is IntValue {\n \
    \                ^~~~~~~~\n/tmp/tmpfcdqkemf.swift:25:22: error: cannot find type\
    \ 'DoubleValue' in scope\n        if bValue is DoubleValue {\n               \
    \      ^~~~~~~~~~~\n/tmp/tmpfcdqkemf.swift:28:27: error: cannot find type 'StringValue'\
    \ in scope\n        else if bValue is StringValue {\n                        \
    \  ^~~~~~~~~~~\n/tmp/tmpfcdqkemf.swift:29:32: error: no exact matches in call\
    \ to initializer \n            aValue = .intValue(Int(bValue.stringValue))\n \
    \                              ^\n/tmp/tmpfcdqkemf.swift:29:32: note: found candidate\
    \ with type '(@escaping (String) -> Value) -> Int'\n            aValue = .intValue(Int(bValue.stringValue))\n\
    \                               ^\n/tmp/tmpfcdqkemf.swift:32:23: error: cannot\
    \ find type 'DoubleValue' in scope\n    else if aValue is DoubleValue {\n    \
    \                  ^~~~~~~~~~~\n/tmp/tmpfcdqkemf.swift:33:22: error: cannot find\
    \ type 'IntValue' in scope\n        if bValue is IntValue {\n                \
    \     ^~~~~~~~\n/tmp/tmpfcdqkemf.swift:36:27: error: cannot find type 'StringValue'\
    \ in scope\n        else if bValue is StringValue {\n                        \
    \  ^~~~~~~~~~~\n/tmp/tmpfcdqkemf.swift:37:35: error: no exact matches in call\
    \ to initializer \n            aValue = .doubleValue(Double(bValue.stringValue))\n\
    \                                  ^\n/tmp/tmpfcdqkemf.swift:37:35: note: found\
    \ candidate with type '(@escaping (String) -> Value) -> Double'\n            aValue\
    \ = .doubleValue(Double(bValue.stringValue))\n                               \
    \   ^\n/tmp/tmpfcdqkemf.swift:40:23: error: cannot find type 'StringValue' in\
    \ scope\n    else if aValue is StringValue {\n                      ^~~~~~~~~~~\n\
    /tmp/tmpfc"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    }\n \
    \   if let aInt = a.intValue, bInt = b.intValue {\n        if aInt > bInt {\n\
    \            return a\n        }\n        return b\n    }\n    if let aDouble\
    \ = a.doubleValue, bDouble = b.doubleValue {\n        if aDouble > bDouble {\n\
    \            return a\n        }\n        return b\n    }\n    if let aString\
    \ = a.stringValue, bString = b.stringValue {\n        let aStringSlice = String(aString)\n\
    \        let bStringSlice = String(bString)\n        if aString > bString {\n\
    \            return a\n        }\n        if aStringSlice == bStringSlice {\n\
    \            return a\n        }\n        return b\n    }\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4gww71sp.swift:25:31: error: expected 'let' in conditional\n  \
    \  if let aInt = a.intValue, bInt = b.intValue {\n                           \
    \   ^\n                              let \n/tmp/tmp4gww71sp.swift:31:37: error:\
    \ expected 'let' in conditional\n    if let aDouble = a.doubleValue, bDouble =\
    \ b.doubleValue {\n                                    ^\n                   \
    \                 let \n/tmp/tmp4gww71sp.swift:37:37: error: expected 'let' in\
    \ conditional\n    if let aString = a.stringValue, bString = b.stringValue {\n\
    \                                    ^\n                                    let\
    \ \n/tmp/tmp4gww71sp.swift:25:19: error: enum case 'intValue' cannot be used as\
    \ an instance member\n    if let aInt = a.intValue, bInt = b.intValue {\n    \
    \              ^\n                  Value\n/tmp/tmp4gww71sp.swift:25:38: error:\
    \ enum case 'intValue' cannot be used as an instance member\n    if let aInt =\
    \ a.intValue, bInt = b.intValue {\n                                     ^\n  \
    \                                   Value\n/tmp/tmp4gww71sp.swift:31:22: error:\
    \ enum case 'doubleValue' cannot be used as an instance member\n    if let aDouble\
    \ = a.doubleValue, bDouble = b.doubleValue {\n                     ^\n       \
    \              Value\n/tmp/tmp4gww71sp.swift:31:47: error: enum case 'doubleValue'\
    \ cannot be used as an instance member\n    if let aDouble = a.doubleValue, bDouble\
    \ = b.doubleValue {\n                                              ^\n       \
    \                                       Value\n/tmp/tmp4gww71sp.swift:37:22: error:\
    \ enum case 'stringValue' cannot be used as an instance member\n    if let aString\
    \ = a.stringValue, bString = b.stringValue {\n                     ^\n       \
    \              Value\n/tmp/tmp4gww71sp.swift:37:47: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n    if let aString = a.stringValue, bString\
    \ = b.stringValue {\n                                              ^\n       \
    \                                       Value\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(_): return\
    \ b == .intValue(a)\n    case .doubleValue(_): return b == .doubleValue(a)\n \
    \   case .stringValue(_): return b == .stringValue(a)\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwj11mh_n.swift:23:33: error: cannot convert return expression of\
    \ type 'Bool' to return type 'Value?'\n    case .intValue(_): return b == .intValue(a)\n\
    \                              ~~^~~~~~~~~~~~~~~\n/tmp/tmpwj11mh_n.swift:23:46:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Int'\n\
    \    case .intValue(_): return b == .intValue(a)\n                           \
    \                  ^\n/tmp/tmpwj11mh_n.swift:24:36: error: cannot convert return\
    \ expression of type 'Bool' to return type 'Value?'\n    case .doubleValue(_):\
    \ return b == .doubleValue(a)\n                                 ~~^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwj11mh_n.swift:24:52: error: cannot convert value of type 'Value' to expected\
    \ argument type 'Double'\n    case .doubleValue(_): return b == .doubleValue(a)\n\
    \                                                   ^\n/tmp/tmpwj11mh_n.swift:25:36:\
    \ error: cannot convert return expression of type 'Bool' to return type 'Value?'\n\
    \    case .stringValue(_): return b == .stringValue(a)\n                     \
    \            ~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpwj11mh_n.swift:25:52: error: cannot\
    \ convert value of type 'Value' to expected argument type 'String'\n    case .stringValue(_):\
    \ return b == .stringValue(a)\n                                              \
    \     ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   return .intValue(max(b.intValue(), Int64.max))\n    case .doubleValue(_):\n\
    \        return .doubleValue(max(b.doubleValue(), Double.max))\n    case .stringValue(_):\n\
    \        return .stringValue(max(b.stringValue(), a.stringValue()))\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdypj5us3.swift:24:26: error: cannot convert value of type 'Int64'\
    \ to expected argument type 'Int'\n        return .intValue(max(b.intValue(),\
    \ Int64.max))\n                         ^\n                         Int(     \
    \                   )\n/tmp/tmpdypj5us3.swift:24:32: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int64'\n        return .intValue(max(b.intValue(),\
    \ Int64.max))\n                               ^\n/tmp/tmpdypj5us3.swift:24:30:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        return\
    \ .intValue(max(b.intValue(), Int64.max))\n                             ^\n  \
    \                           Value\n/tmp/tmpdypj5us3.swift:24:41: error: missing\
    \ argument for parameter #1 in call\n        return .intValue(max(b.intValue(),\
    \ Int64.max))\n                                        ^\n                   \
    \                     <#Int#>\n/tmp/tmpdypj5us3.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmpdypj5us3.swift:26:35: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Double'\n  \
    \      return .doubleValue(max(b.doubleValue(), Double.max))\n               \
    \                   ^\n/tmp/tmpdypj5us3.swift:26:47: error: missing argument for\
    \ parameter #1 in call\n        return .doubleValue(max(b.doubleValue(), Double.max))\n\
    \                                              ^\n                           \
    \                   <#Double#>\n/tmp/tmpdypj5us3.swift:4:10: note: 'doubleValue'\
    \ declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmpdypj5us3.swift:26:33:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  return .doubleValue(max(b.doubleValue(), Double.max))\n                   \
    \             ^\n                                Value\n/tmp/tmpdypj5us3.swift:26:57:\
    \ error: type 'Double' has no member 'max'\n        return .doubleValue(max(b.doubleValue(),\
    \ Double.max))\n                                                 ~~~~~~ ^~~\n\
    /tmp/tmpdypj5us3.swift:28:29: error: cannot convert value of type 'Value' to expected\
    \ argument"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(i): return\
    \ b == .intValue(i) ? .intValue(i) : nil\n    case .doubleValue(d): return b ==\
    \ .doubleValue(d) ? .doubleValue(d) : nil\n    case .stringValue(str): return\
    \ b == .stringValue(str) ? .stringValue(str) : nil\n    }\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9e113sfv.swift:23:20: error: cannot find 'i' in scope\n    case\
    \ .intValue(i): return b == .intValue(i) ? .intValue(i) : nil\n              \
    \     ^\n/tmp/tmp9e113sfv.swift:24:23: error: cannot find 'd' in scope\n    case\
    \ .doubleValue(d): return b == .doubleValue(d) ? .doubleValue(d) : nil\n     \
    \                 ^\n/tmp/tmp9e113sfv.swift:25:23: error: cannot find 'str' in\
    \ scope\n    case .stringValue(str): return b == .stringValue(str) ? .stringValue(str)\
    \ : nil\n                      ^~~\n/tmp/tmp9e113sfv.swift:23:46: error: cannot\
    \ find 'i' in scope\n    case .intValue(i): return b == .intValue(i) ? .intValue(i)\
    \ : nil\n                                             ^\n/tmp/tmp9e113sfv.swift:23:61:\
    \ error: cannot find 'i' in scope\n    case .intValue(i): return b == .intValue(i)\
    \ ? .intValue(i) : nil\n                                                     \
    \       ^\n/tmp/tmp9e113sfv.swift:24:52: error: cannot find 'd' in scope\n   \
    \ case .doubleValue(d): return b == .doubleValue(d) ? .doubleValue(d) : nil\n\
    \                                                   ^\n/tmp/tmp9e113sfv.swift:24:70:\
    \ error: cannot find 'd' in scope\n    case .doubleValue(d): return b == .doubleValue(d)\
    \ ? .doubleValue(d) : nil\n                                                  \
    \                   ^\n/tmp/tmp9e113sfv.swift:25:54: error: cannot find 'str'\
    \ in scope\n    case .stringValue(str): return b == .stringValue(str) ? .stringValue(str)\
    \ : nil\n                                                     ^~~\n/tmp/tmp9e113sfv.swift:25:74:\
    \ error: cannot find 'str' in scope\n    case .stringValue(str): return b == .stringValue(str)\
    \ ? .stringValue(str) : nil\n                                                \
    \                         ^~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(aValue): return\
    \ .intValue(bValue)\n    case .doubleValue(aValue): return .doubleValue(bValue)\n\
    \    case .stringValue(aValue): return .stringValue(bValue)\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwqj98j0c.swift:23:20: error: cannot find 'aValue' in scope\n  \
    \  case .intValue(aValue): return .intValue(bValue)\n                   ^~~~~~\n\
    /tmp/tmpwqj98j0c.swift:24:23: error: cannot find 'aValue' in scope\n    case .doubleValue(aValue):\
    \ return .doubleValue(bValue)\n                      ^~~~~~\n/tmp/tmpwqj98j0c.swift:25:23:\
    \ error: cannot find 'aValue' in scope\n    case .stringValue(aValue): return\
    \ .stringValue(bValue)\n                      ^~~~~~\n/tmp/tmpwqj98j0c.swift:23:46:\
    \ error: cannot find 'bValue' in scope\n    case .intValue(aValue): return .intValue(bValue)\n\
    \                                             ^~~~~~\n/tmp/tmpwqj98j0c.swift:24:52:\
    \ error: cannot find 'bValue' in scope\n    case .doubleValue(aValue): return\
    \ .doubleValue(bValue)\n                                                   ^~~~~~\n\
    /tmp/tmpwqj98j0c.swift:25:52: error: cannot find 'bValue' in scope\n    case .stringValue(aValue):\
    \ return .stringValue(bValue)\n                                              \
    \     ^~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   switch b {\n        case .intValue(_):\n            return a\n        case\
    \ .doubleValue(_):\n            return b\n        case .stringValue(_):\n    \
    \        return a\n        }\n    case .doubleValue(_):\n        switch b {\n\
    \        case .intValue(_):\n            return a\n        case .doubleValue(_):\n\
    \            return b\n        case .stringValue(_):\n            return a\n \
    \       }\n    case .stringValue(_):\n        switch b {\n        case .intValue(_):\n\
    \            return a\n        case .doubleValue(_):\n            return b\n \
    \       case .stringValue(_):\n            return a\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp4q3sruen/tmp4q3sruen.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acedcac7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acedc7beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acedc7be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acedc7bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4q3sruen                        0x0000555b18ceaa56 <unavailable> + 6742

    5    libc.so.6                          0x00002acedccb3460 __libc_start_main +
    245

    6    tmp4q3sruen                        0x0000555b18cea499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (Value.intValue(a),\
    \ Value.intValue(b)):\n        return Value.intValue(max(Int(a), Int(b)))\n  \
    \  case (Value.doubleValue(a), Value.doubleValue(b)):\n        return Value.doubleValue(max(Double(a),\
    \ Double(b)))\n    case (Value.stringValue(a), Value.stringValue(b)):\n      \
    \  return Value.stringValue(max(String(a), String(b)))\n    default:\n       \
    \ return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpq1ipc4nx.swift:23:26: error: expression pattern of type 'Value'\
    \ cannot match values of type 'Int'\n    case (Value.intValue(a), Value.intValue(b)):\n\
    \                         ^\n/tmp/tmpq1ipc4nx.swift:25:29: error: expression pattern\
    \ of type 'Value' cannot match values of type 'Double'\n    case (Value.doubleValue(a),\
    \ Value.doubleValue(b)):\n                            ^\n/tmp/tmpq1ipc4nx.swift:27:29:\
    \ error: expression pattern of type 'Value' cannot match values of type 'String'\n\
    \    case (Value.stringValue(a), Value.stringValue(b)):\n                    \
    \        ^\n/tmp/tmpq1ipc4nx.swift:27:29: note: overloads for '~=' exist with\
    \ these partially matching parameter lists: (Substring, String)\n    case (Value.stringValue(a),\
    \ Value.stringValue(b)):\n                            ^\n/tmp/tmpq1ipc4nx.swift:24:35:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \        return Value.intValue(max(Int(a), Int(b)))\n                        \
    \          ^\nSwift.SignedInteger:2:23: note: where 'T' = 'Value'\n    @inlinable\
    \ public init<T>(_ source: T) where T : BinaryInteger\n                      ^\n\
    /tmp/tmpq1ipc4nx.swift:24:43: error: no exact matches in call to initializer \n\
    \        return Value.intValue(max(Int(a), Int(b)))\n                        \
    \                  ^\n/tmp/tmpq1ipc4nx.swift:24:43: note: found candidate with\
    \ type '(Value) -> Int'\n        return Value.intValue(max(Int(a), Int(b)))\n\
    \                                          ^\n/tmp/tmpq1ipc4nx.swift:26:49: error:\
    \ no exact matches in call to initializer \n        return Value.doubleValue(max(Double(a),\
    \ Double(b)))\n                                                ^\n/tmp/tmpq1ipc4nx.swift:26:49:\
    \ note: found candidate with type '(Value) -> Double'\n        return Value.doubleValue(max(Double(a),\
    \ Double(b)))\n                                                ^\n/tmp/tmpq1ipc4nx.swift:26:38:\
    \ error: initializer 'init(_:)' requires that 'Value' conform to 'BinaryInteger'\n\
    \        return Value.doubleValue(max(Double(a), Double(b)))\n               \
    \               "
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aIsInt = a.typeIsInt()\n    let bIsInt\
    \ = b.typeIsInt()\n\n    let aIsDouble = a.typeIsDouble()\n    let bIsDouble =\
    \ b.typeIsDouble()\n\n    let aIsString = a.typeIsString()\n    let bIsString\
    \ = b.typeIsString()\n\n    if aIsInt && bIsInt {\n        return max(a, max)(b,\
    \ max(a, b))\n    } else if aIsInt || bIsInt {\n        return max(a, min)(b,\
    \ min(a, b))\n    } else if aIsDouble && bIsDouble {\n        return max(a, max)(b,\
    \ max(a, b))\n    } else if aIsDouble || bIsDouble {\n        return max(a, min)(b,\
    \ min(a, b))\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppo5skz_t.swift:22:20: error: value of type 'Value' has no member\
    \ 'typeIsInt'\n    let aIsInt = a.typeIsInt()\n                 ~ ^~~~~~~~~\n\
    /tmp/tmppo5skz_t.swift:23:20: error: value of type 'Value' has no member 'typeIsInt'\n\
    \    let bIsInt = b.typeIsInt()\n                 ~ ^~~~~~~~~\n/tmp/tmppo5skz_t.swift:25:23:\
    \ error: value of type 'Value' has no member 'typeIsDouble'\n    let aIsDouble\
    \ = a.typeIsDouble()\n                    ~ ^~~~~~~~~~~~\n/tmp/tmppo5skz_t.swift:26:23:\
    \ error: value of type 'Value' has no member 'typeIsDouble'\n    let bIsDouble\
    \ = b.typeIsDouble()\n                    ~ ^~~~~~~~~~~~\n/tmp/tmppo5skz_t.swift:28:23:\
    \ error: value of type 'Value' has no member 'typeIsString'\n    let aIsString\
    \ = a.typeIsString()\n                    ~ ^~~~~~~~~~~~\n/tmp/tmppo5skz_t.swift:29:23:\
    \ error: value of type 'Value' has no member 'typeIsString'\n    let bIsString\
    \ = b.typeIsString()\n                    ~ ^~~~~~~~~~~~\n/tmp/tmppo5skz_t.swift:32:16:\
    \ error: type '(Value, Value) -> Value' cannot conform to 'Comparable'\n     \
    \   return max(a, max)(b, max(a, b))\n               ^\n/tmp/tmppo5skz_t.swift:32:16:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        return max(a, max)(b, max(a, b))\n               ^\n/tmp/tmppo5skz_t.swift:32:16:\
    \ note: required by global function 'max' where 'T' = '(Value, Value) -> Value'\n\
    \        return max(a, max)(b, max(a, b))\n               ^\n/tmp/tmppo5skz_t.swift:32:20:\
    \ error: cannot convert value of type 'Value' to expected argument type '(Value,\
    \ Value) -> Value'\n        return max(a, max)(b, max(a, b))\n               \
    \    ^\n/tmp/tmppo5skz_t.swift:34:16: error: type '(Value, Value) -> Value' cannot\
    \ conform to 'Comparable'\n        return max(a, min)(b, min(a, b))\n        \
    \       ^\n/tmp/tmppo5skz_t.swift:34:16: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n        return max(a, min)(b, min(a,\
    \ b))\n               ^\n/tmp/tmppo5skz_t.swift:34:16: note: required by global\
    \ function 'max' where 'T' = '(Value, Value) -> V"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(aInt), .intValue(bInt):\n\
    \        if aInt.compare(bInt) == .orderedSame {\n            return a\n     \
    \   } else {\n            return b\n        }\n    case .doubleValue(aDouble),\
    \ .doubleValue(bDouble):\n        if aDouble.compare(bDouble) == .orderedSame\
    \ {\n            return a\n        } else {\n            return b\n        }\n\
    \    case .stringValue(aString), .stringValue(bString):\n        if aString.compare(bString)\
    \ == .orderedSame {\n            return a\n        } else {\n            return\
    \ b\n        }\n    default:\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpgc3nmw08.swift:23:20: error: cannot find 'aInt' in scope\n    case\
    \ .intValue(aInt), .intValue(bInt):\n                   ^~~~\n/tmp/tmpgc3nmw08.swift:23:37:\
    \ error: cannot find 'bInt' in scope\n    case .intValue(aInt), .intValue(bInt):\n\
    \                                    ^~~~\n/tmp/tmpgc3nmw08.swift:29:23: error:\
    \ cannot find 'aDouble' in scope\n    case .doubleValue(aDouble), .doubleValue(bDouble):\n\
    \                      ^~~~~~~\n/tmp/tmpgc3nmw08.swift:29:46: error: cannot find\
    \ 'bDouble' in scope\n    case .doubleValue(aDouble), .doubleValue(bDouble):\n\
    \                                             ^~~~~~~\n/tmp/tmpgc3nmw08.swift:35:23:\
    \ error: cannot find 'aString' in scope\n    case .stringValue(aString), .stringValue(bString):\n\
    \                      ^~~~~~~\n/tmp/tmpgc3nmw08.swift:35:46: error: cannot find\
    \ 'bString' in scope\n    case .stringValue(aString), .stringValue(bString):\n\
    \                                             ^~~~~~~\n/tmp/tmpgc3nmw08.swift:24:12:\
    \ error: cannot find 'aInt' in scope\n        if aInt.compare(bInt) == .orderedSame\
    \ {\n           ^~~~\n/tmp/tmpgc3nmw08.swift:24:25: error: cannot find 'bInt'\
    \ in scope\n        if aInt.compare(bInt) == .orderedSame {\n                \
    \        ^~~~\n/tmp/tmpgc3nmw08.swift:30:12: error: cannot find 'aDouble' in scope\n\
    \        if aDouble.compare(bDouble) == .orderedSame {\n           ^~~~~~~\n/tmp/tmpgc3nmw08.swift:30:28:\
    \ error: cannot find 'bDouble' in scope\n        if aDouble.compare(bDouble) ==\
    \ .orderedSame {\n                           ^~~~~~~\n/tmp/tmpgc3nmw08.swift:36:12:\
    \ error: cannot find 'aString' in scope\n        if aString.compare(bString) ==\
    \ .orderedSame {\n           ^~~~~~~\n/tmp/tmpgc3nmw08.swift:36:28: error: cannot\
    \ find 'bString' in scope\n        if aString.compare(bString) == .orderedSame\
    \ {\n                           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    // Get the type of the largest type\n\
    \    let smallestType = min(type(of: a), type(of: b))\n    \n    // Check if one\
    \ of the types is float\n    if smallestType == Float.self {\n        // Check\
    \ if the types are equal\n        \n        // Cast the float to a Double\n  \
    \      let aDouble = a.doubleValue\n        let bDouble = b.doubleValue\n    \
    \    \n        // If the values are equal, return it\n        if aDouble == bDouble\
    \ {\n            return a\n        }\n    }\n    \n    // Check if the types are\
    \ equal\n    if smallestType == Double.self {\n        // Cast the double to a\
    \ Int\n        let aInt = a.intValue\n        let bInt = b.intValue\n        \n\
    \        // If the values are equal, return it\n        if aInt == bInt {\n  \
    \          return a\n        }\n    }\n    \n    // Check if the types are equal\n\
    \    if smallestType == Int.self {\n        // Cast the int to a String\n    \
    \    let aString = a.stringValue\n        let bString = b.stringValue\n      \
    \  \n        // If the values are equal, return it\n        if aString == bString\
    \ {\n            return a\n        }\n    }\n    \n    // If the types are equal,\
    \ return nil\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp031wlfqa.swift:24:24: error: type 'Value.Type' cannot conform to\
    \ 'Comparable'\n    let smallestType = min(type(of: a), type(of: b))\n       \
    \                ^\n/tmp/tmp031wlfqa.swift:24:24: note: only concrete types such\
    \ as structs, enums and classes can conform to protocols\n    let smallestType\
    \ = min(type(of: a), type(of: b))\n                       ^\n/tmp/tmp031wlfqa.swift:24:24:\
    \ note: required by global function 'min' where 'T' = 'Value.Type'\n    let smallestType\
    \ = min(type(of: a), type(of: b))\n                       ^\n/tmp/tmp031wlfqa.swift:31:23:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \  let aDouble = a.doubleValue\n                      ^\n                    \
    \  Value\n/tmp/tmp031wlfqa.swift:32:23: error: enum case 'doubleValue' cannot\
    \ be used as an instance member\n        let bDouble = b.doubleValue\n       \
    \               ^\n                      Value\n/tmp/tmp031wlfqa.swift:43:20:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        let\
    \ aInt = a.intValue\n                   ^\n                   Value\n/tmp/tmp031wlfqa.swift:44:20:\
    \ error: enum case 'intValue' cannot be used as an instance member\n        let\
    \ bInt = b.intValue\n                   ^\n                   Value\n/tmp/tmp031wlfqa.swift:55:23:\
    \ error: enum case 'stringValue' cannot be used as an instance member\n      \
    \  let aString = a.stringValue\n                      ^\n                    \
    \  Value\n/tmp/tmp031wlfqa.swift:56:23: error: enum case 'stringValue' cannot\
    \ be used as an instance member\n        let bString = b.stringValue\n       \
    \               ^\n                      Value\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if let aInt = a.intValue() { return aInt >\
    \ b.intValue() }\n    if let aDouble = a.doubleValue() { return aDouble > b.doubleValue()\
    \ }\n    if let aString = a.stringValue() { return aString > b.stringValue() }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjbqfyy2l.swift:22:30: error: missing argument for parameter #1\
    \ in call\n    if let aInt = a.intValue() { return aInt > b.intValue() }\n   \
    \                          ^\n                             <#Int#>\n/tmp/tmpjbqfyy2l.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpjbqfyy2l.swift:22:19:\
    \ error: enum case 'intValue' cannot be used as an instance member\n    if let\
    \ aInt = a.intValue() { return aInt > b.intValue() }\n                  ^\n  \
    \                Value\n/tmp/tmpjbqfyy2l.swift:22:46: error: binary operator '>'\
    \ cannot be applied to operands of type '_' and 'Value'\n    if let aInt = a.intValue()\
    \ { return aInt > b.intValue() }\n                                        ~~~~\
    \ ^ ~~~~~~~~~~~~\n/tmp/tmpjbqfyy2l.swift:22:46: error: cannot convert return expression\
    \ of type 'Bool' to return type 'Value?'\n    if let aInt = a.intValue() { return\
    \ aInt > b.intValue() }\n                                        ~~~~~^~~~~~~~~~~~~~\n\
    /tmp/tmpjbqfyy2l.swift:22:59: error: missing argument for parameter #1 in call\n\
    \    if let aInt = a.intValue() { return aInt > b.intValue() }\n             \
    \                                             ^\n                            \
    \                              <#Int#>\n/tmp/tmpjbqfyy2l.swift:3:10: note: 'intValue'\
    \ declared here\n    case intValue(Int)\n         ^\n/tmp/tmpjbqfyy2l.swift:23:22:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    if\
    \ let aDouble = a.doubleValue() { return aDouble > b.doubleValue() }\n       \
    \              ^\n                     Value\n/tmp/tmpjbqfyy2l.swift:23:36: error:\
    \ missing argument for parameter #1 in call\n    if let aDouble = a.doubleValue()\
    \ { return aDouble > b.doubleValue() }\n                                   ^\n\
    \                                   <#Double#>\n/tmp/tmpjbqfyy2l.swift:4:10: note:\
    \ 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n/tmp/tmpjbqfyy2l.swift:23:55:\
    \ error: binary operator '>' cannot be applied to operands of type '_' and 'Value'\n\
    \    if let aDouble = a.doubleValue() { return a"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_):\n     \
    \   if b == .intValue(_) {\n            return a\n        }\n    case .doubleValue(_):\n\
    \        if b == .doubleValue(_) {\n            return a\n        }\n    case\
    \ .stringValue(_):\n        if b == .stringValue(_) {\n            return a\n\
    \        }\n    }\n    if let b = b, b.isGreater(a) {\n        return b\n    }\
    \ else {\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp89d4gkau.swift:24:27: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n        if b == .intValue(_) {\n        \
    \                  ^\n/tmp/tmp89d4gkau.swift:28:30: error: '_' can only appear\
    \ in a pattern or on the left side of an assignment\n        if b == .doubleValue(_)\
    \ {\n                             ^\n/tmp/tmp89d4gkau.swift:32:30: error: '_'\
    \ can only appear in a pattern or on the left side of an assignment\n        if\
    \ b == .stringValue(_) {\n                             ^\n/tmp/tmp89d4gkau.swift:36:21:\
    \ error: value of type 'Value' has no member 'isGreater'\n    if let b = b, b.isGreater(a)\
    \ {\n                  ~ ^~~~~~~~~\n/tmp/tmp89d4gkau.swift:36:8: error: initializer\
    \ for conditional binding must have Optional type, not 'Value'\n    if let b =\
    \ b, b.isGreater(a) {\n       ^       ~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    }\n\n\
    \    switch a as? Int:\n    case let integerValue as Int:\n        switch b as?\
    \ Int:\n        case let integerValue as Int:\n            return integerValue\
    \ > integerValue\n        case let doubleValue as Double:\n            return\
    \ doubleValue > doubleValue\n        default:\n            return nil\n      \
    \  }\n    case let doubleValue as Double:\n        switch b as? Int:\n       \
    \ case let integerValue as Int:\n            return integerValue > integerValue\n\
    \        case let doubleValue as Double:\n            return doubleValue > doubleValue\n\
    \        default:\n            return nil\n        }\n    case let stringValue\
    \ as String:\n        switch b as? Int:\n        case let integerValue as Int:\n\
    \            return integerValue > integerValue\n        case let stringValue\
    \ as String:\n            return stringValue > stringValue\n        default:\n\
    \            return nil\n        }\n    default:\n        return nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpk4s1guc9.swift:26:21: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as? Int:\n                    ^\n/tmp/tmpk4s1guc9.swift:26:21:\
    \ error: consecutive statements on a line must be separated by ';'\n    switch\
    \ a as? Int:\n                    ^\n                    ;\n/tmp/tmpk4s1guc9.swift:26:21:\
    \ error: expected expression\n    switch a as? Int:\n                    ^\n/tmp/tmpk4s1guc9.swift:27:5:\
    \ error: 'case' label can only appear inside a 'switch' statement\n    case let\
    \ integerValue as Int:\n    ^\n/tmp/tmpk4s1guc9.swift:28:25: error: expected '{'\
    \ after 'switch' subject expression\n        switch b as? Int:\n             \
    \           ^\n/tmp/tmpk4s1guc9.swift:28:25: error: consecutive statements on\
    \ a line must be separated by ';'\n        switch b as? Int:\n               \
    \         ^\n                        ;\n/tmp/tmpk4s1guc9.swift:28:25: error: expected\
    \ expression\n        switch b as? Int:\n                        ^\n/tmp/tmpk4s1guc9.swift:29:9:\
    \ error: 'case' label can only appear inside a 'switch' statement\n        case\
    \ let integerValue as Int:\n        ^\n/tmp/tmpk4s1guc9.swift:31:9: error: 'case'\
    \ label can only appear inside a 'switch' statement\n        case let doubleValue\
    \ as Double:\n        ^\n/tmp/tmpk4s1guc9.swift:33:9: error: 'default' label can\
    \ only appear inside a 'switch' statement\n        default:\n        ^\n/tmp/tmpk4s1guc9.swift:36:5:\
    \ error: 'case' label can only appear inside a 'switch' statement\n    case let\
    \ doubleValue as Double:\n    ^\n/tmp/tmpk4s1guc9.swift:37:25: error: expected\
    \ '{' after 'switch' subject expression\n        switch b as? Int:\n         \
    \               ^\n/tmp/tmpk4s1guc9.swift:37:25: error: consecutive statements\
    \ on a line must be separated by ';'\n        switch b as? Int:\n            \
    \            ^\n                        ;\n/tmp/tmpk4s1guc9.swift:37:25: error:\
    \ expected expression\n        switch b as? Int:\n                        ^\n\
    /tmp/tmpk4s1guc9.swift:38:9: error: 'case' label can only appear inside a 'switch'\
    \ statement\n        case let integerValue as Int:\n        ^\n/tmp/t"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(aInt)\n        \n\
    \    case .doubleValue(aDouble)\n        \n    case .stringValue(aString)\n  \
    \      \n    case .intValue(bInt)\n        \n    case .doubleValue(bDouble)\n\
    \        \n    case .stringValue(bString)\n        \n    case .stringValue(aString),\
    \ .stringValue(bString)\n        return nil\n    }\n\n    if a == b {\n      \
    \  return a\n    }\n\n    switch b {\n    \n    case .intValue(bInt)\n       \
    \ return a\n        \n    case .doubleValue(bDouble)\n        return a\n     \
    \   \n    case .stringValue(bString)\n        return a\n        \n    case .stringValue(aString),\
    \ .stringValue(bString)\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmqdlnv6q.swift:22:36: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(aInt)\n                                   ^\n/tmp/tmpmqdlnv6q.swift:24:31:\
    \ error: expected ':' after 'case'\n    case .doubleValue(aDouble)\n         \
    \                     ^\n/tmp/tmpmqdlnv6q.swift:26:31: error: expected ':' after\
    \ 'case'\n    case .stringValue(aString)\n                              ^\n/tmp/tmpmqdlnv6q.swift:28:25:\
    \ error: expected ':' after 'case'\n    case .intValue(bInt)\n               \
    \         ^\n/tmp/tmpmqdlnv6q.swift:30:31: error: expected ':' after 'case'\n\
    \    case .doubleValue(bDouble)\n                              ^\n/tmp/tmpmqdlnv6q.swift:32:31:\
    \ error: expected ':' after 'case'\n    case .stringValue(bString)\n         \
    \                     ^\n/tmp/tmpmqdlnv6q.swift:34:54: error: expected ':' after\
    \ 'case'\n    case .stringValue(aString), .stringValue(bString)\n            \
    \                                         ^\n/tmp/tmpmqdlnv6q.swift:44:25: error:\
    \ expected ':' after 'case'\n    case .intValue(bInt)\n                      \
    \  ^\n/tmp/tmpmqdlnv6q.swift:47:31: error: expected ':' after 'case'\n    case\
    \ .doubleValue(bDouble)\n                              ^\n/tmp/tmpmqdlnv6q.swift:50:31:\
    \ error: expected ':' after 'case'\n    case .stringValue(bString)\n         \
    \                     ^\n/tmp/tmpmqdlnv6q.swift:53:54: error: expected ':' after\
    \ 'case'\n    case .stringValue(aString), .stringValue(bString)\n            \
    \                                         ^\n/tmp/tmpmqdlnv6q.swift:22:31: error:\
    \ cannot find 'aInt' in scope\n    switch a { case .intValue(aInt)\n         \
    \                     ^~~~\n/tmp/tmpmqdlnv6q.swift:24:23: error: cannot find 'aDouble'\
    \ in scope\n    case .doubleValue(aDouble)\n                      ^~~~~~~\n/tmp/tmpmqdlnv6q.swift:26:23:\
    \ error: cannot find 'aString' in scope\n    case .stringValue(aString)\n    \
    \                  ^~~~~~~\n/tmp/tmpmqdlnv6q.swift:28:20: error: cannot find 'bInt'\
    \ in scope\n    case .intValue(bInt)\n                   ^~~~\n/tmp/tmpmqdlnv6q.swift:30:23:\
    \ error: cannot find 'bDouble' in scope\n    case"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(n1), .doubleValue(d1),\
    \ .stringValue(str1):\n        switch b {\n        case .intValue(n2), .doubleValue(d2),\
    \ .stringValue(str2):\n            return (n1 > n2) || (n1 == n2 && d1 > d2) ||\
    \ (n1 == n2 && d1 == d2 && str1 > str2)\n        case .intValue(\"\"), .doubleValue(\"\
    \"), .stringValue(\"\"), nil:\n            return nil\n        }\n    case .intValue(\"\
    \"), .doubleValue(\"\"), .stringValue(\"\"), nil:\n        return nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpewuv8ucw.swift:23:20: error: cannot find 'n1' in scope\n    case\
    \ .intValue(n1), .doubleValue(d1), .stringValue(str1):\n                   ^~\n\
    /tmp/tmpewuv8ucw.swift:23:38: error: cannot find 'd1' in scope\n    case .intValue(n1),\
    \ .doubleValue(d1), .stringValue(str1):\n                                    \
    \ ^~\n/tmp/tmpewuv8ucw.swift:23:56: error: cannot find 'str1' in scope\n    case\
    \ .intValue(n1), .doubleValue(d1), .stringValue(str1):\n                     \
    \                                  ^~~~\n/tmp/tmpewuv8ucw.swift:30:20: error:\
    \ expression pattern of type 'String' cannot match values of type 'Int'\n    case\
    \ .intValue(\"\"), .doubleValue(\"\"), .stringValue(\"\"), nil:\n            \
    \       ^~\n/tmp/tmpewuv8ucw.swift:30:38: error: expression pattern of type 'String'\
    \ cannot match values of type 'Double'\n    case .intValue(\"\"), .doubleValue(\"\
    \"), .stringValue(\"\"), nil:\n                                     ^~\n/tmp/tmpewuv8ucw.swift:30:61:\
    \ warning: type 'Value' is not optional, value can never be nil; this is an error\
    \ in Swift 6\n    case .intValue(\"\"), .doubleValue(\"\"), .stringValue(\"\"\
    ), nil:\n                                                            ^\n/tmp/tmpewuv8ucw.swift:25:24:\
    \ error: cannot find 'n2' in scope\n        case .intValue(n2), .doubleValue(d2),\
    \ .stringValue(str2):\n                       ^~\n/tmp/tmpewuv8ucw.swift:25:42:\
    \ error: cannot find 'd2' in scope\n        case .intValue(n2), .doubleValue(d2),\
    \ .stringValue(str2):\n                                         ^~\n/tmp/tmpewuv8ucw.swift:25:60:\
    \ error: cannot find 'str2' in scope\n        case .intValue(n2), .doubleValue(d2),\
    \ .stringValue(str2):\n                                                      \
    \     ^~~~\n/tmp/tmpewuv8ucw.swift:27:24: error: expression pattern of type 'String'\
    \ cannot match values of type 'Int'\n        case .intValue(\"\"), .doubleValue(\"\
    \"), .stringValue(\"\"), nil:\n                       ^~\n/tmp/tmpewuv8ucw.swift:27:42:\
    \ error: expression pattern of type 'String' cannot match values of type 'Double'\n\
    \        case .intValue(\"\"), .doubleValue(\"\"), .stringValu"
  stdout: ''
  timestamp: 1660013425
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var compare = .stringValue(\"\")\n    switch\
    \ a {\n    case .intValue(i):\n        switch b {\n        case .doubleValue(j):\n\
    \            compare = .stringValue(i == j ? \"1\" : \"0\")\n        case .stringValue(k):\n\
    \            compare = .stringValue(i == j ? \"0\" : \"1\")\n        }\n    case\
    \ .doubleValue(j):\n        switch b {\n        case .intValue(i):\n         \
    \   compare = .stringValue(i == j ? \"0\" : \"1\")\n        case .stringValue(k):\n\
    \            compare = .stringValue(i == j ? \"1\" : \"0\")\n        }\n    case\
    \ .stringValue(k):\n        switch b {\n        case .intValue(i):\n         \
    \   compare = .stringValue(i == j ? \"1\" : \"0\")\n        case .doubleValue(j):\n\
    \            compare = .stringValue(i == j ? \"0\" : \"1\")\n        }\n    }\n\
    \    if compare == .stringValue(\"1\") {\n        return nil\n    }\n    return\
    \ .stringValue(compare)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpofess1pv.swift:22:20: error: reference to member 'stringValue'\
    \ cannot be resolved without a contextual type\n    var compare = .stringValue(\"\
    \")\n                  ~^~~~~~~~~~~\n/tmp/tmpofess1pv.swift:24:20: error: cannot\
    \ find 'i' in scope\n    case .intValue(i):\n                   ^\n/tmp/tmpofess1pv.swift:31:23:\
    \ error: cannot find 'j' in scope\n    case .doubleValue(j):\n               \
    \       ^\n/tmp/tmpofess1pv.swift:38:23: error: cannot find 'k' in scope\n   \
    \ case .stringValue(k):\n                      ^\n/tmp/tmpofess1pv.swift:26:27:\
    \ error: cannot find 'j' in scope\n        case .doubleValue(j):\n           \
    \               ^\n/tmp/tmpofess1pv.swift:28:27: error: cannot find 'k' in scope\n\
    \        case .stringValue(k):\n                          ^\n/tmp/tmpofess1pv.swift:27:36:\
    \ error: cannot find 'i' in scope\n            compare = .stringValue(i == j ?\
    \ \"1\" : \"0\")\n                                   ^\n/tmp/tmpofess1pv.swift:27:41:\
    \ error: cannot find 'j' in scope\n            compare = .stringValue(i == j ?\
    \ \"1\" : \"0\")\n                                        ^\n/tmp/tmpofess1pv.swift:29:36:\
    \ error: cannot find 'i' in scope\n            compare = .stringValue(i == j ?\
    \ \"0\" : \"1\")\n                                   ^\n/tmp/tmpofess1pv.swift:29:41:\
    \ error: cannot find 'j' in scope\n            compare = .stringValue(i == j ?\
    \ \"0\" : \"1\")\n                                        ^\n/tmp/tmpofess1pv.swift:33:24:\
    \ error: cannot find 'i' in scope\n        case .intValue(i):\n              \
    \         ^\n/tmp/tmpofess1pv.swift:35:27: error: cannot find 'k' in scope\n \
    \       case .stringValue(k):\n                          ^\n/tmp/tmpofess1pv.swift:34:36:\
    \ error: cannot find 'i' in scope\n            compare = .stringValue(i == j ?\
    \ \"0\" : \"1\")\n                                   ^\n/tmp/tmpofess1pv.swift:34:41:\
    \ error: cannot find 'j' in scope\n            compare = .stringValue(i == j ?\
    \ \"0\" : \"1\")\n                                        ^\n/tmp/tmpofess1pv.swift:36:36:\
    \ error: cannot find 'i' in scope\n            compare = .stringValue(i == j ?\
    \ \"1\" : \"0\")\n      "
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a < b {\n    case true: return b\n\
    \    case false: return a\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpq3lhms2o.swift:22:14: error: binary operator '<' cannot be applied\
    \ to two 'Value' operands\n    switch a < b {\n           ~ ^ ~\n/tmp/tmpq3lhms2o.swift:22:14:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \    switch a < b {\n             ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aNumber = a.intValue\n    var bNumber\
    \ = b.intValue\n\n    if aNumber < bNumber {\n        return a\n    } else if\
    \ bNumber < aNumber {\n        return b\n    } else {\n        if let aString\
    \ = a.stringValue, bString = b.stringValue {\n            if aString == \".\"\
    \ || aString == \",\" || bString == \".\" || bString == \",\" {\n            \
    \    return nil\n            }\n            aNumber = Double(aString)\n      \
    \      bNumber = Double(bString)\n            if aNumber < bNumber {\n       \
    \         return a\n            } else if bNumber < aNumber {\n              \
    \  return b\n            } else {\n                return nil\n            }\n\
    \        } else {\n            if let aDouble = a.doubleValue, bDouble = b.doubleValue\
    \ {\n                if aDouble < bDouble {\n                    return a\n  \
    \              } else if bDouble < aDouble {\n                    return b\n \
    \               } else {\n                    return nil\n                }\n\
    \            } else {\n                return nil\n            }\n        }\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp56o_9qhb.swift:30:41: error: expected 'let' in conditional\n  \
    \      if let aString = a.stringValue, bString = b.stringValue {\n           \
    \                             ^\n                                        let \n\
    /tmp/tmp56o_9qhb.swift:44:45: error: expected 'let' in conditional\n         \
    \   if let aDouble = a.doubleValue, bDouble = b.doubleValue {\n              \
    \                              ^\n                                           \
    \ let \n/tmp/tmp56o_9qhb.swift:22:19: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    var aNumber = a.intValue\n                  ^\n \
    \                 Value\n/tmp/tmp56o_9qhb.swift:23:19: error: enum case 'intValue'\
    \ cannot be used as an instance member\n    var bNumber = b.intValue\n       \
    \           ^\n                  Value\n/tmp/tmp56o_9qhb.swift:30:26: error: enum\
    \ case 'stringValue' cannot be used as an instance member\n        if let aString\
    \ = a.stringValue, bString = b.stringValue {\n                         ^\n   \
    \                      Value\n/tmp/tmp56o_9qhb.swift:30:51: error: enum case 'stringValue'\
    \ cannot be used as an instance member\n        if let aString = a.stringValue,\
    \ bString = b.stringValue {\n                                                \
    \  ^\n                                                  Value\n/tmp/tmp56o_9qhb.swift:44:30:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \      if let aDouble = a.doubleValue, bDouble = b.doubleValue {\n           \
    \                  ^\n                             Value\n/tmp/tmp56o_9qhb.swift:44:55:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n      \
    \      if let aDouble = a.doubleValue, bDouble = b.doubleValue {\n           \
    \                                           ^\n                              \
    \                        Value\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a < b {\n    case true:\n        return\
    \ a\n    case false:\n        return b\n    case let aInt, bInt where aInt < bInt:\n\
    \        return .intValue(aInt)\n    case let aDouble, bDouble where aDouble >\
    \ bDouble:\n        return .doubleValue(bDouble)\n    case let aString, bString\
    \ where aString < bString:\n        return .stringValue(bString)\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0cn_5yg8.swift:27:14: error: 'aInt' must be bound in every pattern\n\
    \    case let aInt, bInt where aInt < bInt:\n             ^\n/tmp/tmp0cn_5yg8.swift:29:14:\
    \ error: 'aDouble' must be bound in every pattern\n    case let aDouble, bDouble\
    \ where aDouble > bDouble:\n             ^\n/tmp/tmp0cn_5yg8.swift:31:14: error:\
    \ 'aString' must be bound in every pattern\n    case let aString, bString where\
    \ aString < bString:\n             ^\n/tmp/tmp0cn_5yg8.swift:22:14: error: binary\
    \ operator '<' cannot be applied to two 'Value' operands\n    switch a < b {\n\
    \           ~ ^ ~\n/tmp/tmp0cn_5yg8.swift:22:14: note: binary operator '<' cannot\
    \ be synthesized for enums with associated values\n    switch a < b {\n      \
    \       ^\n/tmp/tmp0cn_5yg8.swift:27:20: error: cannot find 'bInt' in scope\n\
    \    case let aInt, bInt where aInt < bInt:\n                   ^~~~\n/tmp/tmp0cn_5yg8.swift:27:31:\
    \ error: cannot find 'aInt' in scope\n    case let aInt, bInt where aInt < bInt:\n\
    \                              ^~~~\n/tmp/tmp0cn_5yg8.swift:27:38: error: cannot\
    \ find 'bInt' in scope\n    case let aInt, bInt where aInt < bInt:\n         \
    \                            ^~~~\n/tmp/tmp0cn_5yg8.swift:29:23: error: cannot\
    \ find 'bDouble' in scope\n    case let aDouble, bDouble where aDouble > bDouble:\n\
    \                      ^~~~~~~\n/tmp/tmp0cn_5yg8.swift:29:37: error: cannot find\
    \ 'aDouble' in scope\n    case let aDouble, bDouble where aDouble > bDouble:\n\
    \                                    ^~~~~~~\n/tmp/tmp0cn_5yg8.swift:29:47: error:\
    \ cannot find 'bDouble' in scope\n    case let aDouble, bDouble where aDouble\
    \ > bDouble:\n                                              ^~~~~~~\n/tmp/tmp0cn_5yg8.swift:31:23:\
    \ error: cannot find 'bString' in scope\n    case let aString, bString where aString\
    \ < bString:\n                      ^~~~~~~\n/tmp/tmp0cn_5yg8.swift:31:37: error:\
    \ cannot find 'aString' in scope\n    case let aString, bString where aString\
    \ < bString:\n                                    ^~~~~~~\n/tmp/tmp0cn_5yg8.swift:31:47:\
    \ error: cannot find 'bString' in scope\n    case let aString, bString"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var result_type = nil\n    if a == b {\n \
    \       return nil\n    } else if a == .intValue(b) {\n        return a\n    }\
    \ else if b == .intValue(a) {\n        return b\n    } else if a == .doubleValue(b)\
    \ {\n        return a\n    } else if b == .doubleValue(a) {\n        return b\n\
    \    } else if a == .stringValue(b) {\n        return a\n    } else if b == .stringValue(a)\
    \ {\n        return b\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprxi7h8_v.swift:22:23: error: 'nil' requires a contextual type\n\
    \    var result_type = nil\n                      ^\n/tmp/tmprxi7h8_v.swift:25:30:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Int'\n\
    \    } else if a == .intValue(b) {\n                             ^\n/tmp/tmprxi7h8_v.swift:27:30:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Int'\n\
    \    } else if b == .intValue(a) {\n                             ^\n/tmp/tmprxi7h8_v.swift:29:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \    } else if a == .doubleValue(b) {\n                                ^\n/tmp/tmprxi7h8_v.swift:31:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \    } else if b == .doubleValue(a) {\n                                ^\n/tmp/tmprxi7h8_v.swift:33:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \    } else if a == .stringValue(b) {\n                                ^\n/tmp/tmprxi7h8_v.swift:35:33:\
    \ error: cannot convert value of type 'Value' to expected argument type 'String'\n\
    \    } else if b == .stringValue(a) {\n                                ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue($0): return\
    \ b\n    case .doubleValue($0): return b\n    case .stringValue($0): return b\n\
    \    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_r5ivm8i.swift:23:20: error: anonymous closure argument not contained\
    \ in a closure\n    case .intValue($0): return b\n                   ^\n/tmp/tmp_r5ivm8i.swift:24:23:\
    \ error: anonymous closure argument not contained in a closure\n    case .doubleValue($0):\
    \ return b\n                      ^\n/tmp/tmp_r5ivm8i.swift:25:23: error: anonymous\
    \ closure argument not contained in a closure\n    case .stringValue($0): return\
    \ b\n                      ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(v1) where b\
    \ == .intValue(v2): return v1 > v2 ? v1 : v2\n    case .doubleValue(v1) where\
    \ b == .doubleValue(v2): return v1 > v2 ? v1 : v2\n    case .stringValue(v1) where\
    \ b == .stringValue(v2): return v1 > v2 ? v1 : v2\n    default: return nil\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpw4xnt2e1.swift:23:20: error: cannot find 'v1' in scope\n    case\
    \ .intValue(v1) where b == .intValue(v2): return v1 > v2 ? v1 : v2\n         \
    \          ^~\n/tmp/tmpw4xnt2e1.swift:23:45: error: cannot find 'v2' in scope\n\
    \    case .intValue(v1) where b == .intValue(v2): return v1 > v2 ? v1 : v2\n \
    \                                           ^~\n/tmp/tmpw4xnt2e1.swift:24:23:\
    \ error: cannot find 'v1' in scope\n    case .doubleValue(v1) where b == .doubleValue(v2):\
    \ return v1 > v2 ? v1 : v2\n                      ^~\n/tmp/tmpw4xnt2e1.swift:24:51:\
    \ error: cannot find 'v2' in scope\n    case .doubleValue(v1) where b == .doubleValue(v2):\
    \ return v1 > v2 ? v1 : v2\n                                                 \
    \ ^~\n/tmp/tmpw4xnt2e1.swift:25:23: error: cannot find 'v1' in scope\n    case\
    \ .stringValue(v1) where b == .stringValue(v2): return v1 > v2 ? v1 : v2\n   \
    \                   ^~\n/tmp/tmpw4xnt2e1.swift:25:51: error: cannot find 'v2'\
    \ in scope\n    case .stringValue(v1) where b == .stringValue(v2): return v1 >\
    \ v2 ? v1 : v2\n                                                  ^~\n/tmp/tmpw4xnt2e1.swift:23:57:\
    \ error: cannot find 'v1' in scope\n    case .intValue(v1) where b == .intValue(v2):\
    \ return v1 > v2 ? v1 : v2\n                                                 \
    \       ^~\n/tmp/tmpw4xnt2e1.swift:23:62: error: cannot find 'v2' in scope\n \
    \   case .intValue(v1) where b == .intValue(v2): return v1 > v2 ? v1 : v2\n  \
    \                                                           ^~\n/tmp/tmpw4xnt2e1.swift:23:67:\
    \ error: cannot find 'v1' in scope\n    case .intValue(v1) where b == .intValue(v2):\
    \ return v1 > v2 ? v1 : v2\n                                                 \
    \                 ^~\n/tmp/tmpw4xnt2e1.swift:23:72: error: cannot find 'v2' in\
    \ scope\n    case .intValue(v1) where b == .intValue(v2): return v1 > v2 ? v1\
    \ : v2\n                                                                     \
    \  ^~\n/tmp/tmpw4xnt2e1.swift:24:63: error: cannot find 'v1' in scope\n    case\
    \ .doubleValue(v1) where b == .doubleValue(v2): return v1 > v2 ? v1 : v2\n   \
    \                 "
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { \n    case .intValue(aInt), .intValue(bInt):\n\
    \        if aInt <= bInt {\n            return a\n        } else {\n         \
    \   return b\n        }\n    \n    case .doubleValue(aDouble), .doubleValue(bDouble):\n\
    \        if aDouble < bDouble {\n            return a\n        } else {\n    \
    \        return b\n        }\n        \n    case .stringValue(aString), .stringValue(bString):\n\
    \        if aString <= bString {\n            return a\n        } else {\n   \
    \         return b\n        }\n        \n    default:\n        return nil\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpr2c23qki.swift:23:20: error: cannot find 'aInt' in scope\n    case\
    \ .intValue(aInt), .intValue(bInt):\n                   ^~~~\n/tmp/tmpr2c23qki.swift:23:37:\
    \ error: cannot find 'bInt' in scope\n    case .intValue(aInt), .intValue(bInt):\n\
    \                                    ^~~~\n/tmp/tmpr2c23qki.swift:30:23: error:\
    \ cannot find 'aDouble' in scope\n    case .doubleValue(aDouble), .doubleValue(bDouble):\n\
    \                      ^~~~~~~\n/tmp/tmpr2c23qki.swift:30:46: error: cannot find\
    \ 'bDouble' in scope\n    case .doubleValue(aDouble), .doubleValue(bDouble):\n\
    \                                             ^~~~~~~\n/tmp/tmpr2c23qki.swift:37:23:\
    \ error: cannot find 'aString' in scope\n    case .stringValue(aString), .stringValue(bString):\n\
    \                      ^~~~~~~\n/tmp/tmpr2c23qki.swift:37:46: error: cannot find\
    \ 'bString' in scope\n    case .stringValue(aString), .stringValue(bString):\n\
    \                                             ^~~~~~~\n/tmp/tmpr2c23qki.swift:24:12:\
    \ error: cannot find 'aInt' in scope\n        if aInt <= bInt {\n           ^~~~\n\
    /tmp/tmpr2c23qki.swift:24:20: error: cannot find 'bInt' in scope\n        if aInt\
    \ <= bInt {\n                   ^~~~\n/tmp/tmpr2c23qki.swift:31:12: error: cannot\
    \ find 'aDouble' in scope\n        if aDouble < bDouble {\n           ^~~~~~~\n\
    /tmp/tmpr2c23qki.swift:31:22: error: cannot find 'bDouble' in scope\n        if\
    \ aDouble < bDouble {\n                     ^~~~~~~\n/tmp/tmpr2c23qki.swift:38:12:\
    \ error: cannot find 'aString' in scope\n        if aString <= bString {\n   \
    \        ^~~~~~~\n/tmp/tmpr2c23qki.swift:38:23: error: cannot find 'bString' in\
    \ scope\n        if aString <= bString {\n                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as Value {\n    case .intValue(_):\n\
    \        switch b as Value {\n        case .intValue(_):\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n        case .stringValue(let bStr):\n\
    \            let bInt: Int? = bStr.integerValue\n            return .stringValue(bInt?.compare(b.stringValue)\
    \ == .orderedSame ? bInt : nil)\n        case .doubleValue(let bDouble):\n   \
    \         let bInt: Int? = bDouble.integerValue\n            return .doubleValue(bInt?.compare(b.doubleValue)\
    \ == .orderedSame ? bInt : nil)\n        }\n    case .doubleValue(_):\n      \
    \  switch b as Value {\n        case .intValue(_):\n            return .doubleValue(a.doubleValue\
    \ > b.intValue ? a.doubleValue : b.doubleValue)\n        case .stringValue(let\
    \ bStr):\n            let bDouble: Double? = bStr.doubleValue\n            return\
    \ .stringValue(bDouble?.compare(b.stringValue) == .orderedSame ? bDouble : nil)\n\
    \        case .doubleValue(let bDouble):\n            let bInt: Int? = bDouble.integerValue\n\
    \            return .doubleValue(bInt?.compare(b.doubleValue) == .orderedSame\
    \ ? bInt : nil)\n        }\n    case .stringValue(_):\n        switch b as Value\
    \ {\n        case .intValue(_):\n            return .stringValue(a.stringValue.compare(b.stringValue)\
    \ == .orderedSame ? a.stringValue : b.stringValue)\n        case .stringValue(let\
    \ bStr):\n            return .stringValue(a.stringValue > bStr ? a.stringValue\
    \ : bStr)\n        case .doubleValue(let bDouble):\n            let bInt: Int?\
    \ = bDouble.integerValue\n            return .doubleValue(bInt?.compare(b.doubleValue)\
    \ == .orderedSame ? bInt : nil)\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpou5z2xwr.swift:26:54: error: cannot convert value of type '(Int)\
    \ -> Value' to expected argument type 'Int'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \                   ^\n/tmp/tmpou5z2xwr.swift:26:30: error: enum case 'intValue'\
    \ cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                             ^\n  \
    \                           Value\n/tmp/tmpou5z2xwr.swift:26:41: error: type '(Int)\
    \ -> Value' cannot conform to 'Comparable'\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpou5z2xwr.swift:26:41: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \      ^\n/tmp/tmpou5z2xwr.swift:26:41: note: required by referencing operator\
    \ function '>' on 'Comparable' where 'Self' = '(Int) -> Value'\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                           ^\n/tmp/tmpou5z2xwr.swift:26:43: error: enum case\
    \ 'intValue' cannot be used as an instance member\n            return .intValue(a.intValue\
    \ > b.intValue ? a.intValue : b.intValue)\n                                  \
    \        ^\n                                          Value\n/tmp/tmpou5z2xwr.swift:26:56:\
    \ error: enum case 'intValue' cannot be used as an instance member\n         \
    \   return .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n    \
    \                                                   ^\n                      \
    \                                 Value\n/tmp/tmpou5z2xwr.swift:26:69: error:\
    \ enum case 'intValue' cannot be used as an instance member\n            return\
    \ .intValue(a.intValue > b.intValue ? a.intValue : b.intValue)\n             \
    \                                                       ^\n                  \
    \                                "
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { // case .intValue(let a):\n   \
    \ case .intValue(let a):\n        switch b { // case .doubleValue(let b):\n  \
    \      case .doubleValue(let b):\n            return b > a ? .doubleValue(max(b,\
    \ a)) : .doubleValue(min(b, a))\n        default: break\n        }\n    default:\
    \ break\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4gye6efv.swift:26:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n            return b > a ? .doubleValue(max(b,\
    \ a)) : .doubleValue(min(b, a))\n                   ^\n                   Int(\
    \ )\n/tmp/tmp4gye6efv.swift:26:48: error: cannot convert value of type 'Int' to\
    \ expected argument type 'Double'\n            return b > a ? .doubleValue(max(b,\
    \ a)) : .doubleValue(min(b, a))\n                                            \
    \   ^\n                                               Double( )\n/tmp/tmp4gye6efv.swift:26:74:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Double'\n\
    \            return b > a ? .doubleValue(max(b, a)) : .doubleValue(min(b, a))\n\
    \                                                                         ^\n\
    \                                                                         Double(\
    \ )\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard let aValue = a.intValue,\n        let\
    \ bValue = b.intValue else { return nil }\n    guard let aValueAsDouble = aValue.doubleValue,\n\
    \        let bValueAsDouble = bValue.doubleValue else { return nil }\n    return\
    \ aValueAsDouble > bValueAsDouble ? a : b\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5xv9ys9a.swift:22:24: error: enum case 'intValue' cannot be used\
    \ as an instance member\n    guard let aValue = a.intValue,\n                \
    \       ^\n                       Value\n/tmp/tmp5xv9ys9a.swift:23:22: error:\
    \ enum case 'intValue' cannot be used as an instance member\n        let bValue\
    \ = b.intValue else { return nil }\n                     ^\n                 \
    \    Value\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(_): return\
    \ .intValue(b as Int)\n    case .doubleValue(_): return .doubleValue(b as Double)\n\
    \    case .stringValue(_): return .stringValue(b as String)\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdnz3cfmd.swift:23:43: error: cannot convert value of type 'Value'\
    \ to type 'Int' in coercion\n    case .intValue(_): return .intValue(b as Int)\n\
    \                                        ~~^~~~~~\n/tmp/tmpdnz3cfmd.swift:24:49:\
    \ error: cannot convert value of type 'Value' to type 'Double' in coercion\n \
    \   case .doubleValue(_): return .doubleValue(b as Double)\n                 \
    \                             ~~^~~~~~~~~\n/tmp/tmpdnz3cfmd.swift:25:49: error:\
    \ cannot convert value of type 'Value' to type 'String' in coercion\n    case\
    \ .stringValue(_): return .stringValue(b as String)\n                        \
    \                      ~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a as Value, b as Value {\n    case\
    \ let .intValue(a), let .intValue(b):\n        if a > b {\n            return\
    \ b\n        } else {\n            return a\n        }\n    case let .doubleValue(a),\
    \ let .doubleValue(b):\n        return a.doubleValue(b) // if these are equal,\
    \ the bigger one is returned.\n    case let .stringValue(a), let .stringValue(b):\n\
    \        if a == b {\n            return nil\n        } else {\n            return\
    \ a\n        }\n    default:\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4cwqvsnn.swift:22:22: error: expected '{' after 'switch' subject\
    \ expression\n    switch a as Value, b as Value {\n                     ^\n/tmp/tmp4cwqvsnn.swift:22:22:\
    \ error: consecutive statements on a line must be separated by ';'\n    switch\
    \ a as Value, b as Value {\n                     ^\n                     ;\n/tmp/tmp4cwqvsnn.swift:22:22:\
    \ error: expected expression\n    switch a as Value, b as Value {\n          \
    \           ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (IntValue(x), _):\
    \ // x is an int\n    case (DoubleValue(x), _): // x is a float\n    case (_,\
    \ StringValue(x): // x is a string\n        if x == y { return nil }\n       \
    \ \n        // if x < y, return x\n        if x < y { return x }\n        \n \
    \       // if x > y, return y\n        if x > y { return y }\n    }\n    \n  \
    \  // if both values are the same type, return nil\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp49jeq0ub.swift:23:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case (IntValue(x), _): // x is an int\n\
    \    ^~~~~~~~~~~~~~~~~~~~~~\n                           break\n/tmp/tmp49jeq0ub.swift:24:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case (DoubleValue(x), _): // x is a float\n    ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                              break\n/tmp/tmp49jeq0ub.swift:25:28: error: expected\
    \ ',' separator\n    case (_, StringValue(x): // x is a string\n             \
    \              ^\n                           ,\n/tmp/tmp49jeq0ub.swift:25:28:\
    \ error: expected expression in list of expressions\n    case (_, StringValue(x):\
    \ // x is a string\n                           ^\n/tmp/tmp49jeq0ub.swift:32:30:\
    \ error: expected ':' after 'case'\n        if x > y { return y }\n          \
    \                   ^\n/tmp/tmp49jeq0ub.swift:23:11: error: cannot find 'IntValue'\
    \ in scope\n    case (IntValue(x), _): // x is an int\n          ^~~~~~~~\n/tmp/tmp49jeq0ub.swift:23:20:\
    \ error: cannot find 'x' in scope\n    case (IntValue(x), _): // x is an int\n\
    \                   ^\n/tmp/tmp49jeq0ub.swift:24:11: error: cannot find 'DoubleValue'\
    \ in scope\n    case (DoubleValue(x), _): // x is a float\n          ^~~~~~~~~~~\n\
    /tmp/tmp49jeq0ub.swift:24:23: error: cannot find 'x' in scope\n    case (DoubleValue(x),\
    \ _): // x is a float\n                      ^\n/tmp/tmp49jeq0ub.swift:25:14:\
    \ error: cannot find 'StringValue' in scope\n    case (_, StringValue(x): // x\
    \ is a string\n             ^~~~~~~~~~~\n/tmp/tmp49jeq0ub.swift:25:26: error:\
    \ cannot find 'x' in scope\n    case (_, StringValue(x): // x is a string\n  \
    \                       ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue = a.rawValue\n    var bValue =\
    \ b.rawValue\n    \n    // Return nil if both values are equal\n    if aValue\
    \ == bValue {\n        return nil\n    }\n    \n    // Return nil if a is less\
    \ than b\n    if aValue < bValue {\n        return nil\n    }\n    \n    // Return\
    \ nil if a is greater than b\n    if aValue > bValue {\n        return nil\n \
    \   }\n    \n    // Return b if a is less than b\n    return b\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvkuaomgt.swift:22:20: error: value of type 'Value' has no member\
    \ 'rawValue'\n    var aValue = a.rawValue\n                 ~ ^~~~~~~~\n/tmp/tmpvkuaomgt.swift:2:6:\
    \ note: did you mean to specify a raw type on the enum declaration?\nenum Value:\
    \ Equatable, Hashable {\n     ^\n/tmp/tmpvkuaomgt.swift:23:20: error: value of\
    \ type 'Value' has no member 'rawValue'\n    var bValue = b.rawValue\n       \
    \          ~ ^~~~~~~~\n/tmp/tmpvkuaomgt.swift:2:6: note: did you mean to specify\
    \ a raw type on the enum declaration?\nenum Value: Equatable, Hashable {\n   \
    \  ^\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    }\n \
    \   \n    // TODO: Switch to Float, Double, or String\n    switch a as! Value\
    \ {\n    case .intValue(_):\n        return .intValue(max(b.intValue(a), a.intValue(b)))\n\
    \    case .doubleValue(_):\n        return .doubleValue(max(b.doubleValue(a),\
    \ a.doubleValue(b)))\n    case .stringValue(_):\n        return .stringValue(max(b.stringValue(a),\
    \ a.stringValue(b)))\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpgh9a3jbo.swift:27:14: warning: forced cast of 'Value' to same type\
    \ has no effect\n    switch a as! Value {\n             ^~~~~~~~~~\n         \
    \    \n/tmp/tmpgh9a3jbo.swift:29:26: error: cannot convert value of type 'Value'\
    \ to expected argument type 'Int'\n        return .intValue(max(b.intValue(a),\
    \ a.intValue(b)))\n                         ^\n/tmp/tmpgh9a3jbo.swift:29:41: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Int'\n     \
    \   return .intValue(max(b.intValue(a), a.intValue(b)))\n                    \
    \                    ^\n/tmp/tmpgh9a3jbo.swift:29:56: error: cannot convert value\
    \ of type 'Value' to expected argument type 'Int'\n        return .intValue(max(b.intValue(a),\
    \ a.intValue(b)))\n                                                       ^\n\
    /tmp/tmpgh9a3jbo.swift:29:26: error: global function 'max' requires that 'Value'\
    \ conform to 'Comparable'\n        return .intValue(max(b.intValue(a), a.intValue(b)))\n\
    \                         ^\nSwift.max:1:24: note: where 'T' = 'Value'\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpgh9a3jbo.swift:31:29: error: cannot convert value of type\
    \ 'Value' to expected argument type 'Double'\n        return .doubleValue(max(b.doubleValue(a),\
    \ a.doubleValue(b)))\n                            ^\n/tmp/tmpgh9a3jbo.swift:31:47:\
    \ error: cannot convert value of type 'Value' to expected argument type 'Double'\n\
    \        return .doubleValue(max(b.doubleValue(a), a.doubleValue(b)))\n      \
    \                                        ^\n/tmp/tmpgh9a3jbo.swift:31:65: error:\
    \ cannot convert value of type 'Value' to expected argument type 'Double'\n  \
    \      return .doubleValue(max(b.doubleValue(a), a.doubleValue(b)))\n        \
    \                                                        ^\n/tmp/tmpgh9a3jbo.swift:31:29:\
    \ error: global function 'max' requires that 'Value' conform to 'Comparable'\n\
    \        return .doubleValue(max(b.doubleValue(a), a.doubleValue(b)))\n      \
    \                      ^\nSwift.max:1:24: note: where 'T' = 'Value'\n@inlinable\
    \ public"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a { case .intValue(_), .doubleValue(_),\
    \ .stringValue(_)\n         \n         // If a.value == b.value or if they are\
    \ both nil,\n         // return nil.\n         case .intValue(let a)\n       \
    \     if b == a { return nil }\n         case .doubleValue(let a)\n          \
    \  if b == a { return nil }\n         case .stringValue(let a)\n            if\
    \ b == a { return nil }\n         \n         // If a.value < b.value, return a.\n\
    \         case .intValue(_) < .doubleValue(_)\n            return a\n        \
    \ case .doubleValue(_) < .stringValue(_)\n            return a\n         \n  \
    \       // If a.value > b.value, return b.\n         case .intValue(_) > .doubleValue(_)\n\
    \            return b\n         case .doubleValue(_) > .stringValue(_)\n     \
    \       return b\n         \n         // If a.value <= b.value, return a.\n  \
    \       case .intValue(_) <= .doubleValue(_)\n            return a\n         case\
    \ .doubleValue(_) <= .stringValue(_)\n            return a\n         \n      \
    \   // If a.value >= b.value, return b.\n         case .intValue(_) >= .doubleValue(_)\n\
    \            return b\n         case .doubleValue(_) >= .stringValue(_)\n    \
    \        return b\n         \n         // If a.value == b.value, return b.\n \
    \        case .intValue(_) == .doubleValue(_)\n            return b\n        \
    \ case .doubleValue(_) == .stringValue(_)\n            return b\n         \n \
    \        // If a.value <=> b.value, return b.\n         case .intValue(_) <=>\
    \ .doubleValue(_)\n            return b\n         case .doubleValue(_) <=> .stringValue(_)\n\
    \            return b\n         \n         // If a.value <> b.value, return nil.\n\
    \         case .intValue(_) <> .doubleValue(_)\n            return nil\n     \
    \    case .doubleValue(_) <> .stringValue(_)\n            return nil\n       \
    \  case .intValue(_) != .doubleValue(_)\n            return nil\n         case\
    \ .doubleValue(_) != .stringValue(_)\n            return nil\n         \n    \
    \     // If a.value < b, return nil.\n         case .intValue(_) < b\n       \
    \     return nil\n         case .doubleValue(_) < b\n            return nil\n\
    \         case .intValue(_) < .stringValue(_)\n            return nil\n      \
    \   case .doubleValue(_) < .stringValue(_)\n            return \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpm12r374k.swift:22:67: error: expected ':' after 'case'\n    switch\
    \ a { case .intValue(_), .doubleValue(_), .stringValue(_)\n                  \
    \                                                ^\n/tmp/tmpm12r374k.swift:26:31:\
    \ error: expected ':' after 'case'\n         case .intValue(let a)\n         \
    \                     ^\n/tmp/tmpm12r374k.swift:28:34: error: expected ':' after\
    \ 'case'\n         case .doubleValue(let a)\n                                \
    \ ^\n/tmp/tmpm12r374k.swift:30:34: error: expected ':' after 'case'\n        \
    \ case .stringValue(let a)\n                                 ^\n/tmp/tmpm12r374k.swift:34:45:\
    \ error: expected ':' after 'case'\n         case .intValue(_) < .doubleValue(_)\n\
    \                                            ^\n/tmp/tmpm12r374k.swift:36:48:\
    \ error: expected ':' after 'case'\n         case .doubleValue(_) < .stringValue(_)\n\
    \                                               ^\n/tmp/tmpm12r374k.swift:40:45:\
    \ error: expected ':' after 'case'\n         case .intValue(_) > .doubleValue(_)\n\
    \                                            ^\n/tmp/tmpm12r374k.swift:42:48:\
    \ error: expected ':' after 'case'\n         case .doubleValue(_) > .stringValue(_)\n\
    \                                               ^\n/tmp/tmpm12r374k.swift:46:46:\
    \ error: expected ':' after 'case'\n         case .intValue(_) <= .doubleValue(_)\n\
    \                                             ^\n/tmp/tmpm12r374k.swift:48:49:\
    \ error: expected ':' after 'case'\n         case .doubleValue(_) <= .stringValue(_)\n\
    \                                                ^\n/tmp/tmpm12r374k.swift:52:46:\
    \ error: expected ':' after 'case'\n         case .intValue(_) >= .doubleValue(_)\n\
    \                                             ^\n/tmp/tmpm12r374k.swift:54:49:\
    \ error: expected ':' after 'case'\n         case .doubleValue(_) >= .stringValue(_)\n\
    \                                                ^\n/tmp/tmpm12r374k.swift:58:46:\
    \ error: expected ':' after 'case'\n         case .intValue(_) == .doubleValue(_)\n\
    \                                             ^\n/tmp/tmpm12r374k.swift:60:49:\
    \ error: exp"
  stdout: ''
  timestamp: 1660013423
