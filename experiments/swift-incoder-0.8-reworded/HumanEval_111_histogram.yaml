name: HumanEval_111_histogram
language: swift
prompt: "\n/// Given a string representing a space separated lowercase letters, return\
  \ a dictionary\n/// of the letter with the most repetition and containing the corresponding\
  \ count.\n/// If several letters have the same occurrence, return all of them.\n\
  /// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" : 1, \"b\" : 1, \"\
  c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" : 2, \"b\" : 2]\n///\
  \ >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\" : 2]\n/// >>> histogram(test:\
  \ \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test: \"\")\n/// [:] as [String\
  \ : Int]\nfunc histogram(test: String) -> [String : Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" :\
  \ 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
  assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\"\
  \ : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
  \ \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
  \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
  ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
completions: ["    if isEmpty(test) {\n        return []\n    }\n    var map = [:]\n\
    \    test.unicodeScalars.forEach { scalar in\n        let char = scalar.stringValue\n\
    \        if let count = map[char] {\n            map[char] = count + 1\n     \
    \   } else {\n            map[char] = 1\n        }\n    }\n    return map", " \
    \   let maxOccurrences = Dictionary(grouping: test.lowercased(), by: {$0})\n \
    \       .map({ (key, value) in (value, key) })\n        .max{$0.1 < $1.1}\n  \
    \      .map{$0.0 }\n        .reduce([:]) { $0 + [$1] + [$2] }\n        .sorted\
    \ { $0.1 < $1.1 }\n        .map{$0.key}\n        .reduce([:]) { $0 + [$1] + [$2].map\
    \ { $0.1 } }\n    return maxOccurrences", "    var letters = [String: Int]()\n\
    \    var mostRepeatedLetter = \"\"\n    var mostRepeatedCount = Int64(Int.max)\n\
    \    var temp = \"\"\n    for _char in test {\n        let value = letters[temp]\n\
    \        if value == nil {\n            letters[temp] = 1\n        } else {\n\
    \            let count = value! + 1\n            if count > mostRepeatedCount\
    \ {\n                mostRepeatedLetter = temp\n                mostRepeatedCount\
    \ = count\n            }\n            letters[temp] = count\n        }\n     \
    \   temp = String(Character(_char))\n    }\n    return letters", "\tvar max =\
    \ [String : Int]()\n\tvar count = [String : Int]()\n\tvar words = test.characters\n\
    \tvar maxWord = nil\n\twords.forEach {\n\t\tif let count = count[$0] {\n\t\t\t\
    max[$0] = count\n\t\t\tif maxWord == nil || count > maxWord!.value {\n\t\t\t\t\
    maxWord = max[$0]\n\t\t\t}\n\t\t\tcount[$0] += 1\n\t\t} else {\n\t\t\tcount[$0]\
    \ = 1\n\t\t\tmax[$0] = 1\n\t\t}\n\t}\n\tif maxWord == nil {\n\t\treturn [:]\n\t\
    }\n\treturn maxWord!", "    let characters = test.characters.map({ String($0)\
    \ })\n    var result = [:]\n    characters.forEach { character, count in\n   \
    \     if let count = result[character] {\n            result[character] = count\
    \ + 1\n        } else {\n            result[character] = 1\n        }\n    }\n\
    \    return result", "    if test == \"\" {\n        return [:]\n    }\n\n   \
    \ var freq: [String : Int] = [:]\n    test.split(separator: \" \").forEach { x\
    \ in\n        freq[x] = (x != \"\") ? freq[x!] + 1 : 0\n    }\n\n    return freq",
  "\tcharCounts := [String : Int]()\n\ttest.unicodeScalars.forEach { char in\n\t\t\
    charCounts[char.unicodeScalars.first!.stringValue] = charCounts[char.unicodeScalars.first!.stringValue]!\
    \ + 1\n\t}\n\treturn charCounts", "\tresult : [String : Int]()\n\ttest.lowercaseString.split(\"\
    \ \").forEach {\n\t\tletter:String in\n\t\tresult[letter] = result[letter]! +\
    \ 1\n\t}\n\treturn result", "\tvar freq = [String : Int]()\n\tvar max = 0\n\t\
    var test = [String]()\n\tfor i := 0; i < len(test); i++ {\n\t\tfreq[test[i]] =\
    \ freq[test[i]] + 1\n\t\tif freq[test[i]] > max {\n\t\t\tmax = freq[test[i]]\n\
    \t\t}\n\t}\n\tfor k := range freq {\n\t\ttest = append(test, k)\n\t}\n\tsort.Sort(sort.Reverse(sort.IntSlice((test))))\n\
    \tfor i := 0; i < len(test); i++ {\n\t\tif freq[test[i]] == max {\n\t\t\tcontinue\n\
    \t\t}\n\t\tresult = append(result, test[i])\n\t\tfreq[test[i]]--\n\t}\n\treturn\
    \ result", "\tvar counts: [String : Int] = [:]\n\ttest.characters\n\t\t.flatMap\
    \ { c in\n\t\t\tif let char = c.unicodeScalars.first {\n\t\t\t\tlet count = counts[char]\
    \ ?? 0\n\t\t\t\tcounts[char] = (count + 1)\n\t\t\t}\n\t\t}\n\t\t.sorted { $0.count\
    \ < $1.count }\n\t\t.forEach { print($0.char, $0.count) }\n\treturn counts", " \
    \   switch test {\n    case \"\":\n        return [:] as [String : Int]\n    case\
    \ \"a b c a b\":\n        var result = [:] as [String : Int]\n        var letterCount\
    \ = [String : Int]()\n        test.components(separatedBy: \" \").forEach { letter\
    \ in\n            letterCount[letter] = (letterCount[letter] ?? 0) + 1 as Int\n\
    \        }\n        let maxCount = letterCount.keys.max()!\n        var maxLetter\
    \ = letterCount.keys.max()!\n        for i in 0...letterCount.keys.count {\n \
    \           let letter = letterCount.keys.sorted()[i]\n            if letterCount[letter]\
    \ > maxCount {\n                maxCount = letterCount[letter]\n             \
    \   maxLetter = letter\n            }\n        }\n        result[maxLetter] =\
    \ maxCount\n        return result\n    default:\n        let letterCount = [String\
    \ : Int]()\n        test.components(separatedBy: \" \").forEach { letter in\n\
    \            letterCount[letter] = (letterCount[letter] ?? 0) + 1 as Int\n   \
    \     }\n        let maxCount = letterCount.keys.max()!\n        var maxLetter\
    \ = letterCount.keys.max()!\n        for i in 0...letterCount.keys.count {\n \
    \           let letter = letterCount.keys.sorted()[i]\n            if letterCount[letter]\
    \ > maxCount {\n                maxCount = letterCount[letter]\n             \
    \   maxLetter = letter\n            }\n        }\n        return [maxLetter: maxCount]\n\
    \    }", '    histogram(test: test, symbols: nil)', "    if test == \"\" { return\
    \ [:] }\n    let array = test.characters.map { String($0) }\n    let histogram\
    \ = Dictionary(uniqueKeysWithValues: array.enumerated().map {\n        ($1, test.characters.filter({\
    \ $0 == $1 }).count)\n    })\n    return histogram", "    return test.components(separatedBy:\
    \ \" \")\n        .sorted { $0.count > $1.count }\n        .map { $0.trimmingCharacters(in:\
    \ .whitespaces) }\n        .map({ $0.lowercased() })\n        .enumerated().reduce(into:\
    \ [:]) {\n            $1[$0.0 + $0.1.count] = $0.0 + $0.1\n        }", "\t\n\t\
    let letters = test.lowercased().characters\n\t\n\tlet charCount: [String : Int]\
    \ = [:]\n\t\n\tfor char in letters {\n\t\t\n\t\tcharCount[char] = (charCount[char]\
    \ ?? 0) + 1\n\t\t\n\t}\n\t\n\treturn charCount\n\t", "    guard let testArray\
    \ = test.split(separator: \" \") else {\n        return [:] as [String : Int]\n\
    \    }\n\n    var counter = [String : Int]()\n    for letter in testArray {\n\
    \        guard let letterAsInt = counter[letter] else {\n            counter[letter]\
    \ = 1\n        }\n        counter[letter]! += 1 // += since counter is a mutable\
    \ dictionary\n    }\n\n    return counter", "\tvar letters : [String : Int]\n\t\
    var maxCount : Int\n\t\n\tfor letter in test.characters {\n\t\tletters[letter]\
    \ = letters[letter] ?? 0\n\t\tletters[letter] = letters[letter] + 1\n\t\tif maxCount\
    \ < letters[letter] {\n\t\t\tmaxCount = letters[letter]\n\t\t}\n\t}\n\n\treturn\
    \ letters", "    var counter = [String : Int]()\n    for ch in test {\n      \
    \  counter[ch] = (counter[ch] ?? 0) + 1\n    }\n    return counter.sorted(by:\
    \ { $0.0 < $1.0 })", "    var count: [String : Int] = [:]\n    var result = [String]()\n\
    \    for char in test.characters {\n        if let count = count[char] {\n   \
    \         count[char] = count + 1\n        } else {\n            count[char] =\
    \ 1\n        }\n    }\n    for char in count {\n        if count[char] == 1 {\n\
    \            result.append(char)\n        }\n    }\n    if result.isEmpty {\n\
    \        return [:]\n    } else {\n        return result\n    }", '    return
    count(test, " ")', "    var histogram: [String : Int] = [:]\n    for letter in\
    \ test.characters {\n        histogram[letter] = (histogram[letter] ?? 0) + 1\n\
    \    }\n    return histogram", "    var results = [String : Int]()\n    for c\
    \ in test.characters {\n        if let count = results[c] {\n            results[c]\
    \ = count + 1\n        } else {\n            results[c] = 1\n        }\n    }\n\
    \    return results", "    // get all letters found in the test\n    let characters\
    \ = test.characters\n    var result: [String : Int] = [:]\n\n    // loop through\
    \ all the letters\n    for let character in characters {\n        // if the letter\
    \ doesn't exist in our result, add it\n        if result[character] == nil {\n\
    \            result[character] = 1\n        } else {\n            // if the letter\
    \ exists in our result, increment the count\n            result[character]!++\n\
    \        }\n    }\n\n    // return the result\n    return result", "    var histogram:\
    \ [String: Int] = [:]\n    for letter in test.lowercaseString.characters {\n \
    \       histogram[letter] = (histogram[letter] ?? 0) + 1\n    }\n    return histogram",
  "    // Split on whitespace.\n    let testArray = test.split(separator: \" \")\n\
    \n    // For each word, count how many times it occurs.\n    var histogram: [String\
    \ : Int] = [:]\n    for word in testArray {\n        if let count = histogram[word]\
    \ {\n            // Increment by one, and keep track of the old value.\n     \
    \       histogram[word] = count + 1\n        } else {\n            // First time\
    \ seeing this word, so set its count to one.\n            histogram[word] = 1\n\
    \        }\n    }\n\n    return histogram", "    let letters = test.characters.filter\
    \ { $0 != ' ' }\n    return letters.enumerated().reduce(into: [String : Int]())\
    \ { (result, element) in\n        var count = result[(element.element)!]!\n  \
    \      result[(element.element)!] = (count + 1)\n    }", "\tcounts := [String\
    \ : Int]()\n\tfor c := range test {\n\t\tcounts[test[c]] = counts[test[c]] + 1\n\
    \t}\n\tvar letters []String = [:] // TODO: Swift 2.0\n\tfor c := range counts\
    \ {\n\t\tletters = append(letters, String(test[c]))\n\t}\n\treturn counts", "\t\
    var maxCount = 0\n\tvar maxLetter = [String: Int]()\n\tfor char in test.characters\
    \ {\n\t\tletterCount := 0\n\t\tif let letter = maxLetter[char] {\n\t\t\tletterCount\
    \ = letter + 1\n\t\t}\n\t\tif letterCount > maxCount {\n\t\t\tmaxCount = letterCount\n\
    \t\t\tmaxLetter[char] = letterCount\n\t\t}\n\t}\n\treturn maxLetter", "    let\
    \ letters = test.characters.flatMap { String($0) }\n    return Dictionary(uniqueKeysWithValues:\
    \ letters.enumerated().map { ($0, letters.filter{$0 == $1}).count) })", "    var\
    \ letters = test.split(\" \")\n    var histo = [String : Int]()\n    for letter\
    \ in letters {\n        if histo[letter] == nil {\n            histo[letter] =\
    \ 1\n        } else {\n            histo[letter]++\n        }\n    }\n    return\
    \ histo", "    if test == \"\" {\n        return [:]\n    }\n\n    var map = [:]\n\
    \    var testChars = test.unicodeScalars.map { $0.value }\n\n    for char in testChars\
    \ {\n        if let count = map[char] {\n            map[char] = count + 1\n \
    \       } else {\n            map[char] = 1\n        }\n    }\n\n    return map",
  "  var result = Dictionary<String, Int>()\n\n  for word in test.split(\" \") {\n\
    \    guard let letter = word.removeFirst(), letter != \"\" else { return result\
    \ }\n    result[letter] = (result[letter] ?? 0) + 1\n  }\n\n  return result",
  "    var (max, histograms): [String : Int] = [:]\n    for i in test.split(\" \"\
    ) {\n        let currentCount = histograms![i] ?? 0\n        histograms![i] +=\
    \ currentCount\n        if currentCount > max {\n            max = currentCount\n\
    \        }\n    }\n    return histograms", "    return histogram(strings.Split(test).reduce([String\
    \ : Int]()) { counts, letter in\n        counts[letter] = (counts[letter] ?? 0)\
    \ + 1;\n        return counts;\n    });", "    var h = [String : Int]()\n    test.split(\"\
    \ \").forEach { a in\n        h[a.lowercased()] = h[a.lowercased()] ?? 0\n   \
    \     h[a.lowercased()] += 1 }\n    return h", "\tlet count = test.characters.reduce(into:\
    \ [String : Int](), { (result, char) in\n\t\tresult[char] = (result[char] ?? 0)\
    \ + 1\n\t\tif result[char] > result[String(result[char])] {\n\t\t\tresult[char]\
    \ = result[String(result[char])]\n\t\t}\n\t})\n\treturn count", "    return test.split(\"\
    \ \").filter({ $0 }).reduce([String : Int]()) {\n        guard let index = self[$0]\
    \ else { return $0 }\n        self[$0] = (index + 1, $0)\n    }", "    if isEmpty(test)\
    \ {\n        return [:]\n    }\n    var histogram = [String : Int]()\n    var\
    \ count: Int = 0\n    var letter: String? = nil\n    for character in test.lowercased()\
    \ {\n        if let count = histogram[character] {\n            histogram[character]\
    \ = count + 1\n        } else {\n            histogram[character] = 1\n      \
    \      count += 1\n            letter = character\n        }\n    }\n    if let\
    \ count = histogram[letter!] {\n        histogram[letter!] = count + 1\n    }\
    \ else {\n        histogram[letter!] = 1\n    }\n    return histogram", '    return
    reduce(test).sorted { $0.key < $1.key }.map { $0.key }', "    var maxCount = 0\n\
    \    var maxLetter = \"\"\n    var letterCount = [String: Int]()\n\n    var letters\
    \ = test.characters()\n\n    for letter in letters {\n        letterCount[letter]\
    \ = (letterCount[letter] ?? 0) + 1\n\n        if letterCount[letter] > maxCount\
    \ {\n            maxCount = letterCount[letter]\n            maxLetter = letter\n\
    \        }\n    }\n\n    return letterCount", "\tvar letters = test.split(\" \"\
    )\n\tvar freqs: [String : Int] = [ : ]\n\n\tfor letter in letters {\n\t\tif let\
    \ index = freqs.index(forKey: letter) {\n\t\t\tfreqs[index] = freqs[index] + 1\n\
    \t\t} else {\n\t\t\tfreqs[letter] = 1\n\t\t}\n\t}\n\n\treturn freqs", "    var\
    \ histogram = Dictionary<String, Int>()\n    var letters: [String] = []\n    test.split(\"\
    \ \").forEach { letter in\n        guard letter.characters.count > 0 else { return\
    \ }\n        letters.append(letter)\n        histogram[letter] = (histogram[letter]\
    \ ?? 0) + 1\n    }\n    letters = letters.sorted { $0 < $1 }\n\n    return letters\n\
    \        .prefix(2)\n        .flatMap { histogram[$0] ?? 0 }\n        .reduce(into:\
    \ [:]) { (result, count) in\n            result[String(count)] = count\n     \
    \   }", "    var histogram = [String : Int]()\n    for s in test.split(\" \")\
    \ {\n        if let i = histogram[s] {\n            histogram[s] += 1\n      \
    \  } else {\n            histogram[s] = 1\n        }\n    }\n    return histogram",
  "\tresult := [:]\n\tfor _, letter := range test {\n\t\tif _, ok := result[letter];\
    \ !ok {\n\t\t\tresult[letter] = 1\n\t\t} else {\n\t\t\tresult[letter] += 1\n\t\
    \t}\n\t}\n\treturn result", "    var dictionary: [String : Int] = [:]\n    var\
    \ maxCount: Int = 0\n    for letter in test.split(\" \") {\n        guard let\
    \ count = dictionary[letter] else {\n            dictionary[letter] = 1\n    \
    \        maxCount = 1\n            continue\n        }\n        dictionary[letter]\
    \ = count + 1\n        maxCount = max(maxCount, count)\n    }\n    if maxCount\
    \ <= 0 {\n        return [:]\n    }\n    return dictionary.map { (letter, count)\
    \ -> (String, Int) in\n        return (letter, count)\n    }", "\tguard let words\
    \ = test.components(separatedBy: \" \").filter({ !$0.isEmpty }) else {\n\t\treturn\
    \ [:]\n\t}\n\t\n\tlet maxLetter = words.reduce(0) { (max: Int, current: String)\
    \ -> Int in\n\t\treturn max(max, current.unicodeScalars.filter({ $0.isLower }).count)\n\
    \t}\n\t\n\treturn words.reduce(into: [String : Int](), { (acc, cur, ind) -> ([String\
    \ : Int], Int, Int) -> [String : Int] in\n\t\tacc[ind] = ind == words.count -\
    \ 1 ? maxLetter : acc[ind] + 1\n\t\treturn acc\n\t})", "    // TODO: make this\
    \ faster\n    var histogram = [:]\n    for letter in\n        test.unicodeScalars.map\
    \ {\n        String($0).unicodeScalars.map {\n            histogram[$0] = (histogram[$0]\
    \ ?? 0) + 1\n        }\n    }\n    \n    return histogram", "    var histogram:\
    \ [String : Int] = [:]\n    for letter in test.lowercased() {\n        histogram[letter]\
    \ = (histogram[letter]!) ?? 0\n        histogram[letter]!++\n    }\n    return\
    \ histogram", "    var result: [String : Int] = [:]\n    for c in test.characters.sorted()\
    \ {\n        let index = result[c] ?? 0\n        result[c] = index + 1\n    }\n\
    \    return result", "    var histogram = [String : Int]()\n    var letters =\
    \ [Character]()\n    var maxCount = 0\n    for char in test.characters {\n   \
    \     letters.append(char)\n        if histogram[String(char)] ?? 0 == 0 {\n \
    \           histogram[String(char)] -= 1\n        } else {\n            histogram[String(char)]\
    \ += 1\n        }\n        if histogram[String(char)] > maxCount {\n         \
    \   maxCount = histogram[String(char)]\n        }\n    }\n    for (char, count)\
    \ in histogram {\n        if maxCount < count {\n            letters.removeAll()\n\
    \            histogram[String(char)] = count\n        }\n    }\n    \n    return\
    \ letters.map { String($0) : histogram[String($0)] }", "    let alphabet = Dictionary(grouping:\
    \ test, by: { String($0) })\n    return alphabet.map{ $0.key }.sorted {\n    \
    \    if $1 == ($0 as NSString).lowercased() {\n            return false\n    \
    \    }\n        return true\n    }.map {\n        String($0): Int($1)\n    }",
  "    var result: [String : Int] = [:]\n    var charArray = test.characters.map {\
    \ String($0) }\n    charArray.enumerated().forEach { index, char in\n        let\
    \ count = charArray.filter({ $0 == char }).count\n        result[char] = count\n\
    \    }\n    return result", "    var result : [String : Int] = [:]\n    test.characters.forEach\
    \ { c in\n        let i = result[c]\n        result[c] = i + 1\n    }\n    return\
    \ result", "    var histogram = [String : Int]()\n    var testChars = test.characters\n\
    \    for char in testChars {\n        if let count = histogram[char] {\n     \
    \       histogram[char] = count + 1\n        } else {\n            histogram[char]\
    \ = 1\n        }\n    }\n    return histogram", "\tcounts := [String : Int]()\n\
    \tfor _, c := range test {\n\t\tif _, ok := counts[c]; !ok {\n\t\t\tcounts[c]\
    \ = 0\n\t\t}\n\t\tcounts[c]++\n\t}\n\treturn counts", '    return countString(test,
    " ").sorted(by: { $0.1 > $1.1 }).reversed()', "    return test(\" \")\n      \
    \  .split(\" \")\n        .filter({ !$0.isEmpty })\n        .map {\n         \
    \   String($0)\n        }\n        .map {\n            String($0).lowercased()\n\
    \        }\n        .reduce([String : Int](), { $0[$1] = $0[$1] + 1 })\n     \
    \   .sorted(by: { $0.value > $1.value })\n        .map({ $0.key })\n        .sorted(by:\
    \ { $0.compare($1) == NSComparisonResult.OrderedAscending })\n        .map({ String($0)\
    \ })\n        .sorted(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n        .map({ String($0) })\n        .sorted(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n        .map({ String($0) })", "    guard !test.isEmpty else {\n       \
    \ return [ : ]\n    }\n    \n    var histogram = [String : Int]()\n    var letters\
    \ = test.characters\n    while !letters.isEmpty {\n        let letter = letters.removeLast()\n\
    \        let count = histogram.countValue(forKey: String(letter)) ?? 0\n     \
    \   histogram[letter] = histogram.updateValue(count + 1, forKey: String(letter))\n\
    \    }\n    return histogram", "    if isEmpty(test) {\n        return []\n  \
    \  }\n    var maxCount = 0\n    var result: [String : Int] = [:]\n    for char\
    \ in test.lowercaseString.split(separator: \"a\") {\n        if let count = result[char]\
    \ {\n            count += count\n        } else {\n            result[char] =\
    \ 1\n        }\n        if count == maxCount {\n            for (key, value) in\
    \ result {\n                if value == maxCount {\n                    result.removeValue(forKey:\
    \ key)\n                    break\n                }\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.1 < $1.1 }).reversed().reduce(into:\
    \ [String : Int](), { (_, item) in item[\"key\"] = item[\"value\"]; item; })",
  "    if test == \"\" {\n        return []\n    }\n    return test.split(\" \").compactMap({\
    \ String($0).lowercased() }).reduce([String : Int]()) { (res, v) in\n        res[v]\
    \ = res[v] + 1\n        return res\n    }", '    return test.characters.reduce(into:
    [String : Int](), { $0[$1] = $0[$1] + 1 })', "\treturn countOccurrences(letters:\
    \ test.lowercased(), letterGrouping: letterGrouping, letterCounts: letterCountsMap)",
  "    var maxCount = 0\n    var maxLetter = \"\"\n    var histogram = [String : Int]()\n\
    \    for letter in test.lowercased() {\n        var letterCount = histogram[letter]\n\
    \        letterCount = letterCount == nil ? 1 : letterCount + 1\n        histogram[letter]\
    \ = letterCount\n        if letterCount > maxCount {\n            maxCount = letterCount\n\
    \            maxLetter = letter\n        }\n    }\n    return histogram", '    return
    histogram.(test)', '    return test(test).reduce(into: [String : Int](), { $0[$1]
    = $0[$1] + 1 })', "    if test.isEmpty {\n        return [:]\n    }\n    var histo\
    \ = [String : Int]()\n    for char in test {\n        histo[char] = (histo[char]!)\
    \ + (1)\n    }\n    var max = -1\n    for char in histo {\n        if max < histo[char]\
    \ {\n            max = histo[char]\n        }\n    }\n    var result = [String\
    \ : Int]()\n    for char in histo {\n        if histo[char] == max {\n       \
    \     result[char] = histo[char]\n        }\n    }\n    return result", '    histogram(test:
    test.trimmingCharacters(in: .whitespaces))', "    guard test != \"\" else {\n\
    \        return []\n    }\n    var frequency: [String : Int] = [:]\n    for letter\
    \ in test.lowercased() {\n        frequency[letter] = (countForKey(frequency,\
    \ letter)!) + 1\n    }\n    return frequency", "    guard let words = test.components(separatedBy:\
    \ \" \") else {\n        return []\n    }\n\n    // Sort the letters by the count\n\
    \    let sortedLetters = words.sorted{ $0.count > $1.count }\n\n    var occurrences\
    \ = Dictionary<String, Int>()\n    var letters = [String]()\n\n    for letter\
    \ in sortedLetters {\n        guard let count = occurrences[letter] else {\n \
    \           occurrences[letter] = Int()\n        }\n        occurrences[letter]\
    \ = occurrences[letter] + 1\n        letters.append(letter)\n    }\n\n    return\
    \ letters.map{\n        (letter, count) -> (String, Int) in\n        return (letter,\
    \ count)\n    }.sorted{ $0.1 < $1.1 }.last!", "    var maxCount = 0\n    var maxChar\
    \ = \"\"\n    var maxKey = \"\"\n    var histogram = [:]\n    for char in test.unicodeScalars\
    \ {\n        let count = String(char).unicodeScalars.count\n        if count >\
    \ maxCount {\n            maxCount = count\n            maxChar = char\n     \
    \       maxKey = String(char)\n        } else if count == maxCount {\n       \
    \     let key = String(char)\n            if histogram[key] != nil {\n       \
    \         histogram[key]?.append(count)\n            } else {\n              \
    \  histogram[key] = [count]\n            }\n        }\n    }\n\n    var returnDict:\
    \ [String : Int] = [String : Int]()\n    for (_, values) in histogram {\n    \
    \    var max = 0\n        var maxChar = \"\"\n        for v in values {\n    \
    \        if v > max {\n                max = v\n                maxChar = v\n\
    \            }\n        }\n        returnDict[maxChar] = max\n    }\n    return\
    \ returnDict", "\tvar dict [String : Int] = [:]\n\tfor letter in test.split(\"\
    \ \") {\n\t\tdict[letter] = dict[letter] + 1\n\t}\n\treturn dict", "    if test.isEmpty\
    \ {\n        return [:]\n    }\n\n    // Split the string into words and process\
    \ each one.\n    // We keep track of which letters have been encountered so we\n\
    \    // don't count them twice.\n    var letters = [String: Int]()\n    var words\
    \ = [String]()\n    var letterCounts = [:]\n    var letterCount = 0\n    var wordCount\
    \ = 0\n\n    for c in test.unicodeScalars {\n        // Skip this letter if it\
    \ has already been encountered.\n        if let count = letters[c] {\n       \
    \     letterCount += count\n        } else {\n            letters[c] = letterCount\n\
    \            letterCount += 1\n\n            // Split the string and add the words\
    \ found.\n            words = test.unicodeScalars.filter({ c in\n            \
    \    let cString = String($0)\n                return !letterCounts[cString] &&\
    \ !letterCounts[c]\n            }).map { String($0) }\n            letterCounts[words[0].lowercased()]\
    \ = wordCount\n            wordCount += words.count\n        }\n    }\n\n    //\
    \ Return a dictionary with the letter with the most occurrences and a count of\
    \ how often it occurred.\n    let most = letters.reduce([String: Int](), { (r,\
    \ k) -> ([String : Int], Int) in\n        let count = r[k] ?? 0\n        return\
    \ (count > r[k], count)\n    }).0\n    return most", "    var histogram = [String:\
    \ Int]()\n    test.split(\" \").map { histogram.updateValue(1, forKey: $0) }\n\
    \    return histogram", "    switch test.countByReduce() {\n    case let .Some(count),\
    \ let strings = count:\n        return strings.compactMap({ (string, _) -> [String\
    \ : Int] in\n            let count = count[string]!\n            return [string\
    \ : count]\n        }).sorted(by: { (_, _) -> Bool in\n            return $0.1\
    \ > $1.1\n        })\n    default:\n        return []\n    }", '    return histogram(test.lowercased().components(separatedBy:
    " "))', "    var letterCounts = [String : Int]()\n    var i = 0\n    for letter\
    \ in test.lowercased() {\n        if let count = letterCounts[letter] {\n    \
    \        letterCounts[letter] = count + 1\n        } else {\n            letterCounts[letter]\
    \ = 1\n        }\n        i += 1\n    }\n    return letterCounts", "    let list\
    \ = test.characters.split{$0 == \" \"}.map{String($0)}\n    let letters = list.reduce(into:\
    \ [String : Int](), {\n        $1[$0] = ($1[$0] ?? 0) + 1\n    })\n    return\
    \ letters", "    var max = [String: Int]()\n    var result = [String : Int]()\n\
    \n    for character in test.characters.split(\" \") {\n        let count = max[character]\n\
    \        max[character] = count + 1\n    }\n\n    for character in max.keys {\n\
    \        result[character] = max[character]\n    }\n\n    return result", "  \
    \  var result = Dictionary<String, Int>()\n    for c in test {\n        switch\
    \ c {\n        case 'a':\n        case 'b':\n        case 'c':\n        case '\
    \ ':\n        case '\\t':\n            continue\n        case '\\n':\n       \
    \     result = [:] as [String : Int]\n            return result\n        }\n\n\
    \        var count = result[c] ?? 0\n        result[c] = count + 1\n    }\n\n\
    \    return result.sorted(by: { $0.1 > $1.1 }).reversed().map { ($0, $1) }", " \
    \   var result: [String : Int] = [:]\n    var count: Int = 0\n    var letter:\
    \ String = \"\"\n    for char in test {\n        if let charIndex = test.index(of:\
    \ char) {\n            letter = String(test[charIndex])\n            result[letter]\
    \ = result[letter] + 1\n        }\n    }\n    return result ", "    var histogram\
    \ = [String : Int]()\n    for char in test.lowercased() {\n        histogram[char]\
    \ = (histogram[char] ?? 0) + 1\n    }\n    return histogram", "    guard let letters\
    \ = test.split(separator: \" \").map({ $0.lowercased() }),\n        let keys =\
    \ Array(letters.map { $0.prefix(1).uppercased() }),\n        let values = letters.map({\
    \ letters.filter({ $0.lowercased() == $0.prefix(1).uppercased() }).count })\n\
    \    else {\n        return [:] as [String : Int]\n    }\n    return zip(keys,\
    \ values).map { $0.0 : $0.1 }", "    var result = [:] as [String : Int]\n    for\
    \ letter in test.characters {\n        if let count = result[letter] {\n     \
    \       result[letter] = 1 + count\n        } else {\n            result[letter]\
    \ = 1\n        }\n    }\n    return result", "    if test == \"\" {\n        return\
    \ [String: Int]()\n    }\n\n    var letters: [String: Int] = [:]\n    for s in\
    \ test.split(separator: \" \") {\n        if let letter = String(s.characters)\
    \ {\n            if letters.keys.contains(letter) {\n                letters[letter]\
    \ = (letters[letter] ?? 0) + 1;\n            } else {\n                letters[letter]\
    \ = 1;\n            }\n        }\n    }\n    return letters.sorted(by: { ($0.key,\
    \ $1.key) < ($1.key, $0.key) }).map { ($0.0, $0.1) }", "\tvar result : [String\
    \ : Int]\n\tvar letters : [String] = test.stringByReplacingOccurrencesOfStrings(\n\
    \t\t\" \", withString: \"\",\n\t\toptions: NSStringCompareOptions.CaseInsensitiveSearch).componentsSeparatedByString(\"\
    \ \")\n\tfor letter in letters {\n\t\tif let count = letters.filter({ $0 == letter\
    \ }).count  {\n\t\t\tresult[letter] = count\n\t\t}\n\t}\n\treturn result", " \
    \   guard !test.isEmpty else { return [:] }\n    var result = [:]\n    test.split(separator:\
    \ \" \")\n        .reduce(0) { $1 + counts[$0] }\n        .sort().reversed()\n\
    \        .forEach { result[String($0)] = $1 }\n    return result", "    if test\
    \ == \"\" {\n        return [String: Int]()\n    }\n    var counters: [String:\
    \ Int] = [:]\n    var result: [String: Int] = [:]\n    for letter in test.lowercased()\
    \ {\n        if let count = counters[letter] {\n            counters[letter] =\
    \ count + 1\n        } else {\n            counters[letter] = 1\n        }\n \
    \   }\n    for (_, count) in counters {\n        if count > result.count {\n \
    \           result = counters\n        }\n    }\n    return result", "    if test\
    \ == \"\" {\n        return []\n    }\n    counts := make(map[String: Int]) //\
    \ [String : Int]\n    var maxCount = 1\n    for _, letter := range test {\n  \
    \      if counts[letter] == nil {\n            counts[letter] = 1\n        } else\
    \ if counts[letter] > maxCount {\n            counts[letter] = maxCount\n    \
    \        maxCount = counts[letter]\n        }\n    }\n    return counts", "  \
    \  var histogram = [String : Int]()\n    var max = 0\n    test.split(\" \").forEach()\
    \ { histogram += [$0 : (histogram[$0] ?? 0)+1] }\n    for (k,v) in histogram {\n\
    \        if v > max { max = v }\n    }\n    if max < 1 { histogram = [:] }\n \
    \   return histogram", "    var histogram = [String : Int]()\n    for string in\
    \ test.split(\" \") {\n        if let letter = string.first {\n            histogram[letter]\
    \ = (histogram[letter] ?? 0) + 1\n        }\n    }\n    return histogram", "\t\
    var histogram: [String : Int] = [:]\n\ttest.characters.forEach { char in\n\t\t\
    histogram[char] = (histogram[char] ?? 0) + 1\n\t}\n\treturn histogram", "    var\
    \ result: [String : Int] = [:]\n\n    for s in test.split(\" \") {\n        if\
    \ let count = result[s]?? 0 {\n            result[s] = (result[s]?? 0) + 1\n \
    \       } else {\n            result[s] = 1 // We start at 1 because the first\
    \ character has only 1 occurrence\n        }\n    }\n\n    return result", " \
    \   let letters = test.characters\n    var result = [:]\n    for letter in letters\
    \ {\n        if let count = result[letter] {\n            result[letter] = count\
    \ + 1\n        } else {\n            result[letter] = 1\n        }\n    }\n  \
    \  return result", "    guard let testRange = test.unicodeScalars.filter { $0\
    \ != ' ' }.map(String.init), \n        let counts = testRange\n            .map({\
    \ charToFrequency($0) })\n            .sorted()\n            .map({ ($1, $0) })\n\
    \            else { return [:] }\n    return counts", "    var histogram = [String\
    \ : Int]()\n\n    var letters = [String]()\n    if test != \"\" {\n        letters\
    \ = test.split(separator: \" \")\n    }\n\n    for let letter in letters {\n \
    \       if let count = histogram.value(forKey: letter) {\n            histogram[letter]\
    \ = count + 1\n        } else {\n            histogram[letter] = 1\n        }\n\
    \    }\n\n    return histogram", "\thistogram = [:]\n\tlet chars = Array(test.characters)\n\
    \tfor char in chars {\n\t\thistogram[char] = histogram.value(forKey: char) ??\
    \ 0 + 1\n\t}\n\treturn histogram", "    var result = [:]\n    var seen = [String]()\n\
    \    for letter in test.lowercased() {\n        if let count = result[letter]\
    \ {\n            result[letter] = count + 1\n        } else {\n            result[letter]\
    \ = 1\n        }\n        if let alreadySeen = seen[letter] {\n            result[letter]\
    \ = result[letter] + result[alreadySeen]\n        } else {\n            seen[letter]\
    \ = 1\n        }\n    }\n    return result", "    var result: [String : Int] =\
    \ [:]\n    for letter in test.split(\" \") {\n        result[letter] = (result[letter]\
    \ ?? 0) + 1\n    }\n    return result", "    var charDict: [String : Int] = [:]\n\
    \    for char in test.characters.split(separator: \" \") {\n        if charDict[char]\
    \ == nil {\n            charDict[char] = 1\n        } else {\n            charDict[char]\
    \ += 1\n        }\n    }\n    return charDict", "\tlet chars = test.characters\n\
    \tvar frequency = [String : Int]()\n\tvar maxCount = 0\n\tfor char in chars {\n\
    \t\tif let count = frequency.updateValue(chars.filter({ $0 == char }).count, forKey:\
    \ char) {\n\t\t\tmaxCount = max(maxCount, count)\n\t\t}\n\t}\n\treturn frequency",
  "    var result = [String : Int]()\n    \n    for letter in test.unicodeScalars.reversed()\
    \ {\n        let count = test.unicodeScalars.filter { $0 == letter }.count\n \
    \       if result[key: letter] != nil { \n            result[key: letter]! +=\
    \ count\n        } else {\n            result[key: letter] = count\n        }\n\
    \    }\n    \n    return result", "\tvar result : [String : Int] = [ : ]\n\tfor\
    \ char in test.characters {\n\t\tresult[char] = result[char]! + 1\n\t}\n\treturn\
    \ result", "    letterCounts.withDefaultValue { [ : : Int : ] in\n        var\
    \ result: [String : Int] = [ : : ]()\n\n        var count = letterCounts[test.lowercased()]\n\
    \        if let currentCount = letterCounts[test.lowercased()] {\n           \
    \ result[test.lowercased()] = max(1, currentCount + count)\n        }\n\n    \
    \    if test.count > 1 {\n            let subTests = test.components(separatedBy:\
    \ \" \")\n            for subTest in subTests {\n                var subCount\
    \ = letterCounts[subTest.lowercased()]\n                if let currentCount =\
    \ letterCounts[subTest.lowercased()] {\n                    subCount = max(1,\
    \ currentCount + subCount)\n                }\n                result[subTest.lowercased()]\
    \ = subCount\n            }\n        }\n\n        return result\n    }", "\tvar\
    \ letters = [String: Int]()\n\tfor letter := range test.lowercased() {\n\t\tif\
    \ letters[letter] == nil {\n\t\t\tletters[letter] = 1\n\t\t} else {\n\t\t\tletters[letter]!++\n\
    \t\t}\n\t}\n\treturn letters", "    var charCount = [String : Int]()\n    test.unicodeScalars.forEach\
    \ { char in\n        if let _ = charCount[char] {\n            charCount[char]\
    \ = charCount[char] + 1\n        }\n        else {\n            charCount[char]\
    \ = 1\n        }\n    }\n    return charCount", "    \n    var result = [:]\n\
    \    var letters = [String]()\n    \n    letters = test.split(separator: \" \"\
    )\n    \n    for letter in letters {\n        \n        let count = result[letter]\
    \ ?? 0\n        \n        result[letter] = count + 1\n    }\n    \n    return\
    \ result", "    var letters = [String : Int]()\n    for letter in test.characters\
    \ {\n        if let count = letters[letter] {\n            letters[letter] = count\
    \ + 1\n        } else {\n            letters[letter] = 1\n        }\n    }\n \
    \   return letters", "    var histogram: [String : Int] = [:]\n    for letter\
    \ in test.lowercaseString.characters {\n        if histogram.values.contains(letter)\
    \ {\n            histogram[letter] = histogram.values[letter] + 1\n        } else\
    \ {\n            histogram[letter] = 1\n        }\n    }\n    return histogram",
  "    guard let testArray = test.split(separator: \" \").map { $0.lowercased() }\
    \ else { return [:] }\n    let histogramsArray: [String : Int] = [:]\n    for\
    \ string in testArray {\n        histogramsArray[string] = (histogramsArray[string]\
    \ ?? 0) + 1;\n    }\n    return histogramsArray", "\tvar frequencies = [String\
    \ : Int]()\n\tfor letter in test {\n\t\tif frequencies[letter] == nil {\n\t\t\t\
    frequencies[letter] = 1\n\t\t} else {\n\t\t\tfrequencies[letter]!++\n\t\t}\n\t\
    }\n\treturn frequencies", "\tguard !test.isEmpty else { return [:] }\n\n\tlet\
    \ result = test.componentsSeparatedByCharactersInSet(NSCharacterSet.lowercaseLetterCharacterSet())\n\
    \t\t.map { (letter) -> String in\n\t\t\tlet letterCount = letters.filter{ $0.letter\
    \ ==  letter }.count\n\t\t\treturn letter == letter ? letter : [letter, letterCount]\n\
    \t\t}\n\t\t.filter { $0.count > 1 }\n\t\t.sorted(by: { $0.1 < $1.1 }).reduce(into:\
    \ [String : Int]()) { (result, e) in\n\t\t\tresult[e.0] = (result[e.0] ?? 0) +\
    \ e.1\n\t\t}\n\treturn result", "    var letters: [String: Int] = [:]\n    for\
    \ char in test.lowercased() {\n        letters[char] = (letters[char]!?.0) + 1\n\
    \    }\n    return letters", "    if testIsEmpty(test) {\n        return [:]\n\
    \    }\n    let chars = test.characters\n    var histogram: [String : Int] = [:]\n\
    \    var currentLetter = nil\n    var currentOccurrence = 0\n    for char in chars\
    \ {\n        guard let countValue = histogram[char] else {\n            histogram[char]\
    \ = 1\n        } else {\n            histogram[char] += countValue\n        }\n\
    \        if currentLetter == nil {\n            currentLetter = char\n       \
    \ } else if char == currentLetter {\n            currentOccurrence += 1\n    \
    \        currentLetter = nil\n        } else {\n            if currentOccurrence\
    \ > histogram[currentLetter] {\n                histogram[currentLetter] = currentOccurrence\n\
    \                currentOccurrence = 1\n                currentLetter = char\n\
    \            }\n        }\n    }\n    if currentOccurrence > histogram[currentLetter]\
    \ {\n        histogram[currentLetter] = currentOccurrence\n    }\n    return histogram",
  "    if test == \"\" {\n        return [:]\n    }\n    var histogram: [String :\
    \ Int] = [:]\n    for letter in test.lowercaseString.split(separator: \" \") {\n\
    \        histogram[letter] = (histogram[letter] ?? 0) + 1\n    }\n    return histogram",
  "    var dict: [String : Int] = [:]\n\n    test.split(separator: \" \").forEach\
    \ { word in\n        dict[word] = (dict[word] ?? 0) + 1\n    }\n\n    return dict",
  "    return test.characters.reduce(into: [String : Int]()) {\n        histogram($0.value,\
    \ $0.key, $1)\n    }", "    if test == \"\" { return [:] }\n\n    var histogram\
    \ = [String : Int]()\n    var letterCounts = [String : Int]()\n    var letters\
    \ = test.lowercased()\n    for letter in letters {\n        if let count = letterCounts[letter]\
    \ {\n            histogram[letter] = count + 1\n        } else {\n           \
    \ letterCounts[letter] = 1\n        }\n    }\n    return histogram", "    var\
    \ histogram: [String : Int] = [:]\n    test.split(\" \").forEach { char in\n \
    \       histogram[char] = (histogram[char] ?? 0) + 1\n    }\n    return histogram",
  "    histogramCount := [String : Int]()\n\n    for _, char := range test {\n   \
    \     if _, exists := histogramCount[char]; !exists {\n            histogramCount[char]\
    \ = 1\n        } else {\n            histogramCount[char]++\n        }\n    }\n\
    \n    return histogramCount", "    if test == \"\" { return [:] }\n\n    var map\
    \ = [:] as [String : Int]\n    var words = test.split(\" \")\n    for word in\
    \ words {\n        guard let value = map[word] else {\n            map[word] =\
    \ 1\n            continue\n        }\n        map[word] += 1\n    }\n\n    return\
    \ map", "    var letters = [String: Int]()\n    for letter in test.lowercaseString.split(separator:\
    \ \" \") {\n        letters[letter] = (letters[letter] ?? 0) + 1\n    }\n    return\
    \ letters", "\tresult := [String: Int]()\n\ttest.splitN(\" \")\n\t\t.reduce([String:\
    \ Int]()) { (result, word) in\n\t\t\tresult[(word)] = result[(word)] + 1\n\t\t\
    \treturn result\n\t\t}\n\treturn result", '  return countAndSort(test.split("
    "), by: { $0 })', "    if test == \"\" {\n        return [:] as [String : Int]\n\
    \    }\n\n    var letters = test.characters.flatMap({ $0.lowercased() })\n   \
    \ var histogram: [String : Int] = [:]\n    for letter in letters {\n        histogram[letter]\
    \ = (histogram[letter] ?? 0) + 1\n    }\n    return histogram", "    if test ==\
    \ \"\" {\n        return [:] as [String : Int]\n    }\n    \n    var map = [:]\
    \ as [String : Int]\n    test.split(\" \").forEach { word in\n        word = (word\
    \ + \"\").lowercased()\n        if map.keys.contains(word) {\n            map[word]!\
    \ += 1;\n        } else {\n            map[word] = 1\n        }\n    }\n    \n\
    \    return map", "    var result = Dictionary<String, Int>()\n    for c in test.lowercased()\
    \ {\n        result[c] = result[c] ?? 0\n        result[c] += 1\n    }\n    let\
    \ sorted = Dictionary(grouping: result.values, by: { $0 })\n    return sorted",
  "    var count = [String : Int]()\n    for char in test.characters {\n        if\
    \ let char = String(char) {\n            let count = count[char] ?? 0\n      \
    \      count[char] = count + 1\n        }\n    }\n    return count", "    if test\
    \ == \"\" { //empty string is considered as empty list\n        return [:] as\
    \ [String : Int]\n    }\n    var result = [String : Int]()\n    var letters: [String]\
    \ = test.split(\" \").map { String($0) }\n    for letter in letters {\n      \
    \  result[letter] = (result[letter] ?? 0) + 1\n    }\n    return result", "  \
    \  var histogram = [String: Int]()\n    var count = 0\n    var letters = \"\"\n\
    \n    for letter in test {\n        if letters.isEmpty {\n            letters\
    \ += letter\n        } else {\n            letters += \" \"\n            letters\
    \ += letter\n        }\n        if histogram[letters.lowercased()] == nil {\n\
    \            histogram[letters.lowercased()] = Int()\n        }\n        histogram[letters.lowercased()]\
    \ = histogram[letters.lowercased()] + 1\n    }\n\n    for letter in histogram\
    \ {\n        if histogram[letter] == nil {\n            histogram[letter] = Int()\n\
    \        }\n    }\n\n    return histogram", "\tguard !test.isEmpty else { return\
    \ [:] }\n\tlet letterCount = [Character : Int]()\n\tfor letter in test.lowercased()\
    \ {\n\t\tletterCount[letter] = (letterCount[letter] ?? 0) + 1\n\t}\n\treturn letterCount",
  "  var result = [:]\n  for letter in test.lowercaseString.split(\" \") {\n    guard\
    \ let count = result[letter] else {\n      result[letter] = 1\n      continue\n\
    \    }\n    result[letter] = count + 1\n  }\n  return result", "\tif test == \"\
    \" {\n\t\treturn [:] as [String : Int]\n\t}\n\n\thistogram := [:]\n\tvar maxCount\
    \ : Int = -1\n\tvar maxKey : String = \"\"\n\n\tfor _, charAt := range test {\n\
    \t\tcount := histogram[charAt] ?? 0\n\t\thistogram[charAt] = count + 1\n\t\tif\
    \ count > maxCount {\n\t\t\tmaxCount = count\n\t\t\tmaxKey = charAt\n\t\t}\n\t\
    }\n\n\treturn histogram", "    var result = [String : Int]()\n    test.split(separator:\
    \ \" \").forEach { (letter) in\n        result[letter] = (result[letter] ?? 0)\
    \ + 1\n    }\n    return result", "    let letters = test.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    var letterCounts = [String : Int]()\n\
    \    letters.split(separator: \" \").forEach { letter in\n        let count =\
    \ letterCounts[letter] ?? 0\n        letterCounts[letter] = count + 1\n    }\n\
    \    return letterCounts", "    var histogram = [String : Int]()\n    func updateCounter(char:\
    \ String) {\n        histogram[char] = (histogram[char] ?? 0) + 1\n    }\n   \
    \ test.unicodeScalars.forEach { updateCounter($0.value) }\n    return histogram",
  "    guard let lowercased = test.lowercased() else {\n        return [String : Int]()\n\
    \    }\n\n    var histogram = [String : Int]()\n    \n    for i in lowercased.characters\
    \ {\n        let letter = String(i).uppercased()\n\n        if let count = histogram[letter]\
    \ {\n            histogram[letter] = 1 + count\n        } else {\n           \
    \ histogram[letter] = 1\n        }\n    }\n    \n    return histogram", "    \n\
    \    var result: [String : Int] = [:]\n    var letter: String = test.characters.map({\
    \ String($0) })\n    letter = letter.reduce(into: [String: Int]()) { (result,\
    \ next, letter) in\n        \n        var count = 1\n        result[letter] =\
    \ (result[letter] ?? 0) + count\n        \n        if letter == next {\n     \
    \       count += 1\n        }\n        \n        result[letter] = count\n    }\n\
    \    \n    return letter", "    return test.split().reduce(into: [String : Int]())\
    \ {\n        ($1, $2) in\n        if let value = $1[$2] {\n            $1[$2]\
    \ = value + 1\n        } else {\n            $1[$2] = 1\n        }\n    }", " \
    \   return test.split(\" \").map { $0.lowercased() }\n        .filter { !$0.isEmpty\
    \ }\n        .map {\n            ($0, test.split($0).reduce(0,+))\n        }\n\
    \        .reduce([String : Int]()) { $0 + [$1 : ($1 ?? 0) + $0] }", "    let testChars\
    \ = test.characters\n    var histogram = [String : Int]()\n\n    for i in 0..<testChars.count\
    \ {\n        if let v = histogram[testChars[i]] {\n            histogram[testChars[i]]\
    \ += 1\n        } else {\n            histogram[testChars[i]] = 1\n        }\n\
    \    }\n    return histogram", "    let words = test.split(separator: \" \")\n\
    \    return words.reduce(into: [String : Int](), { result, word in\n        result[word]\
    \ = (result[word] ?? 0) + 1\n    })", "    var histogram = [:] as [String : Int]\n\
    \    for letter in test.lowercased() {\n        let index = histogram.count\n\
    \        histogram[letter] = index\n    }\n    return histogram", "    var letters:\
    \ [String: Int] = [:]\n    for letter in test.split(\" \") {\n        letters[letter]\
    \ = (letters[letter] ?? 0) + 1\n    }\n    return letters", "\tif test == \"\"\
    \ {\n\t\treturn [:]\n\t}\n\n\tvar histogram: [String : Int] = [:]\n\n\tfor word\
    \ in test.split(\" \") {\n\t\thistogram[word] = histogram.getOrDefault(word, 0)\
    \ + 1\n\t}\n\n\treturn histogram", "    var occurrence: [String : Int] = [:]\n\
    \n    for letter in test.characters {\n        if let count = occurrence[letter]\
    \ {\n            occurrence[letter] = count + 1\n        } else {\n          \
    \  occurrence[letter] = 1\n        }\n    }\n\n    return occurrence", "    \n\
    \    let letters = test.lowercaseString.split(separator: \" \")\n    \n    var\
    \ dictionary: [String : Int] = [:]\n    \n    for letter in letters {\n      \
    \  let occurrences = dictionary[letter] ?? 0\n        dictionary[letter] = occurrences\
    \ + 1\n    }\n    \n    return dictionary", "    var result: [String : Int] =\
    \ [:]\n    var i: Int = 1\n    for letter in test.lowercaseString.split(\" \"\
    ) {\n        result[letter] = result[letter] + i\n        i = i + 1\n    }\n \
    \   return result", '    return histogram(test.characters.map { String($0) })',
  "    var histogram = [String: Int]()\n    test.characters.forEach {\n        let\
    \ currentCount = histogram[$0] ?? 0\n        histogram[$0] = currentCount + 1\n\
    \    }\n    return histogram", "    guard test.count != 0 else { return [:] }\n\
    \    var histogram = [String : Int]()\n    test.unicodeScalars.forEach { unicodeScalar\
    \ in\n        guard let str = unicodeScalar.value, !str.isEmpty else { return\
    \ }\n        if let index = histogram[str]\n        {\n            histogram[str]\
    \ += 1\n        }\n        else\n        {\n            histogram[str] = 1;\n\
    \        }\n    }\n    return histogram", "    let chars = test.characters.map(String.init)\n\
    \    let count = chars.reduce([String: Int](), combine: { (result, [String : Int])\
    \ -> [String : Int] in\n        var count = result\n        for char in chars\
    \ {\n            if let value = result.removeValue(forKey: char) {\n         \
    \       count = count.combine({ [String : Int](char : value.1, value: value.2\
    \ + 1) }) { $0 + $1.value }\n            }\n        }\n        return count\n\
    \    })\n    return count.map { String($0.key): $0.value }", "    let histogram\
    \ = Dictionary<String, Int>()\n    for ch in test {\n        if let count = histogram.value[ch]\
    \ {\n            histogram.value += count\n        } else {\n            histogram.value[ch]\
    \ = 1\n        }\n    }\n    return histogram.value", "    var map = [:]\n   \
    \ for char in test.characters {\n        if var count = map[char] {\n        \
    \    count += 1;\n            map[char] = count;\n        }\n    }\n    return\
    \ map", "    return test.components(separatedBy: \" \").reduce(into: [String :\
    \ Int](), { count, letter in\n        guard let count = count[letter] else {\n\
    \            count[letter] = 1\n        } else {\n            count[letter] +=\
    \ 1\n        }\n    })", "    var histogram = [String : Int]()\n    for i in test.characters.reversed().map({\
    \ $0.isUppercase ? UInt8(1) : UInt8(0) }).sorted(by: <) {\n        histogram[i.string]\
    \ = histogram[i.string] ?? 1\n        histogram[i.string] += 1 // Swift compiler\
    \ can't prove this doesn't overflow.\n    }\n    return histogram", "    var histo\
    \ = [String : Int]()\n    var words = test.split()\n    for word in words {\n\
    \        if histo[word] == nil {\n            histo[word] = 1\n        } else\
    \ {\n            histo[word] = histo[word] + 1\n        }\n    }\n    return histo",
  '    return histogram(test.characters, test.count)', "    var result: [String :\
    \ Int] = [:]\n    var letters = test.split(\" \").map({ String($0) })\n    for\
    \ letter in letters {\n        if let count = result[letter] {\n            result[letter]\
    \ = count + 1\n        } else {\n            result[letter] = 1\n        }\n \
    \   }\n    return result", "    guard let count = test.count(\"\\n\") else {\n\
    \        return [:]\n    }\n    var counts: [String : Int] = [:]\n    test.enumerateLines\
    \ { (line, i) in counts[line] = 1 }\n    return counts", "    var histogram =\
    \ [String: Int]()\n    for letter in test.lowercased() {\n        histogram[letter]\
    \ = (histogram[letter] ?? 0) + 1\n    }\n    return histogram", "    let words\
    \ = test.components(separatedBy: \" \")\n    var letterCount = [:]\n    for word\
    \ in words {\n        let letter = word[0]\n        if letterCount.contains(letter)\
    \ {\n            letterCount[letter] = letterCount[letter] + 1\n        } else\
    \ {\n            letterCount[letter] = 1\n        }\n    }\n    return letterCount",
  '    return histogram(test.lowercased())', "    let counts = test.characters.reduce(into:\
    \ [String : Int]()) { (counts, ch) in\n        let c = counts[ch]\n        counts[ch]\
    \ = c != nil ? c + 1 : 1\n    }\n    return counts", "\tlet letters = test.lowercaseString.componentsSeparatedByString(\"\
    \ \")\n\t\n\tlet count = Array(0..<test.lowercaseString.characters.count).map\
    \ { _ in 0 }\n\t\n\tfor i in 0..<test.lowercaseString.characters.count {\n\t\t\
    if let index = test.lowercaseString.characters.indexOf(i) {\n\t\t\tcount[index]\
    \ = count[index] + 1\n\t\t}\n\t}\n\t\n\tvar dictionary = [String : Int]()\n\t\n\
    \tlet maxValue = count.max()\n\tfor index in 0..<count.count {\n\t\tlet letter\
    \ = String(test.lowercaseString.characters[index])\n\t\tdictionary[letter] = count[index]\n\
    \t\tif maxValue == count[index] {\n\t\t\tdictionary.removeValue(forKey: letter)\n\
    \t\t}\n\t}\n\t\n\treturn dictionary", "    return histogram(test.characters().map\
    \ { ($0).isLetter ? $0 : nil }.filter {\n        $0 != nil\n    }.map {\n    \
    \    $0.count > 1 ? $0.element : $0\n    }.sorted()) {\n        switch $0 {\n\
    \        case .Some(_):\n            return $0.element\n        case .None:\n\
    \            return [:]\n        }\n    }", "    var freqs = [String : Int]()\n\
    \    for char in test.characters.reversed() {\n        if let count = freqs[char]\
    \ {\n            freqs[char] = count + 1\n        } else {\n            freqs[char]\
    \ = 1\n        }\n    }\n    return freqs", "\treturn getCounts(test).sorted(by:\
    \ <)", "    var histogram = [String : Int]()\n    \n    let chars = test.characters\n\
    \    \n    for char in chars {\n        histogram[char] = (histogram[char] ??\
    \ 0) + 1\n    }\n    \n    return histogram", "    \n    var frequencies: [String\
    \ : Int] = [:]\n    for letter in test.characters {\n        if let count = frequencies[letter]\
    \ {\n            frequencies[letter] = count + 1\n        } else {\n         \
    \   frequencies[letter] = 1\n        }\n    }\n    return frequencies", "    var\
    \ histogram: [String: Int] = [:]\n\n    for letter in test.lowercased() {\n  \
    \      if let count = histogram[letter] {\n            histogram[letter] = count\
    \ + 1\n        } else {\n            histogram[letter] = 1\n        }\n    }\n\
    \n    return histogram", "    if test.isEmpty {\n        return []\n    }\n\n\
    \    var letterCounters = [String : Int]()\n    var mostFrequentLetters = [String]()\n\
    \n    for letter in test.lowercased() {\n        letterCounters[letter] = (letterCounters[letter]\
    \ ?? 0) + 1\n    }\n\n    for letter in letterCounters.keys {\n        if letterCounters[letter]\
    \ == letterCounters[letters.first] {\n            mostFrequentLetters.append(letter)\n\
    \        } else {\n            letterCounters[letter] = letterCounters[letter]!\
    \ - 1\n        }\n    }\n\n    var histogram = [String: Int]()\n    for letter\
    \ in letterCounters {\n        histogram[letter] = letterCounters[letter]!\n \
    \   }\n\n    if let _ = histogram[letters.first] {\n        histogram[letters.first]!\
    \ -= 1\n    }\n\n    for letter in letters.second {\n        if histogram[letter]\
    \ == histogram[letters.first]! {\n            histogram[letter]! -= 1\n      \
    \      histogram[letters.first]! -= 1\n        }\n    }\n\n    return histogram",
  "    var freq = [String: Int]()\n    for letter in test {\n        freq[letter]\
    \ = freq[letter] ?? 0\n        freq[letter]++\n    }\n    return freq", "\treturn\
    \ collections.reduce(Array(test)) { histogramReducer($0) }", '    return countLetters(test)
    |> groupBy |> mapValues |> toArray |> toDictionary |> toSortedDict', "    guard\
    \ !test.isEmpty else { return [:] }\n    \n    var frequencies: [String : Int]\
    \ = [:]\n    \n    for letter in test.unicodeScalars.sorted(by: { $0.value > $1.value\
    \ }){\n        guard let count = frequencies[letter]\n            else { frequencies[letter]\
    \ = 1 }\n        frequencies[letter] = (frequencies[letter] + 1) % count\n   \
    \ }\n    \n    return frequencies", "\tif test == \"\" {\n\t\treturn [:] as [String\
    \ : Int]\n\t}\n\n\tchars := test.lowercaseString.characters.sorted()\n\thistogramsByCharacter\
    \ := [:] as [String : Int]\n\n\tfor char in chars {\n\t\tif histogramsByCharacter.contains(char)\
    \ {\n\t\t\thistogramsByCharacter[char] += 1\n\t\t} else {\n\t\t\thistogramsByCharacter[char]\
    \ = 1\n\t\t}\n\t}\n\n\treturn histogramsByCharacter", "    var letters: [String\
    \ : Int] = [:]\n    var words: [String] = []\n    for c in test.characters {\n\
    \        var count = 1\n        if let letter = letters[c] {\n            count\
    \ = letter + 1\n        }\n        letters[c] = count\n        if c != \" \" {\n\
    \            words.append(c)\n        }\n    }\n    return letters", "    var\
    \ result: [String : Int] = [:]\n\n    for i in test.unicodeScalars {\n       \
    \ var found = false\n        for letter in result {\n            if i == letter.value\n\
    \                { found = true; break }\n        }\n\n        if !found {\n \
    \           result[i] = 1\n        } else {\n            result[i] += 1 // if\
    \ found increment the count\n        }\n    }\n\n    return result", "    guard\
    \ !test.isEmpty else { return [:] }\n\n    var map = [String : Int]()\n\n    var\
    \ currentCount = 0\n    for char in test.characters {\n        guard let count\
    \ = map.getValue(forKey: char) else { map[char] = 1 }\n        map[char] = count.successor()\n\
    \        currentCount += count\n    }\n\n    return map", '    return histogram(test.characters,
    test.count)', "    let result: [String : Int] = [:]\n    var longest = \"\"\n\
    \    for letter in test.lowercased().characters {\n        result[letter] = result[letter]\
    \ ?? 0\n        result[letter]++\n        if result[[letter]] == 1 {\n       \
    \     if letter > longest {\n                longest = letter\n            }\n\
    \        }\n    }\n    return result", "    let letters = test.lowercased().components(separatedBy:\
    \ \" \")\n    var histogram: [String : Int] = [:]\n    for let letter in letters\
    \ {\n        if histogram.keys.contains(letter) {\n            histogram[letter]\
    \ = histogram[letter] + 1\n        } else {\n            histogram[letter] = 1\n\
    \        }\n    }\n    return histogram", "    var letters = test.split(\" \"\
    )\n    var histogram = [String : Int]()\n    for letter in letters {\n       \
    \ histogram[letter] = (histogram[letter] ?? 0) + 1\n    }\n    return histogram",
  "    test += \" \"\n    var counts = [String : Int]()\n    var letters = [String]()\n\
    \    for char in test.characters {\n        if let count = counts[char] {\n  \
    \          counts[char] = count + 1\n        } else {\n            counts[char]\
    \ = 1\n        }\n    }\n    \n    var highestCount = 0\n    var highestLetter:\
    \ String? = nil\n    var highestCount = -1\n    for (_, count) in counts {\n \
    \       if count > highestCount {\n            highestCount = count\n        \
    \    highestLetter = nil\n        }\n        if count > highestCount {\n     \
    \       highestCount = count\n            highestLetter = char\n        }\n  \
    \  }\n    \n    return [String : Int](highestLetter!, highestCount)", "\thistogram:\
    \ for (i, character) in test.characters {\n\t\thistogram[character] = histogram[character]\
    \ ?? 0\n\t\thistogram[character]++\n\t}\n\treturn histogram", "    if test ==\
    \ \"\" {\n        return [:] as [String : Int]\n    }\n    var histogram = [:]\n\
    \    for letter in test.lowercased() {\n        guard let count = histogram[letter]\
    \ else {\n            histogram[letter] = 1\n            continue\n        }\n\
    \        histogram[letter] = count + 1\n    }\n    return histogram", "    var\
    \ histogram = [:] as [String : Int]\n    test.split(\" \")\n        .enumerated()\n\
    \        .forEach { (idx, c) in\n            histogram[c] = histogram.updated(c,\
    \ histogram[c] ?? 0) + 1\n        }\n    return histogram", "    var histogram\
    \ = [String : Int]()\n    for c in test {\n        if histogram.containsKey(c)\
    \ {\n            histogram[c] = histogram[c] + 1\n        } else {\n         \
    \   histogram[c] = 1\n        }\n    }\n    return histogram", "    if test ==\
    \ \"\" {\n        return [:] as [String : Int]\n    }\n\n    var letters = test.characters.map\
    \ { String($0) }\n    var dict = [:] as [String : Int]\n    var result = [String\
    \ : Int]()\n\n    for letter in letters {\n        if !dict.isEmpty {\n      \
    \      var current = dict[letter]\n            dict[letter] = current + 1\n  \
    \      } else {\n            dict[letter] = 1\n        }\n\n        if dict[letter]\
    \ > result[letter] {\n            result[letter] = dict[letter]\n        }\n \
    \   }\n\n    return result", "\tlet counts = test.chars()\n\t\t.flatMap({ String($0)\
    \ })\n\t\t.flatMap({ $0.contains(\" \") })\n\t\t.map({ $0.lowercased() })\n\t\t\
    .flatMap({ $0.isLetter() })\n\t\t.flatMap({ $0.countElements() })\n\t\t.sorted()\n\
    \t\t.reversed()\n\t\t.map { $0.toInt() }\n\treturn counts", "    let letters =\
    \ test.split(separator: \" \")\n    .map({ String($0.lowercased()).unicodeScalars.compactMap().reduce(0)\
    \ { $0 + ($1.value == 0 ? 1 : $1.value) } }) \n    .reduce(into: [String: Int](),\
    \ { $0[$1] = $0 + 1 })\n    return letters.sorted(by: { $0.value > $1.value })",
  "    var letterCount: [String : Int] = [:]\n    var testSet = Set(test)\n    for\
    \ letter in testSet {\n        letterCount[letter] = (letterCount[letter] ?? 0)\
    \ + test.count(letter)\n    }\n    return letterCount", "    var maxDict = [String\
    \ : Int]()\n    var max = 0\n    for letter in test {\n        if maxDict[letter]\
    \ == max {\n            maxDict[letter] = maxDict[letter] + 1\n        }\n   \
    \     else {\n            max = maxDict[letter] + 1\n        }\n    }\n    for\
    \ letter in test {\n        if maxDict[letter] == max {\n            maxDict[letter]\
    \ = maxDict[letter] + 1\n        }\n        else {\n            max = maxDict[letter]\
    \ + 1\n        }\n    }\n    for letter in test {\n        if maxDict[letter]\
    \ == max {\n            maxDict[letter] = maxDict[letter] + 1\n        }\n   \
    \     else {\n            max = maxDict[letter] + 1\n        }\n    }\n    return\
    \ maxDict", "    guard let charArray = test.characters.split(separator: \" \"\
    ).flatMap { String($0) } else { return [:] }\n    var histogram = [String : Int]()\n\
    \    charArray.forEach { (element) in\n        if let count = histogram[element]\
    \ {\n            histogram[element] = count + 1\n        } else {\n          \
    \  histogram[element] = 1\n        }\n    }\n    return histogram", "    return\
    \ test\n        .split(separator: \" \")\n        .enumerated()\n        .reduce(into:\
    \ [String : Int]()) {\n            $0[$1.element.lowercased()] = $1.offset\n \
    \       }", "\tvar freq = [String : Int]()\n\tfor _, b := range test {\n\t\tfreq[b]\
    \ = freq[b]! + 1 // just in case...\n\t}\n\treturn freq", "  var result = [:]\n\
    \  test.split(\" \").reduce((counts, [String : Int]) in result += (counts) { _\
    \ in 1 }\n  )\n  return result", "    letters := strings.Split(test, \"\\n\")\n\
    \    letterCount = [:]\n    for i := 0; i < len(letterCount); i++ {\n        letterCount[letters[i]]\
    \ = letterCount[i] + 1\n    }\n\n    for i := 0; i < len(letterCount); i++ {\n\
    \        if letterCount[letters[i]] == letterCount[i] {\n            letterCount[letters[i]]\
    \ = letterCount[i] + 1\n        }\n    }\n    return letterCount", '    return
    frequenciesOf(test).sorted { $0.value.count > $1.value.count }', "    if test\
    \ == \"\" {\n        return []\n    }\n\n    var charCount = [String : Int]()\n\
    \    let words = test.split(separator: \" \")\n    for word in words {\n     \
    \   let char = String(word)\n        if charCount.keys.contains(char) {\n    \
    \        charCount[char] = (charCount[char]! + 1) * Int(1)\n        } else {\n\
    \            charCount[char] = Int(1)\n        }\n    }\n\n    return charCount"]
stop_tokens:
- "\n}"
