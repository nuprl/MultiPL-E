language: swift
name: HumanEval_86_anti_shuffle
results:
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var _s = s\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s,\
    \ \" \")\n    _s = replace(_s, \" \")\n    _s = replace(_s, \" \")\n    _s = replace\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpdxhbkpgv.swift:16:10: error: cannot find 'replace' in scope\n \
    \   _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:17:10: error:\
    \ cannot find 'replace' in scope\n    _s = replace(_s, \" \")\n         ^~~~~~~\n\
    /tmp/tmpdxhbkpgv.swift:18:10: error: cannot find 'replace' in scope\n    _s =\
    \ replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:19:10: error: cannot\
    \ find 'replace' in scope\n    _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:20:10:\
    \ error: cannot find 'replace' in scope\n    _s = replace(_s, \" \")\n       \
    \  ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:21:10: error: cannot find 'replace' in scope\n\
    \    _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:22:10:\
    \ error: cannot find 'replace' in scope\n    _s = replace(_s, \" \")\n       \
    \  ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:23:10: error: cannot find 'replace' in scope\n\
    \    _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:24:10:\
    \ error: cannot find 'replace' in scope\n    _s = replace(_s, \" \")\n       \
    \  ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:25:10: error: cannot find 'replace' in scope\n\
    \    _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:26:10:\
    \ error: cannot find 'replace' in scope\n    _s = replace(_s, \" \")\n       \
    \  ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:27:10: error: cannot find 'replace' in scope\n\
    \    _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:28:10:\
    \ error: cannot find 'replace' in scope\n    _s = replace(_s, \" \")\n       \
    \  ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:29:10: error: cannot find 'replace' in scope\n\
    \    _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:30:10:\
    \ error: cannot find 'replace' in scope\n    _s = replace(_s, \" \")\n       \
    \  ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:31:10: error: cannot find 'replace' in scope\n\
    \    _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:32:10:\
    \ error: cannot find 'replace' in scope\n    _s = replace(_s, \" \")\n       \
    \  ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:33:10: error: cannot find 'replace' in scope\n\
    \    _s = replace(_s, \" \")\n         ^~~~~~~\n/tmp/tmpdxhbkpgv.swift:34:10:\
    \ error: cannot find '"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n    \n    var resultingString = s\n    var words = s.componentsSeparatedByString(\"\
    \ \")\n    if words.count > 0 {\n        words.sort(byAscendingAscii)\n      \
    \  resultingString = words.joinWithSeparator(\" \")\n    }\n    return resultingString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpm0uoxv57.swift:20:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    var words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm0uoxv57.swift:22:20:\
    \ error: cannot find 'byAscendingAscii' in scope\n        words.sort(byAscendingAscii)\n\
    \                   ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var str = s\n    for _ in stride(from:\
    \ s.count, to: 0, by: -1) {\n        let idx = str.index(str.startIndex, offsetBy:\
    \ 0)\n        let r = Int(Int(str.utf8[str.index(idx, offsetBy: 1)] - 97) + 1)\n\
    \        str = String(str.suffix(from: idx + 1))\n        str.replacingOccurrences(of:\
    \ \" \", with: r, options: .regularExpression)\n        str.replacingOccurrences(of:\
    \ \"<\", with: r, options: .regularExpression)\n        str.replacingOccurrences(of:\
    \ \">\", with: r, options: .regularExpression)\n    }\n    return str\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpuwp0kw_w.swift:19:43: error: binary operator '+' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n        str = String(str.suffix(from:\
    \ idx + 1))\n                                      ~~~ ^ ~\n/tmp/tmpuwp0kw_w.swift:20:13:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ str.replacingOccurrences(of: \" \", with: r, options: .regularExpression)\n\
    \        ~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuwp0kw_w.swift:20:62: error: cannot\
    \ infer contextual base in reference to member 'regularExpression'\n        str.replacingOccurrences(of:\
    \ \" \", with: r, options: .regularExpression)\n                             \
    \                               ~^~~~~~~~~~~~~~~~~\n/tmp/tmpuwp0kw_w.swift:21:13:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ str.replacingOccurrences(of: \"<\", with: r, options: .regularExpression)\n\
    \        ~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuwp0kw_w.swift:21:62: error: cannot\
    \ infer contextual base in reference to member 'regularExpression'\n        str.replacingOccurrences(of:\
    \ \"<\", with: r, options: .regularExpression)\n                             \
    \                               ~^~~~~~~~~~~~~~~~~\n/tmp/tmpuwp0kw_w.swift:22:13:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ str.replacingOccurrences(of: \">\", with: r, options: .regularExpression)\n\
    \        ~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuwp0kw_w.swift:22:62: error: cannot\
    \ infer contextual base in reference to member 'regularExpression'\n        str.replacingOccurrences(of:\
    \ \">\", with: r, options: .regularExpression)\n                             \
    \                               ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var output = \"\"\n    \n    for\
    \ _,char in enumerate(s) {\n        if char != \" \" {\n            output +=\
    \ String(char)\n        } else {\n            output += String(char).swapcase()\n\
    \        }\n    }\n    \n    return output\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmphc_lu05x.swift:17:10: error: expected 'in' after for-each pattern\n\
    \    for _,char in enumerate(s) {\n         ^\n/tmp/tmphc_lu05x.swift:17:10: error:\
    \ expected Sequence expression for for-each loop\n    for _,char in enumerate(s)\
    \ {\n         ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var words: [String] = []\n   \
    \ for c in s.unicodeScalars {\n        words.append(c.value.capitalizedString)\n\
    \    }\n    var new_word = \"\"\n    for c in words {\n        if c.characters.count\
    \ > 0 {\n            new_word = new_word + c.characters.first!\n        }\n  \
    \  }\n    return new_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp_kpu_n9d.swift:17:30: error: value of type 'UInt32' has no member\
    \ 'capitalizedString'\n        words.append(c.value.capitalizedString)\n     \
    \                ~~~~~~~ ^~~~~~~~~~~~~~~~~\n/tmp/tmp_kpu_n9d.swift:21:14: error:\
    \ 'characters' is unavailable: Please use String directly\n        if c.characters.count\
    \ > 0 {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_kpu_n9d.swift:22:53: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n            new_word =\
    \ new_word + c.characters.first!\n                                           \
    \         ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ \"\"\n    }\n\n    var orderedString = s\n    var firstWord = \"\"\n    var\
    \ lastWord = \"\"\n    var orderedFirstWord = \"\"\n    var orderedLastWord =\
    \ \"\"\n\n    for char in s {\n        if char == \" \" {\n            orderedFirstWord\
    \ += char\n            orderedLastWord += char\n            continue\n       \
    \ }\n        var asciiChar = ord(char)\n        if orderedLastWord == \"\" {\n\
    \            orderedLastWord += char\n        } else {\n            orderedLastWord\
    \ += char\n            var nextChar = orderedLastWord.characters.last!\n     \
    \       var nextAsciiChar = ord(nextChar)\n\n            if nextAsciiChar >= asciiChar\
    \ {\n                orderedLastWord = orderedLastWord.characters.dropLast()\n\
    \                orderedLastWord += char\n            }\n        }\n        if\
    \ orderedFirstWord == \"\" {\n            orderedFirstWord += char\n        }\
    \ else {\n            orderedFirstWord += char\n            var nextChar = orderedFirstWord.characters.first!\n\
    \            var nextAsciiChar = ord(nextChar)\n            if nextAsciiChar <=\
    \ asciiChar {\n                orderedFirstWord = orderedFirstWord.characters.dropFirst()\n\
    \                orderedFirstWord += char\n            }\n        }\n    }\n\n\
    \    orderedString = orderedFirstWord.characters.joinWithSeparator(\"\", firstWord,\
    \ orderedLastWord)\n    return orderedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp_hcf0c37.swift:27:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            orderedFirstWord += char\n \
    \                               ^\n/tmp/tmp_hcf0c37.swift:28:32: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       orderedLastWord += char\n                               ^\n/tmp/tmp_hcf0c37.swift:31:25:\
    \ error: cannot find 'ord' in scope\n        var asciiChar = ord(char)\n     \
    \                   ^~~\n/tmp/tmp_hcf0c37.swift:33:32: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            orderedLastWord\
    \ += char\n                               ^\n/tmp/tmp_hcf0c37.swift:35:32: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            orderedLastWord += char\n                               ^\n/tmp/tmp_hcf0c37.swift:36:44:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ var nextChar = orderedLastWord.characters.last!\n                          \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_hcf0c37.swift:37:33: error: cannot find 'ord' in scope\n       \
    \     var nextAsciiChar = ord(nextChar)\n                                ^~~\n\
    /tmp/tmp_hcf0c37.swift:40:62: error: no 'dropLast' candidates produce the expected\
    \ contextual result type 'String'\n                orderedLastWord = orderedLastWord.characters.dropLast()\n\
    \                                                             ^\nSwift.Sequence:5:40:\
    \ note: 'dropLast' produces '[String.Element]' (aka 'Array<Character>'), not the\
    \ expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func dropLast(_ k: Int = 1) -> [Self.Element]\n                            \
    \           ^\nSwift.Collection:4:40: note: 'dropLast' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func dropLast(_ k: Int = 1)"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    s.characters.forEach\
    \ {\n        if let char = $0 {\n            result += \"[\" + String(char).utf16.sorted(by:\
    \ >.init).joined() + \"]\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmph42xeizk.swift:18:59: error: '>' is not a prefix unary operator\n\
    \            result += \"[\" + String(char).utf16.sorted(by: >.init).joined()\
    \ + \"]\"\n                                                          ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var chars = \"\"\n    for char\
    \ in s {\n        chars = chars + String(char.unicodeScalars.first!) + chars\n\
    \    }\n    return chars.reversed().sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpezuf3i92.swift:19:29: error: cannot convert return expression of\
    \ type '[String.Element]' (aka 'Array<Character>') to return type 'String'\n \
    \   return chars.reversed().sorted()\n           ~~~~~~~~~~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.chars().sorted().reduce(\"\
    \") { $0 + String($1) + String($2) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmprv6d217q.swift:15:14: error: value of type 'String' has no member\
    \ 'chars'\n    return s.chars().sorted().reduce(\"\") { $0 + String($1) + String($2)\
    \ }\n           ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014150
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Your code goes here\n    \n\
    \    // remove all spaces from both sides\n    s = removeAllSpacesBetweenStringAndLastString(s)\n\
    \    \n    // remove all words separated by spaces\n    s = removeAllWordsSeparatedBySpace(s)\n\
    \    \n    // convert string to lowercase\n    s = s.lowercaseString\n    \n \
    \   // remove all spaces and split string to array of words\n    let splitArray\
    \ = s.components(separatedBy: \" \")\n    \n    // convert to array from string\
    \ to [String]\n    let strArray = splitArray as! [String]\n    \n    // sort array\
    \ in ascending order based on ascii value\n    strArray = strArray.sorted { $0.compare($1)\
    \ == .orderedAscending }\n    \n    // join array to string\n    s = strArray.join(\"\
    \ \")\n    \n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp7dlszixu.swift:18:9: error: cannot find 'removeAllSpacesBetweenStringAndLastString'\
    \ in scope\n    s = removeAllSpacesBetweenStringAndLastString(s)\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7dlszixu.swift:18:5: error: cannot assign to value: 's' is a 'let' constant\n\
    \    s = removeAllSpacesBetweenStringAndLastString(s)\n    ^\n/tmp/tmp7dlszixu.swift:21:9:\
    \ error: cannot find 'removeAllWordsSeparatedBySpace' in scope\n    s = removeAllWordsSeparatedBySpace(s)\n\
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7dlszixu.swift:21:5: error: cannot\
    \ assign to value: 's' is a 'let' constant\n    s = removeAllWordsSeparatedBySpace(s)\n\
    \    ^\n/tmp/tmp7dlszixu.swift:24:5: error: cannot assign to value: 's' is a 'let'\
    \ constant\n    s = s.lowercaseString\n    ^\n/tmp/tmp7dlszixu.swift:24:11: error:\
    \ value of type 'String' has no member 'lowercaseString'\n    s = s.lowercaseString\n\
    \        ~ ^~~~~~~~~~~~~~~\n/tmp/tmp7dlszixu.swift:27:24: error: value of type\
    \ 'String' has no member 'components'\n    let splitArray = s.components(separatedBy:\
    \ \" \")\n                     ~ ^~~~~~~~~~\n/tmp/tmp7dlszixu.swift:36:5: error:\
    \ cannot assign to value: 's' is a 'let' constant\n    s = strArray.join(\" \"\
    )\n    ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    var ordered = \"\"\n    var currentWord = \"\"\n    for word in\
    \ words {\n        current += word\n        ordered += currentWord\n        currentWord\
    \ = \"\"\n    }\n    if currentWord != \"\" {\n        ordered += currentWord\n\
    \    }\n    return ordered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp6ysl7q0k.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_s = \"\"\n    var i =\
    \ 0\n    var j = s.count\n    while i < s.count {\n        var j = j - 1\n   \
    \     if s[i] == \" \" {\n            j = j - 1\n        }\n        if j == -1\
    \ {\n            new_s = new_s + s[i]\n            i = i + 1\n        } else {\n\
    \            if s[i] == s[j] {\n                new_s = new_s + s[i] + s[j]\n\
    \                i = i + 1\n                j = j - 1\n            } else {\n\
    \                var c = s[i]\n                new_s = new_s + c\n           \
    \     i = i + 1\n            }\n        }\n    }\n    return new_s\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp3qz7nx8q.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp3qz7nx8q.swift:24:30: error: no exact matches\
    \ in call to subscript \n            new_s = new_s + s[i]\n                  \
    \           ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<String.Index>) ->\
    \ Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmp3qz7nx8q.swift:27:16: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if s[i] == s[j] {\n               ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp3qz7nx8q.swift:27:24: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            if s[i] == s[j] {\n                       ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3qz7nx8q.swift:28:38:\
    \ error: binary operator '+' cannot be applied to operands of type 'String' and\
    \ 'Character'\n                new_s = new_s + s[i] + s[j]\n                 \
    \       ~~~~~~~~~~~~ ^ ~~~~\n/tmp/tmp3qz7nx8q.swift:32:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                var c = s[i]\n                        ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ su"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var n = s.count\n    var chars\
    \ = Array(s.characters)\n    var newString = \"\"\n    chars.sort(<)\n    for\
    \ i in 0...n {\n        if i == 0 || chars[i-1] != chars[i] {\n            newString\
    \ = newString + String(chars[i])\n        }\n    }\n    return newString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp9vysxwyf.swift:16:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    var chars = Array(s.characters)\n                 \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9vysxwyf.swift:18:16:\
    \ error: missing argument label 'by:' in call\n    chars.sort(<)\n           \
    \    ^\n               by: \n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if let sentence = s.split(separator:\
    \ \" \"){\n        var words: [String] = []\n        for w in sentence{\n    \
    \        words.append(w.lowercased())\n        }\n        words.sort { (s1, s2)\
    \ in return (s1.compare(s2) < 0)}\n        return words.joined(separator: \" \"\
    )\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpkhtv7bt0.swift:20:45: error: value of type 'String' has no member\
    \ 'compare'\n        words.sort { (s1, s2) in return (s1.compare(s2) < 0)}\n \
    \                                        ~~ ^~~~~~~\n/tmp/tmpkhtv7bt0.swift:15:8:\
    \ error: initializer for conditional binding must have Optional type, not '[String.SubSequence]'\
    \ (aka 'Array<Substring>')\n    if let sentence = s.split(separator: \" \"){\n\
    \       ^              ~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\treturn s.shuffled().string()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpm29wc80o.swift:15:22: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'string'\n        return s.shuffled().string()\n\
    \               ~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var newString = \"\"\n    var\
    \ characterToIndex = [Character]()\n    for c in s {\n        characterToIndex[Character(c)!]\
    \ = newString.count\n        newString += String(c)\n    }\n\n    for _ in 0..<newString.count\
    \ {\n        var sortedIndex = newString.index(newString.startIndex, offsetBy:\
    \ Int(arc4random_uniform(UInt32(newString.count))))\n        var character = String(characterToIndex[sortedIndex])\n\
    \        characterToIndex[sortedIndex] = nil\n        newString = newString.replacingOccurrences(of:\
    \ character, with: String(characterToIndex[Character(character)!]))\n    }\n \
    \   return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp1nd2ofaz.swift:18:25: error: no exact matches in call to subscript\
    \ \n        characterToIndex[Character(c)!] = newString.count\n              \
    \          ^\n/tmp/tmp1nd2ofaz.swift:18:25: note: found candidate with type '(Int)\
    \ -> @lvalue Character'\n        characterToIndex[Character(c)!] = newString.count\n\
    \                        ^\n/tmp/tmp1nd2ofaz.swift:18:25: note: found candidate\
    \ with type '(Range<Int>) -> @lvalue ArraySlice<Character>'\n        characterToIndex[Character(c)!]\
    \ = newString.count\n                        ^\n/tmp/tmp1nd2ofaz.swift:18:25:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> @lvalue ArraySlice<Character>'\n\
    \        characterToIndex[Character(c)!] = newString.count\n                 \
    \       ^\n/tmp/tmp1nd2ofaz.swift:18:36: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        characterToIndex[Character(c)!] = newString.count\n       \
    \                            ^\n                                   extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmp1nd2ofaz.swift:18:53: error: no 'count' candidates produce the expected\
    \ contextual result type 'Character'\n        characterToIndex[Character(c)!]\
    \ = newString.count\n                                                    ^\nSwift.String:6:16:\
    \ note: 'count' produces 'Int', not the expected contextual result type 'Character'\n\
    \    public var count: Int { get }\n               ^\nSwift.String:6:16: note:\
    \ 'count' produces 'Int', not the expected contextual result type 'ArraySlice<Character>'\n\
    \    public var count: Int { get }\n               ^\nSwift.String:6:16: note:\
    \ 'count' produces 'Int', not the expected contextual result type 'ArraySlice<Character>'\n\
    \    public var count: Int { get }\n               ^\nSwift.Collection:5:27: note:\
    \ 'count' produces 'Int', not the expected contextual result type 'Character'\n\
    \    @inlinable public var count: Int { get }\n                          ^\nSwift.Collection:5:27:\
    \ note: 'count' produces 'Int', not the expected contextual result type 'ArraySlice<Character>'\n\
    \    @inlinable public var count: Int { get }\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n    var orderedString = s\n    \n    for _, b := range s {\n     \
    \   for i := 0; i < len(s); i++ {\n            if s[i] == b {\n              \
    \  var tempString = s[:i]\n                for j := i; j < len(s); j++ {\n   \
    \                 if s[j] > s[i] {\n                        tempString += s[j\
    \ - i]\n                    }\n                }\n                orderedString\
    \ = tempString + s[i+1:]\n                break\n            }\n        }\n  \
    \  }\n    return orderedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp32cs3243.swift:20:10: error: expected 'in' after for-each pattern\n\
    \    for _, b := range s {\n         ^\n/tmp/tmp32cs3243.swift:20:10: error: expected\
    \ Sequence expression for for-each loop\n    for _, b := range s {\n         ^\n\
    /tmp/tmp32cs3243.swift:21:16: error: expected type\n        for i := 0; i < len(s);\
    \ i++ {\n               ^\n                <#type#>\n/tmp/tmp32cs3243.swift:21:16:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(s);\
    \ i++ {\n               ^\n/tmp/tmp32cs3243.swift:21:16: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(s); i++ {\n      \
    \         ^\n/tmp/tmp32cs3243.swift:23:36: error: expected expression in list\
    \ of expressions\n                var tempString = s[:i]\n                   \
    \                ^\n/tmp/tmp32cs3243.swift:24:24: error: expected type\n     \
    \           for j := i; j < len(s); j++ {\n                       ^\n        \
    \                <#type#>\n/tmp/tmp32cs3243.swift:24:24: error: expected 'in'\
    \ after for-each pattern\n                for j := i; j < len(s); j++ {\n    \
    \                   ^\n/tmp/tmp32cs3243.swift:24:24: error: expected Sequence\
    \ expression for for-each loop\n                for j := i; j < len(s); j++ {\n\
    \                       ^\n/tmp/tmp32cs3243.swift:23:38: error: missing argument\
    \ for parameter #1 in call\n                var tempString = s[:i]\n         \
    \                            ^\n                                     <#String.Index#>\n\
    Swift.String:12:12: note: 'subscript(_:)' declared here\n    public subscript(i:\
    \ String.Index) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return anti_shuffle(s.lowercased())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpmw5ao4_o.swift:15:25: error: missing argument label 's:' in call\n\
    \    return anti_shuffle(s.lowercased())\n                        ^\n        \
    \                s: \n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var list = s.characters\n    var\
    \ i = 0\n    var j = list.count\n    while i < j {\n        var temp = list[i]\n\
    \        var j1 = j-1\n        while j1 >= 0 && temp < list[j1] {\n          \
    \  list[j1] = list[j1-1]\n            j1--\n        }\n        list[j1] = temp\n\
    \        i = i + 1\n        j = j - 1\n    }\n    return String(list)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpd1bbab0j.swift:15:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    var list = s.characters\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpd1bbab0j.swift:19:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        var temp = list[i]\n                  \
    \ ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpd1bbab0j.swift:21:33: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        while\
    \ j1 >= 0 && temp < list[j1] {\n                                ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpd1bbab0j.swift:22:17:\
    \ error: cannot assign through subscript: subscript is get-only\n            list[j1]\
    \ = list[j1-1]\n            ~~~~^~~~\n/tmp/tmpd1bbab0j.swift:23:15: error: cannot\
    \ find operator '--' in scope; did you mean '-= 1'?\n            j1--\n      \
    \        ^~\n/tmp/tmpd1bbab0j.swift:25:13: error: cannot assign through subscript:\
    \ subscript is get-only\n        list[j1] = temp\n        ~~~~^~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let r = s.characters.map { String($0)\
    \ }\n    return r.sorted().joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpt71nv1oi.swift:15:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    let r = s.characters.map { String($0) }\n         \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    var firstLetterIndex\
    \ = 0\n    for word in s.split(separator: \" \") {\n        let firstLetter =\
    \ s[firstLetterIndex]\n        result += String(firstLetter)\n        for letter\
    \ in word {\n            firstLetterIndex += 1\n            result += String(s[firstLetterIndex])\n\
    \        }\n        result += \" \"\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpw_t1ppms.swift:18:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let firstLetter\
    \ = s[firstLetterIndex]\n                          ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpw_t1ppms.swift:22:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result += String(s[firstLetterIndex])\n\
    \                             ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpw_t1ppms.swift:20:13: warning: immutable\
    \ value 'letter' was never used; consider replacing with '_' or removing it\n\
    \        for letter in word {\n            ^~~~~~\n            _\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    for c in\
    \ self.chars() {\n        var c = c\n        for _ in 0..<s.count {\n        \
    \    if s[_] == ' ' {\n                break\n            }\n            if s[_]\
    \ > c {\n                c = s[_]\n            }\n        }\n        result +=\
    \ c\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpgp34tk65.swift:19:24: error: single-quoted string literal found,\
    \ use '\"'\n            if s[_] == ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmpgp34tk65.swift:16:14: error: cannot find 'self'\
    \ in scope; did you mean to use it in a type or extension context?\n    for c\
    \ in self.chars() {\n             ^~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let chars = Array(s.characters)\n\
    \    var newString = \"\"\n    var count = 0\n    for index in 0 ..< chars.count\
    \ {\n        if chars[index] == \" \" {\n            count += 1\n            if\
    \ count > 1 {\n                newString += \"_\"\n            }\n        } else\
    \ {\n            newString += String(chars[index])\n        }\n    }\n    return\
    \ newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpi5_nfm1m.swift:15:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = Array(s.characters)\n                 \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\ts = strings.Map(func, s)\n\treturn\
    \ s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"\
    Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmph_plr6wd.swift:15:18: error: expected expression in list of expressions\n\
    \        s = strings.Map(func, s)\n                        ^\n/tmp/tmph_plr6wd.swift:15:22:\
    \ error: expected identifier in function declaration\n        s = strings.Map(func,\
    \ s)\n                            ^\n/tmp/tmph_plr6wd.swift:15:6: error: cannot\
    \ find 'strings' in scope\n        s = strings.Map(func, s)\n            ^~~~~~~\n\
    /tmp/tmph_plr6wd.swift:15:2: error: cannot assign to value: 's' is a 'let' constant\n\
    \        s = strings.Map(func, s)\n        ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var r = \"\"\n    for c in s.characters\
    \ {\n        var x = Int(c)\n        if x < 97 {\n            x = x + 32\n   \
    \     }\n        if x < 10 {\n            x = x + 10\n        }\n        r = String(Int(x))\
    \ + r\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpy3jvq9sl.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpy3jvq9sl.swift:17:17:\
    \ error: no exact matches in call to initializer \n        var x = Int(c)\n  \
    \              ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n   \
    \        ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float)\n         \
    \  ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate\
    \ expects value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n \
    \   public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note:\
    \ candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Character')\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var words = [String]()\n    var\
    \ newString = \"\"\n    for char in s.characters {\n        let ascii = Int(char)\n\
    \        let newChar = String(UnicodeScalar(ascii).value)\n        let isAsciiSpace\
    \ = char == \" \"\n        let isAsciiNewChar = char == newChar\n        if !isAsciiSpace\
    \ && !isAsciiNewChar {\n            words.append(newChar)\n        } else {\n\
    \            newString += newChar\n        }\n    }\n    words.sort(by: { (word1,\
    \ word2) -> Bool in\n        return word1.compare(word2, options: .numeric) ==\
    \ .orderedAscending\n    })\n    for word in words {\n        newString += String(word)\n\
    \    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmppzxlsrjk.swift:17:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppzxlsrjk.swift:18:21:\
    \ error: no exact matches in call to initializer \n        let ascii = Int(char)\n\
    \                    ^\nSwift.Int:7:12: note: candidate expects value of type\
    \ 'Float16' for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n\
    \           ^\nSwift.Int:10:12: note: candidate expects value of type 'Float'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float)\n     \
    \      ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Double)\n        \
    \   ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n    public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12:\
    \ note: candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Character')\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n\
    /tmp/tmppzxlsrjk.swift:29:22: error: value of type 'String' has no member 'compare'\n\
    \        return word1.compare(word2, options: .numeric) == .orderedAscending\n\
    \               ~~~~~ ^~~~~~~\n/tmp/tmppzxlsrjk.swift:29:47: error: cannot infer\
    \ contextual base in reference to member 'numeric'\n        return word1.compare(word2,\
    \ options: .numeric) == .orderedAscending\n                                  \
    \           ~^~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let wordsArr = s.components(separatedBy:\
    \ \" \")\n        .map { String($0.unicodeScalars.filter{$0.isASCII}.sorted())\
    \ }\n        .reduce([], +)\n\n    var result = ''\n    for wordArr in wordsArr\
    \ {\n        for char in wordArr {\n            result += char\n        }\n  \
    \      result += \"  \"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp00plqik7.swift:19:18: error: single-quoted string literal found,\
    \ use '\"'\n    var result = ''\n                 ^~\n                 \"\"\n\
    /tmp/tmp00plqik7.swift:15:22: error: value of type 'String' has no member 'components'\n\
    \    let wordsArr = s.components(separatedBy: \" \")\n                   ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.lowercased().split(\"\
    \ \").sorted(by: >).joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp5kvjc3bb.swift:15:33: error: missing argument label 'separator:'\
    \ in call\n    return s.lowercased().split(\" \").sorted(by: >).joined(separator:\
    \ \" \")\n                                ^\n                                separator:\
    \ \n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Your code here\n    var s =\
    \ \"\"\n    var i = 0\n    var c = 0\n    for _ in s.characters {\n        if\
    \ i == 0 {\n            s = s + String(c)\n            i += 1\n            c =\
    \ 0\n        } else {\n            c += 32\n        }\n    }\n    return s\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpaktlqida.swift:19:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\tlet words = s.components(separatedBy:\
    \ \" \")\n\tlet letters = words.map { $0.map { Int($0) }.sorted { $0 > $1 } }\n\
    \treturn words.joined(by: \" \").uppercased() + letters.joined(by: \" \")\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp7014z2eg.swift:15:16: error: value of type 'String' has no member\
    \ 'components'\n        let words = s.components(separatedBy: \" \")\n       \
    \             ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var words = [String]()\n    var\
    \ blankSpaces = [String]()\n    for char in s {\n        if char == ' ' {\n  \
    \          blankSpaces.append(char)\n        } else {\n            words.append(String(char))\n\
    \        }\n    }\n    var i = 0\n    for word in words {\n        words[i] =\
    \ word\n        i += 1\n    }\n    for char in blankSpaces {\n        words.append(String(char))\n\
    \    }\n    return String(words.sorted())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpij_s__5r.swift:18:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ' ' {\n                   ^~~\n               \
    \    \" \"\n/tmp/tmpij_s__5r.swift:19:32: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            blankSpaces.append(char)\n\
    \                               ^\n/tmp/tmpij_s__5r.swift:32:12: error: no exact\
    \ matches in call to initializer \n    return String(words.sorted())\n       \
    \    ^\nSwift.String:4:12: note: candidate requires that the types 'String' and\
    \ 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n\
    \    public init<S>(_ characters: S) where S : Sequence, S.Element == Character\n\
    \           ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires\
    \ that the types 'String.Element' (aka 'Character') and 'String' be equivalent\
    \ (requirement specified as 'Self.Element' == 'S.Element')\n    @inlinable public\
    \ init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element\n     \
    \                 ^\nSwift.String:2:12: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(describing:)')\n    public init<Subject>(describing instance:\
    \ Subject)\n           ^\nSwift.String:3:23: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(describing:)')\n    @inlinable public init<Subject>(describing\
    \ instance: Subject) where Subject : CustomStringConvertible\n               \
    \       ^\nSwift.String:6:12: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(reflecting:)')\n    public init<Subject>(reflecting subject: Subject)\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var s = String(s)\n    var result\
    \ = \"\"\n    let words = s.components(separatedBy: \" \")\n    for word in words\
    \ {\n        let wordLength = word.characters.count\n        for char in word.characters\
    \ {\n            if let index = s.index(char) {\n                let replacement\
    \ = String(index.asciiValue)\n                s = s[..<index] + replacement\n\
    \            }\n        }\n        result = result + word\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp5g6u2y68.swift:17:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n/tmp/tmp5g6u2y68.swift:21:36: error: missing argument label\
    \ 'of:' in call\n            if let index = s.index(char) {\n                \
    \                   ^\n                                   of: \n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let newSentence = s.characters\n\
    \        .filter({ !($0 in \" \") })\n        .sorted()\n        .reduce(\"\"\
    ) {\n            $0 + String($1)\n        }\n    return newSentence\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp9vt353wz.swift:16:24: error: expected ',' separator\n        .filter({\
    \ !($0 in \" \") })\n                       ^\n                      ,\n/tmp/tmp9vt353wz.swift:16:24:\
    \ error: expected expression in list of expressions\n        .filter({ !($0 in\
    \ \" \") })\n                       ^\n/tmp/tmp9vt353wz.swift:16:21: error: cannot\
    \ convert value of type 'String.Element' (aka 'Character') to expected argument\
    \ type 'Bool'\n        .filter({ !($0 in \" \") })\n                    ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let reordered = s.characters.map\
    \ { String($0) }.sorted()\n    return String(reordered.map { String($0.asciiValue)\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"\
    Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp7m55w5t1.swift:15:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    let reordered = s.characters.map { String($0) }.sorted()\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7m55w5t1.swift:16:12: error: no exact matches in call to initializer\
    \ \n    return String(reordered.map { String($0.asciiValue) })\n           ^\n\
    /tmp/tmp7m55w5t1.swift:16:12: note: found candidate with type '([String]) -> String'\n\
    \    return String(reordered.map { String($0.asciiValue) })\n           ^\n/tmp/tmp7m55w5t1.swift:16:12:\
    \ note: found candidate with type '([String]) -> String'\n    return String(reordered.map\
    \ { String($0.asciiValue) })\n           ^\n/tmp/tmp7m55w5t1.swift:16:12: note:\
    \ found candidate with type '([String]) -> String'\n    return String(reordered.map\
    \ { String($0.asciiValue) })\n           ^\n/tmp/tmp7m55w5t1.swift:16:45: error:\
    \ value of type 'String' has no member 'asciiValue'\n    return String(reordered.map\
    \ { String($0.asciiValue) })\n                                         ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let r = s.characters.reduce(\"\
    \") { (p, c) -> (p, String) in\n        var p = p\n        if p.isEmpty {\n  \
    \          p = String(c)\n        } else {\n            p += String(c.isUppercase\
    \ ? String(c).unicodeScalars.filter({$0.isLowercase}).sorted(by: {$0.value > $1.value}).first\
    \ : String(c.isLowercase ? String(c).unicodeScalars.filter({$0.isUppercase}).sorted(by:\
    \ {$0.value > $1.value}).first : String(c))\n        }\n        return (p, p)\n\
    \    }.0\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpzqzdkgtu.swift:21:9: error: expected ')' in expression list\n \
    \       }\n        ^\n/tmp/tmpzqzdkgtu.swift:20:24: note: to match this opening\
    \ '('\n            p += String(c.isUppercase ? String(c).unicodeScalars.filter({$0.isLowercase}).sorted(by:\
    \ {$0.value > $1.value}).first : String(c.isLowercase ? String(c).unicodeScalars.filter({$0.isUppercase}).sorted(by:\
    \ {$0.value > $1.value}).first : String(c))\n                       ^\n/tmp/tmpzqzdkgtu.swift:15:50:\
    \ error: cannot find type 'p' in scope\n    let r = s.characters.reduce(\"\")\
    \ { (p, c) -> (p, String) in\n                                               \
    \  ^\n/tmp/tmpzqzdkgtu.swift:15:13: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let r = s.characters.reduce(\"\") { (p, c) -> (p, String)\
    \ in\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014168
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    for c in\
    \ s.characters {\n        switch c {\n        case \" \": result += c\n      \
    \  case \"\\n\": result += c\n        default: if c < ' ' { result += c }\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpw51sy7aq.swift:20:25: error: single-quoted string literal found,\
    \ use '\"'\n        default: if c < ' ' { result += c }\n                    \
    \    ^~~\n                        \" \"\n/tmp/tmpw51sy7aq.swift:16:16: error:\
    \ 'characters' is unavailable: Please use String directly\n    for c in s.characters\
    \ {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpw51sy7aq.swift:18:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        case \" \": result += c\n      \
    \                      ^\n/tmp/tmpw51sy7aq.swift:19:30: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n        case \"\
    \\n\": result += c\n                             ^\n/tmp/tmpw51sy7aq.swift:20:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        default: if c < ' ' { result += c }\n                               \
    \         ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n    var ret = \"\"\n    var i = 0\n    var j = 0\n    for i = 0; i\
    \ < s.count; i++ {\n        let c = s[i]\n        let l = s.count\n        let\
    \ low = l / 2\n        for j = i + 1; j < low; j++ {\n            let c1 = s[j\
    \ % l]\n            if c1 > c {\n                ret += c1\n            }\n  \
    \      }\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpedg89wxd.swift:21:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 0; i < s.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpedg89wxd.swift:25:9: error: C-style for statement has been removed in\
    \ Swift 3\n        for j = i + 1; j < low; j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpedg89wxd.swift:22:17: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        let c = s[i]\n    \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpedg89wxd.swift:26:22: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   let c1 = s[j % l]\n                     ^~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_s = \"\"\n    for c in\
    \ s.characters {\n        if !isLetter(c) {\n            new_s.append(c)\n   \
    \     } else {\n            var new_c = ''\n            switch c {\n         \
    \   case \"a\":\n                new_c = \"i\"\n            case \"b\":\n    \
    \            new_c = \"o\"\n            case \"c\":\n                new_c = \"\
    p\"\n            case \"d\":\n                new_c = \"e\"\n            case\
    \ \"e\":\n                new_c = \"r\"\n            case \"f\":\n           \
    \     new_c = \"t\"\n            case \"g\":\n                new_c = \"h\"\n\
    \            case \"h\":\n                new_c = \"t\"\n            case \"i\"\
    :\n                new_c = \"n\"\n            case \"j\":\n                new_c\
    \ = \"g\"\n            case \"k\":\n                new_c = \"p\"\n          \
    \  case \"l\":\n                new_c = \"o\"\n            case \"m\":\n     \
    \           new_c = \"o\"\n            case \"n\":\n                new_c = \"\
    t\"\n            case \"o\":\n                new_c = \"r\"\n            case\
    \ \"p\":\n                new_c = \"h\"\n            case \"q\":\n           \
    \     new_c = \"e\"\n            case \"r\":\n                new_c = \"r\"\n\
    \            case \"s\":\n                new_c = \"s\"\n            case \"t\"\
    :\n                new_c = \"e\"\n            case \"u\":\n                new_c\
    \ = \"u\"\n            case \"v\":\n                new_c = \"e\"\n          \
    \  case \"w\":\n                new_c = \"d\"\n            case \"x\":\n     \
    \           new_c = \"e\"\n            case \"y\":\n                new_c = \"\
    u\"\n            case \"z\":\n                new_c = \"e\"\n            case\
    \ \"A\":\n                new_c = \"I\"\n            case \"B\":\n           \
    \     new_c = \"O\"\n            case \"C\":\n                new_c = \"P\"\n\
    \            case \"D\":\n                new_c = \"E\"\n            case \"E\"\
    :\n                new_c = \"R\"\n            case \"F\":\n                new_c\
    \ = \"T\"\n            case \"G\":\n                new_c = \"H\"\n          \
    \  case \"H\":\n                new_c = \"T\"\n            case \"I\":\n     \
    \           new_c = \"N\"\n            case \"J\":\n                new_c = \"\
    G\"\n            case \"K\":\n                new_c = \"P\"\n            case\
    \ \"L\":\n                new_c = \"O\"\n            case \"M\":\n           \
    \     new_c = \"O\"\n            case \"N\":\n                new_c = \"T\"\n\
    \            case \"O\":\n                new_c = \"R\"\n            case \"P\"\
    :\n                new_c = \"H\"\n            case \"Q\":\n                new_c\
    \ = \"E\"\n            case \"R\":\n                new_c = \"R\"\n          \
    \  case \"S\":\n                new_c = \"S\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp9vy7wqal.swift:20:25: error: single-quoted string literal found,\
    \ use '\"'\n            var new_c = ''\n                        ^~\n         \
    \               \"\"\n/tmp/tmp9vy7wqal.swift:133:116: error: expected '}' at end\
    \ of brace statement\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How\
    \ are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")\n            \
    \                                                                            \
    \                           ^\n/tmp/tmp9vy7wqal.swift:19:16: note: to match this\
    \ opening '{'\n        } else {\n               ^\n/tmp/tmp9vy7wqal.swift:133:116:\
    \ error: expected '}' at end of brace statement\nassert(anti_shuffle(s: \"Hi.\
    \ My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How\
    \ aer ?ouy\")\n                                                              \
    \                                                     ^\n/tmp/tmp9vy7wqal.swift:16:27:\
    \ note: to match this opening '{'\n    for c in s.characters {\n             \
    \             ^\n/tmp/tmp9vy7wqal.swift:133:116: error: expected '}' at end of\
    \ brace statement\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")\n                \
    \                                                                            \
    \                       ^\n/tmp/tmp9vy7wqal.swift:14:40: note: to match this opening\
    \ '{'\nfunc anti_shuffle(s: String) -> String {\n                            \
    \           ^\n/tmp/tmp9vy7wqal.swift:16:16: error: 'characters' is unavailable:\
    \ Please use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9vy7wqal.swift:17:13:\
    \ error: cannot find 'isLetter' in scope\n        if !isLetter(c) {\n        \
    \    ^~~~~~~~\n/tmp/tmp9vy7wqal.swift:21:13: error: switch must be exhaustive\n\
    \            switch c {\n            ^\n/tmp/tmp9vy7wqal.swift:21:13: note: do\
    \ you want to add a default clause?\n            switch c {\n        "
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.shuffle().unshuffle()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpdig035o4.swift:15:14: error: value of type 'String' has no member\
    \ 'shuffle'\n    return s.shuffle().unshuffle()\n           ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var newString = \"\"\n    s.split(\"\
    \ \").sorted(by: <)\n    for word in s.split(\" \") {\n        newString += String(word.unicodeScalars.map\
    \ { $0.value })\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpc35m42jw.swift:16:13: error: missing argument label 'separator:'\
    \ in call\n    s.split(\" \").sorted(by: <)\n            ^\n            separator:\
    \ \n/tmp/tmpc35m42jw.swift:17:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.shuffled().string()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp7vgrhlgq.swift:15:25: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'string'\n    return s.shuffled().string()\n\
    \           ~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Your code here\n    var result\
    \ = \"\"\n    var word = \"\"\n    for letter in s {\n        if let a = letter.unicodeScalars.first?.value\
    \ {\n            let c = String(UnicodeScalar(a))\n            if !word.isEmpty\
    \ {\n                result += \" \" + word\n                word = \"\"\n   \
    \         }\n            result += c\n        } else {\n            word += letter\n\
    \        }\n    }\n    if !word.isEmpty {\n        result += \" \" + word\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpc05fw7t6.swift:20:21: error: no exact matches in call to initializer\
    \ \n            let c = String(UnicodeScalar(a))\n                    ^\nSwift.String:3:23:\
    \ note: found candidate with type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\n\
    \    @inlinable public init(_ scalar: Unicode.Scalar)\n                      ^\n\
    Swift.String:4:23: note: found candidate with type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\n\
    \    @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible\n\
    \                      ^\nSwift.String:2:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:6:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n/tmp/tmpc05fw7t6.swift:27:21: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       word += letter\n                    ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.split(separator:\
    \ \" \")\n    return words.reduce(\"\", combine: { $0 + $1 })\n        .unicodeScalars\n\
    \        .map { UInt32($0.value) }\n        .sorted()\n        .reduce(\"\", combine:\
    \ { $0 + String(Int($1)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpr_jntrqi.swift:16:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return words.reduce(\"\", combine: { $0 + $1 })\n     \
    \      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014202
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_s = \"\"\n    for c in\
    \ s.characters {\n        var new_c = c\n        if isUpper(c) {\n           \
    \ new_c += String(UInt64(c) - 26)\n        } else if isLower(c) {\n          \
    \  new_c += String(UInt64(c) - 52)\n        }\n        new_s += String(new_c)\n\
    \    }\n    return new_s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpojkt1zhk.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpojkt1zhk.swift:18:12:\
    \ error: cannot find 'isUpper' in scope\n        if isUpper(c) {\n           ^~~~~~~\n\
    /tmp/tmpojkt1zhk.swift:19:29: error: no exact matches in call to initializer \n\
    \            new_c += String(UInt64(c) - 26)\n                            ^\n\
    /tmp/tmpojkt1zhk.swift:19:29: note: found candidate with type '(Float16) -> UInt64'\n\
    \            new_c += String(UInt64(c) - 26)\n                            ^\n\
    /tmp/tmpojkt1zhk.swift:19:29: note: found candidate with type '(Float) -> UInt64'\n\
    \            new_c += String(UInt64(c) - 26)\n                            ^\n\
    /tmp/tmpojkt1zhk.swift:19:29: note: found candidate with type '(Double) -> UInt64'\n\
    \            new_c += String(UInt64(c) - 26)\n                            ^\n\
    /tmp/tmpojkt1zhk.swift:19:29: note: found candidate with type '(Float80) -> UInt64'\n\
    \            new_c += String(UInt64(c) - 26)\n                            ^\n\
    /tmp/tmpojkt1zhk.swift:19:29: note: found candidate with type '(Builtin.Int64)\
    \ -> UInt64'\n            new_c += String(UInt64(c) - 26)\n                  \
    \          ^\n/tmp/tmpojkt1zhk.swift:19:29: note: found candidate with type '(Unicode.Scalar)\
    \ -> UInt64'\n            new_c += String(UInt64(c) - 26)\n                  \
    \          ^\n/tmp/tmpojkt1zhk.swift:19:19: error: binary operator '+=' cannot\
    \ be applied to operands of type 'Character' and 'String'\n            new_c +=\
    \ String(UInt64(c) - 26)\n                  ^\nSwift.RangeReplaceableCollection:1:11:\
    \ note: candidate requires that 'Character' conform to 'RangeReplaceableCollection'\
    \ (requirement specified as 'Self' : 'RangeReplaceableCollection')\nextension\
    \ RangeReplaceableCollection {\n          ^\n/tmp/tmpojkt1zhk.swift:20:19: error:\
    \ cannot find 'isLower' in scope\n        } else if isLower(c) {\n           \
    \       ^~~~~~~\n/tmp/"
  stdout: ''
  timestamp: 1660014142
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.characters.sorted().joinWithSeparator(\"\
    \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"\
    Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpp4t3le1d.swift:15:34: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'joinWithSeparator'\n    return s.characters.sorted().joinWithSeparator(\"\
    \")\n           ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Split string into words\n \
    \   var words: [[String]] = split(s, \" \")\n    var ordered: [[String]] = words\n\
    \    // Sort words\n    swiftOnce.sort(by: {$0 < $1})\n    // Iterate through\
    \ words\n    for index in 0..<ordered.count {\n        let currentWord = ordered[index][0..<ordered[index].count\
    \ - 1]\n        let nextWord = ordered[index][ordered[index].count - 1..<ordered.count]\n\
    \        let charToRemoveFromFirstIndex = ordered[index][0].characters.count\n\
    \        // Remove char from current index\n        ordered[index][0..<charToRemoveFromFirstIndex\
    \ - 1].forEach { ordered[index][0].remove(at: $0) }\n        // Swap words in\
    \ array\n        ordered[index][0..<ordered[index].count - 1] = nextWord\n   \
    \ }\n    return join(ordered)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmplbqgtyw0.swift:16:29: error: cannot find 'split' in scope\n   \
    \ var words: [[String]] = split(s, \" \")\n                            ^~~~~\n\
    /tmp/tmplbqgtyw0.swift:19:5: error: cannot find 'swiftOnce' in scope\n    swiftOnce.sort(by:\
    \ {$0 < $1})\n    ^~~~~~~~~\n/tmp/tmplbqgtyw0.swift:24:60: error: 'characters'\
    \ is unavailable: Please use String directly\n        let charToRemoveFromFirstIndex\
    \ = ordered[index][0].characters.count\n                                     \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmplbqgtyw0.swift:26:99: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Index'\n        ordered[index][0..<charToRemoveFromFirstIndex\
    \ - 1].forEach { ordered[index][0].remove(at: $0) }\n                        \
    \                                                                          ^\n\
    /tmp/tmplbqgtyw0.swift:30:12: error: cannot find 'join' in scope\n    return join(ordered)\n\
    \           ^~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\tvar result = \"\"\n\n\tlet words:\
    \ [String] = s.split(separator: \" \")\n\n\tfor word in words {\n\t\tvar wordChars:\
    \ [Character] = word.characters\n\n\t\tfor i in 0 ..< (wordChars.count - 1) {\n\
    \t\t\tif wordChars[i] < wordChars[i+1] {\n\t\t\t\twordChars[i+1] = wordChars[i]\n\
    \t\t\t\twordChars[i] = ' '\n\t\t\t}\n\t\t}\n\n\t\tlet sw = String(wordChars)\n\
    \n\t\tresult += sw\n\t\tresult += \" \"\n\t}\n\n\treturn result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp7flkck9l.swift:25:20: error: single-quoted string literal found,\
    \ use '\"'\n                                wordChars[i] = ' '\n             \
    \                                  ^~~\n                                     \
    \          \" \"\n/tmp/tmp7flkck9l.swift:17:26: error: cannot assign value of\
    \ type '[String.SubSequence]' (aka 'Array<Substring>') to type '[String]'\n  \
    \      let words: [String] = s.split(separator: \" \")\n                     \
    \           ^\n/tmp/tmp7flkck9l.swift:17:26: note: arguments to generic parameter\
    \ 'Element' ('String.SubSequence' (aka 'Substring') and 'String') are expected\
    \ to be equal\n        let words: [String] = s.split(separator: \" \")\n     \
    \                           ^\n/tmp/tmp7flkck9l.swift:20:37: error: cannot convert\
    \ value of type 'String' to specified type '[Character]'\n                var\
    \ wordChars: [Character] = word.characters\n                                 \
    \            ~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_s = \"\"\n    var i =\
    \ 0\n    for c in s.unicodeScalars {\n        i += 1\n        if (i > 1) {\n \
    \           c += \" \"\n        }\n        if (i > 3) {\n            c += \"?\"\
    \n        } else {\n            c += c.value\n        }\n        new_s += String(c)\n\
    \    }\n    return new_s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmplej8iau4.swift:20:15: error: binary operator '+=' cannot be applied\
    \ to operands of type 'Unicode.Scalar' and 'String'\n            c += \" \"\n\
    \            ~ ^  ~~~\n/tmp/tmplej8iau4.swift:20:15: note: overloads for '+='\
    \ exist with these partially matching parameter lists: (inout String, String)\n\
    \            c += \" \"\n              ^\n/tmp/tmplej8iau4.swift:23:15: error:\
    \ binary operator '+=' cannot be applied to operands of type 'Unicode.Scalar'\
    \ and 'String'\n            c += \"?\"\n            ~ ^  ~~~\n/tmp/tmplej8iau4.swift:23:15:\
    \ note: overloads for '+=' exist with these partially matching parameter lists:\
    \ (inout String, String)\n            c += \"?\"\n              ^\n/tmp/tmplej8iau4.swift:25:13:\
    \ error: cannot convert value of type 'Unicode.Scalar' to expected argument type\
    \ 'UInt32'\n            c += c.value\n            ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    \n    var new_string = String()\n\
    \    \n    var new_char: Character\n    \n    for char in s.characters {\n   \
    \     \n        if char == ' ' {\n            \n            new_char = '_'\n \
    \           \n        } else {\n            \n            new_char = char\n  \
    \          \n        }\n        \n        new_string = new_string + String(new_char)\n\
    \        \n    }\n    \n    return new_string\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpslncm9ei.swift:22:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ' ' {\n                   ^~~\n               \
    \    \" \"\n/tmp/tmpslncm9ei.swift:24:24: error: single-quoted string literal\
    \ found, use '\"'\n            new_char = '_'\n                       ^~~\n  \
    \                     \"_\"\n/tmp/tmpslncm9ei.swift:20:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var res = \"\"\n    var i = 0\n\
    \    while i < len(s) {\n        if s[i] == \" \" {\n            i += 2\n    \
    \        continue\n        }\n        i += 1\n        if i > len(s) {\n      \
    \      break\n        }\n        var j = i\n        var k = i\n        var m =\
    \ -1\n        while j > 0 {\n            k += 2\n            if s[k] > s[j] {\n\
    \                m = s[k]\n                k = j\n            }\n            if\
    \ s[k] < s[j] {\n                m = s[k]\n                k = j\n           \
    \ }\n            if m > 0 {\n                var tmp = s[j]\n                s[j]\
    \ = s[k]\n                s[k] = tmp\n                k = k + m\n            \
    \    k = k + m\n                j = j - m\n            }\n            if s[k]\
    \ == \" \" {\n                k = j\n            }\n            j -= 1\n     \
    \   }\n        res += String(s[k:])\n        res += \" \"\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpap2640uc.swift:52:27: error: expected expression in list of expressions\n\
    \        res += String(s[k:])\n                          ^\n/tmp/tmpap2640uc.swift:17:15:\
    \ error: cannot find 'len' in scope\n    while i < len(s) {\n              ^~~\n\
    /tmp/tmpap2640uc.swift:18:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if s[i] == \" \" {\n\
    \           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpap2640uc.swift:23:16: error: cannot find 'len' in scope\n\
    \        if i > len(s) {\n               ^~~\n/tmp/tmpap2640uc.swift:31:16: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            if s[k] > s[j] {\n               ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpap2640uc.swift:31:23:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s[k] > s[j] {\n                \
    \      ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpap2640uc.swift:32:22: error: cannot assign value of type 'Character'\
    \ to type 'Int'\n                m = s[k]\n                    ~^~~\n/tmp/tmpap2640uc.swift:35:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s[k] < s[j] {\n               ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpap2640uc.swift:35:23:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s[k] < s[j] {\n                \
    \      ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has "
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var sw = s\n    var r = \"\"\n\
    \    for c in sw {\n        let index = s.rangeOfString(c)\n        if index !=\
    \ nil {\n            sw = sw.stringByReplacingCharactersInRange(index, withString:\
    \ c.uppercaseString())\n        }\n    }\n    r = sw\n    return r\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpqk3gbfj1.swift:18:23: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let index = s.rangeOfString(c)\n                  \
    \  ~ ^~~~~~~~~~~~~\n/tmp/tmpqk3gbfj1.swift:20:21: error: value of type 'String'\
    \ has no member 'stringByReplacingCharactersInRange'\n            sw = sw.stringByReplacingCharactersInRange(index,\
    \ withString: c.uppercaseString())\n                 ~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqk3gbfj1.swift:20:77: error: value of type 'Character' has no member 'uppercaseString'\n\
    \            sw = sw.stringByReplacingCharactersInRange(index, withString: c.uppercaseString())\n\
    \                                                                          ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var ordered = \"\"\n    var word_list\
    \ = s.split(separator: \" \")\n    for word in word_list {\n        let word_str\
    \ = String(word)\n        let char_str = Array(word_str)\n        let char_str\
    \ = char_str.sorted(by: {$0.asciiValue < $1.asciiValue})\n        let ordered\
    \ = ordered + char_str.joinWithSeparator(\"\")\n    }\n    return ordered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpxumayufm.swift:20:48: error: value of optional type 'UInt8?' must\
    \ be unwrapped to a value of type 'UInt8'\n        let char_str = char_str.sorted(by:\
    \ {$0.asciiValue < $1.asciiValue})\n                                         \
    \      ^\n/tmp/tmpxumayufm.swift:20:48: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n        let char_str = char_str.sorted(by:\
    \ {$0.asciiValue < $1.asciiValue})\n                                         \
    \      ^\n                                                          ?? <#default\
    \ value#>\n/tmp/tmpxumayufm.swift:20:48: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        let char_str = char_str.sorted(by:\
    \ {$0.asciiValue < $1.asciiValue})\n                                         \
    \      ^\n                                                         !\n/tmp/tmpxumayufm.swift:20:64:\
    \ error: value of optional type 'UInt8?' must be unwrapped to a value of type\
    \ 'UInt8'\n        let char_str = char_str.sorted(by: {$0.asciiValue < $1.asciiValue})\n\
    \                                                               ^\n/tmp/tmpxumayufm.swift:20:64:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let char_str = char_str.sorted(by: {$0.asciiValue < $1.asciiValue})\n\
    \                                                               ^\n          \
    \                                                                ?? <#default\
    \ value#>\n/tmp/tmpxumayufm.swift:20:64: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        let char_str = char_str.sorted(by:\
    \ {$0.asciiValue < $1.asciiValue})\n                                         \
    \                      ^\n                                                   \
    \                      !\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    var words\
    \ = s.words\n    for word in words {\n        let chars = s.characters\n     \
    \   let len = chars.count\n        let startIndex = chars.index(s.startIndex,\
    \ offsetBy: word.startIndex.advanced(by: word.startIndex.distance(to: s.startIndex)))\n\
    \        let endIndex = chars.index(s.startIndex, offsetBy: word.startIndex.advanced(by:\
    \ word.endIndex.distance(to: s.startIndex)))\n        let newChar = String(cString:\
    \ chars.subarray(from: startIndex, to: endIndex))\n        let charAsInt = newChar.unicodeScalars.reduce(0)\
    \ { (result, val) in\n            result + val.value\n        }\n        let newWord\
    \ = String(cString: chars[startIndex..<endIndex])\n        let newCharAsInt =\
    \ newWord.unicodeScalars.reduce(0) { (result, val) in\n            result + val.value\n\
    \        }\n        let newWordAsInt = newWord.unicodeScalars.reduce(0) { (result,\
    \ val) in\n            result + val.value\n        }\n        let charAsIntAsHex\
    \ = String(format: \"%x\", charAsInt)\n        let newWordAsIntAsHex = String(format:\
    \ \"%x\", newWordAsInt)\n        let charAsIntAsHexAsWord = newWordAsIntAsHex\
    \ + charAsIntAsHex\n        let newCharAsIntAsHexAsWord = String(format: \"%x\"\
    , newCharAsIntAsHexAsWord)\n        let newWordAsIntAsHexAsWord = String(format:\
    \ \"%x\", newWordAsIntAsHexAsWord)\n        if charAsIntAsHexAsWord < newCharAsIntAsHexAsWord\
    \ {\n            result = result.appending(newChar)\n        }\n        if newWordAsIntAsHexAsWord\
    \ < charAsIntAsHexAsWord {\n            result = result.appending(newWord)\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmprd8bus3t.swift:16:19: error: value of type 'String' has no member\
    \ 'words'\n    var words = s.words\n                ~ ^~~~~\n/tmp/tmprd8bus3t.swift:18:23:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ chars = s.characters\n                      ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmprd8bus3t.swift:22:45: error: value of type\
    \ 'String' has no member 'subarray'\n        let newChar = String(cString: chars.subarray(from:\
    \ startIndex, to: endIndex))\n                                      ~~~~~ ^~~~~~~~\n\
    /tmp/tmprd8bus3t.swift:33:36: error: incorrect argument labels in call (have 'format:_:',\
    \ expected 'repeating:count:')\n        let charAsIntAsHex = String(format: \"\
    %x\", charAsInt)\n                                   ^~~~~~~\n               \
    \                     repeating     count: \n/tmp/tmprd8bus3t.swift:34:39: error:\
    \ incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')\n\
    \        let newWordAsIntAsHex = String(format: \"%x\", newWordAsInt)\n      \
    \                                ^~~~~~~\n                                   \
    \    repeating     count: \n/tmp/tmprd8bus3t.swift:36:60: error: use of local\
    \ variable 'newCharAsIntAsHexAsWord' before its declaration\n        let newCharAsIntAsHexAsWord\
    \ = String(format: \"%x\", newCharAsIntAsHexAsWord)\n                        \
    \                                   ^\n/tmp/tmprd8bus3t.swift:36:13: note: 'newCharAsIntAsHexAsWord'\
    \ declared here\n        let newCharAsIntAsHexAsWord = String(format: \"%x\",\
    \ newCharAsIntAsHexAsWord)\n            ^\n/tmp/tmprd8bus3t.swift:36:45: error:\
    \ incorrect argument labels in call (have 'format:_:', expected 'repeating:count:')\n\
    \        let newCharAsIntAsHexAsWord = String(format: \"%x\", newCharAsIntAsHexAsWord)\n\
    \                                            ^~~~~~~\n                       \
    \                      repeating     count: \n/tmp/tmprd8bus3t.swift:37:60: error:\
    \ use of local variable 'newWordAsIntAsHexAsWord'"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    for word\
    \ in s.split(\" \") {\n        result += String(cmp(word, \"\")) == 0 ? word :\
    \ word.capitalized\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpw05mcgu6.swift:16:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let characters = s.characters\n\
    \    var antiShuffled = \"\"\n    for i in 0..<characters.count {\n        let\
    \ currentChar = String(characters[i])\n        let index = characters.indexOf(i)\n\
    \        let nextChar = String(characters[index])\n        if currentChar != nextChar{\n\
    \            antiShuffled += currentChar\n        }\n    }\n    return antiShuffled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpexw118ig.swift:15:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let characters = s.characters\n                   \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpexw118ig.swift:18:34:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let currentChar = String(characters[i])\n\
    \                                 ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpexw118ig.swift:19:32: error: value\
    \ of type 'String' has no member 'indexOf'\n        let index = characters.indexOf(i)\n\
    \                    ~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var sArr = s.characters.sort()\n\
    \    var res = \"\"\n    for str in sArr {\n        res += String(str) ?? \"\"\
    \n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpiu7dfvqo.swift:15:29: error: value of type 'String' has no member\
    \ 'sort'\n    var sArr = s.characters.sort()\n               ~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.characters.sorted().reduce(\"\
    \") { (accum, character) in\n        let charValue = character as! UnicodeScalar\n\
    \        let charAsciiValue = UInt32(character)\n        let numAsciiValue = Int(charAsciiValue)\n\
    \n        var accumulator = accum\n\n        if numAsciiValue < 7 {\n        \
    \    accumulator += String(UnicodeScalar(charAsciiValue))\n        }\n       \
    \ else {\n            let ascii = numAsciiValue - 7\n\n            accumulator\
    \ += String(UnicodeScalar(ascii))\n            accumulator += String(UnicodeScalar(charAsciiValue))\n\
    \        }\n        return accumulator\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpu39nj7s5.swift:17:30: error: no exact matches in call to initializer\
    \ \n        let charAsciiValue = UInt32(character)\n                         \
    \    ^\n/tmp/tmpu39nj7s5.swift:17:30: note: found candidate with type '(Float16)\
    \ -> UInt32'\n        let charAsciiValue = UInt32(character)\n               \
    \              ^\n/tmp/tmpu39nj7s5.swift:17:30: note: found candidate with type\
    \ '(Float) -> UInt32'\n        let charAsciiValue = UInt32(character)\n      \
    \                       ^\n/tmp/tmpu39nj7s5.swift:17:30: note: found candidate\
    \ with type '(Double) -> UInt32'\n        let charAsciiValue = UInt32(character)\n\
    \                             ^\n/tmp/tmpu39nj7s5.swift:17:30: note: found candidate\
    \ with type '(Float80) -> UInt32'\n        let charAsciiValue = UInt32(character)\n\
    \                             ^\n/tmp/tmpu39nj7s5.swift:17:30: note: found candidate\
    \ with type '(Builtin.Int32) -> UInt32'\n        let charAsciiValue = UInt32(character)\n\
    \                             ^\n/tmp/tmpu39nj7s5.swift:17:30: note: found candidate\
    \ with type '(Unicode.Scalar) -> UInt32'\n        let charAsciiValue = UInt32(character)\n\
    \                             ^\n/tmp/tmpu39nj7s5.swift:17:30: note: found candidate\
    \ with type '(String) -> UInt32?'\n        let charAsciiValue = UInt32(character)\n\
    \                             ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    \n    var anti_shuffle = \"\"\n\
    \    \n    for c in s.characters {\n        \n        if c == \" \" {\n      \
    \      \n            for _ in 0..<s.characters.count {\n                \n   \
    \             if anti_shuffle.characters.count < s.characters.count {\n      \
    \              \n                    if anti_shuffle.characters.count > 0 {\n\
    \                        \n                        anti_shuffle += \"\\(anti_shuffle.characters.last!)\
    \ \" \n                    }\n                    \n                    anti_shuffle\
    \ += \"\\(c)\"\n                    \n                    break\n            \
    \    }\n                \n                anti_shuffle += \"\\(c)\"\n        \
    \    }\n            \n        } else {\n            \n            anti_shuffle\
    \ += \"\\(c)\"\n        }\n    }\n    \n    return anti_shuffle\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpv_4s6fnt.swift:18:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpv_4s6fnt.swift:22:28:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ for _ in 0..<s.characters.count {\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpv_4s6fnt.swift:24:33: error: 'characters'\
    \ is unavailable: Please use String directly\n                if anti_shuffle.characters.count\
    \ < s.characters.count {\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpv_4s6fnt.swift:24:54: error: 'characters'\
    \ is unavailable: Please use String directly\n                if anti_shuffle.characters.count\
    \ < s.characters.count {\n                                                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpv_4s6fnt.swift:26:37:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \         if anti_shuffle.characters.count > 0 {\n                           \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpv_4s6fnt.swift:28:57:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \             anti_shuffle += \"\\(anti_shuffle.characters.last!) \" \n      \
    \                                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: -4
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Your code here\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: Exception
  stderr: 'tmp4bb75yso/tmp4bb75yso.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abbe960bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abbe9302b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abbe9302988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abbe93017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4bb75yso                        0x000055589f231307 <unavailable> + 4871

    5    libc.so.6                          0x00002abbe97f7460 __libc_start_main +
    245

    6    tmp4bb75yso                        0x000055589f230f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    var temp\
    \ = \"\"\n    for _ in 0..<s.count {\n        if s.startIndex != s.endIndex {\n\
    \            let i = s.startIndex\n            let j = s.endIndex\n          \
    \  if s[i].unicodeScalars.count < s[j].unicodeScalars.count {\n              \
    \  temp = String(s[i..<j])\n                result += temp\n                s\
    \ = s.substring(from: j)\n                s = s.insert(at: i, with: temp)\n  \
    \          } else {\n                result += s[s.startIndex..<s.endIndex]\n\
    \                s = s.insert(at: s.endIndex, with: String(s[i..<j]))\n      \
    \      }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpqfrij0ct.swift:24:17: error: cannot assign to value: 's' is a 'let'\
    \ constant\n                s = s.substring(from: j)\n                ^\n/tmp/tmpqfrij0ct.swift:24:23:\
    \ error: value of type 'String' has no member 'substring'\n                s =\
    \ s.substring(from: j)\n                    ~ ^~~~~~~~~\n/tmp/tmpqfrij0ct.swift:25:23:\
    \ error: no exact matches in call to instance method 'insert'\n              \
    \  s = s.insert(at: i, with: temp)\n                      ^\n/tmp/tmpqfrij0ct.swift:25:23:\
    \ note: found candidate with type '(Character, String.Index) -> ()'\n        \
    \        s = s.insert(at: i, with: temp)\n                      ^\n/tmp/tmpqfrij0ct.swift:25:23:\
    \ note: found candidate with type '(__owned String.Element, String.Index) -> ()'\
    \ (aka '(__owned Character, String.Index) -> ()')\n                s = s.insert(at:\
    \ i, with: temp)\n                      ^\n/tmp/tmpqfrij0ct.swift:25:17: error:\
    \ cannot assign to value: 's' is a 'let' constant\n                s = s.insert(at:\
    \ i, with: temp)\n                ^\n/tmp/tmpqfrij0ct.swift:25:23: error: cannot\
    \ assign value of type '()' to type 'String'\n                s = s.insert(at:\
    \ i, with: temp)\n                    ~~^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqfrij0ct.swift:28:23:\
    \ error: no exact matches in call to instance method 'insert'\n              \
    \  s = s.insert(at: s.endIndex, with: String(s[i..<j]))\n                    \
    \  ^\n/tmp/tmpqfrij0ct.swift:28:23: note: found candidate with type '(Character,\
    \ String.Index) -> ()'\n                s = s.insert(at: s.endIndex, with: String(s[i..<j]))\n\
    \                      ^\n/tmp/tmpqfrij0ct.swift:28:23: note: found candidate\
    \ with type '(__owned String.Element, String.Index) -> ()' (aka '(__owned Character,\
    \ String.Index) -> ()')\n                s = s.insert(at: s.endIndex, with: String(s[i..<j]))\n\
    \                      ^\n/tmp/tmpqfrij0ct.swift:28:17: error: cannot assign to\
    \ value: 's' is a 'let' constant\n                s = s.insert(at: s.endIndex,\
    \ with: String(s[i..<j]))\n                ^\n/tmp/tmpqfrij0ct.swift:28:23: error:\
    \ cannot assign value o"
  stdout: ''
  timestamp: 1660014139
- exit_code: -4
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Your code here!\n    return\
    \ s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"\
    Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: Exception
  stderr: 'tmpefskvu99/tmpefskvu99.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac8d1ea5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac8d1b9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac8d1b9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac8d1b9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpefskvu99                        0x000056350ed093f7 <unavailable> + 5111

    5    libc.so.6                          0x00002ac8d2091460 __libc_start_main +
    245

    6    tmpefskvu99                        0x000056350ed08f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var a = s.characters\n    var\
    \ l = a.count\n    for i in 0..<l {\n        for j in 1..<(l - i - 1) {\n    \
    \        var tmp = a[j]\n            a[j] = a[j - 1]\n            a[j - 1] = tmp\n\
    \        }\n    }\n    return String.from(a)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmph56757o9.swift:15:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    var a = s.characters\n              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph56757o9.swift:19:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            var tmp = a[j]\n                      ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmph56757o9.swift:20:14: error:\
    \ cannot assign through subscript: subscript is get-only\n            a[j] = a[j\
    \ - 1]\n            ~^~~\n/tmp/tmph56757o9.swift:21:14: error: cannot assign through\
    \ subscript: subscript is get-only\n            a[j - 1] = tmp\n            ~^~~~~~~\n\
    /tmp/tmph56757o9.swift:24:19: error: type 'String' has no member 'from'\n    return\
    \ String.from(a)\n           ~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let s = remove_capital_letters(s)\n\
    \    let sortedWords = split(s).sorted(by: { $0.localizedStandardCompare($1) ==\
    \ ComparisonResult.orderedAscending })\n    return join(sortedWords)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp2h7m72a6.swift:15:13: error: cannot find 'remove_capital_letters'\
    \ in scope\n    let s = remove_capital_letters(s)\n            ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2h7m72a6.swift:16:23: error: cannot find 'split' in scope\n    let sortedWords\
    \ = split(s).sorted(by: { $0.localizedStandardCompare($1) == ComparisonResult.orderedAscending\
    \ })\n                      ^~~~~\n/tmp/tmp2h7m72a6.swift:16:80: error: cannot\
    \ find 'ComparisonResult' in scope\n    let sortedWords = split(s).sorted(by:\
    \ { $0.localizedStandardCompare($1) == ComparisonResult.orderedAscending })\n\
    \                                                                            \
    \   ^~~~~~~~~~~~~~~~\n/tmp/tmp2h7m72a6.swift:17:12: error: cannot find 'join'\
    \ in scope\n    return join(sortedWords)\n           ^~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let chars = Array(s.utf8)\n  \
    \  let strArray = chars.enumerated().map({ $0.element + 1 })\n    var sortedString\
    \ = String()\n    strArray\n        .enumerated()\n        .enumerate()\n    \
    \    .forEach {\n            if $0.element != strArray.count {\n             \
    \   sortedString += String(strArray[$0.element])\n            } else {\n     \
    \           sortedString += String(chars[$0.element])\n            }\n       \
    \ }\n    return sortedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpgq879e3x.swift:20:10: error: value of type 'EnumeratedSequence<[UInt8]>'\
    \ has no member 'enumerate'\n        .enumerate()\n         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n\n    var result = \"\"\n\n    var words = s.componentsSeparatedByString(\"\
    \ \")\n    for word in words {\n        let lower = word.lowercaseString\n\n \
    \       let isCapital = false\n        if isLetterCapital(lower: lower) {\n  \
    \          isCapital = true\n        }\n\n        switch isCapital {\n       \
    \ case true:\n            word = word.replacingOccurrences(of: \"'\", with: \"\
    \")\n            word = word.replacingOccurrences(of: \".\", with: \"\")\n   \
    \         word = word.replacingOccurrences(of: \",\", with: \"\")\n          \
    \  word = word.replacingOccurrences(of: \":\", with: \"\")\n            word =\
    \ word.replacingOccurrences(of: \"!\", with: \"1\")\n            word = word.replacingOccurrences(of:\
    \ \"?\", with: \"2\")\n            word = word.replacingOccurrences(of: \";\"\
    , with: \"3\")\n            word = word.replacingOccurrences(of: \"-\", with:\
    \ \"_\")\n            word = word.replacingOccurrences(of: \"<\", with: \"4\"\
    )\n            word = word.replacingOccurrences(of: \"=\", with: \"5\")\n    \
    \        word = word.replacingOccurrences(of: \">\", with: \"6\")\n          \
    \  word = word.replacingOccurrences(of: \"/\", with: \"7\")\n            word\
    \ = word.replacingOccurrences(of: \"[\", with: \"8\")\n            word = word.replacingOccurrences(of:\
    \ \"]\", with: \"9\")\n            word = word.replacingOccurrences(of: \" \"\
    , with: \"\")\n            word += \"0\"\n            break\n\n        case false:\n\
    \            word += \"0\"\n            break\n        }\n\n        result +=\
    \ word\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpa_ib8hgt.swift:21:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    var words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n\n    var i\
    \ = 0\n    let len = s.count\n\n    while i < len {\n        let c = s[i]\n  \
    \      let j = s.startIndex\n        if c == \" \" {\n            if let index\
    \ = s.index(s.index(s.startIndex, offsetBy: 1), offsetBy: 1) {\n             \
    \   let s = s[index..<j]\n                result.append(s)\n            }\n  \
    \      } else {\n            result.append(c)\n        }\n        i += 1\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpqp982h7a.swift:21:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let c = s[i]\n\
    \                ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpqp982h7a.swift:26:24: error: no exact matches in call to\
    \ instance method 'append'\n                result.append(s)\n               \
    \        ^\nSwift.String:9:26: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(contentsOf:)')\n    public mutating func append(contentsOf newElements:\
    \ Substring)\n                         ^\nSwift.String:10:26: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n    public mutating\
    \ func append<S>(contentsOf newElements: S) where S : Sequence, S.Element == Character\n\
    \                         ^\nSwift.RangeReplaceableCollection:5:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable\
    \ public mutating func append<S>(contentsOf newElements: __owned S) where S :\
    \ Sequence, Self.Element == S.Element\n                                    ^\n\
    /tmp/tmpqp982h7a.swift:24:16: error: initializer for conditional binding must\
    \ have Optional type, not 'String.Index'\n            if let index = s.index(s.index(s.startIndex,\
    \ offsetBy: 1), offsetBy: 1) {\n               ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var newString = String()\n\n \
    \   for character in s {\n        if let intValue = Int(character) {\n       \
    \     switch intValue {\n            case 97 ... 122, 32: newString.append(\"\
    a\")\n            case 65 ... 90, 97 ... 122, 32: newString.append(\"A\")\n  \
    \          case 102 ... 122, 32:\n            case 97 ... 122, 32 ... 122: newString.append(\"\
    B\")\n            case 97 ... 122, 32 ... 122 ... 97 ... 122, 32 ... 122 ... 97\
    \ ... 122: newString.append(\"C\")\n            case 97 ... 122 ... 97 ... 122,\
    \ 32 ... 122 ... 97 ... 122 ... 97 ... 122, 32 ... 122 ... 97 ... 122 ... 97 ...\
    \ 122: newString.append(\"D\")\n            case 65 ... 90, 97 ... 122 ... 97\
    \ ... 122, 32 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122, 32 ... 122\
    \ ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122: newString.append(\"\
    E\")\n            case 102 ... 122 ... 97 ... 122 ... 97 ... 122, 32 ... 122 ...\
    \ 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97\
    \ ... 122, 32 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ...\
    \ 122: newString.append(\"F\")\n            case 65 ... 90, 97 ... 122 ... 97\
    \ ... 122, 32 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ...\
    \ 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122: newString.append(\"G\")\n\
    \            case 102 ... 122 ... 97 ... 122 ... 97 ... 122, 32 ... 122 ... 97\
    \ ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ...\
    \ 122: newString.append(\"H\")\n            case 65 ... 90, 97 ... 122 ... 97\
    \ ... 122, 32 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ...\
    \ 122 ... 97 ... 122 ... 97 ... \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpx42ti2g1.swift:22:13: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n            case 102 ... 122, 32:\n     \
    \       ^~~~~~~~~~~~~~~~~~~~~\n                                  break\n/tmp/tmpx42ti2g1.swift:31:1:\
    \ error: expected expression after operator\n}\n^\n/tmp/tmpx42ti2g1.swift:30:152:\
    \ error: expected ':' after 'case'\n            case 65 ... 90, 97 ... 122 ...\
    \ 97 ... 122, 32 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ... 122 ... 97 ...\
    \ 122 ... 97 ... 122 ... 97 ... \n                                           \
    \                                                                            \
    \                                ^\n/tmp/tmpx42ti2g1.swift:52:116: error: expected\
    \ '}' at end of brace statement\nassert(anti_shuffle(s: \"Hi. My name is Mister\
    \ Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")\n \
    \                                                                            \
    \                                      ^\n/tmp/tmpx42ti2g1.swift:18:42: note:\
    \ to match this opening '{'\n        if let intValue = Int(character) {\n    \
    \                                     ^\n/tmp/tmpx42ti2g1.swift:52:116: error:\
    \ expected '}' at end of brace statement\nassert(anti_shuffle(s: \"Hi. My name\
    \ is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\"\
    )\n                                                                          \
    \                                         ^\n/tmp/tmpx42ti2g1.swift:17:24: note:\
    \ to match this opening '{'\n    for character in s {\n                      \
    \ ^\n/tmp/tmpx42ti2g1.swift:52:116: error: expected '}' at end of brace statement\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")\n                                 \
    \                                                                            \
    \      ^\n/tmp/tmpx42ti2g1.swift:14:40: note: to match this opening '{'\nfunc\
    \ anti_shuffle(s: String) -> String {\n                                      \
    \ ^\n/tmp/tmpx42ti2g1.swift:18:31: error: cannot convert v"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\treturn s.reduce((acc, char) => {\n\
    \t\tif char == \" \" {\n\t\t\treturn acc + char\n\t\t} else if char == \"\\n\"\
    \ || char == \"\\t\" {\n\t\t\treturn acc + char\n\t\t} else {\n\t\t\treturn acc\
    \ + String.fromCharCode(ord(char.unicodeScalars.first!.value + 256 - ord(char.unicodeScalars.last!.value)))\n\
    \t\t}\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpncf7sz45.swift:15:19: error: cannot find 'acc' in scope\n     \
    \   return s.reduce((acc, char) => {\n                         ^~~\n/tmp/tmpncf7sz45.swift:15:24:\
    \ error: cannot find 'char' in scope\n        return s.reduce((acc, char) => {\n\
    \                              ^~~~\n/tmp/tmpncf7sz45.swift:15:30: error: cannot\
    \ find operator '=>' in scope\n        return s.reduce((acc, char) => {\n    \
    \                                ^~\n/tmp/tmpncf7sz45.swift:16:6: error: cannot\
    \ find 'char' in scope\n                if char == \" \" {\n                 \
    \  ^~~~\n/tmp/tmpncf7sz45.swift:17:11: error: cannot find 'acc' in scope\n   \
    \                     return acc + char\n                               ^~~\n\
    /tmp/tmpncf7sz45.swift:17:17: error: cannot find 'char' in scope\n           \
    \             return acc + char\n                                     ^~~~\n/tmp/tmpncf7sz45.swift:18:13:\
    \ error: cannot find 'char' in scope\n                } else if char == \"\\n\"\
    \ || char == \"\\t\" {\n                          ^~~~\n/tmp/tmpncf7sz45.swift:18:29:\
    \ error: cannot find 'char' in scope\n                } else if char == \"\\n\"\
    \ || char == \"\\t\" {\n                                          ^~~~\n/tmp/tmpncf7sz45.swift:19:11:\
    \ error: cannot find 'acc' in scope\n                        return acc + char\n\
    \                               ^~~\n/tmp/tmpncf7sz45.swift:19:17: error: cannot\
    \ find 'char' in scope\n                        return acc + char\n          \
    \                           ^~~~\n/tmp/tmpncf7sz45.swift:21:11: error: cannot\
    \ find 'acc' in scope\n                        return acc + String.fromCharCode(ord(char.unicodeScalars.first!.value\
    \ + 256 - ord(char.unicodeScalars.last!.value)))\n                           \
    \    ^~~\n/tmp/tmpncf7sz45.swift:21:37: error: cannot find 'ord' in scope\n  \
    \                      return acc + String.fromCharCode(ord(char.unicodeScalars.first!.value\
    \ + 256 - ord(char.unicodeScalars.last!.value)))\n                           \
    \                              ^~~\n/tmp/tmpncf7sz45.swift:21:41: error: cannot\
    \ find 'char' in scope\n                        ret"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    for letter\
    \ in s.characters {\n        if letter != ' ' {\n            result += String(letter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp_g_9p778.swift:17:22: error: single-quoted string literal found,\
    \ use '\"'\n        if letter != ' ' {\n                     ^~~\n           \
    \          \" \"\n/tmp/tmp_g_9p778.swift:16:21: error: 'characters' is unavailable:\
    \ Please use String directly\n    for letter in s.characters {\n             \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var a = s.chars\n    sort(&a,\
    \ func(i, j int) bool {\n        if a[i] < a[j] {\n            return true\n \
    \       }\n        return false\n    })\n    return String(a)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmppr_500c8.swift:16:14: error: expected expression in list of expressions\n\
    \    sort(&a, func(i, j int) bool {\n             ^\n/tmp/tmppr_500c8.swift:16:18:\
    \ error: expected identifier in function declaration\n    sort(&a, func(i, j int)\
    \ bool {\n                 ^\n/tmp/tmppr_500c8.swift:15:15: error: value of type\
    \ 'String' has no member 'chars'\n    var a = s.chars\n            ~ ^~~~~\n/tmp/tmppr_500c8.swift:16:5:\
    \ error: cannot find 'sort' in scope\n    sort(&a, func(i, j int) bool {\n   \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Your code here\n    var new_s\
    \ = \"\"\n    for word in s.split(\" \") {\n        let word_ord = word.characters.sorted(by:\
    \ { $0 < $1 }).joined()\n        new_s += (word_ord)\n    }\n    new_s += \" \"\
    \n    return new_s.capitalized\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpp9mnfs3c.swift:17:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpp9mnfs3c.swift:22:18: error: value of type\
    \ 'String' has no member 'capitalized'\n    return new_s.capitalized\n       \
    \    ~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n    let words = s.split(separator: \" \")\n    var shuffled = \"\"\
    \n    for word in words {\n        shuffled += String(word[word.startIndex..<word.endIndex])\
    \ +\n            \"_\" + String(word.unicodeScalars.sorted()[word.unicodeScalars.startIndex..<word.unicodeScalars.endIndex]).uppercased()\n\
    \    }\n    return shuffled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpfknof8lc.swift:22:54: error: no exact matches in call to subscript\
    \ \n            \"_\" + String(word.unicodeScalars.sorted()[word.unicodeScalars.startIndex..<word.unicodeScalars.endIndex]).uppercased()\n\
    \                                                     ^\nSwift.Array:16:23: note:\
    \ candidate expects value of type 'Int' for parameter #1 (got 'Range<Substring.UnicodeScalarView.Index>'\
    \ (aka 'Range<String.Index>'))\n    @inlinable public subscript(index: Int) ->\
    \ Element { get set }\n                      ^\n/tmp/tmpfknof8lc.swift:22:54:\
    \ note: found candidate with type '(Range<Substring.UnicodeScalarView.Index>)\
    \ -> ArraySlice<Substring.UnicodeScalarView.Element>' (aka '(Range<String.Index>)\
    \ -> ArraySlice<Unicode.Scalar>')\n            \"_\" + String(word.unicodeScalars.sorted()[word.unicodeScalars.startIndex..<word.unicodeScalars.endIndex]).uppercased()\n\
    \                                                     ^\n/tmp/tmpfknof8lc.swift:22:19:\
    \ error: no exact matches in call to initializer \n            \"_\" + String(word.unicodeScalars.sorted()[word.unicodeScalars.startIndex..<word.unicodeScalars.endIndex]).uppercased()\n\
    \                  ^\nSwift.Array:16:23: note: candidate expects value of type\
    \ 'Int' for parameter #1 (got 'Range<Substring.UnicodeScalarView.Index>' (aka\
    \ 'Range<String.Index>'))\n    @inlinable public subscript(index: Int) -> Element\
    \ { get set }\n                      ^\n/tmp/tmpfknof8lc.swift:22:19: note: found\
    \ candidate with type '(ArraySlice<Substring.UnicodeScalarView.Element>) -> String'\
    \ (aka '(ArraySlice<Unicode.Scalar>) -> String')\n            \"_\" + String(word.unicodeScalars.sorted()[word.unicodeScalars.startIndex..<word.unicodeScalars.endIndex]).uppercased()\n\
    \                  ^\n/tmp/tmpfknof8lc.swift:22:19: note: found candidate with\
    \ type '(ArraySlice<Substring.UnicodeScalarView.Element>) -> String' (aka '(ArraySlice<Unicode.Scalar>)\
    \ -> String')\n            \"_\" + String(word.unicodeScalars.sorted()[word.unicodeScalars.startIndex..<word.unicodeScalars.endIndex]).uppercased()\n\
    \                  ^\n/tmp/tmpfknof"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.split(\" \").sorted(by:\
    \ { (_, $0) < (_, $1) }).joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpw35xzr04.swift:15:39: error: '_' can only appear in a pattern or\
    \ on the left side of an assignment\n    return s.split(\" \").sorted(by: { (_,\
    \ $0) < (_, $1) }).joined()\n                                      ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_s = \"\"\n    var i =\
    \ 0\n    while i < s.count {\n        var j = i + 1\n        while j < s.count\
    \ && s[i] == s[j] {\n            j += 1\n        }\n        if j - i > 1 {\n \
    \           new_s += String(a: [s[i - 1], s[j]], b: s.substring(i + 1))\n    \
    \        i = j - 1\n        } else {\n            new_s += s[i]\n            i\
    \ += 1\n        }\n    }\n    return new_s\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_wgkz0a.swift:19:30: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        while j <\
    \ s.count && s[i] == s[j] {\n                             ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpi_wgkz0a.swift:19:38:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        while j < s.count && s[i] == s[j] {\n \
    \                                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpi_wgkz0a.swift:23:55: error: extra\
    \ argument 'b' in call\n            new_s += String(a: [s[i - 1], s[j]], b: s.substring(i\
    \ + 1))\n                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~\n\
    /tmp/tmpi_wgkz0a.swift:23:55: error: value of type 'String' has no member 'substring'\n\
    \            new_s += String(a: [s[i - 1], s[j]], b: s.substring(i + 1))\n   \
    \                                                 ~ ^~~~~~~~~\n/tmp/tmpi_wgkz0a.swift:26:23:\
    \ error: no exact matches in call to subscript \n            new_s += s[i]\n \
    \                     ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    let sorted = words.sorted { $0.unicodeScalars.reduce(\"\") { $0\
    \ + String($1) <\n        $1.unicodeScalars.reduce(\"\") { $0 + String($1) } }\n\
    \    }\n\n    return sorted.joined(separator: \"\")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpa9ijw26z.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n/tmp/tmpa9ijw26z.swift:16:18: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n    let sorted = words.sorted { $0.unicodeScalars.reduce(\"\
    \") { $0 + String($1) <\n                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014168
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_s = \"\"\n    let words\
    \ = s.split(separator: \" \")\n    for (i, word) in words.enumerated() {\n   \
    \     let c = word.unicodeScalars.first!\n        var j = i\n        while j <\
    \ words.count {\n            guard let jw = words[j].unicodeScalars.first,\n \
    \               jw < c else { break }\n            let index = jw - c\n      \
    \      if index > 0 {\n                words[j] = String(unicodeScalars: [index])\n\
    \                j--\n            } else {\n                break\n          \
    \  }\n        }\n        if i != words.count {\n            new_s += String(words[i])\n\
    \        } else {\n            new_s += words[i]\n        }\n    }\n    return\
    \ new_s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp17ikp32w.swift:23:28: error: binary operator '-' cannot be applied\
    \ to two 'Substring.UnicodeScalarView.Element' (aka 'Unicode.Scalar') operands\n\
    \            let index = jw - c\n                        ~~ ^ ~\n/tmp/tmp17ikp32w.swift:25:28:\
    \ error: no exact matches in call to initializer \n                words[j] =\
    \ String(unicodeScalars: [index])\n                           ^\n/tmp/tmp17ikp32w.swift:25:28:\
    \ note: found candidate with type '([Character]) -> String'\n                words[j]\
    \ = String(unicodeScalars: [index])\n                           ^\n/tmp/tmp17ikp32w.swift:25:22:\
    \ error: cannot assign through subscript: 'words' is a 'let' constant\n      \
    \          words[j] = String(unicodeScalars: [index])\n                ~~~~~^\n\
    /tmp/tmp17ikp32w.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let words = s.split(separator: \" \")\n    ^~~\n    var\n/tmp/tmp17ikp32w.swift:25:28:\
    \ error: cannot assign value of type 'String' to subscript of type 'String.SubSequence'\
    \ (aka 'Substring')\n                words[j] = String(unicodeScalars: [index])\n\
    \                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp17ikp32w.swift:26:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \      j--\n                 ^~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var a = s.lowercased()\n    var\
    \ n = a.characters.count\n    var c = \"\"\n    for _ in 0..<n {\n        if a.characters.count\
    \ < 2 {\n            break\n        }\n        let b = a.characters.suffix(1).first!\n\
    \        let index = a.characters.indexOf(b)\n        let c = a.characters.prefix(index)\n\
    \        a = a.substringFromIndex(index).appending(c)\n    }\n    return a\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp71oft58o.swift:16:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    var n = a.characters.count\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp71oft58o.swift:19:14:\
    \ error: 'characters' is unavailable: Please use String directly\n        if a.characters.count\
    \ < 2 {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp71oft58o.swift:22:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        let b = a.characters.suffix(1).first!\n       \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp71oft58o.swift:23:34: error: value of type 'String' has no member 'indexOf'\n\
    \        let index = a.characters.indexOf(b)\n                    ~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmp71oft58o.swift:25:15: error: value of type 'String' has no\
    \ member 'substringFromIndex'\n        a = a.substringFromIndex(index).appending(c)\n\
    \            ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var s = s\n    var r = \"\"\n\
    \    var i = 0\n    for c in s.characters {\n        if c == ' ' {\n         \
    \   if i == 0 || s.characters.count <= i {\n                r += c\n         \
    \   } else {\n                i += 2\n            }\n        } else {\n      \
    \      i++\n            r += String(c)\n        }\n    }\n    return r\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmphtjww65c.swift:19:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == ' ' {\n                ^~~\n                \" \"\n\
    /tmp/tmphtjww65c.swift:18:16: error: 'characters' is unavailable: Please use String\
    \ directly\n    for c in s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmphtjww65c.swift:20:28: error: 'characters'\
    \ is unavailable: Please use String directly\n            if i == 0 || s.characters.count\
    \ <= i {\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphtjww65c.swift:21:22: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n                r += c\n\
    \                     ^\n/tmp/tmphtjww65c.swift:26:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            i++\n             ^~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words: [String] = s.split(separator:\
    \ \" \").map{ $0.trimmingCharacters(in: .whitespaces) }\n    let result: [String]\
    \ = words.sorted(by: { $0.count < $1.count })\n    return result.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpfc9tawgt.swift:15:59: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'trimmingCharacters'\n    let words: [String]\
    \ = s.split(separator: \" \").map{ $0.trimmingCharacters(in: .whitespaces) }\n\
    \                                                       ~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfc9tawgt.swift:15:83: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    let words: [String] = s.split(separator: \" \"\
    ).map{ $0.trimmingCharacters(in: .whitespaces) }\n                           \
    \                                                      ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var resultString = String()\n\
    \    for word in s.split(separator: \" \") {\n        let firstChar = word.characters.first\n\
    \        let firstCharAscii = firstChar.asciiValue\n        let charsArray = word.characters.dropFirst().sorted(by:\
    \ { $0.asciiValue < $1.asciiValue })\n        if firstCharAscii < charsArray.first\
    \ {\n            resultString += String(cString: charsArray.first)\n        }\
    \ else {\n            resultString += String(cString: charsArray.last)\n     \
    \   }\n    }\n    return resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmptweivwiq.swift:17:30: error: 'characters' is unavailable: Please\
    \ use Substring directly\n        let firstChar = word.characters.first\n    \
    \                         ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmptweivwiq.swift:18:30: error: value of optional type\
    \ 'Character?' must be unwrapped to refer to member 'asciiValue' of wrapped base\
    \ type 'Character'\n        let firstCharAscii = firstChar.asciiValue\n      \
    \                       ^\n/tmp/tmptweivwiq.swift:18:30: note: chain the optional\
    \ using '?' to access member 'asciiValue' only for non-'nil' base values\n   \
    \     let firstCharAscii = firstChar.asciiValue\n                            \
    \ ^\n                                      ?\n/tmp/tmptweivwiq.swift:19:70: error:\
    \ value of optional type 'UInt8?' must be unwrapped to a value of type 'UInt8'\n\
    \        let charsArray = word.characters.dropFirst().sorted(by: { $0.asciiValue\
    \ < $1.asciiValue })\n                                                       \
    \              ^\n/tmp/tmptweivwiq.swift:19:70: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        let charsArray = word.characters.dropFirst().sorted(by:\
    \ { $0.asciiValue < $1.asciiValue })\n                                       \
    \                              ^\n                                           \
    \                                     ?? <#default value#>\n/tmp/tmptweivwiq.swift:19:70:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        let charsArray = word.characters.dropFirst().sorted(by: { $0.asciiValue\
    \ < $1.asciiValue })\n                                                       \
    \              ^\n                                                           \
    \                    !\n/tmp/tmptweivwiq.swift:19:86: error: value of optional\
    \ type 'UInt8?' must be unwrapped to a value of type 'UInt8'\n        let charsArray\
    \ = word.characters.dropFirst().sorted(by: { $0.asciiValue < $1.asciiValue }"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    for word\
    \ in s.split(separator: \" \") {\n        result += word.unicodeScalars.sorted\
    \ { $0.value < $1.value }.joined(separator: \" \")\n        result += \" \"\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpwve5d_7y.swift:17:39: error: referencing instance method 'joined(separator:)'\
    \ on 'BidirectionalCollection' requires the types 'Substring.UnicodeScalarView.Element'\
    \ (aka 'Unicode.Scalar') and 'String' be equivalent\n        result += word.unicodeScalars.sorted\
    \ { $0.value < $1.value }.joined(separator: \" \")\n                         \
    \             ^\nSwift.BidirectionalCollection:1:11: note: where 'Self.Element'\
    \ = 'Substring.UnicodeScalarView.Element' (aka 'Unicode.Scalar')\nextension BidirectionalCollection\
    \ where Self.Element == String {\n          ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    \n    var result = \"\"\n    var\
    \ i = 0\n    var word = s.substring(i)\n    while i < s.characters.count {\n \
    \       let char = s[i]\n        if char == \" \" {\n            // If it's a\
    \ space, append it to result\n            result += word\n            // Reset\
    \ the word variable\n            word = s.substring(i)\n            // and move\
    \ to the next word\n            i += 1\n        } else {\n            // Otherwise,\
    \ append the current char at the end of the word string\n            word += char\n\
    \            // Move to the next word\n            i += 1\n        }\n    }\n\
    \    \n    // If the last word was left unprocessed, append it at the end\n  \
    \  result += word\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp1jk3670p.swift:18:18: error: value of type 'String' has no member\
    \ 'substring'\n    var word = s.substring(i)\n               ~ ^~~~~~~~~\n/tmp/tmp1jk3670p.swift:19:17:\
    \ error: 'characters' is unavailable: Please use String directly\n    while i\
    \ < s.characters.count {\n                ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp1jk3670p.swift:20:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let char = s[i]\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp1jk3670p.swift:25:22: error: value\
    \ of type 'String' has no member 'substring'\n            word = s.substring(i)\n\
    \                   ~ ^~~~~~~~~\n/tmp/tmp1jk3670p.swift:30:18: error: binary operator\
    \ '+=' cannot be applied to operands of type 'String' and 'Character'\n      \
    \      word += char\n            ~~~~ ^  ~~~~\n/tmp/tmp1jk3670p.swift:30:18: note:\
    \ overloads for '+=' exist with these partially matching parameter lists: (inout\
    \ ContinuousClock.Instant, Duration), (inout Double, Double), (inout Duration,\
    \ Duration), (inout Float, Float), (inout Float16, Float16), (inout Float80, Float80),\
    \ (inout Int, Int), (inout Int16, Int16), (inout Int32, Int32), (inout Int64,\
    \ Int64), (inout Int8, Int8), (inout String, String), (inout SuspendingClock.Instant,\
    \ Duration), (inout UInt, UInt), (inout UInt16, UInt16), (inout UInt32, UInt32),\
    \ (inout UInt64, UInt64), (inout UInt8, UInt8)\n            word += char\n   \
    \              ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\tconst maxLen = 13\n\tlet r = s.unicodeScalars\n\
    \tlet len = r.count\n\tlet words: Array<String> = []\n\tlet word = \"\"\n\tlet\
    \ i: Int\n\tlet j = len - maxLen\n\tlet k: Int\n\tvar len2 = len - 2\n\n\tfor\
    \ (i = 0; i < j; i++ {\n\t\tfor (k = 0; k < maxLen; k++ {\n\t\t\tif i == k {\n\
    \t\t\t\tword += String(UnicodeScalar(r[i].value)) + String(r[i].value)\n\t\t\t\
    } else {\n\t\t\t\tif String(UnicodeScalar(r[i].value)).utf8 <= String(UnicodeScalar(r[j].value)).utf8\
    \ {\n\t\t\t\t\tword += String(r[i].value)\n\t\t\t\t} else {\n\t\t\t\t\tword +=\
    \ String(r[j].value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif words.count == 1 {\n\t\
    \t\tword = word + \" \"\n\t\t}\n\t\twords += [word]\n\t\tword = String()\n\t}\n\
    \n\tfor (i = 0; i < len2; i++, j-- {\n\t\tif i == len2 || j == 0 {\n\t\t\tcontinue\n\
    \t\t}\n\t\tfor (k = 0; k < maxLen; k++ {\n\t\t\tif i == k {\n\t\t\t\tword += String(UnicodeScalar(r[i].value))\
    \ + String(r[i].value)\n\t\t\t} else {\n\t\t\t\tif String(UnicodeScalar(r[i].value)).utf8\
    \ <= String(UnicodeScalar(r[j].value)).utf8 {\n\t\t\t\t\tword += String(r[i].value)\n\
    \t\t\t\t} else {\n\t\t\t\t\tword += String(r[j].value)\n\t\t\t\t}\n\t\t\t}\n\t\
    \t}\n\t\tif words.count == 1 {\n\t\t\tword = word + \" \"\n\t\t}\n\t\twords +=\
    \ [word]\n\t\tword = String()\n\t}\n\n\treturn words.joined(separator: \" \")\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp0eg8da2b.swift:15:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        const maxLen = 13\n             ^\n           \
    \  ;\n/tmp/tmp0eg8da2b.swift:25:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for (i = 0; i < j; i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0eg8da2b.swift:66:37: error: expected '{' to start the body of for-each\
    \ loop\n        return words.joined(separator: \" \")\n                      \
    \                     ^\n/tmp/tmp0eg8da2b.swift:15:2: error: cannot find 'const'\
    \ in scope\n        const maxLen = 13\n        ^~~~~\n/tmp/tmp0eg8da2b.swift:15:8:\
    \ error: cannot find 'maxLen' in scope\n        const maxLen = 13\n          \
    \    ^~~~~~\n/tmp/tmp0eg8da2b.swift:21:16: error: cannot find 'maxLen' in scope\n\
    \        let j = len - maxLen\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var output = \"\"\n    var i =\
    \ 0\n    var j = 0\n    for letter in s {\n        if letter == \" \" {\n    \
    \        output += \" \"\n            i++\n        }\n        switch letter {\n\
    \        case \".\", \"?\", \"!\":\n            output += letter\n        case\
    \ \" \":\n            output += letter\n        default:\n            output +=\
    \ letter + String(Int(letter)) + String(Int(letter) + 1)\n        }\n        j\
    \ = j + 1\n        if j % 2 == 1 {\n            output += letter\n        }\n\
    \    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4q9rna5.swift:21:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            i++\n             ^~\n/tmp/tmpx4q9rna5.swift:25:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            output += letter\n                      ^\n/tmp/tmpx4q9rna5.swift:27:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            output += letter\n                      ^\n/tmp/tmpx4q9rna5.swift:29:13:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n            output\
    \ += letter + String(Int(letter)) + String(Int(letter) + 1)\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx4q9rna5.swift:33:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            output += letter\n         \
    \             ^\n"
  stdout: ''
  timestamp: 1660014160
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let wordsArray = s.split(separator:\
    \ \" \").sorted(by: { $0.compare($1) == .orderedAscending })\n    return wordsArray.join(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp928_8fqp.swift:15:62: error: reference to member 'compare' cannot\
    \ be resolved without a contextual type\n    let wordsArray = s.split(separator:\
    \ \" \").sorted(by: { $0.compare($1) == .orderedAscending })\n               \
    \                                              ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\tlet chars = s.chars().enumerate().map\
    \ { i, char in\n\t\tlet start = s.startIndex\n\t\tlet end = s.index(after: i)\n\
    \t\tlet char = s[start..<end]\n\t\treturn char\n\t}\n\n\tlet sorted = chars.sorted()\n\
    \n\tlet output = String()\n\n\tsorted.forEach { c in\n\t\tif c != ' ' {\n\t\t\t\
    output += c\n\t\t} else {\n\t\t\toutput += ' '\n\t\t}\n\t}\n\n\treturn output\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpqxfx17t0.swift:27:11: error: single-quoted string literal found,\
    \ use '\"'\n                if c != ' ' {\n                        ^~~\n     \
    \                   \" \"\n/tmp/tmpqxfx17t0.swift:30:14: error: single-quoted\
    \ string literal found, use '\"'\n                        output += ' '\n    \
    \                              ^~~\n                                  \" \"\n\
    /tmp/tmpqxfx17t0.swift:15:16: error: value of type 'String' has no member 'chars'\n\
    \        let chars = s.chars().enumerate().map { i, char in\n                \
    \    ~ ^~~~~\n/tmp/tmpqxfx17t0.swift:28:11: error: left side of mutating operator\
    \ isn't mutable: 'output' is a 'let' constant\n                        output\
    \ += c\n                        ~~~~~~ ^\n/tmp/tmpqxfx17t0.swift:24:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let output = String()\n        ^~~\n\
    \        var\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Do not use sort() method because\
    \ we must keep the order of words and blank\n    // spaces in the sentence.\n\
    \    var result = \"\"\n    var pos = 0\n    for ch in s {\n        var is_space\
    \ = ch == \" \"\n        var new_ch: Character\n        var current_ch: Character\n\
    \        if !is_space {\n            current_ch = ch\n            new_ch = ch\
    \ + Character(Int((UInt32(ch) - UInt32(current_ch)) / 36)) + current_ch\n    \
    \    } else {\n            current_ch = \"\\n\"\n            new_ch = \"\\n\"\n\
    \        }\n        result += String(new_ch)\n        pos += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpmhgdew5n.swift:25:13: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n            new_ch = ch + Character(Int((UInt32(ch) - UInt32(current_ch))\
    \ / 36)) + current_ch\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014163
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var resultString = s\n    var\
    \ wordsToShuffle = [String]()\n    for word in s.components(separatedBy: \" \"\
    ) {\n        wordsToShuffle.append(word)\n    }\n    for index in 0..<wordsToShuffle.count\
    \ {\n        var firstWordIndex = Int(index)\n        var secondWordIndex = firstWordIndex\
    \ + 1\n        var thirdWordIndex = secondWordIndex + 1\n        var fourthWordIndex\
    \ = thirdWordIndex + 1\n\n        var firstWord = wordsToShuffle[firstWordIndex]\n\
    \        var secondWord = wordsToShuffle[secondWordIndex]\n        var thirdWord\
    \ = wordsToShuffle[thirdWordIndex]\n        var fourthWord = wordsToShuffle[fourthWordIndex]\n\
    \n        wordsToShuffle[firstWordIndex] = fourthWord\n        wordsToShuffle[secondWordIndex]\
    \ = thirdWord\n        wordsToShuffle[thirdWordIndex] = secondWord\n        wordsToShuffle[fourthWordIndex]\
    \ = firstWord\n    }\n    for index in 0..<wordsToShuffle.count {\n        resultString\
    \ = resultString.replacingOccurrences(of: wordsToShuffle[index], with: \"\")\n\
    \    }\n    return resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpa80ezw2a.swift:17:19: error: value of type 'String' has no member\
    \ 'components'\n    for word in s.components(separatedBy: \" \") {\n         \
    \       ~ ^~~~~~~~~~\n/tmp/tmpa80ezw2a.swift:37:37: error: value of type 'String'\
    \ has no member 'replacingOccurrences'\n        resultString = resultString.replacingOccurrences(of:\
    \ wordsToShuffle[index], with: \"\")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n    var new_s = s.characters.map { $0 }\n    new_s.reverse()\n   \
    \ new_s = new_s.joined(separator: \"\")\n    return new_s.characters.map { Character($0)\
    \ }.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp0uub0_sz.swift:18:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var new_s = s.characters.map { $0 }\n             \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp0uub0_sz.swift:20:19:\
    \ error: no exact matches in call to instance method 'joined'\n    new_s = new_s.joined(separator:\
    \ \"\")\n                  ^\n/tmp/tmp0uub0_sz.swift:20:19: note: found candidate\
    \ with type '(String) -> JoinedSequence<[String.Element]>' (aka '(String) -> JoinedSequence<Array<Character>>')\n\
    \    new_s = new_s.joined(separator: \"\")\n                  ^\n/tmp/tmp0uub0_sz.swift:20:19:\
    \ note: found candidate with type '(String) -> String'\n    new_s = new_s.joined(separator:\
    \ \"\")\n                  ^\n/tmp/tmp0uub0_sz.swift:20:19: error: no 'joined'\
    \ candidates produce the expected contextual result type '[String.Element]' (aka\
    \ 'Array<Character>')\n    new_s = new_s.joined(separator: \"\")\n           \
    \       ^\nSwift.Sequence:2:40: note: 'joined(separator:)' produces 'JoinedSequence<[String.Element]>'\
    \ (aka 'JoinedSequence<Array<Character>>'), not the expected contextual result\
    \ type '[String.Element]' (aka 'Array<Character>')\n    @inlinable public __consuming\
    \ func joined<Separator>(separator: Separator) -> JoinedSequence<Self> where Separator\
    \ : Sequence, Separator.Element == Self.Element.Element\n                    \
    \                   ^\nSwift.Sequence:2:17: note: 'joined(separator:)' produces\
    \ 'String', not the expected contextual result type '[String.Element]' (aka 'Array<Character>')\n\
    \    public func joined(separator: String = \"\") -> String\n                ^\n\
    Swift.BidirectionalCollection:2:17: note: 'joined(separator:)' produces 'String',\
    \ not the expected contextual result type '[String.Element]' (aka 'Array<Character>')\n\
    \    public func joined(separator: String = \"\") -> String\n                ^\n\
    /tmp/tmp0uub0_sz.swift:21:18: error: value of type '[String.Element]' (aka 'Array<Character>')\
    \ has no member 'characters'\n    return new"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\ts = s.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \tlet words = s.components(separatedBy: \" \")\n\tlet sortedWords = words.sorted\
    \ { $0.compare($1) == .orderedAscending }\n\tlet result = sortedWords.reduce(\"\
    \") {\n\t\t$0 + String($1) + \" \"\n\t}\n\treturn result.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_rwinq1.swift:15:2: error: cannot assign to value: 's' is a 'let'\
    \ constant\n        s = s.trimmingCharacters(in: .whitespacesAndNewlines)\n  \
    \      ^\n/tmp/tmp1_rwinq1.swift:15:8: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n        s = s.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \            ~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp1_rwinq1.swift:15:32: error: cannot\
    \ infer contextual base in reference to member 'whitespacesAndNewlines'\n    \
    \    s = s.trimmingCharacters(in: .whitespacesAndNewlines)\n                 \
    \                    ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1_rwinq1.swift:16:16: error:\
    \ value of type 'String' has no member 'components'\n        let words = s.components(separatedBy:\
    \ \" \")\n                    ~ ^~~~~~~~~~\n/tmp/tmp1_rwinq1.swift:21:40: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n     \
    \                                        ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.split(separator:\
    \ \" \")\n    let sortedWords = words.sorted()\n\n    return sortedWords.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: Exception
  stderr: 'tmpq6tgwxz5/tmpq6tgwxz5.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aebc5b53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aebc584ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aebc584a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aebc58497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq6tgwxz5                        0x00005604a9481767 <unavailable> + 5991

    5    libc.so.6                          0x00002aebc5d3f460 __libc_start_main +
    245

    6    tmpq6tgwxz5                        0x00005604a94812b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Your code here\n    var newStr\
    \ = \"\"\n    for _ in s.characters {\n        let rand = arc4random_uniform(64)\n\
    \        if rand < 26 {\n            newStr += String(UnicodeScalar(UInt8(rand)))\n\
    \        } else {\n            newStr += String(UnicodeScalar(UInt16(rand)))\n\
    \        }\n    }\n    return newStr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp3_96z4zm.swift:17:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3_96z4zm.swift:18:20:\
    \ error: cannot find 'arc4random_uniform' in scope\n        let rand = arc4random_uniform(64)\n\
    \                   ^~~~~~~~~~~~~~~~~~\n/tmp/tmp3_96z4zm.swift:22:30: error: value\
    \ of optional type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>') must be unwrapped\
    \ to a value of type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            newStr\
    \ += String(UnicodeScalar(UInt16(rand)))\n                             ^\n/tmp/tmp3_96z4zm.swift:22:30:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            newStr += String(UnicodeScalar(UInt16(rand)))\n         \
    \                    ^\n                                                     \
    \    ?? <#default value#>\n/tmp/tmp3_96z4zm.swift:22:30: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n            newStr\
    \ += String(UnicodeScalar(UInt16(rand)))\n                             ^\n   \
    \                                                     !\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var a = s.characters\n    var\
    \ sw = a.makeIterator()\n    var i = a.startIndex\n    var nw = String()\n   \
    \ var r = true\n    var j = a.endIndex\n    \n    while sw.next() != nil && !sw.hasNext()\
    \ {\n        if j == a.endIndex {\n            j = a.startIndex\n        }\n \
    \       nw.append(r == false ? a[--j] : a[++i])\n    }\n    \n    for _ in 1..a.count\
    \ {\n        nw.append(r == false ? a[--j] : a[++i])\n    }\n    \n    return\
    \ nw\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"\
    Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpcrb_8_tf.swift:15:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    var a = s.characters\n              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpcrb_8_tf.swift:22:35: error: value of\
    \ type 'String.Iterator' has no member 'hasNext'\n    while sw.next() != nil &&\
    \ !sw.hasNext() {\n                               ~~ ^~~~~~~\n/tmp/tmpcrb_8_tf.swift:26:34:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n        nw.append(r\
    \ == false ? a[--j] : a[++i])\n                                 ^~\n/tmp/tmpcrb_8_tf.swift:26:43:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        nw.append(r\
    \ == false ? a[--j] : a[++i])\n                                          ^~\n\
    /tmp/tmpcrb_8_tf.swift:29:15: error: cannot find operator '..' in scope; did you\
    \ mean '...'?\n    for _ in 1..a.count {\n              ^~\n              ...\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var chars = s.characters\n   \
    \ var result = [String]()\n    for i in 0..<s.characters.count {\n        let\
    \ j = chars.count - i\n        let word = String(chars.suffix(j))\n        let\
    \ replaced = s.replacingOccurrences(of: word, with: word)\n        result.append(replaced)\n\
    \    }\n    return result.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp218mwjtb.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp218mwjtb.swift:17:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    for i in\
    \ 0..<s.characters.count {\n                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp218mwjtb.swift:20:26: error: value of\
    \ type 'String' has no member 'replacingOccurrences'\n        let replaced = s.replacingOccurrences(of:\
    \ word, with: word)\n                       ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\treturn s.shuffled().shuffled().shuffled()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpltr2m3uv.swift:15:33: error: cannot convert return expression of\
    \ type '[String.Element]' (aka 'Array<Character>') to return type 'String'\n \
    \       return s.shuffled().shuffled().shuffled()\n               ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if let _ = s.shuffle() {\n   \
    \     return String(s)\n    } else {\n        return \"\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpfkwijtlu.swift:15:18: error: value of type 'String' has no member\
    \ 'shuffle'\n    if let _ = s.shuffle() {\n               ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let arr = s.characters\n    let\
    \ result = (0..<arr.count).map { i in\n        let c = arr[i]\n        if c ==\
    \ \" \" {\n            return \"!\"\n        }\n        let index = arr[i]\n \
    \       let index = c.asciiValue\n        if index >= 65 {\n            index\
    \ = (index + 32) - 64\n        }\n        let index = String(index: index, radix:\
    \ 16)\n        return String(c.unicodeScalars.first!.value, decomposed: false,\
    \ characters: [index])\n    }\n    return String(result)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp6ibk1p5l.swift:15:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arr = s.characters\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6ibk1p5l.swift:23:12:\
    \ error: value of optional type 'UInt8?' must be unwrapped to a value of type\
    \ 'UInt8'\n        if index >= 65 {\n           ^\n/tmp/tmp6ibk1p5l.swift:23:12:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if index >= 65 {\n           ^\n                 ?? <#default\
    \ value#>\n/tmp/tmp6ibk1p5l.swift:23:12: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if index >= 65 {\n \
    \          ^\n                !\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.split(separator:\
    \ \" \")\n    let characters = Array(s)\n    var result = [String]()\n    var\
    \ counts: [Character: [Int]] = [:]\n    for word in words {\n        var c = characters.filter{\
    \ $0 != word }\n        guard !c.isEmpty else { continue }\n        for c in c\
    \ {\n            if let count = counts[c] { counts[c] = count + 1 } else { counts[c]\
    \ = 1; }\n        }\n        var maxCount = 0\n        for (c, _) in counts {\n\
    \            maxCount = maxCount > count ? maxCount : count\n        }\n     \
    \   let newWord = \"\"\n        for (c, _) in counts {\n            newWord +=\
    \ String(c)\n        }\n        guard !newWord.isEmpty else { continue }\n   \
    \     result.insert(newWord, at: 0)\n    }\n    return result.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpctp5gyib.swift:20:28: error: type of expression is ambiguous without\
    \ more context\n        var c = characters.filter{ $0 != word }\n            \
    \    ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpctp5gyib.swift:27:35: error: cannot\
    \ find 'count' in scope\n            maxCount = maxCount > count ? maxCount :\
    \ count\n                                  ^~~~~\n/tmp/tmpctp5gyib.swift:27:54:\
    \ error: cannot find 'count' in scope\n            maxCount = maxCount > count\
    \ ? maxCount : count\n                                                     ^~~~~\n\
    /tmp/tmpctp5gyib.swift:31:21: error: left side of mutating operator isn't mutable:\
    \ 'newWord' is a 'let' constant\n            newWord += String(c)\n          \
    \  ~~~~~~~ ^\n/tmp/tmpctp5gyib.swift:29:9: note: change 'let' to 'var' to make\
    \ it mutable\n        let newWord = \"\"\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var res = s\n    var len = s.count\n\
    \    for i in 0 ..< len {\n        let j = i + random(len - i)\n        if j !=\
    \ i {\n            let temp = s[i ..< j]\n            res.insert(temp, at: i)\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpmbryp5g_.swift:18:21: error: cannot find 'random' in scope\n  \
    \      let j = i + random(len - i)\n                    ^~~~~~\n/tmp/tmpmbryp5g_.swift:21:34:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \            res.insert(temp, at: i)\n                                 ^\n"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var output = \"\"\n    var newString\
    \ = \"\"\n\n    for letter in s.characters {\n        if letter == \" \" {\n \
    \           newString += letter\n        }\n        else if letter == \"\\n\"\
    \ {\n            newString += letter\n        }\n        else if letter == \"\
    \ \" || letter == \"\\n\" || letter == \"\\t\" {\n            newString += letter\n\
    \        }\n        else {\n            newString += String(UnicodeScalar(letter).value)\n\
    \        }\n    }\n    for letter in newString.characters {\n        output +=\
    \ String(UnicodeScalar(letter).value)\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmplrqhwkzm.swift:18:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmplrqhwkzm.swift:20:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            newString += letter\n                         ^\n/tmp/tmplrqhwkzm.swift:23:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            newString += letter\n                         ^\n/tmp/tmplrqhwkzm.swift:26:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            newString += letter\n                         ^\n/tmp/tmplrqhwkzm.swift:29:33:\
    \ error: no exact matches in call to initializer \n            newString += String(UnicodeScalar(letter).value)\n\
    \                                ^\nSwift.Unicode.Scalar:7:23: note: candidate\
    \ expects value of type 'UInt8' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init(_ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23:\
    \ note: candidate expects value of type 'Unicode.Scalar' for parameter #1 (got\
    \ 'Character')\n    @inlinable public init(_ v: Unicode.Scalar)\n            \
    \          ^\n/tmp/tmplrqhwkzm.swift:32:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    for letter in newString.characters {\n     \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmplrqhwkzm.swift:33:26: error: no exact matches in call to\
    \ initializer \n        output += String(UnicodeScalar(letter).value)\n      \
    \                   ^\nSwift.Unicode.Scalar:7:23: note: candidate expects value\
    \ of type 'UInt8' for parameter #1 (got 'Character')\n    @inlinable public init(_\
    \ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23: note: candidate\
    \ expects value of type 'Unicode.Scalar' f"
  stdout: ''
  timestamp: 1660014139
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var newString = \"\"\n    for\
    \ c in s.characters.reversed() {\n        newString += String(Int(c) + 97)\n \
    \   }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8f84yw1.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters.reversed() {\n              \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpk8f84yw1.swift:17:29:\
    \ error: no exact matches in call to initializer \n        newString += String(Int(c)\
    \ + 97)\n                            ^\nSwift.Int:7:12: note: candidate expects\
    \ value of type 'Float16' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    public init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'String.Element' (aka 'Character'))\n\
    \    public init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got 'String.Element' (aka\
    \ 'Character'))\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'String.Element' (aka 'Character'))\n    public init(_ _value: Builtin.Int64)\n\
    \           ^\nSwift.Int:61:12: note: candidate expects value of type 'Builtin.Word'\
    \ for parameter #1 (got 'String.Element' (aka 'Character'))\n    public init(_\
    \ _v: Builtin.Word)\n           ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // TODO: implement anti_shuffle\
    \ function here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: Exception
  stderr: 'tmp5bgndao3/tmp5bgndao3.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4335b3bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4335832b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4335832988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43358317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5bgndao3                        0x0000559f822e0307 <unavailable> + 4871

    5    libc.so.6                          0x00002b4335d27460 __libc_start_main +
    245

    6    tmp5bgndao3                        0x0000559f822dff49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var ordered: String = s\n    for\
    \ word in s.split(\" \") {\n        var temp: String = word\n        for char\
    \ in temp.unicodeScalars {\n            temp = temp.replacingCharacter(in: char,\
    \ with: char.value.uppercased())\n        }\n        ordered = ordered.replacingOccurrences(of:\
    \ temp, with: \"\")\n    }\n    return ordered\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmps8wywefx.swift:16:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    var out = \"\"\n    words.forEach { word in\n        var firstLetter:\
    \ Character = \"a\"\n        for letter in word {\n            guard let newLetter\
    \ = Character(UnicodeScalar(letter).value - firstLetter) else {\n            \
    \    out += \"a\"\n                break\n            }\n            out += String(newLetter)\n\
    \            firstLetter = Character(UnicodeScalar(letter).value)\n        }\n\
    \    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpx4ow36pl.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n/tmp/tmpx4ow36pl.swift:20:35: error: no exact matches in call\
    \ to initializer \n            guard let newLetter = Character(UnicodeScalar(letter).value\
    \ - firstLetter) else {\n                                  ^\n/tmp/tmpx4ow36pl.swift:20:35:\
    \ note: found candidate with type '(Unicode.Scalar) -> Character'\n          \
    \  guard let newLetter = Character(UnicodeScalar(letter).value - firstLetter)\
    \ else {\n                                  ^\n/tmp/tmpx4ow36pl.swift:20:35: note:\
    \ found candidate with type '(String) -> Character'\n            guard let newLetter\
    \ = Character(UnicodeScalar(letter).value - firstLetter) else {\n            \
    \                      ^\n/tmp/tmpx4ow36pl.swift:20:75: error: cannot convert\
    \ value of type 'Character' to expected argument type 'UInt32'\n            guard\
    \ let newLetter = Character(UnicodeScalar(letter).value - firstLetter) else {\n\
    \                                                                          ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var ans = \"\"\n    var newWord\
    \ = \"\"\n    for ch in s {\n        let index = newWord.index(of: ch)\n     \
    \   newWord.replaceSubrange(index...index, with: String(Int(ch) - Int(s.first!.characters.first!)\
    \ - 96))\n    }\n    ans += newWord\n    return ans\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpb4mzo7xr.swift:18:29: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = newWord.index(of: ch)\n          \
    \                  ^\n/tmp/tmpb4mzo7xr.swift:18:29: note: use 'firstIndex(of:)'\
    \ instead\n        let index = newWord.index(of: ch)\n                       \
    \     ^~~~~\n                            firstIndex\n/tmp/tmpb4mzo7xr.swift:19:9:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n        newWord.replaceSubrange(index...index,\
    \ with: String(Int(ch) - Int(s.first!.characters.first!) - 96))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014161
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var list = s.characters\n    var\
    \ new_list = [Character]()\n    let n = list.count\n    for i in 0..<n {\n   \
    \     var j = 0\n        var new_word = Character(\"__\")\n        for j in 0..<n\
    \ {\n            if i == j {\n                continue\n            }\n      \
    \      if list[i] == list[j] {\n                new_list.append(list[i])\n   \
    \         } else {\n                break\n            }\n        }\n        if\
    \ j < n {\n            new_word = list[i]\n            new_list.append(new_word)\n\
    \        }\n        for j in 0..<j {\n            new_list.append(list[j])\n \
    \       }\n        new_list.append(new_word)\n    }\n    new_list = new_list.sorted()\n\
    \    return String(new_list)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpc160sl4k.swift:15:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    var list = s.characters\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpc160sl4k.swift:25:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if list[i] == list[j] {\n         \
    \      ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpc160sl4k.swift:25:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if list[i] == list[j] {\n                          ^~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpc160sl4k.swift:26:33:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                new_list.append(list[i])\n    \
    \                            ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpc160sl4k.swift:32:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            new_word = list[i]\n                       ^~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpc160sl4k.swift:36:29:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            new_list.append(list[j])\n        \
    \                    ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpc160sl4k"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.split(\" \").sorted(by:\
    \ >).joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpda0issvl.swift:15:20: error: missing argument label 'separator:'\
    \ in call\n    return s.split(\" \").sorted(by: >).joined()\n                \
    \   ^\n                   separator: \n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var words = s.split(\" \")\n \
    \   var sArray = s.characters\n    for word in words {\n        for char in word\
    \ {\n            char := char.lowercased()\n            if let index = sArray.index(of:\
    \ char) {\n                sArray.remove(at: index)\n            }\n        }\n\
    \    }\n    return String(sArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ct2qe1e.swift:19:17: error: consecutive statements on a line must\
    \ be separated by ';'\n            char := char.lowercased()\n               \
    \ ^\n                ;\n/tmp/tmp7ct2qe1e.swift:19:18: error: expected expression\n\
    \            char := char.lowercased()\n                 ^\n/tmp/tmp7ct2qe1e.swift:15:19:\
    \ error: no exact matches in call to instance method 'split'\n    var words =\
    \ s.split(\" \")\n                  ^\nSwift.Sequence:2:40: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable public\
    \ __consuming func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmp7ct2qe1e.swift:16:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var sArray\
    \ = s.characters\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let chars = s.characters\n   \
    \ var i = 0\n    var j = 0\n    var k = 0\n    var n = s.count\n\n    while i\
    \ < n {\n        j += 1\n        if chars[i] == ' ' {\n            i += j\n  \
    \      }\n        k += 1\n        while chars[k] == ' ' {\n            k -= 1\n\
    \        }\n        if j < k {\n            chars[i + j] = chars[k]\n        \
    \    chars[i + j + 1] = chars[j]\n            chars[i + j + 1] = ' '\n       \
    \     i += j + 2\n        }\n    }\n\n    return String(chars)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpbxcz_287.swift:23:24: error: single-quoted string literal found,\
    \ use '\"'\n        if chars[i] == ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmpbxcz_287.swift:27:27: error: single-quoted string\
    \ literal found, use '\"'\n        while chars[k] == ' ' {\n                 \
    \         ^~~\n                          \" \"\n/tmp/tmpbxcz_287.swift:33:32:\
    \ error: single-quoted string literal found, use '\"'\n            chars[i + j\
    \ + 1] = ' '\n                               ^~~\n                           \
    \    \" \"\n/tmp/tmpbxcz_287.swift:15:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    let chars = s.characters\n                 \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpbxcz_287.swift:23:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if chars[i] == ' ' {\n           ^~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpbxcz_287.swift:27:15:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        while chars[k] == ' ' {\n             \
    \ ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpbxcz_287.swift:31:18: error: cannot assign through subscript:\
    \ subscript is get-only\n            chars[i + j] = chars[k]\n            ~~~~~^~~~~~~\n\
    /tmp/tmpbxcz_287.swift:32:18: error: cannot assign through subscript: subscript\
    \ is get-only\n            chars[i + j + 1] = chars[j]\n            ~~~~~^~~~~~~~~~~\n\
    /tmp/tmpbxcz_287.swift:33:18: error: cannot assign through subscript: subscript\
    \ is get-only\n            chars[i + j + 1] = ' '\n            ~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let characters = s.characters;\n\
    \    var result = \"\";\n    var i = 0;\n    for character in characters {\n \
    \       let ascii = character.unicodeScalars.filter { $0.value == 0 }.count;\n\
    \        if i == characters.count - 1 {\n            result = result + character;\n\
    \        }\n        else if (i == 0) {\n            result = result + character;\n\
    \        }\n        else if (ascii <= characters[i + 1].ascii) {\n           \
    \ result = result + character;\n        }\n        else {\n            result\
    \ = result + characters[i + 1];\n        }\n        i += 1;\n    }\n    return\
    \ result;\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp9smtiofs.swift:15:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let characters = s.characters;\n                  \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9smtiofs.swift:21:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result = result + character;\n                              ^\n/tmp/tmp9smtiofs.swift:24:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result = result + character;\n                              ^\n/tmp/tmp9smtiofs.swift:26:45:\
    \ error: value of type 'Character' has no member 'ascii'\n        else if (ascii\
    \ <= characters[i + 1].ascii) {\n                          ~~~~~~~~~~~~~~~~~ ^~~~~\n\
    /tmp/tmp9smtiofs.swift:27:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result = result + character;\n\
    \                              ^\n/tmp/tmp9smtiofs.swift:30:41: error: no exact\
    \ matches in call to subscript \n            result = result + characters[i +\
    \ 1];\n                                        ^\nSwift.String:3:12: note: candidate\
    \ expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n \
    \   public subscript(r: Range<String.Index>) -> Substring { get }\n          \
    \ ^\nSwift.Collection:3:23: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var r : String = \"\"\n    for\
    \ i in s.characters {\n        if i > 'Z' {\n            r = String(r + \"A\"\
    \ + String(i - 'Z') + \" \")\n        } else {\n            r = String(r + String(i\
    \ - 'A') + \" \")\n        }\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp2p53ehg3.swift:17:16: error: single-quoted string literal found,\
    \ use '\"'\n        if i > 'Z' {\n               ^~~\n               \"Z\"\n/tmp/tmp2p53ehg3.swift:18:45:\
    \ error: single-quoted string literal found, use '\"'\n            r = String(r\
    \ + \"A\" + String(i - 'Z') + \" \")\n                                       \
    \     ^~~\n                                            \"Z\"\n/tmp/tmp2p53ehg3.swift:20:39:\
    \ error: single-quoted string literal found, use '\"'\n            r = String(r\
    \ + String(i - 'A') + \" \")\n                                      ^~~\n    \
    \                                  \"A\"\n/tmp/tmp2p53ehg3.swift:16:16: error:\
    \ 'characters' is unavailable: Please use String directly\n    for i in s.characters\
    \ {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2p53ehg3.swift:18:43: error: referencing operator function '-' on\
    \ 'SIMD' requires that 'Unicode.Scalar' conform to 'SIMD'\n            r = String(r\
    \ + \"A\" + String(i - 'Z') + \" \")\n                                       \
    \   ^\nSwift.SIMD:1:11: note: where 'Self' = 'Unicode.Scalar'\nextension SIMD\
    \ where Self.Scalar : FloatingPoint {\n          ^\n/tmp/tmp2p53ehg3.swift:20:37:\
    \ error: referencing operator function '-' on 'SIMD' requires that 'Unicode.Scalar'\
    \ conform to 'SIMD'\n            r = String(r + String(i - 'A') + \" \")\n   \
    \                                 ^\nSwift.SIMD:1:11: note: where 'Self' = 'Unicode.Scalar'\n\
    extension SIMD where Self.Scalar : FloatingPoint {\n          ^\n"
  stdout: ''
  timestamp: 1660014164
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.split(separator:\
    \ \" \")\n    guard words.count > 0 else { return s }\n    return words.map {\
    \ $0.swapcase() }.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpojwhtq62.swift:17:27: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'swapcase'\n    return words.map { $0.swapcase()\
    \ }.joined(separator: \" \")\n                       ~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let wordsSplit = s.characters\n\
    \        .filter({$0 != \" \"})\n        .sorted()\n    let lettersSplit = s.characters\n\
    \        .filter({$0 != \" \" && $0 != \"\\n\"})\n        .sorted()\n    return\
    \ String(wordsSplit + lettersSplit)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpio6a0eem.swift:15:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let wordsSplit = s.characters\n                   \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpio6a0eem.swift:18:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let lettersSplit\
    \ = s.characters\n                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    var output = \"\"\n    for word in words {\n        let sortedChars\
    \ = word.characters.sorted()\n        for char in sortedChars {\n            output\
    \ += char\n        }\n        output += \" \"\n    }\n    return output\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp0s0iqmzy.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var out = String()\n    var i\
    \ = 0\n    while i < s.count {\n        if i == 0 {\n            out = String(s.characters.dropFirst())\n\
    \        }\n        var lower = Int(s.characters[i])\n        if lower >= 97 &&\
    \ lower <= 122 {\n            out += String(s.characters[i-1]) + String(s.characters[i+1])\n\
    \            i += 2\n        } else {\n            out += String(s.characters[i-1])\n\
    \            i += 1\n        }\n    }\n    return out\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpo88spvk0.swift:19:28: error: 'characters' is unavailable: Please\
    \ use String directly\n            out = String(s.characters.dropFirst())\n  \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpo88spvk0.swift:21:37: error: no exact matches in call to\
    \ subscript \n        var lower = Int(s.characters[i])\n                     \
    \               ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Int')\n    public subscript(r: Range<String.Index>) ->\
    \ Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n/tmp/tmpo88spvk0.swift:23:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            out += String(s.characters[i-1]) + String(s.characters[i+1])\n  \
    \                        ^~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpo88spvk0.swift:23:29: error: 'characters'\
    \ is unavailable: Please use String directly\n            out += String(s.characters[i-1])\
    \ + String(s.characters[i+1])\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpo88spvk0.swift:23:55: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            out += String(s.characters[i-1]) + String(s.characters[i+1])\n  \
    \                                                    ^~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpo"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"_\", options: NSStringCompareOptions.CaseInsensitiveSearch,\
    \ range: nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp3ll8i9os.swift:15:82: error: cannot find 'NSStringCompareOptions'\
    \ in scope\n    return s.stringByReplacingOccurrencesOfString(\" \", withString:\
    \ \"_\", options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil)\n\
    \                                                                            \
    \     ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ll8i9os.swift:15:14: error: value of type\
    \ 'String' has no member 'stringByReplacingOccurrencesOfString'\n    return s.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"_\", options: NSStringCompareOptions.CaseInsensitiveSearch,\
    \ range: nil)\n           ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ll8i9os.swift:15:135:\
    \ error: 'nil' requires a contextual type\n    return s.stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"_\", options: NSStringCompareOptions.CaseInsensitiveSearch,\
    \ range: nil)\n                                                              \
    \                                                                        ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\tlet words = s.components(separatedBy:\
    \ \" \")\n\tvar new_s = \"\"\n\tfor i in 0..<words.count {\n\t\tlet word = words[i]\n\
    \t\tlet characters = Array(word)\n\t\tlet characters_sort_by = characters.sorted(by:\
    \ { $0 < $1 })\n\t\tlet new_word = String(characters_sort_by)\n\t\tnew_s += new_word\n\
    \t}\n\treturn new_s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpc3bufts8.swift:15:16: error: value of type 'String' has no member\
    \ 'components'\n        let words = s.components(separatedBy: \" \")\n       \
    \             ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var chars = s.characters\n   \
    \ if chars.count == 0 {\n        return \"\"\n    }\n    var new_chars = [Character]()\n\
    \    var i = 0\n    for char in chars {\n        let char = Character(char)\n\
    \        if char == ' ' {\n            new_chars.append(char!)\n        } else\
    \ {\n            new_chars.append(char)\n        }\n    }\n    for char in new_chars\
    \ {\n        for _ in 0...s.count {\n            var j = i + Int(arc4random_uniform(UInt32(i\
    \ + 1)))\n            var temp = chars[j]\n            chars[j] = chars[i]\n \
    \           chars[i] = temp\n            i += Int(arc4random_uniform(UInt32(i\
    \ + 1)))\n        }\n    }\n    return String(chars)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpx_glr_qm.swift:23:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == ' ' {\n                   ^~~\n               \
    \    \" \"\n/tmp/tmpx_glr_qm.swift:15:19: error: 'characters' is unavailable:\
    \ Please use String directly\n    var chars = s.characters\n                 \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpx_glr_qm.swift:22:20:\
    \ error: no exact matches in call to initializer \n        let char = Character(char)\n\
    \                   ^\nSwift.Character:5:23: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(extendedGraphemeClusterLiteral:)')\n    @inlinable\
    \ public init(extendedGraphemeClusterLiteral value: Character)\n             \
    \         ^\nSwift.ExpressibleByExtendedGraphemeClusterLiteral:2:12: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(unicodeScalarLiteral:)')\n \
    \   public init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType)\n\
    \           ^\n/tmp/tmpx_glr_qm.swift:31:29: error: cannot find 'arc4random_uniform'\
    \ in scope\n            var j = i + Int(arc4random_uniform(UInt32(i + 1)))\n \
    \                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmpx_glr_qm.swift:34:18:\
    \ error: cannot assign through subscript: subscript is get-only\n            chars[i]\
    \ = temp\n            ~~~~~^~~\n/tmp/tmpx_glr_qm.swift:35:22: error: cannot find\
    \ 'arc4random_uniform' in scope\n            i += Int(arc4random_uniform(UInt32(i\
    \ + 1)))\n                     ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_str = s\n    var word_array:\
    \ [String] = []\n    var space_index = 0\n\n    for c in s.unicodeScalars {\n\
    \        switch c {\n        case Character(c) == \" \":\n            space_index\
    \ += 1\n        case Character(c) == \"\\n\":\n            new_str = new_str.removeLast()\n\
    \        case Character(c) == \"\\r\":\n            new_str = new_str.removeLast()\n\
    \        case Character(c) == \" \":\n            word_array.append(new_str.removeLast())\n\
    \        case Character(c) == \"\\n\":\n            new_str = new_str.removeLast()\n\
    \        case Character(c) == \"\\r\":\n            new_str = new_str.removeLast()\n\
    \        case Character(c) == \" \":\n            word_array.append(new_str.removeLast())\n\
    \        default:\n            word_array.append(new_str.removeLast())\n     \
    \   }\n    }\n\n    for index in 0..<word_array.count {\n        var str = word_array[index]\n\
    \        var last_char = str.removeLast()\n        let start_index = str.startIndex\n\
    \        let end_index = str.endIndex\n        let length = str.length\n\n   \
    \     for j in 0..<length - 1 {\n            let c = String(str[j])\n        \
    \    if c == last_char {\n                new_str = new_str.replace(str.suffix(from:\
    \ j), String(str[j + 1]))\n                new_str = new_str.removeFirst()\n \
    \               new_str = new_str.removeLast()\n            } else {\n       \
    \         new_str = new_str.removeFirst()\n                new_str = new_str.removeLast()\n\
    \            }\n        }\n    }\n    return new_str\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqvih9fy.swift:21:27: error: expression pattern of type 'Bool'\
    \ cannot match values of type 'Unicode.Scalar'\n        case Character(c) == \"\
    \ \":\n             ~~~~~~~~~~~~~^~~~~~\n/tmp/tmpuqvih9fy.swift:23:27: error:\
    \ expression pattern of type 'Bool' cannot match values of type 'Unicode.Scalar'\n\
    \        case Character(c) == \"\\n\":\n             ~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpuqvih9fy.swift:25:27:\
    \ error: expression pattern of type 'Bool' cannot match values of type 'Unicode.Scalar'\n\
    \        case Character(c) == \"\\r\":\n             ~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpuqvih9fy.swift:27:27:\
    \ error: expression pattern of type 'Bool' cannot match values of type 'Unicode.Scalar'\n\
    \        case Character(c) == \" \":\n             ~~~~~~~~~~~~~^~~~~~\n/tmp/tmpuqvih9fy.swift:29:27:\
    \ error: expression pattern of type 'Bool' cannot match values of type 'Unicode.Scalar'\n\
    \        case Character(c) == \"\\n\":\n             ~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpuqvih9fy.swift:31:27:\
    \ error: expression pattern of type 'Bool' cannot match values of type 'Unicode.Scalar'\n\
    \        case Character(c) == \"\\r\":\n             ~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpuqvih9fy.swift:33:27:\
    \ error: expression pattern of type 'Bool' cannot match values of type 'Unicode.Scalar'\n\
    \        case Character(c) == \" \":\n             ~~~~~~~~~~~~~^~~~~~\n/tmp/tmpuqvih9fy.swift:24:31:\
    \ error: cannot assign value of type 'String.Element' (aka 'Character') to type\
    \ 'String'\n            new_str = new_str.removeLast()\n                     \
    \ ~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpuqvih9fy.swift:26:31: error: cannot assign value\
    \ of type 'String.Element' (aka 'Character') to type 'String'\n            new_str\
    \ = new_str.removeLast()\n                      ~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpuqvih9fy.swift:28:39:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n            word_array.append(new_str.removeLast())\n\
    \                                      ^\n/tmp/tmpuqvih9fy.swift:30:31: error:\
    \ cannot assign value of type 'String.Element' (aka 'Character') to type 'String'\n\
    \        "
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var chars = \"\"\n    var word\
    \ = \"\"\n    var len = 0\n    for char in s.unicodeScalars {\n        chars =\
    \ chars + String(char)\n        len = len + 1\n    }\n    for char in chars.unicodeScalars\
    \ {\n        if !isLetterOrDigit(String(char)) {\n            word = word + String(char)\n\
    \        }\n    }\n    for char in word.unicodeScalars {\n        if !isLetterOrDigit(String(char))\
    \ {\n            word = word + String(char)\n        }\n    }\n    return word\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpfhimnsxa.swift:23:13: error: cannot find 'isLetterOrDigit' in scope\n\
    \        if !isLetterOrDigit(String(char)) {\n            ^~~~~~~~~~~~~~~\n/tmp/tmpfhimnsxa.swift:28:13:\
    \ error: cannot find 'isLetterOrDigit' in scope\n        if !isLetterOrDigit(String(char))\
    \ {\n            ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let characters = s.characters;\n\
    \    let characterCount = characters.count;\n    var newString = \"\";\n    for\
    \ (index, char) in characters.enumerate() {\n        if char != \" \" && char\
    \ != \"\\n\" && char != \"\\t\" && char != \"!\" && char != \".\" && char != \"\
    ?\" && char != \"-\" && char != \".\" && char != \";\" && char != \"-\" && char\
    \ != \"!\" && char != \"?\" {\n            newString += \"\\u{1f4aa}\";\n    \
    \    } else {\n            newString += char;\n        }\n    }\n    return newString;\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmptx6kjx6s.swift:15:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let characters = s.characters;\n                  \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmptx6kjx6s.swift:18:37:\
    \ error: value of type 'String' has no member 'enumerate'\n    for (index, char)\
    \ in characters.enumerate() {\n                         ~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var s = s\n    for c in s.unicodeScalars\
    \ {\n        if !c.isBlank {\n            if c.value < 0x80 {\n              \
    \  c.value = c.value - 64\n            } else {\n                c.value = c.value\
    \ + 0x57\n            }\n        }\n    }\n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpiuxr0sys.swift:17:15: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBlank'\n        if !c.isBlank {\n            ~ ^~~~~~~\n/tmp/tmpiuxr0sys.swift:19:19:\
    \ error: cannot assign to property: 'value' is a get-only property\n         \
    \       c.value = c.value - 64\n                ~~^~~~~\n/tmp/tmpiuxr0sys.swift:21:19:\
    \ error: cannot assign to property: 'value' is a get-only property\n         \
    \       c.value = c.value + 0x57\n                ~~^~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var i = 0\n    var j = 0\n   \
    \ var k = s.count\n\n    var temp1 = \"\"\n    var temp2 = \"\"\n\n    for var\
    \ i = 0; i < k; i++ {\n        if i < k / 2 {\n            temp1 += String(i)\n\
    \        }\n    }\n\n    for var j = k - 1; j >= 0; j-- {\n        temp2 += String(j)\n\
    \    }\n\n    var newString = \"\"\n    var strArray = Array(temp1 + \" \" + temp2\
    \ + \" \")\n\n    for var i = 0; i < strArray.count; i++ {\n        newString\
    \ += String(strArray[i])\n    }\n\n    return newString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmptdcdubdq.swift:22:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < k; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptdcdubdq.swift:28:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for var j = k - 1; j >= 0; j-- {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptdcdubdq.swift:35:5: error: C-style for statement has been removed in\
    \ Swift 3\n    for var i = 0; i < strArray.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_s = s\n    var count =\
    \ [Int]()\n    var words = [String]()\n    var spaces = [Bool]()\n    words.reserveCapacity(s.count)\n\
    \    for c in s.unicodeScalars {\n        count = count[Int(c)] ?? 0\n       \
    \ count = count! + 1\n        words.append(String(c))\n        spaces.append(false)\n\
    \    }\n    for c in range(s.count) {\n        if count[Int(c)] != 0 {\n     \
    \       count[Int(c)] = count - 1\n            new_s = String([String(c)]) + new_s\n\
    \        }\n    }\n    return new_s\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp2cdy4wzz.swift:21:23: error: no exact matches in call to initializer\
    \ \n        count = count[Int(c)] ?? 0\n                      ^\n/tmp/tmp2cdy4wzz.swift:21:23:\
    \ note: found candidate with type '(Unicode.Scalar) -> Int'\n        count = count[Int(c)]\
    \ ?? 0\n                      ^\n/tmp/tmp2cdy4wzz.swift:21:31: error: cannot assign\
    \ value of type 'Int' to type '[Int]'\n        count = count[Int(c)] ?? 0\n  \
    \              ~~~~~~~~~~~~~~^~~~\n/tmp/tmp2cdy4wzz.swift:22:26: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Array<Int>'\n       \
    \ count = count! + 1\n                         ^\n/tmp/tmp2cdy4wzz.swift:26:14:\
    \ error: cannot find 'range' in scope\n    for c in range(s.count) {\n       \
    \      ^~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.split(separator: \" \"\
    ).sorted { (lhs, rhs) -> Bool in\n        let lhsChar = String(lhs.utf8)\n   \
    \     let rhsChar = String(rhs.utf8)\n        return lhsChar > rhsChar\n    }.join(\"\
    \ \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpi7_94km9.swift:18:26: error: value of optional type 'String?' must\
    \ be unwrapped to a value of type 'String'\n        return lhsChar > rhsChar\n\
    \                         ^\n/tmp/tmpi7_94km9.swift:18:26: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        return\
    \ lhsChar > rhsChar\n                         ^\n                            \
    \     ?? <#default value#>\n/tmp/tmpi7_94km9.swift:18:26: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        return\
    \ lhsChar > rhsChar\n                         ^\n                            \
    \    !\n/tmp/tmpi7_94km9.swift:18:16: error: value of optional type 'String?'\
    \ must be unwrapped to a value of type 'String'\n        return lhsChar > rhsChar\n\
    \               ^\n/tmp/tmpi7_94km9.swift:18:16: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        return lhsChar\
    \ > rhsChar\n               ^\n                       ?? <#default value#>\n/tmp/tmpi7_94km9.swift:18:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return lhsChar > rhsChar\n               ^\n                \
    \      !\n/tmp/tmpi7_94km9.swift:19:7: error: value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') has no member 'join'\n    }.join(\" \")\n~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var stringArr = s.characters\n\
    \    var newString = \"\"\n    stringArr = stringArr.map { str in\n        let\
    \ code = str.unicodeScalars.last!.value ?? 0\n        let charArr = Array(str.unicodeScalars)\n\
    \        let charArr = charArr.sorted { $0.value ?? 0 > $1.value ?? 0 }\n    \
    \    var str = \"\"\n        for i in 0..<charArr.count {\n            str +=\
    \ String(charArr[i].value)\n        }\n        return String(code).prefix(3)\n\
    \    }\n    newString = String(stringArr)\n    return newString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp3iadia5c.swift:15:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    var stringArr = s.characters\n                    \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp3iadia5c.swift:17:27:\
    \ error: cannot assign value of type '[String.SubSequence]' (aka 'Array<Substring>')\
    \ to type 'String'\n    stringArr = stringArr.map { str in\n                ~~~~~~~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var arr = s.split(\" \").sorted()\n\
    \    let length = arr.count\n    var result = \"\"\n    for _ in 0..<length {\n\
    \        result += arr[Int(arc4random_uniform(UInt32(length - 1)))]\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmplfv9sgbd.swift:15:23: error: missing argument label 'separator:'\
    \ in call\n    var arr = s.split(\" \").sorted()\n                      ^\n  \
    \                    separator: \n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var words: [String] = []\n   \
    \ var i: Int\n    var c: Int\n    var len: Int\n\n    for c in s.characters {\n\
    \        len += 1\n    }\n    \n    for c in s.characters {\n        if s.rangeOfString(\"\
    .\") != nil {\n            i = Int(c) - Int(s.rangeOfString(\".\")!.startIndex)\n\
    \        }\n        else {\n            i = Int(c)\n        }\n        \n    \
    \    if s.rangeOfString(\" \") != nil {\n            i = Int(c) - Int(s.rangeOfString(\"\
    \ \")!.startIndex)\n        }\n        \n        if i >= 0 {\n            words.append(String(Character(c)))\n\
    \        }\n    }\n    \n    return words.sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp07bekkgd.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp07bekkgd.swift:24:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp07bekkgd.swift:25:14: error: value of type 'String'\
    \ has no member 'rangeOfString'\n        if s.rangeOfString(\".\") != nil {\n\
    \           ~ ^~~~~~~~~~~~~\n/tmp/tmp07bekkgd.swift:26:17: error: no exact matches\
    \ in call to initializer \n            i = Int(c) - Int(s.rangeOfString(\".\"\
    )!.startIndex)\n                ^\n/tmp/tmp07bekkgd.swift:26:17: note: found candidate\
    \ with type '(Float16) -> Int'\n            i = Int(c) - Int(s.rangeOfString(\"\
    .\")!.startIndex)\n                ^\n/tmp/tmp07bekkgd.swift:26:17: note: found\
    \ candidate with type '(Float) -> Int'\n            i = Int(c) - Int(s.rangeOfString(\"\
    .\")!.startIndex)\n                ^\n/tmp/tmp07bekkgd.swift:26:17: note: found\
    \ candidate with type '(Double) -> Int'\n            i = Int(c) - Int(s.rangeOfString(\"\
    .\")!.startIndex)\n                ^\n/tmp/tmp07bekkgd.swift:26:17: note: found\
    \ candidate with type '(Float80) -> Int'\n            i = Int(c) - Int(s.rangeOfString(\"\
    .\")!.startIndex)\n                ^\n/tmp/tmp07bekkgd.swift:26:17: note: found\
    \ candidate with type '(Builtin.Int64) -> Int'\n            i = Int(c) - Int(s.rangeOfString(\"\
    .\")!.startIndex)\n                ^\n/tmp/tmp07bekkgd.swift:26:17: note: found\
    \ candidate with type '(Builtin.Word) -> Int'\n            i = Int(c) - Int(s.rangeOfString(\"\
    .\")!.startIndex)\n                ^\n/tmp/tmp07bekkgd.swift:26:32: error: value\
    \ of type 'String' has no member 'rangeOfString'\n            i = Int(c) - Int(s.rangeOfString(\"\
    .\")!.startIndex)\n                             ~ ^~~~~~~~~~~~~\n/tm"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\treturn StringSlice(s).sorted(by:\
    \ >).joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp4na4m39u.swift:15:9: error: cannot find 'StringSlice' in scope\n\
    \        return StringSlice(s).sorted(by: >).joined()\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n    \n    let chars = s.characters()\n    let sorted = chars.sorted\
    \ { $0.ascii < $1.ascii }\n    \n    let buffer = UnsafeMutablePointer<UniChar>.allocate(capacity:\
    \ s.characters.count)\n    defer {\n        buffer.deallocate()\n    }\n    \n\
    \    var i = 0\n    while i < s.characters.count {\n        let c = sorted[i]\n\
    \        buffer.initializeFrom(&c, count: 1)\n        sorted[i] = sorted[i + 1]\n\
    \        sorted[i + 1] = c.ascii\n        i += 1\n    }\n    \n    var string\
    \ = \"\"\n    for i in 0..<s.characters.count {\n        string += String(UnicodeScalar(buffer[i]))\n\
    \    }\n    \n    return string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpfzb6ces2.swift:19:19: error: cannot call value of non-function\
    \ type 'String'\n    let chars = s.characters()\n                  ^         ~~\n\
    \                            \n/tmp/tmpfzb6ces2.swift:22:39: error: cannot find\
    \ type 'UniChar' in scope\n    let buffer = UnsafeMutablePointer<UniChar>.allocate(capacity:\
    \ s.characters.count)\n                                      ^~~~~~~\n/tmp/tmpfzb6ces2.swift:28:17:\
    \ error: 'characters' is unavailable: Please use String directly\n    while i\
    \ < s.characters.count {\n                ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpfzb6ces2.swift:37:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    for i in 0..<s.characters.count\
    \ {\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.shuffled().shuffled().shuffled()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp3uola6ld.swift:15:36: error: cannot convert return expression of\
    \ type '[String.Element]' (aka 'Array<Character>') to return type 'String'\n \
    \   return s.shuffled().shuffled().shuffled()\n           ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    \n    return words.reduce(\"\") { current, next in\n        var\
    \ currentChar: unichar = 0\n        var nextChar: unichar = 0\n        \n    \
    \    let currentWord = current.components(separatedBy: \" \")\n        let nextWord\
    \ = next.components(separatedBy: \" \")\n        \n        currentWord.forEach\
    \ { char in\n            nextChar = nextWord.first!.unicodeScalars\n         \
    \   .filter { $0.value == char.value }\n            .first!\n            \n  \
    \          currentChar = nextChar.value - char.value\n            currentChar\
    \ = (currentChar - char.value) % 26\n            currentChar = unichar(currentChar\
    \ + char.value)\n            \n            nextChar.value = currentChar.value\n\
    \        }\n        \n        return String(currentWord) + String(nextWord)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp5qk5gnnt.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n/tmp/tmp5qk5gnnt.swift:31:27: error: cannot find 'unichar'\
    \ in scope\n            currentChar = unichar(currentChar + char.value)\n    \
    \                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var output = \"\"\n    for cStr\
    \ in s.unicodeScalars {\n        if cStr.value > 128 {\n            output +=\
    \ cStr.value.description\n        } else {\n            output += cStr.value.description\n\
    \        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: Exception
  stderr: 'tmp1dyay431/tmp1dyay431.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab919597c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab91928eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab91928e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab91928d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1dyay431                        0x000056293be0f5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002ab919783460 __libc_start_main +
    245

    6    tmp1dyay431                        0x000056293be0f239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    var i =\
    \ 0\n    for c in s.unicodeScalars {\n        if c.value > 128 {\n           \
    \ result += \" \"\n        }\n        result += String(c)\n        i += 1\n  \
    \  }\n    for char in s.unicodeScalars {\n        let index = s.unicodeScalars.index(of:\
    \ char)\n        if index < i {\n            result += String(char)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpuxhl2jsh.swift:25:38: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let index = s.unicodeScalars.index(of: char)\n\
    \                                     ^\n/tmp/tmpuxhl2jsh.swift:25:38: note: use\
    \ 'firstIndex(of:)' instead\n        let index = s.unicodeScalars.index(of: char)\n\
    \                                     ^~~~~\n                                \
    \     firstIndex\n/tmp/tmpuxhl2jsh.swift:26:18: error: binary operator '<' cannot\
    \ be applied to operands of type 'String.UnicodeScalarView.Index?' (aka 'Optional<String.Index>')\
    \ and 'Int'\n        if index < i {\n           ~~~~~ ^ ~\n/tmp/tmpuxhl2jsh.swift:26:18:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if index < i {\n                 ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var a = s.characters\n    var\
    \ r = \"\"\n    var t = \"\"\n    a.forEach {\n        switch $0 {\n        case\
    \ \" \":\n            r +=  $0\n        case \" \":\n            t = $0\n    \
    \    case \" \" :\n            if $0 < t {\n                r += $0\n        \
    \    }\n            else {\n                r += $0\n            }\n        case\
    \ \" \" :\n            t = $0\n        case \" \" :\n            if $0 > t {\n\
    \                r += $0\n            }\n            else {\n                r\
    \ += $0\n            }\n        default :\n            r += $0\n        }\n  \
    \  }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmptu8wl6rh.swift:15:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    var a = s.characters\n              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmptu8wl6rh.swift:21:19: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \            r +=  $0\n                  ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = ''\n    for ch in\
    \ s.characters {\n        let asciiVal = Int(ch)\n        if asciiVal < 97 ||\
    \ asciiVal > 122 {\n            let num = Int(asciiVal)\n            let charVal\
    \ = String(UnicodeScalar(Int(asciiVal)))\n            var newCharVal = charVal\n\
    \            if num < 26 {\n                newCharVal = \"\\(num )\"\n      \
    \      }\n            if num < 53 {\n                newCharVal = \"\\(num )\"\
    \n            }\n            if num < 58 {\n                newCharVal = \"\\\
    (num )\"\n            }\n            if num < 65 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 90 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 96 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 123 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 127 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 161 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 177 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 190 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 203 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 207 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 221 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 223 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 226 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 230 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 234 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 237 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 241 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 245 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 247 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 251 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 253 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 256 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 258 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 262 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 265 {\n                newCharVal\
    \ = \"\\(num )\"\n            }\n            if num < 26\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpedrunvbr.swift:15:18: error: single-quoted string literal found,\
    \ use '\"'\n    var result = ''\n                 ^~\n                 \"\"\n\
    /tmp/tmpedrunvbr.swift:106:24: error: expected '{' after 'if' condition\n    \
    \        if num < 26\n                       ^\n/tmp/tmpedrunvbr.swift:128:116:\
    \ error: expected '}' at end of brace statement\nassert(anti_shuffle(s: \"Hi.\
    \ My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot How\
    \ aer ?ouy\")\n                                                              \
    \                                                     ^\n/tmp/tmpedrunvbr.swift:16:28:\
    \ note: to match this opening '{'\n    for ch in s.characters {\n            \
    \               ^\n/tmp/tmpedrunvbr.swift:128:116: error: expected '}' at end\
    \ of brace statement\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How\
    \ are you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")\n            \
    \                                                                            \
    \                           ^\n/tmp/tmpedrunvbr.swift:14:40: note: to match this\
    \ opening '{'\nfunc anti_shuffle(s: String) -> String {\n                    \
    \                   ^\n/tmp/tmpedrunvbr.swift:16:17: error: 'characters' is unavailable:\
    \ Please use String directly\n    for ch in s.characters {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpedrunvbr.swift:17:24:\
    \ error: no exact matches in call to initializer \n        let asciiVal = Int(ch)\n\
    \                       ^\nSwift.Int:7:12: note: candidate expects value of type\
    \ 'Float16' for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n\
    \           ^\nSwift.Int:10:12: note: candidate expects value of type 'Float'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float)\n     \
    \      ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Double)\n        \
    \   ^\nSwift.Int:14:12: note: candidate expects value of ty"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    for word\
    \ in s.split(separator: \" \") {\n        var i = 0\n        for c in word {\n\
    \            result.append(String(UnicodeScalar(c).value))\n            if i ==\
    \ 0 {\n                i = 2\n            }\n            i += 1\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpb10cnneu.swift:19:34: error: no exact matches in call to initializer\
    \ \n            result.append(String(UnicodeScalar(c).value))\n              \
    \                   ^\nSwift.Unicode.Scalar:7:23: note: candidate expects value\
    \ of type 'UInt8' for parameter #1 (got 'Character')\n    @inlinable public init(_\
    \ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23: note: candidate\
    \ expects value of type 'Unicode.Scalar' for parameter #1 (got 'Character')\n\
    \    @inlinable public init(_ v: Unicode.Scalar)\n                      ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var ordered = s\n    var i = 0\n\
    \    while i < ordered.count {\n        if let j = ordered.index(of: ordered[i],\
    \ offsetBy: 1) {\n            var temp = ordered[i]\n            ordered[i] =\
    \ ordered[j]\n            ordered[j] = temp\n        }\n        i += 1\n    }\n\
    \    return ordered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpscpzi208.swift:18:60: error: extra argument 'offsetBy' in call\n\
    \        if let j = ordered.index(of: ordered[i], offsetBy: 1) {\n           \
    \                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmpscpzi208.swift:19:24:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            var temp = ordered[i]\n           \
    \            ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpscpzi208.swift:20:20: error: cannot assign through subscript:\
    \ subscript is get-only\n            ordered[i] = ordered[j]\n            ~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var newStr = \"\"\n    for c in\
    \ s.characters {\n        switch c {\n        case 'a':\n            newStr +=\
    \ \"z\"\n        case 'b':\n            newStr += \"y\"\n        case 'c':\n \
    \           newStr += \"x\"\n        case 'd':\n            newStr += \"w\"\n\
    \        case 'e':\n            newStr += \"v\"\n        case 'f':\n         \
    \   newStr += \"u\"\n        case 'g':\n            newStr += \"t\"\n        case\
    \ 'h':\n            newStr += \"s\"\n        case 'i':\n            newStr +=\
    \ \"q\"\n        case 'j':\n            newStr += \"p\"\n        case 'k':\n \
    \           newStr += \"o\"\n        case 'l':\n            newStr += \"n\"\n\
    \        case 'm':\n            newStr += \"m\"\n        case 'n':\n         \
    \   newStr += \"l\"\n        case 'o':\n            newStr += \"k\"\n        case\
    \ 'p':\n            newStr += \"j\"\n        case 'q':\n            newStr +=\
    \ \"i\"\n        case 'r':\n            newStr += \"h\"\n        case 's':\n \
    \           newStr += \"g\"\n        case 't':\n            newStr += \"f\"\n\
    \        case 'u':\n            newStr += \"e\"\n        case 'v':\n         \
    \   newStr += \"d\"\n        case 'w':\n            newStr += \"r\"\n        case\
    \ 'x':\n            newStr += \"m\"\n        case 'y':\n            newStr +=\
    \ \"n\"\n        case 'z':\n            newStr += \"o\"\n        }\n    }\n  \
    \  return newStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmppjhtw8px.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmppjhtw8px.swift:20:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmppjhtw8px.swift:22:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'c':\n             ^~~\n      \
    \       \"c\"\n/tmp/tmppjhtw8px.swift:24:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'd':\n             ^~~\n             \"d\"\n/tmp/tmppjhtw8px.swift:26:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'e':\n   \
    \          ^~~\n             \"e\"\n/tmp/tmppjhtw8px.swift:28:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'f':\n             ^~~\n      \
    \       \"f\"\n/tmp/tmppjhtw8px.swift:30:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'g':\n             ^~~\n             \"g\"\n/tmp/tmppjhtw8px.swift:32:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'h':\n   \
    \          ^~~\n             \"h\"\n/tmp/tmppjhtw8px.swift:34:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'i':\n             ^~~\n      \
    \       \"i\"\n/tmp/tmppjhtw8px.swift:36:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'j':\n             ^~~\n             \"j\"\n/tmp/tmppjhtw8px.swift:38:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'k':\n   \
    \          ^~~\n             \"k\"\n/tmp/tmppjhtw8px.swift:40:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'l':\n             ^~~\n      \
    \       \"l\"\n/tmp/tmppjhtw8px.swift:42:14: error: single-quoted string literal\
    \ found, use '\"'\n        case 'm':\n             ^~~\n             \"m\"\n/tmp/tmppjhtw8px.swift:44:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'n':\n   \
    \          ^~~\n             \"n\"\n/tmp/tmppjhtw8px.swift:46:14: error: single-quoted\
    \ string literal found, use '\"'\n        case 'o':\n             ^~~\n      \
    \       \"o\"\n/tmp/tmppjhtw8px.swift:48:14: error: single-quoted st"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    var newString = \"\"\n    for word in words {\n        let key = word.unicodeScalars.sorted()\n\
    \        newString += String(key: key)\n    }\n    return newString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpod5t2cjv.swift:15:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.split(\" \").map({\n\
    \        String($0.asciiValue)\n    }).sort()\n        .joinWithSeparator(\"\"\
    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp6a_7shhj.swift:15:14: error: no exact matches in call to instance\
    \ method 'split'\n    return s.split(\" \").map({\n             ^\n/tmp/tmp6a_7shhj.swift:15:14:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n    return s.split(\"\
    \ \").map({\n             ^\n/tmp/tmp6a_7shhj.swift:15:14: note: found candidate\
    \ with type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character,\
    \ Int, Bool) -> Array<Substring>')\n    return s.split(\" \").map({\n        \
    \     ^\n/tmp/tmp6a_7shhj.swift:18:10: error: value of tuple type '()' has no\
    \ member 'joinWithSeparator'\n        .joinWithSeparator(\"\")\n         ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp6a_7shhj.swift:16:19: error: reference to member 'asciiValue' cannot be\
    \ resolved without a contextual type\n        String($0.asciiValue)\n        \
    \          ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: -4
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.split(separator:\
    \ \" \")\n    let sortedWords = words.sorted(by: { (word1, word2) -> Bool in\n\
    \        return word1 < word2\n    })\n    return sortedWords.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: Exception
  stderr: 'tmpewgpduk7/tmpewgpduk7.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6315422c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6315119b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6315119988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63151187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpewgpduk7                        0x000055944c836797 <unavailable> + 6039

    5    libc.so.6                          0x00002b631560e460 __libc_start_main +
    245

    6    tmpewgpduk7                        0x000055944c8362e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_s = \"\"\n    for _, b\
    \ in s.characters {\n        let c = (b as NSString).unicodeScalars.first!.value\
    \ - UInt16(97)\n        if c != 0 && c != 1 {\n            new_s = new_s.appending(c)\n\
    \        } else {\n            new_s = new_s.appending(b)\n        }\n    }\n\
    \    return new_s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpze60orw2.swift:16:10: error: expected 'in' after for-each pattern\n\
    \    for _, b in s.characters {\n         ^\n/tmp/tmpze60orw2.swift:16:10: error:\
    \ expected Sequence expression for for-each loop\n    for _, b in s.characters\
    \ {\n         ^\n/tmp/tmpze60orw2.swift:17:18: error: cannot find 'b' in scope\n\
    \        let c = (b as NSString).unicodeScalars.first!.value - UInt16(97)\n  \
    \               ^\n/tmp/tmpze60orw2.swift:17:23: error: cannot find type 'NSString'\
    \ in scope\n        let c = (b as NSString).unicodeScalars.first!.value - UInt16(97)\n\
    \                      ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var s = String()\n    var i =\
    \ 0\n    var j = 0\n    for c in s {\n        if c == \" \" {\n            if\
    \ s.isEmpty {\n                continue\n            }\n            s.append(\"\
    \ \")\n        } else {\n            s[i] = c\n            i += 1\n        }\n\
    \    }\n    var j = 0\n    var k = 0\n    for c in s {\n        if c == \" \"\
    \ {\n            if s.isEmpty {\n                continue\n            }\n   \
    \         s[k] = \" \"\n            k += 1\n        } else {\n            s[k]\
    \ = c\n            k += 1\n        }\n    }\n    for c = \" \"; c < k; c += 1\
    \ {\n        s[k] = c\n        k += 1\n    }\n    s = s.unicodeScalars\n    return\
    \ String(s)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpp841xuu7.swift:43:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for c = \" \"; c < k; c += 1 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpp841xuu7.swift:25:14: error: cannot assign through subscript: subscript\
    \ is get-only\n            s[i] = c\n            ~^~~\n/tmp/tmpp841xuu7.swift:29:9:\
    \ error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpp841xuu7.swift:17:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpp841xuu7.swift:36:14:\
    \ error: cannot assign through subscript: subscript is get-only\n            s[k]\
    \ = \" \"\n            ~^~~\n/tmp/tmpp841xuu7.swift:39:14: error: cannot assign\
    \ through subscript: subscript is get-only\n            s[k] = c\n           \
    \ ~^~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.split(separator:\
    \ \" \")\n    var result = \"\"\n    for word in words {\n        for c in word\
    \ {\n            if c.isUpper {\n                if let index = alphanumerics.index(of:\
    \ c) {\n                    result = result + alphanumerics[index + 1]\n     \
    \           }\n            } else {\n                if let index = alphanumerics.index(of:\
    \ c) {\n                    result = result + alphanumerics[index]\n         \
    \       }\n            }\n        }\n        result = result + \" \"\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3br_ui_.swift:19:18: error: value of type 'Character' has no member\
    \ 'isUpper'\n            if c.isUpper {\n               ~ ^~~~~~~\n/tmp/tmpr3br_ui_.swift:20:32:\
    \ error: cannot find 'alphanumerics' in scope\n                if let index =\
    \ alphanumerics.index(of: c) {\n                               ^~~~~~~~~~~~~\n\
    /tmp/tmpr3br_ui_.swift:21:39: error: cannot find 'alphanumerics' in scope\n  \
    \                  result = result + alphanumerics[index + 1]\n              \
    \                        ^~~~~~~~~~~~~\n/tmp/tmpr3br_ui_.swift:24:32: error: cannot\
    \ find 'alphanumerics' in scope\n                if let index = alphanumerics.index(of:\
    \ c) {\n                               ^~~~~~~~~~~~~\n/tmp/tmpr3br_ui_.swift:25:39:\
    \ error: cannot find 'alphanumerics' in scope\n                    result = result\
    \ + alphanumerics[index]\n                                      ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var newS = \"\"\n    for i in\
    \ 0..<s.count {\n        let j = i\n        let char = s[i]\n        let c = s[(j\
    \ + 1) % s.count]\n        let c2 = s[(j + 2) % s.count]\n\n        if char.asciiValue\
    \ < c.asciiValue {\n            newS += c\n        } else {\n            newS\
    \ += char\n        }\n    }\n    return newS\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmplis2l6p4.swift:18:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = s[i]\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplis2l6p4.swift:19:17: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let c = s[(j + 1) % s.count]\n                ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplis2l6p4.swift:20:18:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let c2 = s[(j + 2) % s.count]\n       \
    \          ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplis2l6p4.swift:22:28: error: binary operator\
    \ '<' cannot be applied to two 'UInt8?' operands\n        if char.asciiValue <\
    \ c.asciiValue {\n           ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~\n/tmp/tmplis2l6p4.swift:22:28:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (UInt8, UInt8)\n        if char.asciiValue < c.asciiValue {\n              \
    \             ^\n/tmp/tmplis2l6p4.swift:23:21: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            newS += c\n\
    \                    ^\n/tmp/tmplis2l6p4.swift:25:21: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            newS +=\
    \ char\n                    ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    -\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    .\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    /\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    \\\\\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    ?\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    !\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    (\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    )\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    \\\\\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    ,\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    \\\"\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    \\\"\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    [\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    ]\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    {\", withString: \"\") }\n    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    }\", withString: \"\") }\n    let words = words.map { String($0).lowercased\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp_b52f3hy.swift:55:116: error: expected '}' at end of brace statement\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")\n                                 \
    \                                                                            \
    \      ^\n/tmp/tmp_b52f3hy.swift:14:40: note: to match this opening '{'\nfunc\
    \ anti_shuffle(s: String) -> String {\n                                      \
    \ ^\n/tmp/tmp_b52f3hy.swift:15:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_b52f3hy.swift:16:53:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n\
    \    let words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    \ \", withString: \"\") }\n                            ~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_b52f3hy.swift:17:53: error: value\
    \ of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n    let\
    \ words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    -\", withString: \"\") }\n                            ~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_b52f3hy.swift:18:53: error: value\
    \ of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n    let\
    \ words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    .\", withString: \"\") }\n                            ~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_b52f3hy.swift:19:53: error: value\
    \ of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n    let\
    \ words = words.map { String($0).lowercased().stringByReplacingOccurrencesOfString(\"\
    /\", withString: \"\") }\n                            ~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_b52f3hy.swift:20:53: error: value\
    \ of type 'String' has no member 'stringByReplacingOccurrencesOfString'\n    let\
    \ words = words.ma"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n\n    for i\
    \ in 0..<s.characters.count {\n        result += String(s.characters[i]).lowercased()\n\
    \        if i != s.characters.count-1 {\n            result += \" \"\n       \
    \ }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpgvb9frx4.swift:17:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<s.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpgvb9frx4.swift:18:26:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        result += String(s.characters[i]).lowercased()\n\
    \                         ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgvb9frx4.swift:18:28: error: 'characters'\
    \ is unavailable: Please use String directly\n        result += String(s.characters[i]).lowercased()\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgvb9frx4.swift:19:19: error: 'characters' is unavailable:\
    \ Please use String directly\n        if i != s.characters.count-1 {\n       \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    var result = \"\"\n\n    for word in words {\n        result += String(word.utf16.count)\n\
    \    }\n    \n    for word in words {\n        let word = String(word.utf16)\n\
    \        result = word.replacingOccurrences(of: String(word.utf16.count), with:\
    \ result)\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp9hhokdjy.swift:15:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n    var chars = [Character]()\n    var i = 0\n    while i < s.characters.count\
    \ {\n        if s.characters[i] != ' ' {\n            chars.append(s.characters[i])\n\
    \            i += 1\n            continue\n        }\n        i += 1\n       \
    \ while i < s.characters.count {\n            if s.characters[i] == ' ' {\n  \
    \              chars.append(s.characters[i])\n                i += 1\n       \
    \         continue\n            }\n            chars.append(s.characters[i])\n\
    \            i += 1\n        }\n    }\n    return String(chars)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp9kzin_cb.swift:21:31: error: single-quoted string literal found,\
    \ use '\"'\n        if s.characters[i] != ' ' {\n                            \
    \  ^~~\n                              \" \"\n/tmp/tmp9kzin_cb.swift:28:35: error:\
    \ single-quoted string literal found, use '\"'\n            if s.characters[i]\
    \ == ' ' {\n                                  ^~~\n                          \
    \        \" \"\n/tmp/tmp9kzin_cb.swift:20:17: error: 'characters' is unavailable:\
    \ Please use String directly\n    while i < s.characters.count {\n           \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9kzin_cb.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s.characters[i] != ' ' {\n         \
    \  ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp9kzin_cb.swift:21:14: error: 'characters' is unavailable:\
    \ Please use String directly\n        if s.characters[i] != ' ' {\n          \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp9kzin_cb.swift:22:26:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            chars.append(s.characters[i])\n   \
    \                      ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp9kzin_cb.swift:22:28: error: 'characters'\
    \ is unavailable: Please use String directly\n            chars.append(s.characters[i])\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9kzin_cb.swift:27:21: error: 'characters' is unavailable:\
    \ Please use String directl"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.shuffled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpnkyjdbv8.swift:15:14: error: cannot convert return expression of\
    \ type '() -> [String.Element]' (aka '() -> Array<Character>') to return type\
    \ 'String'\n    return s.shuffled\n           ~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.split(separator:\
    \ \" \")\n    return words.reduce(\"\", combine: {\n        if $0.hasPrefix($1)\
    \ {\n            return $1.unicodeScalars.reduce(\"\", combine: {\n          \
    \      if $0.hasPrefix($1) {\n                    return $0 + $1 + $2\n      \
    \          } else {\n                    return $0 + $1\n                }\n \
    \           })\n        } else {\n            return $0 + $1\n        }\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp3j70efz2.swift:16:24: error: extraneous argument label 'combine:'\
    \ in call\n    return words.reduce(\"\", combine: {\n                       ^\
    \    ~~~~~~~~~\n                            \n/tmp/tmp3j70efz2.swift:18:44: error:\
    \ extraneous argument label 'combine:' in call\n            return $1.unicodeScalars.reduce(\"\
    \", combine: {\n                                           ^    ~~~~~~~~~\n  \
    \                                              \n/tmp/tmp3j70efz2.swift:18:58:\
    \ error: contextual closure type '(String, Substring.UnicodeScalarView.Element)\
    \ throws -> String' (aka '(String, Unicode.Scalar) throws -> String') expects\
    \ 2 arguments, but 3 were used in closure body\n            return $1.unicodeScalars.reduce(\"\
    \", combine: {\n                                                         ^\n/tmp/tmp3j70efz2.swift:19:20:\
    \ note: anonymous closure parameter '$0' is used here\n                if $0.hasPrefix($1)\
    \ {\n                   ^\n/tmp/tmp3j70efz2.swift:19:33: note: anonymous closure\
    \ parameter '$1' is used here\n                if $0.hasPrefix($1) {\n       \
    \                         ^\n/tmp/tmp3j70efz2.swift:20:28: note: anonymous closure\
    \ parameter '$0' is used here\n                    return $0 + $1 + $2\n     \
    \                      ^\n/tmp/tmp3j70efz2.swift:20:33: note: anonymous closure\
    \ parameter '$1' is used here\n                    return $0 + $1 + $2\n     \
    \                           ^\n/tmp/tmp3j70efz2.swift:20:38: note: anonymous closure\
    \ parameter '$2' is used here\n                    return $0 + $1 + $2\n     \
    \                                ^\n/tmp/tmp3j70efz2.swift:22:28: note: anonymous\
    \ closure parameter '$0' is used here\n                    return $0 + $1\n  \
    \                         ^\n/tmp/tmp3j70efz2.swift:22:33: note: anonymous closure\
    \ parameter '$1' is used here\n                    return $0 + $1\n          \
    \                      ^\n/tmp/tmp3j70efz2.swift:19:20: error: instance method\
    \ 'hasPrefix' requires that 'Substring.UnicodeScalarView.Element' (aka 'Unicode.Scalar')\
    \ conform to 'StringProtocol'\n                if $0.hasPrefix($1) {"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // TODO: Your code here\n    var\
    \ result = \"\"\n    for word in s.split(\" \") {\n        for letter in word\
    \ {\n            if letter.unicodeScalars.isEmpty == true {\n                result\
    \ += letter\n            }\n        }\n        if result == \"\" {\n         \
    \   result.append(word)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp2e1ykqcp.swift:17:19: error: no exact matches in call to instance\
    \ method 'split'\n    for word in s.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s.isEmpty() {\n        return\
    \ s\n    }\n\n    var output = \"\"\n    var previousAsciiValue: Int = 0\n   \
    \ var previousWord: String = \" \"\n\n    for index in 0..<s.characters.count\
    \ {\n        character: String.Character\n        character: s.characters[index]\n\
    \n        if character == \" \" {\n            output += \"  \"\n            continue\n\
    \        }\n\n        let asciiValue: Int = character.unicodeScalars.first!.value.intValue\n\
    \n        if previousAsciiValue > asciiValue {\n            output += previousWord\n\
    \            previousWord = character\n        } else {\n            previousWord\
    \ = character\n        }\n\n        previousAsciiValue = asciiValue\n    }\n\n\
    \    output += previousWord\n\n    return output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp646dzdfc.swift:24:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        character: String.Character\n                 ^\n\
    \                 ;\n/tmp/tmp646dzdfc.swift:24:18: error: expected expression\n\
    \        character: String.Character\n                 ^\n/tmp/tmp646dzdfc.swift:15:10:\
    \ error: cannot call value of non-function type 'Bool'\n    if s.isEmpty() {\n\
    \         ^      ~~\n                \n/tmp/tmp646dzdfc.swift:23:24: error: 'characters'\
    \ is unavailable: Please use String directly\n    for index in 0..<s.characters.count\
    \ {\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp646dzdfc.swift:24:9: error: cannot find 'character'\
    \ in scope\n        character: String.Character\n        ^~~~~~~~~\n/tmp/tmp646dzdfc.swift:27:12:\
    \ error: cannot find 'character' in scope\n        if character == \" \" {\n \
    \          ^~~~~~~~~\n/tmp/tmp646dzdfc.swift:32:31: error: cannot find 'character'\
    \ in scope\n        let asciiValue: Int = character.unicodeScalars.first!.value.intValue\n\
    \                              ^~~~~~~~~\n/tmp/tmp646dzdfc.swift:36:28: error:\
    \ cannot find 'character' in scope\n            previousWord = character\n   \
    \                        ^~~~~~~~~\n/tmp/tmp646dzdfc.swift:38:28: error: cannot\
    \ find 'character' in scope\n            previousWord = character\n          \
    \                 ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014140
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    for c in\
    \ s.characters {\n        let ord = Int(c)\n        if ord >= 97 { // A\n    \
    \        let ord1 = Int(c - 32)\n            if ord1 < 97 { // a\n           \
    \     result += String(ord1 - 97)\n            } else { // A\n               \
    \ result += String(ord1 - 65)\n            }\n        } else if ord >= 65 { //\
    \ a\n            let ord1 = Int(c - 32)\n            if ord1 < 65 { // A\n   \
    \             result += String(ord1 - 97)\n            } else { // a\n       \
    \         result += String(ord1 - 65)\n            }\n        } else { // Not\
    \ A or a\n            result += String(ord - 32)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpttrxg5x9.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpttrxg5x9.swift:17:19:\
    \ error: no exact matches in call to initializer \n        let ord = Int(c)\n\
    \                  ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n   \
    \        ^\nSwift.Int:10:12: note: candidate expects value of type 'Float' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Float)\n         \
    \  ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Double)\n           ^\nSwift.Int:14:12:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate\
    \ expects value of type 'Builtin.Int64' for parameter #1 (got 'Character')\n \
    \   public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12: note:\
    \ candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'Character')\n\
    \    @inlinable public init?(_ description: String)\n                      ^\n\
    /tmp/tmpttrxg5x9.swift:19:28: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n            let ord1 = Int(c - 32)\n      \
    \                     ^\n/tmp/tmpttrxg5x9.swift:26:28: error: cannot convert value\
    \ of type 'Character' to expected argument type 'Int'\n            let ord1 =\
    \ Int(c - 32)\n                           ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let wordArray = s.characters\n\
    \    var newWord = \"\"\n    for character in wordArray {\n        let asciiValue\
    \ = UInt8(character)\n        if asciiValue < 128 {\n            newWord.append(character)\n\
    \        } else {\n            let newValue = asciiValue - 128 + 64\n        \
    \    newWord.append(UnicodeScalar(newValue).value)\n        }\n    }\n    return\
    \ newWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpl3b31iel.swift:15:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    let wordArray = s.characters\n                    \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpl3b31iel.swift:18:26:\
    \ error: no exact matches in call to initializer \n        let asciiValue = UInt8(character)\n\
    \                         ^\nSwift.UInt8:7:12: note: candidate expects value of\
    \ type 'Float16' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float16)\n           ^\nSwift.UInt8:10:12: note: candidate expects value of\
    \ type 'Float' for parameter #1 (got 'Character')\n    public init(_ source: Float)\n\
    \           ^\nSwift.UInt8:12:12: note: candidate expects value of type 'Double'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Double)\n    \
    \       ^\nSwift.UInt8:14:12: note: candidate expects value of type 'Float80'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float80)\n   \
    \        ^\nSwift.UInt8:28:12: note: candidate expects value of type 'Builtin.Int8'\
    \ for parameter #1 (got 'Character')\n    public init(_ _value: Builtin.Int8)\n\
    \           ^\nSwift.FixedWidthInteger:3:23: note: candidate expects value of\
    \ type 'String' for parameter #1 (got 'Character')\n    @inlinable public init?(_\
    \ description: String)\n                      ^\n/tmp/tmpl3b31iel.swift:23:21:\
    \ error: no exact matches in call to instance method 'append'\n            newWord.append(UnicodeScalar(newValue).value)\n\
    \                    ^\n/tmp/tmpl3b31iel.swift:23:21: note: found candidate with\
    \ type '(String) -> ()'\n            newWord.append(UnicodeScalar(newValue).value)\n\
    \                    ^\n/tmp/tmpl3b31iel.swift:23:21: note: found candidate with\
    \ type '(Character) -> ()'\n            newWord.append(UnicodeScalar(newValue).value)\n\
    \                    ^\n/tmp/tmpl3b31iel.swift:23:21: note: found candidate with\
    \ type '(__owned String.Element) -> ()' (aka '(__owned Character) -> ()')\n  \
    \          newWord.append(UnicodeScalar(newValue).val"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let wordArray = s.components(separatedBy:\
    \ \" \")\n    var result = \"\"\n    for word in wordArray {\n        let sortedWord\
    \ = wordArray\n            .sort(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n            .sorted(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n        let sortedString = String(describing: sortedWord)\n        result\
    \ += sortedString\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpir26g7kc.swift:15:23: error: value of type 'String' has no member\
    \ 'components'\n    let wordArray = s.components(separatedBy: \" \")\n       \
    \             ~ ^~~~~~~~~~\n/tmp/tmpir26g7kc.swift:19:43: error: cannot find 'NSComparisonResult'\
    \ in scope\n            .sort(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n                                          ^~~~~~~~~~~~~~~~~~\n/tmp/tmpir26g7kc.swift:20:45:\
    \ error: cannot find 'NSComparisonResult' in scope\n            .sorted(by: {\
    \ $0.compare($1) == NSComparisonResult.OrderedAscending })\n                 \
    \                           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    let result = \"\"\n    for word in words {\n        let charArray\
    \ = word.unicodeScalars\n        var charArraySorted = charArray\n        let\
    \ sortedArray = charArraySorted.sorted()\n        let charArrayString = sortedArray.reduce(\"\
    \", { $0 + String($1) })\n        result += String(charArrayString)\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpsgiu1br4.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var new_string = \"\"\n    var\
    \ new_string2 = \"\"\n    for char in s {\n        switch char {\n        case\
    \ \" \":\n            new_string2 = new_string2 + char\n        case \" \":\n\
    \            new_string2 = new_string2 + char + char\n        default:\n     \
    \       new_string = new_string + char\n        }\n    }\n    return new_string2\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmprrh5ic43.swift:20:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            new_string2 = new_string2 +\
    \ char\n                                        ^\n/tmp/tmprrh5ic43.swift:22:39:\
    \ error: binary operator '+' cannot be applied to operands of type 'String' and\
    \ 'Character'\n            new_string2 = new_string2 + char + char\n         \
    \                 ~~~~~~~~~~~ ^ ~~~~\n/tmp/tmprrh5ic43.swift:24:39: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       new_string = new_string + char\n                                     \
    \ ^\n/tmp/tmprrh5ic43.swift:21:14: warning: literal value is already handled by\
    \ previous pattern; consider removing it\n        case \" \":\n             ^~~\n\
    /tmp/tmprrh5ic43.swift:19:14: note: first occurrence of identical literal pattern\
    \ is here\n        case \" \":\n             ^~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let wordsAndSpaces = s.components(separatedBy:\
    \ \" \").map(String.init)\n    let wordsWithAsciiValues = wordsAndSpaces.map {\n\
    \        String($0.characters.map {\n            Int($0)\n        })\n    }\n\
    \    return wordsWithAsciiValues.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpsk_fsb5y.swift:15:28: error: value of type 'String' has no member\
    \ 'components'\n    let wordsAndSpaces = s.components(separatedBy: \" \").map(String.init)\n\
    \                         ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words: [String] = s.split(separator:\
    \ \" \").map{String($0)}\n    words.sort{$0.localizedStandardCompare($1) == .orderedAscending}\n\
    \    let result = \"\"\n    for word in words {\n        if word.characters.count\
    \ == 0 {\n            result += \"_\"\n        } else {\n            let firstLetter\
    \ = word.startIndex.advancedBy(0)\n            let lastLetter = word.endIndex.advancedBy(-1)\n\
    \            result += String(word[firstLetter..<lastLetter])\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpl434gx0k.swift:16:19: error: value of type 'String' has no member\
    \ 'localizedStandardCompare'\n    words.sort{$0.localizedStandardCompare($1) ==\
    \ .orderedAscending}\n               ~~ ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpl434gx0k.swift:19:17:\
    \ error: 'characters' is unavailable: Please use String directly\n        if word.characters.count\
    \ == 0 {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpl434gx0k.swift:20:20: error: left side of mutating operator\
    \ isn't mutable: 'result' is a 'let' constant\n            result += \"_\"\n \
    \           ~~~~~~ ^\n/tmp/tmpl434gx0k.swift:17:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let result = \"\"\n    ^~~\n    var\n/tmp/tmpl434gx0k.swift:22:47:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n           \
    \ let firstLetter = word.startIndex.advancedBy(0)\n                          \
    \    ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpl434gx0k.swift:23:44: error: value of\
    \ type 'String.Index' has no member 'advancedBy'\n            let lastLetter =\
    \ word.endIndex.advancedBy(-1)\n                             ~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n\n    for c\
    \ in s.characters {\n        if c == \" \" {\n            result += \" \"\n  \
    \          continue\n        }\n        if c > 47 && c < 58 {\n            result\
    \ += String(c-64)\n            continue\n        }\n        result += String(c)\n\
    \    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmphn9_7nqu.swift:17:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmphn9_7nqu.swift:22:24:\
    \ error: binary operator '<' cannot be applied to operands of type 'Character'\
    \ and 'Int'\n        if c > 47 && c < 58 {\n                     ~ ^ ~~\n/tmp/tmphn9_7nqu.swift:22:24:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Character, Character), (Int, Int)\n        if c > 47 && c < 58 {\n        \
    \               ^\n/tmp/tmphn9_7nqu.swift:22:12: error: cannot convert value of\
    \ type 'Character' to expected argument type 'Int'\n        if c > 47 && c < 58\
    \ {\n           ^\n/tmp/tmphn9_7nqu.swift:23:30: error: cannot convert value of\
    \ type 'Character' to expected argument type 'Int'\n            result += String(c-64)\n\
    \                             ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: -4
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let wordList = s.split(separator:\
    \ \" \")\n        .sorted()\n        .map { String($0) }\n    return wordList.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: Exception
  stderr: 'tmpwkqjpu12/tmpwkqjpu12.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace1081fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace10516b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace10516988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace105157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwkqjpu12                        0x000055cb59ec3837 <unavailable> + 6199

    5    libc.so.6                          0x00002ace10a0b460 __libc_start_main +
    245

    6    tmpwkqjpu12                        0x000055cb59ec3389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var t = \"\"\n    var i = 0\n\
    \    for c in s {\n        let d = String(c).unicodeScalars\n        i = i + d.count\n\
    \        if i % 2 == 0 {\n            t += String(d[d.count - 1])\n        } else\
    \ {\n            t += String(d[d.count - 2])\n        }\n    }\n    return t\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpoli38b64.swift:21:26: error: no exact matches in call to subscript\
    \ \n            t += String(d[d.count - 1])\n                         ^\nSwift.String.UnicodeScalarView:7:23:\
    \ note: candidate expects value of type 'String.UnicodeScalarView.Index' (aka\
    \ 'String.Index') for parameter #1 (got 'Int')\n    @inlinable public subscript(position:\
    \ String.UnicodeScalarView.Index) -> Unicode.Scalar { get }\n                \
    \      ^\nSwift.String.UnicodeScalarView:4:12: note: candidate expects value of\
    \ type 'Range<String.UnicodeScalarView.Index>' (aka 'Range<String.Index>') for\
    \ parameter #1 (got 'Int')\n    public subscript(r: Range<String.UnicodeScalarView.Index>)\
    \ -> String.UnicodeScalarView.SubSequence { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpoli38b64.swift:23:26:\
    \ error: no exact matches in call to subscript \n            t += String(d[d.count\
    \ - 2])\n                         ^\nSwift.String.UnicodeScalarView:7:23: note:\
    \ candidate expects value of type 'String.UnicodeScalarView.Index' (aka 'String.Index')\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(position: String.UnicodeScalarView.Index)\
    \ -> Unicode.Scalar { get }\n                      ^\nSwift.String.UnicodeScalarView:4:12:\
    \ note: candidate expects value of type 'Range<String.UnicodeScalarView.Index>'\
    \ (aka 'Range<String.Index>') for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView.SubSequence\
    \ { get }\n           ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.characters.sorted(by:\
    \ >).reduce(\"\", combine: +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpjsnx5uyj.swift:15:45: error: extraneous argument label 'combine:'\
    \ in call\n    return s.characters.sorted(by: >).reduce(\"\", combine: +)\n  \
    \                                          ^    ~~~~~~~~~\n                  \
    \                               \n/tmp/tmpjsnx5uyj.swift:15:59: error: binary\
    \ operator '+' cannot be applied to operands of type 'String' and 'String.Element'\
    \ (aka 'Character')\n    return s.characters.sorted(by: >).reduce(\"\", combine:\
    \ +)\n                                                          ^\nSwift.RangeReplaceableCollection:5:35:\
    \ note: candidate requires that 'String.Element' (aka 'Character') conform to\
    \ 'RangeReplaceableCollection' (requirement specified as 'Other' : 'RangeReplaceableCollection')\n\
    \    @inlinable public static func + <Other>(lhs: Self, rhs: Other) -> Self where\
    \ Other : RangeReplaceableCollection, Self.Element == Other.Element\n        \
    \                          ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\tvar new_s = \"\"\n\tfor\ti := 0;\
    \ i < len(s); i++ {\n\t\tvar new_char = 0\n\t\tswitch s[i] {\n\t\tcase 'a':\n\t\
    \t\tnew_char = 'n'\n\t\tcase 'b':\n\t\t\tnew_char = 'o'\n\t\tcase 'c':\n\t\t\t\
    new_char = 'q'\n\t\tcase 'd':\n\t\t\tnew_char = 'r'\n\t\tcase 'e':\n\t\t\tnew_char\
    \ = 's'\n\t\tcase 'f':\n\t\t\tnew_char = 't'\n\t\tcase 'g':\n\t\t\tnew_char =\
    \ 'u'\n\t\tcase 'h':\n\t\t\tnew_char = 'v'\n\t\tcase 'i':\n\t\t\tnew_char = 'w'\n\
    \t\tcase 'j':\n\t\t\tnew_char = 'x'\n\t\tcase 'k':\n\t\t\tnew_char = 'y'\n\t\t\
    case 'l':\n\t\t\tnew_char = 'z'\n\t\tcase 'm':\n\t\t\tnew_char = 'A'\n\t\tcase\
    \ 'n':\n\t\t\tnew_char = 'B'\n\t\tcase 'o':\n\t\t\tnew_char = 'C'\n\t\tcase 'p':\n\
    \t\t\tnew_char = 'D'\n\t\tcase 'q':\n\t\t\tnew_char = 'E'\n\t\tcase 'r':\n\t\t\
    \tnew_char = 'F'\n\t\tcase 's':\n\t\t\tnew_char = 'G'\n\t\tcase 't':\n\t\t\tnew_char\
    \ = 'H'\n\t\tcase 'u':\n\t\t\tnew_char = 'I'\n\t\tcase 'v':\n\t\t\tnew_char =\
    \ 'J'\n\t\tcase 'w':\n\t\t\tnew_char = 'K'\n\t\tcase 'x':\n\t\t\tnew_char = 'L'\n\
    \t\tcase 'y':\n\t\t\tnew_char = 'M'\n\t\tcase 'z':\n\t\t\tnew_char = 'N'\n\t\t\
    }\n\t\tnew_s = new_s + String(new_char)\n\t}\n\treturn new_s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpqtkkw7fk.swift:16:9: error: expected type\n        for     i :=\
    \ 0; i < len(s); i++ {\n                   ^\n                    <#type#>\n/tmp/tmpqtkkw7fk.swift:16:9:\
    \ error: expected 'in' after for-each pattern\n        for     i := 0; i < len(s);\
    \ i++ {\n                   ^\n/tmp/tmpqtkkw7fk.swift:16:9: error: expected Sequence\
    \ expression for for-each loop\n        for     i := 0; i < len(s); i++ {\n  \
    \                 ^\n/tmp/tmpqtkkw7fk.swift:19:8: error: single-quoted string\
    \ literal found, use '\"'\n                case 'a':\n                     ^~~\n\
    \                     \"a\"\n/tmp/tmpqtkkw7fk.swift:20:15: error: single-quoted\
    \ string literal found, use '\"'\n                        new_char = 'n'\n   \
    \                                ^~~\n                                   \"n\"\
    \n/tmp/tmpqtkkw7fk.swift:21:8: error: single-quoted string literal found, use\
    \ '\"'\n                case 'b':\n                     ^~~\n                \
    \     \"b\"\n/tmp/tmpqtkkw7fk.swift:22:15: error: single-quoted string literal\
    \ found, use '\"'\n                        new_char = 'o'\n                  \
    \                 ^~~\n                                   \"o\"\n/tmp/tmpqtkkw7fk.swift:23:8:\
    \ error: single-quoted string literal found, use '\"'\n                case 'c':\n\
    \                     ^~~\n                     \"c\"\n/tmp/tmpqtkkw7fk.swift:24:15:\
    \ error: single-quoted string literal found, use '\"'\n                      \
    \  new_char = 'q'\n                                   ^~~\n                  \
    \                 \"q\"\n/tmp/tmpqtkkw7fk.swift:25:8: error: single-quoted string\
    \ literal found, use '\"'\n                case 'd':\n                     ^~~\n\
    \                     \"d\"\n/tmp/tmpqtkkw7fk.swift:26:15: error: single-quoted\
    \ string literal found, use '\"'\n                        new_char = 'r'\n   \
    \                                ^~~\n                                   \"r\"\
    \n/tmp/tmpqtkkw7fk.swift:27:8: error: single-quoted string literal found, use\
    \ '\"'\n                case 'e':\n                     ^~~\n                \
    \     \"e\"\n/tmp/tmpqtkkw7fk.swift:28:15: error: single-quoted s"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var buffer = [String]()\n    var\
    \ spaceIndex = 0\n    for characterIndex in 0..<s.count {\n        if Character(s.characters[characterIndex])\
    \ == \" \" {\n            spaceIndex = characterIndex\n        }\n        if Character(s.characters[characterIndex])\
    \ >= 'a' && Character(s.characters[characterIndex]) <= 'z' {\n            buffer.append(String(Character(s.characters[characterIndex])\
    \ - 'a' + 'a'))\n        } else {\n            buffer.append(String(Character(s.characters[characterIndex])\
    \ - 'A' + 'a'))\n        }\n    }\n    var result = \"\"\n    for characterIndex\
    \ in 0..<buffer.count {\n        result = result + String(Character(buffer[characterIndex])\
    \ + Character(s.characters[spaceIndex]))\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp_jhk48ol.swift:21:55: error: single-quoted string literal found,\
    \ use '\"'\n        if Character(s.characters[characterIndex]) >= 'a' && Character(s.characters[characterIndex])\
    \ <= 'z' {\n                                                      ^~~\n      \
    \                                                \"a\"\n/tmp/tmp_jhk48ol.swift:21:105:\
    \ error: single-quoted string literal found, use '\"'\n        if Character(s.characters[characterIndex])\
    \ >= 'a' && Character(s.characters[characterIndex]) <= 'z' {\n               \
    \                                                                            \
    \             ^~~\n                                                          \
    \                                              \"z\"\n/tmp/tmp_jhk48ol.swift:22:76:\
    \ error: single-quoted string literal found, use '\"'\n            buffer.append(String(Character(s.characters[characterIndex])\
    \ - 'a' + 'a'))\n                                                            \
    \               ^~~\n                                                        \
    \                   \"a\"\n/tmp/tmp_jhk48ol.swift:22:82: error: single-quoted\
    \ string literal found, use '\"'\n            buffer.append(String(Character(s.characters[characterIndex])\
    \ - 'a' + 'a'))\n                                                            \
    \                     ^~~\n                                                  \
    \                               \"a\"\n/tmp/tmp_jhk48ol.swift:24:76: error: single-quoted\
    \ string literal found, use '\"'\n            buffer.append(String(Character(s.characters[characterIndex])\
    \ - 'A' + 'a'))\n                                                            \
    \               ^~~\n                                                        \
    \                   \"A\"\n/tmp/tmp_jhk48ol.swift:24:82: error: single-quoted\
    \ string literal found, use '\"'\n            buffer.append(String(Character(s.characters[characterIndex])\
    \ - 'A' + 'a'))\n                                                            \
    \                     ^~~\n                                                  \
    \                               \"a\"\n/tmp/"
  stdout: ''
  timestamp: 1660014148
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var reversedString = s[s.startIndex..<s.endIndex].map\
    \ { String($0, radix: 10) }.reversed()\n    return reversedString.reduce(\"\"\
    ) { $0 + String($1, radix: 26) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpk4lm9st7.swift:15:61: error: initializer 'init(_:radix:uppercase:)'\
    \ requires that 'Character' conform to 'BinaryInteger'\n    var reversedString\
    \ = s[s.startIndex..<s.endIndex].map { String($0, radix: 10) }.reversed()\n  \
    \                                                          ^\nSwift.String:2:12:\
    \ note: where 'T' = 'Character'\n    public init<T>(_ value: T, radix: Int = 10,\
    \ uppercase: Bool = false) where T : BinaryInteger\n           ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if let range = s.range(of: \"\
    \ \") {\n        switch s.distance(from: s.startIndex, to: range.upperBound) {\n\
    \        case 1:\n            let index = s.distance(from: s.startIndex, to: range.upperBound)\n\
    \            let letter = s[index]\n            let swap = s[index]\n        \
    \    s[index] = s[range.upperBound]\n            s[range.upperBound] = swap\n\
    \            return String(s.dropFirst(index) + letter + s.suffix(from: range.upperBound))\n\
    \        case 2:\n            let first = s[s.startIndex..<range.upperBound]\n\
    \            let second = s[range.upperBound..<s.endIndex]\n            let index\
    \ = second.distance(from: second.startIndex, to: s.startIndex)\n            let\
    \ letter = s[index]\n            let swap = s[index]\n            s[index] = s[second.startIndex]\n\
    \            s[second.startIndex] = swap\n            return String(first + letter\
    \ + second)\n        default:\n            let first = s[s.startIndex..<range.upperBound]\n\
    \            let second = s[range.upperBound..<range.lowerBound]\n           \
    \ let third = s[range.lowerBound..<s.endIndex]\n            let index = second.distance(from:\
    \ second.startIndex, to: s.startIndex)\n            let letter = s[index]\n  \
    \          let swap = s[index]\n            s[index] = s[second.startIndex]\n\
    \            s[second.startIndex] = swap\n            return String(first + letter\
    \ + second + third)\n        }\n    } else {\n        return s\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpflz4oqf5.swift:15:22: error: value of type 'String' has no member\
    \ 'range'\n    if let range = s.range(of: \" \") {\n                   ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014143
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var ans = \"\"\n    var first\
    \ = True\n    for s in s.split(\" \") {\n        if first {\n            ans =\
    \ s\n            first = false\n        } else {\n            for (index, char)\
    \ in s.characters.enumerated() {\n                var ascii = char.asciiValue\n\
    \                if (ascii != 0) {\n                    ascii = ascii + 10\n \
    \               }\n                let c = String(UnicodeScalar(ascii))\n    \
    \            if let index = ans.characters.index(of: c) {\n                  \
    \  ans = ans.replacingCharacters(in: IndexSet(index: index), with: c)\n      \
    \          }\n            }\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp7b0bqpk3.swift:16:17: error: cannot find 'True' in scope\n    var\
    \ first = True\n                ^~~~\n/tmp/tmp7b0bqpk3.swift:17:16: error: no\
    \ exact matches in call to instance method 'split'\n    for s in s.split(\" \"\
    ) {\n               ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n    var list = s.characters()\n    let length = s.length\n    \n \
    \   // 1. split all characters in to array\n    // 2. find unique elements in\
    \ array\n    // 3. find longest common substring\n    // 4. split all elements\
    \ to array\n    // 5. sort the array (using ASCII value)\n    \n    var unique\
    \ = Array(Set(list))\n    \n    let maxLen = unique.count\n    \n    let longestCommonSub\
    \ = Array(unique.filter {\n        var count = 0\n        var substring = String()\n\
    \        for i in 0..<length {\n            if let index = unique.index(of: s[i])\
    \ {\n                if count > 1 {\n                    substring = String(unique[index])\n\
    \                }\n                count += 1\n            }\n        }\n   \
    \     return substring.isEmpty == false\n    })\n    \n    var letters = longestCommonSub\n\
    \    \n    var reversed = letters.reversed()\n    \n    var characters = Array(s)\n\
    \    \n    var output = \"\"\n    \n    \n    for i in 0..<maxLen {\n        \n\
    \        for i in 0..<characters.count {\n            \n            if characters[i]\
    \ == unique[i] {\n                characters.remove(at: i)\n            }\n  \
    \      }\n        \n        var newOutput = \"\"\n        \n        for j in 0..<characters.count\
    \ {\n            newOutput += reversed[j]\n        }\n        \n        output\
    \ = newOutput + output\n    }\n    \n    return output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpug_skkmc.swift:18:18: error: cannot call value of non-function\
    \ type 'String'\n    var list = s.characters()\n                 ^         ~~\n\
    \                           \n/tmp/tmpug_skkmc.swift:19:20: error: value of type\
    \ 'String' has no member 'length'\n    let length = s.length\n               \
    \  ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    let characters = words.map { $0.utf16.sorted(by: >).joined(separator:\
    \ \"\") }\n    return characters.joined(separator: \" \")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpcoc4s4hy.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var arr = [Character]()\n    for\
    \ char in s.characters {\n        arr[Character.asciiValue(char)] = char\n   \
    \ }\n    arr.sort()\n    let res = \"\\(arr)\"\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpigqa4uko.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpigqa4uko.swift:17:23:\
    \ error: cannot call value of non-function type 'UInt8?'\n        arr[Character.asciiValue(char)]\
    \ = char\n                      ^\n/tmp/tmpigqa4uko.swift:17:13: error: instance\
    \ member 'asciiValue' cannot be used on type 'Character'; did you mean to use\
    \ a value of this type instead?\n        arr[Character.asciiValue(char)] = char\n\
    \            ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    guard s.isEmpty == false else\
    \ { return s }\n\n    var chars = [Character]()\n    var words = s.componentsSeparatedByString(\"\
    \ \")\n    for word in words {\n        chars.append(word.lowercased())\n    }\n\
    \n    var letters: [Character] = Array(chars)\n\n    // sort the letters\n   \
    \ letters.sort(<)\n\n    // map each letter into the new string\n    var newWord\
    \ = String()\n    for letter in letters {\n        newWord += String(letter)\n\
    \    }\n\n    return newWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpz7fsku0k.swift:18:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    var words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz7fsku0k.swift:26:18:\
    \ error: missing argument label 'by:' in call\n    letters.sort(<)\n         \
    \        ^\n                 by: \n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let stringArray = s.components(separatedBy:\
    \ \" \")\n    let result = \"\"\n    for string in stringArray {\n        let\
    \ charArray = string.components(separatedBy: \"\")\n        let sortedArray =\
    \ charArray.sorted()\n        let resultCharArray = String((sortedArray))\n  \
    \      result += resultCharArray\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpht35jx57.swift:15:25: error: value of type 'String' has no member\
    \ 'components'\n    let stringArray = s.components(separatedBy: \" \")\n     \
    \                 ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var output = \"\"\n    var chars\
    \ = s.characters.map({ $0 })\n    chars.sorted(by: { (a1, b1) in\n        let\
    \ a2 = a1.asciiValue\n        let b2 = b1.asciiValue\n        if a1 < b1 {\n \
    \           return true\n        } else if a1 == b1 {\n            return false\n\
    \        } else {\n            return true\n        }\n    })\n    chars.forEach\
    \ { output += \"\\($0)\" }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpbqoptgpx.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    var chars = s.characters.map({ $0 })\n            \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpbqoptgpx.swift:17:11:\
    \ warning: result of call to 'sorted(by:)' is unused\n    chars.sorted(by: { (a1,\
    \ b1) in\n          ^     ~~~~~~~~~~~~~~~~~~\n/tmp/tmpbqoptgpx.swift:16:9: warning:\
    \ variable 'chars' was never mutated; consider changing to 'let' constant\n  \
    \  var chars = s.characters.map({ $0 })\n    ~~~ ^\n    let\n/tmp/tmpbqoptgpx.swift:18:13:\
    \ warning: initialization of immutable value 'a2' was never used; consider replacing\
    \ with assignment to '_' or removing it\n        let a2 = a1.asciiValue\n    \
    \    ~~~~^~\n        _\n/tmp/tmpbqoptgpx.swift:19:13: warning: initialization\
    \ of immutable value 'b2' was never used; consider replacing with assignment to\
    \ '_' or removing it\n        let b2 = b1.asciiValue\n        ~~~~^~\n       \
    \ _\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return s.split(\" \").sorted(by:\
    \ { $0.compare($1) == .orderedAscending })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpl_ezzvvm.swift:15:14: error: no exact matches in call to instance\
    \ method 'split'\n    return s.split(\" \").sorted(by: { $0.compare($1) == .orderedAscending\
    \ })\n             ^\n/tmp/tmpl_ezzvvm.swift:15:14: note: found candidate with\
    \ type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]' (aka '(Character,\
    \ Int, Bool) -> Array<ArraySlice<Character>>')\n    return s.split(\" \").sorted(by:\
    \ { $0.compare($1) == .orderedAscending })\n             ^\n/tmp/tmpl_ezzvvm.swift:15:14:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [String.SubSequence]'\
    \ (aka '(Character, Int, Bool) -> Array<Substring>')\n    return s.split(\" \"\
    ).sorted(by: { $0.compare($1) == .orderedAscending })\n             ^\n/tmp/tmpl_ezzvvm.swift:15:41:\
    \ error: reference to member 'compare' cannot be resolved without a contextual\
    \ type\n    return s.split(\" \").sorted(by: { $0.compare($1) == .orderedAscending\
    \ })\n                                        ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    for i in\
    \ 0..<s.count {\n        let firstChar = s[i]\n        if s.endIndex > i {\n \
    \           let nextChar = s[(i + 1)..<s.endIndex]\n            let charIndex\
    \ = s.index { (_, idx) -> Bool in\n                if idx > i {\n            \
    \        return true\n                } else {\n                    return (s[idx]\
    \ == \" \")\n                }\n            }\n            if nextChar == firstChar\
    \ {\n                result += String(firstChar)\n                continue\n \
    \           }\n            if charIndex < s.endIndex {\n                result\
    \ += String(firstChar)\n                result += String(nextChar)\n         \
    \   }\n        } else {\n            if s[i] == firstChar {\n                result\
    \ += String(firstChar)\n                continue\n            }\n            if\
    \ s[i] == \" \" {\n                result += String(firstChar)\n            }\
    \ else {\n                result += String(firstChar)\n                result\
    \ += String(s[i])\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmphtjeq5pg.swift:17:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let firstChar\
    \ = s[i]\n                        ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmphtjeq5pg.swift:18:23: error: referencing\
    \ operator function '>' on 'BinaryInteger' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n        if s.endIndex > i {\n                      ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n\
    /tmp/tmphtjeq5pg.swift:19:33: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n            let nextChar = s[(i + 1)..<s.endIndex]\n\
    \                                ^\n/tmp/tmphtjeq5pg.swift:20:39: error: contextual\
    \ closure type '(String.Element) throws -> Bool' (aka '(Character) throws -> Bool')\
    \ expects 1 argument, but 2 were used in closure body\n            let charIndex\
    \ = s.index { (_, idx) -> Bool in\n                                      ^\n/tmp/tmphtjeq5pg.swift:36:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if s[i] == firstChar {\n          \
    \     ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmphtjeq5pg.swift:40:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if s[i] == \" \" {\n               ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmphtjeq5pg.swift:44:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                result += String(s[i])\n                                 ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been exp"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n        .map({ String($0).lowercased() })\n    return words.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"Hi\"\
    ) == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp6f1lfkpa.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let wordsArray = s.components(separatedBy:\
    \ \" \")\n    let newString = words.sorted { $0.first < $1.first }\n    return\
    \ String(newString)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s: \"\
    Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp8zy6iuhd.swift:15:24: error: value of type 'String' has no member\
    \ 'components'\n    let wordsArray = s.components(separatedBy: \" \")\n      \
    \               ~ ^~~~~~~~~~\n/tmp/tmp8zy6iuhd.swift:16:21: error: cannot find\
    \ 'words' in scope\n    let newString = words.sorted { $0.first < $1.first }\n\
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let newString = s.map { $0.unicodeScalars.first!.value\
    \ }\n        .sort(<)\n        .map { String($0, radix: 16) }\n    return newString.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp6ndtf6nn.swift:16:15: error: missing argument label 'by:' in call\n\
    \        .sort(<)\n              ^\n              by: \n/tmp/tmp6ndtf6nn.swift:17:10:\
    \ error: value of tuple type '()' has no member 'map'\n        .map { String($0,\
    \ radix: 16) }\n         ^~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    var word_counter\
    \ = -1\n    var word_index = -1\n    var word_index2 = -1\n    for word_index\
    \ = 0; ; word_index += 1 {\n        var word_length = 0\n        var word_count\
    \ = 0\n        for word_counter = 0; ; word_counter += 1 {\n            if word_index\
    \ < s.count() {\n                word_length += s.distance(s.startIndex, word_index)\n\
    \                word_count += 1\n            }\n            if word_index ==\
    \ s.endIndex && word_counter < s.count() {\n                word_length += s.distance(word_index,\
    \ s.endIndex)\n                word_count += 1\n            }\n            if\
    \ word_index == s.endIndex && word_counter == s.endIndex && word_index < s.endIndex\
    \ {\n                word_length += s.distance(word_index, s.endIndex)\n     \
    \           word_count += 1\n            }\n        }\n        var new_word =\
    \ String(repeatElement(\" \", word_count) + String(UnicodeScalar(s.characters[word_index])))\n\
    \        result += new_word\n        if word_index == s.endIndex && word_counter\
    \ < s.count() {\n            word_length += s.distance(word_index, s.endIndex)\n\
    \            word_count += 1\n        }\n        if word_index == s.endIndex &&\
    \ word_counter == s.endIndex && word_index < s.endIndex {\n            word_length\
    \ += s.distance(word_index, s.endIndex)\n            word_count += 1\n       \
    \ }\n        if word_length != word_count {\n            result += \" \"\n   \
    \         for (; ; ) {\n                let old_word = String(UnicodeScalar(s.characters[word_index]))\n\
    \                let new_word = String(repeatElement(\" \", word_count) + String(UnicodeScalar(s.characters[word_index])))\n\
    \                let old_word2 = String(UnicodeScalar(s.characters[word_index2]))\n\
    \                let new_word2 = String(repeatElement(\" \", word_count) + String(UnicodeScalar(s.characters[word_index2])))\n\
    \                result += new_word\n                if word_index2 == s.endIndex\
    \ && word_counter < s.count() {\n                    word_length += s.distance(word_index,\
    \ s.endIndex)\n                    word_count += 1\n                }\n      \
    \          if word_index2 == s.endIndex && word_counter == s.endIndex && word_index\
    \ < s.endIndex {\n                    word_length += s.distance(word_index, s.endIndex)\n\
    \                    word_count += 1\n                }\n                if word_length\
    \ != word_count {\n                    result += \" \"\n                }\n  \
    \              word_index2 -= 1\n                if word_index2 == 0 {\n     \
    \               break\n                }\n                word_length -= word_count\n\
    \                word_count -= 1\n                word_index2 -= 1\n         \
    \       word_index -= 1\n            }\n            result += \" \"\n        }\
    \ else {\n            word_length = 0\n            word_count = 0\n          \
    \  word_index2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpm2efivct.swift:19:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for word_index = 0; ; word_index += 1 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm2efivct.swift:22:9: error: C-style for statement has been removed in\
    \ Swift 3\n        for word_counter = 0; ; word_counter += 1 {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm2efivct.swift:48:13: error: C-style for statement has been removed in\
    \ Swift 3\n            for (; ; ) {\n            ^   ~~~~~~\n/tmp/tmpm2efivct.swift:36:71:\
    \ error: no exact matches in call to initializer \n        var new_word = String(repeatElement(\"\
    \ \", word_count) + String(UnicodeScalar(s.characters[word_index])))\n       \
    \                                                               ^\n/tmp/tmpm2efivct.swift:36:71:\
    \ note: candidate has partially matching parameter list (UInt8)\n        var new_word\
    \ = String(repeatElement(\" \", word_count) + String(UnicodeScalar(s.characters[word_index])))\n\
    \                                                                      ^\n/tmp/tmpm2efivct.swift:36:71:\
    \ note: candidate has partially matching parameter list (Unicode.Scalar)\n   \
    \     var new_word = String(repeatElement(\" \", word_count) + String(UnicodeScalar(s.characters[word_index])))\n\
    \                                                                      ^\n/tmp/tmpm2efivct.swift:36:44:\
    \ error: missing argument label 'count:' in call\n        var new_word = String(repeatElement(\"\
    \ \", word_count) + String(UnicodeScalar(s.characters[word_index])))\n       \
    \                                    ^\n                                     \
    \            count: \n/tmp/tmpm2efivct.swift:49:39: error: no exact matches in\
    \ call to initializer \n                let old_word = String(UnicodeScalar(s.characters[word_index]))\n\
    \                                      ^\nSwift.Unicode.Scalar:7:23: note: candidate\
    \ expects value of type 'UInt8' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init(_ v: UInt8)\n                      ^\nSwift.Unicode.Scalar:8:23:\
    \ note: candidate expects value of type 'Unico"
  stdout: ''
  timestamp: 1660014144
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var str = s\n    var characters\
    \ = str.characters\n\n    var i = 0\n    for character in characters {\n     \
    \   let value = character\n        let index = characters.index(of: character)\n\
    \        characters.remove(at: index)\n        characters.insert(value, at: i)\n\
    \        i += 1\n    }\n\n    return String(characters)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpjobg_n1a.swift:16:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    var characters = str.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpjobg_n1a.swift:21:32:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = characters.index(of: character)\n                               ^\n\
    /tmp/tmpjobg_n1a.swift:21:32: note: use 'firstIndex(of:)' instead\n        let\
    \ index = characters.index(of: character)\n                               ^~~~~\n\
    \                               firstIndex\n/tmp/tmpjobg_n1a.swift:22:31: error:\
    \ value of optional type 'String.Index?' must be unwrapped to a value of type\
    \ 'String.Index'\n        characters.remove(at: index)\n                     \
    \         ^\n/tmp/tmpjobg_n1a.swift:21:13: note: short-circuit using 'guard' to\
    \ exit this function early if the optional value contains 'nil'\n        let index\
    \ = characters.index(of: character)\n            ^\n        guard            \
    \                           else { return <#default value#> }\n/tmp/tmpjobg_n1a.swift:21:32:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let index = characters.index(of: character)\n               \
    \                ^\n                                                    ?? <#default\
    \ value#>\n/tmp/tmpjobg_n1a.swift:21:32: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        let index = characters.index(of:\
    \ character)\n                               ^\n                             \
    \                      !\n/tmp/tmpjobg_n1a.swift:22:31: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        characters.remove(at:\
    \ index)\n                              ^\n                                  \
    \  ?? <#default value#>\n/tmp/tmpjobg_n1a.swift:22:31: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        charact"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var result = \"\"\n    var prev_value\
    \ = \"\"\n    var char_count = 0\n    for c in s.characters {\n        char_count\
    \ += 1\n        if prev_value != \"\" {\n            if c == prev_value {\n  \
    \              result = result + c\n                char_count = 1\n         \
    \   } else {\n                result = result + \" \" + c\n            }\n   \
    \     } else {\n            result = result + c\n        }\n        prev_value\
    \ = c\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpvjrtkfcd.swift:18:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvjrtkfcd.swift:21:18:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n            if c == prev_value {\n               ~ ^  ~~~~~~~~~~\n\
    /tmp/tmpvjrtkfcd.swift:21:18: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \     if c == prev_value {\n                 ^\n/tmp/tmpvjrtkfcd.swift:22:35:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result = result + c\n                                  ^\n/tmp/tmpvjrtkfcd.swift:25:41:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result = result + \" \" + c\n                               \
    \         ^\n/tmp/tmpvjrtkfcd.swift:28:31: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result = result\
    \ + c\n                              ^\n/tmp/tmpvjrtkfcd.swift:30:22: error: cannot\
    \ assign value of type 'Character' to type 'String'\n        prev_value = c\n\
    \                     ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    return String(s.characters.map\
    \ { $0.isLower ? String($0.unicodeScalars.filter { $0.value > 64 }).reversed()\n\
    \       : $0.unicodeScalars }).lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpr0c78a1c.swift:15:12: error: no exact matches in call to initializer\
    \ \n    return String(s.characters.map { $0.isLower ? String($0.unicodeScalars.filter\
    \ { $0.value > 64 }).reversed()\n           ^\n/tmp/tmpr0c78a1c.swift:15:12: note:\
    \ found candidate with type '([Character.UnicodeScalarView]) -> String' (aka '(Array<String.UnicodeScalarView>)\
    \ -> String')\n    return String(s.characters.map { $0.isLower ? String($0.unicodeScalars.filter\
    \ { $0.value > 64 }).reversed()\n           ^\n/tmp/tmpr0c78a1c.swift:15:12: note:\
    \ found candidate with type '([Character.UnicodeScalarView]) -> String' (aka '(Array<String.UnicodeScalarView>)\
    \ -> String')\n    return String(s.characters.map { $0.isLower ? String($0.unicodeScalars.filter\
    \ { $0.value > 64 }).reversed()\n           ^\n/tmp/tmpr0c78a1c.swift:15:12: note:\
    \ found candidate with type '([Character.UnicodeScalarView]) -> String' (aka '(Array<String.UnicodeScalarView>)\
    \ -> String')\n    return String(s.characters.map { $0.isLower ? String($0.unicodeScalars.filter\
    \ { $0.value > 64 }).reversed()\n           ^\n/tmp/tmpr0c78a1c.swift:15:41: error:\
    \ value of type 'String.Element' (aka 'Character') has no member 'isLower'\n \
    \   return String(s.characters.map { $0.isLower ? String($0.unicodeScalars.filter\
    \ { $0.value > 64 }).reversed()\n                                     ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\tlet words = s.split(separator: \"\
    \ \").map({ $0.trimmingCharacters(in: .whitespaces)})\n\tlet blankSpaces = words.filter({\
    \ $0 == \"\"}).count\n\tlet characters = words.map({ $0.unicodeScalars.reduce(\"\
    \") { $0 + $1.value } })\n\tlet characterArray = characters.map({ Int($0)! })\n\
    \t\n\treturn String(characterArray.sorted(by: >))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmptc1pib3j.swift:15:47: error: reference to member 'trimmingCharacters'\
    \ cannot be resolved without a contextual type\n        let words = s.split(separator:\
    \ \" \").map({ $0.trimmingCharacters(in: .whitespaces)})\n                   \
    \                                  ^\n/tmp/tmptc1pib3j.swift:15:71: error: cannot\
    \ infer contextual base in reference to member 'whitespaces'\n        let words\
    \ = s.split(separator: \" \").map({ $0.trimmingCharacters(in: .whitespaces)})\n\
    \                                                                            ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    let sortedWords = words.sorted { $0.0 < $1.0 }\n    var result = \"\
    \"\n    for word in sortedWords {\n        var s = \"\"\n        for letter in\
    \ word {\n            if let asciiValue = letter.unicodeScalars.map { $0.value\
    \ }.reduce(0, combine: +) {\n                s = s + String(UnicodeScalar(UInt32(asciiValue))).uppercaseString\n\
    \            } else {\n                s = s + letter\n            }\n       \
    \ }\n        result = result + \" \" + s\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp2punuc2m.swift:15:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let arr = s.components(separatedBy:\
    \ \" \")\n    \n    var result = \"\"\n    for i in 0..<arr.count {\n        let\
    \ word = arr[i]\n        let arr1 = word.characters\n        var j = 0\n     \
    \   while j < arr1.count {\n            let c = arr1[j]\n            let a = Int(c).description\n\
    \            \n            if a > 96 {\n                arr1.remove(at: j)\n \
    \               j -= 1\n            } else {\n                j += 1\n       \
    \     }\n        }\n        arr.removeSubrange(i, range.lowerBound: i)\n     \
    \   arr.insert(word, at: i)\n        result += arr[i]\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp4znu7soc.swift:33:47: error: expected ',' separator\n        arr.removeSubrange(i,\
    \ range.lowerBound: i)\n                                              ^\n    \
    \                                          ,\n/tmp/tmp4znu7soc.swift:33:47: error:\
    \ expected expression in list of expressions\n        arr.removeSubrange(i, range.lowerBound:\
    \ i)\n                                              ^\n/tmp/tmp4znu7soc.swift:15:17:\
    \ error: value of type 'String' has no member 'components'\n    let arr = s.components(separatedBy:\
    \ \" \")\n              ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n\tlet len = s.characters.count\n\t\
    let newString: NSMutableString = NSMutableString(string: s)\n\tlet separators\
    \ = newString.componentsSeparatedByString(\" \")\n\tlet wordsLength = separators.count\n\
    \n\tfor i = 0; i <= wordsLength - 2; i = i + 2 {\n\t\tlet first = separators[i]\n\
    \t\tlet last = separators[i + 1]\n\t\tlet start = newString.rangeOfString(first)\n\
    \t\tlet end = newString.rangeOfString(last)\n\t\tif start.location == NSNotFound\
    \ {\n\t\t\tnewString.insertString(first, range: NSMakeRange(0, newString.length))\n\
    \t\t}\n\t\tif end.location == NSNotFound {\n\t\t\tnewString.insertString(last,\
    \ range: NSMakeRange(newString.length - first.length, newString.length - last.length))\n\
    \t\t}\n\t}\n\treturn newString.substringToIndex(newString.length - 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp48qxqwak.swift:20:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for i = 0; i <= wordsLength - 2; i = i + 2 {\n        ^\
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp48qxqwak.swift:15:14: error:\
    \ 'characters' is unavailable: Please use String directly\n        let len = s.characters.count\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp48qxqwak.swift:16:17: error: cannot find type 'NSMutableString' in\
    \ scope\n        let newString: NSMutableString = NSMutableString(string: s)\n\
    \                       ^~~~~~~~~~~~~~~\n/tmp/tmp48qxqwak.swift:21:26: error:\
    \ cannot find 'i' in scope\n                let first = separators[i]\n      \
    \                                 ^\n/tmp/tmp48qxqwak.swift:22:25: error: cannot\
    \ find 'i' in scope\n                let last = separators[i + 1]\n          \
    \                            ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    \n    var new_string = \"\"\n    \n    for string in words {\n    \
    \    var new_str = \"\"\n        for char in string {\n            let ascii =\
    \ char.asciiValue\n            if ascii > 96 {\n                let ascii = char.unicodeScalars.last!.value\
    \ - 32\n                new_str += String(UnicodeScalar(ascii))\n            }\
    \ else {\n                new_str += char\n            }\n        }\n        new_string\
    \ += new_str\n    }\n    return new_string\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\"\
    ) == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp6rqnuzzz.swift:15:19: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var characters = [Character]()\n\
    \    let length = s.count\n    var word = \"\"\n    var i = 0\n    while i < length\
    \ {\n        if let ch = s[i]{\n            if let _ = Character(ch).isWhitespace(){\n\
    \                characters.remove(at: i)\n                i -= 1\n          \
    \      continue\n            }\n            if let _ = Character(ch).isLetter{\n\
    \                characters.remove(at: i)\n                i -= 1\n          \
    \      word += String(Character(ch))\n                continue\n            }\n\
    \        }\n        i += 1\n    }\n    while i < length {\n        if let _ =\
    \ s[i]{\n            characters.remove(at: i)\n            i -= 1\n        } else\
    \ {\n            word += String(s[i])\n        }\n    }\n    var newString = \"\
    \"\n    for c in characters {\n        if let _ = String(Character(c)).characters.count\
    \ {\n            newString += String(Character(c))\n        } else {\n       \
    \     newString += String(c)\n        }\n    }\n    \n    var count = 0\n    var\
    \ finalString = \"\"\n    while count < length - 1 {\n        finalString += String(Character(characters.remove(at:\
    \ count)))\n        count += 1\n    }\n    finalString += String(Character(characters.remove(at:\
    \ length)))\n    \n    if let _ = word {\n        newString += String(word)\n\
    \    }\n    \n    newString += finalString\n    return newString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmphz47kwkd.swift:20:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if let ch\
    \ = s[i]{\n                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmphz47kwkd.swift:21:34: error: missing\
    \ argument label 'extendedGraphemeClusterLiteral:' in call\n            if let\
    \ _ = Character(ch).isWhitespace(){\n                                 ^\n    \
    \                             extendedGraphemeClusterLiteral: \n/tmp/tmphz47kwkd.swift:21:38:\
    \ error: cannot call value of non-function type 'Bool'\n            if let _ =\
    \ Character(ch).isWhitespace(){\n                                     ^      \
    \     ~~\n                                                 \n/tmp/tmphz47kwkd.swift:26:34:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \          if let _ = Character(ch).isLetter{\n                              \
    \   ^\n                                 extendedGraphemeClusterLiteral: \n/tmp/tmphz47kwkd.swift:29:42:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \              word += String(Character(ch))\n                               \
    \          ^\n                                         extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmphz47kwkd.swift:20:12: error: initializer for conditional binding must\
    \ have Optional type, not 'Character'\n        if let ch = s[i]{\n           ^\
    \        ~~~~\n/tmp/tmphz47kwkd.swift:36:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ let _ = s[i]{\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmphz47kwkd.swift:40:28: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            word += String(s[i])\n                           ^~~~\nSwift.Strin"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var words = s.words\n    var characters\
    \ = Array(s.characters)\n    var newString = s\n    for word in words {\n    \
    \    var tempString = word\n        var newString = \"\"\n        for char in\
    \ words {\n            newString += String(characters[characters.index(of: char)!])\n\
    \        }\n        words.remove(at: word.index)\n        newString = newString.trimmingCharacters(in:\
    \ .whitespaces)\n        newString += tempString\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp8fi1dgm7.swift:15:19: error: value of type 'String' has no member\
    \ 'words'\n    var words = s.words\n                ~ ^~~~~\n/tmp/tmp8fi1dgm7.swift:16:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    var characters\
    \ = Array(s.characters)\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    return words.joined(separator: \"\")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpg3x8hshq.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    // Create an array from input\
    \ string where each element is an integer\n    let integerArray = Array(s.utf8)\n\
    \n    // Convert each element of array to string\n    let integerArrayAsStrings\
    \ = integerArray.map { String($0) }\n\n    // Reverse array elements\n    let\
    \ reversedArray = integerArrayAsStrings.reverse()\n\n    // Convert each element\
    \ of reversed array to string\n    let reversedArrayAsStrings = reversedArray.map\
    \ { String($0) }\n\n    // Use join method to get ordered words of string\n  \
    \  let orderedWords = reversedArrayAsStrings.joined(separator: \" \")\n\n    //\
    \ Return the ordered string\n    return orderedWords\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp7pqro66i.swift:22:47: error: cannot use mutating member on immutable\
    \ value: 'integerArrayAsStrings' is a 'let' constant\n    let reversedArray =\
    \ integerArrayAsStrings.reverse()\n                        ~~~~~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmp7pqro66i.swift:19:5: note: change 'let' to 'var' to make it mutable\n\
    \    let integerArrayAsStrings = integerArray.map { String($0) }\n    ^~~\n  \
    \  var\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    let words = s.components(separatedBy:\
    \ \" \")\n    let sortedWords = words.sorted(by: {$0.localizedStandardCompare($1)\
    \ == .orderedAscending})\n    return sortedWords.joined(separator: \" \")\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpx7b6a1j1.swift:15:19: error: value of type 'String' has no member\
    \ 'components'\n    let words = s.components(separatedBy: \" \")\n           \
    \     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var n = \"\"\n    for c in s.characters\
    \ {\n        n = n + \"\\u{0020}\" + c.string\n    }\n    return n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmp05aeyf6c.swift:16:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp05aeyf6c.swift:17:32:\
    \ error: value of type 'Character' has no member 'string'\n        n = n + \"\\\
    u{0020}\" + c.string\n                             ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var list = s.characters.map {\
    \ String($0) }\n    var new_list = NSMutableArray()\n    var index = 0\n    var\
    \ new_str = \"\"\n\n    for char in list {\n        let char = String(char)\n\
    \        if char == \" \" {\n            new_str.append(char[index..<list.endIndex])\n\
    \            new_list.append(char)\n            index = list.index(char.advancedBy(1),\
    \ offsetBy: 1)\n        } else {\n            if char != \"\\n\" {\n         \
    \       new_str.append(char)\n            }\n        }\n    }\n\n    while new_list.count\
    \ > 0 {\n        let word = new_list.removeAtIndex(0)\n        new_str.append(word)\n\
    \    }\n\n    return new_str as String\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") ==\
    \ \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\nassert(anti_shuffle(s:\
    \ \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello World!!!\") == \"Hello\
    \ !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\nassert(anti_shuffle(s: \"\
    Hi. My name is Mister Robot. How are you?\") == \".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpaia9v8qr.swift:15:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    var list = s.characters.map { String($0) }\n      \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpaia9v8qr.swift:16:20: error: cannot find 'NSMutableArray' in scope\n \
    \   var new_list = NSMutableArray()\n                   ^~~~~~~~~~~~~~\n/tmp/tmpaia9v8qr.swift:23:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            new_str.append(char[index..<list.endIndex])\n\
    \                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpaia9v8qr.swift:25:37: error: value of type 'String' has no member 'advancedBy'\n\
    \            index = list.index(char.advancedBy(1), offsetBy: 1)\n           \
    \                    ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    words = s.split(separator: \"\
    \ \")\n    return words.map { word -> String in\n        var rep = \"\"\n    \
    \    for symbol in word {\n            guard let asciiValue = symbol.asciiValue\
    \ else {\n                return \"?\"\n            }\n            rep += String(asciiValue)\n\
    \        }\n        return rep\n    }.joined(separator: \" \")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpjjjtdl4x.swift:15:5: error: cannot find 'words' in scope\n    words\
    \ = s.split(separator: \" \")\n    ^~~~~\n/tmp/tmpjjjtdl4x.swift:16:12: error:\
    \ cannot find 'words' in scope\n    return words.map { word -> String in\n   \
    \        ^~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    if s == \"\" {\n        return\
    \ s\n    }\n    words = s.split(separator: \" \")\n    sortedWords = words.sorted()\n\
    \    return String(sortedWords)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(anti_shuffle(s:\
    \ \"Hi\") == \"Hi\")\nassert(anti_shuffle(s: \"hello\") == \"ehllo\")\nassert(anti_shuffle(s:\
    \ \"number\") == \"bemnru\")\nassert(anti_shuffle(s: \"abcd\") == \"abcd\")\n\
    assert(anti_shuffle(s: \"Hello World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s:\
    \ \"\") == \"\")\nassert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are\
    \ you?\") == \".Hi My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpeuvp4k6v.swift:18:5: error: cannot find 'words' in scope\n    words\
    \ = s.split(separator: \" \")\n    ^~~~~\n/tmp/tmpeuvp4k6v.swift:19:5: error:\
    \ cannot find 'sortedWords' in scope\n    sortedWords = words.sorted()\n    ^~~~~~~~~~~\n\
    /tmp/tmpeuvp4k6v.swift:19:19: error: cannot find 'words' in scope\n    sortedWords\
    \ = words.sorted()\n                  ^~~~~\n/tmp/tmpeuvp4k6v.swift:20:19: error:\
    \ cannot find 'sortedWords' in scope\n    return String(sortedWords)\n       \
    \           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014141
- exit_code: 1
  program: "\n/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(s: \"Hi\")\n/// \"Hi\"\n/// >>> anti_shuffle(s: \"hello\")\n///\
    \ \"ehllo\"\n/// >>> anti_shuffle(s: \"Hello World!!!\")\n/// \"Hello !!!Wdlor\"\
    \nfunc anti_shuffle(s: String) -> String {\n    var i = 0\n    var j = s.count\n\
    \    var buffer = \"\"\n    while i < j {\n        let a = s[i]\n        let b\
    \ = s[i+1]\n        let c = s[i+2]\n        i+=3\n        let aChar = a.unicodeScalars\n\
    \        let bChar = b.unicodeScalars\n        let cChar = c.unicodeScalars\n\
    \        if aChar.count == 0 {\n            aChar = bChar\n            bChar =\
    \ cChar\n            cChar = aChar\n        }\n        let aVal = aChar[0]\n \
    \       let bVal = bChar[0]\n        let cVal = cChar[0]\n        if aVal < bVal\
    \ {\n            buffer = buffer + cChar[1]\n        }\n        else if bVal <\
    \ cVal {\n            buffer = buffer + bChar[1]\n        }\n        else {\n\
    \            buffer = buffer + aChar[1]\n        }\n    }\n    return buffer\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(anti_shuffle(s: \"Hi\") == \"Hi\")\nassert(anti_shuffle(s:\
    \ \"hello\") == \"ehllo\")\nassert(anti_shuffle(s: \"number\") == \"bemnru\")\n\
    assert(anti_shuffle(s: \"abcd\") == \"abcd\")\nassert(anti_shuffle(s: \"Hello\
    \ World!!!\") == \"Hello !!!Wdlor\")\nassert(anti_shuffle(s: \"\") == \"\")\n\
    assert(anti_shuffle(s: \"Hi. My name is Mister Robot. How are you?\") == \".Hi\
    \ My aemn is Meirst .Rboot How aer ?ouy\")"
  status: SyntaxError
  stderr: "/tmp/tmpgfprzx0s.swift:19:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a = s[i]\n\
    \                ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpgfprzx0s.swift:20:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ b = s[i+1]\n                ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgfprzx0s.swift:21:17: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let c = s[i+2]\n                ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgfprzx0s.swift:27:13: error: cannot\
    \ assign to value: 'aChar' is a 'let' constant\n            aChar = bChar\n  \
    \          ^~~~~\n/tmp/tmpgfprzx0s.swift:23:9: note: change 'let' to 'var' to\
    \ make it mutable\n        let aChar = a.unicodeScalars\n        ^~~\n       \
    \ var\n/tmp/tmpgfprzx0s.swift:28:13: error: cannot assign to value: 'bChar' is\
    \ a 'let' constant\n            bChar = cChar\n            ^~~~~\n/tmp/tmpgfprzx0s.swift:24:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let bChar = b.unicodeScalars\n\
    \        ^~~\n        var\n/tmp/tmpgfprzx0s.swift:29:13: error: cannot assign\
    \ to value: 'cChar' is a 'let' constant\n            cChar = aChar\n         \
    \   ^~~~~\n/tmp/tmpgfprzx0s.swift:25:9: note: change 'let' to 'var' to make it\
    \ mutable\n        let cChar = c.unicodeScalars\n        ^~~\n        var\n/tmp/tmpgfprzx0s.swift:31:25:\
    \ error: no exact matches in call to subscript \n        let aVal = aChar[0]\n\
    \                        ^\nSwift.String.UnicodeScalarView:7:23: note: candidate\
    \ expects value of type 'String.UnicodeScalarView.Index' (aka 'String.Index')"
  stdout: ''
  timestamp: 1660014141
