name: HumanEval_132_is_nested
language: swift
prompt: "\n/// Create a function that takes a string as input which contains only\
  \ square brackets.\n/// The function should return true if and only if there is\
  \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
  \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
  \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
  /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
  )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
  \ String) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
  \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
  assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
  ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
  \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
  \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
  \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
  \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
completions: ["\tlet tokens = tokenize(string)\n\tlet stack = Stack()\n\tfor token\
    \ in tokens {\n\t\tswitch token {\n\t\tcase \"[\", \"]\":\n\t\t\t// push onto\
    \ the stack\n\t\t\tstack.push(token)\n\t\tdefault:\n\t\t\t// if we get an opening\
    \ bracket, then\n\t\t\tif stack.len() > 0 {\n\t\t\t\t// check that the previous\
    \ token is an closing bracket\n\t\t\t\tlet lastToken = stack.pop()\n\t\t\t\tswitch\
    \ lastToken {\n\t\t\t\tcase \"[\", \"]\":\n\t\t\t\t\treturn true\n\t\t\t\tdefault:\n\
    \t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.len() ==\
    \ 0", "    guard string.count >= 2 else {\n        return false\n    }\n    let\
    \ opens = Set<Character>()\n    let closes = Set<Character>()\n    let index =\
    \ string.firstIndex(of: \"[\")\n    if index == nil {\n        return false\n\
    \    }\n    \n    // count the opening brackets\n    guard let openBracketCount\
    \ = string.substring(from: index!).characters.filter({ opens.contains($0) }).count\
    \ else {\n        return false\n    }\n    opens.insert(\"[\")\n    \n    // count\
    \ the closing brackets\n    guard let closeBracketCount = string.substring(from:\
    \ index!).characters.filter({ closes.contains($0) }).count else {\n        return\
    \ false\n    }\n    closes.insert(\"]\")\n    \n    // return true if there exists\
    \ a valid nested brackets\n    return openBracketCount >= closeBracketCount",
  "    var open = [0]\n    var closed = [0]\n    var i : Int = 0\n    var prevOpen\
    \ = 0\n    var prevClosed = 0\n    var found : Bool = false\n    for _, bracket\
    \ := range string {\n        open[i] = bracket\n        closed[i] = bracket\n\
    \        i = i + 1\n        if i == len(string) {\n            closed = append(closed,\
    \ 0)\n        }\n    }\n    for open != nil {\n        if prevOpen != 0 || prevClosed\
    \ != 0 || open != nil {\n            if open[0] == 0 {\n                closed\
    \ = closed[:len(closed)-1]\n            } else {\n                open = open[:len(open)-1]\n\
    \            }\n        } else {\n            if open[0] == 0 {\n            \
    \    closed = closed[:len(closed)-1]\n                open = open[:len(open)-1]\n\
    \            } else {\n                open = nil\n            }\n        }\n\
    \        if open != nil {\n            open = open[:len(open)-1]\n           \
    \ found = true\n        } else {\n            closed = closed[:len(closed)-1]\n\
    \            open = open[:len(open)-1]\n            found = false\n        }\n\
    \        prevOpen = open[0]\n        prevClosed = closed[0]\n    }\n    return\
    \ found", "\tvar count int\n\tfor i := 0; i < len(string); i++ {\n\t\tswitch string[i]\
    \ {\n\t\tcase '[':\n\t\t\tcount++\n\t\tcase '[':\n\t\t\tif count > 0 {\n\t\t\t\
    \treturn false\n\t\t\t}\n\t\tcase '(':\n\t\t\tcount++\n\t\tcase ')':\n\t\t\tif\
    \ count > 1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\tif count < 2 {\n\t\
    \treturn false\n\t}\n\treturn true", "\tlet length = string.length\n\tlet brackets\
    \ = string.unicodeScalars.filter({ $0 == '[' }).count\n\tlet nestings = string.unicodeScalars.filter({\
    \ $0 == ']' }).count\n\treturn brackets >= nestings", "\tif string == \"\" {\n\
    \t\treturn false\n\t}\n\tswitch count := strings.Count(string, \"[\"), count {\n\
    \tcase 0:\n\t\treturn false\n\tcase 1:\n\t\treturn true\n\tdefault:\n\t\tfor i\
    \ := 0; i < count; i++ {\n\t\t\tswitch count := strings.Count(string, \"[\"+string[i*2+1:(i+1)*2],\
    \ \"[\"), count {\n\t\t\tcase 0:\n\t\t\t\treturn false\n\t\t\tcase 1:\n\t\t\t\t\
    return true\n\t\t\tdefault:\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}", "\treturn\
    \ is_nested_impl(string, 0)", "\tlet chars: CharacterIterator = string.makeIterator()\n\
    \t\n\tlet inner: Bool = true\n\tlet outerBracket: Bool = true\n\tlet innerBracket:\
    \ Bool = true\n\tlet openBracket: Bool = true\n\tlet isFirst: Bool = true\n\t\
    let innerInner: Bool = true\n\tlet innerOuterBracket: Bool = true\n\t\n\twhile\
    \ !inner {\n\t\tswitch chars.next() {\n\t\tcase \"[\":\n\t\t\tif innerBracket\
    \ {\n\t\t\t\tif !outerBracket {\n\t\t\t\t\treturn false\n\t\t\t\t} else {\n\t\t\
    \t\t\tinnerBracket = false\n\t\t\t\t\touterBracket = false\n\t\t\t\t\tinnerInner\
    \ = true\n\t\t\t\t\tinnerOuterBracket = true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\
    \tinnerBracket = true\n\t\t\t\touterBracket = true\n\t\t\t\tinnerInner = true\n\
    \t\t\t\tinnerOuterBracket = true\n\t\t\t}\n\t\tcase \"[\":\n\t\t\tif !outerBracket\
    \ {\n\t\t\t\treturn false\n\t\t\t} else {\n\t\t\t\tinnerBracket = true\n\t\t\t\
    \touterBracket = true\n\t\t\t\tinnerInner = true\n\t\t\t\tinnerOuterBracket =\
    \ true\n\t\t\t}\n\t\tcase \"\\\\\":\n\t\t\tif isFirst {\n\t\t\t\tinnerBracket\
    \ = true\n\t\t\t\tisFirst = false\n\t\t\t} else {\n\t\t\t\tinnerBracket = false\n\
    \t\t\t\touterBracket = false\n\t\t\t\tinnerInner = true\n\t\t\t\tinnerOuterBracket\
    \ = true\n\t\t\t}\n\t\tdefault:\n\t\t\tif innerOuterBracket {\n\t\t\t\tif innerInner\
    \ {\n\t\t\t\t\tinnerInner++\n\t\t\t\t} else {\n\t\t\t\t\treturn false\n\t\t\t\t\
    }\n\t\t\t} else {\n\t\t\t\tinnerBracket = false\n\t\t\t\touterBracket = true\n\
    \t\t\t\tinnerInner = true\n\t\t\t\tinnerOuterBracket = true\n\t\t\t}\n\t\t}\n\t\
    }\n\t\n\treturn true", "\tlet tokens = tokenize(string: string)\n\tlet openCount\
    \ = tokens.filter({ $0.isOpen }).count\n\tlet closeCount = tokens.filter({ $0.isClose\
    \ }).count\n\treturn closeCount == openCount", "    let open = Set([String]())\n\
    \    let closed = Set([String]())\n    for index in 0..<string.count {\n     \
    \   if string[index] == \"[\" {\n            if !open.contains(string[index..<index+2])\
    \ {\n                return false\n            }\n            open[string[index..<index+2]]\
    \ = true\n        }\n        if string[index] == \"]\" {\n            if open.contains(string[index..<index+2])\
    \ {\n                open.remove(string[index..<index+2])\n            }\n   \
    \         if closed.contains(string[index..<index+2]) {\n                return\
    \ false\n            }\n            closed.insert(string[index..<index+2])\n \
    \       }\n    }\n    return true", "    let regex = NSRegularExpression(pattern:\
    \ bracket_pattern, options: NSRegularExpression.Options.dotMatchesLineSeparators)\n\
    \    return regex.numberOfMatchesInString(string, options: [], range: NSMakeRange(0,\
    \ string.utf16.count)) != 0", "    var current = 0\n    var count = 1\n    var\
    \ openingBrackets: Int = 0\n    var closingBrackets: Int = 0\n    var last: Int?\
    \ = nil\n    var lastOpeningBrackets: Int? = nil\n    var lastClosingBrackets:\
    \ Int? = nil\n    var openingBracketString = \"\"\n    var closingBracketString\
    \ = \"\"\n\n    while current < string.count {\n        var openingBracket = string.index(\"\
    [\", current)\n        var closingBracket = string.index(\"]\", current)\n\n \
    \       if openingBracket != -1 && closingBracket != -1 {\n            openingBrackets\
    \ = openingBrackets\n            closingBrackets = closingBrackets\n         \
    \   last = current\n            lastOpeningBrackets = lastOpeningBrackets\n  \
    \          lastClosingBrackets = lastClosingBrackets\n            openingBracketString\
    \ = string[openingBracket + 1 : closingBracket]\n\n            current = closingBracket\n\
    \            count = 1\n        } else {\n            if openingBracket != -1\
    \ && closingBracket == -1 {\n                openingBrackets = openingBrackets\n\
    \                closingBrackets = closingBrackets\n                last = current\n\
    \                lastOpeningBrackets = lastOpeningBrackets\n                lastClosingBrackets\
    \ = lastClosingBrackets\n                openingBracketString = string[openingBracket\
    \ + 1 : current]\n\n                current = string.index(\"]\", current)\n \
    \               count = 1\n            } else {\n                if openingBracket\
    \ == -1 && closingBracket == -1 {\n                    if count == 1 {\n     \
    \                   current = string.index(\"]\", current)\n                 \
    \       count = 1\n                    } else {\n                        return\
    \ false\n                    }\n                } else {\n                   \
    \ lastOpeningBrackets = lastOpeningBrackets\n                    lastClosingBrackets\
    \ = lastClosingBrackets\n                    openingBracketString = string[openingBracket\
    \ + 1 : current]\n\n                    current = string.index(\"]\", current)\n\
    \                    count = 1\n                }\n            }\n        }\n\
    \    }\n\n    if count == 0 {\n        return true\n    }\n\n    if lastOpeningBrackets\
    \ != nil && lastClosingBrackets == nil {\n        return true\n    } else if lastOpeningBrackets\
    \ != nil && lastClosingBrackets != nil {\n        return false\n    } else if\
    \ lastOpeningBrackets == nil && lastClosingBrackets != nil {\n        return false\n\
    \    } else if lastOpeningBrackets != nil && lastClosingBrackets == nil {\n  \
    \      return false\n    }\n\n    var open", "    guard string.count >= 3 else\
    \ {\n        return false\n    }\n    \n    // A valid subsequence is either empty\
    \ or just an opening bracket.\n    guard let first = string.first else {\n   \
    \     return false\n    }\n    guard first == \"[\" else {\n        return false\n\
    \    }\n\n    // Find the position of the last closing bracket.\n    var last\
    \ = string.endIndex\n    if last != string.string.count {\n        guard let lastCloseBracket\
    \ = string.string.rangeOfString(\"]\", options: .BackwardsSearch).endIndex else\
    \ {\n            return false\n        }\n        last = lastCloseBracket\n  \
    \  }\n    \n    // Return true if and only if the string contains a valid subsequence\
    \ of brackets.\n    let range = (last, string.count)\n    guard string.countElements(in:\
    \ range) > 1 else {\n        return false\n    }\n    let bracketsString = string.substringWithRange(range)\n\
    \    let brackets = bracketsString.components(separatedBy: CharacterSet.init(charactersInString:\
    \ \"[\")).map(String.init)\n    return brackets.contains(where: { (bracketedString)\
    \ -> Bool in\n        let bracketsString = bracketedString.components(separatedBy:\
    \ CharacterSet.init(charactersInString: \"[\")).map(String.init)\n        let\
    \ firstBracket = bracketsString.first\n        guard firstBracket != nil else\
    \ {\n            return false\n        }\n        let lastBracket = bracketsString.last\n\
    \        guard lastBracket != nil else {\n            return false\n        }\n\
    \        let bracketedString = bracketedString.dropFirst()\n        let bracketsCount\
    \ = bracketsString.count\n        if bracketedString == bracketsString {\n   \
    \         return true\n        } else if bracketedString.first == firstBracket\
    \ {\n            // Only one opening.\n            return true\n        } else\
    \ if bracketsCount == 1 {\n            // Only one closing bracket.\n        \
    \    return true\n        } else {\n            // Nested brackets.\n        \
    \    return false\n        }\n    })", "\tlet length = string.characters.count\n\
    \treturn (length == 0) || (length == 1 && string[0] == \"]\")", "    \n    //\
    \ This code uses two stacks to count brackets and the number of open brackets.\n\
    \    // A closed bracket \"[\" pushes the number of open brackets one and an open\
    \ bracket \"]\" \n    // pops the number of open brackets. When the number is\
    \ zero, there is an open bracket \n    // before the bracket. So the number of\
    \ open brackets must be zero or more.\n\n    // Two stacks\n    var bracketCount\
    \ = [0]\n    var openBracketCount = [2]\n    \n    var lastChar: Character\n \
    \   var lastBracket: Character\n    \n    for char in string {\n        \n   \
    \     // If this character is not an opening bracket, increment the count of brackets.\n\
    \        if char != lastBracket {\n            bracketCount[0]++\n        }\n\
    \        lastBracket = char\n        \n        // If the last character was an\
    \ opening bracket, decrement the count of brackets.\n        if char == \"[\"\
    \ {\n            bracketCount[1]--\n        }\n        lastChar = char\n     \
    \   \n        // If this bracket count is zero, there is a closing bracket before\
    \ this bracket. \n        // Therefore the number of open brackets must be zero.\n\
    \        if bracketCount[0] == 0 {\n            return true\n        }\n     \
    \   \n        // If this bracket count is greater than zero, there is an open\
    \ bracket before this bracket.\n        // Therefore the number of open brackets\
    \ must be zero.\n        if bracketCount[1] > 0 {\n            return false\n\
    \        }\n    }\n    return false", "\tlet chars = string.characters\n\t\n\t\
    return chars.contains(where: {$0 == \"[\" || $0 == \"[\"}) //first bracket is\
    \ a nested one", "\tvar index = 0\n\tlet isNested = false\n\t\n\twhile index <\
    \ string.count {\n\t\tif !isValidBracket(string: string[index], index: index+1,\
    \ isNested, open: bracketOpen, close: bracketClose) {\n\t\t\treturn false\n\t\t\
    }\n\t\tindex++\n\t}\n\t\n\treturn true", "\tlet stack = StringStack()\n\tstack.append(string)\n\
    \tlet opened = stack.open\n\tlet closed = stack.close\n\twhile opened.count !=\
    \ closed.count {\n\t\tlet open = opened.count\n\t\tfor index in 0..<open {\n\t\
    \t\tlet char = String(opened[index])\n\t\t\tif char == \"[\" || char == \"{\"\
    \ || char == \"(\" || char == \"[\" || char == \"{\" {\n\t\t\t\tstack.append(char)\n\
    \t\t\t\topened.insert(index, char)\n\t\t\t} else if char == \"]\" {\n\t\t\t\t\
    let index = opened.index(opened.startIndex, offsetBy: index)\n\t\t\t\tlet isClosed\
    \ = (opened[index-1] == \"[\" || opened[index-1] == \"{\" || opened[index-1] ==\
    \ \"(\" || opened[index-1] == \"[\" || opened[index-1] == \"{\" || opened[index-1]\
    \ == \"[\" || opened[index-1] == \"{\")\n\t\t\t\tif isClosed {\n\t\t\t\t\tstack.append(\"\
    }\")\n\t\t\t\t\topened.insert(index, char)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\
    stack.pop()\n\treturn stack.isEmpty", "\tlet length = string.characters.count\n\
    \t\n\tif length == 0 {\n\t\treturn false\n\t}\n\t\n\tlet firstBracket = string.startIndex\n\
    \tlet lastBracket = string.endIndex\n\t\n\treturn string[lastBracket] == \"]\"\
    \ && lastBracket != firstBracket", "    var stack: [String] = []\n    var result:\
    \ Bool = false\n    for char in string {\n        switch char {\n        case\
    \ \"[\": stack.append(char); break\n        case \"]\": stack.removeLast(); break\n\
    \        default: if stack.count == 0 {\n            result = false\n        \
    \    break\n        }\n        }\n    }\n    return result", "\tvar stack = StringStack(string)\n\
    \tdefer { stack.clear() }\n\treturn stack.is_nested()", "\treturn is_nested(string:\
    \ string, position: 0)", "    let brackets = countBrackets(string: string)\n \
    \   return brackets > 0 && brackets == len(string)-1", "\tlet openIndexes: Set<String>\
    \ = []\n\tlet closeIndexes: Set<String> = []\n\n\tfor character in string {\n\t\
    \tif character == \"[\" {\n\t\t\topenIndexes.insert(\"\\(character)\")\n\t\t}\
    \ else if character == \"]\" {\n\t\t\tcloseIndexes.insert(\"\\(character)\")\n\
    \t\t}\n\t}\n\n\treturn openIndexes.isSuperset(of: closeIndexes)", "    var stack\
    \ = StringStack()\n    for c in string {\n        switch c {\n        case '[':\n\
    \            stack.push(c)\n        case ']':\n            if stack.is_empty()\
    \ {\n                return false\n            }\n            stack.pop()\n  \
    \      case ',':\n            if stack.is_empty() {\n                return false\n\
    \            }\n        default:\n            return false\n        }\n    }\n\
    \    return stack.is_empty()", "\tlet opening = string.rangeOfString(\"[\")\n\t\
    if opening == nil {\n\t\treturn false\n\t}\n\tlet closing = string.rangeOfString(\"\
    ]\")\n\tif closing == nil {\n\t\treturn false\n\t}\n\tif opening.location == closing.location\
    \ {\n\t\treturn false\n\t}\n\tlet first = string.substringWithRange(opening)\n\
    \tlet last = string.substringFromIndex(closing.location).substringToIndex(opening.location)\n\
    \treturn first.rangeOfString(last) == nil", "\tstring = normalize(string)\n\t\n\
    \tvar openBracketCount : Int = -1\n\tvar openSquareBracketCount : Int = -1\n\t\
    var closeSquareBracketCount : Int = -1\n\n\tfor _, character : String in string.characters\
    \ {\n\t\tif character == \"[\" {\n\t\t\topenBracketCount += 1\n\t\t} else if character\
    \ == \"]\" {\n\t\t\tcloseSquareBracketCount += 1\n\t\t} else if character == \"\
    {\" {\n\t\t\topenSquareBracketCount += 1\n\t\t}\n\t}\n\n\treturn (openBracketCount\
    \ != 0 &&\n\t\topenSquareBracketCount != 0 &&\n\t\tcloseSquareBracketCount !=\
    \ 0 &&\n\t\topenBracketCount + openSquareBracketCount + closeSquareBracketCount\
    \ == string.characters.count)", "\tif let subsequence = string.trimmingCharacters(in:\
    \ .whitespacesAndNewlines).components(separatedBy: \"[\").last?.trimmingCharacters(in:\
    \ .whitespacesAndNewlines).components(separatedBy: \"]\").first {\n\t\treturn\
    \ !subsequence.isEmpty && subsequence.count >= 2\n\t}\n\treturn false", "\t\n\t\
    var i = string.count\n\tvar open = [0]bool{}\n\tvar stack = [int]()\n\t\n\tfor\
    \ i > 0{\n\t\topen[stack[stack[stack[0]].0]] = false\n\t\tstack[stack[0]] = stack[stack[0]]\
    \ + 1\n\t\tif open[stack[stack[0]]] {\n\t\t\tif string.count > 0 {\n\t\t\t\tstack[stack[stack[0]]]\
    \ = 0\n\t\t\t\topen[stack[stack[0]]] = true\n\t\t\t}\n\t\t\tstack[stack[0]] =\
    \ stack[stack[0]] + 1\n\t\t\tstack[stack[0]] = stack[stack[0]] + 1\n\t\t\tstack[stack[0]]\
    \ = stack[stack[0]] + 1\n\t\t\tstack[stack[0]] = stack[stack[0]] + 1\n\t\t\tif\
    \ string.count > 0 {\n\t\t\t\tstack[stack[stack[0]]] = 0\n\t\t\t\topen[stack[stack[0]]]\
    \ = true\n\t\t\t}\n\t\t}\n\t\tif string.count > 0 {\n\t\t\tif string[string.startIndex..<string.endIndex]\
    \ == \"][]\" {\n\t\t\t\topen[stack[stack[0]]] = false\n\t\t\t\tstack[stack[0]]\
    \ = stack[stack[0]] + 1\n\t\t\t\tstack[stack[0]] = stack[stack[0]] + 1\n\t\t\t\
    \tstack[stack[0]] = stack[stack[0]] + 1\n\t\t\t\tstack[stack[0]] = stack[stack[0]]\
    \ + 1\n\t\t\t\tif string.count > 0 {\n\t\t\t\t\tstack[stack[stack[0]]] = 0\n\t\
    \t\t\t\topen[stack[stack[0]]] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ stack[0] == 0", "\tlet openCount = countBrackets(string: string)\n\tlet closedCount\
    \ = countBrackets(string: string, openCount: openCount)\n\tlet openCount = openCount\
    \ - 1\n\tlet closedCount = closedCount - 1\n\t\n\treturn openCount == closedCount",
  "    var index = 0\n    var hasNesting = true\n\n    for i := 0; i < len(string);\
    \ i++ {\n        if string[i] != \"]\" {\n            hasNesting = false\n   \
    \     } else {\n            if index == 0 {\n                index++\n       \
    \     } else if string[i - index] != \"]\" {\n                hasNesting = false\n\
    \            }\n            index++\n        }\n    }\n\n    return hasNesting",
  "\tlet length = string.characters.count\n\tif length == 0 {\n\t\treturn false\n\t\
    }\n\t\n\tlet firstIndex = string.characters.index(string.startIndex, offsetBy:\
    \ 0)\n\t\n\tlet lastIndex = string.characters.index(string.endIndex, offsetBy:\
    \ length - 1)\n\t\n\tif let range = string.range(of: \"[]\", options: .backwards,\
    \ range: firstIndex..<lastIndex) {\n\t\tlet foundIndex = firstIndex + range.upperBound\n\
    \t\treturn range.isEmpty && foundIndex == lastIndex\n\t} else {\n\t\treturn false\n\
    \t}", "\tdepth := 0\n\tfound := false\n\tfor i, r := range string {\n\t\tif depth\
    \ == 0 && r == '[' {\n\t\t\tdepth++\n\t\t} else if depth == 1 && r == ']' {\n\t\
    \t\tdepth--\n\t\t} else if depth > 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif depth\
    \ == 0 {\n\t\t\tfound = true\n\t\t\tif i == 0 {\n\t\t\t\treturn false\n\t\t\t\
    }\n\t\t}\n\t}\n\n\treturn found", "    var bracket_counter = 0\n    var bracket_level\
    \ = 0\n    var result = false\n    \n    for index in 0 ..< string.characters.count\
    \ {\n        if let char = string.character(at: index) {\n            if char\
    \ == \"[\" {\n                bracket_counter += 1\n            } else if char\
    \ == \"]\" {\n                bracket_counter -= 1\n            } else if char\
    \ == \"{\" {\n                bracket_level += 1\n            } else if char ==\
    \ \"}\" {\n                bracket_level -= 1\n            }\n            if bracket_counter\
    \ >= bracket_level {\n                result = true\n                break\n \
    \           }\n        }\n    }\n    return result", "\tlet pattern = \"\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\]\"\n\treturn string.rangeOfString(pattern, options:\
    \ NSStringCompareOptions.RegularExpressionSearch) != nil", "    var brackets =\
    \ [0]\n    return is_nested_inner(string, &brackets)", "\tlet ranges = string.characters.enumerated().map\
    \ { $0.offset ..< $0.offset + $1.count }\n\tvar inBrackets = false\n\tvar isNestingRequired\
    \ = true\n\t\n\tfor (index, range) in ranges.reverse().enumerated() {\n\t\tlet\
    \ currentOpenBracketIndex: Int = index\n\t\tlet currentCloseBracketIndex: Int\
    \ = index\n\t\t\n\t\tfor _ in 0..<range.length {\n\t\t\tlet character: Character\
    \ = string.character(at: index)\n\t\t\tif character == \"[\"{\n\t\t\t\tinBrackets\
    \ = true\n\t\t\t\tcurrentCloseBracketIndex = index\n\t\t\t} else if character\
    \ == \"]\" {\n\t\t\t\tinBrackets = false\n\t\t\t\tcurrentCloseBracketIndex = index\n\
    \t\t\t} else if inBrackets == true && character == \"]\" {\n\t\t\t\tisNestingRequired\
    \ = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t\n\t\t\tindex = index + 1\n\t\t}\n\t\t\
    \n\t\tif isNestingRequired {\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\treturn inBrackets\
    \ == true", "\tlet isNested = string.rangeOfCharacter(from: openBracket) != nil\n\
    \tlet isNotNested = string.rangeOfCharacter(from: closeBracket) == nil\n\tlet\
    \ isNestedOrNotNested = string.rangeOfCharacter(from: closeBracket) != nil ||\
    \ string.rangeOfCharacter(from: openBracket) == nil\n\treturn isNested || isNotNested\
    \ || isNestedOrNotNested", "    // We use the standard library function strString\
    \ to find an occurrence of brackets\n    // in the input string.  Since this function\
    \ returns false if an occurrence is found,\n    // we simply negate it here to\
    \ produce a result which indicates whether or not the string\n    // contains\
    \ any brackets.\n    return strString(string) != nil", "\tif string.count < 2\
    \ {\n\t\treturn false\n\t}\n\t\n\tlet open = string(string: string, startIndex:\
    \ 0)\n\tlet closed = string(string: string, startIndex: 1)\n\n\tlet start = index(open)\n\
    \tlet end = index(closed)\n\t\n\tlet openIndex = [start, start].max\n\n\tlet openClosed\
    \ = closed(closed)\n\n\tif openClosed == open {\n\t\treturn true\n\t}\n\t\n\t\
    for i in start + 1..<end {\n\t\tif openClosed[i] != openClosed {\n\t\t\treturn\
    \ false\n\t\t}\n\t\t\n\t\topenIndex = i\n\t}\n\n\treturn true", '    return is_nested_rec(string:
    string)', "\tlet characters = Array(string)\n\t\n\tfor char in characters {\n\t\
    \tlet isNested = is_nested(characters: &characters, char: char)\n\t\t\n\t\tif\
    \ isNested {\n\t\t\treturn true\n\t\t}\n\t}\n\t\n\treturn false", "\tlet regex\
    \ = try! NSRegularExpression(pattern: \"[(\\\\[|\\\\{|\\\\)](\\\\[|\\\\{|\\\\\
    )]|\\\\[\\\\[|\\\\]\\\\])+\", options: .caseInsensitive)\n\treturn regex.firstMatch(in:\
    \ string, options: .anchored, range: NSRange(location: 0, length: string.utf16.count))\
    \ != nil", "\tlet index = 0\n\t\n\twhile index < string.count {\n\t\tif let bracket\
    \ = string.rangeOfString(\"[\", options: .LiteralSearch, range: NSMakeRange(index,\
    \ 1)) {\n\t\t\tif let closeBracket = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: NSMakeRange(bracket.endIndex, 1)) {\n\t\t\t\tif closeBracket.startIndex\
    \ == bracket.endIndex {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\
    \n\t\tindex++\n\t}\n\t\n\treturn false", "\tlet scanner = Scanner(string: string)\n\
    \tscanner.scan(&brackets)\n\treturn scanner.isAtEnd && brackets.count == 0", "\t\
    let brackets = newStringIterator(string)\n\tlet lastBracket = brackets.next()\n\
    \twhile let lastBracket = lastBracket {\n\t\tif lastBracket == \"[\".unicodeScalars\
    \ {\n\t\t\tlet nextBracket = brackets.next()\n\t\t\tif let nextBracket = nextBracket,\
    \ nextBracket == \"[\".unicodeScalars {\n\t\t\t\treturn true\n\t\t\t}\n\t\t} else\
    \ {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn false", "\tvar i int\n\tvar bracket\
    \ Character = ' ' \n\t\n\tif string[i] == ']' {\n\t\tbracket = ']'\n\t} else if\
    \ string[i] == '[' {\n\t\tbracket = '['\n\t}\n\t\n\tfor i := 0; i < len(string);\
    \ i++ {\n\t\tswitch string[i] {\n\t\tcase '[': \n\t\t\tif bracket == '[' {\n\t\
    \t\t\treturn true\n\t\t\t}\n\t\tcase ']':\n\t\t\tif bracket == ']' {\n\t\t\t\t\
    return true\n\t\t\t}\n\t\t}\n\t\t\n\t\tif string[i] == '[' && string[i+1] == '['\
    \ {\n\t\t\treturn true\n\t\t}\n\t}\n\t\n\treturn false", "\treturn find_brackets(string)\
    \ != nil", "    // Get a stack of open brackets\n    var stack = [0](count: Int,\
    \ repeatedValue: 0)\n\n    // Loop through the characters in the string\n    for\
    \ char in string {\n        // If we see an open bracket, increment the count\
    \ of open brackets\n        // We don't want to count a closing bracket as an\
    \ open bracket \n        if char == \"[\" {\n            stack[stack.count - 1]\
    \ += 1\n        } else if char == \"]\" {\n            // If the current count\
    \ of open brackets is even, it's invalid\n            if stack.count % 2 == 0\
    \ {\n                return false\n            }\n            // If the current\
    \ count of open brackets is odd, it's valid\n            else {\n            \
    \    stack[stack.count - 2] -= 1\n            }\n        }\n    }\n    // If we\
    \ reach here, then the string has valid nested brackets\n    return stack.count\
    \ >= 2", "\tlet stringArray = string.components(separatedBy: CharacterSet.brackets)\n\
    \tguard !stringArray.isEmpty else {\n\t\treturn false\n\t}\n\tlet nestedArray\
    \ = stringArray.filter({ $0 == \"]\" })\n\treturn nestedArray.count > 2", "\t\
    for i := 0; i < len(string); i++ {\n\t\tswitch string[i] {\n\t\tcase ']':\n\t\t\
    \treturn true\n\t\tcase '[':\n\t\t\treturn false\n\t\tdefault:\n\t\t\tif string[i]\
    \ == '{' {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn false", "\tlet\
    \ mut brackets = Stack<()>();\n\tbrackets.push(());\n\t\n\tlet mut position =\
    \ 1;\n\tfor _ in 0..string.characters.count {\n\t\tif brackets.isEmpty() {\n\t\
    \t\tbreak;\n\t\t}\n\n\t\tlet bracket = brackets.peek()[0];\n\t\t\n\t\tif string[position]\
    \ == '[' {\n\t\t\tbrackets.push((bracket, 0));\n\t\t} else if string[position]\
    \ == ']' {\n\t\t\tbrackets.pop();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\tposition\
    \ += 1;\n\t}\n\treturn brackets.isEmpty();", "\tdepth := 0\n\tbracket := 0\n\t\
    last := -1\n\tstack := [depth]string{string[:1]}\n\tfor i := 0; i < len(string);\
    \ i++ {\n\t\tswitch string[i] {\n\t\tcase '[':\n\t\t\tstack[depth] = string[i]\n\
    \t\t\tdepth++\n\t\tcase ']':\n\t\t\tif stack[depth] != string[i] {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\t\tdepth--\n\t\t\tif stack[depth] == \"\" {\n\t\t\t\treturn\
    \ true\n\t\t\t}\n\t\t\tstack[depth] = string[i]\n\t\tcase ',':\n\t\t\tif depth\
    \ == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tstack[depth] = string[i]\n\t\t\
    default:\n\t\t\tstack[depth] = string[i]\n\t\t}\n\t}\n\treturn false", "    let\
    \ input = string\n        .stringByReplacingOccurrencesOfString(\"[\", withString:\
    \ \"\", options: .CaseInsensitiveSearch, range: nil)\n        .stringByReplacingOccurrencesOfString(\"\
    ]\", withString: \"\", options: .CaseInsensitiveSearch, range: nil)\n    let characterSet\
    \ = NSCharacterSet(charactersInString: \"[]\").invertedSet\n    return string.rangeOfCharacterFromSet(characterSet)\
    \ != nil", "\tlet re = NSRegularExpression(pattern: \"^\\\\[.*\\\\]$\", options:\
    \ NSRegularExpressionOptions.RegularExpressionCaseInsensitive)\n\treturn re.firstMatchInString(string,\
    \ options: NSMatchingOptions.WithTransparentBounds, range: NSMakeRange(0, string.characters.count))\
    \ == nil", "    let brackets = regex(\"\"\"\\[\\[\\]\\]\"\"\")\n    return brackets.matching(string).hasMatch()",
  '    return is_nested(string: string, depth: 0)', "\tswitch {\n\tcase string ==\
    \ \"\": \n\t\treturn false\n\tcase len(string) == 0: \n\t\treturn false\n\tcase\
    \ len(string) == 1: \n\t\treturn true\n\tcase string[0] == '[': \n\t\treturn is_nested(string[1:len(string)-1])\n\
    \tcase string[stringLength(string) - 1] == ']':\n\t\treturn is_nested(string[1:len(string)-1])\n\
    \tcase strings.Index(string, \"[\") == stringLength(string) - 1: \n\t\treturn\
    \ is_nested(string[1:len(string)-1])\n\tdefault:\n\t\treturn false\n\t}", "\t\
    let length = string.characters.count\n\tlet pattern = bracketPattern\n\t\n\tif\
    \ length == 0 {\n\t\treturn false\n\t}\n\t\n\tfor i in 0 ..< length - pattern.characters.count\
    \ {\n\t\tif !pattern.matches(string.characters, offset: i, length: pattern.characters.count)\
    \ {\n\t\t\treturn false\n\t\t}\n\t}\n\t\n\treturn true", "\tvar index int\n\t\
    var brackets int\n\tfor index = 0; index < len(string); index++ {\n\t\tswitch\
    \ string[index] {\n\t\tcase '[':\n\t\t\tbrackets++\n\t\tcase '[':\n\t\t\tbrackets++\n\
    \t\tcase ']':\n\t\t\tbrackets--\n\t\tcase ']':\n\t\t\tbrackets--\n\t\t}\n\t\t\
    if brackets == 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false", "\tlet openingBrackets:\
    \ Set<Character> = [\"[\", \"{\", \"(\"].makeIterator()\n\tlet closingBrackets:\
    \ Set<Character> = [\"]\", \"}\", \")\"].makeIterator()\n\t\n\tguard let firstChar\
    \ = string.character(at: 0) else {\n\t\treturn false\n\t}\n\t\n\treturn openingBrackets.contains(firstChar)\
    \ && closingBrackets.contains(firstChar)", "    let substrings = string.components(separatedBy:\
    \ \"[]\")\n    return substrings.count > 1", "\treturn is_nested(string: string,\
    \ depth: 0)", "    if string == \"\" {\n        return false\n    }\n    \n  \
    \  let bracketIndex = string.index(of: \"[\")\n    if bracketIndex == -1 {\n \
    \       return false\n    }\n    \n    let rightBracketIndex = string.index(of:\
    \ \"]\", after: bracketIndex)\n    if rightBracketIndex == -1 {\n        return\
    \ false\n    }\n    \n    if string.substring(from: bracketIndex + 1).count !=\
    \ string.substring(from: rightBracketIndex).count {\n        return false\n  \
    \  }\n    \n    return true", "\t/*\n\t\tThere are several algorithms to solve\
    \ this problem:\n\n\t\t1. Find the length of the string\n\n\t\t2. Find a pair\
    \ of brackets with the largest length\n\n\t\t3. Find the location of the second\
    \ bracket\n\n\t\t4. If it's an even number then all brackets are nested else they\
    \ are not nested\n\n\t\t5. Repeat steps 2 and 3 until the length of the string\
    \ is even\n\t*/\n\n\t/*\n\t\tThis algorithm is simple to understand:\n\n\t\t1.\
    \ Find the length of the string\n\t\t2. Find the length of the longest pair of\
    \ brackets\n\t\t3. Find the location of the second longest bracket\n\t\t4. Check\
    \ if it's an even number of brackets then they all are nested else not nested\
    \ \n\t*/\n\n\t/*\n\t\tTo find length of a string we use String's method count\
    \ which takes a substring:\n\n\t\tString.count returns how many substrings does\
    \ a substring contain\n\n\t\tstring.count(\"[\")\n\t\t>>> 2\n\n\t\tstring.count(\"\
    []\")\n\t\t>>> 3\n\n\t\tstring.count(\"[[]\")\n\t\t>>> 2\n\n\t\tstring.count(\"\
    [][]\")\n\t\t>>> 3\n\t*/\n\tlet length = string.count(\"[\")\n\n\t/*\n\t\tTo find\
    \ the length of the longest pair of brackets we use substring:\n\n\t\tString's\
    \ method count takes a substring\n\n\t\tstring.count(\"[\")\n\t\t>>> 2\n\n\t\t\
    string.count(\"[]\")\n\t\t>>> 3\n\n\t\tstring.count(\"[[]\")\n\t\t>>> 2\n\n\t\t\
    string.count(\"[][]\")\n\t\t>>> 3\n\t*/\n\tlet maxBracketLength = string.count(\"\
    [\")\n\n\t/*\n\t\tTo find the location of the second longest pair of brackets\
    \ we use substring:\n\n\t\tString's method count takes a substring\n\n\t\tstring.count(\"\
    [\")\n\t\t>>> 2\n\n\t\tstring.count(\"[]\")\n\t\t>>> 3\n\n\t\tstring.count(\"\
    [[]\")\n\t\t>>> 2\n\n\t\tstring.count(\"[][]\")\n\t\t>>> 3\n\t*/\n\tlet secondLongestBracketIndex\
    \ = string.count(\"[\", maxBracketLength)\n\n\t/*\n\t\tTo check if it's an even\
    \ number of brackets we check if it's even number using %:\n\n\t\tIf (len % 2\
    \ == 0) {\n\t\t\tAll brackets are nested\n\t\t} else {\n\t\t\tAll brackets are\
    \ not nested\n\t\t}\n\t\t>>> true for strings of length 2\n\t\t>>> false for strings\
    \ of length 3\n\t*/\n\tlet isEvenLength = (length % 2) == 0\n\n\treturn isEvenLength",
  "\tlet pattern: String = \"\\\\[\\\\]\"\n\treturn string.hasPrefix(pattern) && string.endsWith(pattern)",
  "    \n    var nesting = 0\n    var charStack = [Character]()\n    var currentChar:\
    \ Character?\n    for char in string {\n        if char == \"[\" {\n         \
    \   nesting += 1\n            currentChar = char\n        } else {\n         \
    \   nesting -= 1\n            if nesting == 0 {\n                if currentChar\
    \ == nil {\n                    return false\n                } else {\n     \
    \               charStack = append(charStack, currentChar!)\n                }\n\
    \            }\n        }\n    }\n    if nesting == 0 {\n        return true\n\
    \    } else {\n        return false\n    }", "\tlet length = string.characters.count\n\
    \t\n\tif length <= 1 {\n\t\treturn false\n\t}\n\t\n\tlet index = 0\n\twhile index\
    \ < length {\n\t\tlet openIndex = string.characters.index{$0 == \"]\"}\n\t\tlet\
    \ closeIndex = string.characters.index{$0 == \"[\"}\n\t\t\n\t\tif openIndex ==\
    \ nil || closeIndex == nil {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tlet openCount\
    \ = 0\n\t\tlet closeCount = 0\n\t\t\n\t\tfor i in openIndex!..<closeIndex! {\n\
    \t\t\tif string.characters.index{$0 == \"]\"} == nil || string.characters.index{$0\
    \ == \"[\"} == nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t\n\t\t\topenCount +=\
    \ 1\n\t\t}\n\t\t\n\t\tfor i in 0..<closeIndex! {\n\t\t\tif string.characters.index{$0\
    \ == \"]\"} == nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t\n\t\t\tcloseCount\
    \ += 1\n\t\t}\n\t\t\n\t\tif closeCount < openCount {\n\t\t\treturn false\n\t\t\
    }\n\t\t\n\t\tindex = closeIndex!\n\t}\n\t\n\treturn true", "\tvar curOpen, curClose,\
    \ curNest bool\n\n\tfor _, r := range string {\n\t\tswitch r {\n\t\tcase '[':\n\
    \t\t\tif !curOpen {\n\t\t\t\tcurOpen = true\n\t\t\t\tcurNest = 0\n\t\t\t} else\
    \ {\n\t\t\t\tcurNest += 1\n\t\t\t}\n\t\tcase ']':\n\t\t\tif !curClose {\n\t\t\t\
    \tcurClose = true\n\t\t\t} else {\n\t\t\t\tcurNest -= 1\n\t\t\t}\n\t\t}\n\t\t\
    if !curOpen && !curClose {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn curNest ==\
    \ 0", "    for char in string {\n        switch char {\n        case \"[\", \"\
    ]\", \"(\", \")\":\n            return true\n        default:\n            return\
    \ false\n        }\n    }\n    return false", "\tguard string.characters.count\
    \ != 0 else {\n\t\treturn false\n\t}\n\n\tguard string.isEmpty == false else {\n\
    \t\treturn false\n\t}\n\n\tlet openParens = Set<Character>()\n\tlet closeParens\
    \ = Set<Character>()\n\tlet stack = Array<String>()\n\n\tvar index = 0\n\n\twhile\
    \ index < string.characters.count {\n\t\tguard openParens.contains(string.characters[index])\
    \ == false else {\n\t\t\tlet substr = String(string.characters[index...])\n\t\t\
    \tstack.append(substr)\n\t\t\topenParens.insert(substr.first!)\n\t\t\tcloseParens.remove(substr.last!)\n\
    \t\t\tindex++\n\t\t}\n\t\tguard closeParens.contains(string.characters[index])\
    \ == false else {\n\t\t\tlet substr = String(string.characters[index...])\n\t\t\
    \tif stack.isEmpty {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif substr == stack.removeLast()\
    \ {\n\t\t\t\topenParens.remove(substr.first!)\n\t\t\t\tcloseParens.insert(substr.last!)\n\
    \t\t\t\tindex++\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\t\
    return !openParens.isEmpty", "\tguard let pattern = brackets_pattern, let regex\
    \ = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) else\
    \ {\n\t\treturn false\n\t}\n\treturn regex.numberOfMatches(in: string, range:\
    \ NSMakeRange(0, string.utf16.count)) > 0 ", "\tlet bracket_pairs = [\n\t\t[false,\
    \ false],\n\t\t[true, true],\n\t\t[false, true],\n\t\t[false, false],\n\t\t[true,\
    \ true],\n\t]\n\tlet open_brackets = string.rangeOfString(\"[\")\n\tlet close_brackets\
    \ = string.rangeOfString(\"]\")\n\tif open_brackets == nil || close_brackets ==\
    \ nil {\n\t\treturn false\n\t}\n\tlet open_brackets_index = open_brackets?.location\n\
    \tlet close_brackets_index = close_brackets?.location\n\tlet open_length = close_brackets_index\
    \ - open_brackets_index\n\tlet close_length = open_brackets_index - close_brackets_index\n\
    \tif open_length < 1 || close_length < 1 {\n\t\treturn false\n\t}\n\tlet index\
    \ = open_brackets_index + 1\n\tlet open_lengths = Array(repeating: 0, count: open_length\
    \ + 1)\n\tlet close_lengths = Array(repeating: 0, count: close_length + 1)\n\t\
    for bracket_pair in bracket_pairs {\n\t\topen_lengths[bracket_pair[0]] = index\n\
    \t\tclose_lengths[bracket_pair[1]] = index\n\t\tindex += 2\n\t}\n\tvar stack =\
    \ [Character]()\n\twhile index < string.characters.count {\n\t\tlet char = string.characters[index]\n\
    \t\tlet open_length = open_lengths[char]\n\t\tlet close_length = close_lengths[char]\n\
    \t\tlet open_brackets = open_length != nil && close_length != nil && open_length\
    \ == close_length\n\t\tlet close_brackets = open_length != nil && close_length\
    \ != nil && open_length != close_length\n\t\tif open_brackets || close_brackets\
    \ {\n\t\t\tlet open_char = string.characters[open_length!]\n\t\t\tlet close_char\
    \ = string.characters[close_length!]\n\t\t\tstack.append(char)\n\t\t\tif open_char\
    \ == \"[\" {\n\t\t\t\topen_lengths[open_char] = nil\n\t\t\t\tclose_lengths[close_char]\
    \ = nil\n\t\t\t}\n\t\t\tif close_char == \"]\" {\n\t\t\t\topen_lengths[open_char]\
    \ = nil\n\t\t\t\tclose_lengths[close_char] = nil\n\t\t\t}\n\t\t} else {\n\t\t\t\
    if stack.isEmpty {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tlet open_char = stack.removeLast()\n\
    \t\t\tlet close_char = stack.removeLast()\n\t\t\tif open_char != close_char {\n\
    \t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tindex++\n\t}\n\treturn true", "\tguard\
    \ string.characters.count >= 2 else {\n\t\treturn false\n\t}\n\tlet openBrackets:\
    \ Set<Character> = [openBracketOpen, openBracketClose]\n\tguard let firstChar\
    \ = string.characters.first else {\n\t\treturn false\n\t}\n\tguard openBrackets.contains(firstChar)\
    \ else {\n\t\treturn false\n\t}\n\tguard let lastChar = string.characters.last\
    \ else {\n\t\treturn false\n\t}\n\tguard lastChar == closeBracketClose else {\n\
    \t\treturn false\n\t}\n\tlet nextLastChar = string.characters[string.characters.index(string.startIndex,\
    \ offsetBy: -1)]\n\tguard nextLastChar == closeBracketOpen else {\n\t\treturn\
    \ false\n\t}\n\treturn true", "    \n    let index = 0\n    var index0 = 0\n \
    \   var index1 = 0\n    var index2 = 0\n    var bracket_count = 0\n    var start_bracket\
    \ = false // First bracket encountered that hasn't been closed yet.\n    \n  \
    \  for c in string {\n        if c == '[' {\n            if start_bracket == false\
    \ {\n                start_bracket = true\n                index0 = index\n  \
    \          } else {\n                start_bracket = false\n                index1\
    \ = index\n            }\n            \n        } else if c == ']' {\n       \
    \     if start_bracket == true {\n                index2 = index\n           \
    \     bracket_count += 1\n                \n                if bracket_count ==\
    \ 1 {\n                    return true\n                }\n                \n\
    \            } else {\n                bracket_count = 0\n            }\n    \
    \        \n        } else {\n            start_bracket = false\n        }\n  \
    \      \n        index += 1 // Move to the next character.\n    }\n    \n    return\
    \ false", "\tlet stack = Array<Character>()\n\t\n\tlet open_brackets = string.unicodeScalars\n\
    \t\t.filter({ $0.isBracketLeft_ })\n\t\t.filter({ $0.isBracketRight_ })\n\t\t\
    .filter({ $0.isBracketLeft_ || $0.isBracketRight_ })\n\t\n\tguard open_brackets.count\
    \ > 0 else {\n\t\treturn false\n\t}\n\t\n\tguard let open_bracket = open_brackets.first\
    \ else {\n\t\treturn false\n\t}\n\t\n\tstack.insert(open_bracket)\n\t\n\twhile\
    \ stack.count > 0 {\n\t\t\n\t\tlet curr_bracket = stack.removeLast()\n\t\t\n\t\
    \tif curr_bracket.isBracketLeft_ {\n\t\t\tif open_bracket.isBracketRight_ {\n\t\
    \t\t\tstack.insert(Character(\"}\"))\n\t\t\t} else {\n\t\t\t\tstack.insert(Character(\"\
    {\"))\n\t\t\t}\n\t\t} else {\n\t\t\tif open_bracket.isBracketRight_ {\n\t\t\t\t\
    stack.insert(Character(\"]]\"))\n\t\t\t} else {\n\t\t\t\tstack.insert(Character(\"\
    ]]\"))\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn stack.count == 0", "    var result:\
    \ Bool = false\n    let input = string.stringByReplacingOccurrencesOfString(\"\
    [[\", withString: \"\", options: .LiteralSearch, range: nil)\n    let bracket\
    \ = string.replacingOccurrencesOfString(\"[]\", withString: \"\", options: .LiteralSearch,\
    \ range: nil)\n    let brackets = string.replacingOccurrencesOfString(\"]]\",\
    \ withString: \"\", options: .LiteralSearch, range: nil)\n    if input.hasPrefix(\"\
    [\") && bracket.hasSuffix(\"]\") && brackets.hasPrefix(\"[\") && brackets.hasSuffix(\"\
    ]\") {\n        result = true\n    }\n    return result", "\t\n\tguard let data\
    \ = string.data(using: .utf8) else { return false }\n\t\n\tlet string = data.utf8String\n\
    \t\n\tlet openingBrackets = string.unicodeScalars.filter({ $0.isOpen })\n\t\n\t\
    return openingBrackets.count > 0 && openingBrackets.count < string.unicodeScalars.count",
  "\tstring.rev()\n\t\n\tguard let i = strings.firstIndex(of: \"[\"), let j = strings.firstIndex(of:\
    \ \"]\") else {\n\t\treturn false\n\t}\n\t\n\treturn j - i >= 1", "    if let\
    \ openingBracketIndex = string.firstIndex(of: \"[\") {\n        let closingBracketIndex\
    \ = string.index(of: \"]\", in: string.endIndex)\n        return closingBracketIndex\
    \ != nil && closingBracketIndex - openingBracketIndex == 1\n    }\n    return\
    \ false", "    let brackets = Set(\"[]\")\n    \n    for character in string {\n\
    \        if brackets.contains(character) {\n            brackets.insert(character)\n\
    \            return true\n        }\n    }\n    \n    return false", "\tvar stack\
    \ = [String]()\n\tvar openingBrackets: [String] = []\n\tvar closingBrackets: [String]\
    \ = []\n\t\n\tvar i : Int = 0\n\t\n\twhile i < string.count {\n\t\tif string[i]\
    \ == '[' {\n\t\t\tstack.append(string[i:])\n\t\t\topeningBrackets.append(string[i:])\n\
    \t\t} else if string[i] == ']' {\n\t\t\tif stack.isEmpty {\n\t\t\t\treturn false\n\
    \t\t\t}\n\t\t\tclosingBrackets.append(string[i:])\n\t\t} else {\n\t\t\tstack.removeLast()\n\
    \t\t}\n\t\ti += 1\n\t}\n\n\t\n\t\n\tfor _, closingBracket in closingBrackets {\n\
    \t\tif openingBrackets.isEmpty {\n\t\t\treturn false\n\t\t}\n\t\tfor openingBracket\
    \ in openingBrackets {\n\t\t\tif openingBracket.hasPrefix(closingBracket) {\n\t\
    \t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false", "    if let str = string,\n\
    \        let openBracket = str.rangeOfString(\"[\"),\n        let closeBracket\
    \ = str.rangeOfString(\"]\") {\n        let openBracketIndex = str.startIndex.distanceTo(openBracket)\n\
    \        let closeBracketIndex = str.startIndex.distanceTo(closeBracket)\n   \
    \     let lastCloseBracketIndex = str.endIndex.distanceTo(closeBracket)\n    \
    \    \n        if openBracketIndex + 1 == closeBracketIndex {\n            let\
    \ subsequence = str.substringWithRange(Range(start: openBracketIndex, end: lastCloseBracketIndex))\n\
    \            if let validSubsequence = subsequence.countBrackets() {\n       \
    \         return validSubsequence > 1\n            }\n        }\n    }\n    return\
    \ false", "    var openBrackets = 0\n    var closeBrackets = 0\n    for _, c :=\
    \ range string {\n        if c == '[' {\n            openBrackets++\n        }\
    \ else if c == ']' {\n            closeBrackets++\n        } else if openBrackets\
    \ == 0 && closeBrackets == 0 {\n            return false\n        }\n    }\n \
    \   return openBrackets + closeBrackets > 0", "    var count = 0\n    var inNestedBracket\
    \ = false\n    var inOuterBracket = false\n    var inEscape = false\n    \n  \
    \  for _ in string.characters {\n        let _ = string.character(at: count)\n\
    \        guard inNestedBracket && inOuterBracket && inEscape else { continue }\n\
    \        \n        if inNestedBracket {\n            if string.character(at: count)\
    \ != \"]\" {\n                inNestedBracket = false\n                continue\n\
    \            }\n            \n            count += 1\n            \n         \
    \   if count == string.endIndex {\n                return true\n            }\n\
    \            \n            count += 1 // skip the ']'\n            \n        \
    \    guard string.character(at: count) == \"[\" else { continue }\n          \
    \  \n            inNestedBracket = false\n            inOuterBracket = true\n\
    \        }\n        else if inOuterBracket {\n            if string.character(at:\
    \ count) != \"]\" {\n                inOuterBracket = false\n                continue\n\
    \            }\n            \n            count += 1\n            \n         \
    \   if count == string.endIndex {\n                return true\n            }\n\
    \            \n            count += 1 // skip the ']'\n            \n        \
    \    guard string.character(at: count) == \"[\" else { continue }\n          \
    \  \n            inOuterBracket = false\n        }\n        else if inEscape {\n\
    \            if string.character(at: count) == \"\\\\\" {\n                inEscape\
    \ = false\n                continue\n            }\n            \n           \
    \ if string.character(at: count) == \"[\" {\n                inNestedBracket =\
    \ true\n                continue\n            }\n            \n            if\
    \ string.character(at: count) == \"]\" {\n                inNestedBracket = false\n\
    \                continue\n            }\n            \n            if string.character(at:\
    \ count) == \"{\" {\n                inOuterBracket = true\n                continue\n\
    \            }\n            \n            if string.character(at: count) == \"\
    }\" {\n                inOuterBracket = false\n                continue\n    \
    \        }\n            \n            if string.character(at: count) == \"`\"\
    \ {\n                inEscape = true\n                continue\n            }\n\
    \            \n            continue // skip the '\\', '[', ']', '}', '`'\n   \
    \     }\n        \n        guard string.character(at: count) == \"[\" else { continue\
    \ }\n        \n        count += 1\n        \n        if count == string.endIndex\
    \ {\n            return true\n        }\n        \n        count += 1 // skip\
    \ the '['\n        \n        guard string.character(at: count) == \"]\" else {\
    \ continue }\n    }\n    \n    return false", "    let brackets = (0..<string.count).filter({\
    \ $0 != string[$0] })\n    return brackets.isEmpty ? false : brackets.contains(string.count\
    \ - 1)", "\tlet brackets = string\n\tguard brackets.contains(\"[\") else { return\
    \ false }\n\tguard brackets.contains(\"]\") else { return false }\n\tguard brackets.contains(\"\
    (\") else { return false }\n\tguard brackets.contains(\")\") else { return false\
    \ }\n\treturn true", "\tguard let charStack = CharacterStack(string.characters).stack\
    \ else {\n\t\treturn false\n\t}\n\tlet startIndex: Int = charStack.count\n\t\n\
    \tlet openingBracketsStack = CharacterStack(string.characters).stack\n\tlet closingBracketsStack\
    \ = CharacterStack(string.characters).stack\n\t\n\tguard !openingBracketsStack.isEmpty\
    \ && !closingBracketsStack.isEmpty else {\n\t\treturn false\n\t}\n\t\n\tlet openingIndex\
    \ = openingBracketsStack.count - 1\n\tlet closingIndex = closingBracketsStack.count\
    \ - 1\n\t\n\tguard openingBracketsStack.contains(closingBracketsStack[openingIndex])\
    \ else {\n\t\treturn false\n\t}\n\t\n\tguard openingBracketsStack[openingIndex].bracketType\
    \ == BracketType.Open else {\n\t\treturn false\n\t}\n\t\n\tguard closingBracketsStack[closingIndex].bracketType\
    \ == BracketType.Close else {\n\t\treturn false\n\t}\n\t\n\tguard openingIndex\
    \ != closingIndex else {\n\t\treturn false\n\t}\n\t\n\tguard closingBracketsStack[closingIndex].nestingLevel\
    \ == openingBracketsStack[openingIndex].nestingLevel + 1 else { // Brackets are\
    \ nested.\n\t\treturn false\n\t}\n\t\n\treturn true", "\tvar lastIndex = string.lastIndexOf(\"\
    [\")\n\tif lastIndex < 0 {\n\t\treturn false\n\t}\n\t\n\tfor i := lastIndex +\
    \ 1; i < len(string); i++ {\n\t\tif string[i] == \"[\"  || string[i] == \"]\"\
    \ || string[i] == \"{\" || string[i] == \"}\" {\n\t\t\treturn true\n\t\t}\n\t\
    }\n\t\n\treturn false", "\tlet start = string.startIndex\n\tlet end = string.endIndex\n\
    \t\n\tvar depth = 0\n\t\n\twhile start < end {\n\t\tif let b = string.unicodeScalars[start].value,\
    \ b == '[' {\n\t\t\tdepth += 1\n\t\t} else if let b = string.unicodeScalars[start].value,\
    \ b == '{' {\n\t\t\tdepth += 2\n\t\t} else if let b = string.unicodeScalars[start].value,\
    \ b == '(' { \n\t\t\tdepth += 3\n\t\t} else if let b = string.unicodeScalars[start].value,\
    \ b == ']' {\n\t\t\tdepth -= 1\n\t\t\tif depth == 0 {\n\t\t\t\treturn true\n\t\
    \t\t}\n\t\t} else if let b = string.unicodeScalars[start].value, b == '}' {\n\t\
    \t\tdepth -= 2\n\t\t\tif depth == 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t} else\
    \ if let b = string.unicodeScalars[start].value, b == '[' {\n\t\t\tdepth -= 1\n\
    \t\t} else if let b = string.unicodeScalars[start].value, b == ']' {\n\t\t\tdepth\
    \ -= 1\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tstart = end + 1\n\t\
    }\n\t\n\treturn false", "    // Find a pair of brackets with a length greater\
    \ than or equal to 2.\n    // If such pair doesn't exist, there are no nested\
    \ brackets.\n    let openingBracket = find(string, substring: \"[\", startingAt:\
    \ 0)\n    let closingBracket = find(string, substring: \"]\", startingAt: openingBracket)\n\
    \n    // If no pair of brackets were found, no nested brackets exist in the string.\n\
    \    guard openingBracket != nil && closingBracket != nil else {\n        return\
    \ false\n    }\n\n    // Find the nearest pair of brackets.\n    // If there is\
    \ no such pair, there are no nested brackets in the string.\n    let innerOpeningBracket\
    \ = find(string, substring: \"[\", startingAt: openingBracket! + 1)\n    let innerClosingBracket\
    \ = find(string, substring: \"]\", startingAt: innerOpeningBracket!)\n\n    //\
    \ If the number of nested brackets is equal to the number of opening brackets\
    \ + number of closing brackets,\n    // the string is valid (nesting brackets).\n\
    \    return innerOpeningBracket != nil && innerClosingBracket != nil && innerClosingBracket!\
    \ - innerOpeningBracket! == 2 &&\n        innerClosingBracket! - openingBracket!\
    \ > 1", "\tvar count int\n\tbrackets := []rune(string)\n\ti := 0\n\tlength :=\
    \ len(brackets)\n\tvar hasNested bool\n\tfor i < length {\n\t\tswitch brackets[i]\
    \ {\n\t\tcase ']':\n\t\t\tcount--\n\t\t\tif count < 0 {\n\t\t\t\thasNested = true\n\
    \t\t\t\tbreak\n\t\t\t}\n\t\tcase ']':\n\t\t\tcount++\n\t\t\tif count < 0 {\n\t\
    \t\t\thasNested = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n\treturn\
    \ hasNested", "    var position = 0\n    let length = string.characters.count\n\
    \    \n    func is_nested(position: Int, string: String) -> Bool {\n        guard\
    \ position < length else { return false }\n        \n        if string[position]\
    \ == '[' && position < length-1 && string[position + 1] == ']' {\n           \
    \ is_nested(position + 2, string)\n        } else {\n            return true\n\
    \        }\n    }\n    \n    guard is_nested(position, string) else {\n      \
    \  return false\n    }\n    \n    return true", "\treturn contains_bracket_nested(string)",
  "    var position = 0\n    for position < string.count {\n        if string[position]\
    \ == '[' {\n            position++\n            if position < string.count {\n\
    \                if string[position] == '[' {\n                    position++\n\
    \                }\n                if string[position] == ']' {\n           \
    \         position++\n                }\n            }\n        }\n    }\n   \
    \ return position >= string.count", "    let opening_brackets = \"([{\"\n    let\
    \ closing_brackets = \")]}\"\n    let close_brackets = \")]\"\n    let brackets_set\
    \ = Set(opening_brackets, closing_brackets)\n    let brackets_size = string.count\n\
    \n    guard let firstBracket = string.index(of: \"[\"),\n        string.count\
    \ >= 1 else {\n            return false\n    }\n\n    guard let lastBracket =\
    \ string.index(of: close_brackets),\n        lastBracket != brackets_size-1 else\
    \ {\n            return false\n    }\n\n    let nestedBracketsCount = brackets_size.flatMap\
    \ { string[string.index($0, offsetBy: 1)..<string.index(close_brackets, offsetBy:\
    \ 1)].contains(opening_brackets) }\n    let nestedBracketsCountCount = nestedBracketsCount.reduce(0,\
    \ +)\n\n    return nestedBracketsCountCount == brackets_size", "\tlet stack =\
    \ [String]()\n\tfor symbol in string {\n\t\tif symbol == \"]\" {\n\t\t\tif stack.isEmpty\
    \ {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif stack.last != \"]\" {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\t\tstack.removeLast()\n\t\t} else if symbol == \"[\" {\n\t\
    \t\tif stack.isEmpty {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif stack.last !=\
    \ \"[\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tstack.removeLast()\n\t\t} else\
    \ {\n\t\t\tstack.append(symbol)\n\t\t}\n\t}\n\tif stack.isEmpty {\n\t\treturn\
    \ true\n\t}\n\treturn false", "\tlet string = string\n\tlet length = string.characters.count\n\
    \n\tguard length > 0 && length > 2 else {\n\t\treturn false\n\t}\n\n\t// Initialize\
    \ stack by pushing first opening bracket\n\tvar stack = [Character]()\n\tstack.append(Character(\"\
    [\"))\n\t\n\tfor i in 0..<length {\n\t\tif let c = string.characters[i] {\n\t\t\
    \tif c == \"[\" {\n\t\t\t\tif stack.last?.characters.count != 1 {\n\t\t\t\t\t\
    return false\n\t\t\t\t}\n\t\t\t\tstack.append(Character(c))\n\t\t\t} else if c\
    \ == \"]\" {\n\t\t\t\tif stack.last?.characters.count != 0 {\n\t\t\t\t\treturn\
    \ false\n\t\t\t\t}\n\t\t\t\tstack.removeLast()\n\t\t\t} else {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true",
  "    let regex = try! NSRegularExpression(pattern: \"\\\\[|\\\\]\", options: .CaseInsensitive)\n\
    \    return regex.firstMatchInString(string, options: .MatchingInexactly)?.rangeAtIndex(1)?.location\
    \ != NSNotFound", "\tlet string = string.trim()\n\tif string.count == 0 || string[0]\
    \ != \"[\" {\n\t\treturn false\n\t}\n\n\tvar left = 0\n\tvar right = 0\n\t\n\t\
    for index in 0..<string.count {\n\t\tif string[index] == \"[\" {\n\t\t\tleft++\n\
    \t\t} else if string[index] == \"}\" {\n\t\t\tright--\n\t\t}\n\n\t\tif right <\
    \ 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn (right == 0)", "    if let firstBracketIndex\
    \ = string.index(of: \"[\") {\n        if let lastBracketIndex = string.index(of:\
    \ \"]\") {\n            return firstBracketIndex < lastBracketIndex\n        }\
    \ else {\n            return false\n        }\n    } else {\n        return false\n\
    \    }", "\tlet open_brackets: Set<String> = Set([String]())\n\tlet close_brackets:\
    \ Set<String> = Set([String]())\n\tfor symbol in string {\n\t\tif symbol == \"\
    [\" {\n\t\t\topen_brackets.insert(symbol)\n\t\t} else if symbol == \"]\" {\n\t\
    \t\tclose_brackets.insert(symbol)\n\t\t}\n\t}\n\t\n\tlet bracket_open = open_brackets.count()\
    \ > open_brackets.countDoubledUp()\n\tlet bracket_close = close_brackets.count()\
    \ > close_brackets.countDoubledUp()\n\tlet both_close_brackets = bracket_open\
    \ && bracket_close\n\tlet only_open_open_close = open_brackets.count() == open_brackets.countDoubledUp()\n\
    \tlet only_close_open_open = close_brackets.count() == close_brackets.countDoubledUp()\n\
    \t\n\treturn both_close_brackets || only_open_open_close || only_close_open_open",
  "    if string == \"\" {\n        return false\n    }\n    let open = string[0]\n\
    \    let close = string[string.endIndex-1]\n    return is_opened(open) && is_closed(close)",
  "    switch strings.Count(string, startWith: \"[\") {\n    case 0:\n        return\
    \ false\n    case 1:\n        return false\n    case 2:\n        return true\n\
    \    default:\n        return true\n    }", "\t\n\tlet open_brackets = countMatches(string:\
    \ string.stringByReplacingOccurrencesOfString(\"[\", withString: \"\", options:\
    \ .LiteralSearch, range: nil))\n\tlet closed_brackets = countMatches(string: string.stringByReplacingOccurrencesOfString(\"\
    ]\", withString: \"\", options: .LiteralSearch, range: nil))\n\t\n\treturn open_brackets\
    \ == closed_brackets", "\tif let stringToTest = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())\
    \ {\n\t\tif stringToTest.characters.count != stringToTest.rangeOfString(\"[]\"\
    ).location {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true", "\tlet index = string.characters.count\n\
    \t\n\tif index == 0 {\n\t\treturn true\n\t}\n\t\n\tlet stack = [String]()\n\t\n\
    \tfor i in 0 ..< index {\n\t\tif let c = string.characters[i] {\n\t\t\tlet index\
    \ = stack.count\n\t\t\tlet newStack = stack + [c]\n\t\t\t\n\t\t\tif c == \"[\"\
    \ {\n\t\t\t\tstack.append(c)\n\t\t\t} else if c == \"{\" {\n\t\t\t\tif stack.count\
    \ < 2 {\n\t\t\t\t\treturn false\n\t\t\t\t} else {\n\t\t\t\t\tstack.removeLast()\n\
    \t\t\t\t}\n\t\t\t} else if c == \"]\" {\n\t\t\t\tif stack.count < 2 {\n\t\t\t\t\
    \treturn false\n\t\t\t\t} else {\n\t\t\t\t\tstack.removeLast()\n\t\t\t\t}\n\t\t\
    \t} else if c == \"]\" {\n\t\t\t\tif stack.count < 2 {\n\t\t\t\t\treturn false\n\
    \t\t\t\t} else {\n\t\t\t\t\tstack.removeLast()\n\t\t\t\t}\n\t\t\t} else if c ==\
    \ \"}\" {\n\t\t\t\tif stack.count == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t} else\
    \ {\n\t\t\t\t\tstack.removeLast()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif stack.count\
    \ != 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif stack.count\
    \ != index {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true", "\t\
    brackets := 0\n\ti := 0\n\tfor i < len(string) {\n\t\tc := string[i]\n\t\tif c\
    \ == '[' {\n\t\t\tbrackets++\n\t\t}\n\t\tif c == ']' {\n\t\t\tbrackets--\n\t\t\
    }\n\t\tif brackets < 0 {\n\t\t\treturn false\n\t\t}\n\t\ti++\n\t}\n\treturn brackets\
    \ == 0", "\t// Check if the string contains only brackets\n\tlet bracket_stack\
    \ = [String]()\n\tlet bracket_count = 0\n\tfor bracket in string {\n\t\tif bracket\
    \ == \"[\" {\n\t\t\tbracket_stack.insert(\"[\")\n\t\t\tbracket_count += 1\n\t\t\
    } else if bracket == \"]\" {\n\t\t\tbracket_stack.removeLast()\n\t\t\tbracket_count\
    \ -= 1\n\t\t}\n\t}\n\n\treturn bracket_stack.isEmpty || (bracket_count == 0)",
  "\tlet bracket_regex = \"(\\\\[|\\\\]|\\\\{|\\\\}|\\\"|\\\\')\"\n\tlet bracket_counts\
    \ = string.components(separatedBy: bracket_regex).count\n\treturn bracket_counts\
    \ != 1 && bracket_counts != 0", "    // check for empty string\n    if string\
    \ == \"\" {\n        return false\n    }\n\n    // check first character\n   \
    \ if string[0] != \"[\" {\n        return false\n    }\n\n    // check remaining\
    \ string\n    let index = string.rangeOfString(\"[\")\n    if index == nil ||\
    \ index.endIndex < string.endIndex {\n        return false\n    }\n\n    // if\
    \ we get to here, the string contains a valid subsequence with at least one open\
    \ bracket\n    return true", "    // Your code here\n    if let string = string\
    \ {\n        for c in string {\n            if let c = c {\n                if\
    \ let foundBracket = Brackets.firstIndex(of: c) {\n                    if Brackets[foundBracket+1].first\
    \ == foundBracket {\n                        return true\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return false", '    return
    has_nested_brackets(string)', "\tlet chars: [Character] = string.characters;\n\
    \tvar stack: Stack<Character> = Stack<Character>();\n\n\tfor char in chars {\n\
    \t\tif char == '[' || char == ']' {\n\t\t\tstack.push(char)\n\t\t}\n\t\tif char\
    \ == '{' || char == '}' {\n\t\t\tif stack.isEmpty() {\n\t\t\t\treturn false\n\t\
    \t\t} else {\n\t\t\t\tstack.pop()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stack.isEmpty()",
  "    var bracketCount = 0\n    var startIndex = string.startIndex\n    for ind in\
    \ startIndex..<string.endIndex {\n        let ch = string[ind]\n        if ch\
    \ == '[' {\n            bracketCount++\n        } else if ch == ']' {\n      \
    \      bracketCount--\n        } else if bracketCount == 0 {\n            return\
    \ false\n        }\n    }\n    if bracketCount == 0 {\n        return true\n \
    \   } else {\n        return false\n    }", "\tlet stack = [String]()\n\tlet index\
    \ = string.startIndex\n\tfor i in 0..<string.count {\n\t\tif string[i] == '['\
    \ {\n\t\t\tstack.append(string[i])\n\t\t}\n\t\tif string[i] == ']' {\n\t\t\tif\
    \ stack.count > 0 {\n\t\t\t\tlet currentBracket = stack.removeLast()\n\t\t\t\t\
    if currentBracket != '[' && currentBracket != '(' {\n\t\t\t\t\treturn false\n\t\
    \t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.count == 0", "\tguard let firstBracket\
    \ = string.firstIndex(of: \"[\"),\n\t\tlet lastBracket = string.lastIndex(of:\
    \ \"]\"),\n\t\tfirstBracket != lastBracket else {\n\t\t\treturn false\n\t}\n\n\
    \treturn (firstBracket + 1) < lastBracket", "    \n    let str = string + \"]\"\
    \n    let strLength = str.characters.count\n    \n    if strLength == 0 {\n  \
    \      return true\n    }\n    \n    let firstChar = str.characters[0]\n    \n\
    \    if firstChar == \"[\" || firstChar == \"{\" || firstChar == \"(\" || firstChar\
    \ == \")\" {\n        return false\n    }\n    \n    let firstBracket = firstChar\n\
    \    \n    \n    for i in 1..<str.characters.count {\n        let currChar = str.characters[i]\n\
    \        \n        if currChar == \"[\" {\n            firstBracket = currChar\n\
    \        }\n        \n        if currChar == \"]\" && firstBracket == \"[\"  {\n\
    \            return true\n        }\n        \n        if currChar == \"{\" &&\
    \ firstBracket == \"{\" {\n            return true\n        }\n        \n    \
    \    if currChar == \"(\" && firstBracket == \"(\" {\n            return true\n\
    \        }\n        \n        if currChar == \")\" && firstBracket == \")\" {\n\
    \            return true\n        }\n    }\n    \n    return false", "    if let\
    \ data = string.data(using: .utf8) {\n        let scanner = Scanner(data: data)\n\
    \        var nesting = 0\n        var nestedBrackets = 0\n        var nextChar\
    \ = scanner.scanUpTo(\"[]\")\n        while nextChar != nil {\n            nesting\
    \ += 1\n            nestedBrackets += 1\n            if nextChar == scanner.scanUpTo(\"\
    []\") {\n                nesting += 1\n                nestedBrackets += 1\n \
    \           }\n            nextChar = scanner.scanUpTo(\"[]\")\n        }\n  \
    \      if nestedBrackets == nesting {\n            return true\n        }\n  \
    \  }\n    return false", "\tlet pattern = #r\"(\\(\\[[^\\[]+\\]\\))\"\n\tlet regex\
    \ = try NSRegularExpression(pattern: pattern, options: NSRegularExpressionOptions.CaseInsensitive)\n\
    \treturn regex.numberOfMatchesInString(string, options: [], range: NSMakeRange(0,\
    \ string.characters.count)) != 0", "    // TODO: Add support for escaped brackets.\n\
    \    if let brackets = string.range(of: \"[]\") {\n        for bracket in brackets.upperBound\
    \ ..< string.endIndex {\n            if let bracket = string.range(of: \"[]\"\
    , range: bracket) {\n                if string.distance(from: bracket, to: bracket.upperBound)\
    \ < 2 {\n                    return true\n                }\n            } else\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ false", "\tlet brackets = string.characters\n\treturn brackets.count >= 2 &&\n\
    \t\tbrackets.contains(\"]\", options: .literal, range: Range<String.Index>(start:\
    \ 0, end: brackets.count - 1)) &&\n\t\tbrackets.contains(\"[\", options: .literal,\
    \ range: Range<String.Index>(start: brackets.count - 1, end: brackets.count))",
  "    \n    let chars = string.characters\n    \n    if chars.isEmpty() {\n     \
    \   return true\n    }\n    \n    let stack = [Character]()\n    let bracketsCounts\
    \ = [Character]()\n    \n    var index = 0\n    while index < chars.count {\n\
    \        let char = chars[index]\n        \n        switch char {\n        case\
    \ '[':\n            stack.append(char)\n            bracketsCounts.append(0)\n\
    \            \n        case \"[\":\n            if stack.count < 2 {\n       \
    \         return false\n            }\n            \n            let prevChar\
    \ = stack.removeLast()\n            let curChar = chars[index+1]\n           \
    \ \n            if prevChar == \"]\" && curChar == \"]\" {\n                bracketsCounts[index]\
    \ += 2\n            }\n            else if prevChar == \"]\" && curChar == \"\
    [\" {\n                bracketsCounts[index] += 1\n            }\n           \
    \ else if prevChar == \"[\" && curChar == \"]\" {\n                bracketsCounts[index]\
    \ -= 1\n            }\n            \n        default:\n            bracketsCounts[index]\
    \ += 1\n        }\n        \n        index += 1\n    }\n    \n    if bracketsCounts.count\
    \ != 0 {\n        return false\n    }\n    \n    return true", "\tguard let regex\
    \ = try! NSRegularExpression(pattern: \"\\\\[\\\\]\", options: .caseInsensitive)\
    \ else { return false }\n\tlet range = NSMakeRange(0, string.utf16.count)\n\t\
    let numberOfOpenBrackets = regex.numberOfMatches(in: string, options: [], range:\
    \ range)\n\treturn numberOfOpenBrackets > 0", "    for _, bracket := range string\
    \ {\n        if !valid_bracket(string.Index(bracket)) {\n            return false\n\
    \        }\n    }\n    return true", "\tguard let characters = string.unicodeScalars.filter({\
    \ $0.isInverted }) else { return false }\n\tguard let startIndex = string.unicodeScalars.index(of:\
    \ \"[\"), let endIndex = string.unicodeScalars.index(of: \"]\") else {\n\t\treturn\
    \ false\n\t}\n\tlet range = NSRange(location: startIndex, length: endIndex - startIndex\
    \ + 1)\n\tguard let searchRange = string.range(of: \"[[\", options: .backwards)\
    \ else { return false }\n\tlet index = string.index(before: searchRange.endIndex)\n\
    \treturn characters[range] >= characters[index] ", "    if let open_bracket =\
    \ string.index(of: \"[\") {\n        let close_bracket = string.index(of: \"]\"\
    , after: open_bracket)\n        return close_bracket == nil || close_bracket >\
    \ open_bracket\n    }\n    return false", "\tguard let index = string.index(of:\
    \ \"[\"), string.index(of: \"]\") else {\n\t\treturn false\n\t}\n\tlet start =\
    \ string.index(before: index)\n\tlet end = string.index(string, in: index)\n\t\
    return start < end && !is_nested(string: string, start: start, end: end)", "\t\
    let counts : [String: Int] = [:]\n\tfor char in string.characters {\n\t\tcounts[String(char)]\
    \ = counts[String(char)] ?? 0\n\t\tif counts[String(char)] > 2 {\n\t\t\treturn\
    \ false\n\t\t}\n\t\tcounts[String(char)]++\n\t}\n\tfor char in string.characters\
    \ {\n\t\tif counts[String(char)] < 2 {\n\t\t\treturn false\n\t\t}\n\t\tcounts[String(char)]--\n\
    \t}\n\treturn true", "    let openBrackets = \"[[\"\n    let closeBrackets = \"\
    ]]]\"\n    \n    for index in 0..<string.count {\n        let currentChar = string[index]\n\
    \        if openBrackets.characters.contains(currentChar) {\n            for char\
    \ in string.characters {\n                if !closeBrackets.characters.contains(char)\
    \ && char != currentChar {\n                    return false\n               \
    \ }\n            }\n            return true\n        }\n        if currentChar\
    \ == closeBrackets.characters.first {\n            return false\n        }\n \
    \   }\n    return false", "    var bracketCount = 0\n    var openBracketCount\
    \ = 0\n    var openBracketNesting = 0\n    for _, bracket := range string {\n\
    \        if bracketCount == 0 && bracket == '[' {\n            openBracketCount++\n\
    \        }\n        if bracketCount == 0 && bracket == ']' {\n            openBracketCount--\n\
    \        }\n        if bracketCount == 0 && bracket == '[' {\n            openBracketNesting++\n\
    \        }\n        if bracketCount == 0 && bracket == ']' {\n            openBracketNesting--\n\
    \        }\n        if bracketCount >= 0 {\n            bracketCount--\n     \
    \   }\n    }\n    if bracketCount > 0 {\n        return false\n    }\n    return\
    \ openBracketNesting == 0", "    guard let string = string.stringByReplacingOccurrencesOfString(\"\
    [\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\
    \ else {\n        return false\n    }\n    var brackets = [Character]()\n    for\
    \ char in string {\n        guard char == \"[\" else {\n            return false\n\
    \        }\n        brackets.append(char)\n    }\n    return brackets.countOpenBrackets()\
    \ == brackets.countClosedBrackets()", "\tresult := true\n\tvar i int\n\tfor i\
    \ := 0; i < len(string); i++ {\n\t\tif string[i] == '[' {\n\t\t\tresult = result\
    \ && is_nested(string[i:])\n\t\t}\n\t\tif string[i] == ']' {\n\t\t\tif result\
    \ {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tresult = result && is_nested(string[i:])\n\
    \t\t}\n\t}\n\treturn result", "\tlet pattern = \"\\\\[\\\\[(?:[^\\\\[\\\\]]|(?<=\\\
    \\[\\\\])\\\\]\\\\]|\\\\[(?=[^\\\\[\\\\]])])*\\\\]\"\n\tlet regex = try NSRegularExpression(pattern:\
    \ pattern, options: [])\n\tlet results = regex.matches(in: string, range: NSRange(string.startIndex..<string.endIndex,\
    \ in: string))\n\treturn results.count > 0", "\tscanner := bufio.NewScanner(strings.NewReader(string))\n\
    \tscanner.Split(scanBrackets)\n\treturn scanner.Scan()", "\tlet stack = Stack<String>()\n\
    \tvar last = String()\n\tvar open = false \n\tfor i in string.unicodeScalars {\n\
    \t\tif i.isASCII() && open {\n\t\t\tlast = i.value\n\t\t\tcontinue\n\t\t}\n\t\t\
    if i.isASCII() && stack.isEmpty() {\n\t\t\topen = false \n\t\t\tcontinue\n\t\t\
    }\n\t\tif i.isASCII() && stack.isEmpty() {\n\t\t\topen = true \n\t\t\tcontinue\n\
    \t\t}\n\t\tif !open && stack.isEmpty() {\n\t\t\topen = true \n\t\t}\n\t\tif open\
    \ == true {\n\t\t\tstack.push(i.value)\n\t\t} else {\n\t\t\tif stack.isEmpty()\
    \ {\n\t\t\t\topen = false \n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif stack.pop().rangeOfString(last,\
    \ options: .BackwardsSearch) == nil {\n\t\t\t\treturn false\n\t\t\t} else {\n\t\
    \t\t\topen = false \n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\tif stack.isEmpty()\
    \ {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}", "\tlet mut openings\
    \ = 0\n\tlet mut closings = 0\n\tlet mut bracket_stack = VecDeque::new()\n\tlet\
    \ mut last_char_at_start = 0\n\tfor c in string.chars() {\n\t\tswitch c {\n\t\t\
    case '[': bracket_stack.push_back(c);\n\t\tcase '\\'': \n\t\t\t// The closing\
    \ bracket is just another opening bracket\n\t\t\topenings++;\n\t\tcase '\\'':\
    \ \n\t\t\t// The opening bracket is just another closing bracket\n\t\t\tclosings++;\n\
    \t\tcase '[': \n\t\t\t// A nested bracket\n\t\t\tif openings == 0 && closings\
    \ > 0 {\n\t\t\t\t// Make sure it's valid (all nested brackets are closed).\n\t\
    \t\t\t// We can do this by ensuring the closing bracket is at the same depth as\
    \ the opening bracket.\n\t\t\t\tfor b in bracket_stack {\n\t\t\t\t\tif b.chars().count()\
    \ != 1 {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// It's\
    \ valid if the opening and closing brackets aren't adjacent.\n\t\t\t\tif openings\
    \ - closings == 1 {\n\t\t\t\t\tbracket_stack.pop_back();\n\t\t\t\t}\n\t\t\t} else\
    \ if openings == 0 && closings == 0 {\n\t\t\t\t// The opening bracket is just\
    \ another closing bracket.\n\t\t\t\t// It's invalid if the string is all brackets.\n\
    \t\t\t\tif c != ']' {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\tcase '[': \n\t\
    \t\t// An opening bracket\n\t\t\tif openings > 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\
    \tcase '\\'': \n\t\t\t// A closing bracket\n\t\t\tif closings > 0 {\n\t\t\t\t\
    break\n\t\t\t}\n\t\tdefault: \n\t\t\t// A normal character\n\t\t\tbreak\n\t\t\
    }\n\t\tlast_char_at_start = c\n\t}\n\t\n\tif bracket_stack.len() > 0 {\n\t\treturn\
    \ false\n\t} else if bracket_stack.len() == 1 && bracket_stack.pop().chars().count()\
    \ != 1 {\n\t\treturn false\n\t}\n\t\n\treturn true", "    \n    for index in 0..<string.characters.count\
    \ {\n        \n        if string[index] == \"[\" {\n            \n           \
    \ // Found an opening bracket.\n            \n            // Check that we have\
    \ another opening bracket after it.\n            \n            if index == string.characters.count\
    \ - 1 || string[index+1] != \"]\" {\n                \n                // This\
    \ is not an acceptable subsequence. Return false.\n                \n        \
    \        return false\n            }\n            \n            // Found a closing\
    \ bracket. Return true.\n            \n            return true\n        }\n  \
    \  }\n    \n    // All brackets match each other. Return true.\n    \n    return\
    \ true", "\tlet stack = Stack()\n\tlet opening_brackets = Dictionary<String, Int>()\n\
    \t\n\tfor symbol in string {\n\t\tswitch symbol {\n\t\tcase '[':\n\t\t\tstack.push(symbol)\n\
    \t\t\topening_brackets[symbol] = stack.count\n\t\tcase '[':\n\t\t\tlet opening_brackets_count\
    \ = opening_brackets[symbol]\n\t\t\tif opening_brackets_count < stack.count {\n\
    \t\t\t\treturn false\n\t\t\t}\n\t\tcase '}':\n\t\t\tif stack.count < 1 {\n\t\t\
    \t\treturn false\n\t\t\t}\n\t\t\tlet opening_brackets_count = opening_brackets[stack.peek()]\n\
    \t\t\tif opening_brackets_count < stack.count {\n\t\t\t\treturn false\n\t\t\t\
    }\n\t\t\tstack.pop()\n\t\tdefault:\n\t\t\tif stack.count == 0 {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.count == 0", "    guard let start\
    \ = string.index(of: \"[\"), let end = string.index(of: \"]\"), \n          (string.index(of:\
    \ \"[\") == 0 && string.index(of: \"]\") == string.count - 1) else { return false\
    \ }\n    let length = end - start\n    return length == 0 || \n        start ==\
    \ 0 ||\n        string.index(of: \"[\", range: start..<end) == (start + length)",
  "\tlet depth = 0\n\tlet stack = Stack()\n\t\n\tstring.forEach {\n\t\tswitch $0 {\n\
    \t\tcase '{':\n\t\t\tstack.push(depth)\n\t\tcase '}':\n\t\t\tdepth = stack.pop()\n\
    \t\t\t\n\t\t\tif depth == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\t\n\
    \treturn true", '    return is_nested(string: string, start: 0, end: string.characters.count)',
  "    if string == \"\" {\n        return false\n    }\n    let openingBrackets =\
    \ countBrackets(string: \"[[]\", fromIndex: 0)\n    let closingBrackets = countBrackets(string:\
    \ \"][]\", fromIndex: 0)\n    return (openingBrackets == closingBrackets)", " \
    \   guard let regex = try? NSRegularExpression(pattern: \"\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\\\
    \\]\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\\\\]\", options: []) else { return false }\n\
    \    return regex.firstMatch(in: string, options: [], range: NSMakeRange(0, string.utf16.count))\
    \ != nil", "\tlet pattern = try! NSRegularExpression(pattern: \"\\\\[\\\\[\\\\\
    [\", options: .CaseInsensitive)\n\tlet range = NSMakeRange(0, string.length)\n\
    \treturn pattern.firstMatchInString(string, options: nil, range: range).rangeAtIndex(0)\
    \ == nil", "\tvar nestLevel = 0\n\tchars := strings.Split(string, \"[]\")\n\t\
    for _, char := range chars {\n\t\tif char == \"[\" {\n\t\t\tnestLevel++\n\t\t\
    } else if char == \"]\" {\n\t\t\tnestLevel--\n\t\t} else if nestLevel == 0 {\n\
    \t\t\treturn false\n\t\t}\n\t}\n\treturn nestLevel == 0", "\tlet string = string\
    \ + \"]\"\n\tlet stringIndex = string.count\n\tlet bracketsIndex = string.unicodeScalars.firstIndex(of:\
    \ \"[\")\n\tvar bracketsCount = 1\n\tvar bracketsOpenCount = 1\n\tvar bracketsCloseCount\
    \ = 0\n\tvar parensCount = 0\n\n\tfor i in stride(from: 1, through: stringIndex,\
    \ by: 1) {\n\t\tif string[i - 1] == \"[\" {\n\t\t\tbracketsOpenCount += 1\n\t\t\
    } else if string[i - 1] == \"]\" {\n\t\t\tbracketsCloseCount += 1\n\t\t} else\
    \ if string[i - 1] == \"(\" {\n\t\t\tparensCount += 1\n\t\t} else if string[i\
    \ - 1] == \")\" {\n\t\t\tparensCount -= 1\n\t\t}\n\n\t\tif bracketsOpenCount >\
    \ 0 && parensCount == 0 && bracketsCloseCount >= bracketsOpenCount {\n\t\t\tbracketsCount\
    \ += 1\n\t\t} else if bracketsOpenCount > 0 && bracketsCloseCount == 0 && parensCount\
    \ == 0 {\n\t\t\tbracketsCount -= 1\n\t\t}\n\t}\n\n\treturn bracketsCount >= 0",
  "    var pos = 0\n    var openBrackets: Int = 0\n    var closeBrackets: Int = 0\n\
    \n    while pos < string.count {\n        let c = string[pos]\n        if c !=\
    \ \"[\" {\n            openBrackets++\n        } else {\n            openBrackets++\n\
    \        }\n\n        if c != \"]\" {\n            closeBrackets++\n        }\
    \ else {\n            closeBrackets++\n        }\n\n        if openBrackets >\
    \ closeBrackets {\n            return false\n        }\n\n        pos++\n    }\n\
    \n    return true", "\tlet array = string.characters.split(separator: \"\").map(String.init)\n\
    \tlet arrayLength = array.count\n\t\n\tvar currentStringIndex = 0\n\t\n\tfor currentStringIndex\
    \ < arrayLength {\n\t\tlet currentString = array[currentStringIndex]\n\t\t\n\t\
    \tif currentString.hasPrefix(\"[\") {\n\t\t\tif currentString.hasSuffix(\"]\"\
    ) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\t\n\t\tcurrentStringIndex += 1\n\t\
    }\n\t\n\treturn false", "\tlet regex = \"\\\\[\\\\[.*\\\\]\\\\]\"\n\tlet isNested\
    \ = NSPredicate(format: \"SELF MATCHES %@\", regex)\n\tlet result = isNested.evaluate(with:\
    \ string)\n\treturn result", "\tlet opening = string[string.startIndex]\n\tlet\
    \ closing = string[string.endIndex]\n\n\treturn opening == \"[\" && closing ==\
    \ \"]\"", "    var index = 0\n    \n    // If the string is empty or it contains\
    \ no brackets at all\n    if string.characters.count == 0 {\n        return true\n\
    \    }\n    \n    // If the string contains only square brackets\n    if string.characters.count\
    \ == 1 {\n        return true\n    }\n    \n    // Iterate over all characters\
    \ in the string\n    for char in string.characters {\n        // If the current\
    \ character is square bracket\n        if char == \"[\" {\n            // If the\
    \ next character is a closing square bracket\n            if string.characters.count\
    \ > index + 1 && string[index + 1] == \"]\" {\n                // The current\
    \ index is a valid closing index\n                if char == \"]\" {\n       \
    \             index += 1\n                    return true\n                }\n\
    \            }\n            // If the next character is not a closing square bracket\n\
    \            if string.characters.count > index + 1 && string[index + 1] != \"\
    ]\" {\n                // The current index is not a closing index\n         \
    \       index -= 1\n                return false\n            }\n        }\n \
    \       // If the current character is a closing square bracket\n        else\
    \ if char == \"]\" {\n            // If the next character is a opening square\
    \ bracket\n            if string.characters.count > index + 1 && string[index\
    \ + 1] == \"[\" {\n                // The current index is a valid opening index\n\
    \                if char == \"[\" {\n                    index += 1\n        \
    \            return true\n                }\n            }\n            // If\
    \ the next character is not a opening square bracket\n            if string.characters.count\
    \ > index + 1 && string[index + 1] != \"]\" {\n                // The current\
    \ index is not a closing index\n                index -= 1\n                return\
    \ false\n            }\n        }\n    }\n    \n    // The string does not contain\
    \ valid subsequences of brackets\n    return false", "    var bracketsCount =\
    \ 1\n    let count = string.characters.count\n    var nextCount = 0\n    var inNestedBrackets\
    \ = false\n    \n    for c in string.characters {\n        if c == '[' {\n   \
    \         nextCount = count\n            bracketsCount += 1\n        } else if\
    \ c == '{' {\n            if bracketsCount == 0 {\n                inNestedBrackets\
    \ = true\n            }\n            nextCount = count\n        } else if c ==\
    \ ']' {\n            if bracketsCount != 0 {\n                bracketsCount -=\
    \ 1\n            }\n            if bracketsCount == 0 {\n                nextCount\
    \ += 1\n            }\n        } else if inNestedBrackets && c == '}' {\n    \
    \        nextCount += 1\n            if bracketsCount == 0 {\n               \
    \ nextCount += 1\n            }\n        } else if inNestedBrackets && c == ']'\
    \ {\n            if bracketsCount == 0 {\n                nextCount += 1\n   \
    \         }\n        } else if bracketsCount > 0 {\n            nextCount += 1\n\
    \        }\n\n        if bracketsCount == 0 {\n            if count == nextCount\
    \ {\n                return true\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n\n    return true", "\tif string ==\
    \ \"\" { return false }\n\n\tstack := []rune(\"\")\n\tindex := 0\n\tstart := 0\n\
    \tdepth := 0\n\tquote := '['\n\tswitch string[0] {\n\tcase quote:\n\t\tstack =\
    \ append(stack, quote)\n\tcase '[':\n\t\tstack = append(stack, quote)\n\t\tdepth++\n\
    \tcase ']':\n\t\tdepth--\n\t\tif depth < 0 {\n\t\t\tlog.Panic(\"Unexpected unmatched\
    \ closing bracket\")\n\t\t}\n\t\tif depth == 0 {\n\t\t\tstack = stack[:len(stack)-1]\n\
    \t\t}\n\tdefault:\n\t\treturn false\n\t}\n\n\tfor i, c := range string[start:]\
    \ {\n\t\tif c == quote {\n\t\t\tcontinue\n\t\t}\n\t\tif stack[index] != quote\
    \ {\n\t\t\tstack = append(stack, c)\n\t\t}\n\t\tindex++\n\t\tif index >= len(stack)\
    \ {\n\t\t\treturn true\n\t\t}\n\t\tstack = stack[:len(stack)-1]\n\t}\n\treturn\
    \ false", "\tlet open_brackets = string.characters.filter({ $0 == \"[\" })\n\t\
    let close_brackets = string.characters.filter({ $0 == \"]\" })\n\n\tguard open_brackets.count\
    \ > 0 && close_brackets.count > 0 else {\n\t\treturn false\n\t}\n\n\tvar close_brackets_count\
    \ = 0\n\tguard let open_brackets_count = open_brackets.count else {\n\t\treturn\
    \ false\n\t}\n\n\tguard open_brackets_count == close_brackets_count && open_brackets_count\
    \ != 0 else {\n\t\treturn false\n\t}\n\n\treturn true", "    let lastIndex = string.index(string.startIndex,\
    \ offsetBy: 1)\n    if string.characters.count < lastIndex {\n        return false\n\
    \    }\n    let next = string.index(string.endIndex, offsetBy: -2)\n    if next\
    \ < 0 {\n        return false\n    }\n    let start = string.index(string.startIndex,\
    \ offsetBy: -2)\n    let end = string.index(string.endIndex, offsetBy: -1)\n \
    \   if start < 0 || end < 0 {\n        return false\n    }\n    let startIndex\
    \ = string.index(string.startIndex, offsetBy: -1)\n    if start == end {\n   \
    \     return false\n    }\n    let closing = string.index(string.endIndex, offsetBy:\
    \ 1)\n    if closing < 0 || closing == start {\n        return false\n    }\n\
    \    let opening = string.index(string.startIndex, offsetBy: 1)\n    if opening\
    \ < 0 || closing < opening {\n        return false\n    }\n    \n    if string.substring((opening),\
    \ string.index(string.endIndex, offsetBy: 2)) != \"][]\" {\n        return false\n\
    \    }\n    \n    return true", "\tlet stack = Array<Character>.init()\n\tlet\
    \ string = string.lowercased()\n\tfor (index, ch) in string.enumerated() {\n\t\
    \tswitch ch {\n\t\tcase '[':\n\t\t\tstack.append(ch)\n\t\tcase '[':\n\t\t\tif\
    \ stack.isEmpty {\n\t\t\t\treturn false\n\t\t\t} else {\n\t\t\t\tstack.removeLast()\n\
    \t\t\t}\n\t\tcase '}':\n\t\t\tif stack.isEmpty {\n\t\t\t\treturn false\n\t\t\t\
    } else {\n\t\t\t\tstack.removeLast()\n\t\t\t}\n\t\tcase ']':\n\t\t\tif stack.isEmpty\
    \ {\n\t\t\t\treturn false\n\t\t\t} else {\n\t\t\t\tstack.removeLast()\n\t\t\t\
    }\n\t\tcase '{':\n\t\t\tif stack.isEmpty {\n\t\t\t\treturn false\n\t\t\t} else\
    \ {\n\t\t\t\tstack.removeLast()\n\t\t\t}\n\t\tcase '}':\n\t\t\tif stack.isEmpty\
    \ {\n\t\t\t\treturn false\n\t\t\t} else {\n\t\t\t\tstack.removeLast()\n\t\t\t\
    }\n\t\tcase ',':\n\t\t\tif stack.isEmpty {\n\t\t\t\treturn false\n\t\t\t} else\
    \ {\n\t\t\t\tstack.removeLast()\n\t\t\t}\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\
    \t}\n\treturn stack.isEmpty == false", "    let substrings = string.characters.filter\
    \ { Character.isLetterOrDigit($0) }\n    return is_nested_helper(string: substrings,\
    \ currentIndex: 0)", "\tdepth := 0\n\tbracket := 0\n\tfor _, s := range string\
    \ {\n\t\tif s == '[' {\n\t\t\tbracket++\n\t\t}\n\t\tif s == ']' {\n\t\t\tbracket--\n\
    \t\t}\n\t\tif bracket < 0 {\n\t\t\treturn false\n\t\t}\n\t\tdepth++\n\t}\n\tif\
    \ depth == 0 {\n\t\treturn true\n\t}\n\treturn false", "\tif string == \"\" {\n\
    \t\treturn false\n\t}\n\t\n\tbracketStack := []int{}\n\topen := -1\n\tclose :=\
    \ 0\n\tbracket := 0\n\tvar count int\n\tvar stack []int\n\tfor i, c := range string\
    \ {\n\t\tif c == \"]\" {\n\t\t\tcount = count*-1\n\t\t\tclose = i\n\t\t}\n\t\t\
    if c == \"[\" {\n\t\t\topen = i\n\t\t\tbracketStack = append(bracketStack, open)\n\
    \t\t}\n\t\tif count == -1 {\n\t\t\tstack = append(stack, bracketStack...)\n\t\t\
    }\n\t\tif bracketStack[bracket] == -1 {\n\t\t\tstack = append(stack, i)\n\t\t\
    }\n\t\tbracketStack[bracket] = i\n\t}\n\t\n\tbracketStack = append(bracketStack,\
    \ close)\n\t\n\tif len(bracketStack) != 1 {\n\t\treturn false\n\t}\n\t\n\tstack\
    \ := bracketStack[:len(bracketStack)-1]\n\tfor _, i := range stack {\n\t\tif bracketStack[i]\
    \ == close {\n\t\t\treturn true\n\t\t}\n\t}\n\t\n\treturn false", "    func is_nested_impl(_\
    \ str: String) -> Bool {\n        var i = 0\n        var found = false\n     \
    \   while i < str.characters.count {\n            if str[i] == '[' {\n       \
    \         if found {\n                    return false\n                }\n  \
    \              if i+1 < str.characters.count {\n                    if str[i+1]\
    \ == '[' {\n                        found = true\n                    }\n    \
    \            } else {\n                    return false\n                }\n \
    \           } else if str[i] == '[' {\n                if found {\n          \
    \          return false\n                }\n                if i+1 < str.characters.count\
    \ {\n                    if str[i+1] != ']' {\n                        found =\
    \ true\n                    }\n                } else {\n                    return\
    \ false\n                }\n            } else if str[i] == ']' {\n          \
    \      if !found {\n                    return false\n                }\n    \
    \            found = false\n            } else {\n                return false\n\
    \            }\n            i += 1\n        }\n        return true\n    }\n  \
    \  return is_nested_impl(string)", "    if let index = string.firstIndex(of: \"\
    [\"),\n       index < string.endIndex {\n        if let index = string.firstIndex(of:\
    \ \"]\", range: Range<String.Index>(start: index, end: string.endIndex)),\n  \
    \         index < string.endIndex {\n            if let index = string.firstIndex(of:\
    \ \"[\", range: Range<String.Index>(start: index, end: string.endIndex)),\n  \
    \             index < string.endIndex {\n                return true\n       \
    \     } else {\n                return false\n            }\n        } else {\n\
    \            return false\n        }\n    } else {\n        return false\n   \
    \ }", "    var stack: [String] = []\n    for symbol in string {\n        if symbol\
    \ == \"[\" {\n            stack.append(symbol)\n        } else if symbol == \"\
    ]\" {\n            stack.removeLast()\n        } else if stack.count > 0 {\n \
    \           return false\n        } else {\n            return true\n        }\n\
    \    }\n    return stack.count == 0", "    let brackets = brackets(string)\n \
    \   let openings = openings(brackets)\n    let closings = closings(brackets)\n\
    \    \n    if openings.count + closings.count > 0 {\n        return true\n   \
    \ }\n    \n    return false", "\treturn is_nested(string: string, count: 0)",
  "\treturn (string.contains(\"[[\") && string.contains(\"]]\"))", "\tlet isNested\
    \ = (string.range(of: \"[[[[]\", options: .anchored) == nil)\n\t\n\treturn isNested",
  '    return is_nested_regex(string: string) != nil', "\tlet openCount = string.count(\"\
    [\")\n\tlet closedCount = string.count(\"]\")\n\t\n\treturn (openCount == closedCount)\
    \ && openCount > 0", '    return is_nested(string: &string, length: string.count)',
  "\t_ = string.makeIterator()\n\t\n\tvar bracketsStack = [Character : Character]()\n\
    \tvar isNested = true\n\t\n\tlet startIndex: Int = string.startIndex\n\tlet endIndex:\
    \ Int = string.endIndex\n\t\n\tfor _ in 0..<endIndex - startIndex {\n\t\tlet nextChar\
    \ : Character = string.next()\n\t\t\n\t\tbracketsStack[nextChar] = nextChar\n\t\
    \tif isNested {\n\t\t\tif nextChar != ']' {\n\t\t\t\tisNested = false\n\t\t\t\
    }\n\t\t}\n\t}\n\t\n\treturn isNested && bracketsStack[']'] != nil", "\tvar isNested\
    \ bool\n\tfor _, character := range string {\n\t\tswitch character {\n\t\tcase\
    \ '[':\n\t\t\tisNested = true\n\t\tcase ']':\n\t\t\tisNested = false\n\t\tdefault:\n\
    \t\t\tif !isNested {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true",
  "    let start = string.startIndex\n    let end = string.endIndex\n    return start\
    \ < end && start > 0 && isNested(string[start...end])", "\tvar stack = [Character]()\n\
    \tvar opening = false\n\t\n\tfor(var i = 0; i < string.characters.count; i++ )\
    \ {\n\t\tlet ch = string.character(at: i)\n\t\t\n\t\tif opening, opening == true\
    \ {\n\t\t\tstack.append(ch)\n\t\t} else {\n\t\t\topening = ch == '[' || ch ==\
    \ '{'\n\t\t}\n\t\t\n\t\tif stack.isEmpty {\n\t\t\treturn false\n\t\t}\n\t}\n\t\
    \n\treturn true", "\tguard let range = string.range(of: \"[[]]\") else {\n\t\t\
    return false\n\t}\n\tguard let range = string.range(of: \"[[]]\", options: .backwards)\
    \ else {\n\t\treturn false\n\t}\n\treturn true", "    if string.hasPrefix(\"[\"\
    ) || string.hasPrefix(\"{\") || string.hasPrefix(\"(\") {\n        return true\n\
    \    }\n    if string.hasSuffix(\"]\") == true || string.hasSuffix(\"}\") == true\
    \ || string.hasSuffix(\")\") == true || string.hasSuffix(\"]}\") == true {\n \
    \       return true\n    }\n    return false", "    let regex = try! NSRegularExpression(pattern:\
    \ \"^\\\\[\\\\[.*\\\\]\\\\].*$\", options: [])\n    \n    return regex.firstMatch(in:\
    \ string, range: NSRange(string.utf16.count)) != nil", "    let re = try! NSRegularExpression(pattern:\
    \ \"[][]\")\n    let range = NSRange(location: 0, length: string.utf16.count)\n\
    \    return re.firstMatch(in: string, range: range) != nil", "    var count =\
    \ 0\n    for x in string.characters {\n        if brackets[Character(x)] {\n \
    \           count += 1\n        }\n    }\n    return count > 0", '    return isNested(string,
    delimiter: "]")', "\t// TODO: Fill this in\n\treturn true", "\tstack = [string]()\n\
    \treturn is_nested_internal(string)", "    var stack = [Char]()\n    var result\
    \ = false\n    for i := 0; i < len(string); i++ {\n        if string[i] == '['\
    \ && string[i+1] == '[' {\n            stack.append(string[i+2])\n           \
    \ i += 2\n        } else if string[i] == '[' && string[i+1] != ']' {\n       \
    \     if stack.last == ']' {\n                return false\n            }\n  \
    \          stack.pop()\n        } else if string[i] == ']' && string[i+1] != ']'\
    \ {\n            if stack.last == '[' {\n                return false\n      \
    \      }\n            stack.pop()\n        } else if string[i] == '[' {\n    \
    \        stack.append(string[i])\n        } else if string[i] == ']' {\n     \
    \       stack.pop()\n        }\n    }\n    return result", "    guard let _ =\
    \ string.range(of: \"[[\", options: .regularExpression) else {\n        return\
    \ false\n    }\n\n    guard let _ = string.range(of: \"]]\", options: .regularExpression)\
    \ else {\n        return false\n    }\n\n    return true", "\treturn is_nested(string:\
    \ \"\", startIndex: 0)", "    // A pattern that matches a square bracket pair\
    \ that is followed by a comma\n    let openBracket = String(\"[[\".data(using:\
    \ .ascii)!)\n    let closeBracket = String(\"]]\".data(using: .ascii)!)\n    \n\
    \    let isBracketOpen = string.range(of: openBracket) != nil\n    let isBracketClosed\
    \ = string.range(of: closeBracket) != nil\n    \n    return (isBracketOpen &&\
    \ !isBracketClosed) || !isBracketOpen && !isBracketClosed", "\tbracketCount :=\
    \ 0\n\tinBracketGroup := false\n\tfor _, r := range string {\n\t\tif r == '['\
    \ {\n\t\t\tbracketCount += 1\n\t\t} else if r == ']' {\n\t\t\tbracketCount -=\
    \ 1\n\t\t\tif bracketCount == 0 {\n\t\t\t\tinBracketGroup = false\n\t\t\t\tbreak\n\
    \t\t\t}\n\t\t}\n\t\tif bracketCount == 0 {\n\t\t\tif inBracketGroup == false {\n\
    \t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tif inBracketGroup == false {\n\t\t\t\
    inBracketGroup = r == '['\n\t\t}\n\t}\n\treturn true", "\tlet str = string.stringByReplacingOccurrencesOfString(\"\
    [\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\
    \tlet str = string.stringByReplacingOccurrencesOfString(\"]\", withString: \"\"\
    , options: NSStringCompareOptions.LiteralSearch, range: nil)\n\tlet str = string.stringByReplacingOccurrencesOfString(\"\
    [[\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n\tlet str = string.stringByReplacingOccurrencesOfString(\"]]\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\tlet str\
    \ = string.stringByReplacingOccurrencesOfString(\"[[[\", withString: \"\", options:\
    \ NSStringCompareOptions.LiteralSearch, range: nil)\n\tlet str = string.stringByReplacingOccurrencesOfString(\"\
    [[]]\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n\tlet str = string.stringByReplacingOccurrencesOfString(\"[[[]\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\tlet str\
    \ = string.stringByReplacingOccurrencesOfString(\"[[]]]\", withString: \"\", options:\
    \ NSStringCompareOptions.LiteralSearch, range: nil)\n\tlet str = string.stringByReplacingOccurrencesOfString(\"\
    [[[]]\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n\tlet str = string.stringByReplacingOccurrencesOfString(\"[][]\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\tlet str\
    \ = string.stringByReplacingOccurrencesOfString(\"[][]]]\", withString: \"\",\
    \ options: NSStringCompareOptions.LiteralSearch, range: nil)\n\tlet str = string.stringByReplacingOccurrencesOfString(\"\
    [][]]]]\", withString: \"\", options: NSStringCompareOptions.LiteralSearch, range:\
    \ nil)\n\tlet str = string.stringByReplacingOccurrencesOfString(\"[]]]]]\", withString:\
    \ \"\", options: NSStringCompareOptions.LiteralSearch, range: nil)\n\tlet str\
    \ = string.stringByReplacingOccurrencesOfString(\"[]]]]]]]\", withString: \"\"\
    , options: NSStringCompareOptions.LiteralSearch, range: nil)\n\treturn (str.characters.count\
    \ > 0)", "    guard let index = string.index(of: \"[\"), let endIndex = string.index(of:\
    \ \"]\") else {\n        return false\n    }\n    return string.rangeOfCharacter(from:\
    \ openingBrackets, options: .regularExpression) != nil && string.rangeOfCharacter(from:\
    \ closingBrackets, options: .regularExpression) != nil && index != endIndex",
  "\tstr = string\n\tnested = 0\n\tdepth := 0\n\tvar open_brackets = 0, closed_brackets\
    \ = 0, open_brackets_depth = 0, closed_brackets_depth = 0\n\tvar start = 0\n\t\
    var end = len(str)\n\t\n\tfor i, c := range str {\n\t\tif c == '[' {\n\t\t\tif\
    \ depth == 0 {\n\t\t\t\tstart = i\n\t\t\t}\n\t\t\topen_brackets++\n\t\t\topen_brackets_depth++\n\
    \t\t\tdepth++\n\t\t}\n\t\tif c == '[' {\n\t\t\topen_brackets++\n\t\t\topen_brackets_depth++\n\
    \t\t}\n\t\tif c == ']' {\n\t\t\tclosed_brackets++\n\t\t\tclosed_brackets_depth++\n\
    \t\t\topen_brackets--\n\t\t\tclosed_brackets--\n\t\t\tdepth--\n\t\t}\n\t\tif c\
    \ == ']' {\n\t\t\tclosed_brackets--\n\t\t\tclosed_brackets_depth--\n\t\t}\n\t\
    }\n\tif open_brackets == 0 {\n\t\treturn false\n\t}\n\tif closed_brackets == 0\
    \ {\n\t\treturn true\n\t}\n\tif open_brackets_depth != closed_brackets_depth {\n\
    \t\treturn false\n\t}\n\tfor i := start; i != end; i++ {\n\t\tc := str[i]\n\t\t\
    if c == '[' {\n\t\t\tif depth == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\topen_brackets++\n\
    \t\t\topen_brackets_depth++\n\t\t\tdepth++\n\t\t}\n\t\tif c == '[' {\n\t\t\topen_brackets++\n\
    \t\t\topen_brackets_depth++\n\t\t}\n\t\tif c == ']' {\n\t\t\tclosed_brackets--\n\
    \t\t\tclosed_brackets_depth--\n\t\t\topen_brackets--\n\t\t\tclosed_brackets--\n\
    \t\t\tdepth--\n\t\t}\n\t\tif c == ']' {\n\t\t\tclosed_brackets--\n\t\t\tclosed_brackets_depth--\n\
    \t\t}\n\t\tif open_brackets_depth == closed_brackets_depth {\n\t\t\treturn false\n\
    \t\t}\n\t}\n\treturn true", "\tfor i := 0; i < len(string); i++ {\n\t\tif !is_bracket(string[i])\
    \ {\n\t\t\treturn false\n\t\t}\n\t\tif i+1 < len(string) && !is_bracket(string[i+1])\
    \ {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true", "    // Create a stack that\
    \ is initially empty\n    var stack = [String]()\n    \n    for char in string.characters\
    \ {\n        if char == \"[\" {\n            // Add the character to the stack\n\
    \            stack.append(char)\n        } else if char == \"]\" {\n         \
    \   // Remove the top element from the stack\n            stack.removeLast()\n\
    \        } else {\n            // If the character is not \"[\", then it is not\
    \ the end of a nested bracket\n            return false\n        }\n    }\n  \
    \  // If the stack is empty then return true \n    return stack.count == 0", "\t\
    var count int\n\tvar is_nest bool = false\n\tfor _, c := range string {\n\t\t\
    if c == '[' && count > 0 {\n\t\t\tcount++\n\t\t} else if c == '[' {\n\t\t\tcount\
    \ = 1\n\t\t} else if c == ']' && count > 0 {\n\t\t\tcount--\n\t\t} else if c ==\
    \ ']' {\n\t\t\tcount = 0\n\t\t} else {\n\t\t\tcontinue\n\t\t}\n\t\tis_nest = !is_nest\n\
    \t}\n\treturn is_nest", "\treturn is_nested_impl(string, 0)", "    var startIndex:\
    \ Int = 0\n    var hasNesting: Bool = false\n    var hasRightBracket: Bool = false\n\
    \n    for _ in 0..<string.characters.count {\n        let currentChar = string.characters[string.startIndex]\n\
    \        switch currentChar {\n        case \"[\":\n            if hasRightBracket\
    \ {\n                hasNesting = false\n                hasRightBracket = false\n\
    \            } else {\n                hasNesting = true\n            }\n    \
    \    case \"{\":\n            hasRightBracket = true\n        default:\n     \
    \       if hasRightBracket {\n                hasNesting = false\n           \
    \     hasRightBracket = false\n            }\n        }\n\n        if hasNesting\
    \ {\n            if hasRightBracket {\n                hasNesting = false\n  \
    \              hasRightBracket = false\n            } else {\n               \
    \ hasNesting = true\n            }\n        } else {\n            if hasRightBracket\
    \ {\n                return false\n            }\n        }\n\n        if !hasRightBracket\
    \ {\n            startIndex += 1\n        }\n    }\n\n    return hasNesting",
  "    let index = 0\n    \n    if let openBracket = string.find(\"[\", startIndex:\
    \ &index) {\n        if let closeBracket = string.find(\"]\", startIndex: &index)\
    \ {\n            let isNested = true\n            \n            if let openBracket2\
    \ = string.find(\"[\", startIndex: &index + 1) {\n                if let closeBracket2\
    \ = string.find(\"]\", startIndex: &index + 1) {\n                    if let openBracket3\
    \ = string.find(\"[\", startIndex: &index + 2) {\n                        if let\
    \ closeBracket3 = string.find(\"]\", startIndex: &index + 2) {\n             \
    \               \n                            if openBracket2 == closeBracket2\
    \ && openBracket3 == closeBracket3 {\n                                isNested\
    \ = false\n                            }\n                        }\n        \
    \            }\n                }\n            }\n            \n            return\
    \ isNested\n        }\n    }\n    \n    return false", "\tguard let regex = try?\
    \ NSRegularExpression(pattern: \"\\\\[.*?\\\\]\", options: []) else {\n\t\treturn\
    \ false\n\t}\n\tlet match = regex.firstMatch(in: string, options: [], range: NSMakeRange(0,\
    \ string.utf16.count))\n\treturn (match != nil) && match.numberOfRanges > 0",
  "\tstack, _ := bracket.New(string(string))\n\tfor len(stack) > 0 {\n\t\tbracket\
    \ := stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\n\t\tif bracket.Kind\
    \ == bracket.CloseBracketNested {\n\t\t\tstack = append(stack, bracket)\n\t\t\t\
    return true\n\t\t} else if bracket.Kind == bracket.OpenBracketUnnested {\n\t\t\
    \tstack = append(stack, bracket)\n\t\t}\n\t}\n\treturn false", "\tvar i = strings.Index(string,\
    \ \"[\")\n\tvar j = strings.Index(string, \"]\")\n\tif i < 0 {\n\t\treturn false\n\
    \t}\n\tif j == -1 {\n\t\treturn true\n\t}\n\treturn is_nested(string: string,\
    \ start: i, end: j+1)", "\t\n\tlet substrings = string.characters\n\t\n\tfor index\
    \ in 0..<substrings.count {\n\t\t\n\t\tlet character = substrings[index]\n\t\t\
    \n\t\tif character == \"[\" || character == \"{\" || character == \"}\" {\n\t\t\
    \t\n\t\t\treturn true\n\t\t}\n\t}\n\t\n\treturn false"]
stop_tokens:
- "\n}"
