language: swift
name: HumanEval_7_filter_by_substring
results:
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  guard let pattern = try? NSRegularExpression(pattern: substring, options: [])\
    \ else { return strings }\n  return strings.filter { pattern!.matches($0, options:\
    \ []) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnugtuzg8.swift:8:28: error: cannot find 'NSRegularExpression' in\
    \ scope\n  guard let pattern = try? NSRegularExpression(pattern: substring, options:\
    \ []) else { return strings }\n                           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = [String]()\n    strings.forEach() {\n        if strings.index(of:\
    \ substring) != nil {\n            filtered = filtered + this\n        }\n   \
    \ }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp29v8oi4a.swift:11:35: error: cannot find 'this' in scope\n    \
    \        filtered = filtered + this\n                                  ^~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_string_for_substring(strings, substring, false)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnpxvp754.swift:8:12: error: cannot find 'filter_string_for_substring'\
    \ in scope\n    return filter_string_for_substring(strings, substring, false)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = [String]()\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            result.append(string)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let start = substring.startIndex\n    let end = substring.endIndex\n    return\
    \ strings.filter() {\n        substring($0, start, end) == true\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_iymbl0d.swift:11:9: error: cannot call value of non-function type\
    \ 'String'\n        substring($0, start, end) == true\n        ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter({ $0.hasPrefix(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmp2w4a6dw_/tmp2w4a6dw_.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17b1484c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17b117bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17b117b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17b117a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2w4a6dw_                        0x00005582a0851b87 <unavailable> + 7047

    5    libc.so.6                          0x00002b17b1670460 __libc_start_main +
    245

    6    tmp2w4a6dw_                        0x00005582a08511e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    strings.filter { $0.contains(substring) }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013447
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filtered: [String] = strings.filter {\n        let index = $0.index(substring,\
    \ options: .caseInsensitive)\n        return index != nil\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdanml0jk.swift:9:24: error: no exact matches in call to instance\
    \ method 'index'\n        let index = $0.index(substring, options: .caseInsensitive)\n\
    \                       ^\n/tmp/tmpdanml0jk.swift:9:24: note: found candidate\
    \ with type '(String.Index) -> String.Index'\n        let index = $0.index(substring,\
    \ options: .caseInsensitive)\n                       ^\n/tmp/tmpdanml0jk.swift:9:24:\
    \ note: found candidate with type '(String.Index) -> String.Index'\n        let\
    \ index = $0.index(substring, options: .caseInsensitive)\n                   \
    \    ^\n/tmp/tmpdanml0jk.swift:9:24: note: found candidate with type '((String.Element)\
    \ throws -> Bool) throws -> String.Index?' (aka '((Character) throws -> Bool)\
    \ throws -> Optional<String.Index>')\n        let index = $0.index(substring,\
    \ options: .caseInsensitive)\n                       ^\n/tmp/tmpdanml0jk.swift:9:24:\
    \ note: found candidate with type '(String.Element) -> String.Index?' (aka '(Character)\
    \ -> Optional<String.Index>')\n        let index = $0.index(substring, options:\
    \ .caseInsensitive)\n                       ^\n/tmp/tmpdanml0jk.swift:9:51: error:\
    \ cannot infer contextual base in reference to member 'caseInsensitive'\n    \
    \    let index = $0.index(substring, options: .caseInsensitive)\n            \
    \                                     ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = strings\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            result = result.filter{ $0 != string }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmp9q0jagtk/tmp9q0jagtk.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f89fbac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f89cb1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f89cb1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f89cb07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9q0jagtk                        0x0000555e4203ea77 <unavailable> + 6775

    5    libc.so.6                          0x00002b4f8a1a6460 __libc_start_main +
    245

    6    tmp9q0jagtk                        0x0000555e4203e3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let strings = strings.filter { $0.contains(substring) }\n    return strings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = strings\n    for i := 0; i < len(strings); i++ {\n       \
    \ if strings[i].contains(substring) {\n            filtered = filtered[filtered.indices.filter{\
    \ $0 != i }: filtered.indices.dropFirst()]\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpk5orxlak.swift:9:12: error: expected type\n    for i := 0; i <\
    \ len(strings); i++ {\n           ^\n            <#type#>\n/tmp/tmpk5orxlak.swift:9:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(strings);\
    \ i++ {\n           ^\n/tmp/tmpk5orxlak.swift:9:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(strings); i++ {\n           ^\n/tmp/tmpk5orxlak.swift:11:67:\
    \ error: expected ',' separator\n            filtered = filtered[filtered.indices.filter{\
    \ $0 != i }: filtered.indices.dropFirst()]\n                                 \
    \                                 ^\n                                        \
    \                          ,\n/tmp/tmpk5orxlak.swift:11:67: error: expected expression\
    \ in list of expressions\n            filtered = filtered[filtered.indices.filter{\
    \ $0 != i }: filtered.indices.dropFirst()]\n                                 \
    \                                 ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard let firstIndex = strings.firstIndex(of: substring) else { return strings\
    \ }\n    return strings.indices.contains(firstIndex) ? strings[firstIndex..<strings.endIndex]\
    \ : strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr7_ms23y.swift:9:49: error: cannot convert return expression of\
    \ type 'ArraySlice<String>' to return type '[String]'\n    return strings.indices.contains(firstIndex)\
    \ ? strings[firstIndex..<strings.endIndex] : strings\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings: [String] = []\n    strings.enumerated().forEach { idx,\
    \ str in\n        if str.hasSuffix(substring) {\n            filteredStrings.append(str)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmpvazn7bgf/tmpvazn7bgf.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ed07aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ed04a1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ed04a1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ed04a07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvazn7bgf                        0x000055de996a2967 <unavailable> + 6503

    5    libc.so.6                          0x00002b7ed0996460 __libc_start_main +
    245

    6    tmpvazn7bgf                        0x000055de996a22e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tstrings := strings.MapBySlice(func(i int) func(j int) bool {\n\t\treturn strings.Contains(strings[i],\
    \ substring)\n\t})\n\treturn strings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmyg47gxd.swift:8:9: error: consecutive statements on a line must\
    \ be separated by ';'\n        strings := strings.MapBySlice(func(i int) func(j\
    \ int) bool {\n               ^\n               ;\n/tmp/tmpmyg47gxd.swift:8:10:\
    \ error: expected expression\n        strings := strings.MapBySlice(func(i int)\
    \ func(j int) bool {\n                ^\n/tmp/tmpmyg47gxd.swift:8:2: warning:\
    \ expression of type '[String]' is unused\n        strings := strings.MapBySlice(func(i\
    \ int) func(j int) bool {\n        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    \n    var filtered: [String] = []\n    \n    for string in strings {\n  \
    \      \n        if string.contains(substring) {\n            \n            filtered.append(string)\n\
    \        }\n    }\n    \n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  guard !strings.isEmpty else {\n    return strings\n  }\n\n  let filtered =\
    \ strings\n    .enumerated()\n    .filter { index, string in\n      let containsSubstring\
    \ = string.lowercased().rangeOfString(substring) != nil\n      guard containsSubstring\
    \ else {\n        return false\n      }\n      return index == 0\n    }\n    .map\
    \ { index, string -> String in\n      return string\n    }\n  \n  return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3vrg4m76.swift:15:51: error: value of type 'String' has no member\
    \ 'rangeOfString'\n      let containsSubstring = string.lowercased().rangeOfString(substring)\
    \ != nil\n                              ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return removeAll(strings.filter({ $0.contains(substring) }))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo81f6f2n.swift:8:12: error: cannot find 'removeAll' in scope\n\
    \    return removeAll(strings.filter({ $0.contains(substring) }))\n          \
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let mut index = -1\n    let mut indexEnd = strings.len()\n    for stringIdx\
    \ in 0..<strings.len() {\n        if strings[stringIdx].contains(substring) {\n\
    \            if index == -1 {\n                index = stringIdx\n           \
    \     indexEnd = stringIdx\n            } else {\n                indexEnd = stringIdx\n\
    \            }\n        }\n    }\n    if index != -1 {\n        let range = (index\
    \ + 1, indexEnd)\n        return strings.subslice(range)\n    } else {\n     \
    \   return strings\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp50_2fw4f.swift:8:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut index =\
    \ -1\n            ^\n/tmp/tmp50_2fw4f.swift:8:13: note: join the identifiers together\n\
    \    let mut index = -1\n        ~~~~^~~~~\n        mutindex\n/tmp/tmp50_2fw4f.swift:8:13:\
    \ note: join the identifiers together with camel-case\n    let mut index = -1\n\
    \        ~~~~^~~~~\n        mutIndex\n/tmp/tmp50_2fw4f.swift:9:13: error: found\
    \ an unexpected second identifier in constant declaration; is there an accidental\
    \ break?\n    let mut indexEnd = strings.len()\n            ^\n/tmp/tmp50_2fw4f.swift:9:13:\
    \ note: join the identifiers together\n    let mut indexEnd = strings.len()\n\
    \        ~~~~^~~~~~~~\n        mutindexEnd\n/tmp/tmp50_2fw4f.swift:9:13: note:\
    \ join the identifiers together with camel-case\n    let mut indexEnd = strings.len()\n\
    \        ~~~~^~~~~~~~\n        mutIndexEnd\n/tmp/tmp50_2fw4f.swift:9:32: error:\
    \ value of type '[String]' has no member 'len'\n    let mut indexEnd = strings.len()\n\
    \                       ~~~~~~~ ^~~\n/tmp/tmp50_2fw4f.swift:10:34: error: value\
    \ of type '[String]' has no member 'len'\n    for stringIdx in 0..<strings.len()\
    \ {\n                         ~~~~~~~ ^~~\n/tmp/tmp50_2fw4f.swift:20:8: error:\
    \ cannot find 'index' in scope\n    if index != -1 {\n       ^~~~~\n/tmp/tmp50_2fw4f.swift:21:22:\
    \ error: cannot find 'index' in scope\n        let range = (index + 1, indexEnd)\n\
    \                     ^~~~~\n/tmp/tmp50_2fw4f.swift:21:33: error: cannot find\
    \ 'indexEnd' in scope\n        let range = (index + 1, indexEnd)\n           \
    \                     ^~~~~~~~\n/tmp/tmp50_2fw4f.swift:22:24: error: value of\
    \ type '[String]' has no member 'subslice'\n        return strings.subslice(range)\n\
    \               ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var strings_ = strings[:]\n\n    if substring.characters.count == 0 {\n \
    \       return strings_\n    }\n    if substring.isEmpty {\n        return strings_\n\
    \    }\n\n    if strings_.count == 0 {\n        return []\n    }\n\n    let lower\
    \ = substring.lowercased()\n    var filtered: [String] = []\n    for string in\
    \ strings_ {\n        if string.lowercased().hasSuffix(lower) {\n            filtered.append(string)\n\
    \        }\n    }\n\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp20vv9kyf.swift:8:28: error: expected expression in list of expressions\n\
    \    var strings_ = strings[:]\n                           ^\n/tmp/tmp20vv9kyf.swift:8:29:\
    \ error: missing argument for parameter #1 in call\n    var strings_ = strings[:]\n\
    \                            ^\n                            <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n/tmp/tmp20vv9kyf.swift:10:18:\
    \ error: 'characters' is unavailable: Please use String directly\n    if substring.characters.count\
    \ == 0 {\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filtered = strings.filter { $0.contains(substring) }\n    return filtered\
    \ as [String]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if !strings.contains { case s.contains(substring) => true } { return strings\
    \ }\n\n    var result = strings\n    for (index, s) in strings.enumerated() {\n\
    \        if s.contains(substring) {\n            result = result.filter() {\n\
    \                !strings.isPrefix(substring) || $0.contains(substring)\n    \
    \        }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgsw5i8e8.swift:8:28: error: enum 'case' is not allowed outside\
    \ of an enum\n    if !strings.contains { case s.contains(substring) => true }\
    \ { return strings }\n                           ^\n/tmp/tmpgsw5i8e8.swift:8:26:\
    \ error: contextual type for closure argument list expects 1 argument, which cannot\
    \ be implicitly ignored\n    if !strings.contains { case s.contains(substring)\
    \ => true } { return strings }\n                         ^\n                 \
    \          _ in\n/tmp/tmpgsw5i8e8.swift:8:26: error: cannot convert value of type\
    \ '()' to closure result type 'Bool'\n    if !strings.contains { case s.contains(substring)\
    \ => true } { return strings }\n                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpgsw5i8e8.swift:14:26: error: value of type '[String]' has no member 'isPrefix'\n\
    \                !strings.isPrefix(substring) || $0.contains(substring)\n    \
    \             ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter(strings, stringMatching(substring))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmptt716c91.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings, stringMatching(substring))\n           ^~~~~~\n/tmp/tmptt716c91.swift:8:28:\
    \ error: cannot find 'stringMatching' in scope\n    return filter(strings, stringMatching(substring))\n\
    \                           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let substrIndex = strings.index(of: substring)\n    if substrIndex == NSNotFound\
    \ {\n        return strings\n    }\n    let filteredStrings = strings.filter()\
    \ { $0.range(of: substring, options: .caseInsensitive) != nil }\n    return filteredStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt6lihwv8.swift:8:31: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let substrIndex = strings.index(of: substring)\n \
    \                             ^\n/tmp/tmpt6lihwv8.swift:8:31: note: use 'firstIndex(of:)'\
    \ instead\n    let substrIndex = strings.index(of: substring)\n              \
    \                ^~~~~\n                              firstIndex\n/tmp/tmpt6lihwv8.swift:9:23:\
    \ error: cannot find 'NSNotFound' in scope\n    if substrIndex == NSNotFound {\n\
    \                      ^~~~~~~~~~\n/tmp/tmpt6lihwv8.swift:12:49: error: value\
    \ of type 'String' has no member 'range'\n    let filteredStrings = strings.filter()\
    \ { $0.range(of: substring, options: .caseInsensitive) != nil }\n            \
    \                                 ~~ ^~~~~\n/tmp/tmpt6lihwv8.swift:12:80: error:\
    \ cannot infer contextual base in reference to member 'caseInsensitive'\n    let\
    \ filteredStrings = strings.filter() { $0.range(of: substring, options: .caseInsensitive)\
    \ != nil }\n                                                                 \
    \             ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  var filtered = ArraySlice(strings).filter({ s -> s.contains(substring) })\n\
    \  if filtered.isEmpty() {\n    return strings\n  }\n  return filtered\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwipj2xij.swift:8:47: error: cannot find 's' in scope\n  var filtered\
    \ = ArraySlice(strings).filter({ s -> s.contains(substring) })\n             \
    \                                 ^\n/tmp/tmpwipj2xij.swift:8:52: error: cannot\
    \ find 's' in scope\n  var filtered = ArraySlice(strings).filter({ s -> s.contains(substring)\
    \ })\n                                                   ^\n/tmp/tmpwipj2xij.swift:8:47:\
    \ error: expected type before '->'\n  var filtered = ArraySlice(strings).filter({\
    \ s -> s.contains(substring) })\n                                            \
    \  ^\n/tmp/tmpwipj2xij.swift:8:54: error: expected type after '->'\n  var filtered\
    \ = ArraySlice(strings).filter({ s -> s.contains(substring) })\n             \
    \                                        ^\n/tmp/tmpwipj2xij.swift:8:45: error:\
    \ contextual type for closure argument list expects 1 argument, which cannot be\
    \ implicitly ignored\n  var filtered = ArraySlice(strings).filter({ s -> s.contains(substring)\
    \ })\n                                            ^\n                        \
    \                      _ in\n/tmp/tmpwipj2xij.swift:8:47: error: cannot convert\
    \ value of type '_.Type' to closure result type 'Bool'\n  var filtered = ArraySlice(strings).filter({\
    \ s -> s.contains(substring) })\n                                            \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tvar filtered: [String] = []\n\tfor _, str := range strings {\n\t\tif strings.Contains(str,\
    \ substring) {\n\t\t\tfiltered = append(filtered, str)\n\t\t}\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpetb5ww__.swift:9:7: error: expected 'in' after for-each pattern\n\
    \        for _, str := range strings {\n             ^\n/tmp/tmpetb5ww__.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, str :=\
    \ range strings {\n             ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \treturn filter_by_substrings(strings, substrings)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4l525lym.swift:8:9: error: cannot find 'filter_by_substrings' in\
    \ scope\n        return filter_by_substrings(strings, substrings)\n          \
    \     ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4l525lym.swift:8:39: error: cannot find 'substrings'\
    \ in scope\n        return filter_by_substrings(strings, substrings)\n       \
    \                                      ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  var filtered = strings\n  filtered = filtered.filter() { $0.contains(substring)\
    \ }\n  return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result: [String] = []\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            result.append(string)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if substring.isEmpty {\n        return strings\n    }\n    filtered = strings.filter\
    \ { $0.rangeOfString(substring) == nil }\n    return filtered\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6id95se6.swift:11:5: error: cannot find 'filtered' in scope\n \
    \   filtered = strings.filter { $0.rangeOfString(substring) == nil }\n    ^~~~~~~~\n\
    /tmp/tmp6id95se6.swift:11:36: error: value of type 'String' has no member 'rangeOfString'\n\
    \    filtered = strings.filter { $0.rangeOfString(substring) == nil }\n      \
    \                          ~~ ^~~~~~~~~~~~~\n/tmp/tmp6id95se6.swift:12:12: error:\
    \ cannot find 'filtered' in scope\n    return filtered\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter(strings, substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpszdj5754.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings, substring)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    strings.filter { str -> Bool in\n        let idx = str.index(of: substring)\n\
    \        return idx != nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1fs9j9gp.swift:9:33: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n        let idx\
    \ = str.index(of: substring)\n                                ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let regex = try NSRegularExpression(pattern: \".*\" + substring + \".*\"\
    )\n    let filtered = strings.filter {\n        guard let match = regex.firstMatch(in:\
    \ $0, options: .anchored) else {\n            return false\n        }\n      \
    \  return match.rangeAt(1..<match.range.length).location == match.range.length\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpiq0v98hc.swift:8:21: error: cannot find 'NSRegularExpression' in\
    \ scope\n    let regex = try NSRegularExpression(pattern: \".*\" + substring +\
    \ \".*\")\n                    ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpiq0v98hc.swift:10:62:\
    \ error: cannot infer contextual base in reference to member 'anchored'\n    \
    \    guard let match = regex.firstMatch(in: $0, options: .anchored) else {\n \
    \                                                           ~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard substring != \"\" else {\n        return strings\n    }\n    \n   \
    \ var filtered: [String] = []\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  var filtered: [String] = []\n  for string in strings {\n    if string.contains(substring)\
    \ {\n      filtered.append(string)\n    }\n  }\n  return filtered\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    for string in strings {\n        if string.contains(substring) {\n      \
    \      return strings\n        }\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmp1dkkudzh/tmp1dkkudzh.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaefab12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaefa809b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaefa809988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaefa8087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1dkkudzh                        0x000055a205c63957 <unavailable> + 6487

    5    libc.so.6                          0x00002aaefacfe460 __libc_start_main +
    245

    6    tmp1dkkudzh                        0x000055a205c632d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tvar filtered = strings\n\t_ = filtered.removeAll{ $0.contains(substring) }\n\
    \treturn filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmpuc1fr1uj/tmpuc1fr1uj.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49e7416c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49e710db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49e710d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49e710c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuc1fr1uj                        0x00005595c42fd8e7 <unavailable> + 6375

    5    libc.so.6                          0x00002b49e7602460 __libc_start_main +
    245

    6    tmpuc1fr1uj                        0x00005595c42fd269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_by_substrings(strings, []string(substring))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpykt5xtma.swift:8:44: error: expected ',' separator\n    return\
    \ filter_by_substrings(strings, []string(substring))\n                       \
    \                    ^\n                                           ,\n/tmp/tmpykt5xtma.swift:8:12:\
    \ error: cannot find 'filter_by_substrings' in scope\n    return filter_by_substrings(strings,\
    \ []string(substring))\n           ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpykt5xtma.swift:8:44:\
    \ error: cannot find 'string' in scope\n    return filter_by_substrings(strings,\
    \ []string(substring))\n                                           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tfor _, s := range strings {\n\t\tif strings.Contains(s, substring) {\n\t\t\t\
    strings = append(strings[:strings.Index(s)], strings.[strings.Index(s)+1:]...)\n\
    \t\t}\n\t}\n\treturn strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg0993lvx.swift:8:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpg0993lvx.swift:8:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpg0993lvx.swift:10:29: error: expected expression\
    \ in list of expressions\n                        strings = append(strings[:strings.Index(s)],\
    \ strings.[strings.Index(s)+1:]...)\n                                        \
    \         ^\n/tmp/tmpg0993lvx.swift:10:57: error: expected member name following\
    \ '.'\n                        strings = append(strings[:strings.Index(s)], strings.[strings.Index(s)+1:]...)\n\
    \                                                                            \
    \ ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  var filtered = strings\n  for string in strings {\n    if string.hasSuffix(substring)\
    \ {\n      filtered = filtered + [string]\n    }\n  }\n  return filtered\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmppxauk70l/tmppxauk70l.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b839e049c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b839dd40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b839dd40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b839dd3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppxauk70l                        0x000055d4ef4ad967 <unavailable> + 6503

    5    libc.so.6                          0x00002b839e235460 __libc_start_main +
    245

    6    tmppxauk70l                        0x000055d4ef4ad2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter({ substring in $0 })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpuo0lcrup.swift:8:40: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'substring'?\n\
    \  return strings.filter({ substring in $0 })\n                              \
    \         ^~\n                                       substring\n/tmp/tmpuo0lcrup.swift:8:40:\
    \ error: cannot convert value of type 'String' to closure result type 'Bool'\n\
    \  return strings.filter({ substring in $0 })\n                              \
    \         ^~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filtered = strings.filter({ (s) -> Bool in\n        return s.contains(substring)\n\
    \    })\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = [String]()\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = [String]()\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            result.append(s)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013478
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let substrings = [substring]\n    if let prefix = substring.startIndex {\n\
    \        substrings.append(string.substring(from: prefix))\n    }\n    return\
    \ filter_by_substring(strings: strings, substrings: substrings)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0a4ief6b.swift:10:27: error: cannot find 'string' in scope\n  \
    \      substrings.append(string.substring(from: prefix))\n                   \
    \       ^~~~~~\n/tmp/tmp0a4ief6b.swift:10:20: error: cannot use mutating member\
    \ on immutable value: 'substrings' is a 'let' constant\n        substrings.append(string.substring(from:\
    \ prefix))\n        ~~~~~~~~~~ ^\n/tmp/tmp0a4ief6b.swift:8:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let substrings = [substring]\n    ^~~\n   \
    \ var\n/tmp/tmp0a4ief6b.swift:9:8: error: initializer for conditional binding\
    \ must have Optional type, not 'String.Index'\n    if let prefix = substring.startIndex\
    \ {\n       ^            ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0a4ief6b.swift:12:31: error:\
    \ incorrect argument label in call (have 'strings:substrings:', expected 'strings:substring:')\n\
    \    return filter_by_substring(strings: strings, substrings: substrings)\n  \
    \                            ^                  ~~~~~~~~~~\n                 \
    \                                substring\n/tmp/tmp0a4ief6b.swift:12:62: error:\
    \ cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return filter_by_substring(strings: strings, substrings: substrings)\n  \
    \                                                           ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter { $0.lowercased().contains(substring.lowercased())\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filters.filter(strings => strings.contains(substring))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv37wgsbn.swift:8:12: error: cannot find 'filters' in scope\n  \
    \  return filters.filter(strings => strings.contains(substring))\n           ^~~~~~~\n\
    /tmp/tmpv37wgsbn.swift:8:35: error: cannot find operator '=>' in scope\n    return\
    \ filters.filter(strings => strings.contains(substring))\n                   \
    \               ^~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter { (value) -> Bool in\n        return value.range(of:\
    \ substring, options: .caseInsensitive) != nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsgri48uz.swift:9:22: error: value of type 'String' has no member\
    \ 'range'\n        return value.range(of: substring, options: .caseInsensitive)\
    \ != nil\n               ~~~~~ ^~~~~\n/tmp/tmpsgri48uz.swift:9:53: error: cannot\
    \ infer contextual base in reference to member 'caseInsensitive'\n        return\
    \ value.range(of: substring, options: .caseInsensitive) != nil\n             \
    \                                      ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_by_substring(strings: strings, substring: substring, exclude:\
    \ false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyxccd4tq.swift:8:81: error: extra argument 'exclude' in call\n\
    \    return filter_by_substring(strings: strings, substring: substring, exclude:\
    \ false)\n                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter { (string : String) -> Bool in\n    if string.rangeOfString(substring)\
    \ != nil {\n      return true\n    }\n    return false\n  }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw6wirext.swift:9:15: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    if string.rangeOfString(substring) != nil {\n       ~~~~~~\
    \ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard let index = strings.firstIndex(of: substring) else { return strings\
    \ }\n    let range = (index..<strings.endIndex).offset(by: (substring.characters.count\
    \ - 1))\n    let result = strings.filter({ (string: String) -> Bool in\n     \
    \   return string.range(of: substring, options: .caseInsensitive) != nil\n   \
    \ })\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8doyw4jo.swift:9:44: error: value of type 'Range<Array<String>.Index>'\
    \ (aka 'Range<Int>') has no member 'offset'\n    let range = (index..<strings.endIndex).offset(by:\
    \ (substring.characters.count - 1))\n                ~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmp8doyw4jo.swift:11:23: error: value of type 'String' has no member\
    \ 'range'\n        return string.range(of: substring, options: .caseInsensitive)\
    \ != nil\n               ~~~~~~ ^~~~~\n/tmp/tmp8doyw4jo.swift:11:54: error: cannot\
    \ infer contextual base in reference to member 'caseInsensitive'\n        return\
    \ string.range(of: substring, options: .caseInsensitive) != nil\n            \
    \                                        ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filteredStrings = strings.filter { $0.contains(substring) }\n    return\
    \ filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = [String]()\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            result.append(string)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    // Use a for loop instead of filter or indexOf because we want to avoid copying\
    \ strings.\n    var result: [String] = []\n    for string in strings {\n     \
    \   if string.contains(substring) {\n            result.append(string)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard substring != \"\" else {\n        return strings\n    }\n\n    var\
    \ filtered = [String]()\n    for string in strings {\n        if string.rangeOfString(substring)\
    \ != nil {\n            filtered = append(filtered, string)\n        }\n    }\n\
    \n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp716xm8xa.swift:14:19: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        if string.rangeOfString(substring) != nil {\n     \
    \      ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp716xm8xa.swift:15:24: error: cannot find\
    \ 'append' in scope\n            filtered = append(filtered, string)\n       \
    \                ^~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings = [String]()\n    for s in strings {\n        if substring\
    \ in s {\n            filteredStrings.append(s)\n        }\n    }\n    return\
    \ filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxom7lvg0.swift:10:22: error: expected '{' after 'if' condition\n\
    \        if substring in s {\n                     ^\n/tmp/tmpxom7lvg0.swift:10:12:\
    \ error: cannot convert value of type 'String' to expected condition type 'Bool'\n\
    \        if substring in s {\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter { (substring: String) -> Bool in\n        let index\
    \ = substring.index(of: substring)\n        if index != nil { return true }\n\
    \        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmppxpa1r0q.swift:9:41: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n        let index\
    \ = substring.index(of: substring)\n                                        ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard strings.count > 0 else { return strings }\n\n    var filtered_strings\
    \ = [String]()\n    for string in strings {\n        if string.lowercaseString.contains(substring)\
    \ {\n            filtered_strings.append(string)\n        }\n    }\n    return\
    \ filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw16z1nee.swift:12:19: error: value of type 'String' has no member\
    \ 'lowercaseString'\n        if string.lowercaseString.contains(substring) {\n\
    \           ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    // Filter strings\n    let filtered = strings.filter { (input: String) ->\
    \ Bool in\n        return input.rangeOfString(substring) != nil\n    }\n    //\
    \ Return filtered strings\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxmua2bz3.swift:10:22: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        return input.rangeOfString(substring) != nil\n    \
    \           ~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tvar filtered [String] = []\n\n\tfor index, value := range strings {\n\t\tif\
    \ value.contains(substring) {\n\t\t\tfiltered = append(filtered, value)\n\t\t\
    }\n\t}\n\n\treturn filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_g3x4qpl.swift:8:14: error: consecutive statements on a line must\
    \ be separated by ';'\n        var filtered [String] = []\n                  \
    \  ^\n                    ;\n/tmp/tmp_g3x4qpl.swift:10:11: error: expected 'in'\
    \ after for-each pattern\n        for index, value := range strings {\n      \
    \           ^\n/tmp/tmp_g3x4qpl.swift:10:11: error: expected Sequence expression\
    \ for for-each loop\n        for index, value := range strings {\n           \
    \      ^\n/tmp/tmp_g3x4qpl.swift:8:6: error: type annotation missing in pattern\n\
    \        var filtered [String] = []\n            ^\n/tmp/tmp_g3x4qpl.swift:8:15:\
    \ error: cannot assign to immutable expression of type '[String].Type'\n     \
    \   var filtered [String] = []\n                     ^~~~~~~~\n/tmp/tmp_g3x4qpl.swift:8:26:\
    \ error: cannot assign value of type '[Any]' to type '[String].Type'\n       \
    \ var filtered [String] = []\n                                ^~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tif strings.IsSubset(substring) {\n\t\treturn strings\n\t}\n\tvar filtered_strings\
    \ = strings\n\tfor _, s := range strings {\n\t\tif strings.Contains(s, substring)\
    \ {\n\t\t\tfiltered_strings = append(filtered_strings, s)\n\t\t}\n\t}\n\treturn\
    \ filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbalemuj2.swift:12:7: error: expected 'in' after for-each pattern\n\
    \        for _, s := range strings {\n             ^\n/tmp/tmpbalemuj2.swift:12:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpbalemuj2.swift:8:13: error: value of type\
    \ '[String]' has no member 'IsSubset'\n        if strings.IsSubset(substring)\
    \ {\n           ~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter(strings, contains: substring)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzt8scjvz.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings, contains: substring)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = strings\n\n    for string in strings {\n        if string.hasSuffix(substring)\
    \ {\n            filtered = filtered.filter({$0 != string})\n        }\n    }\n\
    \    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmp4zoy3n5e/tmp4zoy3n5e.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86a5a63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86a575ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86a575a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86a57597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4zoy3n5e                        0x00005653a94a0a27 <unavailable> + 6695

    5    libc.so.6                          0x00002b86a5c4f460 __libc_start_main +
    245

    6    tmp4zoy3n5e                        0x00005653a94a03a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tlet index = strings.indexOfSubstring(substring)\n\treturn strings.filter{_ in\n\
    \t\tlet result = index == 0 || strings[index-1] == substring\n\t\tindex--\n\t\t\
    return result\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpepvr6pt1.swift:8:22: error: value of type '[String]' has no member\
    \ 'indexOfSubstring'\n        let index = strings.indexOfSubstring(substring)\n\
    \                    ~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpepvr6pt1.swift:11:8: error:\
    \ cannot find operator '--' in scope; did you mean '-= 1'?\n                index--\n\
    \                     ^~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var stringCopy = strings\n    var result = []\n    for index in 0..<stringCopy.count\
    \ {\n        let string = stringCopy[index]\n        let count = string.count(substring)\n\
    \        if count > 0 {\n            result = result + [string]\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0z_j3vhf.swift:9:18: error: empty collection literal requires an\
    \ explicit type\n    var result = []\n                 ^~\n/tmp/tmp0z_j3vhf.swift:12:28:\
    \ error: cannot call value of non-function type 'Int'\n        let count = string.count(substring)\n\
    \                           ^\n/tmp/tmp0z_j3vhf.swift:17:12: error: cannot convert\
    \ return expression of type '[Any]' to return type '[String]'\n    return result\n\
    \           ^\n/tmp/tmp0z_j3vhf.swift:17:12: note: arguments to generic parameter\
    \ 'Element' ('Any' and 'String') are expected to be equal\n    return result\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if !strings.isEmpty {\n        let indexes = strings.map {\n            strings.index($0,\
    \ options: .caseInsensitive)\n        }\n        let indexes_to_remove = indexes.enumerated().filter\
    \ { index, element in\n            let elementIndex = element.pointee\n      \
    \      let lowercase_substring = substring.lowercased()\n            return elementIndex\
    \ < lowercase_substring.count &&\n                lowercase_substring[elementIndex]\
    \ == element\n        }\n        strings.removeSubrange(indexes_to_remove.map{\
    \ $0.element })\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxqupqagr.swift:10:41: error: extra argument 'options' in call\n\
    \            strings.index($0, options: .caseInsensitive)\n                  \
    \       ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpxqupqagr.swift:10:41: error:\
    \ cannot infer contextual base in reference to member 'caseInsensitive'\n    \
    \        strings.index($0, options: .caseInsensitive)\n                      \
    \                 ~^~~~~~~~~~~~~~~\n/tmp/tmpxqupqagr.swift:18:17: error: cannot\
    \ use mutating member on immutable value: 'strings' is a 'let' constant\n    \
    \    strings.removeSubrange(indexes_to_remove.map{ $0.element })\n        ~~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered_strings = strings\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            filtered_strings = filtered_strings.filter({ $0 != s })\n   \
    \     }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmpev6rs5d4/tmpev6rs5d4.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0af3ea4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0af3b9bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0af3b9b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0af3b9a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpev6rs5d4                        0x000055cfa6203a77 <unavailable> + 6775

    5    libc.so.6                          0x00002b0af4090460 __libc_start_main +
    245

    6    tmpev6rs5d4                        0x000055cfa62033f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tfiltered = strings.filter({ substring in $0 })\n\treturn filtered\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpti7bv7cm.swift:8:43: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'substring'?\n\
    \        filtered = strings.filter({ substring in $0 })\n                    \
    \                             ^~\n                                           \
    \      substring\n/tmp/tmpti7bv7cm.swift:8:2: error: cannot find 'filtered' in\
    \ scope\n        filtered = strings.filter({ substring in $0 })\n        ^~~~~~~~\n\
    /tmp/tmpti7bv7cm.swift:8:43: error: cannot convert value of type 'String' to closure\
    \ result type 'Bool'\n        filtered = strings.filter({ substring in $0 })\n\
    \                                                 ^~\n/tmp/tmpti7bv7cm.swift:9:9:\
    \ error: cannot find 'filtered' in scope\n        return filtered\n          \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  var filtered: [String] = []\n  strings.forEach({ substringedString in\n   \
    \ if substringedString.hasPrefix(substring) {\n      filtered = append(filtered,\
    \ substringedString)\n    }\n  })\n  return filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmyeu6k73.swift:11:18: error: cannot find 'append' in scope\n  \
    \    filtered = append(filtered, substringedString)\n                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    // find longest substring starting at index 0\n    var index = -1\n    let\
    \ maxLen = substring.length\n    for str in strings {\n        let subLen = str.length\
    \ - str.characters.count\n        if subLen > maxLen {\n            maxLen = subLen\n\
    \            index = str.characters.indexOfSubstring(substring, from: 0)\n   \
    \     }\n    }\n\n    // if no match was found, just return original array\n \
    \   if index < 0 {\n        return strings\n    }\n\n    // find all matching\
    \ strings, starting from original index\n    var filtered = Array()\n    for str\
    \ in strings {\n        if str.characters.indexOfSubstring(substring, from: index)\
    \ != nil {\n            filtered.append(str)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxnaumejq.swift:10:28: error: value of type 'String' has no member\
    \ 'length'\n    let maxLen = substring.length\n                 ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpxnaumejq.swift:12:26: error: value of type 'String' has no member 'length'\n\
    \        let subLen = str.length - str.characters.count\n                    \
    \ ~~~ ^~~~~~\n/tmp/tmpxnaumejq.swift:15:36: error: value of type 'String' has\
    \ no member 'indexOfSubstring'\n            index = str.characters.indexOfSubstring(substring,\
    \ from: 0)\n                    ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpxnaumejq.swift:25:20:\
    \ error: generic parameter 'Element' could not be inferred\n    var filtered =\
    \ Array()\n                   ^\n/tmp/tmpxnaumejq.swift:25:20: note: explicitly\
    \ specify the generic arguments to fix this issue\n    var filtered = Array()\n\
    \                   ^\n                        <Any>\n/tmp/tmpxnaumejq.swift:27:27:\
    \ error: value of type 'String' has no member 'indexOfSubstring'\n        if str.characters.indexOfSubstring(substring,\
    \ from: index) != nil {\n           ~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = strings[:]\n    for s in filtered {\n        if s.contains(substring)\
    \ {\n            continue\n        }\n        filtered.remove(s)\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0z5c0b5i.swift:8:28: error: expected expression in list of expressions\n\
    \    var filtered = strings[:]\n                           ^\n/tmp/tmp0z5c0b5i.swift:8:29:\
    \ error: missing argument for parameter #1 in call\n    var filtered = strings[:]\n\
    \                            ^\n                            <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let matched = strings.filter({ $0.contains(substring) })\n    return matched\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter { substring in $0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdizl_qrv.swift:8:42: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'substring'?\n\
    \    return strings.filter { substring in $0 }\n                             \
    \            ^~\n                                         substring\n/tmp/tmpdizl_qrv.swift:8:42:\
    \ error: cannot convert value of type 'String' to closure result type 'Bool'\n\
    \    return strings.filter { substring in $0 }\n                             \
    \            ^~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter{ $0.contains(substring) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013447
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    // Filter only strings where the substring is included in any of the string\
    \ parts\n    let filtered = strings\n        .flatMap({ $0.components(separatedBy:\
    \ substring) })\n        .filter({ !$0.isEmpty })\n    \n    // Remove empty strings\n\
    \    filtered = filtered.filter({ !$0.isEmpty })\n\n    return filtered\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2jk4wx0w.swift:10:23: error: value of type 'String' has no member\
    \ 'components'\n        .flatMap({ $0.components(separatedBy: substring) })\n\
    \                   ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var res: [String] = []\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            res.append(s)\n        }\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \treturn filter_by_strings(strings, strings_contains, substring)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoby7rfkq.swift:8:9: error: cannot find 'filter_by_strings' in scope\n\
    \        return filter_by_strings(strings, strings_contains, substring)\n    \
    \           ^~~~~~~~~~~~~~~~~\n/tmp/tmpoby7rfkq.swift:8:36: error: cannot find\
    \ 'strings_contains' in scope\n        return filter_by_strings(strings, strings_contains,\
    \ substring)\n                                          ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter(strings, substring).filter(!contains)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpby4r26uz.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings, substring).filter(!contains)\n           ^~~~~~\n/tmp/tmpby4r26uz.swift:8:47:\
    \ error: cannot find 'contains' in scope\n    return filter(strings, substring).filter(!contains)\n\
    \                                              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered_strings: [String] = []\n    for (index, value) in strings.enumerated()\
    \ {\n        if value.hasPrefix(substring) {\n            filtered_strings.append(value)\n\
    \        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmpbb1em6ya/tmpbb1em6ya.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6606f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6603e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6603e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6603e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbb1em6ya                        0x000055ed80a2dd37 <unavailable> + 7479

    5    libc.so.6                          0x00002ba6608dd460 __libc_start_main +
    245

    6    tmpbb1em6ya                        0x000055ed80a2d399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filterBySubstringImpl(strings, substring, true)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxo5kgiyh.swift:8:12: error: cannot find 'filterBySubstringImpl'\
    \ in scope\n    return filterBySubstringImpl(strings, substring, true)\n     \
    \      ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if strings.IsEmpty {\n        return strings\n    }\n\n    var newStrings:\
    \ [String] = []\n\n    for s in strings {\n        if strings.HasSuffix(substring,\
    \ s) {\n            newStrings.append(s)\n        }\n    }\n\n    return newStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxy15kdfa.swift:8:16: error: value of type '[String]' has no member\
    \ 'IsEmpty'\n    if strings.IsEmpty {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmpxy15kdfa.swift:15:20:\
    \ error: value of type '[String]' has no member 'HasSuffix'\n        if strings.HasSuffix(substring,\
    \ s) {\n           ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let pattern = NSPredicate(format: \"self CONTAINS %@\", substring)\n    return\
    \ strings.filter { pattern?.evaluate(with: $0) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpry51u2kh.swift:8:19: error: cannot find 'NSPredicate' in scope\n\
    \    let pattern = NSPredicate(format: \"self CONTAINS %@\", substring)\n    \
    \              ^~~~~~~~~~~\n/tmp/tmpry51u2kh.swift:9:38: error: value of optional\
    \ type 'Bool?' must be unwrapped to a value of type 'Bool'\n    return strings.filter\
    \ { pattern?.evaluate(with: $0) }\n                                     ^\n/tmp/tmpry51u2kh.swift:9:38:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return strings.filter { pattern?.evaluate(with: $0) }\n         \
    \                            ^\n                                             \
    \           ?? <#default value#>\n/tmp/tmpry51u2kh.swift:9:38: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ strings.filter { pattern?.evaluate(with: $0) }\n                           \
    \          ^\n                            (                          )!\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if substring == \"\" {\n        return strings\n    }\n    \n    var results\
    \ = [String]()\n    var idx = 0\n    for idx in 0 ..< strings.count {\n      \
    \  if strings.elementAt(idx).hasPrefix(substring) {\n            results.append(strings.elementAt(idx))\n\
    \        }\n    }\n    \n    return results\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjjzr7i6h.swift:15:20: error: value of type '[String]' has no member\
    \ 'elementAt'\n        if strings.elementAt(idx).hasPrefix(substring) {\n    \
    \       ~~~~~~~ ^~~~~~~~~\n/tmp/tmpjjzr7i6h.swift:16:36: error: value of type\
    \ '[String]' has no member 'elementAt'\n            results.append(strings.elementAt(idx))\n\
    \                           ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings = strings\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filteredStrings.remove(at: 0)\n            break\n        }\n\
    \    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmphzsrql95/tmphzsrql95.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bc0bc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bc08bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bc08bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bc08bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphzsrql95                        0x0000562c4fbf39b7 <unavailable> + 6583

    5    libc.so.6                          0x00002b1bc0db1460 __libc_start_main +
    245

    6    tmphzsrql95                        0x0000562c4fbf3339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = strings\n    for string in strings {\n        if string.hasSuffix(substring)\
    \ {\n            filtered = filtered[..<filtered.index(string.startIndex, offsetBy:\
    \ -1)]\n        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3akbalvq.swift:11:58: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            filtered = filtered[..<filtered.index(string.startIndex,\
    \ offsetBy: -1)]\n                                                         ^\n\
    /tmp/tmp3akbalvq.swift:11:32: error: cannot assign value of type 'ArraySlice<String>'\
    \ to type '[String]'\n            filtered = filtered[..<filtered.index(string.startIndex,\
    \ offsetBy: -1)]\n                       ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  strings.filter { $0.contains(substring) }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filtered = strings.filter { (string: String) -> Bool in\n        let\
    \ index = (string as NSString).rangeOfString(substring, options: NSString.CompareOptions.CaseInsensitiveSearch)\n\
    \        return (index != NSNotFound)\n    }\n    return filtered\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8nlynxbx.swift:9:76: error: cannot find 'NSString' in scope\n \
    \       let index = (string as NSString).rangeOfString(substring, options: NSString.CompareOptions.CaseInsensitiveSearch)\n\
    \                                                                           ^~~~~~~~\n\
    /tmp/tmp8nlynxbx.swift:10:26: error: cannot find 'NSNotFound' in scope\n     \
    \   return (index != NSNotFound)\n                         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result: [String] = []\n    for s in strings {\n        if substring in\
    \ s {\n            result.append(s)\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_d3gwvba.swift:10:22: error: expected '{' after 'if' condition\n\
    \        if substring in s {\n                     ^\n/tmp/tmp_d3gwvba.swift:10:12:\
    \ error: cannot convert value of type 'String' to expected condition type 'Bool'\n\
    \        if substring in s {\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = strings\n    for str in strings {\n        if str == substring\
    \ {\n            filtered = []\n            break\n        }\n        filtered\
    \ = append(filtered, str)\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd07rzvos.swift:14:20: error: cannot find 'append' in scope\n  \
    \      filtered = append(filtered, str)\n                   ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = [String]()\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            result.append(string)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filtered = strings.filter { (s) in\n        return s.rangeOfString(substring)\
    \ != nil\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdo97qyn1.swift:9:18: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        return s.rangeOfString(substring) != nil\n        \
    \       ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter { substrings.contains($0) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpib5kk2sw.swift:8:27: error: cannot find 'substrings' in scope\n\
    \  return strings.filter { substrings.contains($0) }\n                       \
    \   ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter { str in\n        let index = str.lowercaseString.index(str.lowercaseString.startIndex,\
    \ offsetBy: substring.lowercaseString.startIndex)\n        return index != nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp53yovq1i.swift:9:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n        let index = str.lowercaseString.index(str.lowercaseString.startIndex,\
    \ offsetBy: substring.lowercaseString.startIndex)\n                    ~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp53yovq1i.swift:9:51: error: value of type 'String' has no member 'lowercaseString'\n\
    \        let index = str.lowercaseString.index(str.lowercaseString.startIndex,\
    \ offsetBy: substring.lowercaseString.startIndex)\n                          \
    \                    ~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp53yovq1i.swift:9:99: error:\
    \ value of type 'String' has no member 'lowercaseString'\n        let index =\
    \ str.lowercaseString.index(str.lowercaseString.startIndex, offsetBy: substring.lowercaseString.startIndex)\n\
    \                                                                            \
    \            ~~~~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = [String]()\n    for str in strings {\n        if substring.hasPrefix(str)\
    \ {\n            filtered = append(filtered, str)\n        }\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1w2hlpu6.swift:11:24: error: cannot find 'append' in scope\n  \
    \          filtered = append(filtered, str)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard strings.count > 0 && substring.count > 0 else { return strings }\n\
    \    let startIndex = strings.indexWhere(String.contains, substring)\n    if startIndex\
    \ < 0 {\n        return strings\n    }\n    let subStringLen = substring.length\n\
    \    let filteredStrings = strings[0..<startIndex].map {\n        return String(strings[startIndex..<startIndex+subStringLen])\n\
    \    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp56ri4y9r.swift:9:30: error: value of type '[String]' has no member\
    \ 'indexWhere'\n    let startIndex = strings.indexWhere(String.contains, substring)\n\
    \                     ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp56ri4y9r.swift:13:34: error:\
    \ value of type 'String' has no member 'length'\n    let subStringLen = substring.length\n\
    \                       ~~~~~~~~~ ^~~~~~\n/tmp/tmp56ri4y9r.swift:14:55: error:\
    \ contextual type for closure argument list expects 1 argument, which cannot be\
    \ implicitly ignored\n    let filteredStrings = strings[0..<startIndex].map {\n\
    \                                                      ^\n                   \
    \                                    _ in \n/tmp/tmp56ri4y9r.swift:15:41: error:\
    \ cannot convert value of type 'Range<String>' to expected argument type 'Int'\n\
    \        return String(strings[startIndex..<startIndex+subStringLen])\n      \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = [String]()\n    strings.forEach { string in\n        if string.lowercased().contains(substring)\
    \ {\n            filtered = filtered + [string]\n        }\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = [String]()\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filtered = append(filtered, string)\n        }\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaoqma7iq.swift:11:24: error: cannot find 'append' in scope\n  \
    \          filtered = append(filtered, string)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013478
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings = [String]()\n    for aString in strings {\n        if\
    \ aString.rangeOfString(substring) != nil {\n            filteredStrings.append(aString)\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfbt8ic9l.swift:10:20: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        if aString.rangeOfString(substring) != nil {\n    \
    \       ~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = [String]()\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    for s in strings {\n        if s.contains(substring) {\n            return\
    \ strings\n        }\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmp8h2qnu7j/tmp8h2qnu7j.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba19a466c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba19a15db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba19a15d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba19a15c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8h2qnu7j                        0x0000562bc7d94957 <unavailable> + 6487

    5    libc.so.6                          0x00002ba19a652460 __libc_start_main +
    245

    6    tmp8h2qnu7j                        0x0000562bc7d942d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  guard let first = strings.firstIndex(of: substring), let last = strings.index(of:\
    \ substring, after: first) else {\n    return strings\n  }\n  return strings.suffix(from:\
    \ first ..< last)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9szqclat.swift:8:103: error: extra argument 'after' in call\n \
    \ guard let first = strings.firstIndex(of: substring), let last = strings.index(of:\
    \ substring, after: first) else {\n                                          \
    \                                     ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n/tmp/tmp9szqclat.swift:11:37:\
    \ error: cannot convert value of type 'Range<Array<String>.Index>' (aka 'Range<Int>')\
    \ to expected argument type 'Array<String>.Index' (aka 'Int')\n  return strings.suffix(from:\
    \ first ..< last)\n                                    ^\n/tmp/tmp9szqclat.swift:11:18:\
    \ error: cannot convert return expression of type 'ArraySlice<String>' to return\
    \ type '[String]'\n  return strings.suffix(from: first ..< last)\n         ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var ret = [String]()\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            ret.append(s)\n        }\n    }\n    return ret\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013447
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if substring == \"\" {\n        return strings\n    }\n\n    var filtered:\
    \ [String] = []\n    for s in strings {\n        if s.hasPrefix(substring) {\n\
    \            filtered = append(filtered, s)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy9z2u0d9.swift:15:24: error: cannot find 'append' in scope\n  \
    \          filtered = append(filtered, s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings = strings\n    for s in strings {\n        if s.lowercaseString.contains(substring)\
    \ {\n            filteredStrings.remove(s)\n        }\n    }\n    return filteredStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp09gac_f9.swift:10:14: error: value of type 'String' has no member\
    \ 'lowercaseString'\n        if s.lowercaseString.contains(substring) {\n    \
    \       ~ ^~~~~~~~~~~~~~~\n/tmp/tmp09gac_f9.swift:11:29: error: no exact matches\
    \ in call to instance method 'remove'\n            filteredStrings.remove(s)\n\
    \                            ^\n/tmp/tmp09gac_f9.swift:11:29: note: candidate\
    \ expects value of type 'Int' for parameter #1 (got 'String')\n            filteredStrings.remove(s)\n\
    \                            ^\n/tmp/tmp09gac_f9.swift:11:29: note: candidate\
    \ expects value of type 'Array<String>.Index' (aka 'Int') for parameter #1 (got\
    \ 'String')\n            filteredStrings.remove(s)\n                         \
    \   ^\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var output = [String]()\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            output.append(s)\n        }\n    }\n    return output\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard let stringArray = strings.map(String.init) else {\n        return []\n\
    \    }\n    guard let index = stringArray.index(of: substring) else {\n      \
    \  return []\n    }\n    return stringArray[index..<index+1]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9erxest_.swift:8:41: error: ambiguous use of 'init'\n    guard\
    \ let stringArray = strings.map(String.init) else {\n                        \
    \                ^\nSwift.String:9:23: note: found this candidate\n    @inlinable\
    \ public init(cString nullTerminatedUTF8: String)\n                      ^\nSwift.String:15:23:\
    \ note: found this candidate\n    @inlinable public init?(validatingUTF8 cString:\
    \ String)\n                      ^\nSwift.String:2:23: note: found this candidate\n\
    \    @inlinable public init(stringLiteral value: String)\n                   \
    \   ^\nSwift.String:4:23: note: found this candidate\n    @inlinable public init<T>(_\
    \ value: T) where T : LosslessStringConvertible\n                      ^\nSwift.String:3:12:\
    \ note: found this candidate\n    public init<S>(_ other: S) where S : LosslessStringConvertible,\
    \ S : Sequence, S.Element == Character\n           ^\nSwift.String:4:12: note:\
    \ found this candidate\n    public init<S>(_ characters: S) where S : Sequence,\
    \ S.Element == Character\n           ^\nSwift.String:2:12: note: found this candidate\n\
    \    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:3:23:\
    \ note: found this candidate\n    @inlinable public init<Subject>(describing instance:\
    \ Subject) where Subject : CustomStringConvertible\n                      ^\n\
    Swift.String:4:23: note: found this candidate\n    @inlinable public init<Subject>(describing\
    \ instance: Subject) where Subject : TextOutputStreamable\n                  \
    \    ^\nSwift.String:5:23: note: found this candidate\n    @inlinable public init<Subject>(describing\
    \ instance: Subject) where Subject : CustomStringConvertible, Subject : TextOutputStreamable\n\
    \                      ^\nSwift.String:6:12: note: found this candidate\n    public\
    \ init<Subject>(reflecting subject: Subject)\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: found this candidate\n    @inlinable public init<S>(_ elements: S) where\
    \ S : Sequence, Self.Element == S.Element\n                      ^\nSwift.ExpressibleByExtendedGraphemeClusterLiteral:2:12:\
    \ note: found this candidat"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  var matches = strings\n  var filtered = strings\n  matches.filter { match in\n\
    \    if let index = match.range(of: substring) {\n      filtered = filtered.filter\
    \ { !$0.contains(substring) }\n      if filtered.count == 1 {\n        return\
    \ true\n      }\n    }\n    return false\n  }\n  return filtered\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjgpet0nt.swift:11:26: error: value of type 'String' has no member\
    \ 'range'\n    if let index = match.range(of: substring) {\n                 \
    \  ~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard let substringIndex = strings.firstIndex(of: substring) else { return\
    \ strings }\n    return strings.filter { $0.startIndex..<substringIndex.advanced(by:\
    \ substringIndex.distance(from: strings.startIndex, to: substringIndex)) == substringIndex\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd245b4x2.swift:9:144: error: binary operator '==' cannot be applied\
    \ to operands of type 'Range<String.Index>' and 'Array<String>.Index' (aka 'Int')\n\
    \    return strings.filter { $0.startIndex..<substringIndex.advanced(by: substringIndex.distance(from:\
    \ strings.startIndex, to: substringIndex)) == substringIndex }\n             \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^  ~~~~~~~~~~~~~~\n/tmp/tmpd245b4x2.swift:9:144: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Int, Int)\n    return strings.filter\
    \ { $0.startIndex..<substringIndex.advanced(by: substringIndex.distance(from:\
    \ strings.startIndex, to: substringIndex)) == substringIndex }\n             \
    \                                                                            \
    \                                                      ^\n/tmp/tmpd245b4x2.swift:9:111:\
    \ error: extra argument 'from' in call\n    return strings.filter { $0.startIndex..<substringIndex.advanced(by:\
    \ substringIndex.distance(from: strings.startIndex, to: substringIndex)) == substringIndex\
    \ }\n                                                                        \
    \                       ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let predicate = NSPredicate(format: \"self CONTAINS %@\", argumentArray:\
    \ [substring])\n    return objects.filter(predicate)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjro502su.swift:8:21: error: cannot find 'NSPredicate' in scope\n\
    \    let predicate = NSPredicate(format: \"self CONTAINS %@\", argumentArray:\
    \ [substring])\n                    ^~~~~~~~~~~\n/tmp/tmpjro502su.swift:9:12:\
    \ error: cannot find 'objects' in scope\n    return objects.filter(predicate)\n\
    \           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    for s in strings {\n        if strings.contains(substring) {\n          \
    \  return strings\n        }\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmpz61i5v_o/tmpz61i5v_o.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba08e6abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba08e3a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba08e3a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba08e3a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz61i5v_o                        0x0000556163ab4917 <unavailable> + 6423

    5    libc.so.6                          0x00002ba08e897460 __libc_start_main +
    245

    6    tmpz61i5v_o                        0x0000556163ab4299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter(strings, substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpszdj5754.swift:8:12: error: cannot find 'filter' in scope\n   \
    \ return filter(strings, substring)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if !strings.contains(substring) { return strings }\n    var filtered: [String]\
    \ = []\n    for s in strings {\n        if s.contains(substring) {\n         \
    \   filtered = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe844k05z.swift:12:24: error: cannot find 'append' in scope\n  \
    \          filtered = append(filtered, s)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \treturn filter_by(\n\t\tstrings,\n\t\tfunc(s String) bool {\n\t\t\treturn strings.Contains(s,\
    \ substring)\n\t\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl6rvso_3.swift:10:3: error: expected expression in list of expressions\n\
    \                func(s String) bool {\n                ^\n/tmp/tmpl6rvso_3.swift:10:7:\
    \ error: expected identifier in function declaration\n                func(s String)\
    \ bool {\n                    ^\n/tmp/tmpl6rvso_3.swift:8:9: error: cannot find\
    \ 'filter_by' in scope\n        return filter_by(\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filtered = strings.filter { (string: String) -> Bool in\n        return\
    \ string.rangeOfString(substring) != nil\n    }\n    return filtered\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvq7rhef1.swift:9:23: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        return string.rangeOfString(substring) != nil\n   \
    \            ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter {\n    $0.hasSuffix(substring)\n  }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmpl7oaoi20/tmpl7oaoi20.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc00ca1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc00998b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc00998988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc009977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl7oaoi20                        0x000055fbf142c867 <unavailable> + 6247

    5    libc.so.6                          0x00002abc00e8d460 __libc_start_main +
    245

    6    tmpl7oaoi20                        0x000055fbf142c1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_by_substrings(strings, substring, true)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn24mj9tm.swift:8:12: error: cannot find 'filter_by_substrings'\
    \ in scope\n    return filter_by_substrings(strings, substring, true)\n      \
    \     ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013478
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered: [String] = []\n    for string in strings {\n        if string.hasSuffix(substring)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmp1jb8p8_c/tmp1jb8p8_c.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af424814c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af42450bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af42450b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af42450a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1jb8p8_c                        0x00005576ab78a967 <unavailable> + 6503

    5    libc.so.6                          0x00002af424a00460 __libc_start_main +
    245

    6    tmp1jb8p8_c                        0x00005576ab78a2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter {\n    substring in $0\n  }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1tjnqkzl.swift:9:18: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'substring'?\n\
    \    substring in $0\n                 ^~\n                 substring\n/tmp/tmp1tjnqkzl.swift:9:18:\
    \ error: cannot convert value of type 'String' to closure result type 'Bool'\n\
    \    substring in $0\n                 ^~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = [String]()\n    for str in strings {\n        if str.contains(substring)\
    \ {\n            result.append(str)\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013447
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let startIndex = strings.startIndex.advanced(by: substring.count).successor()\n\
    \    return strings.indices.contains(startIndex)\n        ? strings.filter() {\n\
    \              return strings[$0] == substring\n          }\n        : strings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkc_5y6zz.swift:8:71: error: value of type 'Int' has no member 'successor'\n\
    \    let startIndex = strings.startIndex.advanced(by: substring.count).successor()\n\
    \                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpkc_5y6zz.swift:11:30: error: cannot convert value of type 'String' to\
    \ expected argument type 'Int'\n              return strings[$0] == substring\n\
    \                             ^\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tresult = filter(strings, substring)\n\treturn\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp47p6vyki.swift:8:2: error: cannot find 'result' in scope\n    \
    \    result = filter(strings, substring)\n        ^~~~~~\n/tmp/tmp47p6vyki.swift:8:11:\
    \ error: cannot find 'filter' in scope\n        result = filter(strings, substring)\n\
    \                 ^~~~~~\n/tmp/tmp47p6vyki.swift:9:2: error: non-void function\
    \ should return a value\n        return\n        ^\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tfilteredStrings := [String]()\n\tfor _, string := range strings {\n\t\tif strings.Contains(string,\
    \ substring) {\n\t\t\tfilteredStrings = append(filteredStrings, string)\n\t\t\
    }\n\t}\n\treturn filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdacvoxl5.swift:8:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        filteredStrings := [String]()\n               \
    \        ^\n                       ;\n/tmp/tmpdacvoxl5.swift:8:18: error: expected\
    \ expression\n        filteredStrings := [String]()\n                        ^\n\
    /tmp/tmpdacvoxl5.swift:9:7: error: expected 'in' after for-each pattern\n    \
    \    for _, string := range strings {\n             ^\n/tmp/tmpdacvoxl5.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, string\
    \ := range strings {\n             ^\n/tmp/tmpdacvoxl5.swift:8:2: error: cannot\
    \ find 'filteredStrings' in scope\n        filteredStrings := [String]()\n   \
    \     ^~~~~~~~~~~~~~~\n/tmp/tmpdacvoxl5.swift:14:9: error: cannot find 'filteredStrings'\
    \ in scope\n        return filteredStrings\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result: [String] = []\n    for string in strings {\n        if string.hasSuffix(substring)\
    \ {\n            result.append(string)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmpixelt2nk/tmpixelt2nk.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8122f77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8122c6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8122c6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8122c6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpixelt2nk                        0x00005612f5142967 <unavailable> + 6503

    5    libc.so.6                          0x00002b8123163460 __libc_start_main +
    245

    6    tmpixelt2nk                        0x00005612f51422e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var stringResult = strings\n\n    for string in strings {\n        if string.lowercaseString.contains(substring.lowercaseString)\
    \ {\n            stringResult.append(string)\n        }\n    }\n\n    return stringResult\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpobigsa4h.swift:11:19: error: value of type 'String' has no member\
    \ 'lowercaseString'\n        if string.lowercaseString.contains(substring.lowercaseString)\
    \ {\n           ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpobigsa4h.swift:11:54: error: value\
    \ of type 'String' has no member 'lowercaseString'\n        if string.lowercaseString.contains(substring.lowercaseString)\
    \ {\n                                           ~~~~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard !substring.isEmpty else { return strings }\n    return strings.filter\
    \ { $0.hasSuffix(substring) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmpo9iq3uuv/tmpo9iq3uuv.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c10e8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c10b82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c10b82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c10b817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo9iq3uuv                        0x0000560fdab788b7 <unavailable> + 6327

    5    libc.so.6                          0x00002b1c11077460 __libc_start_main +
    245

    6    tmpo9iq3uuv                        0x0000560fdab78239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    for string in strings {\n        if string.contains(substring) {\n      \
    \      return strings\n        }\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmp1dkkudzh/tmp1dkkudzh.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaefab12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaefa809b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaefa809988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaefa8087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1dkkudzh                        0x000055a205c63957 <unavailable> + 6487

    5    libc.so.6                          0x00002aaefacfe460 __libc_start_main +
    245

    6    tmp1dkkudzh                        0x000055a205c632d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    for s in strings {\n        if substring == s {\n            return strings\n\
    \        }\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmp5vcdk218/tmp5vcdk218.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abecc0e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abecbdd8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abecbdd8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abecbdd77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5vcdk218                        0x00005649e03d8907 <unavailable> + 6407

    5    libc.so.6                          0x00002abecc2cd460 __libc_start_main +
    245

    6    tmp5vcdk218                        0x00005649e03d8289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = strings\n    for str in strings {\n        if str.contains(substring)\
    \ {\n            filtered = filtered.filter{$0 != str}\n        }\n    }\n   \
    \ return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmpqm9q5plz/tmpqm9q5plz.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f76521c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f76218b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f76218988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f762177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqm9q5plz                        0x000055592f978a77 <unavailable> + 6775

    5    libc.so.6                          0x00002b4f7670d460 __libc_start_main +
    245

    6    tmpqm9q5plz                        0x000055592f9783f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard !strings.isEmpty else {\n        return []\n    }\n    return strings.filter\
    \ { $0.contains(substring) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tconst start = substring.startIndex.encodedOffset\n\tconst end = substring.endIndex.encodedOffset\n\
    \treturn strings.filter({ string in\n\t\tlet range = (string as NSString).range(of:\
    \ substring)\n\t\treturn range.contains(range)\n\t})\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkaf6ax17.swift:8:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        const start = substring.startIndex.encodedOffset\n\
    \             ^\n             ;\n/tmp/tmpkaf6ax17.swift:9:7: error: consecutive\
    \ statements on a line must be separated by ';'\n        const end = substring.endIndex.encodedOffset\n\
    \             ^\n             ;\n/tmp/tmpkaf6ax17.swift:8:2: error: cannot find\
    \ 'const' in scope\n        const start = substring.startIndex.encodedOffset\n\
    \        ^~~~~\n/tmp/tmpkaf6ax17.swift:8:8: error: cannot find 'start' in scope\n\
    \        const start = substring.startIndex.encodedOffset\n              ^~~~~\n\
    /tmp/tmpkaf6ax17.swift:9:2: error: cannot find 'const' in scope\n        const\
    \ end = substring.endIndex.encodedOffset\n        ^~~~~\n/tmp/tmpkaf6ax17.swift:9:8:\
    \ error: cannot find 'end' in scope\n        const end = substring.endIndex.encodedOffset\n\
    \              ^~~\n/tmp/tmpkaf6ax17.swift:11:26: error: cannot find type 'NSString'\
    \ in scope\n                let range = (string as NSString).range(of: substring)\n\
    \                                       ^~~~~~~~\n/tmp/tmpkaf6ax17.swift:11:36:\
    \ error: value of type 'String' has no member 'range'\n                let range\
    \ = (string as NSString).range(of: substring)\n                            ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var new_strings: [String] = []\n    for string in strings {\n        if string.hasPrefix(substring)\
    \ {\n            new_strings += [string]\n        }\n    }\n    return new_strings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmpl3nbwt3_/tmpl3nbwt3_.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b1d2e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b1cfdab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9b1cfda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9b1cfd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl3nbwt3_                        0x0000562caf642c87 <unavailable> + 7303

    5    libc.so.6                          0x00002b9b1d4cf460 __libc_start_main +
    245

    6    tmpl3nbwt3_                        0x0000562caf6422e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return filter(strings, substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp363u05xv.swift:8:10: error: cannot find 'filter' in scope\n  return\
    \ filter(strings, substring)\n         ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_by_substring_indexed(strings, 0, substring, 1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwhe1tfnv.swift:8:12: error: cannot find 'filter_by_substring_indexed'\
    \ in scope\n    return filter_by_substring_indexed(strings, 0, substring, 1)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered: [String] = []\n    for string in strings {\n        let substringIndex\
    \ = string.range(of: substring)\n        if substringIndex.lowerBound == nil ||\
    \ substringIndex.upperBound == nil {\n            continue\n        }\n      \
    \  filtered.append(string)\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt6jsdbrq.swift:10:37: error: value of type 'String' has no member\
    \ 'range'\n        let substringIndex = string.range(of: substring)\n        \
    \                     ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = [String]()\n    for element in strings {\n        if element.contains(substring)\
    \ {\n            filtered = filtered + [element]\n        }\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_by_substring(strings, substring, caseSensitive: true)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp279kij5a.swift:8:67: error: extra argument 'caseSensitive' in call\n\
    \    return filter_by_substring(strings, substring, caseSensitive: true)\n   \
    \                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = strings\n    for i in 0..<strings.count {\n        if strings.[i]\
    \ == substring {\n            filtered[i] = \"\"\n        }\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6ykushcg.swift:10:20: error: expected member name following '.'\n\
    \        if strings.[i] == substring {\n                   ^\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings = strings\n    for str in strings {\n        if str.hasPrefix(substring)\
    \ {\n            filteredStrings.remove(str)\n        }\n    }\n    return filteredStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpet3umjc9.swift:11:29: error: no exact matches in call to instance\
    \ method 'remove'\n            filteredStrings.remove(str)\n                 \
    \           ^\n/tmp/tmpet3umjc9.swift:11:29: note: candidate expects value of\
    \ type 'Int' for parameter #1 (got 'String')\n            filteredStrings.remove(str)\n\
    \                            ^\n/tmp/tmpet3umjc9.swift:11:29: note: candidate\
    \ expects value of type 'Array<String>.Index' (aka 'Int') for parameter #1 (got\
    \ 'String')\n            filteredStrings.remove(str)\n                       \
    \     ^\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter { $0.contains(substring) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  let filteredStrings = strings.filter { $0.contains(substring) }\n  return filteredStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tresult := make([]String, 0)\n\n\tfor _, s := range strings {\n\t\tif strings.Index(s,\
    \ substring) != -1 {\n\t\t\tresult = append(result, s)\n\t\t}\n\t}\n\n\treturn\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdx0ytop5.swift:8:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := make([]String, 0)\n              ^\n\
    \              ;\n/tmp/tmpdx0ytop5.swift:8:9: error: expected expression\n   \
    \     result := make([]String, 0)\n               ^\n/tmp/tmpdx0ytop5.swift:10:7:\
    \ error: expected 'in' after for-each pattern\n        for _, s := range strings\
    \ {\n             ^\n/tmp/tmpdx0ytop5.swift:10:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, s := range strings {\n             ^\n/tmp/tmpdx0ytop5.swift:8:2:\
    \ error: cannot find 'result' in scope\n        result := make([]String, 0)\n\
    \        ^~~~~~\n/tmp/tmpdx0ytop5.swift:16:9: error: cannot find 'result' in scope\n\
    \        return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter {\n        contains($0, substring)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8j4im8ij.swift:9:9: error: cannot find 'contains' in scope\n  \
    \      contains($0, substring)\n        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013478
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_by_substring(strings, substring: substring, keepOriginal: false)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9ae7l3oc.swift:8:77: error: extra argument 'keepOriginal' in call\n\
    \    return filter_by_substring(strings, substring: substring, keepOriginal: false)\n\
    \                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tresult := [String]()\n\tfor _, s := range strings {\n\t\tif strings.Contains(s,\
    \ substring) {\n\t\t\tresult = append(result, s)\n\t\t}\n\t}\n\treturn result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmprib9w3g1.swift:8:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := [String]()\n              ^\n       \
    \       ;\n/tmp/tmprib9w3g1.swift:8:9: error: expected expression\n        result\
    \ := [String]()\n               ^\n/tmp/tmprib9w3g1.swift:9:7: error: expected\
    \ 'in' after for-each pattern\n        for _, s := range strings {\n         \
    \    ^\n/tmp/tmprib9w3g1.swift:9:7: error: expected Sequence expression for for-each\
    \ loop\n        for _, s := range strings {\n             ^\n/tmp/tmprib9w3g1.swift:8:2:\
    \ error: cannot find 'result' in scope\n        result := [String]()\n       \
    \ ^~~~~~\n/tmp/tmprib9w3g1.swift:14:9: error: cannot find 'result' in scope\n\
    \        return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_by_substring(strings.ToTypedArray(), substring.ToTypedArray())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1otl91py.swift:8:31: error: missing argument labels 'strings:substring:'\
    \ in call\n    return filter_by_substring(strings.ToTypedArray(), substring.ToTypedArray())\n\
    \                              ^\n                               strings:    \
    \            substring: \n/tmp/tmp1otl91py.swift:8:40: error: value of type '[String]'\
    \ has no member 'ToTypedArray'\n    return filter_by_substring(strings.ToTypedArray(),\
    \ substring.ToTypedArray())\n                               ~~~~~~~ ^~~~~~~~~~~~\n\
    /tmp/tmp1otl91py.swift:8:66: error: value of type 'String' has no member 'ToTypedArray'\n\
    \    return filter_by_substring(strings.ToTypedArray(), substring.ToTypedArray())\n\
    \                                                       ~~~~~~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    // TODO: use filterString()\n    return strings.filter({ str in\n       \
    \ let index = str.index(str.startIndex, offsetBy: 0)\n        let stringLength\
    \ = str.characters.count\n        let subIndex = str.index(index, offsetBy: substring.characters.count)\n\
    \        let substringLength = substring.characters.count\n        let isSubstring\
    \ = (str.characters.suffixFrom(index) == substring)\n        return !isSubstring\
    \ ||\n            (substringLength > 0 &&\n            str.characters.prefix(substringLength)\
    \ == substring.characters)\n        })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfgmbw1fp.swift:14:43: error: value of type 'String' has no member\
    \ 'suffixFrom'\n        let isSubstring = (str.characters.suffixFrom(index) ==\
    \ substring)\n                           ~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = [String]()\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            result.append(s)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013478
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  var filtered: [String] = []\n  for string in strings {\n    if string.contains(substring)\
    \ {\n      filtered.append(string)\n    }\n  }\n  return filtered\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let count = strings.count\n    let substringCount = substring.characters.count\n\
    \    return (0..<count).filter { i in\n        strings[i].characters.count ==\
    \ substringCount &&\n            (strings[i].characters.lowercased().hasSuffix(substring)\
    \ ||\n            strings[i].lowercased().hasSuffix(substring))\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmgq1dldd.swift:9:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    let substringCount = substring.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmgq1dldd.swift:10:17: error: cannot convert value of\
    \ type 'Int' to expected argument type 'String'\n    return (0..<count).filter\
    \ { i in\n                ^\n/tmp/tmpmgq1dldd.swift:10:13: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String'\n    return (0..<count).filter\
    \ { i in\n            ^\n/tmp/tmpmgq1dldd.swift:10:14: error: referencing instance\
    \ method 'filter' on 'Range' requires that 'String' conform to 'Strideable'\n\
    \    return (0..<count).filter { i in\n             ^\nSwift.Range:1:11: note:\
    \ requirement from conditional conformance of 'Range<String>' to 'Sequence'\n\
    extension Range : Sequence where Bound : Strideable, Bound.Stride : SignedInteger\
    \ {\n          ^\n/tmp/tmpmgq1dldd.swift:10:31: error: cannot convert value of\
    \ type '(Int) -> Bool' to expected argument type '(Range<String>.Element) throws\
    \ -> Bool' (aka '(String) throws -> Bool')\n    return (0..<count).filter { i\
    \ in\n                              ^\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard let index = strings.index(where: { $0.contains(substring) }) else {\n\
    \        return strings\n    }\n    return strings.drop(index).append(strings.suffix(from:\
    \ index))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo_b0qaul.swift:8:31: warning: 'index(where:)' is deprecated: renamed\
    \ to 'firstIndex(where:)'\n    guard let index = strings.index(where: { $0.contains(substring)\
    \ }) else {\n                              ^\n/tmp/tmpo_b0qaul.swift:8:31: note:\
    \ use 'firstIndex(where:)' instead\n    guard let index = strings.index(where:\
    \ { $0.contains(substring) }) else {\n                              ^~~~~\n  \
    \                            firstIndex\n/tmp/tmpo_b0qaul.swift:11:25: error:\
    \ missing argument label 'while:' in call\n    return strings.drop(index).append(strings.suffix(from:\
    \ index))\n                        ^\n                        while: \n/tmp/tmpo_b0qaul.swift:11:25:\
    \ error: cannot convert value of type 'Array<String>.Index' (aka 'Int') to expected\
    \ argument type '(String) throws -> Bool'\n    return strings.drop(index).append(strings.suffix(from:\
    \ index))\n                        ^\n/tmp/tmpo_b0qaul.swift:11:32: error: value\
    \ of type 'DropWhileSequence<[String]>' has no member 'append'\n    return strings.drop(index).append(strings.suffix(from:\
    \ index))\n           ~~~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tintersection := strings.Intersect(strings.SplitN(strings.Join(strings, \"\"\
    ), substring, 2))\n\treturn strings.Split(intersection, substring)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkcf2qlv2.swift:8:14: error: consecutive statements on a line must\
    \ be separated by ';'\n        intersection := strings.Intersect(strings.SplitN(strings.Join(strings,\
    \ \"\"), substring, 2))\n                    ^\n                    ;\n/tmp/tmpkcf2qlv2.swift:8:15:\
    \ error: expected expression\n        intersection := strings.Intersect(strings.SplitN(strings.Join(strings,\
    \ \"\"), substring, 2))\n                     ^\n/tmp/tmpkcf2qlv2.swift:8:2: error:\
    \ cannot find 'intersection' in scope\n        intersection := strings.Intersect(strings.SplitN(strings.Join(strings,\
    \ \"\"), substring, 2))\n        ^~~~~~~~~~~~\n/tmp/tmpkcf2qlv2.swift:9:23: error:\
    \ cannot find 'intersection' in scope\n        return strings.Split(intersection,\
    \ substring)\n                             ^~~~~~~~~~~~\n/tmp/tmpkcf2qlv2.swift:9:17:\
    \ error: value of type '[String]' has no member 'Split'\n        return strings.Split(intersection,\
    \ substring)\n               ~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter({$0.contains(substring)})\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered = [String]()\n    for (index, item) in strings.enumerated()\
    \ {\n        if substring == item {\n            filtered = append(filtered, item)\n\
    \        }\n    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbkj3metv.swift:11:24: error: cannot find 'append' in scope\n  \
    \          filtered = append(filtered, item)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filtered = strings.filter { (string: String) -> Bool in\n        let\
    \ sub = string.lowercaseString.rangeOfString(substring)\n        return sub !=\
    \ nil && sub.upperBound != NSNotFound\n    }\n    return filtered\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7ocjn44a.swift:10:48: error: cannot find 'NSNotFound' in scope\n\
    \        return sub != nil && sub.upperBound != NSNotFound\n                 \
    \                              ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  let substrings = substring.characters.split{$0 == \",\"}\n  let substringsCount\
    \ = substrings.count\n\n  guard substringsCount > 0 else {\n    return strings\n\
    \  }\n\n  var filtered = Set<String>()\n\n  for s in strings {\n    let start\
    \ = substring.characters.index($0, options: .caseInsensitive)\n    let end = start.advanced(by:\
    \ substringsCount)\n\n    if start != end {\n      filtered.insert(s[start..<end])\n\
    \    }\n  }\n\n  return [filtered.allObjects]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpou5ufmua.swift:18:44: error: anonymous closure argument not contained\
    \ in a closure\n    let start = substring.characters.index($0, options: .caseInsensitive)\n\
    \                                           ^\n/tmp/tmpou5ufmua.swift:8:30: error:\
    \ 'characters' is unavailable: Please use String directly\n  let substrings =\
    \ substring.characters.split{$0 == \",\"}\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpou5ufmua.swift:18:58:\
    \ error: extra argument 'options' in call\n    let start = substring.characters.index($0,\
    \ options: .caseInsensitive)\n                                          ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n\
    /tmp/tmpou5ufmua.swift:18:58: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n    let start = substring.characters.index($0,\
    \ options: .caseInsensitive)\n                                               \
    \         ~^~~~~~~~~~~~~~~\n/tmp/tmpou5ufmua.swift:26:20: error: value of type\
    \ 'Set<String>' has no member 'allObjects'\n  return [filtered.allObjects]\n \
    \         ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter { string -> Bool in\n    string.hasPrefix(substring)\n\
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmp9l2gpja0/tmp9l2gpja0.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adeee323c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adeee01ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adeee01a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adeee0197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9l2gpja0                        0x0000556b15a97b87 <unavailable> + 7047

    5    libc.so.6                          0x00002adeee50f460 __libc_start_main +
    245

    6    tmp9l2gpja0                        0x0000556b15a971e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tsubstring = substring.lowercased()\n\treturn strings.filter { $0.lowercased().contains(substring)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpewcvmv43.swift:8:2: error: cannot assign to value: 'substring'\
    \ is a 'let' constant\n        substring = substring.lowercased()\n        ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings = strings\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filteredStrings.remove(at: filteredStrings.index(of: string))\n\
    \        }\n    }\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwgxxsp8h.swift:11:56: error: value of optional type 'Array<String>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<String>.Index'\
    \ (aka 'Int')\n            filteredStrings.remove(at: filteredStrings.index(of:\
    \ string))\n                                                       ^\n/tmp/tmpwgxxsp8h.swift:11:56:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            filteredStrings.remove(at: filteredStrings.index(of: string))\n\
    \                                                       ^\n                  \
    \                                                       ?? <#default value#>\n\
    /tmp/tmpwgxxsp8h.swift:11:56: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            filteredStrings.remove(at:\
    \ filteredStrings.index(of: string))\n                                       \
    \                ^\n                                                         \
    \               !\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings: [String] = []\n\n    for string in strings {\n     \
    \   if string.hasPrefix(substring) {\n            filteredStrings.append(string)\n\
    \        }\n    }\n\n    return filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: Exception
  stderr: 'tmpauw6h_xb/tmpauw6h_xb.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b68c9341c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b68c9038b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b68c9038988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b68c90377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpauw6h_xb                        0x000055fa398cdc87 <unavailable> + 7303

    5    libc.so.6                          0x00002b68c952d460 __libc_start_main +
    245

    6    tmpauw6h_xb                        0x000055fa398cd2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = strings[:]\n    for i in 0..<strings.count {\n        if strings[i].lowercased().contains(substring.lowercased())\
    \ {\n            result = result.filter{ $0 != strings[i] }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpk2gpy898.swift:8:26: error: expected expression in list of expressions\n\
    \    var result = strings[:]\n                         ^\n/tmp/tmpk2gpy898.swift:8:27:\
    \ error: missing argument for parameter #1 in call\n    var result = strings[:]\n\
    \                          ^\n                          <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filteredStrings = strings\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            filteredStrings.remove(s)\n        }\n    }\n    return filteredStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpquva0o1d.swift:11:29: error: no exact matches in call to instance\
    \ method 'remove'\n            filteredStrings.remove(s)\n                   \
    \         ^\n/tmp/tmpquva0o1d.swift:11:29: note: candidate expects value of type\
    \ 'Int' for parameter #1 (got 'String')\n            filteredStrings.remove(s)\n\
    \                            ^\n/tmp/tmpquva0o1d.swift:11:29: note: candidate\
    \ expects value of type 'Array<String>.Index' (aka 'Int') for parameter #1 (got\
    \ 'String')\n            filteredStrings.remove(s)\n                         \
    \   ^\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = [String]()\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            result.append(string)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if !strings.HasSuffix(substring) {\n        return strings\n    }\n    \n\
    \    var filtered: [String] = []\n    for s in strings {\n        if s.hasPrefix(substring)\
    \ {\n            filtered = filtered + [s]\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwuzpqpqt.swift:8:17: error: value of type '[String]' has no member\
    \ 'HasSuffix'\n    if !strings.HasSuffix(substring) {\n        ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  let mut result = Vec::new();\n  for str in strings {\n    if str.contains(substring)\
    \ {\n      result.push(str);\n    }\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc1e5y11a.swift:8:11: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n  let mut result = Vec::new();\n\
    \          ^\n/tmp/tmpc1e5y11a.swift:8:11: note: join the identifiers together\n\
    \  let mut result = Vec::new();\n      ~~~~^~~~~~\n      mutresult\n/tmp/tmpc1e5y11a.swift:8:11:\
    \ note: join the identifiers together with camel-case\n  let mut result = Vec::new();\n\
    \      ~~~~^~~~~~\n      mutResult\n/tmp/tmpc1e5y11a.swift:8:23: error: consecutive\
    \ statements on a line must be separated by ';'\n  let mut result = Vec::new();\n\
    \                      ^\n                      ;\n/tmp/tmpc1e5y11a.swift:8:23:\
    \ error: expected expression\n  let mut result = Vec::new();\n               \
    \       ^\n/tmp/tmpc1e5y11a.swift:8:20: error: cannot find 'Vec' in scope\n  let\
    \ mut result = Vec::new();\n                   ^~~\n/tmp/tmpc1e5y11a.swift:11:7:\
    \ error: cannot find 'result' in scope\n      result.push(str);\n      ^~~~~~\n\
    /tmp/tmpc1e5y11a.swift:14:10: error: cannot find 'result' in scope\n  return result\n\
    \         ^~~~~~\n"
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tvar result [String] = []\n\tfor _, s := range strings {\n\t\tif strings.Contains(s,\
    \ substring) {\n\t\t\tresult = append(result, s)\n\t\t}\n\t}\n\treturn result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmufuy8xd.swift:8:12: error: consecutive statements on a line must\
    \ be separated by ';'\n        var result [String] = []\n                  ^\n\
    \                  ;\n/tmp/tmpmufuy8xd.swift:9:7: error: expected 'in' after for-each\
    \ pattern\n        for _, s := range strings {\n             ^\n/tmp/tmpmufuy8xd.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, s := range\
    \ strings {\n             ^\n/tmp/tmpmufuy8xd.swift:8:6: error: type annotation\
    \ missing in pattern\n        var result [String] = []\n            ^\n/tmp/tmpmufuy8xd.swift:8:13:\
    \ error: cannot assign to immutable expression of type '[String].Type'\n     \
    \   var result [String] = []\n                   ^~~~~~~~\n/tmp/tmpmufuy8xd.swift:8:24:\
    \ error: cannot assign value of type '[Any]' to type '[String].Type'\n       \
    \ var result [String] = []\n                              ^~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard let index = strings.firstIndex(of: substring) else { return strings\
    \ }\n    return strings[index..<strings.endIndex].compactMap {\n        strings.firstIndex(of:\
    \ $0)\n    }.map { strings.first }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfvfc9btf.swift:11:21: error: value of optional type 'String?' must\
    \ be unwrapped to a value of type 'String'\n    }.map { strings.first }\n    \
    \                ^\n/tmp/tmpfvfc9btf.swift:11:21: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n    }.map { strings.first\
    \ }\n                    ^\n                          ?? <#default value#>\n/tmp/tmpfvfc9btf.swift:11:21:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    }.map { strings.first }\n                    ^\n                \
    \         !\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return filter_by_substring_inplace(strings, substring, false)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmprhdqxj3m.swift:8:12: error: cannot find 'filter_by_substring_inplace'\
    \ in scope\n    return filter_by_substring_inplace(strings, substring, false)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tvar filtered_strings = [String]()\n\tfor s in strings {\n\t\tif s.contains(substring)\
    \ {\n\t\t\tfiltered_strings.append(s)\n\t\t}\n\t}\n\treturn filtered_strings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var strings_ = strings.slice()\n    for idx := range strings_ {\n       \
    \ if strings_[idx].contains(substring) {\n            strings_.remove(at: idx)\n\
    \        }\n    }\n    return strings_\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp592bphln.swift:9:14: error: expected type\n    for idx := range\
    \ strings_ {\n             ^\n              <#type#>\n/tmp/tmp592bphln.swift:9:14:\
    \ error: expected 'in' after for-each pattern\n    for idx := range strings_ {\n\
    \             ^\n/tmp/tmp592bphln.swift:9:14: error: expected Sequence expression\
    \ for for-each loop\n    for idx := range strings_ {\n             ^\n/tmp/tmp592bphln.swift:8:28:\
    \ error: value of type '[String]' has no member 'slice'\n    var strings_ = strings.slice()\n\
    \                   ~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tvar filtered = strings\n\tfor _, str := range strings {\n\t\tif strings.Contains(str,\
    \ substring) {\n\t\t\tfiltered = append(filtered, str)\n\t\t}\n\t}\n\treturn filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyu9j314m.swift:9:7: error: expected 'in' after for-each pattern\n\
    \        for _, str := range strings {\n             ^\n/tmp/tmpyu9j314m.swift:9:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, str :=\
    \ range strings {\n             ^\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \treturn filter_by_substrings(strings.slice(), substring.asCString())\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl5vgebbd.swift:8:9: error: cannot find 'filter_by_substrings' in\
    \ scope\n        return filter_by_substrings(strings.slice(), substring.asCString())\n\
    \               ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpl5vgebbd.swift:8:38: error: value\
    \ of type '[String]' has no member 'slice'\n        return filter_by_substrings(strings.slice(),\
    \ substring.asCString())\n                                    ~~~~~~~ ^~~~~\n\
    /tmp/tmpl5vgebbd.swift:8:57: error: value of type 'String' has no member 'asCString'\n\
    \        return filter_by_substrings(strings.slice(), substring.asCString())\n\
    \                                                     ~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  guard substring != \"\" else { return strings }\n  return strings.filter({\
    \ (string) -> Bool in\n    let rangeOfSubstring = string.rangeOfString(substring)\n\
    \    return rangeOfSubstring?.location == nil\n  })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmprrucdtxw.swift:10:35: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    let rangeOfSubstring = string.rangeOfString(substring)\n\
    \                           ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    // TODO(Andrew): If this becomes an issue we can add a [String: Int] or [String:\
    \ Bool] parameter\n    let result = strings.filter { (string: String) -> Bool\
    \ in\n        return string.hasPrefix(substring)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmpeb7jwvga/tmpeb7jwvga.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad6dcd32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad6dca29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad6dca29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6dca287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeb7jwvga                        0x00005592ac0afb87 <unavailable> + 7047

    5    libc.so.6                          0x00002ad6dcf1e460 __libc_start_main +
    245

    6    tmpeb7jwvga                        0x00005592ac0af1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    return strings.filter({ substring in $0 })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd_9vyj4r.swift:8:42: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'substring'?\n\
    \    return strings.filter({ substring in $0 })\n                            \
    \             ^~\n                                         substring\n/tmp/tmpd_9vyj4r.swift:8:42:\
    \ error: cannot convert value of type 'String' to closure result type 'Bool'\n\
    \    return strings.filter({ substring in $0 })\n                            \
    \             ^~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tfilteredStrings := strings.filter({ $0.contains(substring) })\n\treturn filteredStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmprsklr4tw.swift:8:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        filteredStrings := strings.filter({ $0.contains(substring)\
    \ })\n                       ^\n                       ;\n/tmp/tmprsklr4tw.swift:8:18:\
    \ error: expected expression\n        filteredStrings := strings.filter({ $0.contains(substring)\
    \ })\n                        ^\n/tmp/tmprsklr4tw.swift:8:2: error: cannot find\
    \ 'filteredStrings' in scope\n        filteredStrings := strings.filter({ $0.contains(substring)\
    \ })\n        ^~~~~~~~~~~~~~~\n/tmp/tmprsklr4tw.swift:9:9: error: cannot find\
    \ 'filteredStrings' in scope\n        return filteredStrings\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    guard !substring.isEmpty else { return strings }\n\n    var filtered = [String]()\n\
    \    for s in strings {\n        if s.range(of: substring)?.lowerBound == nil\
    \ {\n            filtered.append(s)\n        }\n    }\n    return filtered\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbgiiqkvb.swift:12:14: error: value of type 'String' has no member\
    \ 'range'\n        if s.range(of: substring)?.lowerBound == nil {\n          \
    \ ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filtered = strings.filter { (s) in\n        return s.contains(substring)\n\
    \    }\n    return filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \tfilter := strings.Filter(func(s string) bool {\n\t\treturn strings.Contains(s,\
    \ substring)\n\t})\n\treturn strings.SliceToArray(filter, []byte(substring))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmprpent2so.swift:8:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        filter := strings.Filter(func(s string) bool {\n\
    \              ^\n              ;\n/tmp/tmprpent2so.swift:8:9: error: expected\
    \ expression\n        filter := strings.Filter(func(s string) bool {\n       \
    \        ^\n/tmp/tmprpent2so.swift:11:40: error: expected ',' separator\n    \
    \    return strings.SliceToArray(filter, []byte(substring))\n                \
    \                              ^\n                                           \
    \   ,\n/tmp/tmprpent2so.swift:8:2: error: cannot find 'filter' in scope\n    \
    \    filter := strings.Filter(func(s string) bool {\n        ^~~~~~\n/tmp/tmprpent2so.swift:11:30:\
    \ error: cannot find 'filter' in scope\n        return strings.SliceToArray(filter,\
    \ []byte(substring))\n                                    ^~~~~~\n/tmp/tmprpent2so.swift:11:40:\
    \ error: cannot find 'byte' in scope\n        return strings.SliceToArray(filter,\
    \ []byte(substring))\n                                              ^~~~\n/tmp/tmprpent2so.swift:11:17:\
    \ error: value of type '[String]' has no member 'SliceToArray'\n        return\
    \ strings.SliceToArray(filter, []byte(substring))\n               ~~~~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \treturn strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \treturn strings.filter{ s -> Bool in\n\t\treturn s.range(of: substring) != nil\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkijyk13z.swift:9:12: error: value of type 'String' has no member\
    \ 'range'\n                return s.range(of: substring) != nil\n            \
    \           ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    strings.filter { substring in $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(filter_by_substring(strings: [] as [String], substring: \"john\") == []\
    \ as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\"\
    , \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\"\
    , \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\"\
    , \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg4wn4ndx.swift:8:35: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'substring'?\n\
    \    strings.filter { substring in $0 }\n                                  ^~\n\
    \                                  substring\n/tmp/tmpg4wn4ndx.swift:8:35: error:\
    \ cannot convert value of type 'String' to closure result type 'Bool'\n    strings.filter\
    \ { substring in $0 }\n                                  ^~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if !strings.HasSuffix(substring) {\n        strings = strings.Suffix(strings.LastIndexOf(substring))\n\
    \    }\n\n    if strings.IsEmpty() {\n        return strings\n    }\n\n    strings.Remove(strings.LastIndex(substring))\n\
    \n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6nbevtjs.swift:8:17: error: value of type '[String]' has no member\
    \ 'HasSuffix'\n    if !strings.HasSuffix(substring) {\n        ~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmp6nbevtjs.swift:9:9: error: cannot assign to value: 'strings' is a 'let'\
    \ constant\n        strings = strings.Suffix(strings.LastIndexOf(substring))\n\
    \        ^~~~~~~\n/tmp/tmp6nbevtjs.swift:9:27: error: value of type '[String]'\
    \ has no member 'Suffix'\n        strings = strings.Suffix(strings.LastIndexOf(substring))\n\
    \                  ~~~~~~~ ^~~~~~\n/tmp/tmp6nbevtjs.swift:9:42: error: value of\
    \ type '[String]' has no member 'LastIndexOf'\n        strings = strings.Suffix(strings.LastIndexOf(substring))\n\
    \                                 ~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp6nbevtjs.swift:12:16:\
    \ error: value of type '[String]' has no member 'IsEmpty'\n    if strings.IsEmpty()\
    \ {\n       ~~~~~~~ ^~~~~~~\n/tmp/tmp6nbevtjs.swift:16:13: error: value of type\
    \ '[String]' has no member 'Remove'\n    strings.Remove(strings.LastIndex(substring))\n\
    \    ~~~~~~~ ^~~~~~\n/tmp/tmp6nbevtjs.swift:16:28: error: value of type '[String]'\
    \ has no member 'LastIndex'\n    strings.Remove(strings.LastIndex(substring))\n\
    \                   ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  return strings.filter({ $0.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013607
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if let prefix = substring.first {\n        for s in strings {\n         \
    \   if s.starts(with: prefix) {\n                return strings.filter{$0 != substring}\n\
    \            }\n        }\n        return strings\n    }\n\n    return strings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1ecnmqib.swift:10:18: error: no exact matches in call to instance\
    \ method 'starts'\n            if s.starts(with: prefix) {\n                 ^\n\
    _StringProcessing.BidirectionalCollection:3:17: note: candidate requires that\
    \ 'String.Element' (aka 'Character') conform to 'RegexComponent' (requirement\
    \ specified as 'some RegexComponent' : 'RegexComponent')\n    public func starts(with\
    \ regex: some RegexComponent) -> Bool\n                ^\nSwift.Sequence:2:28:\
    \ note: candidate requires that 'String.Element' (aka 'Character') conform to\
    \ 'Sequence' (requirement specified as 'PossiblePrefix' : 'Sequence')\n    @inlinable\
    \ public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool\
    \ where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element\n  \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered: [String] = []\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            filtered.append(string)\n        }\n    }\n    return filtered\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013478
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \  strings.filter({ string.contains(substring) })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(filter_by_substring(strings: [] as [String], substring: \"\
    john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\"\
    , \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\"\
    , \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\"\
    , \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmp06wk16s0.swift:8:20: error: cannot find 'string' in scope\n  strings.filter({\
    \ string.contains(substring) })\n                   ^~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result = [String]()\n    for s in strings {\n        if s.contains(substring)\
    \ {\n            result.append(s)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013478
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var result: [String] = []\n    for string in strings {\n        if string.contains(substring)\
    \ {\n            result.append(string)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring:\
    \ \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\",\
    \ \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") ==\
    \ [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\"\
    , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\")\
    \ == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013337
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let pattern = NSPredicate(format: \"SELF contains[c] %@\", argumentArray:\
    \ [substring])\n    let array = NSArray(array: strings).filteredArrayUsingPredicate(pattern)\n\
    \    return array as! [String]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe9lruey4.swift:8:19: error: cannot find 'NSPredicate' in scope\n\
    \    let pattern = NSPredicate(format: \"SELF contains[c] %@\", argumentArray:\
    \ [substring])\n                  ^~~~~~~~~~~\n/tmp/tmpe9lruey4.swift:9:17: error:\
    \ cannot find 'NSArray' in scope\n    let array = NSArray(array: strings).filteredArrayUsingPredicate(pattern)\n\
    \                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filteredStrings = strings.filter { $0.contains(substring) }\n    return\
    \ filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013606
- exit_code: -4
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    let filteredStrings = strings.filter { $0.hasSuffix(substring) }\n    return\
    \ filteredStrings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: Exception
  stderr: 'tmpgdcadxnh/tmpgdcadxnh.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad4c28dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad4bf84b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad4bf84988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad4bf837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgdcadxnh                        0x00005582e5634867 <unavailable> + 6247

    5    libc.so.6                          0x00002aad4c479460 __libc_start_main +
    245

    6    tmpgdcadxnh                        0x00005582e56341e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    var filtered: [String] = []\n    for string in strings {\n        if string.lowercaseString.rangeOfString(substring)\
    \ != nil {\n            filtered.append(string)\n        }\n    }\n    return\
    \ filtered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings:\
    \ [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"\
    xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring:\
    \ \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings:\
    \ [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"\
    grunt\", \"prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzw5u884z.swift:10:19: error: value of type 'String' has no member\
    \ 'lowercaseString'\n        if string.lowercaseString.rangeOfString(substring)\
    \ != nil {\n           ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 1
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    if strings.isEmpty() {\n        return strings\n    }\n    var result = strings.filter\
    \ { $0.contains(substring) }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: SyntaxError
  stderr: "/tmp/tmppdaw_p3z.swift:8:16: error: cannot call value of non-function type\
    \ 'Bool'\n    if strings.isEmpty() {\n               ^      ~~\n             \
    \         \n"
  stdout: ''
  timestamp: 1660013608
- exit_code: 0
  program: "\n/// Filter an input array of strings only for ones that contain given\
    \ substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"\
    a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\"\
    , \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\n\
    func filter_by_substring(strings: [String], substring: String) -> [String] {\n\
    \    strings.filter { $0.contains(substring) }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(filter_by_substring(strings: [] as [String], substring: \"john\"\
    ) == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"\
    xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"\
    aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\",\
    \ \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\"\
    , \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"\
    prune\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013447
