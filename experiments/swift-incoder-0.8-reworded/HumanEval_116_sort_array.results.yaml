language: swift
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let n = arr.count\n    if n < 2 {\n\
    \        return arr\n    }\n    var newArr: [Int] = Array(repeating: 0, count:\
    \ n)\n    for i in 0..<n {\n        let s = arr[i]\n        if s == 0 {\n    \
    \        continue\n        }\n        let ones = bin2num(String(s))\n        newArr[i]\
    \ = ones\n    }\n    var ret = newArr\n    for i in 0..<n {\n        let ones\
    \ = newArr[i]\n        let arr = arr\n        let s = arr[i]\n        if s ==\
    \ 0 {\n            continue\n        }\n        let arr = bin2num(String(s))\n\
    \        if let k = arr.index(of: ones) {\n            let temp = ret[i]\n   \
    \         ret[i] = arr[k]\n            ret[k] = temp\n        }\n    }\n    return\
    \ ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5,\
    \ 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpzy405mf4.swift:23:20: error: cannot find 'bin2num' in scope\n \
    \       let ones = bin2num(String(s))\n                   ^~~~~~~\n/tmp/tmpzy405mf4.swift:34:19:\
    \ error: cannot find 'bin2num' in scope\n        let arr = bin2num(String(s))\n\
    \                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr == nil || arr.count < 1 {\n\
    \        return arr\n    }\n    let ones = arr.filter{ $0 == 1 }\n    let decimal\
    \ = arr.filter{ $0 > 0 }\n    \n    guard ones.count > 0 && decimal.count > 0\
    \ else { return arr }\n    \n    if decimal.count < ones.count {\n        decimal.sort()\
    \ { $0 < $1 }\n    } else {\n        ones.sort() { $0 < $1 }\n    }\n    \n  \
    \  return ones + decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpgp36lqv2.swift:13:12: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if arr == nil || arr.count <\
    \ 1 {\n       ~~~ ^  ~~~\n/tmp/tmpgp36lqv2.swift:22:17: error: cannot use mutating\
    \ member on immutable value: 'decimal' is a 'let' constant\n        decimal.sort()\
    \ { $0 < $1 }\n        ~~~~~~~ ^\n/tmp/tmpgp36lqv2.swift:17:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let decimal = arr.filter{ $0 > 0 }\n    ^~~\n\
    \    var\n/tmp/tmpgp36lqv2.swift:24:14: error: cannot use mutating member on immutable\
    \ value: 'ones' is a 'let' constant\n        ones.sort() { $0 < $1 }\n       \
    \ ~~~~ ^\n/tmp/tmpgp36lqv2.swift:16:5: note: change 'let' to 'var' to make it\
    \ mutable\n    let ones = arr.filter{ $0 == 1 }\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted { (a, b) -> Bool\
    \ in\n        let binA = format_bin(Int(a)) as String\n        let binB = format_bin(Int(b))\
    \ as String\n        let cA = count_ones(binA)\n        let cB = count_ones(binB)\n\
    \n        if cA < cB {\n            return true\n        } else if cA > cB {\n\
    \            return false\n        } else {\n            return a.compare(to:\
    \ b) == .orderedAscending\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpp98tu1_q.swift:14:20: error: cannot find 'format_bin' in scope\n\
    \        let binA = format_bin(Int(a)) as String\n                   ^~~~~~~~~~\n\
    /tmp/tmpp98tu1_q.swift:15:20: error: cannot find 'format_bin' in scope\n     \
    \   let binB = format_bin(Int(b)) as String\n                   ^~~~~~~~~~\n/tmp/tmpp98tu1_q.swift:16:18:\
    \ error: cannot find 'count_ones' in scope\n        let cA = count_ones(binA)\n\
    \                 ^~~~~~~~~~\n/tmp/tmpp98tu1_q.swift:17:18: error: cannot find\
    \ 'count_ones' in scope\n        let cB = count_ones(binB)\n                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.count == 0 {\n        return\
    \ arr\n    }\n\n    let twos = arr.filter{ (num: Int) -> Bool in\n        num\
    \ >> 1 == 0\n    }\n    let negative = arr.filter{ (num: Int) -> Bool in\n   \
    \     num < 0\n    }\n\n    let tens = arr.filter{ (num: Int) -> Bool in\n   \
    \     num >> 1 == 1\n    }\n    let tensNegs = arr.filter{ (num: Int) -> Bool\
    \ in\n        num >> 1 == 0\n    }\n\n    let tensNegsNegs = arr.filter{ (num:\
    \ Int) -> Bool in\n        num >> 1 == -1\n    }\n\n    let tensNegsNegsNegs =\
    \ arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -2\n    }\n\n    let\
    \ tensNegsNegsNegsNegs = arr.filter{ (num: Int) -> Bool in\n        num >> 1 ==\
    \ -3\n    }\n\n    let tensNegsNegsNegsNegsNegs = arr.filter{ (num: Int) -> Bool\
    \ in\n        num >> 1 == -4\n    }\n\n    let tensNegsNegsNegsNegsNegsNegs =\
    \ arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -5\n    }\n\n    let\
    \ tensNegsNegsNegsNegsNegsNegsNegs = arr.filter{ (num: Int) -> Bool in\n     \
    \   num >> 1 == -6\n    }\n\n    let tensNegsNegsNegsNegsNegsNegsNegsNegs = arr.filter{\
    \ (num: Int) -> Bool in\n        num >> 1 == -7\n    }\n\n    let tensNegsNegsNegsNegsNegsNegsNegsNegsNegs\
    \ = arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -8\n    }\n\n    let\
    \ tensNegsNegsNegsNegsNegsNegsNegsNegsNegsNegs = arr.filter{ (num: Int) -> Bool\
    \ in\n        num >> 1 == -9\n    }\n\n    let tensNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegs\
    \ = arr.filter{ (num: Int) -> Bool in\n        num >> 1 == -10\n    }\n\n    let\
    \ tensNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegsNegs = arr.filter{ (num:\
    \ Int) -> Bool in\n        num >> 1 == -11\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp6lvzez7a.swift:95:64: error: expected '}' at end of brace statement\n\
    assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\n            \
    \                                                   ^\n/tmp/tmp6lvzez7a.swift:12:38:\
    \ note: to match this opening '{'\nfunc sort_array(arr: [Int]) -> [Int] {\n  \
    \                                   ^\n/tmp/tmp6lvzez7a.swift:76:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp6lvzez7a.swift:17:9:\
    \ warning: initialization of immutable value 'twos' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    let twos = arr.filter{ (num: Int)\
    \ -> Bool in\n    ~~~~^~~~\n    _\n/tmp/tmp6lvzez7a.swift:20:9: warning: initialization\
    \ of immutable value 'negative' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let negative = arr.filter{ (num: Int) -> Bool in\n\
    \    ~~~~^~~~~~~~\n    _\n/tmp/tmp6lvzez7a.swift:24:9: warning: initialization\
    \ of immutable value 'tens' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let tens = arr.filter{ (num: Int) -> Bool in\n  \
    \  ~~~~^~~~\n    _\n/tmp/tmp6lvzez7a.swift:27:9: warning: initialization of immutable\
    \ value 'tensNegs' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let tensNegs = arr.filter{ (num: Int) -> Bool in\n    ~~~~^~~~~~~~\n\
    \    _\n/tmp/tmp6lvzez7a.swift:31:9: warning: initialization of immutable value\
    \ 'tensNegsNegs' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let tensNegsNegs = arr.filter{ (num: Int) -> Bool in\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmp6lvzez7a.swift:35:9: warning: initialization of immutable value\
    \ 'tensNegsNegsNegs' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    let tensNegsNegsNegs = arr.filter{ (num: Int) -> Bool in\n\
    \    ~~~~^~~~~~~~~~~~~~~~\n    _\n/tmp/tmp6lvzez7a.swift:39:9: warning: initialization\
    \ of immutable value 'tensNegsNegsNegsNegs' was never used; consider replacing "
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sort(arr.sorted(), { a, b in\n\
    \        return count_ones(a) > count_ones(b) ? 1 : count_ones(a) < count_ones(b)\
    \ ? -1 : 0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpgm3kxzw3.swift:13:12: error: cannot find 'sort' in scope\n    return\
    \ sort(arr.sorted(), { a, b in\n           ^~~~\n/tmp/tmpgm3kxzw3.swift:14:16:\
    \ error: cannot find 'count_ones' in scope\n        return count_ones(a) > count_ones(b)\
    \ ? 1 : count_ones(a) < count_ones(b) ? -1 : 0\n               ^~~~~~~~~~\n/tmp/tmpgm3kxzw3.swift:14:32:\
    \ error: cannot find 'count_ones' in scope\n        return count_ones(a) > count_ones(b)\
    \ ? 1 : count_ones(a) < count_ones(b) ? -1 : 0\n                             \
    \  ^~~~~~~~~~\n/tmp/tmpgm3kxzw3.swift:14:52: error: cannot find 'count_ones' in\
    \ scope\n        return count_ones(a) > count_ones(b) ? 1 : count_ones(a) < count_ones(b)\
    \ ? -1 : 0\n                                                   ^~~~~~~~~~\n/tmp/tmpgm3kxzw3.swift:14:68:\
    \ error: cannot find 'count_ones' in scope\n        return count_ones(a) > count_ones(b)\
    \ ? 1 : count_ones(a) < count_ones(b) ? -1 : 0\n                             \
    \                                      ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var ones = 0\n    var dec = 0\n  \
    \  for i : Int in arr {\n        ones += (i as Int)\n        dec += i / 2\n  \
    \  }\n    return arr.sorted { $0 == $1 } + [ones, dec, ones]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpthka4pgb/tmpthka4pgb.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f6c12252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f6c11f49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f6c11f49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f6c11f487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpthka4pgb                        0x000056234d81b6b4 <unavailable> + 5812

    5    libc.so.6                          0x00007f6c11a3f460 __libc_start_main +
    245

    6    tmpthka4pgb                        0x000056234d81b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let counts = arr.map { $0.count_ones()\
    \ }\n    var numZeros = 0.0\n    for count in counts {\n        numZeros += count\n\
    \    }\n\n    return arr.sorted { (lhs, rhs) -> Bool in\n        let leftCount\
    \ = lhs.count_ones()\n        let rightCount = rhs.count_ones()\n        return\
    \ leftCount < rightCount || (leftCount == rightCount && lhs > rhs)\n    }.map\
    \ { lhs in\n        let leftCount = lhs.count_ones()\n        let rightCount =\
    \ rhs.count_ones()\n        if leftCount < rightCount {\n            return (leftCount\
    \ / numZeros) <=> (rightCount / numZeros)\n        }\n        return (leftCount\
    \ / numZeros) <=> (leftCount / numZeros)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpxxm9i71o.swift:13:31: error: value of type 'Int' has no member\
    \ 'count_ones'\n    let counts = arr.map { $0.count_ones() }\n               \
    \            ~~ ^~~~~~~~~~\n/tmp/tmpxxm9i71o.swift:25:26: error: cannot find 'rhs'\
    \ in scope\n        let rightCount = rhs.count_ones()\n                      \
    \   ^~~\n/tmp/tmpxxm9i71o.swift:27:43: error: cannot find operator '<=>' in scope\n\
    \            return (leftCount / numZeros) <=> (rightCount / numZeros)\n     \
    \                                     ^~~\n/tmp/tmpxxm9i71o.swift:29:39: error:\
    \ cannot find operator '<=>' in scope\n        return (leftCount / numZeros) <=>\
    \ (leftCount / numZeros)\n                                      ^~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let ones = arr.filter { $0 == 1 }\n\
    \    let onesInOrder = ones.sorted { $0 < $1 }\n\n    let dec = arr.map { Double($0)\
    \ }\n    let decInOrder = dec.sorted { $0 < $1 }\n\n    return decInOrder + onesInOrder\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmph99b9swb.swift:19:23: error: binary operator '+' cannot be applied\
    \ to operands of type '[Double]' and '[Int]'\n    return decInOrder + onesInOrder\n\
    \           ~~~~~~~~~~ ^ ~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var oneCount\
    \ = 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] != 0 {\n       \
    \     oneCount++\n        }\n    }\n    result.extend(sortByDec(arr, oneCount)...)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpjkbv5584.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmpjkbv5584.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmpjkbv5584.swift:15:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(arr); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n  guard arr.count > 0 else { return arr\
    \ }\n\n  var ans = [Int]()\n  var count = arr.count\n  ans.append(arr[0])\n  var\
    \ i = 1\n  for j in 1...count {\n    if arr[j] < arr[i - 1] {\n      ans.append(arr[j])\n\
    \      ans.append(arr[i - 1])\n    }\n    i += 1\n  }\n  return ans\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00007fe0ac792c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fe0ac489561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00007fe0ac489286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00007fe0ac48913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00007fe0ac488bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00007fe0aca36e83 <unavailable> + 188035

    6    tmprezqluff                        0x000055aafa2492a0 <unavailable> + 8864

    7    tmprezqluff                        0x000055aafa2485e4 <unavailable> + 5604

    8    libc.so.6                          0x00007fe0abf7f460 __libc_start_main +
    245

    9    tmprezqluff                        0x000055aafa2482b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted: [Int] = []\n    for k\
    \ in arr {\n        sorted.append(k)\n    }\n    sorted.sortInPlace()\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpkc_fc4dd.swift:17:12: error: value of type '[Int]' has no member\
    \ 'sortInPlace'\n    sorted.sortInPlace()\n    ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let rev = arr.map { $0 * 0x10000000000\
    \ }\n    return sort(rev, by: { a, b in\n        guard let i = Int(a), let j =\
    \ Int(b) else {\n            return false\n        }\n        return i < j\n \
    \   })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5,\
    \ 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp2wd64h2b.swift:14:12: error: cannot find 'sort' in scope\n    return\
    \ sort(rev, by: { a, b in\n           ^~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sortArr(arr, nil)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpv1zik7z4.swift:13:12: error: cannot find 'sortArr' in scope\n \
    \   return sortArr(arr, nil)\n           ^~~~~~~\n/tmp/tmpv1zik7z4.swift:13:25:\
    \ error: 'nil' requires a contextual type\n    return sortArr(arr, nil)\n    \
    \                    ^\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: '/tmp/tmpsrq4k8z2.swift:14:1: error: missing return in global function expected
    to return ''[Int]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660053429
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let n = arr.count\n    var result\
    \ = Array(repeating: -1, count: n)\n    arr.forEach { i in\n        let n = String(i).count\n\
    \        if n > 1 {\n            result[n - 1] = Int(i)\n        } else {\n  \
    \          result[n - 1] = Int(i)\n        }\n    }\n    result = result.sorted()\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp9cb58maz/tmp9cb58maz.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f6c205a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f6c2029ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f6c2029a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f6c202997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9cb58maz                        0x000055f62ae23854 <unavailable> + 6228

    5    libc.so.6                          0x00007f6c1fd90460 __libc_start_main +
    245

    6    tmp9cb58maz                        0x000055f62ae23439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // Your code here\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: '/tmp/tmppaek3ob7.swift:14:1: error: missing return in global function expected
    to return ''[Int]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n  var ordered = [Int]()\n  var count =\
    \ 0\n  for element in arr {\n    if element != 0 {\n      ordered[count] = element\n\
    \      count += 1\n    }\n  }\n  var count = 0\n  for element in ordered {\n \
    \   if element != 0 {\n      count = element > 0 ? count + 1 : count\n    }\n\
    \  }\n  ordered = ordered[0..<count]\n  return ordered\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpyfkihb_k.swift:21:7: error: invalid redeclaration of 'count'\n\
    \  var count = 0\n      ^\n/tmp/tmpyfkihb_k.swift:14:7: note: 'count' previously\
    \ declared here\n  var count = 0\n      ^\n/tmp/tmpyfkihb_k.swift:27:20: error:\
    \ cannot assign value of type 'ArraySlice<Int>' to type '[Int]'\n  ordered = ordered[0..<count]\n\
    \            ~~~~~~~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var output = [Int]()\n\n    for num\
    \ in arr {\n        var num_bin = bits(num)\n        var num_ones = num_bin &\
    \ 0b00001111\n        if num_ones == 0b00001111 {\n            num_ones = 0\n\
    \        } else {\n            num_ones += 1\n        }\n        num_bin &= 0b11110000\n\
    \        if num_ones == 0 {\n            num_ones = 0\n        } else {\n    \
    \        num_ones += 1\n        }\n        num_bin |= num_ones\n\n        output.append(num)\n\
    \    }\n\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpait96toc.swift:16:23: error: cannot find 'bits' in scope\n    \
    \    var num_bin = bits(num)\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sorted(arr, { $0 < $1 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpuczfx0j2.swift:13:12: error: cannot find 'sorted' in scope\n  \
    \  return sorted(arr, { $0 < $1 })\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    return arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpag0hz30s/tmpag0hz30s.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fddf1277c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fddf0f6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fddf0f6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fddf0f6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpag0hz30s                        0x000056037d2573e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fddf0a64460 __libc_start_main +
    245

    6    tmpag0hz30s                        0x000056037d256fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var i = 0\n    var result = [0]\n\
    \    \n    for n in arr {\n        let index = n / 2\n        result[index] =\
    \ result[index] + 1\n        \n        if n == 0 {\n            result[i] = result[index]\
    \ - 1\n            i++\n        }\n    }\n    \n    let sortedArray = result.sorted()\n\
    \    return Array(sortedArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp5lsuc2mx.swift:22:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            i++\n             ^~\n"
  stdout: ''
  timestamp: 1660053429
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n  var oneCount: [Int] = []\n  var decCount:\
    \ [Int] = []\n  for val in arr {\n    oneCount.append(0)\n    decCount.append(0)\n\
    \    for bit in val {\n      oneCount[bit] += 1\n      decCount[bit] += val\n\
    \    }\n  }\n  \n  for bit in 1...64 {\n    oneCount[bit] = -oneCount[bit]\n \
    \ }\n  \n  var sortedArr = [Int]()\n  for val in oneCount {\n    if val > 0 {\n\
    \      sortedArr.append(val)\n    }\n  }\n  \n  for val in decCount {\n    sortedArr.append(val)\n\
    \  }\n  \n  return sortedArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpno2o668t.swift:18:16: error: for-in loop requires 'Int' to conform\
    \ to 'Sequence'\n    for bit in val {\n               ^~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // base case\n    if arr.count ==\
    \ 0 {\n        return arr\n    }\n\n    // recursive case\n    // split arr into\
    \ two, first is [1, 0, 2, 4, 3], second is [0, 1, 1, 3]\n    var left = [Int]()\n\
    \    var right = [Int]()\n\n    for index in 0..<arr.count {\n        if arr[index]\
    \ == 1 {\n            left.append(arr[index])\n        } else {\n            right.append(arr[index])\n\
    \        }\n    }\n    var left = sort_array(left)\n    var right = sort_array(right)\n\
    \n    // merge two sorted list\n    return left + right\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmp0lzapz_a.swift:30:27: error: missing argument label 'arr:' in call\n\
    \    var left = sort_array(left)\n                          ^\n              \
    \            arr: \n/tmp/tmp0lzapz_a.swift:31:28: error: missing argument label\
    \ 'arr:' in call\n    var right = sort_array(right)\n                        \
    \   ^\n                           arr: \n/tmp/tmp0lzapz_a.swift:34:17: error:\
    \ cannot convert return expression of type 'String' to return type '[Int]'\n \
    \   return left + right\n           ~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let bits = arr.map { $0.bitwiseAnd(1)\
    \ }\n    bits.sortInPlace()\n    return bits\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpxcgjguo9.swift:13:29: error: value of type 'Int' has no member\
    \ 'bitwiseAnd'\n    let bits = arr.map { $0.bitwiseAnd(1) }\n                \
    \         ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sorted(arr, { $0.count_ones()\
    \ == $1.count_ones() ?\n        compare($0, $1, $0.toInt(), $1.toInt(), &compare)\
    \ ?\n            $0.toInt() : $1.toInt() : compare($0, $1, $0.toInt(), $1.toInt(),\
    \ &compare)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpim9ocipj.swift:13:12: error: cannot find 'sorted' in scope\n  \
    \  return sorted(arr, { $0.count_ones() == $1.count_ones() ?\n           ^~~~~~\n\
    /tmp/tmpim9ocipj.swift:14:9: error: cannot find 'compare' in scope\n        compare($0,\
    \ $1, $0.toInt(), $1.toInt(), &compare) ?\n        ^~~~~~~\n/tmp/tmpim9ocipj.swift:14:50:\
    \ error: cannot find 'compare' in scope\n        compare($0, $1, $0.toInt(), $1.toInt(),\
    \ &compare) ?\n                                                 ^~~~~~~\n/tmp/tmpim9ocipj.swift:15:39:\
    \ error: cannot find 'compare' in scope\n            $0.toInt() : $1.toInt() :\
    \ compare($0, $1, $0.toInt(), $1.toInt(), &compare)\n                        \
    \              ^~~~~~~\n/tmp/tmpim9ocipj.swift:15:80: error: cannot find 'compare'\
    \ in scope\n            $0.toInt() : $1.toInt() : compare($0, $1, $0.toInt(),\
    \ $1.toInt(), &compare)\n                                                    \
    \                           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var ones = 0\n    var tens = 0\n \
    \   var hundreds = 0\n    var thousands = 0\n    var tenK = 0\n    var hundredK\
    \ = 0\n    var thousandK = 0\n    for x in arr {\n        if x == 1 {\n      \
    \      ones += 1\n        } else if x == 10 {\n            tens += 1\n       \
    \ } else if x == 100 {\n            hundreds += 1\n        } else if x == 1000\
    \ {\n            thousands += 1\n        } else {\n            if x%10 == 0 {\n\
    \                tenK += x/10\n            } else if x%100 == 0 {\n          \
    \      hundredK += x/100\n            } else if x%1000 == 0 {\n              \
    \  thousandK += x/1000\n            } else {\n                if x%1000 < x%100\
    \ {\n                    tenK += x/100\n                } else {\n           \
    \         hundredK += x/1000\n                }\n            }\n        }\n  \
    \  }\n    var nOnes = ones\n    var nTens = tens\n    var nHundreds = hundreds\n\
    \    var nThousands = thousands\n    var nTenK = tenK\n    var nHundredK = hundredK\n\
    \    var nThousandK = thousandK\n    if nOnes < nTens {\n        if nTenK < nThousandK\
    \ {\n            if nHundredK < nThousands {\n                swap(&arr[0], &arr[nOnes])\n\
    \            } else {\n                swap(&arr[0], &arr[nHundreds])\n      \
    \      }\n        } else {\n            if nThousandK < nHundreds {\n        \
    \        swap(&arr[0], &arr[nThousands])\n            } else {\n             \
    \   swap(&arr[0], &arr[nHundredK])\n            }\n        }\n    } else if nTens\
    \ < nThousands {\n        if nHundredK < nThousandK {\n            if nThousandK\
    \ < nHundreds {\n                swap(&arr[0], &arr[nTens])\n            } else\
    \ {\n                swap(&arr[0], &arr[nThousandK])\n            }\n        }\
    \ else {\n            if nHundredK < nThousands {\n                swap(&arr[0],\
    \ &arr[nHundreds])\n            } else {\n                swap(&arr[0], &arr[nThousandK])\n\
    \            }\n        }\n    } else if nHundreds < nThousandK {\n        if\
    \ nThousandK < nThousands {\n            swap(&arr[0], &arr[nHundreds])\n    \
    \    } else {\n            swap(&arr[0], &arr[nThousand\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpcvctur70.swift:85:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpcvctur70.swift:84:31: note: to match this opening '['\n           \
    \ swap(&arr[0], &arr[nThousand\n                              ^\n/tmp/tmpcvctur70.swift:85:1:\
    \ error: expected ')' in expression list\n}\n^\n/tmp/tmpcvctur70.swift:84:17:\
    \ note: to match this opening '('\n            swap(&arr[0], &arr[nThousand\n\
    \                ^\n/tmp/tmpcvctur70.swift:107:64: error: expected '}' at end\
    \ of brace statement\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])\n                                                               ^\n/tmp/tmpcvctur70.swift:80:38:\
    \ note: to match this opening '{'\n    } else if nHundreds < nThousandK {\n  \
    \                                   ^\n/tmp/tmpcvctur70.swift:107:64: error: expected\
    \ '}' at end of brace statement\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\n                                                       \
    \        ^\n/tmp/tmpcvctur70.swift:12:38: note: to match this opening '{'\nfunc\
    \ sort_array(arr: [Int]) -> [Int] {\n                                     ^\n\
    /tmp/tmpcvctur70.swift:55:22: error: cannot pass immutable value as inout argument:\
    \ 'arr' is a 'let' constant\n                swap(&arr[0], &arr[nOnes])\n    \
    \                 ^~~~\n/tmp/tmpcvctur70.swift:55:31: error: cannot pass immutable\
    \ value as inout argument: 'arr' is a 'let' constant\n                swap(&arr[0],\
    \ &arr[nOnes])\n                              ^~~~\n/tmp/tmpcvctur70.swift:57:22:\
    \ error: cannot pass immutable value as inout argument: 'arr' is a 'let' constant\n\
    \                swap(&arr[0], &arr[nHundreds])\n                     ^~~~\n/tmp/tmpcvctur70.swift:57:31:\
    \ error: cannot pass immutable value as inout argument: 'arr' is a 'let' constant\n\
    \                swap(&arr[0], &arr[nHundreds])\n                            \
    \  ^~~~\n/tmp/tmpcvctur70.swift:61:22: error: cannot pass immutable value as inout\
    \ argument: 'arr' is a 'let' constant\n                swap(&arr[0], &arr[nThousands])\n\
    \                     ^~~~\n/tmp/tmpcvctur70.swift:61:31: "
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let ones = arr.filter{$0.isOne}\n\
    \    let len = arr.count\n    let zeros = len - ones\n    var sorted = [Int]()\n\
    \    for a in arr {\n        if a.isOne {\n            sorted.append(a)\n    \
    \    } else {\n            let index = Int(a).binarize().count\n            let\
    \ index = len + index\n            sorted.append(Int((index).binarize()))\n  \
    \      }\n    }\n    return sorted.sorted{ $0 > $1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmptr39ma0v.swift:13:30: error: value of type 'Int' has no member\
    \ 'isOne'\n    let ones = arr.filter{$0.isOne}\n                          ~~ ^~~~~\n\
    /tmp/tmptr39ma0v.swift:18:14: error: value of type 'Int' has no member 'isOne'\n\
    \        if a.isOne {\n           ~ ^~~~~\n/tmp/tmptr39ma0v.swift:21:32: error:\
    \ value of type 'Int' has no member 'binarize'\n            let index = Int(a).binarize().count\n\
    \                        ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sorted(arr, by: { (a: Int,\
    \ b: Int) -> Bool in\n        let ones = binary(a).characters.count\n        let\
    \ twos = binary(b).characters.count\n        if ones == twos {\n            return\
    \ a > b\n        } else {\n            return ones > twos\n        }\n    })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpoeohwd3x.swift:13:12: error: cannot find 'sorted' in scope\n  \
    \  return sorted(arr, by: { (a: Int, b: Int) -> Bool in\n           ^~~~~~\n/tmp/tmpoeohwd3x.swift:14:20:\
    \ error: cannot find 'binary' in scope\n        let ones = binary(a).characters.count\n\
    \                   ^~~~~~\n/tmp/tmpoeohwd3x.swift:15:20: error: cannot find 'binary'\
    \ in scope\n        let twos = binary(b).characters.count\n                  \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var count = 0\n    var max = -1\n\
    \    for val in arr {\n        if val > max {\n            max = val\n       \
    \ }\n        count += val == 1 && count > 0\n    }\n    if count == 0 {\n    \
    \    return arr\n    }\n    let result: Array<Int> = Array(repeating: max, count:\
    \ count)\n    for idx in 0..<arr.count {\n        let val = arr[idx]\n       \
    \ if val == 1 {\n            idx += 1\n            if idx < arr.count {\n    \
    \            result[idx] = arr[idx]\n            }\n        }\n    }\n    return\
    \ result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpb5o3bkaq.swift:19:27: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'Int'\n        count += val == 1 && count > 0\n  \
    \                        ^\n/tmp/tmpb5o3bkaq.swift:28:17: error: left side of\
    \ mutating operator isn't mutable: 'idx' is a 'let' constant\n            idx\
    \ += 1\n            ~~~ ^\n/tmp/tmpb5o3bkaq.swift:30:23: error: cannot assign\
    \ through subscript: 'result' is a 'let' constant\n                result[idx]\
    \ = arr[idx]\n                ~~~~~~^\n/tmp/tmpb5o3bkaq.swift:24:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let result: Array<Int> = Array(repeating:\
    \ max, count: count)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    guard arr.count >= 1 else {\n    \
    \    return arr\n    }\n    var sorted_arr: [Int] = []\n    var zeroCount = 0\n\
    \    var num = 0\n    for num in arr {\n        let binaryString = String(cmp:\
    \ num, radix: 2)\n        if binaryString.count >= 2 {\n            sorted_arr.insert(num,\
    \ at: 0)\n            zeroCount = 0\n        } else if binaryString.count == 1\
    \ {\n            sorted_arr.insert(num, at: zeroCount)\n            zeroCount\
    \ += 1\n        } else {\n            zeroCount += 1\n        }\n    }\n    for\
    \ num in arr {\n        let decimalValue = Int(num, radix: 2)\n        let isZero\
    \ = num == 0 && !zeroCount\n        if num != 0 && !isZero {\n            sorted_arr.insert(decimalValue,\
    \ at: 0)\n        } else if zeroCount > 0 {\n            sorted_arr.insert(decimalValue,\
    \ at: zeroCount)\n            zeroCount -= 1\n        } else {\n            sorted_arr.insert(decimalValue,\
    \ at: arr.count - 1)\n        }\n    }\n    return sorted_arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmp1e64igqm.swift:20:34: error: extraneous argument label 'cmp:' in\
    \ call\n        let binaryString = String(cmp: num, radix: 2)\n              \
    \                   ^~~~~~\n                                  \n/tmp/tmp1e64igqm.swift:32:28:\
    \ error: initializer 'init(_:radix:)' requires that 'Int' conform to 'StringProtocol'\n\
    \        let decimalValue = Int(num, radix: 2)\n                           ^\n\
    Swift.FixedWidthInteger:2:23: note: where 'S' = 'Int'\n    @inlinable public init?<S>(_\
    \ text: S, radix: Int = 10) where S : StringProtocol\n                      ^\n\
    /tmp/tmp1e64igqm.swift:33:35: error: type 'Int' cannot be used as a boolean; test\
    \ for '== 0' instead\n        let isZero = num == 0 && !zeroCount\n          \
    \                       ~^\n                                  (         == 0)\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    var sorted = [Int]()\n    \n\
    \    for i in 0..<arr.count {\n        if ((arr[i] & 1) == 1) {\n            sorted\
    \ = sorted + [arr[i]]\n        }\n    }\n    \n    return sorted\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp23hstfm8/tmp23hstfm8.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f8a538d0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f8a535c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f8a535c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f8a535c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp23hstfm8                        0x000055931efb16d4 <unavailable> + 5844

    5    libc.so.6                          0x00007f8a530bd460 __libc_start_main +
    245

    6    tmp23hstfm8                        0x000055931efb12b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted = [Int]()\n    var ones\
    \ = 0\n    var decimal = 0\n    for i in arr {\n        if i < 0 {\n         \
    \   sorted = sorted.reversed() //for negative numbers in arr\n            sorted\
    \ = sorted.sorted(by: { $0 < $1 }) //for negative numbers in arr\n           \
    \ return sorted\n        }\n        if i&1 == 1 {\n            ones++\n      \
    \  } else {\n            decimal = decimal + UInt64(i)*pow(10, Int(log10(i)))\n\
    \        }\n    }\n    sorted = sorted.sorted(by: { $0 > $1 })\n    sorted = sorted.sorted(by:\
    \ { $0 < $1 })\n    sorted = sorted.sorted(by: { $0 > $1 })\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpgxl6ohp6.swift:23:17: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            ones++\n                ^~\n/tmp/tmpgxl6ohp6.swift:25:43:\
    \ error: cannot find 'pow' in scope\n            decimal = decimal + UInt64(i)*pow(10,\
    \ Int(log10(i)))\n                                          ^~~\n/tmp/tmpgxl6ohp6.swift:25:55:\
    \ error: cannot find 'log10' in scope\n            decimal = decimal + UInt64(i)*pow(10,\
    \ Int(log10(i)))\n                                                      ^~~~~\n\
    /tmp/tmpgxl6ohp6.swift:25:33: error: cannot convert value of type 'UInt64' to\
    \ expected argument type 'Int'\n            decimal = decimal + UInt64(i)*pow(10,\
    \ Int(log10(i)))\n                                ^\n                        \
    \        Int(     )\n/tmp/tmpgxl6ohp6.swift:25:42: error: cannot convert value\
    \ of type 'UInt64' to expected argument type 'Int'\n            decimal = decimal\
    \ + UInt64(i)*pow(10, Int(log10(i)))\n                                       \
    \  ^\n                                Int(                            )\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var reversedArr = [Int]()\n    var\
    \ count = [Int]()\n    for i in arr {\n        count[i] = count[i] ?? 0\n    \
    \    count[i]++\n    }\n    for i in 0..<count.count {\n        reversedArr.append(count[i]\
    \ * (arr[i]))\n    }\n    reversedArr = reversedArr.reverse()\n    return reversedArr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmppw17sfoc.swift:16:29: warning: left side of nil coalescing operator\
    \ '??' has non-optional type 'Int', so the right side is never used\n        count[i]\
    \ = count[i] ?? 0\n                   ~~~~~~~~ ^~~~\n                        \
    \    \n/tmp/tmppw17sfoc.swift:17:17: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        count[i]++\n                ^~\n/tmp/tmppw17sfoc.swift:22:31:\
    \ error: cannot assign value of type '()' to type '[Int]'\n    reversedArr = reversedArr.reverse()\n\
    \                  ~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var arr = ArraySlice(arr)\n    arr.sort()\n\
    \    return ArraySlice(arr)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpxojplo06.swift:15:12: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return ArraySlice(arr)\n\
    \           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let len = arr.count\n    let maxCount\
    \ = 0\n    var counts = [Int: Int]()\n    for n in arr {\n        let num = n.binary.count\n\
    \        let count = counts[num]\n        if count == 0 {\n            counts[num]\
    \ = 1\n            maxCount = count\n        } else if count > maxCount {\n  \
    \          counts[num] = count\n            maxCount = count\n        }\n    }\n\
    \    var res = [Int]()\n    for i in 0..<len {\n        let num = arr[i]\n   \
    \     if let num = counts[num] {\n            res.append(num)\n            counts[num]\
    \ = counts[num] - 1\n            if counts[num] == 0 {\n                counts[num]\
    \ = maxCount\n            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpj1_ry_ic.swift:17:21: error: value of type 'Int' has no member\
    \ 'binary'\n        let num = n.binary.count\n                  ~ ^~~~~~\n/tmp/tmpj1_ry_ic.swift:21:13:\
    \ error: cannot assign to value: 'maxCount' is a 'let' constant\n            maxCount\
    \ = count\n            ^~~~~~~~\n/tmp/tmpj1_ry_ic.swift:14:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let maxCount = 0\n    ^~~\n    var\n/tmp/tmpj1_ry_ic.swift:24:13:\
    \ error: cannot assign to value: 'maxCount' is a 'let' constant\n            maxCount\
    \ = count\n            ^~~~~~~~\n/tmp/tmpj1_ry_ic.swift:14:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let maxCount = 0\n    ^~~\n    var\n/tmp/tmpj1_ry_ic.swift:32:33:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            counts[num] = counts[num] - 1\n                                ^\n\
    /tmp/tmpj1_ry_ic.swift:32:33: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n            counts[num] = counts[num] - 1\n\
    \                                ^\n                          (           ?? <#default\
    \ value#>)\n/tmp/tmpj1_ry_ic.swift:32:33: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            counts[num] = counts[num]\
    \ - 1\n                                ^\n                                   \
    \  !\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // sort the array by number of ones\n\
    \    let ones = arr.filter { $0 == 1 }\n    let sortedOnes = ones\n        .sorted()\n\
    \        .map { Int(\"\\($0)\", radix: 16) }\n\n    // sort the array by number\
    \ of zeros\n    let zeros = arr.filter { $0 == 0 }\n    let sortedZeros = zeros\n\
    \        .sorted()\n        .map { Int(\"\\($0)\", radix: 16) }\n\n    // sort\
    \ by comparing sorted ones\n    let sortedArray = sortedZeros + sortedOnes\n\n\
    \    // return sorted array\n    return sortedArray\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpozh7cieu.swift:29:12: error: cannot convert return expression of\
    \ type '[Int?]' to return type '[Int]'\n    return sortedArray\n           ^\n\
    /tmp/tmpozh7cieu.swift:29:12: note: arguments to generic parameter 'Element' ('Int?'\
    \ and 'Int') are expected to be equal\n    return sortedArray\n           ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var ones = 0\n    var min: Int? =\
    \ nil\n    for i in arr {\n        if i == 1 {\n            ones += 1\n      \
    \  } else {\n            if let _ = min {\n                if ones < min! {\n\
    \                    min = nil\n                }\n            }\n           \
    \ ones = 1\n        }\n    }\n    if let _ = min {\n        ones = min! + 1\n\
    \    }\n    arr = arr\n        .sorted { $0 == 1 }\n        .sorted { $0 * ones..<$1\
    \ }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpxluigy4s.swift:30:5: error: cannot assign to value: 'arr' is a\
    \ 'let' constant\n    arr = arr\n    ^~~\n/tmp/tmpxluigy4s.swift:31:17: error:\
    \ contextual closure type '(Int, Int) throws -> Bool' expects 2 arguments, but\
    \ 1 was used in closure body\n        .sorted { $0 == 1 }\n                ^\n\
    /tmp/tmpxluigy4s.swift:32:28: error: cannot convert value of type 'Range<Int>'\
    \ to closure result type 'Bool'\n        .sorted { $0 * ones..<$1 }\n        \
    \          ~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var temp = arr.sort()\n    var result\
    \ = [Int]()\n    \n    \n    for x in 0..<temp.count {\n        if temp[x] ==\
    \ 1 {\n            result.append(x)\n        } else {\n            \n        \
    \    for i in 0..<temp.count {\n                if temp[i] == 1 && x == i {\n\
    \                    result.append(x)\n                    \n                \
    \    break\n                }\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpwgd_22jd.swift:13:20: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    var temp = arr.sort()\n              \
    \ ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted { $0 < $1 }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmppnxupquc/tmppnxupquc.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f0edfdd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f0edfac8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f0edfac8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f0edfac77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppnxupquc                        0x00005563aa2ad454 <unavailable> + 5204

    5    libc.so.6                          0x00007f0edf5be460 __libc_start_main +
    245

    6    tmppnxupquc                        0x00005563aa2ad039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return arr\n\
    \    }\n\n    var sortedArr = arr.sorted()\n    var onesCounter = 0\n    var decimalCounter\
    \ = 0\n    var value = 0\n    for val in arr {\n        if val == 1 {\n      \
    \      onesCounter += 1\n        } else {\n            if decimalCounter == 0\
    \ {\n                value = onesCounter * 10 + (val - onesCounter)\n        \
    \    } else {\n                value = decimalCounter * 10 + (val - onesCounter)\n\
    \            }\n            decimalCounter = 0\n            onesCounter = 0\n\
    \        }\n        sortedArr = sortedArr.insert(val, at: sortedArr.endIndex)\n\
    \    }\n    sortedArr = sortedArr.sorted()\n    return sortedArr\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpuk_o3qmd.swift:33:31: error: cannot assign value of type '()' to\
    \ type '[Int]'\n        sortedArr = sortedArr.insert(val, at: sortedArr.endIndex)\n\
    \                    ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // Your code here\n    var binarizedArray\
    \ = [Int](repeating: 0, count: arr.count)\n    var binarizedArrayWithCount = Int()\n\
    \    for var i = 0; i < arr.count; i++ {\n        var bin: Int = binarize(arr[i])\n\
    \        binarizedArrayWithCount += bin\n        binarizedArray[i] = bin\n   \
    \ }\n    var sortedArray = [Int]()\n    var sortedArrayWithCount = Int()\n   \
    \ for i in 0..<binarizedArrayWithCount {\n        sortedArray.append(binarizedArray[i])\n\
    \        sortedArrayWithCount += binarizedArray[i]\n    }\n    var sortedArrayWithCountInt\
    \ = Int(sortedArrayWithCount)\n    var sortedArrayCount = [Int](repeating: 0,\
    \ count: sortedArrayWithCountInt)\n    for element in sortedArray {\n        sortedArrayCount[element]\
    \ += element\n    }\n    var sortedArrayCountInt = Int(sortedArrayCount)\n   \
    \ var sortedArrayCountArray = [Int](repeating: 0, count: sortedArrayCountInt)\n\
    \    for element in sortedArrayCount {\n        sortedArrayCountArray[element]\
    \ += element\n    }\n    var sortedArrayCountIntArray = sortedArrayCountArray.map\
    \ { Int($0) }\n    var sortedArrayCountIntArraySorted = sortedArrayCountIntArray.sorted()\n\
    \    var sortedArrayCountIntArraySortedSorted = [Int](repeating: 0, count: sortedArrayCountIntArraySorted!.count)\n\
    \    for element in sortedArrayCountIntArraySorted {\n        sortedArrayCountIntArraySortedSorted[element]\
    \ += element\n    }\n    var sortedArrayCountIntArraySortedSortedSorted = sortedArrayCountIntArraySortedSorted.sorted()\n\
    \    return sortedArrayCountIntArraySortedSorted\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmprkts2lg7.swift:16:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < arr.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprkts2lg7.swift:32:31: error: no exact matches in call to initializer \n\
    \    var sortedArrayCountInt = Int(sortedArrayCount)\n                       \
    \       ^\nSwift.Int:7:12: note: candidate expects value of type 'Float16' for\
    \ parameter #1 (got '[Int]')\n    public init(_ source: Float16)\n           ^\n\
    Swift.Int:10:12: note: candidate expects value of type 'Float' for parameter #1\
    \ (got '[Int]')\n    public init(_ source: Float)\n           ^\nSwift.Int:12:12:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got '[Int]')\n\
    \    public init(_ source: Double)\n           ^\nSwift.Int:14:12: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got '[Int]')\n    public init(_\
    \ source: Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value\
    \ of type 'Builtin.Int64' for parameter #1 (got '[Int]')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got '[Int]')\n    public init(_ _v:\
    \ Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23: note: candidate expects\
    \ value of type 'String' for parameter #1 (got '[Int]')\n    @inlinable public\
    \ init?(_ description: String)\n                      ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // 1. sort\n    var result = [Int]()\n\
    \    var start = 1\n    while start < arr.count {\n        start += 1\n      \
    \  for j in start..<arr.count {\n            if arr[j-1] == arr[j] {\n       \
    \         continue\n            }\n            temp = arr[j]\n            arr[j]\
    \ = arr[j-1]\n            arr[j-1] = temp\n            // 2. sort\n          \
    \  i = 0\n            while (i < arr.count-1) && arr[i] == arr[i+1] {\n      \
    \          i += 1\n            }\n            if i == arr.count-1 {\n        \
    \        result.append(arr[i])\n            } else {\n                result.append(arr[i],\
    \ arr[i+1])\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpbm9bvbc7.swift:22:13: error: cannot find 'temp' in scope\n    \
    \        temp = arr[j]\n            ^~~~\n/tmp/tmpbm9bvbc7.swift:23:16: error:\
    \ cannot assign through subscript: 'arr' is a 'let' constant\n            arr[j]\
    \ = arr[j-1]\n            ~~~^\n/tmp/tmpbm9bvbc7.swift:24:24: error: cannot find\
    \ 'temp' in scope\n            arr[j-1] = temp\n                       ^~~~\n\
    /tmp/tmpbm9bvbc7.swift:24:16: error: cannot assign through subscript: 'arr' is\
    \ a 'let' constant\n            arr[j-1] = temp\n            ~~~^\n/tmp/tmpbm9bvbc7.swift:26:13:\
    \ error: cannot find 'i' in scope\n            i = 0\n            ^\n/tmp/tmpbm9bvbc7.swift:27:20:\
    \ error: cannot find 'i' in scope\n            while (i < arr.count-1) && arr[i]\
    \ == arr[i+1] {\n                   ^\n/tmp/tmpbm9bvbc7.swift:27:44: error: cannot\
    \ find 'i' in scope\n            while (i < arr.count-1) && arr[i] == arr[i+1]\
    \ {\n                                           ^\n/tmp/tmpbm9bvbc7.swift:27:54:\
    \ error: cannot find 'i' in scope\n            while (i < arr.count-1) && arr[i]\
    \ == arr[i+1] {\n                                                     ^\n/tmp/tmpbm9bvbc7.swift:28:17:\
    \ error: cannot find 'i' in scope\n                i += 1\n                ^\n\
    /tmp/tmpbm9bvbc7.swift:30:16: error: cannot find 'i' in scope\n            if\
    \ i == arr.count-1 {\n               ^\n/tmp/tmpbm9bvbc7.swift:31:35: error: cannot\
    \ find 'i' in scope\n                result.append(arr[i])\n                 \
    \                 ^\n/tmp/tmpbm9bvbc7.swift:33:35: error: cannot find 'i' in scope\n\
    \                result.append(arr[i], arr[i+1])\n                           \
    \       ^\n/tmp/tmpbm9bvbc7.swift:33:43: error: cannot find 'i' in scope\n   \
    \             result.append(arr[i], arr[i+1])\n                              \
    \            ^\n/tmp/tmpbm9bvbc7.swift:33:42: error: extra argument in call\n\
    \                result.append(arr[i], arr[i+1])\n                           \
    \  ~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let swapped = Array(arr)\n    swapped.sort\
    \ { $0 < $1 }\n    return swapped\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpgpqnbzbo.swift:14:13: error: cannot use mutating member on immutable\
    \ value: 'swapped' is a 'let' constant\n    swapped.sort { $0 < $1 }\n    ~~~~~~~\
    \ ^\n/tmp/tmpgpqnbzbo.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let swapped = Array(arr)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted { $0 > $1 }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpajuelm0s/tmpajuelm0s.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f8a5be30c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f8a5bb27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f8a5bb27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f8a5bb267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpajuelm0s                        0x000055f2bf810454 <unavailable> + 5204

    5    libc.so.6                          0x00007f8a5b61d460 __libc_start_main +
    245

    6    tmpajuelm0s                        0x000055f2bf810039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var zeroCount = 0\n    var oneCount\
    \ = 0\n    var twoCount = 0\n    var threeCount = 0\n    var fourCount = 0\n \
    \   var fiveCount = 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i]\
    \ == 0 {\n            zeroCount += 1\n        } else {\n            if zeroCount\
    \ == 0 {\n                zeroCount = 1\n                if arr[i] == 1 {\n  \
    \                  oneCount += 1\n                }\n            } else {\n  \
    \              if arr[i] == 1 {\n                    oneCount += 1\n         \
    \       } else {\n                    oneCount = 0\n                    if arr[i]\
    \ == 2 {\n                        twoCount += 1\n                    }\n     \
    \           }\n            }\n        }\n    }\n    var max = 0\n    var firstZeroIndex\
    \ = 0\n    var secondZeroIndex = 0\n    var firstOneIndex = 0\n    var secondOneIndex\
    \ = 0\n    var firstTwoIndex = 0\n    var secondTwoIndex = 0\n    var firstThreeIndex\
    \ = 0\n    var secondThreeIndex = 0\n    var firstFourIndex = 0\n    var secondFourIndex\
    \ = 0\n    var firstFiveIndex = 0\n    var secondFiveIndex = 0\n    if zeroCount\
    \ > 0 {\n        max = zeroCount\n        maxIndex = zeroCount\n        for i\
    \ := 0; i < len(arr); i++ {\n            if arr[i] == 0 {\n                if\
    \ zeroCount == 1 {\n                    if arr[i] == 1 {\n                   \
    \     if max == zeroCount {\n                            firstZeroIndex = i\n\
    \                        }\n                    } else {\n                   \
    \     if max == zeroCount {\n                            secondZeroIndex = i\n\
    \                        }\n                    }\n                } else {\n\
    \                    if max == zeroCount {\n                        if arr[i]\
    \ == 1 {\n                            if max == zeroCount {\n                \
    \                firstZeroIndex = i\n                            }\n         \
    \               } else {\n                            if max == zeroCount {\n\
    \                                secondZeroIndex = i\n                       \
    \     }\n                        }\n                    } else {\n           \
    \             if arr[i] == 1 {\n                            if max == zeroCount\
    \ {\n                                firstOneIndex = i\n                     \
    \       }\n                        } else {\n                            if max\
    \ == zeroCount {\n                                secondOneIndex = i\n       \
    \                     }\n                        }\n                    }\n  \
    \              }\n                zeroCount = 0\n            }\n        }\n  \
    \  }\n    if oneCount > 0 {\n        max = oneCount\n        maxIndex = oneCount\n\
    \        for i := 0; i < len(arr); i++ {\n            if arr[i] == 1 {\n     \
    \           if oneCount == 1 {\n                    if arr[i] == 1 {\n       \
    \                 if max == oneCount {\n                            firstOneIndex\
    \ = i\n                        }\n                    } else {\n             \
    \           if max == oneCount {\n                            secondOneIndex =\
    \ i\n                        }\n                    }\n                } else\
    \ {\n                    if oneCount == 1 {\n                        if arr[i]\
    \ == 1 {\n                            if max == oneCount {\n                 \
    \               firstOneIndex = i\n                            }\n           \
    \             } else {\n                            if max == oneCount {\n   \
    \                             secondOneIndex = i\n                           \
    \ }\n                        }\n                    } else {\n               \
    \         if arr[i] == 1 {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp7r4qrhgv.swift:19:12: error: expected type\n    for i := 0; i <\
    \ len(arr); i++ {\n           ^\n            <#type#>\n/tmp/tmp7r4qrhgv.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(arr); i++\
    \ {\n           ^\n/tmp/tmp7r4qrhgv.swift:19:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(arr); i++ {\n           ^\n/tmp/tmp7r4qrhgv.swift:56:16:\
    \ error: expected type\n        for i := 0; i < len(arr); i++ {\n            \
    \   ^\n                <#type#>\n/tmp/tmp7r4qrhgv.swift:56:16: error: expected\
    \ 'in' after for-each pattern\n        for i := 0; i < len(arr); i++ {\n     \
    \          ^\n/tmp/tmp7r4qrhgv.swift:56:16: error: expected Sequence expression\
    \ for for-each loop\n        for i := 0; i < len(arr); i++ {\n               ^\n\
    /tmp/tmp7r4qrhgv.swift:98:16: error: expected type\n        for i := 0; i < len(arr);\
    \ i++ {\n               ^\n                <#type#>\n/tmp/tmp7r4qrhgv.swift:98:16:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(arr);\
    \ i++ {\n               ^\n/tmp/tmp7r4qrhgv.swift:98:16: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(arr); i++ {\n    \
    \           ^\n/tmp/tmp7r4qrhgv.swift:145:64: error: expected '}' at end of brace\
    \ statement\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\n\
    \                                                               ^\n/tmp/tmp7r4qrhgv.swift:121:28:\
    \ note: to match this opening '{'\n                    } else {\n            \
    \               ^\n/tmp/tmp7r4qrhgv.swift:145:64: error: expected '}' at end of\
    \ brace statement\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])\n                                                               ^\n/tmp/tmp7r4qrhgv.swift:110:24:\
    \ note: to match this opening '{'\n                } else {\n                \
    \       ^\n/tmp/tmp7r4qrhgv.swift:145:64: error: expected '}' at end of brace\
    \ statement\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\n\
    \                                                               ^\n/tmp/tmp7"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n  var result = arr\n  let reverse = arr.reverse()\n\
    \  for i in 0..<reverse.count {\n    if result[i] == 1 {\n      let j = reverse.index(of:\
    \ 1)!\n      let temp = result[j]\n      result[j] = result[i]\n      result[i]\
    \ = temp\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpw6eittt6.swift:14:21: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n  let reverse = arr.reverse()\n          \
    \      ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.isEmpty() {\n        return\
    \ arr\n    }\n\n    let numOfOnes = arr.map { Int($0 >> 0 & 1)}\n    let sortFunc\
    \ = { $0.compare(arr.last!) == .orderedAscending ? Int($0.bitPattern) : Int(arr.last!.bitPattern).compare($0.bitPattern)\
    \ == .orderedAscending ? $0 : arr.last! }\n\n    return numOfOnes.sorted(by: sortFunc)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpyx1qm7iy.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpyx1qm7iy.swift:18:20: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let sortFunc = { $0.compare(arr.last!) == .orderedAscending\
    \ ? Int($0.bitPattern) : Int(arr.last!.bitPattern).compare($0.bitPattern) == .orderedAscending\
    \ ? $0 : arr.last! }\n                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyx1qm7iy.swift:20:33: error: converting non-escaping value to '(Int, Int)\
    \ throws -> Bool' may allow it to escape\n    return numOfOnes.sorted(by: sortFunc)\n\
    \                                ^\n"
  stdout: ''
  timestamp: 1660053527
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = Array(repeating: 0, count:\
    \ arr.count)\n    if arr.count < 2 { return arr }\n    \n    var onesCount = 0\n\
    \    var decimalCount = 0\n    for v in arr {\n        switch v {\n        case\
    \ 0: onesCount++; decimalCount = 0; break\n        case 1: decimalCount++; break\n\
    \        case 2: decimalCount++; break\n        case 3: onesCount++; decimalCount\
    \ = 0; break\n        case 4: decimalCount++; break\n        case 5: onesCount++;\
    \ decimalCount = 0; break\n        case 6: decimalCount++; break\n        case\
    \ 7: onesCount++; decimalCount = 0; break\n        case 8: decimalCount++; break\n\
    \        case 9: onesCount++; decimalCount = 0; break\n        case 10: decimalCount++;\
    \ break\n        case 11: onesCount++; decimalCount = 0; break\n        case 12:\
    \ decimalCount++; break\n        case 13: onesCount++; decimalCount = 0; break\n\
    \        case 14: decimalCount++; break\n        case 15: onesCount++; decimalCount\
    \ = 0; break\n        case 16: decimalCount++; break\n        case 17: onesCount++;\
    \ decimalCount = 0; break\n        case 18: decimalCount++; break\n        case\
    \ 19: onesCount++; decimalCount = 0; break\n        case 20: decimalCount++; break\n\
    \        case 21: onesCount++; decimalCount = 0; break\n        case 22: decimalCount++;\
    \ break\n        case 23: onesCount++; decimalCount = 0; break\n        case 24:\
    \ decimalCount++; break\n        case 25: onesCount++; decimalCount = 0; break\n\
    \        case 26: decimalCount++; break\n        case 27: onesCount++; decimalCount\
    \ = 0; break\n        case 28: decimalCount++; break\n        case 29: onesCount++;\
    \ decimalCount = 0; break\n        case 30: decimalCount++; break\n        case\
    \ 31: onesCount++; decimalCount = 0; break\n        case 32: decimalCount++; break\n\
    \        case 33: onesCount++; decimalCount = 0; break\n        case 34: decimalCount++;\
    \ break\n        case 35: onesCount++; decimalCount = 0; break\n        case 36:\
    \ decimalCount++; break\n        case 37: onesCount++; decimalCount = 0; break\n\
    \        case 38: decimalCount++; break\n        case 39: onesCount++; decimalCount\
    \ = 0; break\n        case 40: decimalCount++; break\n        case 41: onesCount++;\
    \ decimalCount = 0; break\n        case 42: decimalCount++; break\n        case\
    \ 43: ones\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp4en88pvh.swift:86:64: error: expected '}' at end of brace statement\n\
    assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\n            \
    \                                                   ^\n/tmp/tmp4en88pvh.swift:18:18:\
    \ note: to match this opening '{'\n    for v in arr {\n                 ^\n/tmp/tmp4en88pvh.swift:86:64:\
    \ error: expected '}' at end of brace statement\nassert(sort_array(arr: [2, 4,\
    \ 8, 16, 32]) == [2, 4, 8, 16, 32])\n                                        \
    \                       ^\n/tmp/tmp4en88pvh.swift:12:38: note: to match this opening\
    \ '{'\nfunc sort_array(arr: [Int]) -> [Int] {\n                              \
    \       ^\n/tmp/tmp4en88pvh.swift:20:26: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        case 0: onesCount++; decimalCount = 0; break\n\
    \                         ^~\n/tmp/tmp4en88pvh.swift:21:29: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n        case 1: decimalCount++;\
    \ break\n                            ^~\n/tmp/tmp4en88pvh.swift:22:29: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        case 2: decimalCount++;\
    \ break\n                            ^~\n/tmp/tmp4en88pvh.swift:23:26: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        case 3: onesCount++;\
    \ decimalCount = 0; break\n                         ^~\n/tmp/tmp4en88pvh.swift:24:29:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        case\
    \ 4: decimalCount++; break\n                            ^~\n/tmp/tmp4en88pvh.swift:25:26:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        case\
    \ 5: onesCount++; decimalCount = 0; break\n                         ^~\n/tmp/tmp4en88pvh.swift:26:29:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        case\
    \ 6: decimalCount++; break\n                            ^~\n/tmp/tmp4en88pvh.swift:27:26:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        case\
    \ 7: onesCount++; decimalCount = 0; break\n                         ^~\n/tmp/tmp4en88pvh.swift:28:29:\
    \ error: cannot fi"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var len = 0\n    for el in arr {\n\
    \        len += 1\n    }\n    var sortedArr = [Int]()\n    sortedArr.append(arr[0])\n\
    \    for el in arr {\n        if len == 1 {\n            sortedArr.append(el)\n\
    \        } else {\n            if el & 1 == 1 {\n                sortedArr.append(arr[len-1])\n\
    \            }\n            sortedArr.append(el)\n        }\n        len += 1\n\
    \    }\n    return sortedArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00007ff0a047ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007ff0a0175561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00007ff0a0175286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00007ff0a017513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00007ff0a0174bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00007ff0a0722e83 <unavailable> + 188035

    6    tmpaxf_vtxn                        0x0000558f785802de <unavailable> + 8926

    7    tmpaxf_vtxn                        0x0000558f7857f564 <unavailable> + 5476

    8    libc.so.6                          0x00007ff09fc6b460 __libc_start_main +
    245

    9    tmpaxf_vtxn                        0x0000558f7857f239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var ones = [Int]()\n    var arrCopy\
    \ = arr[:]\n    for num in arrCopy {\n        if num >> 1 != 0 {\n           \
    \ ones.append(num)\n        }\n    }\n    ones.sort()\n    return ones\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpdt12vhv_.swift:14:23: error: expected expression in list of expressions\n\
    \    var arrCopy = arr[:]\n                      ^\n/tmp/tmpdt12vhv_.swift:14:24:\
    \ error: missing argument for parameter #1 in call\n    var arrCopy = arr[:]\n\
    \                       ^\n                       <#Int#>\nSwift.Array:16:23:\
    \ note: 'subscript(_:)' declared here\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted = [Int]()\n\n    guard\
    \ arr.count > 0 else { return sorted }\n\n    for x in arr {\n        if x ==\
    \ 0 {\n            continue\n        }\n        var i = 0\n        var count =\
    \ 0\n        while i < sorted.count {\n            if sorted[i] == 0 && (sorted[i]\
    \ & 1) == x {\n                count += 1\n            } else {\n            \
    \    break\n            }\n            i += 1\n        }\n        if count ==\
    \ sorted.count {\n            sorted.append(x)\n        } else {\n           \
    \ sorted.insert(x, at: count)\n        }\n    }\n\n    return sorted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpmreob_lr/tmpmreob_lr.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fd5ae139c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fd5ade30b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fd5ade30988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fd5ade2f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmreob_lr                        0x000055757ecf1704 <unavailable> + 5892

    5    libc.so.6                          0x00007fd5ad926460 __libc_start_main +
    245

    6    tmpmreob_lr                        0x000055757ecf12e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var oneCounts = [Int]()\n    var decimalCounts\
    \ = [Int]()\n    var tempValues: [Int] = []\n    for n in arr {\n        let count\
    \ = countOnes(n)\n        oneCounts.append(count)\n        decimalCounts.append(Int(n)\
    \ / count)\n    }\n    for n in oneCounts {\n        for m in decimalCounts {\n\
    \            if m < n {\n                tempValues.append(m)\n            } else\
    \ {\n                tempValues.append(n)\n            }\n        }\n    }\n \
    \   return tempValues\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp1cqjmrnj.swift:17:21: error: cannot find 'countOnes' in scope\n\
    \        let count = countOnes(n)\n                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sort() {\n        var tmp\
    \ = 0\n        switch $0 {\n        case 0\n            if tmp < $1 {\n      \
    \          return true\n            } else {\n                return false\n \
    \           }\n        case 1\n            if tmp < $2 {\n                return\
    \ true\n            } else {\n                return false\n            }\n  \
    \      case 2\n            if tmp < $3 {\n                return true\n      \
    \      } else {\n                return false\n            }\n        case 3\n\
    \            if tmp < $4 {\n                return true\n            } else {\n\
    \                return false\n            }\n        case 4\n            if tmp\
    \ < $5 {\n                return true\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp6xq9bowf.swift:16:15: error: expected ':' after 'case'\n      \
    \  case 0\n              ^\n/tmp/tmp6xq9bowf.swift:22:15: error: expected ':'\
    \ after 'case'\n        case 1\n              ^\n/tmp/tmp6xq9bowf.swift:28:15:\
    \ error: expected ':' after 'case'\n        case 2\n              ^\n/tmp/tmp6xq9bowf.swift:34:15:\
    \ error: expected ':' after 'case'\n        case 3\n              ^\n/tmp/tmp6xq9bowf.swift:40:15:\
    \ error: expected ':' after 'case'\n        case 4\n              ^\n/tmp/tmp6xq9bowf.swift:13:16:\
    \ error: cannot convert return expression of type '()' to return type '[Int]'\n\
    \    return arr.sort() {\n           ~~~~^~~~~~~~\n/tmp/tmp6xq9bowf.swift:13:23:\
    \ error: contextual closure type '(Int, Int) throws -> Bool' expects 2 arguments,\
    \ but 6 were used in closure body\n    return arr.sort() {\n                 \
    \     ^\n/tmp/tmp6xq9bowf.swift:15:16: note: anonymous closure parameter '$0'\
    \ is used here\n        switch $0 {\n               ^\n/tmp/tmp6xq9bowf.swift:17:22:\
    \ note: anonymous closure parameter '$1' is used here\n            if tmp < $1\
    \ {\n                     ^\n/tmp/tmp6xq9bowf.swift:23:22: note: anonymous closure\
    \ parameter '$2' is used here\n            if tmp < $2 {\n                   \
    \  ^\n/tmp/tmp6xq9bowf.swift:29:22: note: anonymous closure parameter '$3' is\
    \ used here\n            if tmp < $3 {\n                     ^\n/tmp/tmp6xq9bowf.swift:35:22:\
    \ note: anonymous closure parameter '$4' is used here\n            if tmp < $4\
    \ {\n                     ^\n/tmp/tmp6xq9bowf.swift:41:22: note: anonymous closure\
    \ parameter '$5' is used here\n            if tmp < $5 {\n                   \
    \  ^\n/tmp/tmp6xq9bowf.swift:13:16: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    return arr.sort() {\n           ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var ones = [Int]()\n    for x in arr\
    \ {\n        ones = append(ones, Int((bin(x)[1].count(\"1\")))) // append the\
    \ number of ones\n    }\n    \n    var compareInts = [Int]()\n    \n    for x\
    \ in ones {\n        for y in ones {\n            if x == y { continue } // skip\
    \ equal ones\n            \n            let z = Int(pow(y, 2) + (pow(Int(x), 2)\
    \ - pow(Int(y), 2)))\n            compareInts = append(compareInts, z) // append\
    \ the compared integers\n        }\n    }\n    \n    // sort by compared integers\n\
    \    compareInts = Array(compareInts).sorted() { $0 > $1 }\n    \n    var sortedArray\
    \ = [Int]()\n    for x in arr {\n        sortedArray = append(sortedArray, Int(pow(x,\
    \ 2)-pow(Int(compareInts.first!), 2)))\n    }\n    \n    return sortedArray\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpg2f_3p4q.swift:15:16: error: cannot find 'append' in scope\n  \
    \      ones = append(ones, Int((bin(x)[1].count(\"1\")))) // append the number\
    \ of ones\n               ^~~~~~\n/tmp/tmpg2f_3p4q.swift:15:34: error: cannot\
    \ find 'bin' in scope\n        ones = append(ones, Int((bin(x)[1].count(\"1\"\
    )))) // append the number of ones\n                                 ^~~\n/tmp/tmpg2f_3p4q.swift:24:25:\
    \ error: cannot find 'pow' in scope\n            let z = Int(pow(y, 2) + (pow(Int(x),\
    \ 2) - pow(Int(y), 2)))\n                        ^~~\n/tmp/tmpg2f_3p4q.swift:24:38:\
    \ error: cannot find 'pow' in scope\n            let z = Int(pow(y, 2) + (pow(Int(x),\
    \ 2) - pow(Int(y), 2)))\n                                     ^~~\n/tmp/tmpg2f_3p4q.swift:24:55:\
    \ error: cannot find 'pow' in scope\n            let z = Int(pow(y, 2) + (pow(Int(x),\
    \ 2) - pow(Int(y), 2)))\n                                                    \
    \  ^~~\n/tmp/tmpg2f_3p4q.swift:25:27: error: cannot find 'append' in scope\n \
    \           compareInts = append(compareInts, z) // append the compared integers\n\
    \                          ^~~~~~\n/tmp/tmpg2f_3p4q.swift:34:23: error: cannot\
    \ find 'append' in scope\n        sortedArray = append(sortedArray, Int(pow(x,\
    \ 2)-pow(Int(compareInts.first!), 2)))\n                      ^~~~~~\n/tmp/tmpg2f_3p4q.swift:34:47:\
    \ error: cannot find 'pow' in scope\n        sortedArray = append(sortedArray,\
    \ Int(pow(x, 2)-pow(Int(compareInts.first!), 2)))\n                          \
    \                    ^~~\n/tmp/tmpg2f_3p4q.swift:34:57: error: cannot find 'pow'\
    \ in scope\n        sortedArray = append(sortedArray, Int(pow(x, 2)-pow(Int(compareInts.first!),\
    \ 2)))\n                                                        ^~~\n"
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let len = arr.count\n    \n    if\
    \ len < 2 {\n        return arr\n    }\n    \n    var ans = Array(repeating: 0,\
    \ count: len)\n    \n    // Binary representation of integers\n    let bin = arr.map\
    \ { $0.pow.powInt(2).intValue }\n    \n    // Sort from least to most ones.\n\
    \    let firstIndex = bin.index(where: {$0 == 1})\n    let lastIndex = bin.index(where:\
    \ {$0 == 0})\n    for (i in 0 ..< lastIndex) {\n        let temp = bin[i]\n  \
    \      bin[i] = bin[firstIndex]\n        bin[firstIndex] = temp\n        \n  \
    \      let temp = ans[i]\n        ans[i] = ans[firstIndex]\n        ans[firstIndex]\
    \ = temp\n    }\n    \n    ans.reverse()\n    \n    return ans\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpcopvct2z.swift:27:12: error: expected ',' separator\n    for (i\
    \ in 0 ..< lastIndex) {\n           ^\n          ,\n/tmp/tmpcopvct2z.swift:27:12:\
    \ error: expected pattern\n    for (i in 0 ..< lastIndex) {\n           ^\n/tmp/tmpcopvct2z.swift:27:32:\
    \ error: expected 'in' after for-each pattern\n    for (i in 0 ..< lastIndex)\
    \ {\n                               ^\n/tmp/tmpcopvct2z.swift:27:32: error: expected\
    \ Sequence expression for for-each loop\n    for (i in 0 ..< lastIndex) {\n  \
    \                             ^\n/tmp/tmpcopvct2z.swift:22:28: error: value of\
    \ type 'Int' has no member 'pow'\n    let bin = arr.map { $0.pow.powInt(2).intValue\
    \ }\n                        ~~ ^~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sortedArray = [Int]()\n    if\
    \ arr.isEmpty { return sortedArray }\n    var biggestNumber = Int(0)\n    for\
    \ number in arr {\n        if number > biggestNumber { biggestNumber = number\
    \ }\n    }\n    sortedArray = Array(repeating: biggestNumber, count: arr.count)\n\
    \    for number in arr {\n        if number == 1 { sortedArray[arr.index(of: number)]\
    \ = number }\n    }\n    return sortedArray\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp7utytmzu.swift:21:42: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        if number == 1 { sortedArray[arr.index(of: number)] = number\
    \ }\n                                         ^\n/tmp/tmp7utytmzu.swift:21:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if number == 1 { sortedArray[arr.index(of: number)] = number\
    \ }\n                                         ^\n                            \
    \                               ?? <#default value#>\n/tmp/tmp7utytmzu.swift:21:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if number == 1 { sortedArray[arr.index(of: number)] = number\
    \ }\n                                         ^\n                            \
    \                              !\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    for number\
    \ in arr {\n        guard number > -1 else {\n            return result\n    \
    \    }\n        var count = 0\n        for bit in 1..<number {\n            guard\
    \ number & 1 == bit else {\n                count += 1\n            }\n      \
    \      number >>= 1\n        }\n        if count == 1 {\n            result.append(number)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp3q355lzh.swift:23:20: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n            number >>= 1\n          \
    \  ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    func sortByOnes(arr: [Int], start:\
    \ Int, end: Int) -> [Int] {\n        var result = [Int]()\n        if start <\
    \ end {\n            for i in start..end {\n                if arr[i] == 0 {\n\
    \                    var leftIndex = i\n                    for j in i..end {\n\
    \                        if arr[j] == 1 {\n                            leftIndex\
    \ = j\n                            break\n                        }\n        \
    \            }\n                    var rightIndex = end\n                   \
    \ for j in start..leftIndex {\n                        if arr[j] == 0 {\n    \
    \                        rightIndex = j\n                            break\n \
    \                       }\n                    }\n                    result.insert(arr[i],\
    \ at: i)\n                    result.insert(arr[leftIndex], at: i)\n         \
    \           result.insert(arr[rightIndex], at: i)\n                    result.insert(arr[i],\
    \ at: rightIndex)\n                }\n            }\n        }\n        return\
    \ result\n    }\n\n    func sortByDecNum(arr: [Int], start: Int, end: Int) ->\
    \ [Int] {\n        var result = [Int]()\n        if start < end {\n          \
    \  for i in start..end {\n                if arr[i] == 0 {\n                 \
    \   var leftIndex = i\n                    for j in i..end {\n               \
    \         if arr[j] == 1 {\n                            leftIndex = j\n      \
    \                      break\n                        }\n                    }\n\
    \                    var rightIndex = end\n                    for j in start..leftIndex\
    \ {\n                        if arr[j] == 0 {\n                            rightIndex\
    \ = j\n                            break\n                        }\n        \
    \            }\n                    let decNum = arr[i] * 10 + (arr[leftIndex]\
    \ - 1) * 2 + arr[rightIndex] - 1\n                    result.insert(decNum, at:\
    \ i)\n                }\n            }\n        }\n        return result\n   \
    \ }\n    return sortByOnes(arr: arr, start: 0, end: arr.count).sorted()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmph1zrlqco.swift:16:27: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n            for i in start..end {\n                   \
    \       ^~\n                          ...\n/tmp/tmph1zrlqco.swift:45:27: error:\
    \ cannot find operator '..' in scope; did you mean '...'?\n            for i in\
    \ start..end {\n                          ^~\n                          ...\n\
    /tmp/tmph1zrlqco.swift:19:31: error: cannot find operator '..' in scope; did you\
    \ mean '...'?\n                    for j in i..end {\n                       \
    \       ^~\n                              ...\n/tmp/tmph1zrlqco.swift:26:35: error:\
    \ cannot find operator '..' in scope; did you mean '...'?\n                  \
    \  for j in start..leftIndex {\n                                  ^~\n       \
    \                           ...\n/tmp/tmph1zrlqco.swift:48:31: error: cannot find\
    \ operator '..' in scope; did you mean '...'?\n                    for j in i..end\
    \ {\n                              ^~\n                              ...\n/tmp/tmph1zrlqco.swift:55:35:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n           \
    \         for j in start..leftIndex {\n                                  ^~\n\
    \                                  ...\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.count == 0 {\n        return\
    \ []\n    }\n    \n    var ones: [Int] = []\n    var zeros: [Int] = []\n    \n\
    \    for i in arr {\n        if i != 0 {\n            ones.append(i)\n       \
    \ } else {\n            zeros.append(i)\n        }\n    }\n    \n    return sort_array2(ones,\
    \ zeros)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpximknj4a.swift:28:12: error: cannot find 'sort_array2' in scope\n\
    \    return sort_array2(ones, zeros)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sort(arr, arr.map { (val) ->\
    \ Int in\n        return val.toBinary(radix: 2).count().toInt()\n    })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpl8bdkzjo.swift:13:12: error: cannot find 'sort' in scope\n    return\
    \ sort(arr, arr.map { (val) -> Int in\n           ^~~~\n/tmp/tmpl8bdkzjo.swift:14:20:\
    \ error: value of type 'Int' has no member 'toBinary'\n        return val.toBinary(radix:\
    \ 2).count().toInt()\n               ~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    // sort on number of 1's in\
    \ binary representation\n    var binary = []\n    \n    for i in 0..<arr.count\
    \ {\n        let bin = arr[i].binary()\n        let count = bin.count / 2\n  \
    \      binary = append(binary, Array(count: count, repeatedValue: 0))\n      \
    \  for j in 0..<count {\n            binary[j / 2] = binary[j / 2] + Int(bin[count-j])\n\
    \        }\n    }\n\n    \n    // sort on dec. value of binary\n    return binary.sorted(by:\
    \ {\n        if $0 == 0 {\n            return true\n        }\n        if $1 ==\
    \ 0 {\n            return false\n        }\n        \n        var remainder: Int\
    \ = 0\n        var base: Int = 0\n        \n        while $0 > 0 {\n         \
    \   base = 10\n            remainder = $0 % base\n            $0 = ($0 - remainder)\
    \ / base\n        }\n        \n        return $0 < $1 \n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpj2twlsex.swift:15:18: error: empty collection literal requires\
    \ an explicit type\n    var binary = []\n                 ^~\n/tmp/tmpj2twlsex.swift:18:26:\
    \ error: value of type 'Int' has no member 'binary'\n        let bin = arr[i].binary()\n\
    \                  ~~~~~~ ^~~~~~\n/tmp/tmpj2twlsex.swift:20:18: error: cannot\
    \ find 'append' in scope\n        binary = append(binary, Array(count: count,\
    \ repeatedValue: 0))\n                 ^~~~~~\n/tmp/tmpj2twlsex.swift:20:68: error:\
    \ extra argument 'repeatedValue' in call\n        binary = append(binary, Array(count:\
    \ count, repeatedValue: 0))\n                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmpj2twlsex.swift:28:19: error: cannot convert return expression of type\
    \ '[Any]' to return type '[Int]'\n    return binary.sorted(by: {\n           \
    \       ^\n/tmp/tmpj2twlsex.swift:28:19: note: arguments to generic parameter\
    \ 'Element' ('Any' and 'Int') are expected to be equal\n    return binary.sorted(by:\
    \ {\n                  ^\n/tmp/tmpj2twlsex.swift:29:12: error: cannot convert\
    \ value of type 'Any' to expected argument type 'Int'\n        if $0 == 0 {\n\
    \           ^\n              as! Int\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n\t\n\treturn arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmp3gc5xfpy/tmp3gc5xfpy.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f2cb4087c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f2cb3d7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f2cb3d7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f2cb3d7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3gc5xfpy                        0x000055fb03d223e4 <unavailable> + 5092

    5    libc.so.6                          0x00007f2cb3874460 __libc_start_main +
    245

    6    tmp3gc5xfpy                        0x000055fb03d21fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sortedArr = arr\n    for i in\
    \ 0..<sortedArr.count {\n        for j in 1..<sortedArr.count {\n            if\
    \ sortedArr[j-1] > sortedArr[j] {\n                let tmp = sortedArr[j-1]\n\
    \                sortedArr[j-1] = sortedArr[j]\n                sortedArr[j] =\
    \ tmp\n            }\n        }\n    }\n    return sortedArr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpp_6ntznw/tmpp_6ntznw.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f13f3a6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f13f3765b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f13f3765988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f13f37647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp_6ntznw                        0x000055c2753d4674 <unavailable> + 5748

    5    libc.so.6                          0x00007f13f325b460 __libc_start_main +
    245

    6    tmpp_6ntznw                        0x000055c2753d4259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted: [Int] = []\n    sorted.reserveCapacity(arr.count)\n\
    \n    // sort by number of ones in their binary representation\n    let sortedBin\
    \ = arr.map {\n        let binary = $0.binary(withWidth: 8)\n        return binary.count\n\
    \    }.sorted()\n\n    // sort by decimal value\n    for index in 0..<arr.count\
    \ {\n        if sortedBin[index] == 1 {\n            sorted.append(arr[index])\n\
    \        }\n    }\n\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp43b36kwk.swift:18:25: error: value of type 'Int' has no member\
    \ 'binary'\n        let binary = $0.binary(withWidth: 8)\n                   \
    \  ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n\tvar result : [Int] = []\n\n\tfor _i\
    \ in arr {\n\t\tswitch _i {\n\t\tcase 0:\n\t\t\tresult.insert(result.count, -1)\n\
    \t\tcase 1:\n\t\t\tresult.insert(result.count, -1)\n\t\tcase 2:\n\t\t\tresult.insert(result.count,\
    \ -2)\n\t\tcase 3:\n\t\t\tresult.insert(result.count, -1)\n\t\tdefault:\n\t\t\t\
    result.insert(result.count, -1)\n\t\t}\n\t}\n\n\tresult.sort({\n\t\t$0 > $1\n\t\
    })\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmps5i5wfw7.swift:18:11: error: no exact matches in call to instance\
    \ method 'insert'\n                        result.insert(result.count, -1)\n \
    \                              ^\nSwift.Array:11:37: note: incorrect labels for\
    \ candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating\
    \ func insert(_ newElement: __owned Element, at i: Int)\n                    \
    \                ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels\
    \ for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating\
    \ func insert(_ newElement: __owned Self.Element, at i: Self.Index)\n        \
    \                            ^\n/tmp/tmps5i5wfw7.swift:20:11: error: no exact\
    \ matches in call to instance method 'insert'\n                        result.insert(result.count,\
    \ -1)\n                               ^\nSwift.Array:11:37: note: incorrect labels\
    \ for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating\
    \ func insert(_ newElement: __owned Element, at i: Int)\n                    \
    \                ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels\
    \ for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating\
    \ func insert(_ newElement: __owned Self.Element, at i: Self.Index)\n        \
    \                            ^\n/tmp/tmps5i5wfw7.swift:22:11: error: no exact\
    \ matches in call to instance method 'insert'\n                        result.insert(result.count,\
    \ -2)\n                               ^\nSwift.Array:11:37: note: incorrect labels\
    \ for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating\
    \ func insert(_ newElement: __owned Element, at i: Int)\n                    \
    \                ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels\
    \ for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating\
    \ func insert(_ newElement: __owned Self.Element, at i: Self.Index)\n        \
    \                            ^\n/tmp/tmps5i5wfw7.swift:24:11: error: no exact\
    \ matches in call to instance method 'insert'\n                       "
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return arr\n\
    \    }\n    var oneCounts = [Int]()\n    var decimalCounts = [Int]()\n    var\
    \ maxDecimalCount = arr.count\n    for i in arr {\n        if i <= 0 {\n     \
    \       continue\n        }\n        let binStr = strconv.FormatInt(int64(i),\
    \ 2)\n        var oneCount = 0\n        var decimalCount = 0\n        for _, ch\
    \ in binStr.characters {\n            if ch == '1' {\n                oneCount++\n\
    \            }\n        }\n        if oneCount > 0 {\n            oneCounts.append(oneCount)\n\
    \            decimalCount += oneCount - 1\n        } else {\n            decimalCounts.append(decimalCount)\n\
    \        }\n    }\n    if maxDecimalCount > decimalCounts.max() {\n        return\
    \ arr\n    }\n    var sortedArr = [Int]()\n    for decimalCount in decimalCounts\
    \ {\n        sortedArr = sortedArr.sorted() { $0 < $1 }\n    }\n    for oneCount\
    \ in oneCounts {\n        sortedArr = sortedArr.sorted() { $0 < $1 }\n    }\n\
    \    return sortedArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmplbkdwkk9.swift:26:14: error: expected 'in' after for-each pattern\n\
    \        for _, ch in binStr.characters {\n             ^\n/tmp/tmplbkdwkk9.swift:26:14:\
    \ error: expected Sequence expression for for-each loop\n        for _, ch in\
    \ binStr.characters {\n             ^\n/tmp/tmplbkdwkk9.swift:27:22: error: single-quoted\
    \ string literal found, use '\"'\n            if ch == '1' {\n               \
    \      ^~~\n                     \"1\"\n/tmp/tmplbkdwkk9.swift:23:22: error: cannot\
    \ find 'strconv' in scope\n        let binStr = strconv.FormatInt(int64(i), 2)\n\
    \                     ^~~~~~~\n/tmp/tmplbkdwkk9.swift:23:40: error: cannot find\
    \ 'int64' in scope\n        let binStr = strconv.FormatInt(int64(i), 2)\n    \
    \                                   ^~~~~\n/tmp/tmplbkdwkk9.swift:38:40: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \   if maxDecimalCount > decimalCounts.max() {\n                             \
    \          ^\n/tmp/tmplbkdwkk9.swift:38:40: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    if maxDecimalCount > decimalCounts.max()\
    \ {\n                                       ^\n                              \
    \               ?? <#default value#>\n/tmp/tmplbkdwkk9.swift:38:40: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    if maxDecimalCount\
    \ > decimalCounts.max() {\n                                       ^\n        \
    \                                    !\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n  var result = ArraySlice<Int>(arr)\n\
    \  result.sort(&compare)\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpq5oqzo__.swift:14:16: error: cannot find 'compare' in scope\n \
    \ result.sort(&compare)\n               ^~~~~~~\n/tmp/tmpq5oqzo__.swift:14:15:\
    \ error: missing argument label 'by:' in call\n  result.sort(&compare)\n     \
    \         ^\n              by: \n/tmp/tmpq5oqzo__.swift:14:15: error: cannot convert\
    \ value of type '_' to expected argument type '(Int, Int) throws -> Bool'\n  result.sort(&compare)\n\
    \              ^\n/tmp/tmpq5oqzo__.swift:15:10: error: cannot convert return expression\
    \ of type 'ArraySlice<Int>' to return type '[Int]'\n  return result\n        \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let len = arr.count\n    let len =\
    \ arr.count\n    var temp = [Int]()\n    var tempCount = 0\n    var maxValue =\
    \ -1\n    for i in 0..<len {\n        if arr[i] > maxValue {\n            maxValue\
    \ = arr[i]\n        }\n    }\n    for i in 0..<len {\n        if arr[i] != maxValue\
    \ {\n            temp.append(arr[i])\n            tempCount += 1\n        }\n\
    \    }\n    for j in 0..<len - 1 {\n        if tempCount > maxValue {\n      \
    \      temp.insert(maxValue, at: j)\n            tempCount = tempCount + maxValue\n\
    \            maxValue = arr[j]\n        } else {\n            temp.insert(temp[tempCount\
    \ - 1], at: j)\n            tempCount -= 1\n        }\n    }\n    return temp\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpmr13suk0.swift:14:9: error: invalid redeclaration of 'len'\n  \
    \  let len = arr.count\n        ^\n/tmp/tmpmr13suk0.swift:13:9: note: 'len' previously\
    \ declared here\n    let len = arr.count\n        ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var ones = make([]uint, 0)\n    var\
    \ decimals = make([]int, 0)\n    for i in arr {\n        if i >> uint(len(ones))\
    \ != 1 {\n            ones = append(ones, 0)\n        }\n        ones[len(ones)-1]\
    \ ^= 1\n        decimals = append(decimals, i)\n    }\n    quicksort(&ones, 0,\
    \ len(ones)-1)\n    quicksort(&decimals, 0, len(decimals)-1)\n    var result =\
    \ make([]int, 0)\n    for i := 0; i < len(ones); i++ {\n        if decimals[i]\
    \ != 0 {\n            result = append(result, decimals[i])\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpoevuirvb.swift:13:23: error: expected ',' separator\n    var ones\
    \ = make([]uint, 0)\n                      ^\n                      ,\n/tmp/tmpoevuirvb.swift:14:27:\
    \ error: expected ',' separator\n    var decimals = make([]int, 0)\n         \
    \                 ^\n                          ,\n/tmp/tmpoevuirvb.swift:24:25:\
    \ error: expected ',' separator\n    var result = make([]int, 0)\n           \
    \             ^\n                        ,\n/tmp/tmpoevuirvb.swift:25:12: error:\
    \ expected type\n    for i := 0; i < len(ones); i++ {\n           ^\n        \
    \    <#type#>\n/tmp/tmpoevuirvb.swift:25:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(ones); i++ {\n           ^\n/tmp/tmpoevuirvb.swift:25:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(ones);\
    \ i++ {\n           ^\n/tmp/tmpoevuirvb.swift:13:16: error: cannot find 'make'\
    \ in scope\n    var ones = make([]uint, 0)\n               ^~~~\n/tmp/tmpoevuirvb.swift:13:23:\
    \ error: cannot find 'uint' in scope\n    var ones = make([]uint, 0)\n       \
    \               ^~~~\n/tmp/tmpoevuirvb.swift:14:20: error: cannot find 'make'\
    \ in scope\n    var decimals = make([]int, 0)\n                   ^~~~\n/tmp/tmpoevuirvb.swift:14:27:\
    \ error: cannot find 'int' in scope\n    var decimals = make([]int, 0)\n     \
    \                     ^~~\n/tmp/tmpoevuirvb.swift:16:17: error: cannot find 'uint'\
    \ in scope\n        if i >> uint(len(ones)) != 1 {\n                ^~~~\n/tmp/tmpoevuirvb.swift:16:22:\
    \ error: cannot find 'len' in scope\n        if i >> uint(len(ones)) != 1 {\n\
    \                     ^~~\n/tmp/tmpoevuirvb.swift:17:20: error: cannot find 'append'\
    \ in scope\n            ones = append(ones, 0)\n                   ^~~~~~\n/tmp/tmpoevuirvb.swift:19:14:\
    \ error: cannot find 'len' in scope\n        ones[len(ones)-1] ^= 1\n        \
    \     ^~~\n/tmp/tmpoevuirvb.swift:20:20: error: cannot find 'append' in scope\n\
    \        decimals = append(decimals, i)\n                   ^~~~~~\n/tmp/tmpoevuirvb.swift:22:5:\
    \ error: cannot find 'quicksort' in scope\n    quicksort(&ones, 0, len(ones)-1)\n\
    \    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = Array(0..<arr.count)\n\
    \    var ones = arr.filter { $0 == 1 }\n    ones = ones + [Int]()\n    for idx\
    \ in 0..<arr.count {\n        if idx == 0 {\n            result[idx] = arr[idx]\n\
    \            continue\n        }\n        if arr[idx / 2] != 0 && ones[idx / 2]\
    \ > ones[idx] {\n            result[idx] = arr[idx / 2]\n            arr[idx /\
    \ 2] = arr[idx]\n            arr[idx] = 0\n        } else {\n            result[idx]\
    \ = arr[idx]\n            arr[idx / 2] = arr[idx]\n            arr[idx] = 0\n\
    \        }\n    }\n    return result.sort(<)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp6fxdbr4u.swift:23:16: error: cannot assign through subscript: 'arr'\
    \ is a 'let' constant\n            arr[idx / 2] = arr[idx]\n            ~~~^\n\
    /tmp/tmp6fxdbr4u.swift:24:16: error: cannot assign through subscript: 'arr' is\
    \ a 'let' constant\n            arr[idx] = 0\n            ~~~^\n/tmp/tmp6fxdbr4u.swift:27:16:\
    \ error: cannot assign through subscript: 'arr' is a 'let' constant\n        \
    \    arr[idx / 2] = arr[idx]\n            ~~~^\n/tmp/tmp6fxdbr4u.swift:28:16:\
    \ error: cannot assign through subscript: 'arr' is a 'let' constant\n        \
    \    arr[idx] = 0\n            ~~~^\n/tmp/tmp6fxdbr4u.swift:31:24: error: missing\
    \ argument label 'by:' in call\n    return result.sort(<)\n                  \
    \     ^\n                       by: \n/tmp/tmp6fxdbr4u.swift:31:19: error: cannot\
    \ convert return expression of type '()' to return type '[Int]'\n    return result.sort(<)\n\
    \           ~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var swapped = true\n    var sorted:\
    \ Int?\n\n    while swapped {\n        swapped = false\n        var i = 0\n  \
    \      var j = arr.count - 1\n\n        while i < j {\n            if arr[i] >\
    \ arr[j] {\n                swap(&arr[i], &arr[j])\n                swapped =\
    \ true\n            }\n\n            i += 1\n            j -= 1\n        }\n \
    \   }\n\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp4h7it97s.swift:23:22: error: cannot pass immutable value as inout\
    \ argument: 'arr' is a 'let' constant\n                swap(&arr[i], &arr[j])\n\
    \                     ^~~~\n/tmp/tmp4h7it97s.swift:23:31: error: cannot pass immutable\
    \ value as inout argument: 'arr' is a 'let' constant\n                swap(&arr[i],\
    \ &arr[j])\n                              ^~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let ones = arr.filter{$0.isMultiple(of:\
    \ 1)}.sorted{$0.isMultiple(of: 2)}\n    let decOnes = arr.filter{$0.isMultiple(of:\
    \ 1)}.sorted{$0.isMultiple(of: 10)}\n    return ones + decOnes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpzf2d4gur.swift:13:55: error: contextual closure type '(Int, Int)\
    \ throws -> Bool' expects 2 arguments, but 1 was used in closure body\n    let\
    \ ones = arr.filter{$0.isMultiple(of: 1)}.sorted{$0.isMultiple(of: 2)}\n     \
    \                                                 ^\n/tmp/tmpzf2d4gur.swift:14:58:\
    \ error: contextual closure type '(Int, Int) throws -> Bool' expects 2 arguments,\
    \ but 1 was used in closure body\n    let decOnes = arr.filter{$0.isMultiple(of:\
    \ 1)}.sorted{$0.isMultiple(of: 10)}\n                                        \
    \                 ^\n/tmp/tmpzf2d4gur.swift:15:17: error: cannot convert return\
    \ expression of type 'String' to return type '[Int]'\n    return ones + decOnes\n\
    \           ~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // Add base case\n    if arr.isEmpty()\
    \ {\n        return arr\n    }\n\n    // Create result array and put the first\
    \ element there\n    var result = [Int]()\n    result.append(arr[0])\n\n    //\
    \ Iterate over the rest of the array\n    for index in range(1, arr.count) {\n\
    \        // Sum binary representation of current element\n        let sumBits\
    \ = arr[index].bitCount()\n\n        // Convert to decimal\n        let numDecimal\
    \ = sumBits / 2\n\n        // Put the element where its binary representation\
    \ is smaller\n        let index = arr.index(of: numDecimal)\n        arr[index]\
    \ = arr[index]\n        arr.remove(at: index)\n\n        result.append(numDecimal)\n\
    \    }\n\n    // Reverse the array\n    arr.reverse()\n\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp0lupneii.swift:14:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if arr.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp0lupneii.swift:23:18: error: cannot find 'range' in scope\n    for\
    \ index in range(1, arr.count) {\n                 ^~~~~\n/tmp/tmp0lupneii.swift:39:9:\
    \ error: cannot use mutating member on immutable value: 'arr' is a 'let' constant\n\
    \    arr.reverse()\n    ~~~ ^\n/tmp/tmp0lupneii.swift:25:34: error: reference\
    \ to member 'bitCount' cannot be resolved without a contextual type\n        let\
    \ sumBits = arr[index].bitCount()\n                                 ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted().sorted { $0 ==\
    \ $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5,\
    \ 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp5hihqekl/tmp5hihqekl.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc3ab305c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc3aaffcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc3aaffc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc3aaffb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5hihqekl                        0x0000556691422504 <unavailable> + 5380

    5    libc.so.6                          0x00007fc3aaaf2460 __libc_start_main +
    245

    6    tmp5hihqekl                        0x00005566914220e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sorted(arr)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmp52c6lu5g.swift:13:12: error: cannot find 'sorted' in scope\n  \
    \  return sorted(arr)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n\n    var\
    \ result = [Int](repeating: 0, count: arr.count)\n    var sorted = [Int](repeating:\
    \ 0, count: arr.count)\n\n    while i < arr.count {\n        var numOnes = binary(arr[i])\n\
    \        sorted[j] = numOnes\n        for j in (0..<numOnes).reversed() {\n  \
    \          result[i++] = arr[j]\n        }\n    }\n    for i in (0..<sorted).reversed()\
    \ {\n        result[i++] = sorted[i]\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpdii0v3qc.swift:20:23: error: cannot find 'binary' in scope\n  \
    \      var numOnes = binary(arr[i])\n                      ^~~~~~\n/tmp/tmpdii0v3qc.swift:26:19:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    for i in (0..<sorted).reversed() {\n                  ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted() { $0 < $1 }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpo_7_parp/tmpo_7_parp.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f2ad66bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f2ad63b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f2ad63b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f2ad63b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo_7_parp                        0x00005601c5fa9454 <unavailable> + 5204

    5    libc.so.6                          0x00007f2ad5eac460 __libc_start_main +
    245

    6    tmpo_7_parp                        0x00005601c5fa9039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n\
    \    }\n\n    // Compute ones\n    var ones = 0\n    for val in arr {\n      \
    \  if val > 0 {\n            ones++\n        }\n    }\n\n    // Compute binary\
    \ representation of numbers\n    var binary = 0\n    for val in arr {\n      \
    \  if val > 0 {\n            binary = binary | (1 << val)\n        }\n    }\n\n\
    \    // Compute decimal value of numbers\n    var decimal = binary.scanLocations({\
    \ $0[Int($0)] })\n        .map { Int($0.last!) }\n\n    // Sort according to ones\n\
    \    if ones > 0 {\n        decimal = decimal.sorted()\n        decimal = decimal.sorted().reversed()\n\
    \    }\n\n    // Sort according to decimal\n    decimal = decimal.sorted()\n \
    \   return decimal\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp_y00d58a.swift:21:17: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            ones++\n                ^~\n/tmp/tmp_y00d58a.swift:34:26:\
    \ error: value of type 'Int' has no member 'scanLocations'\n    var decimal =\
    \ binary.scanLocations({ $0[Int($0)] })\n                  ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp_y00d58a.swift:34:45: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n    var decimal = binary.scanLocations({ $0[Int($0)]\
    \ })\n                                            ^\n/tmp/tmp_y00d58a.swift:34:45:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    var decimal = binary.scanLocations({ $0[Int($0)] })\n           \
    \                                 ^\n                                        \
    \            ?? <#default value#>\n/tmp/tmp_y00d58a.swift:34:45: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    var decimal\
    \ = binary.scanLocations({ $0[Int($0)] })\n                                  \
    \          ^\n                                                   !\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort()\n    var i = 0\n    var\
    \ len = arr.count\n    while i < len {\n        if arr[i] == 0 {\n           \
    \ arr.removeAtIndex(i)\n            len -= 1\n        } else {\n            i\
    \ += 1\n        }\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp9qlh8hvt.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n/tmp/tmp9qlh8hvt.swift:18:17:\
    \ error: value of type '[Int]' has no member 'removeAtIndex'\n            arr.removeAtIndex(i)\n\
    \            ~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n  arr.sort { $0.bit_count() < $1.bit_count()\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3,\
    \ 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4,\
    \ -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\n\
    assert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp8mscl6fy.swift:13:7: error: cannot convert return expression of\
    \ type '()' to return type '[Int]'\n  arr.sort { $0.bit_count() < $1.bit_count()\
    \ }\n  ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8mscl6fy.swift:13:17:\
    \ error: value of type 'Int' has no member 'bit_count'\n  arr.sort { $0.bit_count()\
    \ < $1.bit_count() }\n             ~~ ^~~~~~~~~\n/tmp/tmp8mscl6fy.swift:13:34:\
    \ error: value of type 'Int' has no member 'bit_count'\n  arr.sort { $0.bit_count()\
    \ < $1.bit_count() }\n                              ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let n = arr.count\n    let ones =\
    \ arr.filter { $0 > 0 }\n    let zeros = arr.filter { $0 < 0 }\n    let zeroLengths\
    \ = zeros.map { $0.count }\n    guard zeroLengths.count == n else { return arr\
    \ }\n    guard n > 0 else { return arr }\n    var res = [Int]()\n    var cur =\
    \ 0\n    var i = 0\n    var k = 0\n    while i < n {\n        let zeros = zeros.subarrayWithRange(Range(start:\
    \ i, end: n))\n        k += zeros.count\n        i += zeros.count\n        let\
    \ ones = ones.subarrayWithRange(Range(start: i, end: n))\n        let onesCount\
    \ = ones.length\n        if onesCount > 0 {\n            for j in 0 ..< onesCount\
    \ {\n                let one = ones[j]\n                let left = 0\n       \
    \         let right = 0\n                while left < n {\n                  \
    \  let left = left + k\n                    let right = right + k\n          \
    \          if arr[left] == one {\n                        k += 1\n           \
    \             cur += 1\n                    }\n                    left += 1\n\
    \                }\n                let right = 0\n                let left =\
    \ 0\n                while right < n {\n                    let right = right\
    \ + k\n                    let left = left + k\n                    if arr[right]\
    \ == one {\n                        k += 1\n                        cur += 1\n\
    \                    }\n                    right += 1\n                }\n  \
    \              if cur > onesCount {\n                    k -= (cur - onesCount)\n\
    \                    res += [one]\n                    cur = 0\n             \
    \   }\n            }\n        } else {\n            let left = 0\n           \
    \ let right = 0\n            while left < n {\n                let left = left\
    \ + k\n                let right = right + k\n                if arr[left] ==\
    \ 0 {\n                    k += 1\n                    cur += 1\n            \
    \    }\n                left += 1\n            }\n            let right = 0\n\
    \            let left = 0\n            while right < n {\n                let\
    \ right = right + k\n                let left = left + k\n                if arr[right]\
    \ == 0 {\n                    k += 1\n                    cur += 1\n         \
    \       }\n                right += 1\n            }\n            if cur > 0 {\n\
    \                k -= (cur - 1)\n                res += [zero]\n             \
    \   cur = 0\n            }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmp0r26aer0.swift:16:38: error: value of type 'Int' has no member\
    \ 'count'\n    let zeroLengths = zeros.map { $0.count }\n                    \
    \              ~~ ^~~~~\n/tmp/tmp0r26aer0.swift:24:27: error: value of type '[Int]'\
    \ has no member 'subarrayWithRange'\n        let zeros = zeros.subarrayWithRange(Range(start:\
    \ i, end: n))\n                    ~~~~~ ^~~~~~~~~~~~~~~~~\n/tmp/tmp0r26aer0.swift:24:66:\
    \ error: extra argument 'end' in call\n        let zeros = zeros.subarrayWithRange(Range(start:\
    \ i, end: n))\n                                                 ~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmp0r26aer0.swift:24:58: error: cannot convert value of type 'Int' to expected\
    \ argument type 'ClosedRange<Bound>'\n        let zeros = zeros.subarrayWithRange(Range(start:\
    \ i, end: n))\n                                                         ^\n/tmp/tmp0r26aer0.swift:24:45:\
    \ error: generic parameter 'Bound' could not be inferred\n        let zeros =\
    \ zeros.subarrayWithRange(Range(start: i, end: n))\n                         \
    \                   ^\n/tmp/tmp0r26aer0.swift:24:45: note: explicitly specify\
    \ the generic arguments to fix this issue\n        let zeros = zeros.subarrayWithRange(Range(start:\
    \ i, end: n))\n                                            ^\n               \
    \                                  <<#Bound: Comparable#>>\n/tmp/tmp0r26aer0.swift:27:25:\
    \ error: value of type '[Int]' has no member 'subarrayWithRange'\n        let\
    \ ones = ones.subarrayWithRange(Range(start: i, end: n))\n                   ~~~~\
    \ ^~~~~~~~~~~~~~~~~\n/tmp/tmp0r26aer0.swift:27:43: error: generic parameter 'Bound'\
    \ could not be inferred\n        let ones = ones.subarrayWithRange(Range(start:\
    \ i, end: n))\n                                          ^\n/tmp/tmp0r26aer0.swift:27:43:\
    \ note: explicitly specify the generic arguments to fix this issue\n        let\
    \ ones = ones.subarrayWithRange(Range(start: i, end: n))\n                   \
    \                       ^\n                                               <<#Bound:\
    \ Comparable#>>\n/tmp/tmp0r26aer0.swift:27:64: error: extra argument 'end' in\
    \ call\n "
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // return sorted(arr).\n    return\
    \ arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5,\
    \ 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpchxhd_lu/tmpchxhd_lu.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f84c5a87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f84c577eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f84c577e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f84c577d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchxhd_lu                        0x000055a926f293e4 <unavailable> + 5092

    5    libc.so.6                          0x00007f84c5274460 __libc_start_main +
    245

    6    tmpchxhd_lu                        0x000055a926f28fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let len = arr.count\n    if arr.count\
    \ > 0 {\n        arr.sort {\n            let ones = Int(bitPattern: 1 << $0)\n\
    \            if $0 > ones {\n                return false\n            } else\
    \ if ones > $0 {\n                return true\n            } else {\n        \
    \        return $0 < ones\n            }\n        }\n    }\n    return arr\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpfzwh8198.swift:15:13: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n        arr.sort {\n        ~~~ ^\n/tmp/tmpfzwh8198.swift:15:18:\
    \ error: contextual closure type '(Int, Int) throws -> Bool' expects 2 arguments,\
    \ but 1 was used in closure body\n        arr.sort {\n                 ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted{ $0 == $1 }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpnuiiugc2/tmpnuiiugc2.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f31d47b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f31d44aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f31d44ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f31d44ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnuiiugc2                        0x000055c9e71f0454 <unavailable> + 5204

    5    libc.so.6                          0x00007f31d3fa4460 __libc_start_main +
    245

    6    tmpnuiiugc2                        0x000055c9e71f0039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    for index, _ in enumerate(arr) {\n\
    \        arr[index] = sortIndex(arr[index])\n    }\n    return arr\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpj1qu9r2o.swift:13:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ in enumerate(arr) {\n             ^\n/tmp/tmpj1qu9r2o.swift:13:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, _ in enumerate(arr)\
    \ {\n             ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n  var res = Array(repeating: 0, count:\
    \ arr.count)\n\n  for i in 0 ..< arr.count {\n    let binary = arr[i].binary.countBits(startingAt:\
    \ 0)\n    let decimal = arr[i].decimal\n\n    if binary < decimal {\n      res[i]\
    \ = arr[i]\n    } else {\n      res[i] = Int(truncating: arr[i] / Int(pow(2.0,\
    \ Double(binary))))\n    }\n  }\n\n  return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpiyckb9yr.swift:16:25: error: value of type 'Int' has no member\
    \ 'binary'\n    let binary = arr[i].binary.countBits(startingAt: 0)\n        \
    \         ~~~~~~ ^~~~~~\n/tmp/tmpiyckb9yr.swift:17:26: error: value of type 'Int'\
    \ has no member 'decimal'\n    let decimal = arr[i].decimal\n                \
    \  ~~~~~~ ^~~~~~~\n/tmp/tmpiyckb9yr.swift:22:45: error: cannot find 'pow' in scope\n\
    \      res[i] = Int(truncating: arr[i] / Int(pow(2.0, Double(binary))))\n    \
    \                                        ^~~\n/tmp/tmpiyckb9yr.swift:22:19: error:\
    \ extraneous argument label 'truncating:' in call\n      res[i] = Int(truncating:\
    \ arr[i] / Int(pow(2.0, Double(binary))))\n                  ^~~~~~~~~~~~~\n \
    \                  \n"
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return arr\n\
    \    }\n    \n    // Count ones and sort from most to least\n    // To sort in\
    \ descending order, decrease the result if result==0\n    var oneCount = arr[0]\n\
    \    for val in arr {\n        if val == 0 {\n            oneCount--\n       \
    \ }\n    }\n    if oneCount == 0 {\n        return arr.sorted()\n    }\n    \n\
    \    // Sort based on decimal value\n    // The idea is to count the number of\
    \ ones from big to small numbers\n    // and sort them in descending order.\n\
    \    var oneCount2 = oneCount\n    for val in arr {\n        if val == 0 {\n \
    \           oneCount2--\n        }\n    }\n    \n    if oneCount2 < 0 {\n    \
    \    // The smallest number has negative number of ones\n        // so we sort\
    \ them in descending order based on decimal value\n        return arr.sorted()\n\
    \    }\n    \n    // Else sort them based on number of ones\n    return arr.sorted(by:\
    \ {$0 > $1})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpcs6itbor.swift:22:21: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            oneCount--\n                    ^~\n/tmp/tmpcs6itbor.swift:35:22:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  oneCount2--\n                     ^~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    guard arr.count >= 2 else { return\
    \ arr }\n\n    // Sort by number of ones\n    var onesCount = [0]\n    for idx\
    \ in 0..<arr.count {\n        onesCount[idx] = count1Bit(arr[idx])\n    }\n  \
    \  onesCount = sortedArray(onesCount, descending: true)\n\n    // Sort by decimal\
    \ value\n    var decValue = arr[0]\n    for idx in 1..<arr.count {\n        let\
    \ idx = idx - 1\n        decValue = decValue / 10 + arr[idx]\n    }\n    return\
    \ arr\n        .enumerated()\n        .sorted { idx, el in\n            let onesCountIdx\
    \ = idx\n            let decValueIdx = idx - 1\n            let onesCount = onesCount[onesCountIdx]\n\
    \            let decValue = decValue[decValueIdx]\n            if onesCount >\
    \ decValue {\n                return false\n            } else if onesCount <\
    \ decValue {\n                return true\n            }\n            return false\n\
    \        }\n        .map { idx -> Int in\n            arr[idx]\n        }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpekq3i6vq.swift:18:26: error: cannot find 'count1Bit' in scope\n\
    \        onesCount[idx] = count1Bit(arr[idx])\n                         ^~~~~~~~~\n\
    /tmp/tmpekq3i6vq.swift:20:17: error: cannot find 'sortedArray' in scope\n    onesCount\
    \ = sortedArray(onesCount, descending: true)\n                ^~~~~~~~~~~\n/tmp/tmpekq3i6vq.swift:32:31:\
    \ error: cannot convert value of type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') to expected argument type 'Int'\n      \
    \      let decValueIdx = idx - 1\n                              ^\n/tmp/tmpekq3i6vq.swift:43:17:\
    \ error: cannot convert value of type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') to expected argument type 'Int'\n      \
    \      arr[idx]\n                ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sortedArr = arr\n    for i :=\
    \ 0; i < arr.count; i++ {\n        var tmp := sortedArr[i]\n        sortedArr[i]\
    \ = 0\n        for j := 0; j < arr.count; j++ {\n            if tmp == arr[j]\
    \ {\n                sortedArr[i] += j\n                tmp -= j\n           \
    \ }\n        }\n    }\n    return sortedArr\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp9247gdvn.swift:14:12: error: expected type\n    for i := 0; i <\
    \ arr.count; i++ {\n           ^\n            <#type#>\n/tmp/tmp9247gdvn.swift:14:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < arr.count;\
    \ i++ {\n           ^\n/tmp/tmp9247gdvn.swift:14:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < arr.count; i++ {\n       \
    \    ^\n/tmp/tmp9247gdvn.swift:15:18: error: expected type\n        var tmp :=\
    \ sortedArr[i]\n                 ^\n                  <#type#>\n/tmp/tmp9247gdvn.swift:17:16:\
    \ error: expected type\n        for j := 0; j < arr.count; j++ {\n           \
    \    ^\n                <#type#>\n/tmp/tmp9247gdvn.swift:17:16: error: expected\
    \ 'in' after for-each pattern\n        for j := 0; j < arr.count; j++ {\n    \
    \           ^\n/tmp/tmp9247gdvn.swift:17:16: error: expected Sequence expression\
    \ for for-each loop\n        for j := 0; j < arr.count; j++ {\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else {\n     \
    \   return arr\n    }\n    var result = [0]\n    var counts = [Int]()\n    for\
    \ i in arr {\n        if i > 0 {\n            counts[i] = 1\n        } else {\n\
    \            counts[i] = 0\n        }\n    }\n    for i in counts {\n        result.append(i\
    \ + result[0])\n    }\n    result.removeLast()\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00007ffb15d04c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007ffb159fb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00007ffb159fb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00007ffb159fb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00007ffb159fabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00007ffb15fa87ec <unavailable> + 186348

    6    tmpth2ad9p_                        0x00005616c700a395 <unavailable> + 9109

    7    tmpth2ad9p_                        0x00005616c70096f4 <unavailable> + 5876

    8    libc.so.6                          0x00007ffb154f1460 __libc_start_main +
    245

    9    tmpth2ad9p_                        0x00005616c70093c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort()\n    return arr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmphvs1p5_y.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    return arr.sorted()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp48m_0j86/tmp48m_0j86.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f41e0db7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f41e0aaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f41e0aae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f41e0aad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp48m_0j86                        0x0000564f5e560494 <unavailable> + 5268

    5    libc.so.6                          0x00007f41e05a4460 __libc_start_main +
    245

    6    tmp48m_0j86                        0x0000564f5e560079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    var arrSorted = [Int]()\n  \
    \  for i in arr {\n        var count = 0\n        for b in binaryToDecimalString(decimal:\
    \ i) {\n            if b == \"1\".toBool() {\n                count += 1\n   \
    \         }\n        }\n        if count > arrSorted.count {\n            arrSorted\
    \ = [Int]()\n        }\n        arrSorted.append(i)\n    }\n    arrSorted.sort()\n\
    \    return arrSorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpaqp7_ub4.swift:17:18: error: cannot find 'binaryToDecimalString'\
    \ in scope\n        for b in binaryToDecimalString(decimal: i) {\n           \
    \      ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort({ $0.isZeroOrNull < $1.isZeroOrNull\
    \ })\n    if arr.isEmpty {\n        return arr\n    }\n    if arr[0].isZeroOrNull\
    \ {\n        return sort_array(arr.dropFirst())\n    }\n    let ones = arr.reduce(0,\
    \ {$0 * 2})\n    return sort_array(arr.dropFirst()).sorted(by: { $0.isZeroOrNull\
    \ ? true : $0.compare(Int($1 >> ones)) == .orderedAscending })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpwr9i1h_2.swift:13:14: error: missing argument label 'by:' in call\n\
    \    arr.sort({ $0.isZeroOrNull < $1.isZeroOrNull })\n             ^\n       \
    \      by: \n/tmp/tmpwr9i1h_2.swift:13:9: error: cannot use mutating member on\
    \ immutable value: 'arr' is a 'let' constant\n    arr.sort({ $0.isZeroOrNull <\
    \ $1.isZeroOrNull })\n    ~~~ ^\n/tmp/tmpwr9i1h_2.swift:13:19: error: value of\
    \ type 'Int' has no member 'isZeroOrNull'\n    arr.sort({ $0.isZeroOrNull < $1.isZeroOrNull\
    \ })\n               ~~ ^~~~~~~~~~~~\n/tmp/tmpwr9i1h_2.swift:13:37: error: value\
    \ of type 'Int' has no member 'isZeroOrNull'\n    arr.sort({ $0.isZeroOrNull <\
    \ $1.isZeroOrNull })\n                                 ~~ ^~~~~~~~~~~~\n/tmp/tmpwr9i1h_2.swift:17:15:\
    \ error: value of type 'Int' has no member 'isZeroOrNull'\n    if arr[0].isZeroOrNull\
    \ {\n       ~~~~~~ ^~~~~~~~~~~~\n/tmp/tmpwr9i1h_2.swift:18:27: error: missing\
    \ argument label 'arr:' in call\n        return sort_array(arr.dropFirst())\n\
    \                          ^\n                          arr: \n/tmp/tmpwr9i1h_2.swift:20:30:\
    \ error: contextual closure type '(Int, Int) throws -> Int' expects 2 arguments,\
    \ but 1 was used in closure body\n    let ones = arr.reduce(0, {$0 * 2})\n   \
    \                          ^\n/tmp/tmpwr9i1h_2.swift:21:23: error: missing argument\
    \ label 'arr:' in call\n    return sort_array(arr.dropFirst()).sorted(by: { $0.isZeroOrNull\
    \ ? true : $0.compare(Int($1 >> ones)) == .orderedAscending })\n             \
    \         ^\n                      arr: \n/tmp/tmpwr9i1h_2.swift:21:27: error:\
    \ cannot convert value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n\
    \    return sort_array(arr.dropFirst()).sorted(by: { $0.isZeroOrNull ? true :\
    \ $0.compare(Int($1 >> ones)) == .orderedAscending })\n                      \
    \    ^\n/tmp/tmpwr9i1h_2.swift:21:56: error: value of type 'Int' has no member\
    \ 'isZeroOrNull'\n    return sort_array(arr.dropFirst()).sorted(by: { $0.isZeroOrNull\
    \ ? true : $0.compare(Int($1 >> ones)) == .orderedAscending })\n             \
    \                                       ~~ ^~~~~~~~~~~~\n/tmp/tmpwr9i1h_2.s"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted = [Int]()\n    var i =\
    \ 0\n    for element in arr {\n        // init binary representation as string\n\
    \        let binary = String(format:\"%b\", element)\n        // calculate number\
    \ of 1s\n        let ones = binary.count{String($0, radix: 2)}\n        if ones\
    \ < 0 {\n            ones = 0\n        }\n        // calculate number of digits\n\
    \        let digits = Int(binary.dropLast())\n        // calculate decimal value\n\
    \        let decimal = Int((pow(16, digits)*ones)/pow(16, digits))\n        //\
    \ add it to sorted\n        sorted.append(decimal)\n        // move to next element\n\
    \        i += 1\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpgw09rhy5.swift:17:28: error: incorrect argument labels in call\
    \ (have 'format:_:', expected 'repeating:count:')\n        let binary = String(format:\"\
    %b\", element)\n                           ^~~~~~~\n                         \
    \   repeating    count: \n/tmp/tmpgw09rhy5.swift:26:28: error: cannot find 'pow'\
    \ in scope\n        let decimal = Int((pow(16, digits)*ones)/pow(16, digits))\n\
    \                           ^~~\n/tmp/tmpgw09rhy5.swift:26:50: error: cannot find\
    \ 'pow' in scope\n        let decimal = Int((pow(16, digits)*ones)/pow(16, digits))\n\
    \                                                 ^~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let sorted = arr.sorted()\n    \n\
    \    if sorted.count != arr.count {\n        return sorted\n    }\n    \n    var\
    \ isZero = false\n    var isOne = false\n    var isNegative = false\n    var isEven\
    \ = false\n    var isOdd = false\n    var isAllZero = true\n    \n    for elem\
    \ in sorted {\n        isAllZero = isAllZero && elem == 0\n        isZero = isZero\
    \ || elem == 0\n        isOne = isOne || elem == 1\n        isNegative = isNegative\
    \ && elem < 0\n        isEven = isEven && (elem % 2) == 0\n        isOdd = isOdd\
    \ && (elem % 2) != 0\n    }\n    \n    let isAllNegative = isAllZero || isNegative\
    \ || isEven\n    let isAllOne = isAllZero || isOne || isOdd\n    \n    if isAllZero\
    \ || isAllNegative {\n        return sorted\n    }\n    \n    if isAllOne {\n\
    \        return isNegative\n            ? sorted\n            : sorted.sorted().reversed()\n\
    \    }\n    \n    if isAllNegative {\n        return isNegative\n            ?\
    \ sorted.sorted().reversed()\n            : sorted\n    }\n    \n    return isNegative\n\
    \        ? sorted.sorted().reversed()\n        : sorted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpe5eezauf/tmpe5eezauf.swift:72: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f22805ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f22802c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f22802c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f22802c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe5eezauf                        0x0000564e20819744 <unavailable> + 5956

    5    libc.so.6                          0x00007f227fdb9460 __libc_start_main +
    245

    6    tmpe5eezauf                        0x0000564e20819329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted { $0.bitCount()\
    \ > $1.bitCount() }\n        .sorted { $0.decimalValue < $1.decimalValue }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp1bl8mnqz.swift:13:28: error: value of type 'Int' has no member\
    \ 'bitCount'\n    return arr.sorted { $0.bitCount() > $1.bitCount() }\n      \
    \                  ~~ ^~~~~~~~\n/tmp/tmp1bl8mnqz.swift:13:44: error: value of\
    \ type 'Int' has no member 'bitCount'\n    return arr.sorted { $0.bitCount() >\
    \ $1.bitCount() }\n                                        ~~ ^~~~~~~~\n/tmp/tmp1bl8mnqz.swift:14:22:\
    \ error: value of type 'Int' has no member 'decimalValue'\n        .sorted { $0.decimalValue\
    \ < $1.decimalValue }\n                  ~~ ^~~~~~~~~~~~\n/tmp/tmp1bl8mnqz.swift:14:40:\
    \ error: value of type 'Int' has no member 'decimalValue'\n        .sorted { $0.decimalValue\
    \ < $1.decimalValue }\n                                    ~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    guard arr.count >= 2 else {\n    \
    \    return arr\n    }\n\n    let ones = arr.filter{ $0 == 1 }\n    let twos =\
    \ arr.filter{ $0 == 2 }\n    var rest = arr\n    guard rest != [] else {\n   \
    \     return arr\n    }\n    guard ones.count <= twos.count else {\n        ones.append(contentsOf:\
    \ twos)\n        return ones\n    }\n    guard ones.count == twos.count else {\n\
    \        rest = rest.filter{ $0 != 1 }\n        guard rest != [] else {\n    \
    \        return arr\n        }\n        let ones = rest.filter{ $0 == 1 }\n  \
    \      twos = rest.filter{ $0 == 2 }\n        rest = rest.filter{ $0 != 1 }\n\
    \        guard rest != [] else {\n            return arr\n        }\n        let\
    \ twos = rest.filter{ $0 == 2 }\n        return ones + twos + sort_array(rest)\n\
    \    }\n    var min = ones[0]\n    for one in ones {\n        if one < min {\n\
    \            min = one\n        }\n    }\n    guard min < 1 else {\n        return\
    \ arr\n    }\n\n    var min = twos[0]\n    for two in twos {\n        if two <\
    \ min {\n            min = two\n        }\n    }\n    guard min < 2 else {\n \
    \       return arr\n    }\n\n    var rest = sort_array(rest)\n    var mins = [Int]()\n\
    \    mins.append(min)\n    guard rest != [] else {\n        return mins\n    }\n\
    \    for rest in rest {\n        var min = 0\n        for min in mins {\n    \
    \        if rest < min {\n                break\n            }\n        }\n  \
    \      mins.append(min)\n    }\n    return mins + arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpa8yec7vp.swift:24:14: error: cannot use mutating member on immutable\
    \ value: 'ones' is a 'let' constant\n        ones.append(contentsOf: twos)\n \
    \       ~~~~ ^\n/tmp/tmpa8yec7vp.swift:17:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let ones = arr.filter{ $0 == 1 }\n    ^~~\n    var\n/tmp/tmpa8yec7vp.swift:33:9:\
    \ error: cannot assign to value: 'twos' is a 'let' constant\n        twos = rest.filter{\
    \ $0 == 2 }\n        ^~~~\n/tmp/tmpa8yec7vp.swift:18:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let twos = arr.filter{ $0 == 2 }\n    ^~~\n  \
    \  var\n/tmp/tmpa8yec7vp.swift:39:41: error: missing argument label 'arr:' in\
    \ call\n        return ones + twos + sort_array(rest)\n                      \
    \                  ^\n                                        arr: \n/tmp/tmpa8yec7vp.swift:51:9:\
    \ error: invalid redeclaration of 'min'\n    var min = twos[0]\n        ^\n/tmp/tmpa8yec7vp.swift:41:9:\
    \ note: 'min' previously declared here\n    var min = ones[0]\n        ^\n/tmp/tmpa8yec7vp.swift:61:27:\
    \ error: missing argument label 'arr:' in call\n    var rest = sort_array(rest)\n\
    \                          ^\n                          arr: \n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = ArraySlice(arr)\n   \
    \ result.sort({ a in\n        guard a >= 0 else {\n            return true\n \
    \       }\n        let ones: Int = Int(log2(Double(a))) + 1\n        return ones\
    \ < a.count ? false : (ones == a.count) || a.compare(a[a.count - ones], selector:\
    \ >)\n    })\n    return ArraySlice(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpt5sn2fr3.swift:18:29: error: cannot find 'log2' in scope\n    \
    \    let ones: Int = Int(log2(Double(a))) + 1\n                            ^~~~\n\
    /tmp/tmpt5sn2fr3.swift:21:12: error: cannot convert return expression of type\
    \ 'ArraySlice<Int>' to return type '[Int]'\n    return ArraySlice(result)\n  \
    \         ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = Array()\n    var i =\
    \ 0\n    for e in arr {\n        switch e {\n        case 0:\n            if i\
    \ == 0 {\n                result.append(0)\n                i++\n            }\
    \ else {\n                result.insert(i, 1)\n                i += 1\n      \
    \      }\n        case 1:\n            if i == 0 {\n                result.append(0)\n\
    \                i++\n            } else {\n                result.insert(i, 0)\n\
    \                i += 1\n            }\n        default:\n            i += 1\n\
    \            if i == result.count {\n                result.append(0)\n      \
    \          i++\n            }\n        }\n    }\n    if i == result.count {\n\
    \        return result\n    }\n    var temp = result\n    result = Array()\n \
    \   for e in temp {\n        result.insert(i, e)\n        i += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmptq9_7vo_.swift:13:18: error: generic parameter 'Element' could\
    \ not be inferred\n    var result = Array()\n                 ^\n/tmp/tmptq9_7vo_.swift:13:18:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var result\
    \ = Array()\n                 ^\n                      <Any>\n/tmp/tmptq9_7vo_.swift:20:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      i++\n                 ^~\n/tmp/tmptq9_7vo_.swift:28:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                i++\n        \
    \         ^~\n/tmp/tmptq9_7vo_.swift:37:18: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n                i++\n                 ^~\n/tmp/tmptq9_7vo_.swift:45:14:\
    \ error: generic parameter 'Element' could not be inferred\n    result = Array()\n\
    \             ^\n/tmp/tmptq9_7vo_.swift:45:14: note: explicitly specify the generic\
    \ arguments to fix this issue\n    result = Array()\n             ^\n        \
    \          <Any>\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var numOnes = 0\n    var lastNonZeroIndex\
    \ = 0\n\n    for num in arr {\n        switch num {\n        case 0:\n       \
    \     numOnes++\n        case 1:\n            numOnes--\n        case -1:\n  \
    \          if lastNonZeroIndex != num {\n                swap(&arr[lastNonZeroIndex],\
    \ &num)\n                lastNonZeroIndex = num\n            }\n        }\n  \
    \  }\n    swap(&arr[lastNonZeroIndex], &arr[0])\n    return arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpzzh0ww0v.swift:19:20: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            numOnes++\n                   ^~\n/tmp/tmpzzh0ww0v.swift:21:20:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  numOnes--\n                   ^~\n/tmp/tmpzzh0ww0v.swift:24:22: error: cannot\
    \ pass immutable value as inout argument: 'arr' is a 'let' constant\n        \
    \        swap(&arr[lastNonZeroIndex], &num)\n                     ^~~~\n/tmp/tmpzzh0ww0v.swift:24:46:\
    \ error: cannot pass immutable value as inout argument: 'num' is a 'let' constant\n\
    \                swap(&arr[lastNonZeroIndex], &num)\n                        \
    \                     ^~~~\n/tmp/tmpzzh0ww0v.swift:17:9: error: switch must be\
    \ exhaustive\n        switch num {\n        ^\n/tmp/tmpzzh0ww0v.swift:17:9: note:\
    \ do you want to add a default clause?\n        switch num {\n        ^\n/tmp/tmpzzh0ww0v.swift:29:10:\
    \ error: cannot pass immutable value as inout argument: 'arr' is a 'let' constant\n\
    \    swap(&arr[lastNonZeroIndex], &arr[0])\n         ^~~~\n/tmp/tmpzzh0ww0v.swift:29:34:\
    \ error: cannot pass immutable value as inout argument: 'arr' is a 'let' constant\n\
    \    swap(&arr[lastNonZeroIndex], &arr[0])\n                                 ^~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sortedArray = arr\n    let sortedArrayCount\
    \ = arr.count\n\n    if sortedArrayCount == 0 {\n        return arr\n    }\n\n\
    \    if sortedArrayCount == 1 {\n        return arr\n    }\n\n    if sortedArrayCount\
    \ == 2 {\n        let oneCount = arr[0]\n        let twoCount = arr[1]\n     \
    \   if oneCount == twoCount {\n            return arr\n        }\n        return\
    \ sort_array(arr: [oneCount, twoCount])\n    }\n\n    if sortedArrayCount == 3\
    \ {\n        let oneCount = arr[0]\n        let twoCount = arr[1]\n        let\
    \ threeCount = arr[2]\n        if oneCount == twoCount && oneCount == threeCount\
    \ {\n            return arr\n        }\n        if twoCount == threeCount {\n\
    \            return sort_array(arr: [oneCount, twoCount])\n        }\n       \
    \ return sort_array(arr: [oneCount, twoCount, threeCount])\n    }\n\n    if sortedArrayCount\
    \ == 4 {\n        let oneCount = arr[0]\n        let twoCount = arr[1]\n     \
    \   let threeCount = arr[2]\n        let fourCount = arr[3]\n        if oneCount\
    \ == twoCount && oneCount == threeCount && oneCount == fourCount {\n         \
    \   return arr\n        }\n        if twoCount == threeCount && twoCount == fourCount\
    \ {\n            return sort_array(arr: [oneCount, twoCount, threeCount])\n  \
    \      }\n        if threeCount == fourCount {\n            return sort_array(arr:\
    \ [oneCount, twoCount, threeCount, fourCount])\n        }\n        return sort_array(arr:\
    \ [oneCount, twoCount, threeCount, fourCount, arr[0]])\n    }\n\n    if sortedArrayCount\
    \ == 5 {\n        let oneCount = arr[0]\n        let twoCount = arr[1]\n     \
    \   let threeCount = arr[2]\n        let fourCount = arr[3]\n        let fiveCount\
    \ = arr[4]\n        if oneCount == twoCount && oneCount == threeCount && oneCount\
    \ == fourCount && oneCount == fiveCount {\n            return arr\n        }\n\
    \        if twoCount == threeCount && twoCount == fourCount && twoCount == fiveCount\
    \ {\n            return sort_array(arr: [oneCount, twoCount, threeCount, fourCount,\
    \ fiveCount])\n        }\n        if threeCount == fourCount && threeCount ==\
    \ fiveCount && threeCount == arr[0] {\n            return sort_array(arr: [oneCount,\
    \ twoCount, threeCount, fourCount, fiveCount, arr[0]])\n        }\n        if\
    \ fourCount == fiveCount && fourCount == arr[0] {\n            return sort_array(arr:\
    \ [oneCount, twoCount, threeCount, fourCount, fiveCount, arr[0], arr[1]])\n  \
    \      }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpymv62h0z.swift:104:64: error: expected '}' at end of brace statement\n\
    assert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\n            \
    \                                                   ^\n/tmp/tmpymv62h0z.swift:12:38:\
    \ note: to match this opening '{'\nfunc sort_array(arr: [Int]) -> [Int] {\n  \
    \                                   ^\n/tmp/tmpymv62h0z.swift:85:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpymv62h0z.swift:13:9:\
    \ warning: initialization of variable 'sortedArray' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var sortedArray = arr\n    ~~~~^~~~~~~~~~~\n\
    \    _\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let oneBits = arr.filter{$0 == 1}\n\
    \    let twoBits = arr.filter{$0 == 2}\n    var i = 0\n    while i < arr.count\
    \ {\n        i += 1\n        let lastOne = oneBits.count > i ? oneBits[i] : twoBits[i\
    \ - 1]\n        let firstTwo = twoBits.count > i ? twoBits[i] : oneBits[i - 1]\n\
    \        if lastOne == firstTwo {\n            continue\n        }\n        let\
    \ comparison = lastOne - firstTwo\n        if comparison > 0 {\n            swap(&oneBits,\
    \ &twoBits, i)\n            i += 2\n        } else {\n            swap(&twoBits,\
    \ &oneBits, i)\n            i += 2\n        }\n    }\n    return oneBits\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpj83rs941.swift:25:38: error: extra argument in call\n         \
    \   swap(&oneBits, &twoBits, i)\n                ~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmpj83rs941.swift:25:18:\
    \ error: cannot pass immutable value as inout argument: 'oneBits' is a 'let' constant\n\
    \            swap(&oneBits, &twoBits, i)\n                 ^~~~~~~~\n/tmp/tmpj83rs941.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let oneBits = arr.filter{$0\
    \ == 1}\n    ^~~\n    var\n/tmp/tmpj83rs941.swift:25:28: error: cannot pass immutable\
    \ value as inout argument: 'twoBits' is a 'let' constant\n            swap(&oneBits,\
    \ &twoBits, i)\n                           ^~~~~~~~\n/tmp/tmpj83rs941.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let twoBits = arr.filter{$0\
    \ == 2}\n    ^~~\n    var\n/tmp/tmpj83rs941.swift:28:38: error: extra argument\
    \ in call\n            swap(&twoBits, &oneBits, i)\n                ~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmpj83rs941.swift:28:18: error: cannot pass immutable value as inout argument:\
    \ 'twoBits' is a 'let' constant\n            swap(&twoBits, &oneBits, i)\n   \
    \              ^~~~~~~~\n/tmp/tmpj83rs941.swift:14:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let twoBits = arr.filter{$0 == 2}\n    ^~~\n    var\n\
    /tmp/tmpj83rs941.swift:28:28: error: cannot pass immutable value as inout argument:\
    \ 'oneBits' is a 'let' constant\n            swap(&twoBits, &oneBits, i)\n   \
    \                        ^~~~~~~~\n/tmp/tmpj83rs941.swift:13:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let oneBits = arr.filter{$0 == 1}\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // write your code in Swift 5\n  \
    \  let binaryArray = arr.map { $0.bInt()! }\n    let ones = binaryArray.filter({\
    \ $0.isOne() }).count\n    let decimals = binaryArray.filter{ $0.isZero() }.count\n\
    \    if decimals == 0 && ones == 0 {\n        return arr\n    }\n    if decimals\
    \ > 0 {\n        return binaryArray.sorted { $0.decimalValue() > $0.decimalValue()\
    \ }\n    } else {\n        return binaryArray.sorted { $0.decimalValue() < $0.decimalValue()\
    \ }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpdzv5_8fs.swift:14:23: error: generic parameter 'T' could not be\
    \ inferred\n    let binaryArray = arr.map { $0.bInt()! }\n                   \
    \   ^\nSwift.Collection:2:28: note: in call to function 'map'\n    @inlinable\
    \ public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n\
    \                           ^\n/tmp/tmpdzv5_8fs.swift:14:36: error: value of type\
    \ 'Int' has no member 'bInt'\n    let binaryArray = arr.map { $0.bInt()! }\n \
    \                               ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.isEmpty { return arr }\n  \
    \  var ones = [Int]()\n    for a in arr {\n        ones.append(count_ones(a))\n\
    \    }\n    ones = ones.sorted()\n    return ones.map { Int($0) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpd8hplpt_.swift:16:21: error: cannot find 'count_ones' in scope\n\
    \        ones.append(count_ones(a))\n                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let ones = arr.filter{$0 == 1}\n \
    \   let dec = arr.filter{$0 > 0}\n    return ones\n        .enumerated()\n   \
    \     .sorted{$1.0 * $0.element > $1.element }\n        .map {$0.element}\n  \
    \      + dec\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7f378d6l/tmp7f378d6l.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f9c45bc9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f9c458c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f9c458c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f9c458bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7f378d6l                        0x000055caf3978734 <unavailable> + 5940

    5    libc.so.6                          0x00007f9c453b6460 __libc_start_main +
    245

    6    tmp7f378d6l                        0x000055caf3978319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted: [Int] = []\n    let bits\
    \ = arr.map({ $0.countBits })\n    sorted = bits.sorted()\n    sorted.reverse()\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmppa4_nheo.swift:14:29: error: value of type 'Int' has no member\
    \ 'countBits'\n    let bits = arr.map({ $0.countBits })\n                    \
    \     ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted() { $0 == $1 }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp3k298n0w/tmp3k298n0w.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcba0077c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcb9fd6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcb9fd6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcb9fd6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3k298n0w                        0x00005650c3df7454 <unavailable> + 5204

    5    libc.so.6                          0x00007fcb9f864460 __libc_start_main +
    245

    6    tmp3k298n0w                        0x00005650c3df7039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var res = arr\n    if arr.count <=\
    \ 1 {\n        return res\n    }\n    var max = 0\n    var max_index = 0\n   \
    \ for i in 0..<arr.count {\n        if res[i] == 1 {\n            max = max(max,\
    \ i)\n            if max > max_index {\n                max_index = max\n    \
    \        }\n        }\n    }\n    if max_index == 0 {\n        return arr\n  \
    \  }\n    var index = 0\n    var count = 1\n    for _ in 0..<arr.count {\n   \
    \     if res[max_index] != 1 {\n            count++\n            if count == 3\
    \ {\n                res[max_index] = 1\n                if index == max_index\
    \ {\n                    return arr\n                }\n            } else {\n\
    \                res[max_index] = count\n            }\n            index = max_index\n\
    \            max_index++\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmphen2i7zc.swift:21:19: error: cannot call value of non-function\
    \ type 'Int'\n            max = max(max, i)\n                  ^\n/tmp/tmphen2i7zc.swift:34:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  count++\n                 ^~\n/tmp/tmphen2i7zc.swift:44:22: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            max_index++\n    \
    \                 ^~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var tmp = arr\n\n    // sort base\
    \ on number of ones\n    tmp = tmp.sort{ $0.binBitCount > $1.binBitCount }\n\n\
    \    // sort base on decimal value\n    tmp = tmp.sort{ $0.decimalValue > $1.decimalValue\
    \ }\n\n    return tmp\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp756u5wmn.swift:16:15: error: cannot assign value of type '()' to\
    \ type '[Int]'\n    tmp = tmp.sort{ $0.binBitCount > $1.binBitCount }\n      \
    \    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp756u5wmn.swift:16:24:\
    \ error: value of type 'Int' has no member 'binBitCount'\n    tmp = tmp.sort{\
    \ $0.binBitCount > $1.binBitCount }\n                    ~~ ^~~~~~~~~~~\n/tmp/tmp756u5wmn.swift:16:41:\
    \ error: value of type 'Int' has no member 'binBitCount'\n    tmp = tmp.sort{\
    \ $0.binBitCount > $1.binBitCount }\n                                     ~~ ^~~~~~~~~~~\n\
    /tmp/tmp756u5wmn.swift:19:15: error: cannot assign value of type '()' to type\
    \ '[Int]'\n    tmp = tmp.sort{ $0.decimalValue > $1.decimalValue }\n         \
    \ ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp756u5wmn.swift:19:24:\
    \ error: value of type 'Int' has no member 'decimalValue'\n    tmp = tmp.sort{\
    \ $0.decimalValue > $1.decimalValue }\n                    ~~ ^~~~~~~~~~~~\n/tmp/tmp756u5wmn.swift:19:42:\
    \ error: value of type 'Int' has no member 'decimalValue'\n    tmp = tmp.sort{\
    \ $0.decimalValue > $1.decimalValue }\n                                      ~~\
    \ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    var arraySorted = arr\n    \n\
    \    for i in 0..<arraySorted.count {\n        var binaryString = \"\"\n     \
    \   for j in 0..<arraySorted.count {\n            if arraySorted[j] == 1 {\n \
    \               binaryString += \"1\"\n            } else {\n                binaryString\
    \ += \"0\"\n            }\n        }\n        \n        let length = binaryString.count\n\
    \        let decimalString = String(binaryString.reversed())\n        var decimalValue:\
    \ Int = 0\n        \n        for _ in 0..<length {\n            decimalValue =\
    \ decimalValue * 2 + Int(binaryString[length - 1]) - Int(binaryString[length])\n\
    \        }\n        \n        arraySorted.sort { (value1, value2) -> Bool in\n\
    \            return decimalValue < Int(value2)\n        }\n    }\n    \n    return\
    \ arraySorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp9r10k9js.swift:31:13: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n            decimalValue = decimalValue * 2 + Int(binaryString[length\
    \ - 1]) - Int(binaryString[length])\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053446
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    var result = [Int]()\n    \n\
    \    for i in 0 ..< arr.count {\n        let ones = arr[Int(i)]\n        let num\
    \ = ones\n        \n        if ones > 0 {\n            let num2 = num / 2\n  \
    \          let num3 = num % 2\n            if num3 < 0 {\n                result.append(num2)\n\
    \                result.append(num3)\n            } else {\n                result.append(num3)\n\
    \                result.append(num2)\n            }\n        } else {\n      \
    \      result.append(num)\n        }\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmptvj1zd9x/tmptvj1zd9x.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f51b1f7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f51b1c73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f51b1c73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f51b1c727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptvj1zd9x                        0x000056077f87b804 <unavailable> + 6148

    5    libc.so.6                          0x00007f51b1769460 __libc_start_main +
    245

    6    tmptvj1zd9x                        0x000056077f87b3e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sorted(arr, cmp: count_ones)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp43xgt03a.swift:13:12: error: cannot find 'sorted' in scope\n  \
    \  return sorted(arr, cmp: count_ones)\n           ^~~~~~\n/tmp/tmp43xgt03a.swift:13:29:\
    \ error: cannot find 'count_ones' in scope\n    return sorted(arr, cmp: count_ones)\n\
    \                            ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted { $0.isOne() ??\
    \ false < $1.isOne() ?? false }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmptjkyfi6l.swift:13:45: error: binary operator '<' cannot be applied\
    \ to two '()' operands\n    return arr.sorted { $0.isOne() ?? false < $1.isOne()\
    \ ?? false }\n                        ~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptjkyfi6l.swift:13:45: note: overloads for '<' exist with these partially\
    \ matching parameter lists: ((), ()), (AnyIndex, AnyIndex), (Character, Character),\
    \ (ContinuousClock.Instant, ContinuousClock.Instant), (Duration, Duration), (Int,\
    \ Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (Never,\
    \ Never), (ObjectIdentifier, ObjectIdentifier), (String, String), (String.Index,\
    \ String.Index), (SuspendingClock.Instant, SuspendingClock.Instant), (TaskPriority,\
    \ TaskPriority), (UInt, UInt), (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64),\
    \ (UInt8, UInt8), (Unicode.CanonicalCombiningClass, Unicode.CanonicalCombiningClass),\
    \ (Unicode.Scalar, Unicode.Scalar), (_ValidUTF8Buffer.Index, _ValidUTF8Buffer.Index)\n\
    \    return arr.sorted { $0.isOne() ?? false < $1.isOne() ?? false }\n       \
    \                                     ^\n/tmp/tmptjkyfi6l.swift:13:28: error:\
    \ value of type 'Int' has no member 'isOne'\n    return arr.sorted { $0.isOne()\
    \ ?? false < $1.isOne() ?? false }\n                        ~~ ^~~~~\n/tmp/tmptjkyfi6l.swift:13:50:\
    \ error: value of type 'Int' has no member 'isOne'\n    return arr.sorted { $0.isOne()\
    \ ?? false < $1.isOne() ?? false }\n                                         \
    \     ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sort_array(arr: arr, keys:\
    \ {\n        (_: Int) -> Int\n        in\n        1 << Int(truncatingBits(Int.bitCount(_)))\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1, 5,\
    \ 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpdmlz_1tn.swift:16:18: error: cannot find 'truncatingBits' in scope\n\
    \        1 << Int(truncatingBits(Int.bitCount(_)))\n                 ^~~~~~~~~~~~~~\n\
    /tmp/tmpdmlz_1tn.swift:16:46: error: '_' can only appear in a pattern or on the\
    \ left side of an assignment\n        1 << Int(truncatingBits(Int.bitCount(_)))\n\
    \                                             ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var count = [Int]()\n    for num in\
    \ arr {\n        guard let index = Int(String(num, radix: 2)) else {\n       \
    \     assertionFailure(\"Cannot convert \\(num) to an Int\")\n            return\
    \ []\n        }\n        if let count = count[index] {\n            count[index]\
    \ = count + 1\n        } else {\n            count[index] = 1\n        }\n   \
    \ }\n\n    var result = Array<Int>()\n    var curIndex = -1\n    var currentCount\
    \ = 0\n    for count in count {\n        if count == 1 {\n            guard let\
    \ index = Int(String(curIndex, radix: 2)) else {\n                assertionFailure(\"\
    Cannot convert \\(curIndex) to an Int\")\n                return []\n        \
    \    }\n            result.append(index)\n            curIndex -= 1\n        }\
    \ else {\n            guard let index = Int(String(curIndex, radix: 2)) else {\n\
    \                assertionFailure(\"Cannot convert \\(curIndex) to an Int\")\n\
    \                return []\n            }\n            currentCount += count\n\
    \            if currentCount > 1 {\n                result.append((Int)((currentCount\
    \ - 1) / 2))\n                currentCount = currentCount % 2\n            }\n\
    \        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpgisld5bv.swift:20:18: error: value of type 'Int' has no subscripts\n\
    \            count[index] = count + 1\n            ~~~~~^\n/tmp/tmpgisld5bv.swift:19:12:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \        if let count = count[index] {\n           ^           ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n\
    \    }\n    switch arr.count {\n    case 0: return []\n    case 1: return arr\n\
    \    case 2: return arr.sorted()\n    default:\n        // first we find out how\
    \ long each element of array is binary.\n        var bins: [Int]\n        let\
    \ power = 2\n        let limit = power.pow(Double(arr.count))\n        var power1\
    \ = 1\n        var power2 = 1\n        var power3 = 1\n        var power4 = 1\n\
    \        for _ in 0 ..< arr.count {\n            let num = Int(pow(Double(power),\
    \ Double(arr.count)))\n            power *= num\n            power1 *= num\n \
    \           power2 *= num\n            power3 *= num\n            power4 *= num\n\
    \        }\n        bins = (0..<limit).map { Int(pow(Double(power), Double($0))\
    \ ) }\n        var tempArr = [Int]()\n        for idx in bins.indices {\n    \
    \        var bin1 = bins[idx] / power1\n            var bin2 = bins[idx] / power2\n\
    \            var bin3 = bins[idx] / power3\n            var bin4 = bins[idx] /\
    \ power4\n            if bin1 == 0 {\n                if bin2 > bin3 {\n     \
    \               bin1 = bin2\n                    bin2 = bin3\n               \
    \ }\n            }\n            if bin2 > bin1 {\n                if bin3 > bin4\
    \ {\n                    bin1 = bin2\n                    bin2 = bin3\n      \
    \              bin3 = bin4\n                }\n            }\n            if bin3\
    \ > bin1 {\n                if bin4 > bin2 {\n                    bin1 = bin2\n\
    \                    bin2 = bin3\n                    bin3 = bin4\n          \
    \      }\n            }\n            if bin4 > bin1 {\n                if bin4\
    \ > bin2 {\n                    bin1 = bin2\n                    bin2 = bin3\n\
    \                    bin3 = bin4\n                }\n            }\n         \
    \   tempArr.append(bin1)\n        }\n        return tempArr\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp43vuuklt.swift:24:27: error: value of type 'Int' has no member\
    \ 'pow'\n        let limit = power.pow(Double(arr.count))\n                  \
    \  ~~~~~ ^~~\n/tmp/tmp43vuuklt.swift:30:27: error: cannot find 'pow' in scope\n\
    \            let num = Int(pow(Double(power), Double(arr.count)))\n          \
    \                ^~~\n/tmp/tmp43vuuklt.swift:37:38: error: cannot find 'pow' in\
    \ scope\n        bins = (0..<limit).map { Int(pow(Double(power), Double($0)) )\
    \ }\n                                     ^~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort()\n    return arr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmphvs1p5_y.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let binArray = arr.map({ String(format:\
    \ \"%0*b\", $0.bitLength, 0) }).map({ Int($0) })\n    let sortedArray = binArray.sorted\
    \ { $0.1 < $1.1 }\n    return sortedArray.map { Int($0) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpm2x4pu59.swift:13:36: error: incorrect argument labels in call\
    \ (have 'format:_:_:', expected '_:radix:uppercase:')\n    let binArray = arr.map({\
    \ String(format: \"%0*b\", $0.bitLength, 0) }).map({ Int($0) })\n            \
    \                       ^~~~~~~~~\n                                          \
    \          radix:        uppercase: \n/tmp/tmpm2x4pu59.swift:13:56: error: value\
    \ of type 'Int' has no member 'bitLength'\n    let binArray = arr.map({ String(format:\
    \ \"%0*b\", $0.bitLength, 0) }).map({ Int($0) })\n                           \
    \                         ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort()\n    return arr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmphvs1p5_y.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted { $0 > $1 }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpajuelm0s/tmpajuelm0s.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f8a5be30c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f8a5bb27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f8a5bb27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f8a5bb267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpajuelm0s                        0x000055f2bf810454 <unavailable> + 5204

    5    libc.so.6                          0x00007f8a5b61d460 __libc_start_main +
    245

    6    tmpajuelm0s                        0x000055f2bf810039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var arrSorted = [Int]()\n\n    for\
    \ i in 0..<arr.count {\n        let count = count_bits(arr[i])\n\n        if count\
    \ == 1 {\n            arrSorted.append(arr[i])\n        } else {\n           \
    \ let value = Int(log2(count)) + 1\n\n            arrSorted.append(Int(pow(value,\
    \ Float64(i))) * (Int(arr[i])).powi(Float64(i)))\n        }\n    }\n\n    return\
    \ arrSorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpg83cfhjx.swift:16:21: error: cannot find 'count_bits' in scope\n\
    \        let count = count_bits(arr[i])\n                    ^~~~~~~~~~\n/tmp/tmpg83cfhjx.swift:21:29:\
    \ error: cannot find 'log2' in scope\n            let value = Int(log2(count))\
    \ + 1\n                            ^~~~\n/tmp/tmpg83cfhjx.swift:23:34: error:\
    \ cannot find 'pow' in scope\n            arrSorted.append(Int(pow(value, Float64(i)))\
    \ * (Int(arr[i])).powi(Float64(i)))\n                                 ^~~\n/tmp/tmpg83cfhjx.swift:23:74:\
    \ error: value of type 'Int' has no member 'powi'\n            arrSorted.append(Int(pow(value,\
    \ Float64(i))) * (Int(arr[i])).powi(Float64(i)))\n                           \
    \                                ~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort()\n    return arr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmphvs1p5_y.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    var sortedArray = [Int]()\n\n\
    \    for _ in 0..<arr.count {\n        var index = 0\n        for _ in 0..<(pow(Int(2),\
    \ arr.count - 1) - 1) {\n            let bin = binary_to_decimal(arr[index])\n\
    \            if bin == 1 {\n                sortedArray.append(arr[index])\n \
    \               break\n            }\n            index += 1\n        }\n    }\n\
    \n    return sortedArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp2k8c8uf_.swift:18:23: error: cannot find 'pow' in scope\n     \
    \   for _ in 0..<(pow(Int(2), arr.count - 1) - 1) {\n                      ^~~\n\
    /tmp/tmp2k8c8uf_.swift:19:23: error: cannot find 'binary_to_decimal' in scope\n\
    \            let bin = binary_to_decimal(arr[index])\n                      ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // write your code in Swift 5.0\n\
    \    let len = arr.count\n    let result = Array(repeating: 0, count: len)\n \
    \   for i in 0..<len {\n        let num = arr[i]\n        let count = num.count\n\
    \        var bin = \"0\"\n        for j in 0..<count {\n            bin += String(num[j])\n\
    \        }\n        let res = Int(bin)\n        if res == 0 {\n            result[i]\
    \ = num\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpjlje9hyz.swift:18:25: error: value of type 'Int' has no member\
    \ 'count'\n        let count = num.count\n                    ~~~ ^~~~~\n/tmp/tmpjlje9hyz.swift:25:19:\
    \ error: cannot assign through subscript: 'result' is a 'let' constant\n     \
    \       result[i] = num\n            ~~~~~~^\n/tmp/tmpjlje9hyz.swift:15:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let result = Array(repeating:\
    \ 0, count: len)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // Your code here\n    return arr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpatbineed/tmpatbineed.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f6658936c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f665862db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f665862d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f665862c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpatbineed                        0x0000560846f423e4 <unavailable> + 5092

    5    libc.so.6                          0x00007f6658123460 __libc_start_main +
    245

    6    tmpatbineed                        0x0000560846f41fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    let ones = arr.map { $0.isOne()\
    \ }\n    var sortedOnes: [Int] = []\n    var sortedOnesCount = 0\n    \n    for\
    \ i in 0..<arr.count {\n        if !ones[i] {\n            sortedOnes.append(arr[i])\n\
    \            sortedOnesCount += 1\n        }\n    }\n    \n    for index in sortedOnes.reverse()\
    \ {\n        arr.remove(at: index)\n    }\n    \n    for i in sortedOnes.reverse()\
    \ {\n        arr.remove(at: i)\n    }\n    \n    return arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpahl548mj.swift:14:29: error: value of type 'Int' has no member\
    \ 'isOne'\n    let ones = arr.map { $0.isOne() }\n                         ~~\
    \ ^~~~~\n/tmp/tmpahl548mj.swift:25:29: error: for-in loop requires '()' to conform\
    \ to 'Sequence'\n    for index in sortedOnes.reverse() {\n                 ~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpahl548mj.swift:29:25: error: for-in loop requires '()' to conform to 'Sequence'\n\
    \    for i in sortedOnes.reverse() {\n             ~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return sortWith(arr.sorted())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpiv6bp66s.swift:13:12: error: cannot find 'sortWith' in scope\n\
    \    return sortWith(arr.sorted())\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted: [Int] = []\n    sort.withSort(func(a,\
    \ b Int) -> Bool {\n        let oneBit = a & 1\n        let otherBit = b & 1\n\
    \        var result = oneBit == otherBit ? 1 : 0\n        result *= 10\n     \
    \   result += a ^ b\n        result /= 2\n        if result != 0 {\n         \
    \   sorted = sorted + [result]\n        }\n        return result < 0\n    })\n\
    \    sorted = sorted + arr\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp91_ebbbz.swift:14:19: error: expected expression in list of expressions\n\
    \    sort.withSort(func(a, b Int) -> Bool {\n                  ^\n/tmp/tmp91_ebbbz.swift:14:23:\
    \ error: expected identifier in function declaration\n    sort.withSort(func(a,\
    \ b Int) -> Bool {\n                      ^\n/tmp/tmp91_ebbbz.swift:14:5: error:\
    \ cannot find 'sort' in scope\n    sort.withSort(func(a, b Int) -> Bool {\n  \
    \  ^~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var counter\
    \ = 0\n    for number in arr {\n        counter += 1\n        if number == 1 {\n\
    \            result += [number]\n        } else {\n            result += [counter\
    \ - number]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp_7fxi_sv/tmp_7fxi_sv.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f1af7558c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f1af724fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f1af724f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f1af724e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_7fxi_sv                        0x000055ecbe9ae604 <unavailable> + 5636

    5    libc.so.6                          0x00007f1af6d45460 __libc_start_main +
    245

    6    tmp_7fxi_sv                        0x000055ecbe9ae1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted{ $0 == 0 }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpwja8r4ia.swift:13:22: error: contextual closure type '(Int, Int)\
    \ throws -> Bool' expects 2 arguments, but 1 was used in closure body\n    return\
    \ arr.sorted{ $0 == 0 }\n                     ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    var result = [Int]()\n    \n\
    \    for ele in arr {\n        let binaryString = String(ele, radix: 2)\n    \
    \    let binaryStringWithoutLeadingZeros = binaryString.remove(at: 0) // remove\
    \ leading zeros\n        let binaryStringWithoutLeadingOnes = binaryStringWithoutLeadingZeros.remove(at:\
    \ 0)\n        \n        if binaryStringWithoutLeadingOnes == \"\" { // no 1 found\
    \ in binaryStringWithoutLeadingOnes\n            result.insert(ele, at: 0)\n \
    \           continue\n        }\n        \n        let lastDigit = Int(binaryStringWithoutLeadingOnes[binaryStringWithoutLeadingOnes.index(binaryStringWithoutLeadingOnes.startIndex,\
    \ offsetBy: -1)]) \n        let digitToInsertBefore = binaryString.remove(at:\
    \ binaryString.index(binaryString.startIndex, offsetBy: -1)) // remove last digit\n\
    \        \n        if lastDigit == 1 { // find digit that equals to one in binaryStringWithoutLeadingOnes\n\
    \            // binaryStringWithoutLeadingOnes is \"101111\"\n            // digitToInsertBefore\
    \ is \"10\"\n            // lastDigit is 1\n            // binaryStringWithoutLeadingOnes.count\
    \ is 4\n            \n            let digit = Int(digitToInsertBefore)\n     \
    \       \n            // binaryStringWithoutLeadingOnes is \"101111\"\n      \
    \      // digitToInsertBefore is \"11\"\n            // lastDigit is 1\n     \
    \       // binaryStringWithoutLeadingOnes.count is 5\n            \n         \
    \   let beforeDigit = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: lastDigit + 1))\n            \n            // binaryStringWithoutLeadingOnes\
    \ is \"1011\"\n            // digitToInsertBefore is \"10\"\n            // lastDigit\
    \ is 1\n            // binaryStringWithoutLeadingOnes.count is 6\n           \
    \ \n            let afterDigit = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: lastDigit + 1))\n            \n            // binaryStringWithoutLeadingOnes\
    \ is \"111\"\n            // digitToInsertBefore is \"1\"\n            // lastDigit\
    \ is 1\n            // binaryStringWithoutLeadingOnes.count is 7\n           \
    \ \n            let newBinaryString = beforeDigit + String(digit, radix: 2) +\
    \ afterDigit + String(lastDigit, radix: 2)\n            let newBinaryStringWithoutLeadingZeros\
    \ = newBinaryString.remove(at: 0) // remove leading zeros\n            \n    \
    \        result.insert(newBinaryStringWithoutLeadingZeros, at: 0)\n        } else\
    \ {\n            result.insert(ele, at: 0)\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpsmyfzz5m.swift:18:60: error: no exact matches in call to instance\
    \ method 'remove'\n        let binaryStringWithoutLeadingZeros = binaryString.remove(at:\
    \ 0) // remove leading zeros\n                                               \
    \            ^\n/tmp/tmpsmyfzz5m.swift:18:60: note: found candidate with type\
    \ '(String.Index) -> Character'\n        let binaryStringWithoutLeadingZeros =\
    \ binaryString.remove(at: 0) // remove leading zeros\n                       \
    \                                    ^\n/tmp/tmpsmyfzz5m.swift:27:48: error: cannot\
    \ use mutating member on immutable value: 'binaryString' is a 'let' constant\n\
    \        let digitToInsertBefore = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: -1)) // remove last digit\n                                  ~~~~~~~~~~~~\
    \ ^\n/tmp/tmpsmyfzz5m.swift:17:9: note: change 'let' to 'var' to make it mutable\n\
    \        let binaryString = String(ele, radix: 2)\n        ^~~\n        var\n\
    /tmp/tmpsmyfzz5m.swift:42:44: error: no exact matches in call to instance method\
    \ 'remove'\n            let beforeDigit = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: lastDigit + 1))\n                                           ^\n/tmp/tmpsmyfzz5m.swift:42:44:\
    \ note: found candidate with type '(String.Index) -> Character'\n            let\
    \ beforeDigit = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: lastDigit + 1))\n                                           ^\n/tmp/tmpsmyfzz5m.swift:49:43:\
    \ error: no exact matches in call to instance method 'remove'\n            let\
    \ afterDigit = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: lastDigit + 1))\n                                          ^\n/tmp/tmpsmyfzz5m.swift:49:43:\
    \ note: found candidate with type '(String.Index) -> Character'\n            let\
    \ afterDigit = binaryString.remove(at: binaryString.index(binaryString.startIndex,\
    \ offsetBy: lastDigit + 1))\n                                          ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sortedArray = [Int]()\n\n    for\
    \ i in arr {\n        if i == 1 {\n            sortedArray.append(i)\n       \
    \     continue\n        }\n\n        var binaryString = \"\"\n        for j in\
    \ (0...Int(i).bit_length).reversed() {\n            if i != 1 {\n            \
    \    binaryString += \"0\"\n            }\n            binaryString += \"1\"\n\
    \n            if j == (Int(i).bit_length - 1) {\n                break\n     \
    \       }\n        }\n\n        sortedArray.append(Int(binaryString, radix: 2)!)\n\
    \    }\n\n    return sortedArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp5gbrrpst.swift:22:30: error: value of type 'Int' has no member\
    \ 'bit_length'\n        for j in (0...Int(i).bit_length).reversed() {\n      \
    \                ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort()\n    return arr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmphvs1p5_y.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return\
    \ [] }\n    let ones = arr.filter{$0 == 1}\n    let sortedOnes = sort_array(arr:\
    \ ones)\n    let decimals = sortedOnes.map { (ones) -> Double in\n        return\
    \ pow(10.0, Double(ones) / 10.0)\n    }\n    return sortedOnes.sorted {\n    \
    \    $0 < $1 // sort by decimal order\n    }.map {\n        let decimal = decimals[$0]\n\
    \        let number = arr[Int(ceil(ones[$0] * float64(10) + 0.5))]\n        return\
    \ number < decimal ? -1 : number > decimal ? 1 : 0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpcbihpcij.swift:17:16: error: cannot find 'pow' in scope\n     \
    \   return pow(10.0, Double(ones) / 10.0)\n               ^~~\n/tmp/tmpcbihpcij.swift:23:30:\
    \ error: cannot find 'ceil' in scope\n        let number = arr[Int(ceil(ones[$0]\
    \ * float64(10) + 0.5))]\n                             ^~~~\n/tmp/tmpcbihpcij.swift:23:46:\
    \ error: cannot find 'float64' in scope\n        let number = arr[Int(ceil(ones[$0]\
    \ * float64(10) + 0.5))]\n                                             ^~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let ones = count_ones(arr)\n    if\
    \ ones == 0 {\n        return arr\n    }\n    let max = arr.max()\n    let maxInt\
    \ = (max >> 4) << 4\n    let minInt = -(max & 0x0f)\n    let arr2 = arr.map {\
    \ Int($0 * (max - 1)) }\n    return arr2.sorted { $0 >= $1 }.map { ($0 & maxInt)\
    \ + minInt }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpidkr6hs4.swift:13:16: error: cannot find 'count_ones' in scope\n\
    \    let ones = count_ones(arr)\n               ^~~~~~~~~~\n/tmp/tmpidkr6hs4.swift:18:19:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    let maxInt = (max >> 4) << 4\n                  ^\n/tmp/tmpidkr6hs4.swift:18:19:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let maxInt = (max >> 4) << 4\n                  ^\n             \
    \     (   ?? <#default value#>)\n/tmp/tmpidkr6hs4.swift:18:19: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let maxInt\
    \ = (max >> 4) << 4\n                  ^\n                     !\n/tmp/tmpidkr6hs4.swift:19:20:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    let minInt = -(max & 0x0f)\n                   ^\n/tmp/tmpidkr6hs4.swift:19:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let minInt = -(max & 0x0f)\n                   ^\n              \
    \     (   ?? <#default value#>)\n/tmp/tmpidkr6hs4.swift:19:20: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    let minInt\
    \ = -(max & 0x0f)\n                   ^\n                      !\n/tmp/tmpidkr6hs4.swift:20:36:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    let arr2 = arr.map { Int($0 * (max - 1)) }\n                            \
    \       ^\n/tmp/tmpidkr6hs4.swift:20:36: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let arr2 = arr.map { Int($0\
    \ * (max - 1)) }\n                                   ^\n                     \
    \              (   ?? <#default value#>)\n/tmp/tmpidkr6hs4.swift:20:36: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    let arr2 = arr.map { Int($0 * (max - 1)) }\n                            \
    \       ^\n                                      !\n"
  stdout: ''
  timestamp: 1660053437
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp7q7zast_/tmp7q7zast_.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fcc46440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fcc46137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fcc46137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fcc461367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q7zast_                        0x00005605149333e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fcc45c2d460 __libc_start_main +
    245

    6    tmp7q7zast_                        0x0000560514932fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = Array<T>()\n    \n  \
    \  var i = 0\n    var j = 0\n    var k = 0\n    \n    for i < arr.count {\n  \
    \      let count = arr[i]\n        if count == 1 {\n            result[j] = arr[i]\n\
    \            j++\n        } else if count == 0 {\n            continue\n     \
    \   } else {\n            var temp = 0\n            var left = 0\n           \
    \ var right = i + 1\n            \n            while left <= right {\n       \
    \         if arr[left] > arr[right] {\n                    temp = arr[left]\n\
    \                    arr[left] = arr[right]\n                    arr[right] =\
    \ temp\n                }\n                \n                if count == 1 {\n\
    \                    while left <= right && arr[left] == 0 {\n               \
    \         left++\n                    }\n                    while left <= right\
    \ && arr[right] == 0 {\n                        right--\n                    }\n\
    \                    if left > right {\n                        break\n      \
    \              } else {\n                        k++\n                    }\n\
    \                } else if count > 1 {\n                    while left <= right\
    \ && arr[left] == 0 {\n                        left++\n                    }\n\
    \                    while left <= right && arr[right] == 0 {\n              \
    \          right--\n                    }\n                    if left > right\
    \ {\n                        break\n                    } else if arr[left] >=\
    \ count {\n                        k--\n                        k++\n        \
    \            } else {\n                        k++\n                    }\n  \
    \              }\n            }\n        }\n    }\n    \n    for i < arr.count\
    \ {\n        result.append(arr[i])\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpqwys1q7u.swift:19:11: error: expected 'in' after for-each pattern\n\
    \    for i < arr.count {\n          ^\n/tmp/tmpqwys1q7u.swift:19:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < arr.count {\n   \
    \       ^~\n           \n/tmp/tmpqwys1q7u.swift:70:11: error: expected 'in' after\
    \ for-each pattern\n    for i < arr.count {\n          ^\n/tmp/tmpqwys1q7u.swift:70:11:\
    \ error: unary operator cannot be separated from its operand\n    for i < arr.count\
    \ {\n          ^~\n           \n/tmp/tmpqwys1q7u.swift:13:24: error: cannot find\
    \ type 'T' in scope\n    var result = Array<T>()\n                       ^\n/tmp/tmpqwys1q7u.swift:19:11:\
    \ error: '<' is not a prefix unary operator\n    for i < arr.count {\n       \
    \   ^\n/tmp/tmpqwys1q7u.swift:70:11: error: '<' is not a prefix unary operator\n\
    \    for i < arr.count {\n          ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted(by: { (n1, n2) ->\
    \ Bool in\n        return n1 < (n2 as! Int)\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmp84a8w6g1/tmp84a8w6g1.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fb528a45c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fb52873cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fb52873c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fb52873b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp84a8w6g1                        0x00005561ef44b454 <unavailable> + 5204

    5    libc.so.6                          0x00007fb528232460 __libc_start_main +
    245

    6    tmp84a8w6g1                        0x00005561ef44b039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sortInPlace()\n    return arr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmph3jhbzln.swift:13:9: error: value of type '[Int]' has no member\
    \ 'sortInPlace'\n    arr.sortInPlace()\n    ~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = make([]Int, 0)\n    arr.forEach\
    \ { number in\n        if number > 0 {\n            result.insert(result.count-1,\
    \ number)\n        } else {\n            result.insert(result.count, number)\n\
    \        }\n    }\n    result.sort()\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpapug3t0v.swift:13:25: error: expected ',' separator\n    var result\
    \ = make([]Int, 0)\n                        ^\n                        ,\n/tmp/tmpapug3t0v.swift:13:18:\
    \ error: cannot find 'make' in scope\n    var result = make([]Int, 0)\n      \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted{ $0 == 1 }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpyra7x60z.swift:13:22: error: contextual closure type '(Int, Int)\
    \ throws -> Bool' expects 2 arguments, but 1 was used in closure body\n    return\
    \ arr.sorted{ $0 == 1 }\n                     ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted = [Int]()\n    if arr.isEmpty\
    \ {\n        return sorted\n    }\n    var i = 0\n    var max = 0\n    for num\
    \ in arr {\n        if max < num {\n            max = num\n        }\n       \
    \ sorted.append(num)\n    }\n\n    var j = 0\n    var max2 = 0\n    var max3 =\
    \ 0\n    for num in sorted {\n        if max2 < num {\n            max2 = num\n\
    \        }\n        if max3 < num {\n            max3 = num\n        }\n     \
    \   if max3 == 0 {\n            if max2 == 0 {\n                j++\n        \
    \        max2 = 0\n                max3 = 0\n            }\n        }\n      \
    \  if max2 == 0 {\n            if max3 == 0 {\n                j++\n         \
    \       max2 = 0\n                max3 = 0\n            }\n        }\n    }\n\
    \    let max2 = Int64(max2)\n    let max3 = Int64(max3)\n    var result = sorted\n\
    \    swap(&result, &result[0], j)\n    swap(&result, &result[0], j)\n    for k\
    \ in 0..<j-1 {\n        var i = k\n        swap(&result, &result[i], j-1)\n  \
    \      swap(&result, &result[i], j-1)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpov03sxyq.swift:38:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmpov03sxyq.swift:45:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      j++\n                 ^~\n/tmp/tmpov03sxyq.swift:51:9: error: invalid redeclaration\
    \ of 'max2'\n    let max2 = Int64(max2)\n        ^\n/tmp/tmpov03sxyq.swift:27:9:\
    \ note: 'max2' previously declared here\n    var max2 = 0\n        ^\n/tmp/tmpov03sxyq.swift:52:9:\
    \ error: invalid redeclaration of 'max3'\n    let max3 = Int64(max3)\n       \
    \ ^\n/tmp/tmpov03sxyq.swift:28:9: note: 'max3' previously declared here\n    var\
    \ max3 = 0\n        ^\n/tmp/tmpov03sxyq.swift:54:31: error: extra argument in\
    \ call\n    swap(&result, &result[0], j)\n        ~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmpov03sxyq.swift:54:19:\
    \ error: cannot convert value of type 'Int' to expected argument type '[Int]'\n\
    \    swap(&result, &result[0], j)\n                  ^\n/tmp/tmpov03sxyq.swift:55:31:\
    \ error: extra argument in call\n    swap(&result, &result[0], j)\n        ~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmpov03sxyq.swift:55:19: error: cannot convert value of type 'Int' to expected\
    \ argument type '[Int]'\n    swap(&result, &result[0], j)\n                  ^\n\
    /tmp/tmpov03sxyq.swift:58:36: error: extra argument in call\n        swap(&result,\
    \ &result[i], j-1)\n            ~~~~~~~~~~~~~~~~~~~~~~~^~~\n/tmp/tmpov03sxyq.swift:58:23:\
    \ error: cannot convert value of type 'Int' to expected argument type '[Int]'\n\
    \        swap(&result, &result[i], j-1)\n                      ^\n/tmp/tmpov03sxyq.swift:59:36:\
    \ error: extra argument in call\n        swap(&result, &result[i], j-1)\n    \
    \        ~~~~~~~~~~~~~~~~~~~~~~~^~~\n/tmp/tmpov03sxyq.swift:59:23: error: cannot\
    \ convert value of type 'Int' to expected argument type '[Int]'\n        swap(&result,\
    \ &result[i], j-1)\n                      ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort()\n    return arr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmphvs1p5_y.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    return sorted(arr, { $0.bitCount()\
    \ < $1.bitCount() })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp6629cwkk.swift:14:12: error: cannot find 'sorted' in scope\n  \
    \  return sorted(arr, { $0.bitCount() < $1.bitCount() })\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var len = 0\n    for x in arr {\n\
    \        len += 1\n    }\n    var result = Array(repeating: 0, count: len)\n \
    \   for x in arr {\n        if x != 0 {\n            result[len - x] = len - x\n\
    \        }\n    }\n    result.sort(by: {\n        arr1[Int($0)] < arr1[Int($1)]\
    \ ? -1 : 1\n    })\n    return Array(result.reversed())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmp1l2muzz9.swift:24:9: error: cannot find 'arr1' in scope\n     \
    \   arr1[Int($0)] < arr1[Int($1)] ? -1 : 1\n        ^~~~\n/tmp/tmp1l2muzz9.swift:24:25:\
    \ error: cannot find 'arr1' in scope\n        arr1[Int($0)] < arr1[Int($1)] ?\
    \ -1 : 1\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let counts = arr.map({ Int($0)! }).reduce([Int](),\
    \ { (result, num) -> [Int] in\n        var r = result\n        if r.contains(num)\
    \ {\n            r = r.filter{$0 != num}\n        } else {\n            if r <\
    \ num {\n                r += [num]\n            } else {\n                r +=\
    \ [num]\n                r = [num]\n            }\n        }\n        return r\n\
    \    })\n    let ones = counts.filter({ $0 == 1 }).sorted()\n    let decimals\
    \ = counts.map{ Int($0)! }.sorted()\n    if ones.count == 0 {\n        return\
    \ arr\n    }\n    return ones + decimals\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp7luub_52.swift:13:32: error: missing argument label 'exactly:'\
    \ in call\n    let counts = arr.map({ Int($0)! }).reduce([Int](), { (result, num)\
    \ -> [Int] in\n                               ^\n                            \
    \   exactly: \n/tmp/tmp7luub_52.swift:18:16: error: cannot convert value of type\
    \ '[Int]' to expected argument type 'Int'\n            if r < num {\n        \
    \       ^\n/tmp/tmp7luub_52.swift:32:17: error: cannot convert return expression\
    \ of type 'String' to return type '[Int]'\n    return ones + decimals\n      \
    \     ~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053433
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result: [Int] = []\n    for value\
    \ in arr {\n        var binary: String = String((value & 0x01))\n        while\
    \ binary.characters.count < 8 {\n            binary += \"0\"\n        }\n    \
    \    result.append(Int(binary.characters[3..<binary.characters.count - 1]))\n\
    \    }\n    result.sort()\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpe6x8rdsa.swift:16:22: error: 'characters' is unavailable: Please\
    \ use String directly\n        while binary.characters.count < 8 {\n         \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpe6x8rdsa.swift:19:23: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n        result.append(Int(binary.characters[3..<binary.characters.count\
    \ - 1]))\n                      ^\n/tmp/tmpe6x8rdsa.swift:19:23: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     result.append(Int(binary.characters[3..<binary.characters.count - 1]))\n\
    \                      ^\n                                                   \
    \                           ?? <#default value#>\n/tmp/tmpe6x8rdsa.swift:19:23:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        result.append(Int(binary.characters[3..<binary.characters.count\
    \ - 1]))\n                      ^\n                                          \
    \                                   !\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted_arr = Array(0..<arr.count)\n\
    \    sorted_arr.sort() {\n        (a, b) in sort_helper(a, b, arr)\n    }\n  \
    \  return sorted_arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp1on4m21b.swift:15:19: error: cannot find 'sort_helper' in scope\n\
    \        (a, b) in sort_helper(a, b, arr)\n                  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var counts = make(map[int](count:\
    \ Int, repeatedValue: Int))\n    for num in arr {\n        counts[num] += 1\n\
    \    }\n    var res = make([]Int, 0)\n    for count in counts {\n        if count\
    \ == 1 {\n            res = append(res, count)\n        } else {\n           \
    \ res = append(res, count)\n            res = append(res, res[0]) // swapping\
    \ first element with last element\n        }\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpejjseh57.swift:17:22: error: expected ',' separator\n    var res\
    \ = make([]Int, 0)\n                     ^\n                     ,\n/tmp/tmpejjseh57.swift:13:18:\
    \ error: cannot find 'make' in scope\n    var counts = make(map[int](count: Int,\
    \ repeatedValue: Int))\n                 ^~~~\n/tmp/tmpejjseh57.swift:13:23: error:\
    \ cannot find 'map' in scope\n    var counts = make(map[int](count: Int, repeatedValue:\
    \ Int))\n                      ^~~\n/tmp/tmpejjseh57.swift:13:27: error: cannot\
    \ find 'int' in scope\n    var counts = make(map[int](count: Int, repeatedValue:\
    \ Int))\n                          ^~~\n/tmp/tmpejjseh57.swift:17:15: error: cannot\
    \ find 'make' in scope\n    var res = make([]Int, 0)\n              ^~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let n = arr.count\n    var result\
    \ = Array(repeating: 0, count: n)\n    for idx in 0..<n {\n        let nOnes =\
    \ arr[idx ..< n].filter { $0 == 1 }.count\n        if nOnes == 0 {\n         \
    \   result[idx] = -1000\n        } else {\n            let nDigits = bin2int(arr[idx\
    \ ..< n])\n            result[idx] = (nDigits / nOnes) % 10\n        }\n    }\n\
    \    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpo4uh0ne1.swift:20:27: error: cannot find 'bin2int' in scope\n \
    \           let nDigits = bin2int(arr[idx ..< n])\n                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    guard arr.count >= 1, arr.count <=\
    \ Int.max, arr.count >= Int.min else {\n        return arr\n    }\n\n    // We\
    \ count number of ones in each binary representation\n    var oneCounts: [Int]\
    \ = [0]\n    for i in 0..<arr.count {\n        if arr[i] > 0 {\n            oneCounts[i]\
    \ += 1\n        }\n    }\n\n    // Sort based on number of ones\n    return arr.sort\
    \ { oneCounts[$0] < oneCounts[$1] }\n\n    // Sort based on decimal value\n  \
    \  // return arr.sort { $0.compare($1) < 0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpl8w4bsnv.swift:26:16: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    return arr.sort { oneCounts[$0] < oneCounts[$1]\
    \ }\n           ~~~ ^\n/tmp/tmpl8w4bsnv.swift:26:16: error: cannot convert return\
    \ expression of type '()' to return type '[Int]'\n    return arr.sort { oneCounts[$0]\
    \ < oneCounts[$1] }\n           ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // base case\n    if arr.count <=\
    \ 1 {\n        return arr\n    }\n\n    // sort with binary search\n    let upperBound\
    \ = arr.count\n    let lowerBound = 0\n    let mid = lowerBound + (upperBound\
    \ - lowerBound) / 2.0\n\n    // binary search\n    while arr[mid] < arr[mid+1]\
    \ {\n        let middle = mid\n        if arr[mid] == 1 {\n            upperBound\
    \ = mid\n            lowerBound = mid + 1\n        } else {\n            mid =\
    \ mid + 1\n        }\n        if mid > upperBound {\n            upperBound =\
    \ mid\n            mid = mid/2\n        }\n    }\n\n    let left = arr[lowerBound..<upperBound]\n\
    \    let right = arr[upperBound..<arr.count]\n    let midLeft = sort_array(left)\n\
    \    let midRight = sort_array(right)\n\n    return midLeft + [arr[mid]] + midRight\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp0c6rkovd.swift:21:56: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n    let mid = lowerBound + (upperBound - lowerBound)\
    \ / 2.0\n                                                       ^\n          \
    \                                             Int( )\n/tmp/tmp0c6rkovd.swift:27:13:\
    \ error: cannot assign to value: 'upperBound' is a 'let' constant\n          \
    \  upperBound = mid\n            ^~~~~~~~~~\n/tmp/tmp0c6rkovd.swift:19:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let upperBound = arr.count\n \
    \   ^~~\n    var\n/tmp/tmp0c6rkovd.swift:28:13: error: cannot assign to value:\
    \ 'lowerBound' is a 'let' constant\n            lowerBound = mid + 1\n       \
    \     ^~~~~~~~~~\n/tmp/tmp0c6rkovd.swift:20:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let lowerBound = 0\n    ^~~\n    var\n/tmp/tmp0c6rkovd.swift:33:13:\
    \ error: cannot assign to value: 'upperBound' is a 'let' constant\n          \
    \  upperBound = mid\n            ^~~~~~~~~~\n/tmp/tmp0c6rkovd.swift:19:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let upperBound = arr.count\n \
    \   ^~~\n    var\n/tmp/tmp0c6rkovd.swift:40:30: error: missing argument label\
    \ 'arr:' in call\n    let midLeft = sort_array(left)\n                       \
    \      ^\n                             arr: \n/tmp/tmp0c6rkovd.swift:40:30: error:\
    \ cannot convert value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n\
    \    let midLeft = sort_array(left)\n                             ^\n/tmp/tmp0c6rkovd.swift:41:31:\
    \ error: missing argument label 'arr:' in call\n    let midRight = sort_array(right)\n\
    \                              ^\n                              arr: \n/tmp/tmp0c6rkovd.swift:41:31:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    let midRight = sort_array(right)\n                            \
    \  ^\n"
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let binaryStrings = arr.map { $0.binary()\
    \ }\n    return binaryStrings.sorted(by: { $0.count == $1.count })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpoqphro26.swift:13:38: error: value of type 'Int' has no member\
    \ 'binary'\n    let binaryStrings = arr.map { $0.binary() }\n                \
    \                  ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    arr.sort { $0 > $1 }\n    return arr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpan3nmijr.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n    arr.sort { $0 > $1 }\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = arr\n    if arr.count\
    \ < 2 {\n        return result\n    }\n\n    var (i, j) = 0, 1\n    while i <\
    \ arr.count && j < arr.count {\n        if arr[i] < arr[j] {\n            result[i]\
    \ = arr[j]\n            i += 1\n            j += 1\n        } else {\n       \
    \     result[i] = arr[i]\n            i += 1\n        }\n    }\n    while i <\
    \ arr.count {\n        result[i] = arr[i]\n        i += 1\n    }\n    while j\
    \ < arr.count {\n        result[j] = arr[j]\n        j += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp_jbkwy4o.swift:18:21: error: expected pattern\n    var (i, j) =\
    \ 0, 1\n                    ^\n/tmp/tmp_jbkwy4o.swift:18:18: error: cannot convert\
    \ value of type 'Int' to specified type '(_, _)'\n    var (i, j) = 0, 1\n    \
    \             ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = arr\n    for var i =\
    \ 0; i < result.count - 1; i++ {\n        for var j = i + 1; j < result.count;\
    \ j++ {\n            if result[j] < result[i] {\n                result[i], result[j]\
    \ = result[j], result[i]\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp7hj91moh.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < result.count - 1; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7hj91moh.swift:15:9: error: C-style for statement has been removed in\
    \ Swift 3\n        for var j = i + 1; j < result.count; j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7hj91moh.swift:17:26: error: consecutive statements on a line must be\
    \ separated by ';'\n                result[i], result[j] = result[j], result[i]\n\
    \                         ^\n                         ;\n/tmp/tmp7hj91moh.swift:17:26:\
    \ error: expected expression\n                result[i], result[j] = result[j],\
    \ result[i]\n                         ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    \n    let sortedArray = arr\n\n  \
    \  var temp = 0\n    var tempIndex = 0\n    \n    for index in 0 ..< sortedArray.count\
    \ {\n        \n        if sortedArray[index] == 1 {\n            temp += 1\n \
    \           tempIndex = index\n        } else {\n            \n            sortedArray[index]\
    \ = temp\n            sortedArray[tempIndex] = index\n            temp += 1\n\
    \            tempIndex += 1\n            \n        }\n    }\n    \n    sortedArray[tempIndex]\
    \ = temp\n    \n    return sortedArray\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpqi7u06an.swift:26:24: error: cannot assign through subscript: 'sortedArray'\
    \ is a 'let' constant\n            sortedArray[index] = temp\n            ~~~~~~~~~~~^\n\
    /tmp/tmpqi7u06an.swift:14:5: note: change 'let' to 'var' to make it mutable\n\
    \    let sortedArray = arr\n    ^~~\n    var\n/tmp/tmpqi7u06an.swift:27:24: error:\
    \ cannot assign through subscript: 'sortedArray' is a 'let' constant\n       \
    \     sortedArray[tempIndex] = index\n            ~~~~~~~~~~~^\n/tmp/tmpqi7u06an.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let sortedArray = arr\n\
    \    ^~~\n    var\n/tmp/tmpqi7u06an.swift:34:16: error: cannot assign through\
    \ subscript: 'sortedArray' is a 'let' constant\n    sortedArray[tempIndex] = temp\n\
    \    ~~~~~~~~~~~^\n/tmp/tmpqi7u06an.swift:14:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let sortedArray = arr\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let len = arr.count\n    var result\
    \ = [Int](repeating: 0, count: len)\n    if len == 0 {\n        return result\n\
    \    }\n    var leftIndex = 0\n    var rightIndex = len - 1\n    let pivot = arr[(leftIndex\
    \ + rightIndex) / 2]\n\n    while leftIndex <= rightIndex {\n        while leftIndex\
    \ < rightIndex && arr[leftIndex] <= pivot {\n            leftIndex += 1\n    \
    \    }\n        while leftIndex < rightIndex && arr[rightIndex] >= pivot {\n \
    \           rightIndex -= 1\n        }\n        if leftIndex <= rightIndex {\n\
    \            var temp = arr[leftIndex]\n            arr[leftIndex] = arr[rightIndex]\n\
    \            arr[rightIndex] = temp\n            leftIndex += 1\n            rightIndex\
    \ -= 1\n        }\n    }\n\n    result[leftIndex] = pivot\n    result[rightIndex]\
    \ = arr[len - 1]\n\n    for i in 0..<len - 1 {\n        if arr[i] == 0 {\n   \
    \         arr[i] = result[i]\n        }\n    }\n\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpj9p0ug7s.swift:31:16: error: cannot assign through subscript: 'arr'\
    \ is a 'let' constant\n            arr[leftIndex] = arr[rightIndex]\n        \
    \    ~~~^\n/tmp/tmpj9p0ug7s.swift:32:16: error: cannot assign through subscript:\
    \ 'arr' is a 'let' constant\n            arr[rightIndex] = temp\n            ~~~^\n\
    /tmp/tmpj9p0ug7s.swift:43:16: error: cannot assign through subscript: 'arr' is\
    \ a 'let' constant\n            arr[i] = result[i]\n            ~~~^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted(by: >)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpvavteudc/tmpvavteudc.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f784cac9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f784c7c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f784c7c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f784c7bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvavteudc                        0x000055d211d3c454 <unavailable> + 5204

    5    libc.so.6                          0x00007f784c2b6460 __libc_start_main +
    245

    6    tmpvavteudc                        0x000055d211d3c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660053432
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let maxOnes = arr.filter { return\
    \ $0 != 0 }\n    if maxOnes.count == 0 {\n        return arr\n    }\n\n    var\
    \ arrCopy = arr\n    arrCopy = arrCopy.sorted(by: {\n        (arg1: Int, arg2:\
    \ Int) -> Bool in\n        let bit1 = arg1 >> 1\n        let bit2 = arg2 >> 1\n\
    \        if bit1 < bit2 {\n            return true\n        } else if bit1 > bit2\
    \ {\n            return false\n        } else {\n            let bit1 = arg1 &\
    \ 1\n            let bit2 = arg2 & 1\n            return bit1 < bit2\n       \
    \ }\n    })\n    return arrCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpqcemo7a6/tmpqcemo7a6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007f13b738dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007f13b7084b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007f13b7084988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007f13b70837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqcemo7a6                        0x00005582deaee574 <unavailable> + 5492

    5    libc.so.6                          0x00007f13b6b7a460 __libc_start_main +
    245

    6    tmpqcemo7a6                        0x00005582deaee159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted({ $0 > $1 }).sorted({\
    \ sort_array($0).contains($1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpo71a2_wx.swift:13:23: error: missing argument label 'by:' in call\n\
    \    return arr.sorted({ $0 > $1 }).sorted({ sort_array($0).contains($1) })\n\
    \                      ^\n                      by: \n/tmp/tmpo71a2_wx.swift:13:43:\
    \ error: missing argument label 'by:' in call\n    return arr.sorted({ $0 > $1\
    \ }).sorted({ sort_array($0).contains($1) })\n                               \
    \           ^\n                                          by: \n/tmp/tmpo71a2_wx.swift:13:56:\
    \ error: missing argument label 'arr:' in call\n    return arr.sorted({ $0 > $1\
    \ }).sorted({ sort_array($0).contains($1) })\n                               \
    \                        ^\n                                                 \
    \      arr: \n/tmp/tmpo71a2_wx.swift:13:56: error: cannot convert value of type\
    \ 'Int' to expected argument type '[Int]'\n    return arr.sorted({ $0 > $1 }).sorted({\
    \ sort_array($0).contains($1) })\n                                           \
    \            ^\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let count = arr.count\n    let ones\
    \ = arr.map({ $0 })\n    let zeros = arr.map { $0 == 0 ? 1 : 0 }\n    let reversedZeros\
    \ = zeros.reverse()\n    let reversedOnes = ones.reverse()\n    let zeroIndex\
    \ = reversedZeros.index(of: 0)\n    let oneIndex = reversedOnes.index(of: 0)\n\
    \    var sortedArray = [Int]()\n    var left = 0\n    var right = count - 1\n\
    \    while left < right {\n        let maxIndex = zeroIndex\n        let minIndex\
    \ = oneIndex\n        if maxIndex < minIndex {\n            maxIndex = zeroIndex\n\
    \            minIndex = oneIndex\n        }\n        if sortedArray.count != count\
    \ {\n            sortedArray.append(arr[maxIndex])\n        }\n        sortedArray.append(arr[minIndex])\n\
    \        if maxIndex == minIndex {\n            if maxIndex != zeroIndex {\n \
    \               sortedArray.append(arr[maxIndex])\n            }\n           \
    \ sortedArray.append(arr[zeroIndex])\n        }\n        if maxIndex != zeroIndex\
    \ {\n            sortedArray.append(arr[maxIndex])\n            left += 1\n  \
    \      }\n        if maxIndex != oneIndex {\n            sortedArray.append(arr[minIndex])\n\
    \            right -= 1\n        }\n    }\n    return sortedArray\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpp9fihl75.swift:16:31: error: cannot use mutating member on immutable\
    \ value: 'zeros' is a 'let' constant\n    let reversedZeros = zeros.reverse()\n\
    \                        ~~~~~ ^\n/tmp/tmpp9fihl75.swift:15:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let zeros = arr.map { $0 == 0 ? 1 : 0 }\n \
    \   ^~~\n    var\n/tmp/tmpp9fihl75.swift:17:29: error: cannot use mutating member\
    \ on immutable value: 'ones' is a 'let' constant\n    let reversedOnes = ones.reverse()\n\
    \                       ~~~~ ^\n/tmp/tmpp9fihl75.swift:14:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let ones = arr.map({ $0 })\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var zeroCount = 0\n    var oneCount\
    \ = 0\n    var tmp int\n    var arrCopy = arr\n    for i in 0..<arr.count {\n\
    \        switch arrCopy[i] {\n        case 0:\n            zeroCount++\n     \
    \   case 1:\n            oneCount++\n        }\n    }\n    if oneCount == 0 {\n\
    \        var results = [Int](repeating: 0, count: zeroCount)\n        results[zeroCount\
    \ - 1] = arr[zeroCount - 1]\n        return results\n    }\n    else if zeroCount\
    \ == 0 {\n        var results = [Int](repeating: 1, count: oneCount)\n       \
    \ results[oneCount - 1] = arr[oneCount - 1]\n        return results\n    }\n \
    \   else if zeroCount > oneCount {\n        var results = [Int](repeating: 0,\
    \ count: zeroCount)\n        var onesCount = 1\n        for i in 0..<arr.count\
    \ {\n            switch arrCopy[i] {\n            case 0:\n                zeroCount--\n\
    \                results[zeroCount] = arrCopy[i]\n            case 1:\n      \
    \          onesCount++\n                results[zeroCount] = arrCopy[i]\n    \
    \        }\n        }\n        return results\n    }\n    else {\n        var\
    \ results = [Int](repeating: 1, count: oneCount)\n        var zerosCount = 1\n\
    \        for i in 0..<arr.count {\n            switch arrCopy[i] {\n         \
    \   case 0:\n                zerosCount--\n                results[zerosCount]\
    \ = arrCopy[i]\n            case 1:\n                onesCount++\n           \
    \     results[zerosCount] = arrCopy[i]\n            }\n        }\n        return\
    \ results\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(sort_array(arr: [1,\
    \ 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6])\
    \ == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpflc4nxlu.swift:15:13: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n    var tmp int\n  \
    \          ^\n/tmp/tmpflc4nxlu.swift:15:13: note: join the identifiers together\n\
    \    var tmp int\n        ~~~~^~~\n        tmpint\n/tmp/tmpflc4nxlu.swift:15:13:\
    \ note: join the identifiers together with camel-case\n    var tmp int\n     \
    \   ~~~~^~~\n        tmpInt\n/tmp/tmpflc4nxlu.swift:15:9: error: type annotation\
    \ missing in pattern\n    var tmp int\n        ^\n/tmp/tmpflc4nxlu.swift:20:22:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  zeroCount++\n                     ^~\n/tmp/tmpflc4nxlu.swift:22:21: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            oneCount++\n\
    \                    ^~\n/tmp/tmpflc4nxlu.swift:18:9: error: switch must be exhaustive\n\
    \        switch arrCopy[i] {\n        ^\n/tmp/tmpflc4nxlu.swift:18:9: note: do\
    \ you want to add a default clause?\n        switch arrCopy[i] {\n        ^\n\
    /tmp/tmpflc4nxlu.swift:41:26: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n                zeroCount--\n                         ^~\n/tmp/tmpflc4nxlu.swift:44:26:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      onesCount++\n                         ^~\n/tmp/tmpflc4nxlu.swift:39:13:\
    \ error: switch must be exhaustive\n            switch arrCopy[i] {\n        \
    \    ^\n/tmp/tmpflc4nxlu.swift:39:13: note: do you want to add a default clause?\n\
    \            switch arrCopy[i] {\n            ^\n/tmp/tmpflc4nxlu.swift:56:27:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \      zerosCount--\n                          ^~\n/tmp/tmpflc4nxlu.swift:59:26:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \      onesCount++\n                         ^~\n/tmp/tmpflc4nxlu.swift:59:17:\
    \ error: cannot find 'onesCount' in scope\n                onesCount++\n     \
    \           ^~~~~~~~~\n/tmp/tmpflc4nxlu.swift:54:13: error: switch must be exhaustive\n\
    \            switch arrCopy[i] {\n        "
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var ret = [Int]()\n    for v in arr\
    \ {\n        let bv = bin(v)\n        let len = bv.count\n        var i = 0\n\
    \        while i < len {\n            let n = bv[i]\n            if n == 1 {\n\
    \                i += 1\n                continue\n            }\n           \
    \ let s = bv[(i+1..<len).reversed()]\n            i += 1\n            let l =\
    \ s.count\n            if l > 1 {\n                let j = s.index(where: { $0\
    \ == 1 }) + i + 1 // binary index of 1\n                let m = s.count - j\n\
    \                if m < n {\n                    ret.append(n)\n             \
    \       ret.insert(j, n)\n                } else {\n                    ret.append(n)\n\
    \                    ret.insert(i, n)\n                    ret += s[j]..<s.last!\n\
    \                    ret += s[i..<j] // append the rest of s\n               \
    \ }\n            } else {\n                ret.append(n)\n            }\n    \
    \    }\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpdgisczv4.swift:15:18: error: cannot find 'bin' in scope\n     \
    \   let bv = bin(v)\n                 ^~~\n/tmp/tmpdgisczv4.swift:32:25: error:\
    \ no exact matches in call to instance method 'insert'\n                    ret.insert(j,\
    \ n)\n                        ^\n/tmp/tmpdgisczv4.swift:32:25: note: found candidate\
    \ with type '(__owned Int, Int) -> ()'\n                    ret.insert(j, n)\n\
    \                        ^\n/tmp/tmpdgisczv4.swift:35:25: error: no exact matches\
    \ in call to instance method 'insert'\n                    ret.insert(i, n)\n\
    \                        ^\n/tmp/tmpdgisczv4.swift:35:25: note: found candidate\
    \ with type '(__owned Int, Int) -> ()'\n                    ret.insert(i, n)\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // Your code here\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: '/tmp/tmppaek3ob7.swift:14:1: error: missing return in global function expected
    to return ''[Int]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    let len = arr.count\n    let ones\
    \ = arr.filter({$0 != 0})\n    let sortedArr = ones\n        .sorted {$0 > $1}\n\
    \        .sorted\n        .reverse\n        .map {$0}\n        .prefix(len)\n\
    \    \n    return sortedArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmppog841gl.swift:18:10: error: value of type '((Int, Int) throws\
    \ -> Bool) throws -> [Int]' has no member 'reverse'\n        .reverse\n      \
    \   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660053431
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return\
    \ arr }\n    let l = arr.count - 1\n    var counts: [Int] = [0]\n    var lastCount\
    \ = 0\n    for x in arr {\n        if x == 0 { lastCount = 0 } else { lastCount\
    \ = counts[x] }\n        counts[x] = lastCount + 1\n    }\n    counts = counts.sorted(by:\
    \ { $0[$1] > $1[$1] })\n    var sortedArr = [Int]()\n    for x in counts {\n \
    \       sortedArr.append(x)\n    }\n    return sortedArr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: SyntaxError
  stderr: "/tmp/tmpm5inb_rb.swift:21:36: error: value of type 'Int' has no subscripts\n\
    \    counts = counts.sorted(by: { $0[$1] > $1[$1] })\n                       \
    \          ~~^\n/tmp/tmpm5inb_rb.swift:21:45: error: value of type 'Int' has no\
    \ subscripts\n    counts = counts.sorted(by: { $0[$1] > $1[$1] })\n          \
    \                                ~~^\n"
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var newArr = [Int]()\n\n    for number\
    \ in arr {\n        let bin = number_to_binary(number)\n        var count = 0\n\
    \        for _ in bin {\n            count += 1\n        }\n        newArr.append(number)\
    \ // 0\n        if count > 1 {\n            newArr.append(number) // 1\n     \
    \       newArr.append(number) // 2\n            newArr.append(number) // 3\n \
    \           newArr.append(number) // 4\n            newArr.append(number) // 5\n\
    \        }\n        if count == 5 {\n            newArr.append(number) // 6\n\
    \        }\n    }\n\n    return newArr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmph55upccd.swift:16:19: error: cannot find 'number_to_binary' in\
    \ scope\n        let bin = number_to_binary(number)\n                  ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    guard arr.count\
    \ > 0 else { return result }\n    var temp = [Int]()\n    let maxOnes = Int(ceil(log2(Float(arr.count))))\n\
    \    var i = 0\n    for x in arr {\n        let binary = String(format: \"%08d\"\
    , x)\n        if binary.count < maxOnes {\n            i = i + 1\n           \
    \ continue\n        }\n        for y in 0..<maxOnes {\n            if binary.suffix(from:\
    \ y).count == y {\n                temp = temp + [Int](binary[x..<(x + y)])\n\
    \            }\n        }\n        if i < result.count {\n            result[i]\
    \ = temp[0]\n            if temp.length > 1 {\n                result[result.count\
    \ - 1] = temp[temp.count - 1]\n            }\n        } else {\n            result\
    \ = temp\n        }\n        i = i + 1\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmp7irsw0d2.swift:16:23: error: cannot find 'ceil' in scope\n    let\
    \ maxOnes = Int(ceil(log2(Float(arr.count))))\n                      ^~~~\n/tmp/tmp7irsw0d2.swift:16:28:\
    \ error: cannot find 'log2' in scope\n    let maxOnes = Int(ceil(log2(Float(arr.count))))\n\
    \                           ^~~~\n/tmp/tmp7irsw0d2.swift:19:28: error: incorrect\
    \ argument labels in call (have 'format:_:', expected 'repeating:count:')\n  \
    \      let binary = String(format: \"%08d\", x)\n                           ^~~~~~~\n\
    \                            repeating       count: \n/tmp/tmp7irsw0d2.swift:31:21:\
    \ error: value of type '[Int]' has no member 'length'\n            if temp.length\
    \ > 1 {\n               ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var result = arr\n    let len = arr.count\n\
    \    var sortOrder = countOnes(arr)\n    switch sortOrder {\n    case .Less:\n\
    \        sortOrder = .Greater\n    case .Greater:\n        sortOrder = .Less\n\
    \    case .Equal:\n        sortOrder = .Equal\n    }\n    func comparison(_ a:\
    \ [Int], _ b: [Int]) -> Bool {\n        var i = 0\n        while i < len {\n \
    \           if a[i] > b[i] {\n                return true\n            } else\
    \ if a[i] < b[i] {\n                return false\n            }\n            i\
    \ += 1\n        }\n        return true\n    }\n    if sortOrder == .Equal {\n\
    \        result = arr.sorted()\n    } else {\n        result = result.sorted(by:\
    \ comparison)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr:\
    \ [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0,\
    \ 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as\
    \ [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32, 5])\
    \ == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2,\
    \ 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpcuu3kb02.swift:15:21: error: cannot find 'countOnes' in scope\n\
    \    var sortOrder = countOnes(arr)\n                    ^~~~~~~~~\n/tmp/tmpcuu3kb02.swift:39:36:\
    \ error: cannot convert value of type '([Int], [Int]) -> Bool' to expected argument\
    \ type '(Int, Int) throws -> Bool'\n        result = result.sorted(by: comparison)\n\
    \                                   ^\n"
  stdout: ''
  timestamp: 1660053432
- exit_code: 1
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var sorted = []\n    for i in arr\
    \ {\n        sorted = sorted + sortByCount(i, arr: arr)\n    }\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4,\
    \ 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\n\
    assert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5,\
    \ 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr:\
    \ [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2,\
    \ 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32])\
    \ == [2, 4, 8, 16, 32])"
  status: SyntaxError
  stderr: "/tmp/tmpfjcajz4g.swift:13:18: error: empty collection literal requires\
    \ an explicit type\n    var sorted = []\n                 ^~\n/tmp/tmpfjcajz4g.swift:15:27:\
    \ error: cannot find 'sortByCount' in scope\n        sorted = sorted + sortByCount(i,\
    \ arr: arr)\n                          ^~~~~~~~~~~\n/tmp/tmpfjcajz4g.swift:17:12:\
    \ error: cannot convert return expression of type '[Any]' to return type '[Int]'\n\
    \    return sorted\n           ^\n/tmp/tmpfjcajz4g.swift:17:12: note: arguments\
    \ to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n\
    \    return sorted\n           ^\n"
  stdout: ''
  timestamp: 1660053432
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    var temp = 0\n    var i = 0\n    var\
    \ j = 0\n    var len = 0\n    var sortedArr = [Int]()\n    for _ in arr {\n  \
    \      if i >= len {\n            sortedArr += Array(arr[i ..< j])\n         \
    \   i -= j\n            temp = 1\n            j += i\n            len += i\n \
    \       } else {\n            if temp != 1 {\n                sortedArr += Array(arr[i\
    \ ..< j])\n                i -= j\n            }\n            temp *= -1\n   \
    \         j += 1\n            len += 1\n        }\n    }\n    sortedArr += Array(arr[i\
    \ ..< j])\n    return sortedArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpon4wjtm9/tmpon4wjtm9.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fad6edd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fad6eaceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fad6eace988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fad6eacd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpon4wjtm9                        0x000055887f2cb7f4 <unavailable> + 6132

    5    libc.so.6                          0x00007fad6e5c4460 __libc_start_main +
    245

    6    tmpon4wjtm9                        0x000055887f2cb3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660053432
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    return arr.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\n\
    assert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr:\
    \ [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) ==\
    \ [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) ==\
    \ [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6, 44, 12, 32,\
    \ 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) ==\
    \ [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4, 8, 16,\
    \ 32])"
  status: Exception
  stderr: 'tmpoaxfku6m/tmpoaxfku6m.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fc147815c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fc14750cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fc14750c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fc14750b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoaxfku6m                        0x0000556ceb2d5494 <unavailable> + 5268

    5    libc.so.6                          0x00007fc147002460 __libc_start_main +
    245

    6    tmpoaxfku6m                        0x0000556ceb2d5079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660053430
- exit_code: -4
  program: "\n/// In this Kata, you have to sort an array of non-negative integers\
    \ according to\n/// number of ones in their binary representation in ascending\
    \ order.\n/// For similar number of ones, sort based on decimal value.\n/// It\
    \ must be implemented like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n///\
    \ [1, 2, 3, 4, 5]\n/// >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5,\
    \ -4, -3, -2]\n/// >>> sort_array(arr: [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\n\
    func sort_array(arr: [Int]) -> [Int] {\n    // TODO: Write a function that takes\
    \ an array of non-negative integers and returns\n    // an array that sorts them\
    \ by descending order according to number of ones in their\n    // binary representation\
    \ in ascending order. For example:\n    // sort_array([1, 0, 5, 2, 3]) = [1, 2,\
    \ 3, 4, 5]\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(sort_array(arr:\
    \ [1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5,\
    \ -6]) == [-4, -2, -6, -5, -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 4, 3])\nassert(sort_array(arr: [] as [Int]) == [] as [Int])\nassert(sort_array(arr:\
    \ [2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n\
    assert(sort_array(arr: [3, 6, 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr:\
    \ [2, 4, 8, 16, 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16,\
    \ 32]) == [2, 4, 8, 16, 32])"
  status: Exception
  stderr: 'tmpjxudvbrp/tmpjxudvbrp.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00007fd808a0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00007fd808702b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00007fd808702988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00007fd8087017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjxudvbrp                        0x0000556e4abbc3e4 <unavailable> + 5092

    5    libc.so.6                          0x00007fd8081f8460 __libc_start_main +
    245

    6    tmpjxudvbrp                        0x0000556e4abbbfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660053432
