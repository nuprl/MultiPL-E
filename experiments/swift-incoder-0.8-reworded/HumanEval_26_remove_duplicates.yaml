name: HumanEval_26_remove_duplicates
language: swift
prompt: "\n/// From an array of integers, remove all elements that occur more than\
  \ once.\n/// Keep order of elements left the same as in the input.\n/// >>> remove_duplicates(numbers:\
  \ [1, 2, 3, 2, 4])\n/// [1, 3, 4]\nfunc remove_duplicates(numbers: [Int]) -> [Int]\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int])\
  \ == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3,\
  \ 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"
completions: ["    var seen = [Int]()\n    var result = [Int]()\n    for number in\
    \ numbers {\n        if let index = seen.index(of: number) {\n            result.append(numbers[index])\n\
    \        } else {\n            result.append(number)\n            seen.append(number)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for number\
    \ in numbers {\n        if result.contains(number) {\n            continue\n \
    \       } else {\n            result.append(number)\n        }\n    }\n    return\
    \ result", "  var uniques = [Int]()\n  for number in numbers {\n    if !uniques.contains(number)\
    \ {\n      uniques.append(number)\n    }\n  }\n  return uniques", "  var result\
    \ = [Int]()\n  for number in numbers {\n    if !result.contains(number) {\n  \
    \    result.append(number)\n    }\n  }\n  return result", "    guard numbers.count\
    \ > 0 else { return [] }\n    var newNumbers: [Int] = []\n    let currentValue\
    \ = numbers[0]\n    for number in numbers {\n        if number == currentValue\
    \ {\n            newNumbers.append(number)\n        }\n        else {\n      \
    \      newNumbers.append(currentValue)\n            newNumbers.append(number)\n\
    \        }\n    }\n    return newNumbers", "    var seen = [Int]()\n    for number\
    \ in numbers {\n        if seen.contains(number) {\n            seen.remove(number)\n\
    \        } else {\n            seen.insert(number)\n        }\n    }\n    return\
    \ seen", "    var seen: Set<Int> = []\n    return numbers.filter {\n        if\
    \ !seen.contains($0) {\n            seen.insert($0)\n            return true\n\
    \        }\n        return false\n    }", "    var result: [Int] = []\n    for\
    \ number in numbers {\n        if result.contains(number) {\n            continue\n\
    \        } else {\n            result.append(number)\n        }\n    }\n    return\
    \ result", "    var seen = [Int]()\n    for number in numbers {\n        if seen.contains(number)\
    \ {\n            seen.remove(number)\n        } else {\n            seen.insert(number)\n\
    \        }\n    }\n    return seen", "    let counts = numbers.reduce([Int](),\
    \ combine: { (counts, num) -> [Int] in\n        if let count = counts[num] {\n\
    \            counts[num] = count + 1\n        } else {\n            counts[num]\
    \ = 1\n        }\n        return counts\n    })\n    \n    let result = numbers.filter()\
    \ { counts[$0] == 1 }\n    \n    return result", "    var result = [Int]()\n \
    \   for number in numbers {\n        if !contains(result, number) {\n        \
    \    result.append(number)\n        }\n    }\n    return result", "    var set\
    \ = Set<Int>()\n    var result: [Int] = []\n    for n in numbers {\n        if\
    \ !set.contains(n) {\n            result.append(n)\n            set.insert(n)\n\
    \        }\n    }\n    return result", "    var uniques: [Int] = []\n    var count:\
    \ Int = 0\n    for number in numbers {\n        if uniques.contains(number) {\n\
    \            count += 1\n        } else {\n            uniques.append(number)\n\
    \        }\n    }\n    return uniques", "    var uniques = [Int]()\n    for number\
    \ in numbers {\n        if !uniques.contains(number) {\n            uniques.append(number)\n\
    \        }\n    }\n    return uniques", "    var result = [Int]()\n    var index\
    \ = 0\n    for element in numbers {\n        guard index < result.count else {\
    \ return [] }\n        if result[element] == nil || element == result[element]\
    \ {\n            result[index] = element\n            index += 1\n        }\n\
    \    }\n    return result", "    var uniqueSet = [Int]()\n    for i in numbers\
    \ {\n        if !uniqueSet.contains(i) {\n            uniqueSet.append(i)\n  \
    \      }\n    }\n    return uniqueSet", "    var unique: Set<Int> = []\n    for\
    \ number in numbers {\n        if !unique.contains(number) {\n            unique.append(number)\n\
    \        }\n    }\n    return unique.sorted()", "    return numbers.filter{ numbers\
    \ in\n        numbers.filter{ number in numbers.filter { number != numbers }.count\
    \ }\n            .count == 1\n    }", "    var result = [Int]()\n    var set =\
    \ Set<Int>()\n    for x in numbers {\n        if !set.add(x) {\n            result.append(x)\n\
    \        }\n    }\n    return result", "    var uniques = [Int]()\n    var noDups\
    \ = [Int]()\n    for num in numbers {\n        if !uniques.contains(num) {\n \
    \           uniques.append(num)\n        } else {\n            noDups.append(num)\n\
    \        }\n    }\n    return noDups", "    var result = [Int]()\n    for number\
    \ in numbers {\n        if result.contains(number) {\n            continue\n \
    \       }\n        result.append(number)\n    }\n    return result", "    var\
    \ result = [Int]()\n    for number in numbers {\n        if !contains(&result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result",
  "    var uniqueSet = Set<Int>()\n    var uniqueArray = [Int]()\n    var arrayCount\
    \ = numbers.count\n\n    for number in numbers {\n        if !uniqueSet.contains(number)\
    \ {\n            uniqueSet.add(number)\n            uniqueArray.append(number)\n\
    \        }\n    }\n\n    uniqueArray.removeDuplicates()\n\n    return uniqueArray",
  "    var result = numbers.sort()\n    for value in result {\n        var remove\
    \ = false\n        for index in 0..<result.count {\n            if result[index]\
    \ == value {\n                remove = true\n                break\n         \
    \   }\n        }\n        if remove {\n            result.removeAtIndex(0)\n \
    \       }\n    }\n    return result", "    var output = [Int]()\n    var lastNumber:\
    \ Int = numbers[0]\n    for number in numbers {\n        if number != lastNumber\
    \ {\n            output.append(lastNumber)\n        }\n        lastNumber = number\n\
    \    }\n    return output", "    var uniques = [Int]()\n    for n in numbers {\n\
    \        if uniques.contains(n) {\n            continue\n        }\n        uniques.append(n)\n\
    \    }\n    return uniques", "    \n    guard numbers.count > 0 else { return\
    \ [] }\n    var output = [Int]()\n    \n    for number in numbers {\n        if\
    \ !contains(output, number) {\n            output.append(number)\n        }\n\
    \    }\n    \n    return output", "    let dict = numbers.reduce([Int:Int]()){\n\
    \        var dict = dictionary[$1]\n        if dict == nil {\n            dict[$1.0]\
    \ = true\n        } else {\n            dict[$1.0] += 1\n        }\n        return\
    \ dict\n    }\n\n    var result = [Int]()\n    for i in 0..<dict.count {\n   \
    \     if dict[i] == 1 {\n            result.append(i)\n        }\n    }\n\n  \
    \  return result", "  var result = [Int]()\n  numbers.forEach() { value in\n \
    \   if !result.contains(value) { result.append(value) }\n  }\n  return result",
  "    var result: [Int] = []\n    for number in numbers {\n        if !contains(&result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result",
  "    var result: [Int] = []\n    for number in numbers {\n        if !contains(result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result",
  "    var result = Array(repeating: 0, count: numbers.count)\n\n    var numIndex\
    \ = 0\n    for number in numbers {\n        guard numIndex < numbers.count else\
    \ { return result }\n\n        if number != result[numIndex] {\n            result[numIndex]\
    \ = number\n            numIndex += 1\n        }\n    }\n\n    return result",
  "  var result = [Int]()\n  \n  for number in numbers {\n    if !contains(result,\
    \ number) {\n      result.append(number)\n    }\n  }\n  \n  return result", " \
    \   if numbers.isEmpty {\n        return []\n    }\n\n    var filteredNumbers\
    \ = [Int]()\n\n    for i in 0..<numbers.count {\n        if filteredNumbers.contains(numbers[i])\
    \ {\n            continue\n        } else {\n            filteredNumbers.append(numbers[i])\n\
    \        }\n    }\n\n    return filteredNumbers", "    var seen: Set<Int> = []\n\
    \    var result = [Int]()\n    for number in numbers {\n        if seen.contains(number)\
    \ {\n            continue\n        } else {\n            seen.insert(number)\n\
    \            result.append(number)\n        }\n    }\n    return result", "  \
    \  \n    var result = [Int]()\n    \n    for number in numbers {\n        if result.contains(number)\
    \ {\n            continue\n        }\n        \n        result.append(number)\n\
    \    }\n    \n    return result", "    var result = [Int]()\n    for number in\
    \ numbers {\n        if result.contains(number) {\n            continue\n    \
    \    }\n        result.append(number)\n    }\n    return result", "    var new_numbers\
    \ = [Int]()\n    for i in 0..<numbers.count {\n        if !new_numbers.contains(numbers[i])\
    \ {\n            new_numbers.append(numbers[i])\n        }\n    }\n    return\
    \ new_numbers", "    var result = [Int]()\n    for element in numbers {\n    \
    \    if !contains(&result, element) {\n            result.append(element)\n  \
    \      }\n    }\n    return result", "    // First pass: collect unique elements\n\
    \    var uniquified: [Int] = []\n    for number in numbers {\n        if !uniquified.contains(number)\
    \ {\n            uniquified.append(number)\n        }\n    }\n\n    // Second\
    \ pass: remove those elements we've collected from input\n    var output = [Int]()\n\
    \    for number in numbers {\n        if uniquified.contains(number) {\n     \
    \       output.append(number)\n            uniquified.remove(number)\n       \
    \ }\n    }\n\n    return output", "    numbers.removeAll({ $0 == $1 })\n    return\
    \ numbers", "    if numbers.isEmpty {\n        return []\n    }\n    var result:\
    \ [Int] = []\n    var seen = [Int]()\n    for num in numbers {\n        if !seen.contains(num)\
    \ {\n            seen.insert(num)\n            result.append(num)\n        }\n\
    \    }\n    return result", "    var unique = [Int]()\n    for element in numbers\
    \ {\n        if unique.contains(element) {\n            continue\n        }\n\
    \        unique.append(element)\n    }\n    return unique", "    var count: [Int]\
    \ = [0]\n    for number in numbers {\n        let index = count[number]\n    \
    \    count[number] = index + 1\n    }\n    var result: [Int] = []\n    for number\
    \ in numbers {\n        if count[number] == 1 {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    for n in\
    \ numbers {\n        if !contains(&result, n) {\n            result.append(n)\n\
    \        }\n    }\n    return result", "    let newSet = Set<Int>()\n    var seenNumbers\
    \ = [Int]()\n    for number in numbers {\n        seenNumbers.contains(number)\
    \ ? newSet.remove(number) : newSet.insert(number)\n    }\n    return newSet.map\
    \ { $0 }", "    var unique: [Int] = []\n    for number in numbers {\n        if\
    \ unique.contains(number) {\n            continue\n        } else {\n        \
    \    unique.append(number)\n        }\n    }\n    return unique", "    var count\
    \ = [Int]()\n    for number in numbers {\n        if count.contains(number) {\n\
    \            continue\n        }\n        count += 1\n    }\n    return numbers.filter\
    \ {count[$0] == 0}", "    var seen = [Int]()\n    return numbers.filter { number\
    \ in\n        if seen[number] != nil {\n            return false\n        }\n\
    \        seen[number] = true\n        return true\n    }", "    var set = Set<Int>()\n\
    \    for number in numbers {\n        if set.contains(number) {\n            continue\n\
    \        }\n        set.insert(number)\n    }\n    return Array(set)", "    var\
    \ seen = Set<Int>()\n    var result = [Int]()\n\n    for number in numbers {\n\
    \        if seen.contains(number) {\n            continue\n        }\n\n     \
    \   seen.insert(number)\n        result.append(number)\n    }\n\n    return result",
  "    var uniques = [Int]()\n    for number in numbers {\n        if uniques.contains(number)\
    \ {\n            continue\n        } else {\n            uniques.append(number)\n\
    \        }\n    }\n    return uniques", "    var result = [Int]()\n\n    for num\
    \ in numbers {\n        if result.contains(num) {\n            continue\n    \
    \    }\n        result.append(num)\n    }\n\n    return result", "    var result\
    \ = [Int]()\n    var set = Set<Int>()\n    for i in numbers {\n        if !set.contains(i)\
    \ {\n            set.insert(i)\n            result.append(i)\n        }\n    }\n\
    \    return result", "    var result: [Int] = []\n    for num in numbers {\n \
    \       if !contains(&result, num) {\n            result.append(num)\n       \
    \ }\n    }\n    return result", "    var result: [Int] = []\n    for n in numbers\
    \ {\n        if !contains(result, n) {\n            result.append(n)\n       \
    \ }\n    }\n    return result", "    func remove(_ numbers: [Int], _ index: Int)\
    \ -> Int {\n        guard index >= numbers.count else { return numbers[index]\
    \ }\n        let duplicate: Bool\n        if index < numbers.count - 1 {\n   \
    \         duplicate = numbers[index] == numbers[index + 1]\n        } else {\n\
    \            duplicate = false\n        }\n        if duplicate {\n          \
    \  return remove(_ numbers: numbers, index + 1)\n        }\n        return numbers[index]\n\
    \    }\n    return remove(_ numbers: numbers, 0)", "    var result = [Int]()\n\
    \    for number in numbers {\n        if result.contains(number) {\n         \
    \   continue\n        }\n        result.append(number)\n    }\n    return result",
  "    return numbers.reduce([]) { (memo, number) -> [Int] in\n        let index =\
    \ memo.firstIndex(of: number)\n        if index == nil {\n            memo.append(number)\n\
    \        }\n        else {\n            memo.remove(at: index!)\n        }\n \
    \       return memo\n    }", "    let seen = Set<Int>()\n    var result = [Int]()\n\
    \n    for number in numbers {\n        if seen.contains(number) {\n          \
    \  continue\n        }\n\n        seen.insert(number)\n        result.append(number)\n\
    \    }\n\n    return result", "    var result: [Int] = []\n    var seen: [Int:\
    \ [Int]] = [:]\n    for number in numbers {\n        seen[number] = nil\n    }\n\
    \    for number in numbers {\n        if seen[number] == nil {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var output = [Int]()\n    for (i,\
    \ value) in numbers.enumerated() {\n        if i != numbers.lastIndexOf(value)\
    \ {\n            output.append(value)\n        }\n    }\n    return output", " \
    \ var output: [Int] = []\n  var index: Int = 0\n  for i in 0..<numbers.count {\n\
    \    if index == numbers.count {\n      break\n    }\n    if numbers[index] ==\
    \ numbers[i] {\n      continue\n    }\n    output.append(numbers[index])\n   \
    \ index = index + 1\n  }\n  return output", "    var result = [Int]()\n    \n\
    \    for i in numbers {\n        if !contains(&result, i) {\n            result.append(i)\n\
    \        }\n    }\n    \n    return result", "  var distinctSet = Set<Int>()\n\
    \  for number in numbers {\n    if !distinctSet.contains(number) {\n      distinctSet.insert(number)\n\
    \    }\n  }\n  return Array(distinctSet)", "    var numbers = numbers\n    var\
    \ newnumbers = [Int]()\n    for number in numbers {\n        if !newnumbers.contains(number)\
    \ {\n            newnumbers.append(number)\n        }\n    }\n    return newnumbers",
  "    var result = numbers\n    for number in numbers {\n        if result.contains(number)\
    \ {\n            result.remove(number)\n        } else {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var result: [Int] = []\n    \n   \
    \ for i in 0..<numbers.count {\n        let first = numbers.firstIndex{$0 == numbers[i]}!\n\
    \        \n        if numbers.count == 1 || numbers.index(first) == i {\n    \
    \        result.append(numbers[i])\n        }\n    }\n    \n    return result",
  "    var newArray: [Int] = []\n    for element in numbers {\n        if !contains(newArray,\
    \ element) {\n            newArray.append(element)\n        }\n    }\n    return\
    \ newArray", "    var result = [Int]()\n    for number in numbers {\n        if\
    \ !result.contains(number) {\n            result.append(number)\n        }\n \
    \   }\n    return result", "    var result = [Int]()\n    for element in numbers\
    \ {\n        if !contains(&result, element) {\n            result.append(element)\n\
    \        }\n    }\n    return result", "    var result = numbers.reduce([]) {\
    \ (a, e) in\n        if !a.contains(e) {\n            a.append(e)\n        }\n\
    \        return a\n    }\n    return result", "    var numbers_count = UInt64(0)\n\
    \    for number in numbers {\n        let number_int = Int(number)\n        if\
    \ let number_count = numbers_count[number_int] {\n            numbers_count[number_int]++\n\
    \        } else {\n            numbers_count[number_int] = 1\n        }\n    }\n\
    \    var numbers = [Int]()\n    for i in 0..<numbers_count.count {\n        if\
    \ numbers_count[i] > 1 {\n            numbers.append(i)\n            numbers_count[i]\
    \ = 0\n        }\n    }\n    return numbers", "    var uniqueness: [Int] = numbers.map\
    \ { $0 }\n    var unique: [Int] = []\n    var remaining: [Int] = []\n    for number\
    \ in uniqueness {\n        if !unique.contains(number) {\n            unique.append(number)\n\
    \        } else {\n            remaining.append(number)\n        }\n    }\n  \
    \  return remaining", "    var result = [Int]()\n    for number in numbers {\n\
    \        if !contains(result, number) {\n            result.append(number)\n \
    \       }\n    }\n    return result", "    var newSet = [Int]()\n    for number\
    \ in numbers {\n        if !contains(newSet, number) {\n            newSet.append(number)\n\
    \        }\n    }\n    return newSet", "    var unique = [Int]()\n\n    for number\
    \ in numbers {\n        if unique.contains(number) {\n            removeAtIndex(unique,\
    \ unique.firstIndex(of: number))\n        } else {\n            unique.append(number)\n\
    \        }\n    }\n    return unique", "    var result = Array(repeating: 0, count:\
    \ numbers.count)\n    for i in 0 ..< numbers.count {\n        if result[i] !=\
    \ numbers[i] {\n            result[i] = numbers[i]\n        }\n    }\n    return\
    \ result", '    return numbers.reduce([]) { $0.contains($1) ? $0 : $0 += [$1]
    }', "    var output = [Int]()\n    var seen = [Int]()\n    for element in numbers\
    \ {\n        if seen.contains(element) {\n            continue\n        }\n  \
    \      seen.append(element)\n        output.append(element)\n    }\n    return\
    \ output", "    var result: [Int] = []\n    for number in numbers {\n        if\
    \ !contains(&result, number) {\n            result.append(number)\n        }\n\
    \    }\n    return result", '    return filter_map(numbers.sorted(by: >), <)',
  "    // TODO: implement this\n    return []", "    var result = Set<Int>()\n   \
    \ for num in numbers {\n        guard !result.contains(num) else {\n         \
    \   continue\n        }\n        result.append(num)\n    }\n    return Array(result)",
  "    var index = 0\n    var numberSet = Set(numbers)\n    var result: [Int] = []\n\
    \    for i in 0..<numbers.count {\n        if !numberSet.contains(numbers[i])\
    \ {\n            result.append(numbers[index])\n            index += 1\n     \
    \   }\n    }\n    return result", "    var uniques = [Int]()\n\n    for number\
    \ in numbers {\n        if !uniques.contains(number) {\n            uniques.append(number)\n\
    \        }\n    }\n\n    return uniques", "  var result: [Int] = []\n  var seen\
    \ = Set<Int>()\n  for num in numbers {\n    if !seen.contains(num) {\n      seen.insert(num)\n\
    \      result.append(num)\n    }\n  }\n  return result", "    var result: [Int]\
    \ = []\n    var seen = Set<Int>()\n    for number in numbers {\n        if !seen.contains(number)\
    \ {\n            seen.insert(number)\n            result.append(number)\n    \
    \    }\n    }\n    return result", "    var output = [Int]()\n    for number in\
    \ numbers {\n        if !contains(&output, number) {\n            output.append(number)\n\
    \        }\n    }\n    return output", "    var output = [Int]()\n\n    for i\
    \ in numbers {\n        if !output.contains(i) {\n            output.append(i)\n\
    \        }\n    }\n\n    return output", "    var removed = [Int]()\n    for number\
    \ in numbers {\n        if !contains(removed, number) {\n            removed.append(number)\n\
    \        }\n    }\n    return removed", "    var result: [Int] = []\n    for number\
    \ in numbers {\n        if result.contains(number) {\n            continue\n \
    \       }\n        result.insert(number)\n    }\n    return result", "    var\
    \ numberSet = NSCountedSet()\n    \n    for number in numbers {\n        guard\
    \ let count = numberSet[number] else { numberSet[number] = 1; continue }\n   \
    \     numberSet[number] = count + 1\n    }\n    \n    var result: [Int] = []\n\
    \    for number in numberSet {\n        if number > 1 {\n            result.append(number)\n\
    \        }\n    }\n    \n    return result", "    var unique: [Int] = Array(numbers)\n\
    \    for var i = 0; i < numbers.count; i++ {\n        for var j = i + 1; j < numbers.count;\
    \ j++ {\n            if numbers[j] == numbers[i] {\n                unique.remove(at:\
    \ j)\n                i -= 1\n            }\n        }\n    }\n    return unique",
  "    var result = [Int]()\n    for number in numbers {\n        if !contains(&result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result",
  '    return numbers.reduce(into: [], {$0[$0] += $1})', "    var result = Array(0..<numbers.count).map\
    \ { i in numbers[i] }\n    var i = numbers.count\n    while i >= 1 {\n       \
    \ if result[i-1] == result[i] {\n            result.removeAtIndex(i-1)\n     \
    \       i -= 1\n        } else {\n            break\n        }\n    }\n    return\
    \ result", "    var uniques: [Int] = []\n    for number in numbers {\n       \
    \ if uniques.contains(number) {\n            continue\n        }\n        uniques.append(number)\n\
    \    }\n    return uniques", "    var seen = [Int]()\n    var output = [Int]()\n\
    \n    for i in numbers {\n        if !contains(seen, i) {\n            seen.append(i)\n\
    \            output.append(i)\n        }\n    }\n\n    return output", "    if\
    \ numbers.count == 0 {\n        return numbers\n    }\n    var unique = [Int]()\n\
    \    for number in numbers {\n        if !unique.contains(number) {\n        \
    \    unique.append(number)\n        }\n    }\n    return unique", "    \n    var\
    \ uniqueNumbers = [Int]()\n    \n    for number in numbers {\n        if !uniqueNumbers.contains(number)\
    \ {\n            uniqueNumbers.append(number)\n        }\n    }\n    return uniqueNumbers",
  "    var nums = numbers\n    var indices = [Int]()\n    for i in 0..<nums.count\
    \ {\n        if indices.contains(nums[i]) {\n            nums.remove(at: i)\n\
    \        } else {\n            indices.append(nums[i])\n        }\n    }\n   \
    \ return nums", '    return numbers.reduce(into: [Int]()) { (result, value) in
    result.append(value) }', "    var result = numbers[0]\n    for number in numbers\
    \ {\n        if number != result {\n            result = number\n        }\n \
    \   }\n    return result + numbers[numbers.count-1]", "    var new_list = [Int]()\n\
    \    var index = 0\n    for _ in numbers {\n        if new_list.contains(numbers[index])\
    \ {\n            continue\n        } else {\n            new_list.append(numbers[index])\n\
    \        }\n    }\n    return new_list", "    var numbers_sorted = numbers.sorted()\n\
    \    var result = [Int]()\n    for i in 0..<(numbers_sorted.count - 1) {\n   \
    \     if numbers_sorted[i] == numbers_sorted[i + 1] {\n            numbers_sorted.removeAtIndex(i)\n\
    \        } else {\n            result.append(numbers_sorted[i])\n        }\n \
    \   }\n    return result", "    var result = [Int]()\n    for n in numbers {\n\
    \        if !contains(result, n) {\n            result.append(n)\n        }\n\
    \    }\n    return result", "    var uniques = [Int]()\n    for number in numbers\
    \ {\n        if !uniques.contains(number) {\n            uniques.append(number)\n\
    \        }\n    }\n    return uniques", "  var result = numbers[:]\n  var lookup\
    \ = [Int: Int]()\n  for number in numbers {\n    lookup[number] = number\n  }\n\
    \  for number in numbers {\n    if lookup[number] == nil {\n      continue\n \
    \   }\n    let newNumber = lookup[number]\n    let index = numbers.index(of: number)\n\
    \    switch numbers.count {\n    case 0...1:\n      result[index] = newNumber\n\
    \    case 2...:\n      result[index] = newNumber\n      result[index + 1] = newNumber\n\
    \    default:\n      result[index] = newNumber\n      result[index + 1] = newNumber\n\
    \      result[index + 2] = newNumber\n      result[index + 3] = newNumber\n  \
    \  }\n    lookup[newNumber] = nil\n  }\n  return result", "    // Write your code\
    \ here\n    return numbers.filter { $0.isMember == false }", "    var uniques\
    \ = [Int]()\n    for number in numbers {\n        if !uniques.contains(number)\
    \ {\n            uniques.append(number)\n        }\n    }\n    return uniques",
  "    var unique = [Int]()\n    for i in numbers {\n        if !contains(unique,\
    \ i) {\n            unique.append(i)\n        }\n    }\n    return unique", " \
    \   var unique: [Int] = []\n\n    for number in numbers {\n        if !contains(unique,\
    \ number) {\n            unique.append(number)\n        }\n    }\n\n    return\
    \ unique", "    numbers.sort()\n    var unique = [Int]()\n    for number in numbers\
    \ {\n        if !unique.contains(number) {\n            unique.append(number)\n\
    \        }\n    }\n    return unique", "    var result = [Int]()\n    for number\
    \ in numbers {\n        if !result.contains(number) {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    \n    var result = [Int]()\n    var\
    \ numberSet = Set<Int>()\n    for element in numbers {\n        if !numberSet.contains(element)\
    \ {\n            result.append(element)\n            numberSet.add(element)\n\
    \        }\n    }\n    return result", "    var result: [Int] = []\n    for number\
    \ in numbers {\n        if !contains(&result, number) {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var numbers_copy = numbers\n    var\
    \ indices_to_remove: [Int] = []\n\n    var i = 0\n    while i < numbers_copy.count\
    \ {\n        if numbers.count == 1 {\n            break\n        }\n\n       \
    \ if numbers_copy[i] == numbers_copy[i + 1] {\n            i += 1\n          \
    \  continue\n        }\n\n        if let index = numbers_copy.index(of: numbers_copy[i])\
    \ {\n            indices_to_remove.append(index)\n            numbers_copy.remove(at:\
    \ index)\n        } else {\n            i += 1\n        }\n    }\n\n    if indices_to_remove.count\
    \ == 0 {\n        return numbers\n    }\n\n    var new_numbers = numbers.filter\
    \ {\n        !indices_to_remove.contains($0)\n    }\n\n    return new_numbers",
  "    var result = [Int]()\n    for number in numbers {\n        if !contains(&result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result",
  "    numbers.sort()\n    var result = [Int]()\n    var last: Int?\n    for i in\
    \ 0..<numbers.count {\n        if i == 0 || numbers[i] != numbers[i - 1] {\n \
    \           result.append(numbers[i])\n            last = numbers[i]\n       \
    \ }\n    }\n    if let last = last {\n        result.append(last)\n    }\n   \
    \ return result", "    var uniqueNumbers = Set<Int>()\n    for number in numbers\
    \ {\n        if !uniqueNumbers.contains(number) {\n            uniqueNumbers.insert(number)\n\
    \        }\n    }\n    return uniqueNumbers.sorted().map { number in\n       \
    \ return number\n    }", "    var result = numbers.filter() {\n        if let\
    \ found = numbers.index(of: $0) {\n            numbers.remove(at: found)\n   \
    \         return true\n        }\n        return false\n    }\n    return result",
  "    return numbers.reduce((numbers, number) -> [Int] {\n        var mutableNumbers\
    \ = numbers\n        var mutableIndex = 0\n        while mutableIndex < mutableNumbers.count\
    \ {\n            if number == mutableNumbers[mutableIndex] {\n               \
    \ mutableNumbers.remove(at: mutableIndex)\n            } else {\n            \
    \    mutableIndex += 1\n            }\n        }\n        return mutableNumbers\n\
    \    })", "    // O(n) - Linear time\n    var uniqueNumbers = [Int]()\n    for\
    \ i in numbers {\n        if !uniqueNumbers.contains(i) {\n            uniqueNumbers.append(i)\n\
    \        }\n    }\n\n    return uniqueNumbers", "  var numberSet: [Int] = Array(numbers)\n\
    \  return remove_duplicates1(numberSet)", "    var uniques = [Int]()\n    for\
    \ number in numbers {\n        if !uniques.contains(number) {\n            uniques.append(number)\n\
    \        }\n    }\n    return uniques", "    var result: [Int] = []\n    var seen:\
    \ [Int: Bool] = [:]\n    for n in numbers {\n        if seen[n] == true {\n  \
    \          continue\n        }\n        result.append(n)\n        seen[n] = true\n\
    \    }\n    return result", "    var newNumbers: [Int] = []\n    for number in\
    \ numbers {\n        if !newNumbers.contains(number) {\n            newNumbers.append(number)\n\
    \        }\n    }\n    return newNumbers", '    return remove_duplicates_with_index_array(numbers,
    0)', "    var output = [Int]()\n\n    for number in numbers {\n        if !contains(output,\
    \ number) {\n            output.append(number)\n        }\n    }\n\n    return\
    \ output", "    var numberSet = Set<Int>()\n    for number in numbers {\n    \
    \    if !numberSet.contains(number) {\n            numberSet.insert(number)\n\
    \        }\n    }\n    return Array(numberSet)", "    var output: [Int] = []\n\
    \    for number in numbers {\n        if !contains(output, number) {\n       \
    \     output.append(number)\n        }\n    }\n    return output", "    var result\
    \ = [Int]()\n    for number in numbers {\n        if !contains(&result, number)\
    \ {\n            result.append(number)\n        }\n    }\n    return result",
  "    var unique = [Int]()\n    var output = [Int]()\n\n    for n in numbers {\n\
    \        if !unique.contains(n) {\n            unique.append(n)\n        } else\
    \ {\n            output.removeAll({ $0 == n })\n        }\n    }\n\n    return\
    \ output", "    var result = [Int]()\n    for number in numbers {\n        guard\
    \ result.contains(number) else { result.append(number); }\n    }\n    return result",
  "    var result = [Int]()\n    for num in numbers {\n        if !result.contains(num)\
    \ {\n            result.append(num)\n        }\n    }\n    return result", " \
    \   var set = Set<Int>()\n    var result = Array<Int>()\n\n    for number in numbers\
    \ {\n        if !set.contains(number) {\n            result.append(number)\n \
    \           set.insert(number)\n        }\n    }\n\n    return result", "    var\
    \ output: [Int] = []\n    for number in numbers {\n        if !contains(output,\
    \ number) {\n            output.append(number)\n        }\n    }\n    return output",
  "    var result = [Int]()\n    for number in numbers {\n        if !contains(&result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result",
  "    var result = [Int]()\n    let set: Set<Int> = Set(numbers)\n\n    for number\
    \ in numbers {\n        if !set.contains(number) {\n            result.append(number)\n\
    \        }\n    }\n\n    return result", "    var output = [Int]()\n\n    for\
    \ number in numbers {\n        if !contains(output, number) {\n            output.append(number)\n\
    \        }\n    }\n\n    return output", "    return numbers.reduce(into: [])\
    \ { (result, num) in\n        if !result.contains(num) {\n            result.append(num)\n\
    \        }\n    }", "    var set = Set<Int>()\n    for num in numbers {\n    \
    \    set.insert(num)\n    }\n    return numbers.filter({ set.contains($0) })",
  "    var result = numbers.filter { counts[$0] == 0 }\n    for (_, element) in numbers.enumerated()\
    \ {\n        if counts[element] == 0 {\n            result.remove(at: result.index(of:\
    \ element))\n            counts[element] = 1\n        } else {\n            counts[element]\
    \ = counts[element] + 1\n        }\n    }\n    return result", "    var counters\
    \ = [Int: Int]()\n    for number in numbers {\n        counters[number] = (counters[number]\
    \ ?? 0) + 1\n    }\n    let uniqueNumbers = Array(counters).filter{$0 > 1}\n \
    \   return uniqueNumbers.map {_ in numbers[$0]}", "    var output = [Int]()\n\
    \    var seen = [Int]()\n    for number in numbers {\n        if seen.contains(number)\
    \ {\n            continue\n        } else {\n            output.append(number)\n\
    \            seen.append(number)\n        }\n    }\n    return output", "    var\
    \ result = Set<Int>()\n    for number in numbers {\n        if !result.contains(number)\
    \ {\n            result.insert(number)\n        }\n    }\n    return Array(result)",
  "    var uniquelyUsed = [Int]()\n    var used = [Int]()\n    \n    var lastNumberIndex\
    \ = -1\n    for number in numbers {\n        if number == lastNumberIndex+1 {\n\
    \            uniquelyUsed.append(number)\n        } else {\n            uniquelyUsed.remove(number)\n\
    \        }\n        \n        used[number] = true\n        lastNumberIndex +=\
    \ 1\n    }\n    \n    var outputArray = [Int]()\n    for number in uniquelyUsed\
    \ {\n        outputArray.append(number)\n    }\n    \n    return outputArray",
  "    guard numbers.count > 0 else {\n        return []\n    }\n    var result =\
    \ [Int]()\n    var lastNumberIndex = numbers.startIndex\n    for i in 1..<numbers.count\
    \ {\n        if numbers[lastNumberIndex] == numbers[i] {\n            numbers.remove(at:\
    \ lastNumberIndex)\n            lastNumberIndex = numbers.startIndex\n       \
    \ } else {\n            result.append(numbers[lastNumberIndex])\n            lastNumberIndex\
    \ = numbers.index(after: lastNumberIndex)\n        }\n    }\n    return Array(result)",
  "    var output = Set<Int>()\n    for i in numbers {\n        if !output.contains(i)\
    \ {\n            output.add(i)\n        }\n    }\n\n    return output.sorted().map\
    \ { $0 }", "    var set: [Int] = []\n    for i in numbers {\n        if !set.isEmpty\
    \ && set.contains(i) {\n            continue\n        } else {\n            set.insert(i)\n\
    \        }\n    }\n    return set", "  var result: [Int] = []\n  for number in\
    \ numbers {\n    if !result.contains(number) {\n      result.append(number)\n\
    \    }\n  }\n  return result", "    guard numbers.count > 0 else { return numbers}\n\
    \    var filtered: [Int] = []\n    var index = 0\n    for number in numbers {\n\
    \        if filtered.contains(number) {\n            filtered[index] = number\n\
    \        } else {\n            filtered.append(number)\n        }\n        index\
    \ += 1\n    }\n    return filtered", "    var numberSet = [Int]()\n    for number\
    \ in numbers {\n        if !contains(numberSet, number) {\n            numberSet.append(number)\n\
    \        }\n    }\n    return numberSet", "  var result = numbers.reduce([]) {\
    \ (result, current) -> () in\n    if result.contains(current) {\n      result.append\
    \ (current)\n    } else {\n      result.append(current)\n    }\n  }\n  return\
    \ result", "    var result: [Int] = []\n    for n in numbers {\n        if !contains(&result,\
    \ &n) {\n            result.append(n)\n        }\n    }\n    return result", " \
    \   var result = [Int]()\n    var seen = [Int]()\n    for number in numbers {\n\
    \        if seen.contains(number) {\n            continue\n        }\n       \
    \ result.append(number)\n        seen.append(number)\n    }\n    return result",
  "    var result = [Int]()\n    for number in numbers {\n        if !contains(result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result",
  '    return filter(numbers, uniqueness)', "    var output: [Int] = []\n    var seen:\
    \ Set<Int> = []\n    for number in numbers {\n        if !seen.contains(number)\
    \ {\n            output.append(number)\n            seen.insert(number)\n    \
    \    }\n    }\n    return output", "    seen = Set<Int>()\n    var result = [Int]()\n\
    \    for number in numbers {\n        if seen.contains(number) {\n           \
    \ continue\n        }\n        seen.insert(number)\n        result.append(number)\n\
    \    }\n    return result", "    \n    var uniqueNumbers = [Int]()\n    \n   \
    \ for i in numbers {\n        if !uniqueNumbers.contains(i) {\n            uniqueNumbers.append(i)\n\
    \        }\n    }\n    \n    return uniqueNumbers", "    let seen = Set<Int>()\n\
    \    return numbers.filter { seen.insert($0).inserted }", "    var output = [Int]()\n\
    \    var seen = [Int]()\n    for n in numbers {\n        if seen.contains(n) {\n\
    \            continue\n        }\n        seen.insert(n)\n        output.append(n)\n\
    \    }\n    return output", "    var newArray: [Int] = []\n    for i in numbers\
    \ {\n        if newArray.contains(i) {\n            continue\n        }\n    \
    \    newArray.append(i)\n    }\n    return newArray", "    var result: [Int] =\
    \ []\n    for element in numbers {\n        if !contains(&result, element) {\n\
    \            result.append(element)\n        }\n    }\n    return result", " \
    \   var result = numbers\n    for idx in stride(from: 0, to: result.count, by:\
    \ 1) {\n        if result[idx] == result[idx-1] {\n            result.remove(at:\
    \ idx)\n        }\n    }\n    return result", "    if numbers.isEmpty { return\
    \ [] }\n    var result: [Int] = []\n    for x in numbers {\n        if !contains(result,\
    \ x) {\n            result.append(x)\n        }\n    }\n    return result", " \
    \   let grouped = Dictionary(grouping: numbers) { number in\n        return number\n\
    \    }\n    return grouped.map { key, groups in\n        groups.map { number in\n\
    \            return number\n        }\n    }.flatMap { $0 }", "    var seen =\
    \ [Int]()\n    var unique = [Int]()\n    for n in numbers {\n        if seen[n\
    \ - 1] == nil {\n            unique.append(n)\n            seen[n-1] = n\n   \
    \     }\n    }\n    return unique", "    var result = [Int]()\n    for number\
    \ in numbers {\n        if !result.contains(number) {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    let hashMap: Dictionary<Int, Int>\
    \ = numbers.reduce([:]) {\n        var seen: [Int: Int] = [:]\n        return\
    \ $0 + (seen[$1] = $1)\n    }\n    return Array(hashMap.keys)", "    var result\
    \ = [Int]()\n    for number in numbers {\n        if !contains(&result, number)\
    \ {\n            result.append(number)\n        }\n    }\n    return result",
  "    \n    var removeIndex = 0\n    var removed = [Int]()\n    for number in numbers\
    \ {\n        if !removed.contains(number) {\n            removed.append(number)\n\
    \            removeIndex += 1\n        }\n    }\n    return ArraySlice(removed,\
    \ removeIndex, removeIndex + numbers.count)", "    \n    if numbers.isEmpty {\
    \ return [] }\n    var index = 0\n    var result = [Int]()\n    var lastNumber:\
    \ Int = 0\n    \n    for number in numbers {\n        if number == lastNumber\
    \ {\n            numbers[index] = number\n        }\n        \n        index +=\
    \ 1\n        lastNumber = number\n    }\n    \n    return result", "    var result:\
    \ [Int] = []\n    for number in numbers {\n        if !contains(result, number)\
    \ {\n            result.append(number)\n        }\n    }\n    return result",
  '    return numbers.filter{ numbers.contains($0) }', "    \n    var result = [Int]()\n\
    \    var seen = [Int]()\n    \n    for number in numbers {\n        if seen.contains(number)\
    \ {\n            result.append(number)\n        }\n        seen.insert(number)\n\
    \    }\n    \n    return result", "    var counters = [Int]()\n    var new_numbers\
    \ = [Int]()\n    for number in numbers {\n        if counters.contains(number)\
    \ {\n            continue\n        }\n        new_numbers.append(number)\n   \
    \     counters.append(1)\n    }\n    return new_numbers", "  var uniqueNumbers\
    \ = [Int]()\n  for number in numbers {\n    if uniqueNumbers.contains(number)\
    \ {\n      continue\n    }\n    uniqueNumbers.append(number)\n  }\n  return uniqueNumbers",
  "    var unique = Set()\n    var result = [Int]()\n    for num in numbers {\n  \
    \      if unique.contains(num) {\n            continue\n        } else {\n   \
    \         unique.insert(num)\n            result.append(num)\n        }\n    }\n\
    \    return result", "    var result = numbers[0...numbers.count]\n    let counts\
    \ = Set(result)\n    var i = 0\n    while i < result.count {\n        if !counts.contains(result[i])\
    \ {\n            result.remove(at: i)\n        } else {\n            i += 1\n\
    \        }\n    }\n    return result", "    if numbers.isEmpty { return numbers\
    \ }\n    if numbers.count <= 1 { return numbers }\n    var result: [Int] = []\n\
    \    for x in numbers {\n        if !contains(&result, x) {\n            append(&result,\
    \ x)\n        }\n    }\n    return result", "    var set = Set<Int>()\n    for\
    \ num in numbers {\n        if set.contains(num) {\n            numbers.remove(num)\n\
    \        } else {\n            set.insert(num)\n        }\n    }\n    return numbers",
  "    var output = [Int]()\n    var count = 0\n    for number in numbers {\n    \
    \    if let count = output[count] {\n            if count == 1 {\n           \
    \     count += 1\n            } else {\n                output.insert(number,\
    \ at: count)\n                count += 1\n            }\n        } else {\n  \
    \          count += 1\n            output.insert(number, at: count)\n        }\n\
    \    }\n    return output", "    var result = [Int]()\n    var seen = [Int]()\n\
    \    for number in numbers {\n        if seen.contains(number) {\n           \
    \ continue\n        } else {\n            seen.insert(number)\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var result: [Int] = []\n    for number\
    \ in numbers {\n        if !contains(&result, number) {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var output: [Int] = []\n    for number\
    \ in numbers {\n        if output.contains(number) {\n            continue\n \
    \       } else {\n            output.append(number)\n        }\n    }\n    return\
    \ output", "    var unique = [Int]()\n    for n in numbers {\n        if !contains(unique,\
    \ n) {\n            unique.append(n)\n        }\n    }\n    return unique", " \
    \   var unique: [Int] = []\n    for i in numbers.indices {\n        unique.append(numbers[i])\n\
    \    }\n    return unique", "    var result: [Int] = []\n    var seen = [Int]()\n\
    \    for n in numbers {\n        if seen.append(n).contains(true) {\n        \
    \    continue\n        }\n        result.append(n)\n    }\n    return result",
  "    var result = [Int]()\n    var seen = [Int]()\n    for number in numbers {\n\
    \        if seen[number] == nil {\n            seen[number] = true\n         \
    \   result.append(number)\n        }\n    }\n    return result", "    var result\
    \ = numbers\n    var temp = 0\n    for i in 0 ..< numbers.count {\n        if\
    \ numbers.contains(i) && numbers.count > 1 {\n            temp = numbers[i]\n\
    \            numbers.remove(at: i)\n            result.insert(temp, at: numbers.firstIndex(of:\
    \ temp))\n        }\n    }\n    return result", "    var result: [Int] = []\n\
    \    numbers.forEach { number in \n        if !contains(result, number) {\n  \
    \          result.append(number)\n        }\n    }\n    return result", "    var\
    \ seen: Set<Int> = []\n    var result: [Int] = []\n    for number in numbers {\n\
    \        if seen.contains(number) {\n            continue\n        } else {\n\
    \            seen.insert(number)\n            result.append(number)\n        }\n\
    \    }\n    return result", "    let count = Set(numbers)\n    let numbers = numbers.filter\
    \ { !count.contains($0) }\n    return numbers", "    let uniqueNumbers = Set<Int>()\n\
    \n    for i in numbers {\n        if !uniqueNumbers.contains(i) {\n          \
    \  uniqueNumbers.insert(i)\n        }\n    }\n\n    return uniqueNumbers.sorted()",
  "    var seen: [Int] = [0]\n    \n    for num in numbers {\n        if seen[num]>0\
    \ {\n            seen[num] = seen[num] - 1\n        } else {\n            seen[num]\
    \ = 1\n        }\n    }\n    \n    return seen.filter{ $0>0 }.map { $0 }", " \
    \   var duplicates = Set<Int>()\n    var uniqueNumbers: [Int] = []\n    for num\
    \ in numbers {\n        if !duplicates.contains(num) {\n            uniqueNumbers.append(num)\n\
    \            duplicates.insert(num)\n        }\n    }\n    return uniqueNumbers",
  "    var result: [Int] = []\n    for number in numbers {\n        if !contains(result,\
    \ number) {\n            result.append(number)\n        }\n    }\n    return result"]
stop_tokens:
- "\n}"
