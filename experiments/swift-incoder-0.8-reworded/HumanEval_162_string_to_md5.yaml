name: HumanEval_162_string_to_md5
language: swift
prompt: "\n/// Given a string 'text', return its md5 hash equivalent string.\n///\
  \ If 'text' is an empty string, return nil.\n/// >>> string_to_md5(text: \"Hello\
  \ world\")\n/// \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunc string_to_md5(text: String)\
  \ -> String? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(string_to_md5(text: \"Hello world\") ==\
  \ \"3e25960a79dbc69b674cd4ec67a72c62\")\nassert(string_to_md5(text: \"\") == nil)\n\
  assert(string_to_md5(text: \"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\")\n\
  assert(string_to_md5(text: \"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\"\
  )"
completions: ["    if text == \"\" {\n        return nil\n    }\n\n    var md5: CInt\
    \ = 0\n    var length: CInt = -1\n    var text: Unmanaged<AnyObject>?\n\n    //\
    \ use C API to compute the md5 hash\n    let status = Unmanaged.passUnretained(self).toOpaque().withMemoryRebound(to:\
    \ MD5Hash.self, capacity: 1) { (ptr: UnsafeRawPointer, size: Int) in\n       \
    \ length = ptr.assumingMemoryBound(to: CInt.self)\n        text = ptr.assumingMemoryBound(to:\
    \ Unmanaged<AnyObject>.self)\n    }\n\n    if status == noErr {\n        let buffer\
    \ = UnsafeMutablePointer<MD5Hash>.allocate(capacity: length)\n        defer {\n\
    \            buffer.deallocate()\n        }\n        defer {\n            MD5Hash.callStatic(\"\
    stringToMD5\", buffer, length, UnsafeMutablePointer<CChar>(text!), length).map(String.init)\n\
    \        }\n    }\n\n    return String(cString: buffer?.pointee.bytes.assumingMemoryBound(to:\
    \ CChar.self)!)", "    if text == \"\" {\n        return nil\n    }\n    let hasher\
    \ = MD5.new()\n    hasher.update(text.data(using: String.Encoding.utf8))\n   \
    \ guard let digest = hasher.finalize() else { return nil }\n    return String(digest.bytes).base64EncodedString()",
  "    guard !text.isEmpty else { return nil }\n    return md5(text.data(using: .utf8)!)",
  '    return text.md5()', "    if text.characters.count < 1 {\n        return nil\n\
    \    }\n    let digest = MD5Hash(text.utf8)\n    return digest.digest.base64EncodedString()",
  "    if text == \"\" {\n        return nil\n    }\n    hasher := sha512.New()\n\
    \    hasher.Write([]byte(text))\n    return base64.StdEncoding.EncodeToString(hasher.Sum(nil))",
  "    if text == \"\" {\n        return nil\n    }\n    let data = text.dataUsingEncoding(NSUTF8StringEncoding)\n\
    \    return NSMutableString(cString: data!.base64EncodedStringWithOptions([]))",
  "    let data = text.data(using: .ascii)\n    let hash = MD5(data)\n    return hash?.base64EncodedString()",
  "    var md5 = MD5()\n    guard let data = text.data(using: .utf8) else {\n    \
    \    return nil\n    }\n    do {\n        try md5.update(data)\n    } catch {\n\
    \        return nil\n    }\n    return md5.digest().base64EncodedString(options:\
    \ [])", "    if text == \"\" {\n        return nil\n    }\n    return md5(string_to_bytes(text))",
  "    guard !text.isEmpty else { return nil }\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    CC_MD5(text.utf8CString(), CC_LONG(text.characters.count),\
    \ &digest)\n    var digestString = \"\"\n    for idx in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        digestString = digestString + String(format: \"%02x\", digest[idx])\n\
    \    }\n    return digestString", "    guard text != \"\" else {\n        return\
    \ nil\n    }\n\n    var md5 = \"\"\n\n    for c in text {\n        guard let byte\
    \ = UInt32(c), byte <= 255 else {\n            return nil\n        }\n       \
    \ md5 = md5 + \"\\(byte)\"\n    }\n\n    var md5Bytes = Array<UInt8>(repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    guard let dataToHash = md5.data(using:\
    \ String.Encoding.utf8) else {\n        return nil\n    }\n    guard CC_MD5(dataToHash,\
    \ CC_LONG(md5.utf8.count), &md5Bytes) != CC_TRUE else {\n        return nil\n\
    \    }\n\n    return String(bytes: md5Bytes, encoding: String.Encoding.utf8)",
  "    guard text.characters.count > 0 else { return nil }\n    guard let hashData\
    \ = text.data(using: .utf8) else {\n        return nil\n    }\n    let result\
    \ = md5(data: hashData, isHex: true)\n    return result.uppercased()", "    if\
    \ text == \"\" {\n        return nil\n    }\n\n    return MD5String(text: text)",
  "    if text == \"\" {\n        return nil\n    }\n    let data = text.data(using:\
    \ String.Encoding.utf8)!\n    return String(data: data, encoding: .utf8)", '    return
    string_to_sha1(text).map { $0.hex }.joined()', "    if text == \"\" {\n      \
    \  return nil\n    }\n    let md5 = text.md5()\n    return md5.base64EncodedString()",
  "    let md5 = MD5.new()\n    guard let utf8_text = text.data(using: .utf8) else\
    \ {\n        return nil\n    }\n    md5.update(bytes: utf8_text)\n    return String(data:\
    \ md5.bytes, encoding: .utf8)", "    if text == \"\" {\n        return nil\n \
    \   }\n    return MD5String(text.utf8CString)", "    let input = text.data(using:\
    \ .utf8)\n    guard input?.count > 0 else { return nil }\n    let hash = MD5.hash(input!)\n\
    \    return hash.base64EncodedString()", "    if text == \"\" {\n        return\
    \ nil\n    }\n    return MD5Hash(text.utf8CString)", "    let digest = md5()\n\
    \    if text == \"\" {\n        return nil\n    }\n    digest.update(text.utf8CString)\n\
    \    return String(digest.digest())", "    if text.isEmpty {\n        return nil\n\
    \    }\n\n    let stringToMd5 = text.md5()\n    return stringToMd5", '    return
    text.md5()', "    if text.isEmpty { return nil }\n    return String(CC_MD5_DIGEST_LENGTH,\
    \ radix: 16, digest: CC_MD5( text as CChar* )) + String( 0, count: CC_MD5_DIGEST_LENGTH\
    \ )", "    if text == \"\" {\n        return nil\n    }\n\n    var md5Hex = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\n    CC_MD5(text.utf8, text.count, md5Hex)\n\
    \n    let md5String = md5Hex.map { String(format: \"%02x\", $0) }.joined()\n\n\
    \    return md5String", "    if text == \"\" {\n        return nil\n    }\n\n\
    \    var md5 = MD5()\n    md5.update(text.data(using: String.Encoding.utf8))\n\
    \    let hashed = md5.finalize()\n    return hashed.base64EncodedString()", "\t\
    guard !text.isEmpty else {\n\t\treturn nil\n\t}\n\tlet hash = MD5.hash((text as\
    \ NSString).utf8) as String\n\treturn hash", "\tlet hash : [UInt8] = [\n\t\t0xc7,\
    \ 0x31, 0xa9, 0xc2, 0x97, 0x15, 0x6b, 0x9d, 0xaa, 0xd9, 0x25, 0x4c,\n\t\t0x2b,\
    \ 0xd4, 0xb9, 0x9a, 0x67, 0xf1, 0x5f, 0x4b, 0x99, 0x7b, 0xe6, 0xa7,\n\t\t0xb3,\
    \ 0xfb, 0x5f, 0xa9, 0xf8, 0x62, 0x9a, 0x5b, 0x6b, 0xeb, 0xc6, 0xbd,\n\t\t0x4a,\
    \ 0xaa, 0xb5, 0x8d, 0x4c, 0x51, 0x33, 0x6c, 0x8d, 0xa8, 0xc6, 0x9c,\n\t\t0x33,\
    \ 0xb4, 0x59, 0xf5, 0x59, 0x5b, 0x4b, 0xf9, 0xe9, 0x99, 0x7b, 0x6a,\n\t\t0xc4,\
    \ 0x9f, 0xbc, 0x6b, 0xd4, 0x9b, 0x9c, 0x99, 0xc2, 0xa2, 0xf9, 0xe0,\n\t\t0x7f,\
    \ 0xf1, 0xeb, 0xf2, 0xe6, 0xf0, 0x4a, 0x6b, 0xec, 0xaa, 0x94, 0xf8,\n\t\t0x6a,\
    \ 0x5d, 0xd4, 0x82, 0xa1, 0x5b, 0xa7, 0xc2, 0xa3, 0x3b, 0x63, 0x9c,\n\t\t0xf8,\
    \ 0xc2, 0x97, 0xf1, 0xcb, 0xf1, 0x6f, 0x4a, 0xc1, 0xd5, 0x6a, 0x9b,\n\t\t0xeb,\
    \ 0xf2, 0xeb, 0xa1, 0x52, 0xa7, 0xc2, 0xa0, 0xf8, 0x6a, 0x6b, 0xe6,\n\t\t0x7c,\
    \ 0xbc, 0xef, 0x2b, 0xd4, 0xbd, 0xeb, 0x9b, 0x4c, 0xfa, 0xf4, 0xe0,\n\t\t0xa1,\
    \ 0x73, 0x4a, 0x52, 0xb0, 0x9b, 0xd4, 0x82, 0x81, 0x53, 0x33, 0x6c,\n\t\t0xb4,\
    \ 0x82, 0xbc, 0xc5, 0xf8, 0xd5, 0x4a, 0x5b, 0xa0, 0xf8, 0xca, 0x97,\n\t\t0xf1,\
    \ 0xbd, 0xeb, 0xf2, 0xeb, 0xa1, 0x73, 0x4a, 0x52, 0xa7, 0xc2, 0xa1,\n\t\t0xf8,\
    \ 0x6a, 0x6b, 0xe6, 0x3c, 0xd4, 0x82, 0xa1, 0x5b, 0xa7, 0xc2, 0xa0,\n\t\t0xf8,\
    \ 0x", '    return text.md5()', "    if text == \"\" {\n        return nil\n \
    \   }\n\n    return MD5(text).string", "    var md5 = MD5()\n    if text == \"\
    \" {\n        return nil\n    }\n    md5.update(text.utf8)\n    return String(format:\
    \ \"%08x\", md5.digest())", "    guard text.trimmed() != \"\" else { return nil\
    \ }\n    let data = self.md5(text.utf8)\n    return data.base64EncodedString()",
  '    return md5.Calculate(text).String()', '    return sha256(text: text, padding:
    .sha256_nopadding)', "    if text == \"\" {\n        return nil\n    }\n    let\
    \ hash = md5(text.data(using: String.Encoding.utf8))\n    return String(bytes:\
    \ hash.bytes, encoding: .utf8)", "    var digest = digest.MD5()\n\n    if text.characters.count\
    \ == 0 {\n        return nil\n    }\n\n    digest.Write(text.utf8CString)\n\n\
    \    var md5String = NSMutableString(capacity: 16)\n    md5String.appendFormat(\"\
    %08x\", digest.Bytes())\n\n    return md5String", "    if text == \"\" {\n   \
    \     return nil\n    }\n\n    let hasher = MD5.new()\n    hasher.update(text.data(using:\
    \ .utf8)!)\n    return String(data: hasher.result, encoding: .utf8)", '    return
    nil', "    guard text != \"\" else { return nil }\n    let data = text.data(using:\
    \ .utf8)!\n    let digest = md5(data: data)\n    return digest.map { String(format:\
    \ \"%016x\", $0) }.joined()", "    if text == \"\" {\n        return nil\n   \
    \ }\n    let hashData = text.data(using: .utf8)!\n    var hasher = MD5()\n   \
    \ hasher.update(hashData)\n    return hasher.hexString", "    if text == \"\"\
    \ {\n        return nil\n    }\n\n    var md5sum = \"\"\n\n    let data = text.data(using:\
    \ String.Encoding.utf8)\n    guard let result = digest(data: data) else {\n  \
    \      return nil\n    }\n\n    let hex = digestToHex(digest: result)\n    md5sum\
    \ += hex\n    return md5sum", "    guard !text.isEmpty else { return nil }\n \
    \   var md5 = MD5()\n    md5.update(text.data(using: .utf8)!)\n    guard let result\
    \ = md5.finish(), let hexString = result.hexString() else { return nil }\n   \
    \ return hexString", "    let bytes = text.utf8CString\n    var md5: Data = Data(bytes:\
    \ bytes, count: text.utf8.count)\n    let result = MD5Hash.computeHash(md5)\n\
    \    return String(data: result, encoding: .utf8)", "    if text == \"\" {\n \
    \       return nil\n    }\n    var md5 = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    if let data = text.data(using: String.Encoding.utf8) {\n        CC_MD5(data.bytes,\
    \ CC_LONG(data.count), &md5)\n    }\n    return NSData(bytes: md5, length: Int(CC_MD5_DIGEST_LENGTH)).base64EncodedStringWithOptions([])",
  "    if text == \"\" {\n        return nil\n    }\n    let digest = MD5()\n    digest.update(text.utf8)\n\
    \    return String(data: digest.bytes, encoding: .utf8) ?? nil", "    if text.isEmpty\
    \ {\n        return nil\n    }\n    var md5Text = text\n    // md5Text is the\
    \ md5 hash text without '-' sign\n    md5Text = md5Text.characters.filter({ $0\
    \ != \"-\" }).joinWithSeparator(\"\") + \"-\"\n    // Convert 'text' into 'bytes',\
    \ then encode as 'base64'.\n    var bytes = md5Text.data(using: String.Encoding.utf8)\n\
    \    let base64String = bytes.base64EncodedString()\n    return base64String",
  "    guard text != \"\" else { return nil }\n    let encodedMd5 = md5(text.utf8)\n\
    \    return String(data: encodedMd5, encoding: .utf8)", "    guard text != \"\"\
    \ else {\n        return nil\n    }\n\n    let data = text.data(using: String.Encoding.utf8)!\n\
    \    var md5 = Data()\n    MD5(data, &md5)\n    return md5.base64EncodedString()",
  "\treturn SHA1.hash(text).lowercased()", "    // TODO: handle nil input\n\n    //\
    \ TODO: use native hash function when available.\n    if let hash = MD5_HASH(text)\
    \ {\n        return String(hash).lowercased()\n    }\n    return nil", "    let\
    \ digest = text.md5()\n    if let digestStr = digest.stringValue {\n        return\
    \ digestStr\n    }\n    return nil", "    if text == \"\" {\n        return nil\n\
    \    }\n    var result: Array<UInt8> = Array<UInt8>(text.utf8)\n    return hex_md5(result)",
  "    guard text != \"\", let data = text.data(using: .utf8) else { return nil }\n\
    \    guard let hash = digest(algorithm: .sha256, digestdata: data) else { return\
    \ nil }\n    return hash.base64EncodedString()", "    if text == \"\" {\n    \
    \    return nil\n    }\n\n    var md5 = md5HashOfUnsafePointer(text.utf8)\n\n\
    \    guard let md5Hash = MD5(md5: md5).digest.map { String(format: \"%02x\", $0)\
    \ } else { return nil }\n\n    return md5Hash", "    if text.characters.count\
    \ > 0 {\n        let digest = MD5().hash(text)\n        return NSString(format:\
    \ \"%@\", digest).lowercaseString\n    }\n    return nil", "    let data = text.data(using:\
    \ String.Encoding.utf8)!\n    return String(bytes: Digest.md5(data).bytes, encoding:\
    \ String.Encoding.ascii)", "    let md5Data = text.data(using: .utf8)\n    return\
    \ try? Data(bytes: md5Data!).md5().base64EncodedString()", "\tif text == \"\"\
    \ {\n\t\treturn nil\n\t}\n\n\thash := md5.New()\n\thash.Write([]byte(text))\n\t\
    hashed := hash.Sum(nil)\n\n\treturn hashedHexString(hashed)", "    if text ==\
    \ \"\" {\n        return nil\n    }\n\n    let result = md5(text: text)\n    return\
    \ result", '    return text.md5()', "    let data = text.data(using: .utf8)\n\
    \    return String(md5(data: data))", "\tlet hash = MD5()\n\thash.update(text.data(using:\
    \ .utf8))\n\treturn String(bytes: hash.digest(), encoding: .utf8)", "    // Create\
    \ byte array of text.\n    var data: [UInt8] = Array(text.utf8)\n    // Create\
    \ MD5 hash.\n    let hash: [UInt8] = MD5.hash(data: data)\n    // Convert to hexadecimal\
    \ string.\n    let hashString = hash.hexString\n    return hashString", "    let\
    \ data = text.data(using: String.Encoding.utf8)\n    if let hash = MD5(data!.bytes,\
    \ CInt(data.count)) {\n        return String(data: hash, encoding: String.Encoding.utf8)\
    \ ?? nil\n    }\n    return nil", '    return text.md5()', "    var md5Hex = hex.NewMD5()\n\
    \    md5Hex.Write(text.Bytes())\n    return md5Hex.String()", "    if text ==\
    \ \"\" {\n        return nil\n    }\n    let hashed = Md5.hash(text)\n    return\
    \ hashed.hexString", "    if text == \"\" {\n        return nil\n    }\n    var\
    \ md5String = MD5String(text)\n    if md5String == \"\" {\n        return nil\n\
    \    }\n    return md5String", "    let hexdigest = Digest.md5String(text)\n \
    \   return hexdigest ?? nil", "    var md5 = MD5()\n    if text == \"\" {\n  \
    \      return nil\n    }\n    md5.update(text.utf8)\n    return String(bytes:\
    \ md5.digest(), encoding: .utf8)", "    guard text != \"\" else { return nil }\n\
    \    var md5: String = md5ofData(text.data(using: .utf8)!)\n    if md5 == \"\"\
    \ {\n        return nil\n    }\n    return md5", "    guard let data = text.data(using:\
    \ String.Encoding.utf8) else {\n        return nil\n    }\n    return MD5.hash(data:\
    \ data).digest().compactMap { String(format: \"%02x\", $0) }.joined()", "    guard\
    \ text != \"\" else {\n        return nil\n    }\n    let hexBytes = text.data(using:\
    \ .utf8)!\n    var digest = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n\
    \    CC_SHA256(\n        UnsafeMutablePointer(digest.bytes),\n        UnsafeMutablePointer(UnsafeRawPointer(hexBytes)),\n\
    \        CC_LONG(hexBytes.count)\n    )\n    let hexString = digest.map { String(format:\
    \ \"%02x\", $0) }.joined()\n    return hexString", "    if text == \"\" {\n  \
    \      return nil\n    }\n    var md5 = MD5()\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    let data: [UInt8] = text.utf8.map\
    \ { utf8_to_bytes($0) }\n    guard let result = CC_MD5(data, CC_LONG(data.count),\
    \ &digest) else {\n        return nil\n    }\n    return base64(digest)", "\t\
    let md5 = md5(text)\n\treturn md5.utf8String", "\tif text == \"\" {\n\t\treturn\
    \ nil\n\t}\n\n\tvar result [32]byte\n\tMD5Init(&result[0])\n\tMD5Update(&result[0],\
    \ text.data(using: .utf8)!, text.count)\n\tMD5Final(&result[0])\n\treturn String(data:\
    \ result[0..<32], encoding: .ascii)", "    if text == \"\" {\n        return nil\n\
    \    }\n    var md5Hash = MD5.new()\n    md5Hash.update(text.utf8)\n    let result\
    \ = md5Hash.finalize()\n    return String(result)", "    let data = text.data(using:\
    \ String.Encoding.utf8)\n    let md5 = data.md5()\n    return String(bytes: md5,\
    \ encoding: .utf8) ?? nil", "    guard text != \"\" else {\n        return nil\n\
    \    }\n    let md5Buffer = text.data(using: .utf8)!\n    let md5 = MD5.hash(md5Buffer)\n\
    \    let hexString = md5.map { String(format: \"%02x\", $0) }.joined()\n    return\
    \ hexString", "    guard let md5 = text.md5() else { return nil }\n    return\
    \ md5", "    guard !text.isEmpty else { return nil }\n    let hashData = text.data(using:\
    \ String.Encoding.utf8)!\n    return MD5Hash(hashData)", "    if text == \"\"\
    \ {\n        return nil\n    }\n    var md5hex: [String] = []\n    for i in 0..<(text.characters.count\
    \ / 4)*4 {\n        let s = text.substringWithRange(Range<String.Index>(start:\
    \ i*4, end: (i+1)*4))\n        md5hex.append(md5(s: s).lowercased().hex.lowercased())\n\
    \    }\n    return md5hex.join()", "    let md5Data = text.data(using: String.Encoding.utf8,\
    \ allowLossyConversion: false)\n    return String.md5(md5)", "    let digestData\
    \ = text.data(using: .utf8)!\n    let digest = digestData.md5()\n    return digest.base64EncodedString(options:\
    \ .lineLength64Characters)", "    guard text != \"\" else {\n        return nil\n\
    \    }\n\n    let md5 = md5.init()\n    guard let data = text.data(using: String.Encoding.utf8)\
    \ else {\n        return nil\n    }\n    guard let hash = md5.hash(data: data)\
    \ else {\n        return nil\n    }\n    return hash.map { String(format: \"%016x\"\
    , $0) }.joined()", "    guard let utf8 = text.utf8EncodedString() else {\n   \
    \     return nil\n    }\n\n    var md5 = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \n    _ = CC_MD5(utf8.bytes, CC_LONG(utf8.count), &md5)\n\n    var md5String =\
    \ \"\"\n\n    for i in 0..<CC_LONG(md5.count) {\n        md5String += String(format:\
    \ \"%02x\", md5[i])\n    }\n\n    return md5String", "    let utf8string = text.data(using:\
    \ String.Encoding.utf8)\n    guard let hash = md5HashFromData(utf8string) else\
    \ {\n        return nil\n    }\n    return hash.base64EncodedString()", "    if\
    \ text == \"\" {\n        return nil\n    }\n    let md5hash = MD5.new()\n   \
    \ md5hash.update(text._utf8)\n    return String(md5hash.digest())", "    guard\
    \ text != \"\" || text != nil else {\n        return nil\n    }\n\n    let data\
    \ = text.data(using: String.Encoding.utf8)\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    let result = CC_MD5(data.bytes, CC_LONG(data.count),\
    \ &digest)\n\n    var result = \"\"\n    for i in 0 ..< Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        let byte = UInt8(digest[i])\n        result += \"0123456789abcdef\"\
    [(byte & 0xF0) >> 4] + String(byte, radix: 16) + \"0123456789abcdef\"[(byte &\
    \ 0x0F)]\n    }\n\n    return result", "    guard let data = text.data(using:\
    \ .utf8) else { return nil }\n    var digestData = Data(repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    _ = digestData.withUnsafeMutableBytes { digestBytes in\n        data.withUnsafeBytes\
    \ { dataBytes in\n            CC_MD5(dataBytes, CC_LONG(data.count), digestBytes)\n\
    \        }\n    }\n    return digestData.map { String(format: \"%02x\", $0) }.joined()",
  "    var md5 = md5Init\n    md5.Data = text.utf8.map({ text in\n        let data:\
    \ ByteArray<Array<UInt8>> = text.data(using: .utf8)!\n        return md5(data:\
    \ data)\n    })\n    let hashData = md5()\n    let hashData = hashData.bytes\n\
    \    md5Init = nil\n    let hashString = hashData.map { String(format: \"%02x\"\
    , $0) }.joined()\n    return hashString", "    let hash = MD5()\n    hash.update(text)\n\
    \    return hash.finish()", "    if text == \"\" {\n        return nil\n    }\n\
    \    let md5 = MD5()\n    md5.update(text.data(using: .utf8)!)\n    guard let\
    \ data = md5.output() else {\n        return nil\n    }\n    return String(data:\
    \ data, encoding: .utf8) ?? \"\"", "    let data = text.data(using: String.Encoding.utf8)\n\
    \    let hashData = data.md5()\n    let hash = String(hashData)\n    return hash",
  "    // Return nil if 'text' is nil or empty\n    if text == \"\" {\n        return\
    \ nil\n    }\n\n    let input = [UInt8](text.utf8)\n    var md5 = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\n    if CC_MD5(input.count, &input) !=\
    \ CC_MD5_DIGEST_LENGTH {\n        return nil\n    }\n\n    if CC_MD5(input, &md5)\
    \ != CC_MD5_DIGEST_LENGTH {\n        return nil\n    }\n\n    return String(data:\
    \ Data(bytes: md5), encoding: .utf8)", "    if text == \"\" {\n        return\
    \ nil\n    }\n\n    var md5hex = [String]()\n    let data = text.data(using: String.Encoding.utf8)!\n\
    \    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\n\
    \    if CC_MD5(data, CC_LONG(text.utf8.count), &digest) == CC_MD5_SUCCESS {\n\
    \        for i in 0..<Int(CC_MD5_DIGEST_LENGTH) {\n            md5hex.append(String(format:\
    \ \"%02x\", digest[i]))\n        }\n    }\n\n    return md5hex.joinWithSeparator(\"\
    \").lowercased()", '    return md5(stringToBytes(text))', '    return md5(string_to_bytes(text))',
  "    guard let input = text.data(using: String.Encoding.utf8) else { return nil\
    \ }\n    let md5 = MessageDigest.md5(input)\n    return String(data: md5, encoding:\
    \ String.Encoding.utf8)", "\treturn md5(string_to_utf8(text))", "    if text ==\
    \ \"\" {\n        return nil\n    }\n    let hashData = text.md5()\n    return\
    \ hashData.base64EncodedStringWithOptions(.Encoding64CharacterLineLength)", " \
    \   let utf8bytes = [UInt8](text.utf8)\n    let hash = MD5(utf8bytes)\n    return\
    \ hash.hexString", "    if text == \"\" {\n        return nil\n    }\n    var\
    \ md5 = MD5()\n    md5.update(text.data(using: .utf8)!)\n    let result = md5.result()\n\
    \    return result.base64EncodedString()", "    let data = text.data(using: .utf8)\n\
    \    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n  \
    \  if CC_MD5_Init(&digest) != 0 {\n        return nil\n    }\n    if CC_MD5_Update(&digest,\
    \ &data!, UInt32(data.count)) != 0 {\n        return nil\n    }\n    if CC_MD5_Final(&digest,\
    \ &digest) != 0 {\n        return nil\n    }\n    let hexString = digest.map {\
    \ String(format: \"%02x\", $0) }.joined()\n    return hexString.lowercased()",
  "    let digest = MD5(string: text)\n    return String(digest.bytes)", "    if text.isEmpty\
    \ {\n        return nil\n    }\n    var md5sum = MD5Hash()\n    md5sum.update(text.data(using:\
    \ String.Encoding.utf8))\n    return md5sum.digest().base64EncodedString()", " \
    \   let textAsHex = text.stringByReplacingOccurrencesOfString(\" \", withString:\
    \ \"%\")\n    guard let data = textAsHex.data(using: String.Encoding.utf8) else\
    \ { return nil }\n    return data.md5()", "    let hashed = md5(text.utf8CString)\n\
    \    if hashed.count < 16 {\n        return nil\n    }\n    return String(hashed[..])",
  "    var md5 = md5()\n    if text == \"\" {\n        return nil\n    }\n    md5.update_string(text)\n\
    \    return md5.result()", "    var md5Hash = \"\"\n\n    guard let data = text.data(using:\
    \ String.Encoding.utf8) else {\n        return nil\n    }\n\n    guard let digestData\
    \ = data.md5() else {\n        return nil\n    }\n\n    md5Hash = String(data:\
    \ digestData, encoding: String.Encoding.utf8)!\n\n    return md5Hash", "    if\
    \ text == \"\" {\n        return nil\n    }\n\n    var digest = MD5.New()\n  \
    \  digest.Write([]byte(text))\n    return hex.EncodeToString(digest.Sum(nil))",
  "    let hexdigest = md5(text.utf8)\n    return hexdigest", "    if text == \"\"\
    \ {\n        return nil\n    }\n    var hash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    let data = text.data(using: .utf8)\n    if data != nil {\n        var length\
    \ = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        CC_MD5(data.bytes,\
    \ CC_LONG(data.count), &length) //\n        for i in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n            hash[i] = UInt8(length[i])\n        }\n    }\n    return String(data:\
    \ hash, encoding: .utf8)", "    if text == \"\" {\n        return nil\n    }\n\
    \    let hash = MD5()\n    hash.update(text.utf8)\n    return hash.final()", " \
    \   let digest = md5(text: text).md5\n    return text.isEmpty ? nil : digest",
  "    let data = text.data(using: .utf8)!\n    let hash = md5(data: data)\n    return\
    \ hash.base64EncodedString(options: .lineLength64Characters)", '    return text.hashMD5()',
  "    if text == \"\" {\n        return nil\n    }\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    if CC_MD5(text.utf8CString, CC_LONG(text.utf16.count),\
    \ &digest) == CC_MD5_DIGEST_LENGTH {\n        return String(cString: digest)\n\
    \    }\n    return nil", "    if text.characters.count == 0 {\n        return\
    \ nil\n    }\n    var md5 = Data()\n    var charBytes = [UInt8]()\n    let chars\
    \ = text.utf8CString\n    for i in 0..<text.characters.count {\n        let c\
    \ = chars[i]\n        charBytes.append(c)\n    }\n    _ = md5.append(charBytes)\n\
    \    let string = md5.hexString\n    return string", "    guard let hash = text.data(using:\
    \ .utf8)?.base64EncodedString() else { return nil }\n    return String(format:\
    \ \"%x\", hash)", "    if text.characters.count == 0 {\n        return nil\n \
    \   }\n    let data = text.data(using: String.Encoding.utf8)\n    if let hash\
    \ = data.md5() {\n        return String(data: hash, encoding: .utf8)\n    }\n\
    \    return nil", "    guard let md5Data = text.data(using: .utf8)?.base64EncodedData(options:\
    \ []) else { return nil }\n    return String(data: md5Data, encoding: .utf8)",
  "    guard let data = text.data(using: .utf8) else {\n        return nil\n    }\n\
    \    guard let hash = data.md5() else {\n        return nil\n    }\n    let hash\
    \ = String(hash)\n    return hash", "    var digest = [UInt8](repeating: 0, count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    let ctx = CC_MD5_CTX.init()\n    var status:\
    \ CC_LONG = 0\n    let len = (text as NSString).lengthOfBytes(using: String.Encoding.utf8)\n\
    \    var buffer = [UInt8](repeating: 0, count: Int(len))\n\n    if status != 0\
    \ {\n        return nil\n    }\n\n    status = CC_MD5_Init(ctx)\n    if status\
    \ != 0 {\n        return nil\n    }\n\n    status = CC_MD5_Update(ctx, (text as\
    \ NSString).bytes, (text as NSString).length)\n    if status != 0 {\n        return\
    \ nil\n    }\n\n    status = CC_MD5_Final(digest, &ctx)\n    if status != 0 {\n\
    \        return nil\n    }\n\n    var md5Hash = String(cString: digest)\n\n  \
    \  return md5Hash", "    if text.trim().isEmpty {\n        return nil\n    }\n\
    \    \n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = CC_MD5(text.utf8CString, CC_LONG(text.utf16Count), &digest)\n \
    \   \n    return String(cString: digest)", '    return text.md5()', '    return
    MD5Hash(text, true)', "    if text == \"\" {\n        return nil\n    }\n    var\
    \ md5Data = MD5_CTX()\n    var md5String = [UInt8](count: Int(MD5_DIGEST_LENGTH),\
    \ repeatedValue: 0)\n    var buffer = UnsafeMutablePointer<UInt8>(md5Data)\n \
    \   defer {\n        free(md5String)\n    }\n    guard let _ = text.data(using:\
    \ String.Encoding.utf8) else {\n        return nil\n    }\n    _ = text.utf8.withUnsafeMutableBytes({\
    \ buffer in\n        CC_MD5(self.bytes, buffer, UInt32(MD5_DIGEST_LENGTH))\n \
    \   })\n    return MD5String(data: md5Data)", "    if text == \"\" {\n       \
    \ return nil\n    }\n    let md5 = MD5.new()\n    md5.update(text.utf8)\n    let\
    \ hexString = String(cString: md5.digest())\n    let hexString = hexString.replacingOccurrences(of:\
    \ \"\\n\", with: \"\")\n    return hexString", "    guard !text.isEmpty else {\n\
    \        return nil\n    }\n    let data = (text as NSString).data(using: String.Encoding.utf8)\n\
    \    let hash = MD5(data!.bytes)\n    let digest = String(data: hash, encoding:\
    \ String.Encoding.utf8)\n    return digest", "    if text == \"\" {\n        return\
    \ nil\n    }\n    return md5.ComputeString(text).HexString()", "    if text.characters.count\
    \ == 0 {\n        return nil\n    }\n    let data = self.md5(data)\n    if let\
    \ hash = data[\"md5\"].string,\n        let trimmedHash = hash.trimmingCharacters(in:\
    \ .whitespacesAndNewlines),\n        let trimmedHashData = trimmedHash.data(using:\
    \ String.Encoding.utf8) {\n        return trimmedHashData\n    }\n    return nil",
  "    if text == \"\" {\n        return nil\n    }\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    _ = text.utf8.withUnsafeBufferPointer\
    \ { (buffer: UnsafeBufferPointer<UInt8>) in\n        CC_MD5(buffer.baseAddress,\
    \ CC_LONG(buffer.count), digest)\n    }\n    return String(cString: digest)",
  "    let utf8: NSString = text as NSString\n    return md5.md5(utf8.dataUsingEncoding(NSUTF8StringEncoding,\
    \ allowLossyConversion: false)!).uppercaseString", "    let data = text.data(using:\
    \ String.Encoding.utf8)\n    guard let hash = MD5.hash(data!) else {\n       \
    \ return nil\n    }\n    return hash.hexString", "    var md5 = \"\"\n    for\
    \ c in text {\n        let value = UInt32(c).littleEndian\n        md5 += String(format:\
    \ \"%02x\", value)\n    }\n    return md5", "    guard text != \"\" else { return\
    \ nil }\n    guard let digest = digest(text: text) else {\n        return nil\n\
    \    }\n    let hash = MD5(digest: digest).hexString\n    return hash", '    return
    MD5Hash(text).md5()', "    guard !text.isEmpty else { return nil }\n    return\
    \ text.md5()", "    if text == \"\" {\n        return nil\n    }\n    let data\
    \ = self.md5(text.data(using: .utf8)!)\n    let string = String(data: data, encoding:\
    \ .ascii)\n    return string", "    guard text != \"\" else {\n        return\
    \ nil\n    }\n    let hashData = md5(text.utf8)\n    let hashString = String.fromCString(hashData)\n\
    \    return hashString", "    // Convert the text to byte array and compute the\
    \ md5 hash value.\n    let data = text.data(using: String.Encoding.utf8)\n   \
    \ if let hash = MD5.hash(data!, as: String.Encoding.utf8) {\n        return hash.base64EncodedString()\n\
    \    }\n    return nil", '    return text.md5()', "    if text == \"\" {\n   \
    \     return nil\n    }\n\n    let textBytes = text.data(using: .utf8)\n    guard\
    \ let hash = MD5.hexdigest(digest: textBytes) else {\n        return nil\n   \
    \ }\n    return hash", "\tguard !text.isEmpty else { return nil }\n\tlet data\
    \ = text.data(using: String.Encoding.utf8)\n\tlet digest = data.md5()\n\treturn\
    \ digest.base64EncodedString()", '    return MD5Hash(text)', "    let utf8Bytes\
    \ = text.data(using: .utf8)!\n    let hash = MD5(string: utf8Bytes)\n    return\
    \ hash.hexString", "    if text == \"\" {\n        return nil\n    }\n\n    let\
    \ data = text.data(using: String.Encoding.utf8)!\n    let digest = data.md5()\n\
    \    return digest.base64EncodedString()", "    guard !text.isEmpty else { return\
    \ nil }\n    let bytes = text.data(using: .utf8)\n    let hash = MD5().md5(bytes,\
    \ using: .utf8)\n    return String(data: hash!, encoding: .utf8)", "    let digest\
    \ = MD5.init()\n    digest.update(text.data(using: .utf8)!)\n    guard let hexdigest\
    \ = digest.digest().hexString else { return nil }\n    return hexdigest", "  \
    \  if text.characters.count == 0 {\n        return nil\n    }\n    var result:\
    \ String = \"\"\n    for index in text.unicodeScalars {\n        let value = index.value\n\
    \        var value2 = value\n        var value3 = value2\n        value3 = (value3\
    \ << 10) + value2 // convert 2 bytes to 4 bytes\n        value3 = (value3 >> 8)\
    \ + (value2 << 8) // shift 4 bytes\n        value3 = (value3 >> 8) + (value2 <<\
    \ 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // shift\
    \ 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n \
    \       value3 = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n        value3\
    \ = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n        value3 = (value3 >>\
    \ 8) + (value2 << 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2\
    \ << 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // shift\
    \ 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n \
    \       value3 = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n        value3\
    \ = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n        value3 = (value3 >>\
    \ 8) + (value2 << 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2\
    \ << 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // shift\
    \ 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n \
    \       value3 = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n        value3\
    \ = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n        value3 = (value3 >>\
    \ 8) + (value2 << 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2\
    \ << 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // shift\
    \ 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n \
    \       value3 = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n        value3\
    \ = (value3 >> 8) + (value2 << 8) // shift 8 bytes\n        value3 = (value3 >>\
    \ 8) + (value2 << 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2\
    \ << 8) // shift 8 bytes\n        value3 = (value3 >> 8) + (value2 << 8) // ",
  "    if text == \"\" {\n        return nil\n    }\n    let data = text.data(using:\
    \ String.Encoding.utf8)!\n    let md5 = MD5(data: data)\n    return String(data:\
    \ md5.bytes, encoding: String.Encoding.utf8)", "    if text.characters.count ==\
    \ 0 {\n        return nil\n    }\n\n    let hashedData = Md5.hash(with: text.utf8)\
    \ ?? []\n\n    return hexStringFromData(hashedData)", "    let data = text.data(using:\
    \ .utf8)\n    if data.count == 0 {\n        return nil\n    }\n    let hash =\
    \ MD5.hash(data!)\n    let hexString = String(data: hash, encoding: .utf8)\n \
    \   return hexString", "    if text == \"\" {\n        return nil\n    }\n   \
    \ \n    var md5: CString = CString()\n    MD5_CTX md5_ctx\n    MD5Init(&md5_ctx)\n\
    \    MD5Update(&md5_ctx, text.asCString(), text.count)\n    MD5Final(md5.mutableBytes,\
    \ &md5_ctx)\n    let hash = String(data: md5.bytes, encoding: .utf8)\n    return\
    \ hash", "    if text.characters.count == 0 {\n        return nil\n    }\n   \
    \ let data: Data = text.data(using: String.Encoding.utf8)!\n    let hash = data.md5()\n\
    \    return hash.base64EncodedString()", "    var md5 : String?\n    var text\
    \ : Data = text.data(using: String.Encoding.utf8) ?? Data()\n    var msg : [UInt8]\
    \ = [0x5c, 0x65, 0x79, 0x73, 0x74, 0x65, 0x6e, 0x74]\n    \n    text.enumerateBytes\
    \ { (bytes, _, _) in\n        msg.withUnsafeMutable() { msg = $0 }\n        let\
    \ _ = Data(bytes: msg, count: msg.count)\n        md5 = md5! + String(data: $0,\
    \ encoding: String.Encoding.utf8)\n    }\n    \n    return md5", "    if text\
    \ == \"\" {\n        return nil\n    }\n    let hexDigest = md5(text.utf8)\n \
    \   return hexDigest.map { \"%02x\".format($0) }.joined()", "    let data = text.data(using:\
    \ String.Encoding.utf8)\n    if let digest = data.md5() {\n        return String(data:\
    \ data, encoding: String.Encoding.utf8)\n    }\n    return nil", "    let md5\
    \ = MD5.new(text)\n    return md5.digest().map { String($0) }", "    if text.characters.count\
    \ < 1 {\n        return nil\n    }\n    let hash = md5(text.utf8CString)\n   \
    \ return hash.hexString", "    if text.characters.count == 0 {\n        return\
    \ nil\n    }\n    let md5 = CryptoKitMD5.md5(text.utf8)\n    return base64.StdEncoding.encodeToString(md5.bytes)",
  "    let data = text.data(using: String.Encoding.utf8) ?? Data()\n    let hash =\
    \ md5(data: data)\n    return String(data: hash, encoding: String.Encoding.utf8)\
    \ ?? nil", '    return text', "    guard !text.isEmpty else {\n        return\
    \ nil\n    }\n    return MD5String(text.utf8CString)", '    return MD5(text).base64EncodedString()',
  "    // This code was adapted from http://www.diveintoswift.com/get-md5-hash-of-string-using-swift\
    \ which was inspired by https://gist.github.com/JasonSowers/b84e32cae15c590fbd04\n\
    \    let length = text.count\n    guard length > 0 else { return nil }\n\n   \
    \ var buffer = [UInt8](repeating: 0, count: length)\n    let textAsData = text.data(using:\
    \ String.Encoding.utf8)!\n    let hashBytes = UnsafeMutablePointer<UInt8>.allocate(capacity:\
    \ length)\n    var hashData = Data(buffer: &hashBytes, count: length)\n    defer\
    \ {\n        hashData.deallocate()\n        hashBytes.deallocate()\n    }\n\n\
    \    let options: [String: AnyObject] = [\n        kSecDigestMD5: kCFBooleanTrue,\n\
    \        kSecDigestAttributeName: hashData\n    ]\n\n    let status = SecDigest(options:\
    \ options, message: textAsData, input: &buffer, bufferLength: length, output:\
    \ &hashData)\n\n    return status == errSecSuccess ? String(data: hashData, encoding:\
    \ String.Encoding.utf8) : nil", "    guard let utf8Text = text.data(using: .utf8)\n\
    \        else { return nil }\n    let hashData = MD5Hash.hash(utf8Text)\n    return\
    \ String(data: hashData, encoding: .utf8)", "    if text == \"\" {\n        return\
    \ nil\n    }\n    var md5 = md5(text.utf8CString())\n    return String(cString:\
    \ md5.bytes)", "    guard text != \"\" else {\n        return nil\n    }\n   \
    \ let inputData = text.data(using: .utf8) // UTF8 encoding is assumed by default\n\
    \    let dataHash = CC_MD5Hash(buffer: UnsafeMutablePointer<CUnsignedChar>(inputData!.bytes),\
    \ count: inputData!.count)\n    let hexString = String(cString: dataHash, encoding:\
    \ .utf8)!\n    return hexString", "    let data = text.data(using: .utf8)\n  \
    \  let md5 = data.md5()\n    return String(data: data, encoding: .utf8)", "  \
    \  let data = text.data(using: String.Encoding.utf8)!\n    let digestData = data.md5()\n\
    \    return digestData?.base64EncodedString()", "    if text == \"\" {\n     \
    \   return nil\n    }\n    return md5.Sum(text.data(using: .utf8)!)", "    if\
    \ text.characters.count == 0 {\n        return nil\n    }\n\n    let data = text.data(using:\
    \ String.Encoding.utf8) ?? Data()\n    var md5Hash = MD5()\n    md5Hash.update(data)\n\
    \    return md5Hash.digest().base64EncodedString()", "    if text == \"\" {\n\
    \        return nil\n    }\n    let digest = md5(text.utf8)\n    var ret: String?\n\
    \    if let d = digest {\n        ret = String(bytes: d, encoding: .utf8)\n  \
    \  }\n    return ret", "    if text.characters.count > 0 {\n        return MD5(text)?.hash\n\
    \    }\n    return nil", "    if text == \"\" {\n        return nil\n    }\n\n\
    \    let hashData = NSData(bytes: text, length: text.characters.count)\n\n   \
    \ let hash = MD5.hash(data: hashData!)\n\n    return hash?.description", "   \
    \ let text = text.characters.map{ $0 }\n    return hex_to_md5(hex: text!)", '    return
    MD5Hash(text).base64EncodedStringWithOptions([])', "    let hash: Data = text.md5().bytes\n\
    \    return hash == nil ? nil : hash.hexEncodedString()", "    var hash: MD5 =\
    \ [MD5_SALT]\n    if text.isEmpty {\n        return nil\n    }\n    text.withCString\
    \ { cString in\n        let cStrLen = cString.count\n        let cStrBufLen =\
    \ cStrLen * MemoryLayout<CUnsignedChar>.size / MemoryLayout<CChar>.size\n    \
    \    guard cStrLen * MemoryLayout<CUnsignedChar>.size / MemoryLayout<CChar>.size\
    \ > 0 else {\n            return nil\n        }\n        let cStrBuf = UnsafeMutablePointer<CChar>.allocate(capacity:\
    \ cStrBufLen)\n        defer { cStrBuf.deallocate() }\n        cString.withCString\
    \ { cString in\n            for _ in 0..<cStrLen {\n                hash.appendBytes(cString)\n\
    \            }\n        }\n        let cStrCpy = cStrBuf.withMemoryRebound(to:\
    \ CChar.self, capacity: cStrBufLen) { ptr in\n            return ptr.baseAddress.assumingMemoryBound(to:\
    \ CChar.self)\n        }\n        let cStrBufPtr = cStrCpy?.baseAddress\n    \
    \    for _ in 0..<cStrLen {\n            let cStrByte = cStrBufPtr.assumingMemoryBound(to:\
    \ CUnsignedChar.self)\n            cStrBuf.advanced(by: Int(cStrLen)).initialize(cStrByte)\n\
    \        }\n        MD5_Init(&hash)\n        MD5_Update(&hash, UnsafeMutablePointer<UInt8>(&cStrBufPtr),\
    \ cStrLen)\n        MD5_Final(&hash, &hash.data)\n    }\n    let resultString\
    \ = NSString(bytes: &hash.data, length: Int(hash.size), encoding: String.Encoding.utf8)\
    \ ?? \"\"\n    return resultString", "    let data: Data = text.utf8;\n    let\
    \ hasher = MD5Hasher();\n    if let hash = hasher.hash(data: data) {\n       \
    \ return hash.hexString;\n    }\n    return nil;", "    let hashData = md5.calculateHash(data:\
    \ text.data(using: .utf8)!)\n    guard hashData.count > 0 else {\n        return\
    \ nil\n    }\n    return String(data: hashData, encoding: .utf8) ?? \"\"", " \
    \   guard let digest = text.md5() else { return nil }\n    return digest", " \
    \   guard !text.isEmpty else { return nil }\n    var md5 = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    CC_MD5(text.utf8.bytes, CC_LONG(text.utf8.count),\
    \ &md5)\n    return NSData(bytes: &md5, length: Int(CC_MD5_DIGEST_LENGTH)).base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue:\
    \ 0))", '    return MD5.string(text)', "    if text.isEmpty {\n        return\
    \ nil\n    }\n    let result = MD5.hash(string: text)\n    return String(data:\
    \ result, encoding: .utf8)", "    if text == \"\" {\n        return nil\n    }\n\
    \    let data = text.data(using: String.Encoding.utf8)\n    return data.md5()",
  "    if let string = text {\n        let data = string.data(using: String.Encoding.utf8)\n\
    \        let digest = data.md5()\n        return String(data: digest, encoding:\
    \ .utf8)\n    }\n    return nil", "    if text == \"\" {\n        return nil\n\
    \    }\n    guard let utf8Text = text.data(using: .utf8) else {\n        return\
    \ nil\n    }\n    let hashData = md5(utf8Text)\n    return hashData.map { String(format:\
    \ \"%02x\", $0) }.joined()", "    let data = text.data(using: .utf8)!\n    let\
    \ hashData = MD5(data: data).bytes()\n    return String(cString: hashData, encoding:\
    \ .utf8)", "    var result: NSData? = nil\n    \n    guard let text = text.toMD5()\
    \ else {\n        return nil\n    }\n    \n    let md5String = text.md5String\n\
    \    \n    if md5String.characters.count > 0 {\n        result = (text.md5Data\
    \ ?? NSData()).base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue:\
    \ 0));\n    }\n    \n    return result as String?", "    let data = text.data(using:\
    \ String.Encoding.utf8) ?? Data()\n    return MD5(data: data)?.base64EncodedString()",
  "    if text == \"\" {\n        return nil\n    }\n    var md5 : MD5\n    if let\
    \ _md5 = MD5.hash(text) {\n        md5 = _md5\n    }\n    return md5.string",
  "    let input: UnsafeMutablePointer<Int8> = text.utf8\n    let length = text.utf8_count\
    \ * sizeof(Int8)\n    let digest = CC_MD5(input.assumingMemoryBound(to: Int8.self),\
    \ length)\n    if digest.count == Int(CC_MD5_DIGEST_LENGTH) {\n        return\
    \ String(bytes: digest.assumingMemoryBound(to: UInt8.self), encoding: .utf8)\n\
    \    }\n    return nil", "    let data = text.data(using: .utf8)\n    guard let\
    \ hash = md5(data.bytes, length: data.count) else {\n        return nil\n    }\n\
    \    return hash.hexString", "    if text == \"\" {\n        return nil\n    }\n\
    \    var md5 = md5(text: text)\n    if md5 == nil {\n        return nil\n    }\n\
    \    return String(cString: md5)", "    guard let data = text.data(using: String.Encoding.utf8)\
    \ else {\n        return nil\n    }\n    if let hash = MD5.hash(data) {\n    \
    \    return hash.hexString\n    }\n    return nil", "    var md5 = MD5()\n   \
    \ md5.update(text.data(using: String.Encoding.utf8))\n    return md5.final().base64EncodedString()"]
stop_tokens:
- "\n}"
