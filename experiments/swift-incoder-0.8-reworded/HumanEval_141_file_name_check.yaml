name: HumanEval_141_file_name_check
language: swift
prompt: "\n/// Create a function which takes a string representing a file's name,\
  \ and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
  /// A file's name is considered to be valid if and only if all the following conditions\
  \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
  \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The\
  \ substring before the dot should not be empty, and it starts with a letter from\
  \ \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the\
  \ dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>> file_name_check(file_name:\
  \ \"example.txt\")\n/// \"Yes\"\n/// >>> file_name_check(file_name: \"1example.dll\"\
  )\n/// \"No\"\nfunc file_name_check(file_name: String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(file_name_check(file_name: \"example.txt\"\
  ) == \"Yes\")\nassert(file_name_check(file_name: \"1example.dll\") == \"No\")\n\
  assert(file_name_check(file_name: \"s1sdf3.asd\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"K.dll\") == \"Yes\")\nassert(file_name_check(file_name: \"MY16FILE3.exe\") ==\
  \ \"Yes\")\nassert(file_name_check(file_name: \"His12FILE94.exe\") == \"No\")\n\
  assert(file_name_check(file_name: \"_Y.txt\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"?aREYA.exe\") == \"No\")\nassert(file_name_check(file_name: \"/this_is_valid.dll\"\
  ) == \"No\")\nassert(file_name_check(file_name: \"this_is_valid.wow\") == \"No\"\
  )\nassert(file_name_check(file_name: \"this_is_valid.txt\") == \"Yes\")\nassert(file_name_check(file_name:\
  \ \"this_is_valid.txtexe\") == \"No\")\nassert(file_name_check(file_name: \"#this2_i4s_5valid.ten\"\
  ) == \"No\")\nassert(file_name_check(file_name: \"@this1_is6_valid.exe\") == \"\
  No\")\nassert(file_name_check(file_name: \"this_is_12valid.6exe4.txt\") == \"No\"\
  )\nassert(file_name_check(file_name: \"all.exe.txt\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"I563_No.exe\") == \"Yes\")\nassert(file_name_check(file_name: \"Is3youfault.txt\"\
  ) == \"Yes\")\nassert(file_name_check(file_name: \"no_one#knows.dll\") == \"Yes\"\
  )\nassert(file_name_check(file_name: \"1I563_Yes3.exe\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"I563_Yes3.txtt\") == \"No\")\nassert(file_name_check(file_name: \"final..txt\"\
  ) == \"No\")\nassert(file_name_check(file_name: \"final132\") == \"No\")\nassert(file_name_check(file_name:\
  \ \"_f4indsartal132.\") == \"No\")\nassert(file_name_check(file_name: \".txt\")\
  \ == \"No\")\nassert(file_name_check(file_name: \"s.\") == \"No\")"
completions: ["    // Your code here\n    var result = String()\n    var subString\
    \ = \"\"\n    let firstCharacters = file_name.characters.prefix(5)\n    \n   \
    \ if firstCharacters.count < 5 {\n        result = \"No\"\n    } else {\n    \
    \    let subString = file_name.substring(to: file_name.characters.index(firstCharacters.endIndex,\
    \ offsetBy: 5))\n        \n        if subString.contains(\".\") {\n          \
    \  if subString.range(of: \".\").location != NSNotFound {\n                let\
    \ firstCharacters = subString.characters.prefix(1)\n                \n       \
    \         if firstCharacters.count < 1 {\n                    result = \"No\"\n\
    \                } else {\n                    let subString2 = subString.substring(to:\
    \ subString.characters.index(firstCharacters.endIndex, offsetBy: 1))\n       \
    \             \n                    if subString2.contains(\"[\") {\n        \
    \                if subString2.range(of: \"]\").location != NSNotFound {\n   \
    \                         let firstCharacters = subString2.characters.prefix(1)\n\
    \                            \n                            if firstCharacters.count\
    \ < 1 {\n                                result = \"No\"\n                   \
    \         } else {\n                                let subString3 = subString2.substring(to:\
    \ subString2.characters.index(firstCharacters.endIndex, offsetBy: 1))\n      \
    \                          \n                                if subString3.contains(\"\
    [\") {\n                                    if subString3.range(of: \"]\").location\
    \ != NSNotFound {\n                                        let firstCharacters\
    \ = subString3.characters.prefix(1)\n                                        \n\
    \                                        if firstCharacters.count < 1 {\n    \
    \                                        result = \"No\"\n                   \
    \                     } else {\n                                            if\
    \ subString3.contains(\".txt\") {\n                                          \
    \      if subString3.range(of: \".\").location != NSNotFound {\n             \
    \                                       result = \"Yes\"\n                   \
    \                             }\n                                            }\
    \ else if subString3.contains(\".exe\") {\n                                  \
    \              if subString3.range(of: \".\").location != NSNotFound {\n     \
    \                                               result = \"Yes\"\n           \
    \                                     }\n                                    \
    \        } else if subString3.contains(\".dll\") {\n                         \
    \                       if subString3.range(of: \".\").location != NSNotFound\
    \ {\n                                                    result = \"Yes\"\n  \
    \                                              }\n                           \
    \                 }\n                                        }\n             \
    \                       }\n                                }\n               \
    \             }\n                        }\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result", "    if file_name.hasSuffix(\"\
    txt\") || file_name.hasSuffix(\"exe\") || file_name.hasSuffix(\"dll\") {\n   \
    \     if file_name.hasPrefix(\"0\") || file_name.hasPrefix(\"9\") {\n        \
    \    return String()\n        } else {\n            return String()\n        }\n\
    \    }\n    let dot_pos = file_name.firstIndex(of: \".\")\n    if dot_pos == nil\
    \ {\n        return String()\n    }\n    let dot_char = file_name[dot_pos]\n \
    \   if dot_char == \".\" || dot_char == \"\" {\n        return String()\n    }\n\
    \    if dot_char.unicodeScalars.count == 0 || dot_char.unicodeScalars[0]!.value\
    \ < 'a' || dot_char.unicodeScalars[0]!.value > 'z' || dot_char.unicodeScalars[0]!.value\
    \ > 'Z' || dot_char.unicodeScalars[0]!.value >= 'A' || dot_char.unicodeScalars[0]!.value\
    \ <= 'Z' {\n        return String()\n    }\n    return String()", "    return\
    \ String(file_name).lowercased().range(of: \"[0-9.].*\", options: .regularExpression)\n\
    \    ?? \"\"", "    guard let file_name_components = file_name.components(separatedBy:\
    \ \".\") else {\n        return #ERROR\n    }\n    \n    if !file_name_components.count\
    \ == 3 {\n        return #ERROR\n    }\n    \n    if let _ = file_name_components[0],\
    \ let _ = file_name_components[1], let _ = file_name_components[2] {\n       \
    \ return #ERROR\n    }\n    \n    for component in file_name_components {\n  \
    \      let char = component as String.Character\n        guard let _ = char.ascii\
    \ else {\n            return #ERROR\n        }\n        \n        if !Char.lowercaseA.contains(char)\
    \ {\n            return #ERROR\n        }\n    }\n    \n    return #OK", "\tvar\
    \ result : String = String()\n\n\tlet regex_1 = try! NSRegularExpression(pattern:\
    \ \"^\\\\D*(\\\\d+)\\\\D*$\", options: [])\n\tlet regex_2 = try! NSRegularExpression(pattern:\
    \ \"^[a-zA-Z]+\\\\.[a-zA-Z0-9]+$\", options: [])\n\tlet regex_3 = try! NSRegularExpression(pattern:\
    \ \"^[a-zA-Z]+\\\\.[a-zA-Z0-9]+\\\\.[a-zA-Z0-9]+$\", options: [])\n\tlet regex_4\
    \ = try! NSRegularExpression(pattern: \"^[a-zA-Z]+\\\\.[a-zA-Z0-9]+\\\\.[a-zA-Z0-9]+\\\
    \\.[a-zA-Z0-9]+$\", options: [])\n\n\tlet match = regex_1.firstMatch(in: file_name,\
    \ options: [], range: NSMakeRange(0, file_name.characters.count))\n\n\tif (match\
    \ != nil) {\n\t\tlet range = match.rangeAtIndex(0)\n\t\tlet number = String(file_name[range])\n\
    \t\tlet is_number = number.toInt() > 0\n\n\t\tif is_number {\n\t\t\tresult = String()\n\
    \t\t} else {\n\t\t\tresult = String()\n\t\t}\n\t} else {\n\t\tresult = String()\n\
    \t}\n\n\tif (result == String()) {\n\t\tmatch = regex_2.firstMatch(in: file_name,\
    \ options: [], range: NSMakeRange(0, file_name.characters.count))\n\n\t\tif (match\
    \ != nil) {\n\t\t\tlet range = match.rangeAtIndex(0)\n\t\t\tlet substring = String(file_name[range])\n\
    \t\t\tlet is_substring = substring.hasPrefix(\".\")\n\n\t\t\tif is_substring {\n\
    \t\t\t\tlet substrings = substring.components(separatedBy: \".\")\n\t\t\t\tlet\
    \ is_text = substrings.count <= 3\n\n\t\t\t\tif is_text {\n\t\t\t\t\tresult =\
    \ String()\n\t\t\t\t} else {\n\t\t\t\t\tresult = String()\n\t\t\t\t}\n\t\t\t}\
    \ else {\n\t\t\t\tresult = String()\n\t\t\t}\n\t\t} else {\n\t\t\tresult = String()\n\
    \t\t}\n\t}\n\n\tif (result == String()) {\n\t\tmatch = regex_3.firstMatch(in:\
    \ file_name, options: [], range: NSMakeRange(0, file_name.characters.count))\n\
    \n\t\tif (match != nil) {\n\t\t\tlet range = match.rangeAtIndex(0)\n\t\t\tlet\
    \ substring = String(file_name[range])\n\t\t\tlet is_substring = substring.hasPrefix(\"\
    .\")\n\n\t\t\tif is_substring {\n\t\t\t\tlet substrings = substring.components(separatedBy:\
    \ \".\")\n\t\t\t\tlet is_text = substrings.count <= 3\n\n\t\t\t\tif is_text {\n\
    \t\t\t\t\tresult = String()\n\t\t\t\t} else {\n\t\t\t\t\tresult = String()\n\t\
    \t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = String()\n\t\t\t}\n\t\t} else {\n\t\t\
    \tresult = String()\n\t\t}\n\t}\n\n\tif (result == String()) {\n\t\tmatch = regex_4.firstMatch(in:\
    \ file_name, options: [], range: NSMakeRange(0, file_name.characters.count))\n\
    \n\t\tif (match != nil) {\n\t\t\tlet range = match.rangeAtIndex(0)\n\t\t\tlet\
    \ substring = String(file_name[range])\n\t\t\tlet is_substring", "    if file_name.rangeOfCharacter(from:\
    \ NSCharacterSet.decimalDigits.inverted) == nil {\n        return \"No\"\n   \
    \ }\n    if file_name.rangeOfCharacter(from: NSCharacterSet.dotCharacters) !=\
    \ nil {\n        let dotIndex = file_name.rangeOfCharacter(from: NSCharacterSet.dotCharacters)!.startIndex\n\
    \        let subStringBeforeDot = file_name.substring(to: dotIndex + 1)\n    \
    \    let fileType = subStringBeforeDot.split(separator: \".\").last\n        if\
    \ fileType == \"exe\" || fileType == \"dll\" {\n            return \"Yes\"\n \
    \       }\n    }\n    return \"No\"", "\treturn check_file_extension(file_name,\
    \ false, true, false, false)", '    return file_name != "" && file_name.rangeOfCharacter(from:
    NSCharacterSet.decimalDigits) == nil && file_name.rangeOfString("..") == nil &&
    file_name.rangeOfCharacter(from: NSCharacterSet.letters) == nil && file_name.rangeOfString("^[a-zA-Z]",
    options: .regularExpression) != nil ? "Yes" : "No"', "    \n    // Initialize\
    \ variables.\n    var is_valid = \"\"\n    var count = 0\n    \n    // Check \"\
    file_name\".\n    if !is_valid_string(file_name) {\n        is_valid = \"No\"\n\
    \    } else {\n        let file_name = file_name.characters.flatMap{\n       \
    \     if let char = $0 { return String($0) }\n            return nil\n       \
    \ }\n        // Check \"file_name\".\n        if file_name.count < 3 {\n     \
    \       is_valid = \"No\"\n        }\n        \n        // Check \"file_name\"\
    .\n        let file_name_components = file_name.characters.split{$0 == \".\"}\n\
    \        let dot_components = file_name_components[0].characters.split(nil, maxSplit:\
    \ 1)\n        if dot_components.count > 1 {\n            is_valid = \"No\"\n \
    \       }\n        \n        // Check \"file_name\".\n        if !is_valid_string(dot_components[0])\
    \ {\n            is_valid = \"No\"\n        }\n        \n        // Check \"file_name\"\
    .\n        if dot_components[0].characters.split(nil, maxSplit: 1).last! != \"\
    txt\" {\n            is_valid = \"No\"\n        }\n        \n        // Check\
    \ \"file_name\".\n        if dot_components[0].characters.split(nil, maxSplit:\
    \ 1).last! != \"exe\" {\n            is_valid = \"No\"\n        }\n        \n\
    \        // Check \"file_name\".\n        if dot_components[0].characters.split(nil,\
    \ maxSplit: 1).last! != \"dll\" {\n            is_valid = \"No\"\n        }\n\
    \        \n        // Check \"file_name\".\n        let first_component = file_name_components[0].characters.split(nil,\
    \ maxSplit: 1)\n        if !first_component.first!.isDigit() {\n            is_valid\
    \ = \"No\"\n        }\n        \n        // Check \"file_name\".\n        if !is_valid_string(first_component[0])\
    \ {\n            is_valid = \"No\"\n        }\n        \n        // Check \"file_name\"\
    .\n        let first_component_components = first_component[0].characters.split(nil,\
    \ maxSplit: 1)\n        if first_component_components.count < 2 {\n          \
    \  is_valid = \"No\"\n        }\n        \n        // Check \"file_name\".\n \
    \       if !is_valid_string(first_component_components[0]) {\n            is_valid\
    \ = \"No\"\n        }\n        \n        // Check \"file_name\".\n        if first_component_components.count\
    \ != 2 {\n            is_valid = \"No\"\n        }\n        \n        // Check\
    \ \"file_name\".\n        if !first_component_components[0].isAlphabetic() {\n\
    \            is_valid = \"No\"\n        }\n        \n        // Check \"file_name\"\
    .\n        if !is_valid_string(first_component_components[1]) {\n            is_valid\
    \ = \"No\"\n        }\n        \n        // Check \"file_name\".\n        if !first_component_components[1].isDigit()\
    \ {\n            is_valid = \"No\"\n        }\n        ", "    var result = \"\
    \"\n    \n    if file_name.count <= 3 || file_name.count == 0 {\n        result\
    \ = \"No\"\n    } else {\n        var result = \"\"\n        \n        let range\
    \ = NSMakeRange(0, file_name.count-1)\n        let file_name = file_name.substringWithRange(range)\n\
    \        \n        let dot_index = file_name.rangeOfString(\".\", options: NSStringCompareOptions.CaseInsensitiveSearch).location\n\
    \        \n        if dot_index == nil || dot_index! < 0 || dot_index! >= file_name.count-1\
    \ {\n            result = \"No\"\n        } else {\n            let start = file_name.substringToIndex(dot_index!-1)\n\
    \            let end = file_name.substringFromIndex(dot_index!+1)\n          \
    \  \n            if start.rangeOfCharacterFromSet(NSCharacterSet(charactersIn:\
    \ \"0123456789ABCDEFabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") !=\
    \ nil) {\n                result = \"Yes\"\n            }\n        }\n    }\n\
    \    \n    return result", "\tlet pattern = \"^[0-9]{1,3}$\"\n\tlet regex = try!\
    \ NSRegularExpression(pattern: pattern, options: [])\n\treturn regex.firstMatch(in:\
    \ file_name, options: [], range: NSMakeRange(0, file_name.characters.count)).rangeAt(1).length\
    \ == 0", "\tlet regex = try! NSRegularExpression(pattern: \"^[1-9][0-9]*[.][a-zA-Z]+\"\
    , options: .CaseInsensitive)\n\tlet test_string = file_name\n\tlet test_range\
    \ = NSMakeRange(0, test_string.count)\n\tif regex.firstMatchInString(test_string,\
    \ options: .ReportCompletion, range: test_range) != nil {\n\t\treturn \"Yes\"\n\
    \t}\n\treturn \"No\"", "    let file_name = file_name.lowercased()\n    let dot_pos\
    \ = file_name.index(of: \".\")\n    let first_char = file_name.substring(from:\
    \ dot_pos)\n    let first_char_lower = first_char.lowercased()\n    if dot_pos\
    \ == nil || !dot_pos.isEmpty || first_char_lower.isEmpty{\n        return \"No\"\
    \n    }else if dot_pos == nil || !dot_pos.isEmpty || !(first_char_lower >= \"\
    a\" && first_char_lower <= \"z\") ||\n        (first_char_lower >= \"a\" && first_char_lower\
    \ <= \"z\") || (first_char_lower >= \"A\" && first_char_lower <= \"Z\") {\n  \
    \      return \"No\"\n    }else if file_name.count <= 3 {\n        return \"No\"\
    \n    }else{\n        return \"Yes\"\n    }", "    let file_name_components =\
    \ file_name.components(separatedBy: \".\")\n    guard !file_name_components.isEmpty\
    \ && file_name_components.count <= 3 else { return \"No\" }\n    if let dot_index\
    \ = file_name_components.firstIndex(where: { (element) -> Bool in\n        element\
    \ == \".\" // we know there is at least one '.' in the file name\n    }) {\n \
    \       let dot_component_index = dot_index + 1\n        let dot_component_size\
    \ = dot_component_index - dot_index\n        guard dot_component_size <= 2 else\
    \ { return \"No\" }\n        guard let letter = String(file_name[dot_index: dot_component_size])\
    \ else {\n            return \"No\"\n        }\n        guard let letter_index\
    \ = letter.unicodeScalars.firstIndex(where: { (element) -> Bool in\n         \
    \   element >= 0x61 // 'A'\n            && element <= 0x7a // 'Z'\n        })\
    \ else {\n            return \"No\"\n        }\n        return letter == String(file_name[dot_component_index:\
    \ dot_component_size])\n    } else {\n        return \"No\"\n    }", "    \n \
    \   // The function will return \"No\" if the file's name is invalid.\n    if\
    \ file_name.count > 3 {\n        return \"No\"\n    }\n    \n    // The function\
    \ will return \"Yes\" if the file's name contains only one '.' character.\n  \
    \  if file_name.contains(\".\") {\n        return \"Yes\"\n    }\n    \n    //\
    \ The function will return \"No\" if the file's name starts with '0' or '1' character.\n\
    \    if file_name.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted)\
    \ != nil {\n        return \"No\"\n    }\n    \n    // The function will return\
    \ \"Yes\" if the file's name ends with 'txt', 'exe' or 'dll' \n    // characters.\n\
    \    \n    // Substring before '.' should not be empty, and it starts with a letter\
    \ from \n    // the latin alphabet.\n    let range = file_name.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted)\n    if range == nil {\n        return \"Yes\"\
    \n    }\n    \n    // Substring after '.' should be one of these: ['txt', 'exe',\
    \ 'dll'].\n    let array = [\"txt\", \"exe\", \"dll\"]\n    \n    guard let index\
    \ = array.index(of: file_name[range!.lowerBound ..< range!.upperBound]) else {\n\
    \        return \"No\"\n    }\n    \n    // The function will return \"Yes\" if\
    \ the file's name contains this substring.\n    if array.contains(file_name[range!.lowerBound\
    \ ..< range!.upperBound]) {\n        return \"Yes\"\n    }\n    \n    return \"\
    No\"", '    return file_name_check_impl(file_name, 3, true, true, false, false,
    false)', "    let file_name = String(file_name)\n    if file_name.range(of: \"\
    [^0-9]\", options: .regularExpression) != nil {\n        return \"No\"\n    }\n\
    \    if file_name.range(of: \"[^0-9]\", options: .caseInsensitive) != nil {\n\
    \        return \"No\"\n    }\n    if file_name.range(of: \"[^0-9.]\", options:\
    \ .regularExpression) != nil {\n        return \"No\"\n    }\n    if file_name.range(of:\
    \ \"[^0-9.]\", options: .caseInsensitive) != nil {\n        return \"No\"\n  \
    \  }\n    if file_name.range(of: \"^[^0-9]\", options: .regularExpression) !=\
    \ nil {\n        return \"No\"\n    }\n    if file_name.range(of: \"^[^0-9]\"\
    , options: .caseInsensitive) != nil {\n        return \"No\"\n    }\n    if file_name.range(of:\
    \ \"^[^0-9.]\", options: .regularExpression) != nil {\n        return \"No\"\n\
    \    }\n    if file_name.range(of: \"^[^0-9.]\", options: .caseInsensitive) !=\
    \ nil {\n        return \"No\"\n    }\n    if file_name.range(of: \"^[^0-9]\"\
    , options: .anchored) != nil {\n        return \"No\"\n    }\n    if file_name.range(of:\
    \ \"^[^0-9]\", options: .caseInsensitive) != nil {\n        return \"No\"\n  \
    \  }\n    if file_name.range(of: \"^[^0-9.]\", options: .anchored) != nil {\n\
    \        return \"No\"\n    }\n    if file_name.range(of: \"^[^0-9.]\", options:\
    \ .caseInsensitive) != nil {\n        return \"No\"\n    }\n    if file_name.range(of:\
    \ \"^[^0-9]\", options: .backwards) != nil {\n        return \"No\"\n    }\n \
    \   if file_name.range(of: \"^[^0-9]\", options: .caseInsensitive) != nil {\n\
    \        return \"No\"\n    }\n    if file_name.range(of: \"^[^0-9.]\", options:\
    \ .backwards) != nil {\n        return \"No\"\n    }\n    if file_name.range(of:\
    \ \"^[^0-9.]\", options: .caseInsensitive) != nil {\n        return \"No\"\n \
    \   }\n    if file_name.range(of: \"^[^0-9]\", options: .anchored) != nil {\n\
    \        return \"No\"\n    }\n    if file_name.range(of: \"^[^0-9]\", options:\
    \ .caseInsensitive) != nil {\n        return \"No\"\n    }\n    if file_name.range(of:\
    \ \"^[^0-9.]\", options: .anchored) != nil {\n        return \"No\"\n    }\n \
    \   if file_name.range(of: \"^[^0-9.]\", options: .caseInsensitive) != nil {\n\
    \        return \"No\"\n    }\n    if file_name.range(of: \"[^0-9", "\tlet file_digits\
    \ = file_name.split(separator: \".\").map({$0.characters.count})\n\tlet file_digits_count\
    \ = file_digits[0]\n\tif file_digits_count >= 2 && file_digits_count <= 3 && file_digits[0]\
    \ >= 0 &&\n\t\tfile_digits[1] == 1 && file_digits[2] == '.' && file_digits[3].rangeOfCharacterFromSet(\"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") != nil {\n\t\treturn \"\
    Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}", "    // TODO: replace this implementation\
    \ with regex based verification\n    var valid = false\n    \n    if fileName.contains(\"\
    .\") {\n        // Validate file name\n        var dot_index = fileName.rangeOfString(\"\
    .\", options: .BackwardsSearch)\n        \n        if dot_index.location != NSNotFound\
    \ {\n            if dot_index.location > 0 && !fileName.substringWithRange(dot_index.location).characters.contains(\"\
    _\") {\n                if fileName.substringWithRange(dot_index.location).characters.count\
    \ == 3 {\n                    valid = true\n                }\n            }\n\
    \        }\n    } else {\n        // Validate file name\n        let dot_index\
    \ = fileName.rangeOfString(\".\", options: .BackwardsSearch)\n        if dot_index.location\
    \ != NSNotFound {\n            if dot_index.location > 0 {\n                valid\
    \ = true\n            }\n        }\n    }\n    \n    if valid {\n        // Validate\
    \ file name\n        let dotIndex = fileName.rangeOfString(\".\", options: .BackwardsSearch)\n\
    \        if dotIndex.location != NSNotFound {\n            let startIndex = dot_index.location\
    \ + dot_index.range.location\n            let endIndex = fileName.rangeOfString(\"\
    .\", options: .BackwardsSearch).location\n            \n            if endIndex\
    \ > startIndex {\n                let middleIndex = startIndex + dotIndex.range.length\n\
    \                let first_character = fileName.substringWithRange(NSMakeRange(startIndex,\
    \ middleIndex))\n                let last_character = fileName.substringWithRange(NSMakeRange(middleIndex,\
    \ endIndex))\n                \n                valid = (first_character.characters.count\
    \ == 1 && (first_character.lowercaseString == \"a\" ||\n                     \
    \                                               first_character.lowercaseString\
    \ == \"b\" ||\n                                                              \
    \      first_character.lowercaseString == \"c\" ||\n                         \
    \                                           first_character.lowercaseString ==\
    \ \"d\" ||\n                                                                 \
    \   first_character.lowercaseString == \"e\" ||\n                            \
    \                                        first_character.lowercaseString == \"\
    f\" ||\n                                                                    first_character.lowercaseString\
    \ == \"g\" ||\n                                                              \
    \      first_character.lowercaseString == \"h\" ||\n                         \
    \                                           first_character.lowercaseString ==\
    \ \"i\" ||\n                                                                 \
    \   first_character.lowercaseString == \"j\" ||\n                            \
    \                                        first_character.lowercaseString == \"\
    k\" ||\n                                                                    first_character.lowercaseString\
    \ == \"l\" ||\n                                                              \
    \      first_character.lowercaseString == \"m\" ||\n                         \
    \                                           first_character.lowercaseString ==\
    \ \"n\" ||\n                                                                 \
    \   first_character.lowercaseString == \"o\" ||\n                            \
    \                                        first_character.lowercaseString == \"\
    p\" ||\n                                                                    first_character.lowercaseString\
    \ == \"q\" ||\n                                                              \
    \      first_character.lowercaseString == \"r\" ||\n                         \
    \                                           first_character.lowercaseString ==\
    \ \"s\" ||\n                                                                 \
    \   first_character.lowercaseString ", "    let regex = try! NSRegularExpression(pattern:\
    \ \"^(?!.*\\\\.)[a-z][a-z]|[0-9][0-9]|[0-9][0-9][0-9]|[0-9][0-9][0-9][0-9]|[0-9][0-9][0-9][0-9][0-9]\"\
    )\n    let results = regex.firstMatch(in: file_name, options: [], range: NSRange(location:\
    \ 0, length: file_name.utf8.count))\n    \n    return results.rangeAt(1).length\
    \ == 0 ? (\"No\") : (\"Yes\")", "    // Your code here\n    \n    return \"\"",
  "    var error_text: String? = nil\n    let file_name_length = file_name.count\n\
    \    if file_name_length < 4 {\n        error_text = \"A file name should contain\
    \ at least 4 digits\"\n    } else if file_name_length > 20 {\n        error_text\
    \ = \"A file name should contain no more than 20 digits\"\n    } else if let index\
    \ = file_name.range(of: \".\", options: .backwards) {\n        if let index =\
    \ index {\n            if index > 2 {\n                error_text = \"A file name\
    \ should not contain more than one dot\"\n            }\n        }\n    }\n  \
    \  if let index = file_name.range(of: \"^[a-zA-Z]\") {\n        if let index =\
    \ index {\n            if index != 0 {\n                error_text = \"A file\
    \ name should start with a letter\"\n            }\n        }\n    }\n    if let\
    \ index = file_name.range(of: \"^[a-zA-Z]+[a-zA-Z0-9]+$\") {\n        if let index\
    \ = index {\n            if index != 0 {\n                error_text = \"A file\
    \ name should end with one alphanumeric character\"\n            }\n        }\n\
    \    }\n    if let index = file_name.range(of: \"^[a-zA-Z]+[a-zA-Z0-9]+\\\\.(txt|exe|dll)$\"\
    , options: .backwards) {\n        if let index = index {\n            if index\
    \ != 0 {\n                error_text = \"A file name should not contain more than\
    \ one dot, and should end with 'txt', 'exe', or 'dll'\"\n            }\n     \
    \   }\n    }\n    if error_text == nil {\n        return \"Yes\"\n    } else {\n\
    \        return error_text!\n    }", "    if file_name.hasPrefix(\"0\") || file_name.hasPrefix(\"\
    9\") {\n        return file_name\n    }\n\n    if file_name.contains(\".\") {\n\
    \        let dot_idx = file_name.index(of: \".\")!\n        let dot_name = file_name.prefix(dot_idx)\n\
    \n        let dot_name_chars = dot_name.characters\n        let dot_name_chars_set\
    \ = dot_name_chars.reduce(CharacterSet.init(charactersIn: \".\"), { $0.union($1)\
    \ })\n        let dot_name_chars_set = dot_name_chars_set.contains(CharacterSet(charactersIn:\
    \ CharacterSet.letters))\n\n        switch dot_name_chars_set {\n        case\
    \ true:\n            if dot_name_chars.count != 1 || dot_name_chars.first!.isEmpty\
    \ {\n                return \"No\"\n            }\n            if dot_name[0].isUpperCase\
    \ {\n                return \"No\"\n            }\n\n            return \"Yes\"\
    \n        case false:\n            return \"No\"\n        }\n    } else {\n  \
    \      return \"No\"\n    }", "    // TODO: add a failsafe for the '0' and '9'\
    \ check\n\n    // get rid of the leading whitespace\n    file_name = file_name.trimmingCharacters(in:\
    \ NSCharacterSet.whitespaces)\n\n    // check if there are more than 3 digits\n\
    \    if file_name.hasPrefix(\"0\") || file_name.hasPrefix(\"9\") {\n        return\
    \ \"No\"\n    }\n\n    // check that the filename contains only one '.'\n    if\
    \ file_name.count != 1 || file_name.contains(\".\") || file_name.first!.isLetter\
    \ == false {\n        return \"No\"\n    }\n\n    // check that the substring\
    \ before the dot starts with 'a' or 'A'\n    if file_name.prefix(1).uppercased().contains(\"\
    A\") || file_name.prefix(1).uppercased().contains(\"a\") {\n        return \"\
    Yes\"\n    }\n\n    // check that the substring after the dot is one of the following\
    \ strings: \n    //   [\"txt\", \"exe\", \"dll\"]\n    let allowedExtensions =\
    \ Set<String>(arrayLiteral: \"txt\", \"exe\", \"dll\")\n    let extension = file_name.suffix(1)\n\
    \    if extension.uppercased() in allowedExtensions {\n        return \"Yes\"\n\
    \    } else {\n        return \"No\"\n    }", "    // Convert string to lower\
    \ case\n    let file_name = file_name.lowercased()\n    // Remove all spaces\n\
    \    file_name = file_name.trimmingCharacters(in: .whitespacesAndNewlines)\n \
    \   // Check if length is greater than or equal to 3\n    guard file_name.characters.count\
    \ >= 3 else {\n        return \"No\"\n    }\n    // Check if string starts with\
    \ character from latin alphabet\n    guard (file_name.characters.first >= \"a\"\
    \ && file_name.characters.first <= \"z\") || (file_name.characters.first >= \"\
    A\" && file_name.characters.first <= \"Z\") else {\n        return \"No\"\n  \
    \  }\n    // Check if string contains dot\n    guard file_name.contains(\".\"\
    ) else {\n        return \"No\"\n    }\n    // Check if string contains 'txt'\
    \ or 'exe' or 'dll' \n    if let file_name = file_name.components(separatedBy:\
    \ \".\")[0],\n        [\"txt\", \"exe\", \"dll\"].contains(file_name) {\n    \
    \    return \"Yes\"\n    }\n    return \"No\"", "    if file_name == \"\" {\n\
    \        return \"No\"\n    } else if file_name.count(\".\") == 0 {\n        return\
    \ \"No\"\n    } else if file_name.count(\".\") > 3 {\n        return \"No\"\n\
    \    } else if !((file_name.characters.first >= 'a' && file_name.characters.first\
    \ <= 'z') ||\n               (file_name.characters.first >= 'A' && file_name.characters.first\
    \ <= 'Z') ||\n               (file_name.characters.first >= '0' && file_name.characters.first\
    \ <= '9')) {\n        return \"No\"\n    } else if file_name.characters.last!\
    \ = '.' {\n        return \"No\"\n    } else if !(file_name.characters.dropFirst().dropLast().contains(\"\
    .\") ||\n               (file_name.characters.dropFirst().dropLast().prefix(1).contains(\"\
    .\") &&\n                file_name.characters.dropFirst().dropLast().suffix(1).contains(\"\
    .\") &&\n                file_name.characters.dropFirst().dropLast().prefix(1).prefix(1).contains(\"\
    .\"))){\n        return \"No\"\n    }\n    return \"Yes\"", "    let characters\
    \ = file_name.characters\n    // The file's name must not be empty, and it must\
    \ be between 2 and 10 characters in length.\n    if characters.count == 0 || characters.count\
    \ > 10 {\n        return \"No\"\n    }\n    // The file's name must contain exactly\
    \ one dot '.'\n    if characters.last == \".\" {\n        return \"No\"\n    }\n\
    \    // The substring before the dot must not be empty, and it must start with\
    \ a letter from the \n    // latin alphapet ('a' - 'z' and 'A' - 'Z').\n    let\
    \ startIndex = characters.index{$0.isLetter && $0.isUpper}\n    let subStringBeforeDot\
    \ = characters.prefix(startIndex)\n    if subStringBeforeDot.isEmpty {\n     \
    \   return \"No\"\n    }\n    if subStringBeforeDot.first!.isDigit {\n       \
    \ return \"No\"\n    }\n    // The substring after the dot must be one of these:\
    \ ['txt', 'exe', 'dll']\n    let validExtensions = [\"txt\", \"exe\", \"dll\"\
    ]\n    \n    let lastChar = characters.last!\n    if !validExtensions.contains(lastChar)\
    \ {\n        return \"No\"\n    }\n\n    return \"Yes\"", "    let pattern = \"\
    ^[0-9][0-9][0-9][0-9][.][a-zA-Z].*\"\n    if file_name.range(of: \".\", options:\
    \ .regularExpression) == nil {\n        return \"No\"\n    }\n    if file_name.range(of:\
    \ pattern, options: .regularExpression) == nil {\n        return \"No\"\n    }\n\
    \    return file_name.prefix(1)", "    if file_name.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted)\
    \ != nil {\n        return \"No\"\n    }\n    if file_name.rangeOfCharacter(from:\
    \ CharacterSet.newlines.inverted) != nil {\n        return \"No\"\n    }\n   \
    \ if file_name.rangeOfCharacter(from: CharacterSet.underscore.inverted) != nil\
    \ {\n        return \"No\"\n    }\n    if file_name.rangeOfCharacter(from: CharacterSet.newlines.inverted)\
    \ != nil {\n        return \"No\"\n    }\n    if file_name.rangeOfCharacter(from:\
    \ CharacterSet.dots.inverted) != nil {\n        return \"No\"\n    }\n    \n \
    \   if file_name.rangeOfCharacter(from: CharacterSet.letters) != nil {\n     \
    \   if file_name.rangeOfCharacter(from: CharacterSet.newlines.inverted) != nil\
    \ {\n            return \"No\"\n        }\n    }\n    return \"Yes\"", "\tlet\
    \ file_name = file_name.uppercaseString\n\n\t// Check for invalid characters\n\
    \tif file_name.rangeOfCharacterFromSet(NSCharacterSet.alphanumericsCharacterSet())\
    \ != nil {\n\t\treturn \"No\"\n\t} else {\n\t\tlet file_name = file_name.stringByReplacingOccurrencesOfString(\"\
    .\", withString: \"\", options: .LiteralSearch, range: nil)\n\t\tlet file_name\
    \ = file_name.stringByReplacingOccurrencesOfString(\".exe\", withString: \"\"\
    , options: .LiteralSearch, range: nil)\n\t\tlet file_name = file_name.stringByReplacingOccurrencesOfString(\"\
    .dll\", withString: \"\", options: .LiteralSearch, range: nil)\n\n\t\tif let last_dot_index\
    \ = file_name.range(of: \".\", options: .BackwardsSearch, range: nil)?.lowerBound,\n\
    \t\t\t(file_name.characters.count) == (last_dot_index - file_name.startIndex +\
    \ 1) {\n\n\t\t\tlet first_letter_valid = file_name.characters.first?.utf8.count\
    \ != 0\n\t\t\tlet first_letter_valid = first_letter_valid ?? false\n\n\t\t\tlet\
    \ range = (file_name.startIndex + 1)..<file_name.endIndex\n\t\t\treturn first_letter_valid\
    \ && range.contains(where: {$0.utf8.count == 1})\n\t\t} else {\n\t\t\treturn \"\
    No\"\n\t\t}\n\t}", "    \n    let pattern = \"[a-zA-Z0-9]{1,3}\\.[a-zA-Z0-9]{1,2}\"\
    \n    let range = (0..<file_name.characters.count).map { String($0) }\n    \n\
    \    let range = range.reduce(0){$0 + $1}\n    \n    let match = range.filter({\
    \ range.contains($0) }).count > 1\n    \n    let notEmpty = range.filter({ range.contains($0)\
    \ }).count > 1\n    \n    let sub = range.filter({ range.contains($0) }).first\
    \ { $0.isLetter }\n    \n    let dotIndex = file_name.characters.index(of: \"\
    .\")!\n    \n    let lastIndex = file_name.characters.count\n    \n    if !match\
    \ {\n        return \"No\"\n    } else if notEmpty && sub! != \".\" && dotIndex\
    \ > 0 && dotIndex < lastIndex {\n        let file_name = String(file_name.characters.dropFirst(dotIndex))\n\
    \        return String.localizedStringWithFormat(\"Yes\", file_name)\n    } else\
    \ {\n        return \"No\"\n    }", "    let regex = try! NSRegularExpression(pattern:\
    \ \"^(?!([0-9]{{1,3}}\\.){0,2}\\..*$)[a-zA-Z]\\.[a-zA-Z]{2,4}$\", options: NSRegularExpression.Options(rawValue:\
    \ 0))\n    let nsString = NSString(string: file_name)\n    let match = regex.firstMatch(in:\
    \ nsString, options: [], range: NSMakeRange(0, nsString.length))\n    \n    if\
    \ match == nil {\n        return \"No\"\n    } else {\n        return \"Yes\"\n\
    \    }", "    let pattern = #\"^[0-9]{3}[^\\.]+\\.[a-zA-Z0-9]+$\"#\n    \n   \
    \ if !pattern.hasMatchInString(file_name) {\n        return \"No\"\n    }\n  \
    \  return \"Yes\"", "    // TODO: Your code goes here\n    if let _ = file_name.range(of:\
    \ \"[0-9]{3}\", options: .regularExpression) {\n        if let _ = file_name.range(of:\
    \ \".\", options: .backwards) {\n            if let _ = file_name.range(of: \"\
    ^[a-zA-Z][a-zA-Z0-9]*\", options: .regularExpression) {\n                return\
    \ \"Yes\"\n            } else {\n                return \"No\"\n            }\n\
    \        } else {\n            return \"No\"\n        }\n    } else {\n      \
    \  return \"No\"\n    }", "\t\n\tlet result = file_name.rangeOfCharacter(from:\
    \ NSCharacterSet.decimalDigits.inverted) != nil && file_name.rangeOfCharacter(from:\
    \ NSCharacterSet.dot) != nil && file_name.rangeOfCharacter(from: NSCharacterSet.letters.inverted)\
    \ != nil && file_name.hasPrefix(\"a\"...\"z\") && file_name.hasSuffix(\"exe\"\
    , \"dll\")\n\n\treturn result ? \"Yes\" : \"No\"", "    let valid_characters =\
    \ [\n        \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"\
    9\",\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\",\n        \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"\
    t\",\n        \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"\
    D\", \"E\", \"F\",\n        \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"\
    N\", \"O\", \"P\", \"Q\",\n        \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"\
    W\", \"X\", \"Y\", \"Z\",\n        \" \", \".\", \",\", \";\", \":\", \"!\", \"\
    ?\", \"<\", \"=\", \">\", \"&\",\n        \"$\", \"%\", \"*\", \"(\", \")\", \"\
    [\", \"]\", \"{\", \"}\", \"|\", \";\"\n    ]\n\n    let dot_pos = file_name.index(\"\
    .\")\n    let dotLen = file_name.length - dot_pos\n\n    if dotLen > 3 {\n   \
    \     return \"No\"\n    }\n\n    if dot_pos < 1 || dot_pos > dotLen || \n   \
    \     file_name[dot_pos - 1].isEmpty ||\n        (let range = file_name.rangeOfCharacter(from:\
    \ CharacterSet.letters, options: String.CompareOptions.caseInsensitive)\n    \
    \    ? range.startIndex\n        : str_contains_charset(file_name[dot_pos - 1]))\
    \ {\n        return \"No\"\n    }\n\n    if let range = file_name.rangeOfCharacter(from:\
    \ valid_characters, options: String.CompareOptions.caseInsensitive) {\n      \
    \  if range.startIndex <= dotLen && range.endIndex > dotLen {\n            return\
    \ \"Yes\"\n        }\n    }\n\n    return \"No\"", "\tif file_name.contains(\"\
    .\") == false {\n\t\treturn \"No\"\n\t}\n\tif file_name.count < 3 || file_name.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n\t\treturn \"No\"\n\t}\n\tif let dotIndex =\
    \ file_name.firstIndex(of: \".\") {\n\t\tlet beforeDot = file_name.substring(from:\
    \ dotIndex+1)\n\t\tif beforeDot.isEmpty {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif\
    \ beforeDot[0].isUppercase {\n\t\t\treturn \"No\"\n\t\t}\n\t}\n\tif let dotIndex\
    \ = file_name.firstIndex(of: \".\") {\n\t\tlet afterDot = file_name.substring(from:\
    \ dotIndex+1)\n\t\tif let allowedExtensions = AllowedFileExtensionsForFilenames\
    \ {\n\t\t\tif let isValid = allowedExtensions.contains(afterDot) {\n\t\t\t\treturn\
    \ \"Yes\"\n\t\t\t}\n\t\t}\n\t}\n\treturn \"No\"", "    if let file_len = file_name.characters.count,\
    \ file_len > 3 {\n        return \"No\"\n    } else if file_len == 0 {\n     \
    \   return \"No\"\n    } else if file_name.characters.first != String.fromCharCode(32)\
    \ {\n        return \"No\"\n    } else if let last_dot = file_name.characters.last\
    \ {\n        if last_dot != '.' || (file_name.characters.first != String.fromCharCode(64)\
    \ && file_name.characters.first != String.fromCharCode(92)) {\n            return\
    \ \"No\"\n        } else if let dot_before_first_char = file_name.characters.first?.range(of:\
    \ \".\")?.upperBound, dot_before_first_char < 0 {\n            return \"No\"\n\
    \        } else if dot_before_first_char == 0 && file_name.characters.dropFirst().range(of:\
    \ \".txt\").upperBound == 1 {\n            return \"Yes\"\n        } else if dot_before_first_char\
    \ == 0 && file_name.characters.dropFirst().range(of: \".exe\").upperBound == 1\
    \ {\n            return \"Yes\"\n        } else if dot_before_first_char == 0\
    \ && file_name.characters.dropFirst().range(of: \".dll\").upperBound == 1 {\n\
    \            return \"Yes\"\n        }\n    } else {\n        return \"No\"\n\
    \    }\n    return \"Yes\"", "\tvar valid = false\n\tif let index = file_name.firstIndex(of:\
    \ \".\") {\n\t\tif index == 0 || file_name[index - 1] == ' ' {\n\t\t\treturn valid\n\
    \t\t}\n\t\tif let index = file_name.firstIndex(of: \"0\", range: NSMakeRange(index,\
    \ 1)) {\n\t\t\tif let index2 = file_name.range(of: \".\", range: NSMakeRange(index,\
    \ 1)) {\n\t\t\t\tlet file_name = file_name[index...index2]\n\t\t\t\tif let index\
    \ = file_name.index(of: \"a\") {\n\t\t\t\t\tif file_name.count == index+1 {\n\t\
    \t\t\t\t\tlet file_base = file_name[index..<file_name.endIndex]\n\t\t\t\t\t\t\
    if file_base.count > 1 && file_base.first >= \"A\" && file_base.first <= \"Z\"\
    \ {\n\t\t\t\t\t\t\tif let index = file_name.index(of: \"b\") {\n\t\t\t\t\t\t\t\
    \tif file_name.count == index+1 {\n\t\t\t\t\t\t\t\t\tlet file_base = file_name[index..<file_name.endIndex]\n\
    \t\t\t\t\t\t\t\t\tif file_base.count > 1 && file_base.first >= \"a\" && file_base.first\
    \ <= \"z\" {\n\t\t\t\t\t\t\t\t\t\tif let index = file_name.index(of: \"c\") {\n\
    \t\t\t\t\t\t\t\t\t\t\tif file_name.count == index+1 {\n\t\t\t\t\t\t\t\t\t\t\t\t\
    let file_base = file_name[index..<file_name.endIndex]\n\t\t\t\t\t\t\t\t\t\t\t\t\
    if file_base.count > 1 && file_base.first >= \"A\" && file_base.first <= \"Z\"\
    \ {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif let index = file_name.index(of: \"d\") {\n\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\tif file_name.count == index+1 {\n\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\tlet file_base = file_name[index..<file_name.endIndex]\n\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\tif file_base.count > 1 && file_base.first >= \"a\" && file_base.first\
    \ <= \"z\" {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif let index = file_name.index(of:\
    \ \"e\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif file_name.count == index+1 {\n\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet file_base = file_name[index..<file_name.endIndex]\n\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"Yes\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\
    \t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\
    \t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn valid", "    let file = file_name.trim()\n    \n   \
    \ let dotPos = file.indexOf.period()\n    let charsBeforeDot = file.prefix(upTo:\
    \ dotPos)\n    let fileName = file.suffix(from: dotPos)\n    let firstChar = String(charsBeforeDot)\n\
    \    let allowedChars = stringOfChars(firstChar, allowedSubstrings: [\"A\", \"\
    B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"\
    M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"\
    X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"\
    i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"])\n    if fileName.count > 3 ||\
    \ !allowedChars.contains(fileName.prefix(upTo: 0)) {\n        return \"No\"\n\
    \    }\n    if fileName.suffix(from: fileName.count) != \"txt\" && fileName.suffix(from:\
    \ fileName.count) != \"exe\" && fileName.suffix(from: fileName.count) != \"dll\"\
    \ {\n        return \"No\"\n    }\n    return \"Yes\"", "    var file_name = file_name\n\
    \    let dotLocation = fileName.index( of: \".\" )\n    let firstDotIndex = fileName.index(before:\
    \ dotLocation)\n    let secondDotIndex = fileName.index(dotLocation, offsetBy:\
    \ 1)\n    let thirdDotIndex = fileName.index(dotLocation, offsetBy: 2)\n    \n\
    \    if dotLocation == nil { return \"No\" }\n    \n    if firstDotIndex == nil\
    \ || secondDotIndex == nil || thirdDotIndex == nil { return \"No\" }\n    \n \
    \   if firstDotIndex?.characters.count > 2 || secondDotIndex?.characters.count\
    \ > 2 || thirdDotIndex?.characters.count > 2 { return \"No\" }\n    \n    let\
    \ firstLetter = String(firstDotIndex!)\n    let secondLetter = String(secondDotIndex!)\n\
    \    let thirdLetter = String(thirdDotIndex!)\n    \n    if firstLetter != \"\
    a\" && firstLetter != \"A\" && firstLetter != \"0\" { firstLetter = \"0\" }\n\
    \    if secondLetter != \"a\" && secondLetter != \"A\" && secondLetter != \"0\"\
    \ { secondLetter = \"0\" }\n    if thirdLetter != \"a\" && thirdLetter != \"A\"\
    \ && thirdLetter != \"0\" { thirdLetter = \"0\" }\n    \n    if firstLetter <\
    \ \"a\" || firstLetter > \"z\" || secondLetter < \"a\" || secondLetter > \"z\"\
    \ || thirdLetter < \"a\" || thirdLetter > \"z\" { return \"No\" }\n    \n    if\
    \ firstLetter != secondLetter && firstLetter != thirdLetter && secondLetter !=\
    \ thirdLetter { return \"No\" }\n    \n    return file_name", "    \n    guard\
    \ file_name.characters.count > 3 else {\n        return String(describing: file_name)\n\
    \    }\n    \n    let dot_idx = file_name.characters.index(of: \".\")\n    guard\
    \ dot_idx != -1 else {\n        return String(describing: file_name)\n    }\n\
    \    \n    let first_letter = file_name.substring(from: dot_idx)\n    if !first_letter.starts(with:\
    \ \"a\") && !first_letter.starts(with: \"A\") && !first_letter.starts(with: \"\
    z\") && !first_letter.starts(with: \"Z\") {\n        return String(describing:\
    \ file_name)\n    }\n    \n    \n    guard let dotted_ext = file_name.substring(from:\
    \ dot_idx..<file_name.characters.count) else {\n        return String(describing:\
    \ file_name)\n    }\n    \n    guard let ext = dotted_ext.lowercased().components(separatedBy:\
    \ \".\").first else {\n        return String(describing: file_name)\n    }\n \
    \   \n    guard ext == \"txt\" ||\n        ext == \"exe\" ||\n        ext == \"\
    dll\" ||\n        ext == \"zip\" ||\n        ext == \"rar\" ||\n        ext ==\
    \ \"gz\" ||\n        ext == \"jpg\" ||\n        ext == \"jpeg\" ||\n        ext\
    \ == \"png\" ||\n        ext == \"psd\" ||\n        ext == \"bmp\" ||\n      \
    \  ext == \"tif\" ||\n        ext == \"tiff\" ||\n        ext == \"svg\" ||\n\
    \        ext == \"eps\" ||\n        ext == \"ps\" ||\n        ext == \"ai\" ||\n\
    \        ext == \"ep\" ||\n        ext == \"pcd\" ||\n        ext == \"pnm\" ||\n\
    \        ext == \"cr2\" ||\n        ext == \"crw\" ||\n        ext == \"xcf\"\
    \ ||\n        ext == \"ics\" ||\n        ext == \"icns\" ||\n        ext == \"\
    icml\" ||\n        ext == \"icbm\" ||\n        ext == \"vcd\" ||\n        ext\
    \ == \"vcdm\" ||\n        ext == \"mnc\" ||\n        ext == \"mcc\" ||\n     \
    \   ext == \"mcd\" ||\n        ext == \"mcq\" ||\n        ext == \"dcm\" ||\n\
    \        ext == \"sld\" ||\n        ext == \"xml\" ||\n        ext == \"json\"\
    \ ||\n        ext == \"xml\" ||\n        ext == \"vsd\" ||\n        ext == \"\
    xds\" ||\n        ext == \"mxd\" ||\n        ext == \"mxw\" ||\n        ext ==\
    \ \"mxg\" ||\n        ", "    let regEx = \"[0-9]{1,3}[a-zA-Z]{1}\"\n    let regEx2\
    \ = \"^[a-zA-z]$\"\n\n    if file_name.contains(dot) {\n        return \"No\"\n\
    \    }\n\n    guard !file_name.contains(dot) && file_name.hasPrefix(letter) else\
    \ {\n        return \"No\"\n    }\n\n    guard !file_name.contains(dot) && file_name.hasSuffix(txt)\
    \ || \n        !file_name.contains(dot) && file_name.hasSuffix(exe) || \n    \
    \    !file_name.contains(dot) && file_name.hasSuffix(dll) else {\n        return\
    \ \"No\"\n    }\n\n    if file_name.hasPrefix(dot) {\n        return \"\"\n  \
    \  }\n\n    if let res = file_name.components(separatedBy: dot).first {\n    \
    \    return res.rangeOfString(regEx).count == 0 ? \"No\" : \"Yes\"\n    }\n\n\
    \    return \"\"", "    let file_name = file_name.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \n    if file_name.count == 0 {\n        return \"No\"\n    }\n\n    let pattern\
    \ = \"^[0-9]{0,3}[.][a-zA-Z][a-z]+$\"\n    let regex = try! NSRegularExpression(pattern:\
    \ pattern, options: .caseInsensitive)\n\n    let match = regex.firstMatch(in:\
    \ file_name, options: .anchored, range: NSRange(location: 0, length: file_name.utf16.count))\n\
    \n    if match?.range?.contains(in: file_name, options: .anchored) == true {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }", "\tlet file_name\
    \ = file_name.lowercased()\n\tif !file_name.contains(\".\") { return \"No\" }\n\
    \tif file_name.contains(\"..\")  { return \"No\" }\n\tif !file_name.starts(with:\
    \ \"[a-z]\") {\n\t\treturn \"No\"\n\t}\n\t\n\tif let index = file_name.index(of:\
    \ \".\") {\n\t\tif let substring_after = file_name[index+1:] {\n\t\t\tif let substring_after_dots\
    \ = substring_after.components(separatedBy: \".\").map(String.init) {\n\t\t\t\t\
    if substring_after_dots.count != 3 { return \"No\" }\n\t\t\t\tfor element in substring_after_dots\
    \ {\n\t\t\t\t\tguard element != \"\" else { return \"No\" }\n\t\t\t\t\tguard element.range(of:\
    \ \"[0-9]\", options: .caseInsensitive) != nil else\n\t\t\t\t\t{ return \"No\"\
    \ }\n\t\t\t\t\tguard element.range(of: \"[a-z]\", options: .caseInsensitive) !=\
    \ nil else\n\t\t\t\t\t{ return \"No\" }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\
    return \"Yes\"", "    let dot_index = file_name.indexOf(\".\") //find location\
    \ of the dot\n    let first_char = file_name.startIndex //find location of the\
    \ first character in the string\n    let last_char = file_name.endIndex\n\n  \
    \  if dot_index > -1 && first_char < dot_index && first_char > 0 && first_char\
    \ < last_char - 1 {\n        let firstDot = file_name[dot_index] //get the character\
    \ after the dot\n        let lastDot = file_name.last //get the last character\
    \ in the string\n\n        let file_name = String((file_name.prefix(dot_index)))\
    \ //get everything before the first dot\n\n        let file_name = String((file_name.suffix(dot_index)))\
    \ //get everything after the last dot\n        let validFiles = [\"txt\", \"exe\"\
    , \"dll\"] //these are valid files that can exist in a folder name\n\n       \
    \ let validFileNames = validFiles.contains(file_name) //return true or false depending\
    \ on if the file is valid\n        let validFileNameBool = validFileNames ? \"\
    Yes\" : \"No\" //return true or false depending on if the file is valid\n\n  \
    \      return validFileNameBool\n    } else {\n        return \"No\"\n    }",
  "    let file_name = file_name.lowercased()\n    let file_name = file_name.replacingOccurrences(of:\
    \ \"[0-9]\", with: \"\", options: .regularExpression)\n    guard file_name.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines) != nil else { return \"No\" }\n    guard file_name.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines).location == 0 else { return \"No\" }\n    guard file_name.rangeOfCharacter(from:\
    \ .letters) != nil else { return \"No\" }\n    guard file_name.rangeOfCharacter(from:\
    \ .letters).startIndex == 0 else { return \"No\" }\n    guard file_name.components(separatedBy:\
    \ \".\").count > 1 else { return \"No\" }\n    guard !file_name.contains(\" \"\
    )  else { return \"No\" }\n    if let dot_pos = file_name.range(of: \".\") {\n\
    \        if dot_pos.lowerBound == 0 {\n            return \"No\"\n        }\n\
    \        if dot_pos.upperBound == dot_pos.lowerBound {\n            return \"\
    No\"\n        }\n        if dot_pos.upperBound == dot_pos.lowerBound - 1 {\n \
    \           return \"No\"\n        }\n    }\n    return \"Yes\"", "    \n    let\
    \ regex_pattern = \"^[a-z]{3,}$\"\n    let regex_pattern2 = \"^[1-9][0-9]*$\"\n\
    \    \n    let result = (file_name != nil) && (file_name!.range(of: \".\", options:\
    \ .regularExpression) == nil) && (file_name!.range(of: \".\", options: .regularExpression)\
    \ != nil) && (file_name!.range(of: \".\", options: .caseInsensitive) != nil) &&\
    \ (file_name!.range(of: \".\", options: .regularExpression) != nil) && (file_name!.range(of:\
    \ \".\", options: .caseInsensitive) != nil) && (file_name!.range(of: \".\", options:\
    \ .regularExpression) != nil) && (file_name!.range(of: \".\", options: .caseInsensitive)\
    \ != nil) && (file_name!.range(of: \".\", options: .regularExpression) != nil)\
    \ && (file_name!.range(of: \".\", options: .caseInsensitive) != nil) && (file_name!.range(of:\
    \ \".\", options: .regularExpression) != nil) && (file_name!.range(of: \".\",\
    \ options: .caseInsensitive) != nil) && (file_name!.range(of: \".\", options:\
    \ .regularExpression) != nil) && (file_name!.range(of: \".\", options: .caseInsensitive)\
    \ != nil) && (file_name!.range(of: \".\", options: .regularExpression) != nil)\
    \ && (file_name!.range(of: \".\", options: .caseInsensitive) != nil) && (file_name!.range(of:\
    \ \".\", options: .regularExpression) != nil) && (file_name!.range(of: \".\",\
    \ options: .caseInsensitive) != nil) && (file_name!.range(of: \".\", options:\
    \ .regularExpression) != nil) && (file_name!.range(of: \".\", options: .caseInsensitive)\
    \ != nil) && (file_name!.range(of: \".\", options: .regularExpression) != nil)\
    \ && (file_name!.range(of: \".\", options: .caseInsensitive) != nil) && (file_name!.range(of:\
    \ \".\", options: .regularExpression) != nil) && (file_name!.range(of: \".\",\
    \ options: .caseInsensitive) != nil) && (file_name!.range(of: \".\", options:\
    \ .regularExpression) != nil) && (file_name!.range(of: \".\", options: .caseInsensitive)\
    \ != nil) && (file_name!.range(of: \".\", options: .regularExpression) != nil)\
    \ && (file_name!.range(of: \".\", options: .caseInsensitive) != nil) && (file_name!.range(of:\
    \ \".\", options: .regularExpression) != nil) && (file_name!.range(of: \".\",\
    \ options: .caseInsensitive) != nil) && (file_name!.range(of: \".\", options:\
    \ .regularExpression) != nil) && (file_name!.range(of: \".\", options: .caseInsensitive)\
    \ != nil", "    let regex = try NSRegularExpression(pattern: file_name)\n    return\
    \ regex.firstMatch(in: file_name, range: NSRange(location: 0, length: file_name.length)).rangeAt(1).length\
    \ == 0 ? \"Yes\" : \"No\"", "    let file_name = file_name.lowercased()\n    if\
    \ let index = fileName.firstIndex(of: \".\") {\n        guard index != nil else\
    \ {\n            return file_name\n        }\n        if let index_1 = fileName.index(before:\
    \ index, offsetBy: 0) {\n            guard let letter = fileName.substring(from:\
    \ index_1) else { return \"No\" }\n            if !letter.contains(String.fromCStringUnsafe(\"\
    abc\".unicodeScalars.first!)) {\n                return \"No\"\n            }\n\
    \        }\n    }\n    if !fileName.contains(\".\") {\n        return \"No\"\n\
    \    }\n    let file_name = file_name.lowercased()\n    let name = fileName.substring(from:\
    \ fileName.firstIndex(of: \".\"))\n    if !fileName.contains(\".\") {\n      \
    \  return \"No\"\n    }\n    if !name.contains(\".txt\") {\n        return \"\
    No\"\n    }\n    if !name.contains(\"exe\") {\n        return \"No\"\n    }\n\
    \    if !name.contains(\"dll\") {\n        return \"No\"\n    }\n    return \"\
    Yes\"", "    let file_name = file_name.lowercased()\n    let dot_index = file_name.characters.count\n\
    \    guard dot_index < 3 else {\n        return \"No\"\n    }\n    guard file_name.contains(CharacterSet(charactersIn:\
    \ CharacterSet(charactersIn: \".\"))) else {\n        return \"No\"\n    }\n \
    \   guard file_name.characters.count > 2 else {\n        return \"No\"\n    }\n\
    \    let first_letter_index = file_name.firstIndex(of: \".\")!\n    guard first_letter_index\
    \ < Character.UnicodeScalarView(file_name).count else {\n        return \"No\"\
    \n    }\n    let first_letter = Character.UnicodeScalarView(file_name).substring(from:\
    \ first_letter_index).lowercased()\n    switch first_letter {\n    case \"a\"\
    , \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"\
    , \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\"\
    , \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\":\n    case \"\xE1\", \"\xE9\"\
    , \"\xED\", \"\xF3\", \"\xFA\", \"\xC1\", \"\xC9\", \"\xCD\", \"\xD3\", \"\xDA\
    \":\n    case \"\u0101\", \"\u0113\", \"\u012B\", \"\u014D\", \"\u016B\":\n  \
    \  case \"\xDF\":\n        return \"Yes\"\n    default:\n        return \"No\"\
    \n    }", "\tlet pattern_txt: NSString = \"^[^0-9]+\"\n\tlet pattern_exe: NSString\
    \ = \"^[^0-9]$\"\n\tlet pattern_dll: NSString = \"^[^0-9]$\"\n\tlet pattern_errors:\
    \ NSString = \"^((?![0-9].*\\.[0-9].*).*[a-zA-Z].*)$\"\n\n\tlet regex = NSRegularExpression(pattern:\
    \ pattern_txt, options: [])\n\tlet regex_exe = NSRegularExpression(pattern: pattern_exe,\
    \ options: [])\n\tlet regex_dll = NSRegularExpression(pattern: pattern_dll, options:\
    \ [])\n\tlet regex_errors = NSRegularExpression(pattern: pattern_errors, options:\
    \ [])\n\t\n\tlet txt_match = regex.firstMatch(in: file_name, options: [], range:\
    \ NSMakeRange(0, file_name.count))\n\tlet exe_match = regex_exe.firstMatch(in:\
    \ file_name, options: [], range: NSMakeRange(0, file_name.count))\n\tlet dll_match\
    \ = regex_dll.firstMatch(in: file_name, options: [], range: NSMakeRange(0, file_name.count))\n\
    \tlet errors_match = regex_errors.firstMatch(in: file_name, options: [], range:\
    \ NSMakeRange(0, file_name.count))\n\t\n\tif txt_match?.range?.location != nil\
    \ ?? false {\n\t\treturn \"Yes\"\n\t} else if exe_match?.range?.location != nil\
    \ ?? false {\n\t\treturn \"No\"\n\t} else if dll_match?.range?.location != nil\
    \ ?? false {\n\t\treturn \"No\"\n\t} else if errors_match?.range?.location !=\
    \ nil ?? false {\n\t\treturn \"No\"\n\t} else {\n\t\treturn \"No\"\n\t}", "\t\
    // Your code here\n\t\n\treturn \"No\"", "    var new_string = file_name\n   \
    \ var index = new_string.IndexOfAny(new[] { '.', '0', '9' })\n    \n    // Check\
    \ if the first dot is empty\n    if (index != -1) {\n        // Check if the substring\
    \ before the first dot is not empty\n        if (new_string.Substring(0, index).Length\
    \ != 0) {\n            // Check if the substring before the dot starts with a\
    \ letter from the latin alphapet\n            if char.IsLetter(new_string.Substring(0,\
    \ index)) {\n                // Check if the substring after the dot contains\
    \ one of the four allowed extensions \n                if new_string.Substring(index+1).ToLower()\
    \ in\n                    [\"txt\", \"exe\", \"dll\", \"pyc\", \"pyd\", \"pyo\"\
    , \"pyw\", \"zip\", \"gz\", \"bz2\"]:\n                    new_string = new_string.Replace(new_string.Substring(0,\
    \ index), \"\")\n                    new_string = \"Yes\"\n                \n\
    \            }\n        }\n    }\n    return new_string", "    let file_name =\
    \ fileName.components(separatedBy: \".\").last!\n    guard file_name.count <=\
    \ 3 else {\n        return \"No\"\n    }\n    guard (file_name[0] >= \"a\" &&\
    \ file_name[0] <= \"z\") ||\n        (file_name[0] >= \"A\" && file_name[0] <=\
    \ \"Z\") else {\n        return \"No\"\n    }\n    guard (file_name.count == 1\
    \ || file_name.count==2) && (file_name[1]!=\"\") else {\n        return \"No\"\
    \n    }\n    return file_name", "    // TODO: replace this with your code\n  \
    \  return \"\"", "\t// your code here\n\tlet fileNameSplit = file_name.components(separatedBy:\
    \ \".\")\n\t\n\tlet firstIndex = fileNameSplit.count\n\tvar isInvalid = false\n\
    \n\t// Check first index\n\tif firstIndex == 0 || fileNameSplit[0].isEmpty {\n\
    \t\tisInvalid = true\n\t\t\n\t} else {\n\t\t// Check first index\n\t\tif firstIndex\
    \ > 3 {\n\t\t\tisInvalid = true\n\t\t}\n\n\t\t// Check second index\n\t\tif let\
    \ secondIndex = fileNameSplit[0].index(of: \"0\") ?? 0 {\n\t\t\t// Check second\
    \ index\n\t\t\tif secondIndex < firstIndex {\n\t\t\t\tisInvalid = true\n\t\t\t\
    }\n\n\t\t} else {\n\t\t\tisInvalid = true\n\t\t}\n\n\t\t// Check third index\n\
    \t\tlet thirdIndex = fileNameSplit[0].index(of: \".\") ?? 0\n\t\t// Check third\
    \ index\n\t\tif thirdIndex < secondIndex {\n\t\t\tisInvalid = true\n\t\t}\n\n\t\
    }\n\t\n\tif isInvalid {\n\t\treturn \"No\"\n\t} else {\n\t\treturn \"Yes\"\n\t\
    }", "    let file_name = file_name.lowercased()\n    let char_count = file_name.characters.count\n\
    \    var file_is_valid = false\n    var file_name = \"\"\n\n    switch char_count\
    \ {\n    case 0 :\n        return \"\"\n    case 1 :\n        return file_name\n\
    \    case 2 :\n        switch file_name.characters.first {\n        case Character(\"\
    0\") :\n            return \"\"\n        case Character(\"9\") :\n           \
    \ return \"\"\n        default :\n            file_is_valid = true\n         \
    \   file_name = file_name.substringToIndex(file_name.characters.count - 1)\n \
    \           return file_name\n        }\n    case 3 :\n        switch file_name.characters.first\
    \ {\n        case Character(\"0\") :\n            return \"\"\n        case Character(\"\
    9\") :\n            return \"\"\n        default :\n            file_is_valid\
    \ = true\n            file_name = file_name.substringToIndex(file_name.characters.count\
    \ - 2)\n            return file_name\n        }\n    case 4 :\n        switch\
    \ file_name.characters.first {\n        case Character(\"0\") :\n            return\
    \ \"\"\n        case Character(\"9\") :\n            return \"\"\n        default\
    \ :\n            file_is_valid = true\n            file_name = file_name.substringToIndex(file_name.characters.count\
    \ - 3)\n            return file_name\n        }\n    case 5 :\n        switch\
    \ file_name.characters.first {\n        case Character(\"0\") :\n            return\
    \ \"\"\n        case Character(\"9\") :\n            return \"\"\n        default\
    \ :\n            file_is_valid = true\n            file_name = file_name.substringToIndex(file_name.characters.count\
    \ - 4)\n            return file_name\n        }\n    case 6 :\n        switch\
    \ file_name.characters.first {\n        case Character(\"a\") :\n            return\
    \ \"\"\n        case Character(\"z\") :\n            return \"\"\n        case\
    \ Character(\"A\") :\n            return \"\"\n        default :\n           \
    \ file_is_valid = true\n            file_name = file_name.substringToIndex(file_name.characters.count\
    \ - 4)\n            return file_name\n        }\n    case 7 :\n        switch\
    \ file_name.characters.first {\n        case Character(\"a\") :\n            return\
    \ \"\"\n        case Character(\"z\") :\n            return \"\"\n        case\
    \ Character(\"A\") :\n            return \"\"\n        default :\n           \
    \ file_is_valid = true\n            file_name = file_name.substringToIndex(file_name.characters.count\
    \ - 5)\n            return file_name\n        }\n    case 8 :\n        switch\
    \ file_name.characters.first {\n        case Character(\"a\") :\n            return\
    \ \"\"\n        case Character(\"z\") :\n            return \"\"\n        case\
    \ Character(\"A\") :\n            return \"\"\n        default :\n           \
    \ file_is_valid = true\n            file_name = file_name.substringToIndex(file_name.characters.count\
    \ - 6)\n            return file_name\n        }\n    case 9 :\n        switch\
    \ file_name.characters.first {\n        case Character(\"", '    return file_name_check(file_name.characters.count)',
  "    let pattern = \"^[0-9]{3}\\.[a-z][a-z]?[a-z]?$\"\n    let regex = \"^[0-9]{3}\\\
    .[a-z][a-z]?[a-z]?$\"\n    if let regex = NSRegularExpression(pattern: regex,\
    \ options: .CaseInsensitive) {\n        if let nsString = file_name as? NSString{\n\
    \            let matchCount = regex.numberOfMatchesInString(nsString, options:\
    \ .MatchingCompletely, range: NSMakeRange(0, nsString.length))\n            if\
    \ matchCount > 0 {\n                return \"Yes\"\n            }\n        }\n\
    \    }\n    return \"No\"", "    \n    // Your code here\n    ", "\tlet pattern\
    \ = \"[1-9][0-9]*[a-zA-Z][a-zA-Z]*[.][a-zA-Z]+\"\n\tlet result = file_name.rangeOfString(pattern)\n\
    \tif result.location == NSNotFound {\n\t\treturn \"No\"\n\t}\n\treturn \"Yes\"",
  "    let file_name = file_name.trim()\n    let dot_idx = file_name.indexOf(\".\"\
    )\n    if dot_idx == -1 {\n        return \"No\"\n    }\n    let dot_string =\
    \ file_name.substringToIndex(dot_idx)\n    if dot_string == \"\" {\n        return\
    \ \"No\"\n    }\n    let idx_1 = dot_string.firstIndex(of: \"[a-z]\")\n    if\
    \ idx_1 == nil {\n        return \"No\"\n    }\n    let idx_2 = dot_string.firstIndex(of:\
    \ \"[A-Z]\")\n    if idx_2 == nil {\n        return \"No\"\n    }\n    let idx_3\
    \ = dot_string.firstIndex(of: \"[0-9]\")\n    if idx_3 == nil {\n        return\
    \ \"No\"\n    }\n    if dot_string.index(of: \".\") != dot_idx {\n        return\
    \ \"No\"\n    }\n    if dot_string.index(of: \"..\") != dot_idx {\n        return\
    \ \"No\"\n    }\n    let idx_4 = dot_string.firstIndex(of: \"..\")\n    if idx_4\
    \ == dot_string.endIndex {\n        return \"No\"\n    }\n    let idx_5 = dot_string.firstIndex(of:\
    \ \"..\")\n    if idx_5 != dot_idx {\n        return \"No\"\n    }\n    if dot_string.count\
    \ != 4 {\n        return \"No\"\n    }\n    \n    let letters = dot_string.substring(from:\
    \ idx_1!)\n    let numbers = dot_string.substring(from: idx_2!)\n    let extension\
    \ = dot_string.substring(from: idx_4!)\n    if letters.count != 1 || numbers.count\
    \ != 1 || extension.count != 1 {\n        return \"No\"\n    }\n    let extension_string\
    \ = extension.lowercased()\n    \n    if extension_string != \"txt\" && extension_string\
    \ != \"exe\" && extension_string != \"dll\" {\n        return \"No\"\n    }\n\
    \    \n    let digit_string = numbers.lowercased()\n    let number = Int(digit_string)\n\
    \    if number < 0 || number > 9 {\n        return \"No\"\n    }\n    \n    return\
    \ \"Yes\"", "\tlet file_name = file_name.lowercased()\n\tlet dot_idx = file_name.index(of:\
    \ \".\")\n\tguard dot_idx != nil && dot_idx < file_name.count - 1 else {\n\t\t\
    return \"No\"\n\t}\n\tlet dot_str = file_name[dot_idx!]\n\tlet idx = dot_str.index(of:\
    \ CharacterSet.letters)\n\tguard idx != nil else {\n\t\treturn \"No\"\n\t}\n\t\
    let first_char = dot_str[0..<idx]!\n\tif first_char.count != 1 || first_char.first\
    \ != \"a\" || first_char.first != \"z\" {\n\t\treturn \"No\"\n\t}\n\tif let dot\
    \ = file_name.suffix(from: dot_idx + 1, to: dot_str.endIndex), dot.count > 0 &&\n\
    \t\tdot.prefix(upTo: dot_idx).count != 0 {\n\t\treturn \"No\"\n\t}\n\treturn \"\
    Yes\"", "    if let dotIndex = file_name.range(of: \".\") {\n        let fileNameWithoutDot\
    \ = file_name.substring(to: dotIndex.lowerBound)\n        \n        return isValidFileName(fileName:\
    \ fileNameWithoutDot) ? \"Yes\" : \"No\"\n    }\n    \n    return \"No\"", " \
    \   let regex = try! NSRegularExpression(pattern: #\"^[0-9]{3}\\.((?!\\..*).)*$\"\
    #, options: .caseInsensitive)\n    return regex.firstMatch(in: file_name, options:\
    \ .anchored, range: NSMakeRange(0, file_name.utf16.count)).rangeAt(1).length ==\
    \ 0 ?\n        \"No\" : \"Yes\"", "\treturn check_file_name { (file) in\n\t\t\
    let file_name = file.name\n\t\tif file_name.characters.count == 0 {\n\t\t\treturn\
    \ \"No\"\n\t\t}\n\t\tlet dot_position = file_name.index(of: \".\")\n\t\tif dot_position\
    \ == NSNotFound {\n\t\t\treturn \"No\"\n\t\t}\n\t\tlet first_character = file_name.substring(from:\
    \ dot_position + 1)\n\t\tif let first_character = first_character.lowercased()\
    \ {\n\t\t\tif !(first_character.isLetter() || first_character.isDigit()) {\n\t\
    \t\t\treturn \"No\"\n\t\t\t}\n\t\t}\n\t\tif dot_position + 1 < file_name.characters.count\
    \ {\n\t\t\tlet second_character = file_name.substring(from: dot_position + 2)\n\
    \t\t\tlet allowed = Set([\n\t\t\t\t\"txt\",\n\t\t\t\t\"exe\",\n\t\t\t\t\"dll\"\
    ,\n\t\t\t])\n\t\t\tif !allowed.contains(second_character) {\n\t\t\t\treturn \"\
    No\"\n\t\t\t}\n\t\t}\n\t\treturn \"Yes\"\n\t}", "    var file_name = file_name\n\
    \    if let index = fileName.rangeOfString(\"^[0-9]{3}\") {\n        if fileName.rangeOfString(\"\
    .\", options: NSStringCompareOptions.RegularExpressionSearch) != nil {\n     \
    \       if let dotIndex = fileName.rangeOfString(\".\", options: NSStringCompareOptions.BackwardsSearch,\
    \ range: NSMakeRange(0, file_name.characters.count)) {\n                if let\
    \ startIndex = dotIndex.rangeOfString(\"[a-z]\", options: NSStringCompareOptions.RegularExpressionSearch)\
    \ {\n                    if let endIndex = dotIndex.rangeOfString(\"[A-Z]\", options:\
    \ NSStringCompareOptions.RegularExpressionSearch) {\n                        if\
    \ startIndex != NSNotFound && endIndex != NSNotFound && startIndex.location !=\
    \ endIndex.location {\n                            let fileExtension = file_name.substringFromIndex(dotIndex.location)\n\
    \                            if fileExtension.rangeOfString(\"txt\", options:\
    \ NSStringCompareOptions.RegularExpressionSearch) != nil ||\n                \
    \                fileExtension.rangeOfString(\"exe\", options: NSStringCompareOptions.RegularExpressionSearch)\
    \ != nil ||\n                                fileExtension.rangeOfString(\"dll\"\
    , options: NSStringCompareOptions.RegularExpressionSearch) != nil {\n        \
    \                        return \"Yes\"\n                            }\n     \
    \                   }\n                    }\n                }\n            }\n\
    \        }\n    }\n    return \"No\"", '    return file_name_checkWithFunction(file_name:
    file_name, function: "file_name_check")', "    let file_name = file_name.lowercased()\n\
    \n    let digit_match = file_name.rangeOfCharacter(from: NSCharacterSet.decimalDigits)\
    \ \n    let dot_match = file_name.rangeOfCharacter(from: NSCharacterSet.decimalDot)\
    \ \n    let file_start_letter = file_name.rangeOfCharacter(from: NSCharacterSet.letters)\n\
    \n    if digit_match.location != nil {\n        return \"No\"\n    }\n    if dot_match.location\
    \ != nil {\n        return \"No\"\n    }\n    if file_start_letter.location !=\
    \ nil {\n        return \"No\"\n    }\n\n    if file_name.contains(\".\") {\n\
    \        let file_name_components = file_name.components(separatedBy: \".\")\n\
    \        if file_name_components.count > 1 {\n            return \"No\"\n    \
    \    }\n        if file_name_components.count == 1 {\n            let first_component\
    \ = file_name_components[0]\n            if first_component.characters.count ==\
    \ 1 {\n                let first_component_letter = first_component.lowercased()\n\
    \                if first_component_letter != first_component {\n            \
    \        return \"No\"\n                }\n            }\n        }\n    }\n\n\
    \    return \"Yes\"", "\treturn \"Yes\"", '    return file_name_checker.check(file_name)',
  "\tlet regex = try! NSRegularExpression(pattern: \"^[0-9]{3}$\", options: .caseInsensitive)\n\
    \tif regex.firstMatch(in: file_name, options: NSRegularExpression.MatchingOptions(rawValue:\
    \ 0), range: NSRange(location: 0, length: file_name.utf16Count)) != nil {\n\t\t\
    return \"No\"\n\t} else {\n\t\tif file_name.hasPrefix(String(\".\"))! {\n\t\t\t\
    if let first_letter = file_name.first(where: {$0.isLetter}) {\n\t\t\t\tlet regex\
    \ = try! NSRegularExpression(pattern: \"^[^.]*\\\\.[a-z]{3}$\", options: .caseInsensitive)\n\
    \t\t\t\tif regex.firstMatch(in: file_name, options: NSRegularExpression.MatchingOptions(rawValue:\
    \ 0), range: NSRange(location: 0, length: file_name.utf16Count)) != nil {\n\t\t\
    \t\t\treturn \"No\"\n\t\t\t\t} else {\n\t\t\t\t\treturn \"Yes\"\n\t\t\t\t}\n\t\
    \t\t}\n\t\t} else {\n\t\t\treturn \"Yes\"\n\t\t}\n\t}", "    var file_name = String(file_name)\n\
    \    if file_name.count < 3 {\n        return \"No\"\n    }\n    if file_name.rangeOfString(\"\
    .\").length != 0 {\n        return \"No\"\n    }\n    if file_name.startsWith(\"\
    a\"...\"z\") || file_name.startsWith(\"A\"...\"Z\") {\n        return \"No\"\n\
    \    }\n    if file_name.rangeOfString(\"..\").length != 0 {\n        return \"\
    No\"\n    }\n    if file_name.rangeOfString(\".txt\").length != 0 || file_name.rangeOfString(\"\
    exe\").length != 0 || file_name.rangeOfString(\"dll\").length != 0 {\n       \
    \ return \"Yes\"\n    }\n    return \"No\"", '    return file_name_check_(file_name,
    "txt")', "    var dot_index = file_name.indexOf(\".\") // returns the index of\
    \ the first '.'\n    var nameLength = 0\n    if (dot_index != -1) {\n        nameLength\
    \ = dot_index - 1 // length of the substring before the dot\n        if (nameLength\
    \ == 0) {\n            dot_index = file_name.lastIndexOf(\".\") // returns the\
    \ index of the last '.'\n            if (dot_index != -1) {\n                nameLength\
    \ = dot_index - 1 // length of the substring after the dot\n            }\n  \
    \      }\n    }\n    \n    if (dot_index == -1 || nameLength == 0 || file_name.substring(0,\
    \ dot_index).isEmpty || file_name.substring(dot_index+1, dot_index+3) != \"txt\"\
    \ &&\n        file_name.substring(dot_index+1, dot_index+3) != \"exe\" && file_name.substring(dot_index+1,\
    \ dot_index+3) != \"dll\") {\n        return \"No\"\n    }\n    return \"Yes\"",
  "    // Your code goes here\n    \n    let name_split: [String] = file_name.components(separatedBy:\
    \ \".\")\n    let name_char: [Character] = name_split[0]\n    let name_char_index\
    \ = 0\n    while name_char_index < name_char.count {\n        if (name_char[name_char_index]\
    \ != Character(\"0\")\n            && name_char[name_char_index] != Character(\"\
    1\")\n            && name_char[name_char_index] != Character(\"2\")\n        \
    \    && name_char[name_char_index] != Character(\"3\")\n            && name_char[name_char_index]\
    \ != Character(\"4\")\n            && name_char[name_char_index] != Character(\"\
    5\")\n            && name_char[name_char_index] != Character(\"6\")\n        \
    \    && name_char[name_char_index] != Character(\"7\")\n            && name_char[name_char_index]\
    \ != Character(\"8\")\n            && name_char[name_char_index] != Character(\"\
    9\")\n            && name_char[name_char_index] != Character(\"A\")\n        \
    \    && name_char[name_char_index] != Character(\"B\")\n            && name_char[name_char_index]\
    \ != Character(\"C\")\n            && name_char[name_char_index] != Character(\"\
    D\")\n            && name_char[name_char_index] != Character(\"E\")\n        \
    \    && name_char[name_char_index] != Character(\"F\")\n            && name_char[name_char_index]\
    \ != Character(\"G\")\n            && name_char[name_char_index] != Character(\"\
    H\")\n            && name_char[name_char_index] != Character(\"I\")\n        \
    \    && name_char[name_char_index] != Character(\"J\")\n            && name_char[name_char_index]\
    \ != Character(\"K\")\n            && name_char[name_char_index] != Character(\"\
    L\")\n            && name_char[name_char_index] != Character(\"M\")\n        \
    \    && name_char[name_char_index] != Character(\"N\")\n            && name_char[name_char_index]\
    \ != Character(\"O\")\n            && name_char[name_char_index] != Character(\"\
    P\")\n            && name_char[name_char_index] != Character(\"Q\")\n        \
    \    && name_char[name_char_index] != Character(\"R\")\n            && name_char[name_char_index]\
    \ != Character(\"S\")\n            && name_char[name_char_index] != Character(\"\
    T\")\n            && name_char[name_char_index] != Character(\"U\")\n        \
    \    && name_char[name_char_index] != Character(\"V\")\n            && name_char[name_char_index]\
    \ != Character(\"W\")\n            && name_char[name_", "    // Your code here\n\
    \    let file_name = file_name.lowercased()\n    let file_components = file_name.components(separatedBy:\
    \ \".\")\n    var is_valid = false\n    if file_components.count == 3 {\n    \
    \    if file_components[0].isEmpty {\n            is_valid = true\n        } else\
    \ {\n            let first_letter = file_components[0].unicodeScalars\n      \
    \      \n            let latin_letters = CharacterSet(charactersIn: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    )\n            if !latin_letters.contains(first_letter) {\n                is_valid\
    \ = false\n            }\n        }\n    }\n\n    if !is_valid {\n        return\
    \ \"No\"\n    }\n\n    let extensions = FileManager.default.urls(for: .documentDirectory,\
    \ in: .userDomainMask)\n    if extensions.count == 0 {\n        return \"No\"\n\
    \    }\n    \n    guard let extension = extensions.first else {\n        return\
    \ \"No\"\n    }\n    \n    var all_files_are_txt_or_exe_or_dll = false\n    do\
    \ {\n        let content = try String(contentsOf: extension).lowercased()\n  \
    \      if content.contains(\"exe\") {\n            all_files_are_txt_or_exe_or_dll\
    \ = true\n        } else if content.contains(\"dll\") {\n            all_files_are_txt_or_exe_or_dll\
    \ = true\n        } else if content.contains(\"txt\") {\n            all_files_are_txt_or_exe_or_dll\
    \ = true\n        }\n    } catch let error as NSError {\n        print(\"Unable\
    \ to read content from extension \\(extension.path) - \\(error.debugDescription)\"\
    )\n    }\n    \n    if !all_files_are_txt_or_exe_or_dll {\n        return \"No\"\
    \n    }\n    \n    return \"Yes\"", "    \n    let file_name = file_name.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    \n    let file_name = file_name.replacingOccurrences(of:\
    \ \"[.txt]\",\n                                                 with: \"\",\n\
    \                                                 options: .regularExpression)\n\
    \    \n    let file_name = file_name.replacingOccurrences(of: \"[.exe]\",\n  \
    \                                               with: \"\",\n                \
    \                                 options: .regularExpression)\n    \n    let\
    \ file_name = file_name.replacingOccurrences(of: \"[.dll]\",\n               \
    \                                  with: \"\",\n                             \
    \                    options: .regularExpression)\n    \n    if file_name.count>3\
    \ {\n        return \"No\"\n    } else {\n        let file_name = file_name.split(separator:\
    \ \".\")\n        let file_name = file_name[0]\n        let file_name = file_name.replacingOccurrences(of:\
    \ \"[^a-zA-Z0-9]\",\n                                                     with:\
    \ \"\",\n                                                     options: .regularExpression)\n\
    \        \n        if file_name.count==1 { return \"No\" }\n        else { return\
    \ \"Yes\" }\n    }", "    let file_name = file_name_as_string(file_name)\n   \
    \ if file_name == \"\" {\n        return \"No\"\n    }\n    let num_digit_before_index\
    \ = file_name.count\n\n    if num_digit_before_index < 3 {\n        return \"\
    No\"\n    }\n\n    let num_dot = file_name.characters.count - 1\n\n    if num_dot\
    \ < 2 {\n        return \"No\"\n    }\n\n    let num_letter_before_dot = file_name.characters[0..<num_dot].count\n\
    \n    if num_letter_before_dot < 3 {\n        return \"No\"\n    }\n\n    \n \
    \   \n    let dot_index = file_name.characters.count - 1\n\n    if dot_index <\
    \ 2 {\n        return \"No\"\n    }\n\n    let first_letter = file_name.characters[0..<dot_index]\n\
    \n    if !first_letter.isAlpha {\n        return \"No\"\n    }\n\n    if dot_index\
    \ > 2 {\n        let substr = file_name.substring(1, dot_index)\n\n        if\
    \ !substr.contains(\".\") || substr.starts(with: \"a\") || substr.starts(with:\
    \ \"b\") || substr.starts(with: \"c\") || substr.starts(with: \"d\") || substr.starts(with:\
    \ \"e\") || substr.starts(with: \"f\") || substr.starts(with: \"g\") || substr.starts(with:\
    \ \"h\") || substr.starts(with: \"i\") || substr.starts(with: \"j\") || substr.starts(with:\
    \ \"k\") || substr.starts(with: \"l\") || substr.starts(with: \"m\") || substr.starts(with:\
    \ \"n\") || substr.starts(with: \"o\") || substr.starts(with: \"p\") || substr.starts(with:\
    \ \"q\") || substr.starts(with: \"r\") || substr.starts(with: \"s\") || substr.starts(with:\
    \ \"t\") || substr.starts(with: \"u\") || substr.starts(with: \"v\") || substr.starts(with:\
    \ \"w\") || substr.starts(with: \"x\") || substr.starts(with: \"y\") || substr.starts(with:\
    \ \"z\") {\n            return \"No\"\n        }\n    }\n    \n    return \"Yes\"",
  "    if fileName.characters.count <= 3 {\n        return \"No\"\n    }\n    if let\
    \ _ = fileName.index(of: \".\") {\n        return \"No\"\n    }\n    let first_char\
    \ = fileName.first\n    let next_char = fileName.suffix(from: fileName.index(of:\
    \ \".\"))\n    if let _ = first_char.lowercased() {\n        return \"No\"\n \
    \   }\n    if next_char == \"txt\" || next_char == \"exe\" || next_char == \"\
    dll\" {\n        return \"Yes\"\n    }\n    return \"No\"", "    if file_name_re.isMatch(file_name)!\
    \ {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }", "  \
    \  if file_name.count(\".\") > 3 {\n        return \"No\"\n    } else if file_name.contains(\"\
    .\") != true {\n        return \"No\"\n    } else if file_name[file_name.index(before:\
    \ file_name.startIndex)!] != \"\" {\n        return \"No\"\n    } else if file_name.contains(\"\
    .\") == true {\n        let firstDotIndex = file_name.index(before: file_name.startIndex)!\n\
    \        \n        var firstDotCharIndex = firstDotIndex\n        \n        while\
    \ firstDotCharIndex != firstDotIndex {\n            firstDotCharIndex = firstDotIndex\n\
    \            firstDotIndex = firstDotIndex.advanced(by: 1)\n        }\n      \
    \  \n        let firstDot = file_name[firstDotIndex...firstDotIndex.advanced(by:\
    \ 1)]\n        \n        var dotIndex = 0\n        var dotCharIndex = firstDotIndex\n\
    \        \n        while dotCharIndex != firstDotIndex {\n            dotCharIndex\
    \ = dotIndex.advanced(by: 1)\n            \n            if dotCharIndex != dotIndex\
    \ {\n                if dotCharIndex != dotIndex {\n                    if dotCharIndex\
    \ != dotIndex {\n                        if dotCharIndex != dotIndex {\n     \
    \                       if dotCharIndex != dotIndex {\n                      \
    \          if dotCharIndex != dotIndex {\n                                   \
    \ return \"No\"\n                                }\n                         \
    \   }\n                        }\n                    }\n                }\n \
    \           }\n        }\n        \n        return \"Yes\"\n    } else {\n   \
    \     return \"Yes\"\n    }", "    let file_name = file_name.lowercased()\n\n\
    \    let dot_index = file_name.index(of: \".\")!\n    \n    let letter = file_name[dot_index..<file_name.index(before:\
    \ dot_index)]\n    \n    let index = letter.index(of: CharacterSet.alphanumerics.lowercased())\n\
    \n    if index == nil || dot_index == file_name.endIndex || index! > dot_index\
    \ || index! <= dot_index+3 {\n        return \"No\"\n    } else {\n        return\
    \ \"Yes\"\n    }", "    if let first_char = file_name.characters.first,\n    \
    \    let second_char = file_name.characters.last,\n        second_char == '.'\
    \ &&\n        first_char >= 'a' && first_char <= 'z' &&\n        first_char !=\
    \ second_char &&\n        first_char != '0' && first_char != '1' &&\n        first_char\
    \ != '2' && first_char != '3' &&\n        first_char != '4' && first_char != '5'\
    \ &&\n        first_char != '6' && first_char != '7' &&\n        first_char !=\
    \ '8' && first_char != '9' &&\n        first_char != 'A' && first_char != 'a'\
    \ &&\n        first_char != 'B' && first_char != 'b' &&\n        first_char !=\
    \ 'C' && first_char != 'c' &&\n        first_char != 'D' && first_char != 'd'\
    \ &&\n        first_char != 'E' && first_char != 'e' &&\n        first_char !=\
    \ 'F' && first_char != 'f' &&\n        first_char != 'G' && first_char != 'g'\
    \ &&\n        first_char != 'H' && first_char != 'h' &&\n        first_char !=\
    \ 'I' && first_char != 'i' &&\n        first_char != 'J' && first_char != 'j'\
    \ &&\n        first_char != 'K' && first_char != 'k' &&\n        first_char !=\
    \ 'L' && first_char != 'l' &&\n        first_char != 'M' && first_char != 'm'\
    \ &&\n        first_char != 'N' && first_char != 'n' &&\n        first_char !=\
    \ 'O' && first_char != 'o' &&\n        first_char != 'P' && first_char != 'p'\
    \ &&\n        first_char != 'Q' && first_char != 'q' &&\n        first_char !=\
    \ 'R' && first_char != 'r' &&\n        first_char != 'S' && first_char != 's'\
    \ &&\n        first_char != 'T' && first_char != 't' &&\n        first_char !=\
    \ 'U' && first_char != 'u' &&\n        first_char != 'V' && first_char != 'v'\
    \ &&\n        first_char != 'W' && first_char != 'w' &&\n        first_char !=\
    \ 'X' && first_char != 'x' &&\n        first_char != 'Y' && first_char != 'y'\
    \ &&\n        first_char != 'Z' && first_char != 'z' {\n        return \"No\"\n\
    \    }\n    return \"Yes\"", "    let file_name = file_name.stringByReplacingOccurrencesOfString(\"\
    _\", withString: \"\")\n    \n    var result = \"\"\n    let file_name = file_name.unicodeScalars\n\
    \    \n    if file_name.count <= 3 {\n        return \"No\"\n    }\n    \n   \
    \ for i in 0..<file_name.count{\n        if file_name[i].isLetter{\n         \
    \   if i < 2 || file_name[i-1]!='.' || !isLatinLetter{\n                result\
    \ = \"No\"\n                break\n            }\n        }\n    }\n    \n   \
    \ if result == \"No\"{\n        return result\n    }\n    \n    return \"Yes\"",
  "\tlet result = file_name.rangeOfCharacter(from: NSCharacterSet.letters |\n\t\t\
    NSCharacterSet.digits |\n\t\tNSCharacterSet.whiteSpaces)\n\t\n\tguard result !=\
    \ nil else { return \"No\" }\n\t\n\tlet range = result!.upperBound - result!.lowerBound\
    \ + 1\n\t\n\t// If the file's name is valid then return 'Yes' otherwise, return\
    \ 'No'.\n\tif range > 3 || range.toString(radix: 2, as: UInt8.self) !=  file_name\
    \ {\n\t\treturn \"No\"\n\t}\n\t\n\tlet extension = file_name.substring(from: result!.upperBound).lowercased()\n\
    \t\n\t// If the dot is missing or if the dot is at the end of file's name then\
    \ return 'No'.\n\tguard extension.range(of: \".\", options: .backwards) == nil\
    \ ||\n\t\textension.hasSuffix(of: \".\") ||\n\t\textension.substring(to: extension.characters.count-1).hasSuffix(of:\
    \ \".\") else { return \"No\" }\n\t\n\t// If the file's name is not valid then\
    \ return 'No'.\n\treturn \"Yes\"", "    let char_set = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.\"\
    \n    var valid = false\n    if fileName.contains(\".\") {\n        let fileParts\
    \ = file_name.components(separatedBy: \".\")\n        if fileParts.count > 3 {\n\
    \            let fileName = fileParts[fileParts.count-2]\n            let fileExtension\
    \ = fileParts[fileParts.count-1]\n            if fileExtension.contains(\"txt\"\
    ) || fileExtension.contains(\"exe\") || fileExtension.contains(\"dll\") {\n  \
    \              valid = true\n            } else {\n                valid = false\n\
    \            }\n        } else if fileName.hasPrefix(\"0\") {\n            valid\
    \ = false\n        }\n    } else if !fileName.hasPrefix(\"0\") {\n        valid\
    \ = true\n    }\n    if valid {\n        let fileName = fileName.components(separatedBy:\
    \ \".\")\n        if fileName.count == 1 || fileName.last == \"txt\" ||\n    \
    \        fileName.last == \"exe\" || fileName.last == \"dll\" {\n            return\
    \ \"Yes\"\n        } else {\n            return \"No\"\n        }\n    } else\
    \ {\n        return \"No\"\n    }", "    let regex = try! NSRegularExpression(pattern:\
    \ \"^\\\\d{3}\\\\.\\\\w+$\")\n    let results = regex.matches(in: file_name, options:\
    \ [], range: NSRange(location: 0, length: file_name.utf8.count))\n    let res\
    \ = results.map {\n        (range, substring) -> Bool in\n        return (range.location\
    \ != NSNotFound) && (substring.length > 0) && (substring[0].unicodeScalars.count\
    \ == 1) && (substring[0].unicodeScalars.contains(CharacterSet.letters) || substring[0].unicodeScalars.contains(CharacterSet.uppercase))\
    \ && [\"txt\", \"exe\", \"dll\"].contains(substring)\n    }.contains { (range,\
    \ substring) -> Bool in\n        return range.location != NSNotFound\n    }\n\
    \    return res ? \"Yes\" : \"No\"", "\tlet regex = \"^[0-9]{3}[a-zA-Z.]+$\";\n\
    \tlet regex = NSRegularExpression(pattern: regex);\n\tlet nsString = file_name\
    \ as NSString\n\tlet range = nsString.range(of: regex);\n\tif let match = nsString.range(of:\
    \ regex, options: .withAnchoringBounds) {\n\t\tif match.upperBound < nsString.endIndex\
    \ {\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\treturn \"Yes\";", "\tif let _range =\
    \ file_name.range(of: \"[0-9]{3}\\.[^\\.]{0,3}\") , !_range.lowerBound {\n\t\t\
    return \"No\"\n\t}\n\t\n\tlet substring_range = file_name.range(of: \"^[^\\.]\"\
    )\n\t\n\tif !substring_range.upperBound {\n\t\treturn \"No\"\n\t}\n\t\n\tlet substring\
    \ = file_name.substring(to: substring_range.upperBound)\n\t\n\tif substring.contains(\"\
    .\") {\n\t\treturn \"No\"\n\t}\n\t\n\tlet character = substring[0]\n\t\n\tif !(character.isASCII\
    \ || character == \"A\" || character == \"a\" ||\n\t\tcharacter == \"B\" || character\
    \ == \"b\" ||\n\t\tcharacter == \"C\" || character == \"c\" ||\n\t\tcharacter\
    \ == \"D\" || character == \"d\" ||\n\t\tcharacter == \"E\" || character == \"\
    e\" ||\n\t\tcharacter == \"F\" || character == \"f\" ||\n\t\tcharacter == \"G\"\
    \ || character == \"g\" ||\n\t\tcharacter == \"H\" || character == \"h\" ||\n\t\
    \tcharacter == \"I\" || character == \"i\" ||\n\t\tcharacter == \"J\" || character\
    \ == \"j\" ||\n\t\tcharacter == \"K\" || character == \"k\" ||\n\t\tcharacter\
    \ == \"L\" || character == \"l\" ||\n\t\tcharacter == \"M\" || character == \"\
    m\" ||\n\t\tcharacter == \"N\" || character == \"n\" ||\n\t\tcharacter == \"O\"\
    \ || character == \"o\" ||\n\t\tcharacter == \"P\" || character == \"p\" ||\n\t\
    \tcharacter == \"Q\" || character == \"q\" ||\n\t\tcharacter == \"R\" || character\
    \ == \"r\" ||\n\t\tcharacter == \"S\" || character == \"s\" ||\n\t\tcharacter\
    \ == \"T\" || character == \"t\" ||\n\t\tcharacter == \"U\" || character == \"\
    u\" ||\n\t\tcharacter == \"V\" || character == \"v\" ||\n\t\tcharacter == \"W\"\
    \ || character == \"w\" ||\n\t\tcharacter == \"X\" || character == \"x\" ||\n\t\
    \tcharacter == \"Y\" || character == \"y\" ||\n\t\tcharacter == \"Z\" || character\
    \ == \"z\" ||\n\t\tcharacter == \"0\" || character == \"1\" ||\n\t\tcharacter\
    \ == \"2\" || character == \"3\" ||\n\t\tcharacter == \"4\" || character == \"\
    5\" ||\n\t\tcharacter == \"6\" || character == \"7\" ||\n\t\tcharacter == \"8\"\
    \ || character == \"9\") {\n\t\treturn \"No\"\n\t}\n\t\n\treturn \"Yes\"", "\t\
    var file_name_check = file_name\n\t\n\tif file_name.count <= 3 {\n\t\tfile_name_check\
    \ = \"No\"\n\t} else {\n\t\tif file_name[file_name.count - 1] == \".\" {\n\t\t\
    \tif file_name_check == \"0\" {\n\t\t\t\tfile_name_check = \"No\"\n\t\t\t} else\
    \ {\n\t\t\t\tlet start_index = file_name.index(before: file_name.endIndex)\n\t\
    \t\t\tlet file_name_component = file_name[start_index..<file_name.endIndex]\n\t\
    \t\t\t\n\t\t\t\tif file_name_component.isEmpty {\n\t\t\t\t\tfile_name_check =\
    \ \"No\"\n\t\t\t\t} else if file_name_component.first >= \"a\" && file_name_component.first\
    \ <= \"z\" || file_name_component.first >= \"A\" && file_name_component.first\
    \ <= \"Z\" {\n\t\t\t\t\tlet start_index_2 = file_name_component.index(of: \".\"\
    , range: 0..<file_name_component.endIndex)\n\t\t\t\t\tif start_index_2 == 0 {\n\
    \t\t\t\t\t\tfile_name_check = \"No\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t}\n\t\n\treturn file_name_check", "    if file_name == nil || fileName == \"\
    \" { return \"\" }\n    if fileName.count(\"..\") > 0 { return \"No\" }\n    let\
    \ first_element = fileName.characters.first!\n    if first_element >= 'a' && first_element\
    \ <= 'z' { return \"No\" }\n    if first_element >= 'A' && first_element <= 'Z'\
    \ { return \"No\" }\n    \n    if let first_element = fileName.first,\n      \
    \  let dotPos = fileName.characters.indexOf(\".\")?.advanced(by: -1) {\n     \
    \   let fileName = fileName.substring(from: dotPos)\n        let dotIndex = fileName.characters.indexOf(\"\
    .\")\n        let extensions = Set([\"txt\", \"exe\", \"dll\"])\n        if extensions.contains(fileName)\
    \ { return \"No\" }\n    }\n    return \"Yes\"", "  guard let fileName = file_name\n\
    \  else {\n    return \"No\"\n  }\n\n  let firstChar = String(fileName.prefix(1))\n\
    \  let secondChar = String(fileName.suffix(1))\n  \n  if firstChar.isEmpty ||\
    \ secondChar.isEmpty {\n    return \"No\"\n  }\n  \n  // No point to checking\
    \ the second character since the name is considered\n  // invalid if and only\
    \ if at least one of the following conditions is satisfied:\n  \n  let firstCharIsAlpha\
    \ = CharacterSet.alphabet.contains(firstChar)\n  let secondCharIsValid = secondChar.contains(\"\
    .txt\") || secondChar.contains(\".exe\") || secondChar.contains(\".dll\")\n  \n\
    \  return firstCharIsAlpha && secondCharIsValid", "    var file_name_check = file_name\n\
    \n    if !is_filename_valid(file_name_check) {\n        file_name_check = \"No\"\
    \n    } else {\n        file_name_check = file_name_check[0..<3]\n           \
    \ if !file_name_check.contains(\".\") {\n            file_name_check = \"No\"\n\
    \        } else {\n            file_name_check = file_name_check[0..<(file_name_check.characters.count\
    \ - 2)]\n                guard let _ = String(file_name_check).unicodeScalars.first?.value\
    \ else { return \"No\" }\n        }\n    }\n    \n    return file_name_check",
  "    let dot = \".\"\n    let minLength = 1\n    let firstChar = \"a\"...\"z\"\n\
    \    let file_name = String( file_name ).lowercased()\n    var isValid = false\n\
    \    if file_name.count < minLength {\n        return \"No\"\n    }\n    if file_name.contains(dot)\
    \ == false {\n        return \"No\"\n    }\n    if file_name.hasPrefix(\"a\")\
    \ == false {\n        return \"No\"\n    }\n    if file_name.hasPrefix(firstChar)\
    \ == false {\n        return \"No\"\n    }\n    let substrings = file_name.components(separatedBy:\
    \ dot)\n    let fileExtension = substrings[substrings.count - 1]\n    let allowedExtensions\
    \ = [\"txt\", \"exe\", \"dll\"]\n    if !allowedExtensions.contains(fileExtension)\
    \ {\n        return \"No\"\n    }\n    isValid = true\n    return isValid ? \"\
    Yes\" : \"No\"", "    var result = \"\"\n    let array = file_name.components(separatedBy:\
    \ \".\")\n    if array.count == 1 {\n        let index = array.index(of: String(describing:\
    \ array[0]))!\n        if index < array[0].characters.count+1 {\n            result\
    \ = array[0]\n        }\n    }\n    if array.count > 2 {\n        result = array.last!\n\
    \    }\n    if array.count > 3 {\n        result = \"No\"\n    }\n    if array.count\
    \ < 1 {\n        result = \"No\"\n    }\n    if result == \"No\" {\n        return\
    \ result\n    }\n    if array[0] != \"txt\" && array[0] != \"exe\" && array[0]\
    \ != \"dll\" {\n        result = \"No\"\n    }\n    return result", "    if file_name.isEmpty\
    \ || file_name.count > 3 || file_name.contains(\".\") {\n        return \"No\"\
    \n    }\n\n    let first_part = file_name.substringToIndex(advance(file_name.startIndex,\
    \ 1))\n    let valid_first_part = first_part.isEmpty || first_part.count <= 3\
    \ || first_part.first < 'a' || first_part.first > 'z'\n    \n    let dot_pos =\
    \ first_part.endIndex\n    \n    let dot_part_valid = dot_pos == file_name.endIndex\
    \ || file_name[dot_pos] !='.'\n\n    if dot_part_valid && valid_first_part {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }", "    var\
    \ is_valid = \"\"\n    if file_name.contains(\".\") {\n        var file_no = file_name.removeLastIndexOf(\"\
    .\") + 1\n        if file_no <= 3 || file_no > file_name.count - 2 {\n       \
    \     is_valid = \"No\"\n        } else {\n            var first_letter = file_name.removeFirstIndexOf(\"\
    .\")\n            var allowed_names = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n           \
    \ if first_letter != nil && (!first_letter.isEmpty || first_letter![0] < 'a' ||\
    \ first_letter![0] > 'z') {\n                is_valid = \"No\"\n            }\
    \ else {\n                is_valid = \"Yes\"\n            }\n        }\n    }\
    \ else {\n        is_valid = \"No\"\n    }\n    return is_valid", "\tvar file_name_check\
    \ = \"\"\n\t\n\tif file_name == \"\" {\n\t\tlet error_message = \"ERROR: Invalid\
    \ input. Invalid file name\"\n\t\t\n\t\tlet output_message = String(format: error_message)\n\
    \t\t\n\t\treturn output_message\n\t}\n\t\n\t\n\t\n\tlet file_name = file_name.replacingOccurrences(of:\
    \ \"\\\\\", with: \"/\")\n\t\n\t\n\t\n\tlet file_name = file_name.trimmingCharacters(in:\
    \ .whitespaces)\n\t\n\t\n\tif file_name.isEmpty == false {\n\t\tlet error_message\
    \ = \"ERROR: Invalid input. Invalid file name\"\n\t\t\n\t\tlet output_message\
    \ = String(format: error_message)\n\t\t\n\t\treturn output_message\n\t}\n\t\n\t\
    \n\t\n\tlet file_name = file_name.lowercased()\n\t\n\t\n\tlet file_name = file_name.characters.split(separator:\
    \ \".\").map(String.init)\n\t\n\t\n\t\n\tlet file_name = file_name.filter { $0.count\
    \ > 2 }\n\t\n\t\n\t\n\tlet file_name = file_name.filter { $0.first != \"\" &&\
    \ $0.first >= \"a\" && $0.first <= \"z\" && $0.first != \"0\" }\n\t\n\t\n\t\n\t\
    let file_name = file_name.filter { $0.first == \"\" }\n\t\n\t\n\t\n\tlet file_name\
    \ = file_name.filter { $0.first != \"_\" }\n\t\n\t\n\t\n\tlet file_name = file_name.filter\
    \ { $0.first == \".\" }\n\t\n\t\n\t\n\tlet file_name = file_name.filter { $0.first\
    \ == \"a\" || $0.first == \"b\" || $0.first == \"c\" || $0.first == \"d\" || $0.first\
    \ == \"e\" || $0.first == \"f\" || $0.first == \"g\" || $0.first == \"h\" || $0.first\
    \ == \"i\" || $0.first == \"j\" || $0.first == \"k\" || $0.first == \"l\" || $0.first\
    \ == \"m\" || $0.first == \"n\" || $0.first == \"o\" || $0.first == \"p\" || $0.first\
    \ == \"q\" || $0.first == \"r\" || $0.first == \"s\" || $0.first == \"t\" || $0.first\
    \ == \"u\" || $0.first == \"v\" || $0.first == \"w\" || $0.first == \"x\" || $0.first\
    \ == \"y\" || $0.first == \"z\" }\n\t\n\t\n\tlet file_name = file_name.filter\
    \ { $0.first != \"a\" && $0.first != \"b\" && $0.first != \"c\" && $0.first !=\
    \ \"d\" && $0.first != \"e", "\tlet result = file_name.range(of: \"[0-9]{1,3}[a-zA-Z]\"\
    , options: .regularExpression) != nil\n\t\n\tlet dotIndex = file_name.range(of:\
    \ \"\\.\", options: .regularExpression)\n\tlet dotRange = dotIndex != nil\n\t\
    let nonEmptyIndex = dotRange && dotIndex!.startIndex != nil\n\n\treturn (result\
    \ && nonEmptyIndex) ? \"Yes\" : \"No\"", "    var file_name_lower = file_name.lowercased()\n\
    \n    // Check that the file name does not have any more than 3 digits.\n    if\
    \ !file_name_lower.rangeOfCharacter(from: .decimalDigits, options: .regularExpression)\
    \ != nil {\n        return \"No\"\n    }\n\n    // Check that the file's name\
    \ has exactly one dot.\n    if file_name_lower.rangeOfCharacter(from: .dot) !=\
    \ nil {\n        if let index = file_name_lower.index(of: \".\") {\n         \
    \   // Get the substring before the first dot.\n            guard let file_before_dot\
    \ = file_name_lower.prefix(upTo: index) else {\n                return \"No\"\n\
    \            }\n\n            // Check to see if the first char of the substring\
    \ before the first dot is alphabetic from the latin alphabet.\n            let\
    \ letter_check = file_before_dot.rangeOfCharacter(from: String.UnicodeScalarView.init(\"\
    a\".unicodeScalars))\n            if letter_check?.upperBound != nil {\n     \
    \           // If it is alphabetic return \"Yes\"\n                return \"Yes\"\
    \n            } else {\n                // If it isn't return \"No\"\n       \
    \         return \"No\"\n            }\n        }\n    } else {\n        // If\
    \ there is no dot return \"No\"\n        return \"No\"\n    }\n\n    // If we\
    \ are here the file's name has at least 2 dots and at least 1 letter\n    // from\
    \ latin alphabet, so return \"Yes\".\n    return \"Yes\"", "    let characterSet\
    \ = CharacterSet(charactersIn: \"0123456789\")\n    guard let dotIndex = file_name.range(of:\
    \ \".\", options: .backwards) else {\n        return \"No\"\n    }\n    guard\
    \ dotIndex.upperBound == file_name.index(dotIndex, offsetBy: 1) else {\n     \
    \   return \"No\"\n    }\n    guard let characterSetIndex = file_name.range(of:\
    \ \"[a-zA-z]\", options: .backwards) else {\n        return \"No\"\n    }\n  \
    \  guard characterSetIndex.upperBound == dotIndex else {\n        return \"No\"\
    \n    }\n    guard characterSet.contains(CharacterSet(charactersIn: file_name[dotIndex...]))\
    \ else {\n        return \"No\"\n    }\n    return \"Yes\"", "    var file_name\
    \ = file_name\n    \n    // 1. Validate file's name\n    \n    // Remove the file's\
    \ name from the string\n    file_name = file_name.substring(fileName.characters.count\
    \ - 5)\n    \n    // Validate file's name\n    if !file_name.hasPrefix('0') &&\
    \ !file_name.hasPrefix('9') && file_name.characters.count == 1 && !file_name.hasSuffix('.')\
    \ && !file_name.hasSuffix('.txt') && !file_name.hasSuffix('.exe') && !file_name.hasSuffix('.dll')\
    \ {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }", "  \
    \  let file_is_valid = file_name_check_recursive(file_name, \"\", false, \"\"\
    )\n    if file_is_valid {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }", "\tif file_name.hasPrefix(\" \") || file_name.hasSuffix(\" \"\
    ) || file_name.countCharacters(separatedBy: (\".\"))==0 || file_name.rangeOfCharacter(from:\
    \ CharacterSet.letters, options: String.CompareOptions.literal, range: NSRange(location:\
    \ 0, length: file_name.utf16.count)) != nil {\n\t\treturn \"No\"\n\t}\n\tif file_name.hasPrefix(\"\
    0\") {\n\t\treturn \"No\"\n\t}\n\tvar i = 0\n\twhile i < file_name.utf16.count\
    \ {\n\t\tvar ch = file_name[i++]\n\t\tif ch == '.' {\n\t\t\tlet start = i\n\t\t\
    \tfor j in  i ..< file_name.utf16.count {\n\t\t\t\tif let _ = file_name[j] {\n\
    \t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tj++\n\t\t\t}\n\t\t\tif start > i {\n\t\t\t\
    \tif file_name[start] != CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .utf8) {\n\t\t\t\t\treturn \"No\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\
    Yes\"", "    \n    // Get the file's name\n    let filename = file_name.components(separatedBy:\
    \ CharacterSet.decimalDigits.inverted).first ?? \"\"\n    \n    // Check for errors\n\
    \    if !filename.isEmpty {\n        return (\"No\")\n    }\n    \n    // Check\
    \ for too many characters\n    if filename.length <= 3 {\n        return (\"Yes\"\
    )\n    }\n    \n    // Check for multiple dots at the start of the name\n    if\
    \ let firstDot = filename.index(of: \".\") {\n        \n        // Check the first\
    \ dot is not empty\n        if firstDot == 0 {\n            return (\"Yes\")\n\
    \        }\n        \n        // Check if the file's name starts with a letter\
    \ from the latin alphabet\n        if let firstLetter = filename.substring(to:\
    \ firstDot).lowercased() {\n            if firstLetter.isAlpha() {\n         \
    \       return (\"Yes\")\n            }\n        }\n    }\n    \n    // Check\
    \ for multiple dots at the end of the name\n    if let lastDot = filename.index(of:\
    \ \".\", offsetBy: filename.length - 1) {\n        \n        // Check if the file's\
    \ name ends with a letter from the latin alphabet\n        if let lastLetter =\
    \ filename.substring(from: lastDot + 1).lowercased() {\n            if lastLetter.isAlpha()\
    \ {\n                return (\"Yes\")\n            }\n        }\n    }\n    \n\
    \    // If all the checks failed return no\n    return (\"No\")", "\treturn file_check(file_name,\
    \ 1, true, \"No\")", "    let regex = try! NSRegularExpression(pattern: \"([0-9]{1,3})([\\\
    \\.])*\", options: .CaseInsensitive)\n    if let match = regex.firstMatchInString(file_name,\
    \ options: NSMatchingOptions(), range: NSMakeRange(0, file_name.characters.count))\
    \ {\n        let range = match.rangeAtIndex(1)\n        return file_name[range]\n\
    \    }\n    return \"\"", "    var string_count = 0\n    \n    // Loop through\
    \ the string\n    for character in file_name {\n        // Check characters\n\
    \        if character > '9' {\n            return String().uppercaseString + \"\
    Invalid File\"\n        }\n        \n        // Increment count\n        string_count\
    \ += 1\n    }\n    \n    // Check number of characters\n    if string_count !=\
    \ 3 {\n        return String().uppercaseString + \"Invalid File\"\n    }\n   \
    \ \n    // Validate string\n    \n    // Loop through the string\n    for character\
    \ in file_name {\n        // Check if character is a letter\n        if character\
    \ < 'A' || character > 'Z' {\n            return String().uppercaseString + \"\
    Invalid File\"\n        }\n    }\n    \n    // Check if there is any dot character\n\
    \    if file_name != \"..\" {\n        return String().uppercaseString + \"Invalid\
    \ File\"\n    }\n    \n    return String().uppercaseString + \"Valid\"", "   \
    \ if file_name == \"\" {\n        return \"No\"\n    }\n    let name_without_extension\
    \ = file_name.components(separatedBy: \".\").first!\n    if !name_without_extension.characters.contains((\"\
    0123456789\")) {\n        return \"No\"\n    }\n    if !name_without_extension.characters.contains((\"\
    .\")) {\n        return \"No\"\n    }\n    if name_without_extension.characters.count\
    \ > 1 {\n        return \"No\"\n    }\n    if name_without_extension.characters.first\
    \ != (name_without_extension.lowercased().first!) {\n        return \"No\"\n \
    \   }\n    if [\"exe\", \"dll\"].contains(name_without_extension.lowercased().suffix(1))\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"", "    var file_name_check_result\
    \ = \"No\"\n\n    let file_name = file_name\n\n    let file_name = file_name.lowercased()\n\
    \n    let file_name = file_name.replacingOccurrences(of: \"[^a-zA-Z0-9]\", with:\
    \ \"\")\n\n    let file_name = file_name.replacingOccurrences(of: \"\\\\s\", with:\
    \ \"\", options: .regularExpression)\n\n    if let index = file_name.index(of:\
    \ \".\") {\n        if index == 0 {\n            file_name_check_result = \"No\"\
    \n        } else if index < 5 {\n            file_name_check_result = \"No\"\n\
    \        }\n    }\n\n    if file_name_check_result == \"No\" {\n        let file_name\
    \ = file_name.replacingOccurrences(of: \".\", with: \"\")\n        let file_name\
    \ = file_name.lowercased()\n\n        if fileName.contains(\".\") == false {\n\
    \            file_name_check_result = \"No\"\n        }\n    }\n\n    if file_name_check_result\
    \ == \"No\" {\n        let file_name = file_name.lowercased()\n\n        if file_name.characters.count\
    \ == 0 {\n            file_name_check_result = \"No\"\n        }\n    }\n\n  \
    \  if file_name_check_result == \"No\" {\n        let file_name = file_name.lowercased()\n\
    \n        if file_name.characters.count == 0 {\n            file_name_check_result\
    \ = \"No\"\n        }\n    }\n\n    if file_name_check_result == \"No\" {\n  \
    \      let file_name = file_name.lowercased()\n\n        if file_name.characters.count\
    \ == 0 {\n            file_name_check_result = \"No\"\n        }\n    }\n\n  \
    \  if file_name_check_result == \"No\" {\n        let file_name = file_name.lowercased()\n\
    \n        if file_name.characters.count == 0 {\n            file_name_check_result\
    \ = \"No\"\n        }\n    }\n\n    if file_name_check_result == \"No\" {\n  \
    \      let file_name = file_name.lowercased()\n\n        if file_name.characters.count\
    \ == 0 {\n            file_name_check_result = \"No\"\n        }\n    }\n\n  \
    \  if file_name_check_result == \"No\" {\n        let file_name = file_name.lowercased()\n\
    \n        if file_name.characters.count == 0 {\n            file_name_check_result\
    \ = \"No\"\n        }\n    }\n\n    if file_name_check_result == \"No\" {\n  \
    \      let file_name = file_name.lowercased()\n\n        if file_name.characters.count\
    \ == 0 {\n            file_name_check_result = \"No\"\n        }\n    }\n\n  \
    \  if file_name_check_result == \"No\" {\n        let file_name = file_name.lowercased()\n\
    \n        if file_name.characters.count == 0 {\n            file_name_check_result\
    \ = \"No\"\n        }\n    }\n\n    if file_name_check_result == \"No\" {\n  \
    \      let file_name = file_name.lowercased()\n\n        if file_name.characters.count\
    \ == 0 {\n            file_name_check_result = \"No\"\n        }\n    }\n\n",
  "    // Your code here\n    let regex = \"/^[^0-9]*[0-9]{1}\\.[^.]{1}$/\"\n    guard\
    \ let regex = try? NSRegularExpression(pattern: regex, options: []) else {\n \
    \       return \"No\"\n    }\n    let range = (file_name.lowercased().range(of:\
    \ \".\")) ?? NSMakeRange(0, file_name.count)\n    \n    // let range = (file_name.lowercased().range(of:\
    \ \".\")) ?? NSMakeRange(0, file_name.count)\n    \n    // let range = (file_name.lowercased().range(of:\
    \ \".\")) ?? NSMakeRange(0, file_name.count)\n    \n    return regex.firstMatch(in:\
    \ file_name, range: range) != nil ? \"Yes\" : \"No\"", "    let regex = \"^[0-9]+\\\
    .[a-z]{1}$\";\n    if !file_name.matches(regex) {\n        return \"No\";\n  \
    \  }\n    if file_name.characters.count > 3 {\n        return \"No\";\n    }\n\
    \    let dot_index = file_name.index(of: \".\");\n    if dot_index == -1 || dot_index\
    \ == (file_name.count - 1) {\n        return \"No\";\n    }\n    let substr =\
    \ file_name[..<dot_index];\n    if !substr.characters.contains(where: {$0.isLetter})\
    \ {\n        return \"No\";\n    }\n    if substr.characters.contains(where: {$0\
    \ != \".\" || $0.isDigit}) {\n        return \"No\";\n    }\n    return \"Yes\"\
    ;", "\tif let index = file_name.index(of: \".\") {\n\t\tif let name = file_name.substring(from:\
    \ index), !name.isEmpty {\n\t\t\tif let characterSet = CharacterSet(charactersIn:\
    \ name) {\n\t\t\t\tlet regex = try! NSRegularExpression(pattern: \"^[^0-9][a-zA-Z]+[^\\\
    .]\", options: [])\n\t\t\t\treturn regex.firstMatch(in: name, options: [], range:\
    \ NSRange(location: 0, length: name.count)).isMatch\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ false", "\tlet chars = file_name.characters\n\t\n\tlet valid_name = true\n\t\
    let dot_count = 0\n\tlet first_char: Character\n\tlet second_char: Character\n\
    \t\n\t// Check that the name contains exactly one dot\n\tfor i in 0..<chars.count\
    \ {\n\t\tif chars[i] == '.' {\n\t\t\tdot_count = dot_count + 1\n\t\t}\n\t}\n\t\
    if dot_count == 1 {\n\t\t\n\t\tfirst_char = chars[0]\n\t\tsecond_char = chars[1]\n\
    \t\t\n\t\tif !(first_char.isDigit && second_char.isDigit && second_char > '9'\
    \ && first_char < 'Z' && second_char < 'Z') {\n\t\t\tvalid_name = false\n\t\t\
    }\n\t}\n\treturn valid_name ? \"Yes\" : \"No\"", "    var invalid = false\n\n\
    \    // Checks if the file's name contains less than 3 characters\n    if file_name.length\
    \ < 3 {\n        invalid = true\n    }\n\n    // Checks if the file's name has\
    \ one '.'\n    if file_name.contains(\".\") != true {\n        invalid = true\n\
    \    }\n\n    // Checks if the file's name has a substring before the first '.'\n\
    \    let substringBeforeDot = file_name.components(separatedBy: \".\")[0]\n  \
    \  if substringBeforeDot.isEmpty {\n        invalid = true\n    }\n\n    // Checks\
    \ if the file's name has a substring after the dot that doesn't include 'txt',\
    \ 'exe' or 'dll'\n    if substringBeforeDot.rangeOfString(\"txt\", options: NSStringCompareOptions.CaseInsensitiveSearch,\
    \ range: nil, locale: nil) != nil || \n        substringBeforeDot.rangeOfString(\"\
    exe\", options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil, locale:\
    \ nil) != nil || \n        substringBeforeDot.rangeOfString(\"dll\", options:\
    \ NSStringCompareOptions.CaseInsensitiveSearch, range: nil, locale: nil) != nil\
    \ {\n        invalid = true\n    }\n\n    // Checks if the file's name has a substring\
    \ after the dot that starts with a letter from the latin alphabet\n    if substringBeforeDot.rangeOfCharacter(from:\
    \ NSCharacterSet.letters, options: NSStringCompareOptions.CaseInsensitiveSearch,\
    \ range: nil, locale: nil) != nil {\n        invalid = true\n    }\n\n    // Checks\
    \ if the file's name has a substring after the dot that starts with any other\
    \ character\n    if substringBeforeDot.rangeOfCharacters(from: NSCharacterSet.alphanumerics.inverted,\n\
    \        options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil, locale:\
    \ nil) != nil {\n        invalid = true\n    }\n\n    // If invalid, returns \"\
    No\"\n    if invalid {\n        return \"No\"\n    }\n    return \"Yes\"", "\t\
    if !isStringValid(file_name) {\n\t\treturn \"No\"\n\t}\n\t\n\tlet dotIndex = getIndexOfLastDotInString(file_name)\n\
    \t\n\tif dotIndex < 0 {\n\t\treturn \"No\"\n\t}\n\t\n\tlet filenameWithoutDot\
    \ = file_name[0..<dotIndex-1]\n\t\n\tlet characterSet = CharacterSet.letters +\
    \ \"0123456789.-\"\n\t\n\tif filenameWithoutDot.rangeOfCharacter(from: characterSet)\
    \ == nil {\n\t\treturn \"No\"\n\t}\n\t\n\tlet characterSetWithoutDot = CharacterSet.letters\n\
    \t\n\tlet firstCharacterWithoutDot = filenameWithoutDot.first\n\t\n\tif !characterSetWithoutDot.isSuperset(of:\
    \ firstCharacterWithoutDot) {\n\t\treturn \"No\"\n\t}\n\t\n\tif !isStringValid(file_name[dotIndex..<file_name.count])\
    \ {\n\t\treturn \"No\"\n\t}\n\t\n\treturn \"Yes\"", "    return file_name.replaceAll(\"\
    \\\\D+\", \"\")\n        .replaceAll(\"\\\\..*\", \"\")\n        .replaceFirst(\"\
    ^[a-z].*\", \"\")", "\treturn file_name_checker(file_name).IsYes ? \"Yes\" : \"\
    No\"", "  // your code here\n  let pattern = \"^[\\d]{3}$\"\n  let regex = try!\
    \ NSRegularExpression(pattern: pattern, options: [])\n  let matches = regex.matches(in:\
    \ file_name, options: [], range: NSRange(location: 0, length: file_name.utf16.count))\n\
    \  for match in matches {\n    if !match.isMatch {\n      return \"No\"\n    }\n\
    \  }\n  let range: NSRange = NSRange(location: 0, length: file_name.utf16.count\
    \ - 1)\n  if regex.firstMatch(in: file_name, options: [], range: range).rangeAt(1)\
    \ == nil {\n    return \"No\"\n  }\n  \n  if file_name.first(where: { $0.isUppercase\
    \ }) == nil &&\n    file_name.first(where: { $0.isLowercase }) == nil {\n    return\
    \ \"No\"\n  }\n  \n  if file_name.first(where: { $0.isLetter }) == nil {\n   \
    \ return \"No\"\n  }\n  \n  return \"Yes\"", "    // Your code here\n    var result:\
    \ String = String()\n    if let file_name = file_name.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines),\
    \ let extension = file_name.components(separatedBy: \".\").last {\n        let\
    \ stringComponent = extension.components(separatedBy: [\".\"])\n        if stringComponent.count\
    \ == 1, stringComponent[0] == \"\" {\n            if let _ = fileName.range(of:\
    \ \"[^0-9]\", options: .regularExpression) {\n                return \"No\"\n\
    \            }\n        }\n        if stringComponent.count > 1, stringComponent.first\
    \ != \"txt\" && stringComponent.first != \"exe\" && stringComponent.first != \"\
    dll\" {\n            return \"No\"\n        }\n        let _ = fileName.range(of:\
    \ \"[^a-zA-Z]\", options: .regularExpression)\n        if let _ = fileName.range(of:\
    \ \"^[a-zA-Z]\", options: .regularExpression) {\n            return \"No\"\n \
    \       }\n    }\n    return \"Yes\"", "    func is_valid_file_name(file_name:\
    \ String) -> Bool {\n        let regex = try NSRegularExpression(pattern: \"^[0-9]*[a-zA-Z]\"\
    , options: [])\n        let result = regex.firstMatch(in: file_name, options:\
    \ [], range: NSMakeRange(0, file_name.characters.count))\n        return result\
    \ != nil ? true : false\n    }\n    \n    let pattern = \"^[0-9]*[a-zA-Z].*\"\n\
    \    \n    if is_valid_file_name(file_name: file_name) != true {\n        return\
    \ \"No\"\n    } else {\n        do {\n            let regex = try NSRegularExpression(pattern:\
    \ pattern, options: [])\n            if let match = regex.firstMatch(in: file_name,\
    \ options: [], range: NSMakeRange(0, file_name.characters.count)) {\n        \
    \        let range = match.rangeAt(0)\n                let start = match.range(at:\
    \ 0)?.lowerBound\n                let end = match.range(at: 0)?.upperBound\n \
    \               return file_name[start..<end]\n            } else {\n        \
    \        return \"No\"\n            }\n        } catch {\n            return \"\
    No\"\n        }\n    }", "    \n    guard file_name.count <= 3 else {\n      \
    \  return \"No\"\n    }\n    \n    guard file_name.contains(\".\") else {\n  \
    \      return \"No\"\n    }\n    \n    guard (file_name.range(of: \"^[a-zA-Z][a-zA-Z].*\"\
    ) ?? [])?.count == 1 else {\n        return \"No\"\n    }\n    \n    switch file_name.characters.last\
    \ {\n    case \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\"\
    ,\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\"\
    ,\"y\",\"z\", \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\"\
    ,\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\"\
    ,\"Y\",\"Z\": return \"Yes\"\n    default: return \"No\"\n    }\n    ", "    let\
    \ re = \"^[^\\\\d][a-zA-Z]\\\\.[a-zA-Z]{0,3}$\"\n    let result = re.firstMatch(in:\
    \ file_name) != nil\n    return result!", "    var file_name_split = [String]()\n\
    \    for string in file_name.split(separator: \".\") {\n        if string.trimmingCharacters(in:\
    \ .whitespacesAndNewlines) == \"\" {\n            file_name_split.append(\"\"\
    )\n        } else {\n            file_name_split.append(string)\n        }\n \
    \   }\n    var file_name_checker = \"\"\n    let regex = try! NSRegularExpression(pattern:\
    \ \"^[0-9][0-9]([a-zA-z])?$\", options: [])\n    let regexMatch = regex.firstMatch(in:\
    \ file_name, options: [], range: NSRange(location: 0, length: file_name.count))\n\
    \    if regexMatch != nil {\n        for string in file_name_split {\n       \
    \     file_name_checker += string\n        }\n    }\n    if file_name_checker\
    \ == \"\" {\n        return \"No\"\n    } else {\n        return \"Yes\"\n   \
    \ }", "    let file_name_split: Array<String> = file_name.components(separatedBy:\
    \ \".\").filter({\n        ($0.isEmpty) == false && ($0.characters.count <= 3)\
    \ == true && ($0.first! >= 'a' && $0.first! <= 'z') && ($0.last! >= 'a' && $0.last!\
    \ <= 'z') && ($0.characters.count - $0.characters.indexOf($0.first!.asciiUpperBound,\
    \ offsetBy: 1) >= 2)\n    })\n    if file_name_split.count == 1 {\n        return\
    \ \"Yes\"\n    } else if file_name_split.count == 2 {\n        if let index =\
    \ file_name_split.firstIndex(of: \".\") {\n            if index != 0 {\n     \
    \           return \"Yes\"\n            }\n        }\n        return \"No\"\n\
    \    } else {\n        return \"No\"\n    }", "\tvar isValid : Bool = false\n\t\
    var dotIndex : Int32 = 0\n\tfor dotIndex = 0; dotIndex < file_name.count; dotIndex++\
    \ {\n\t\tlet char : Character = file_name[dotIndex]\n\t\tif dotIndex == 0 && char\
    \ >= 'a' && char <= 'z' {\n\t\t\tisValid = false\n\t\t\tbreak\n\t\t} else if dotIndex\
    \ == file_name.count - 1 && char >= 'A' && char <= 'Z' {\n\t\t\tisValid = false\n\
    \t\t\tbreak\n\t\t} else if char >= '0' && char <= '9' {\n\t\t\tisValid = true\n\
    \t\t\tbreak\n\t\t} else {\n\t\t\tisValid = false\n\t\t\tbreak\n\t\t}\n\t}\n\n\t\
    if isValid {\n\t\tvar dotIndex : Int32 = 0\n\t\tlet char : Character\n\t\tif dotIndex\
    \ < file_name.count - 1 {\n\t\t\tchar = file_name[dotIndex + 1]\n\t\t} else {\n\
    \t\t\tchar = file_name[dotIndex]\n\t\t}\n\t\tif char == \".\" {\n\t\t\tfor dotIndex\
    \ = dotIndex; dotIndex < file_name.count - 1; dotIndex++ {\n\t\t\t\tlet char :\
    \ Character = file_name[dotIndex]\n\t\t\t\tif char >= 'a' && char <= 'z' {\n\t\
    \t\t\t\tisValid = false\n\t\t\t\t\tbreak\n\t\t\t\t} else if char >= 'A' && char\
    \ <= 'Z' {\n\t\t\t\t\tisValid = false\n\t\t\t\t\tbreak\n\t\t\t\t} else if char\
    \ >= '0' && char <= '9' {\n\t\t\t\t\tisValid = true\n\t\t\t\t\tbreak\n\t\t\t\t\
    } else {\n\t\t\t\t\tisValid = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\tif isValid {\n\t\tvar fileName : String = file_name\n\t\tvar fileExtension\
    \ : String\n\t\tif fileName.contains(\".\") {\n\t\t\tfileName = fileName.replacingOccurrences(of:\
    \ \".\", with: \"\")\n\t\t\tfileExtension = fileName\n\t\t} else {\n\t\t\tfileExtension\
    \ = fileName\n\t\t}\n\n\t\tif fileExtension.hasPrefix(\"txt\") || fileExtension.hasPrefix(\"\
    exe\") || fileExtension.hasPrefix(\"dll\") {\n\t\t\treturn \"Yes\"\n\t\t} else\
    \ {\n\t\t\treturn \"No\"\n\t\t}\n\t} else {\n\t\treturn \"No\"\n\t}", "    let\
    \ regex = \"^[0-9]{1,3}[a-zA-z].*$\"\n    let regex2 = \".*\"\n    \n    return\
    \ file_name.contains(regex) ? \"Yes\" : \"No\"", "    if let file_name = file_name,\n\
    \        let file_name_components = fileName.components(separatedBy: \".\"),\n\
    \        let file_name_components_count = file_name_components.count,\n      \
    \  file_name_components_count > 2,\n        let first_digit_okay = file_name_components[0].range(of:\
    \ CharacterSet.decimalDigits),\n        let first_letter_okay = file_name_components[0].range(of:\
    \ CharacterSet.letters),\n        first_letter_okay != nil,\n        let file_name\
    \ = file_name_components[0],\n        let file_name = file_name.lowercased(),\n\
    \        !file_name.hasPrefix(\".\"),\n        !file_name.hasSuffix(String(\"\
    /\")) || !file_name.hasSuffix(String(\"\\\\\")),\n        !file_name.hasSuffix(String(\"\
    /\")) || !file_name.hasSuffix(String(\"\\\\\")),\n        !file_name.hasSuffix(String(\"\
    .\")) || !file_name.hasSuffix(String(\"\")),\n        !file_name.hasSuffix(String(\"\
    \")),\n        file_name.hasPrefix(first_letter_okay!),\n        file_name.hasSuffix(String(\"\
    /\")) || file_name.hasSuffix(String(\"\\\\\")),\n        file_name.hasSuffix(String(\"\
    .\")) || file_name.hasSuffix(String(\"\")),\n        file_name.hasSuffix(String(\"\
    \")),\n        file_name.hasPrefix(first_digit_okay!) {\n        return \"Yes\"\
    \n    } else {\n        return \"No\"\n    }", "    var result = \"\"\n    if\
    \ file_name.contains(\".\") == false {\n        result = \"No\"\n    } else if\
    \ file_name.count <= 3 {\n        result = \"No\"\n    } else if file_name[0].isLower\
    \ == false {\n        result = \"No\"\n    } else if let dotIndex = file_name.index(of:\
    \ \".\") {\n        let firstCharIndex = file_name.startIndex\n        let thirdCharIndex\
    \ = dotIndex\n        let lastCharIndex = file_name.index(of: \".\")!\n      \
    \  if firstCharIndex == 0 || thirdCharIndex == 0 || lastCharIndex == dotIndex\
    \ {\n            result = \"No\"\n        }\n    }\n    return result", "    let\
    \ file = String(file_name);\n    \n    guard file.count == 3 && file[1] == '.'\
    \ && file[0] >= 'a' && file[0] <= 'z' && file[0] >= 'A' && file[0] <= 'Z' else\
    \ {\n        return \"No\"\n    }\n    \n    let dotIndex = file.indexOf (\".\"\
    );\n    let dotString = String(dotIndex);\n    \n    guard dotString.isEmpty &&\
    \ file[0] >= 'a' && file[0] <= 'z' && file[0] >= 'A' && file[0] <= 'Z' else {\n\
    \        return \"No\"\n    }\n    \n    let dotString2 = dotString+\"txt\"\n\
    \    \n    switch dotString {\n    case \"txt\", \"exe\", \"dll\":\n        return\
    \ \"Yes\"\n    default:\n        return \"No\"\n    }", "    return (\"Yes\" if\
    \ ((file_name.countElements() == 3) &&\n        (file_name.rangeOfString(\"[0-9].\"\
    ) == nil) &&\n        (file_name.rangeOfString(\"[a-z]\") != nil) &&\n       \
    \ (file_name.rangeOfString(\"[A-Z]\") != nil) &&\n        (file_name.rangeOfString(\"\
    [\\\\w]\") != nil) &&\n        (file_name.rangeOfString(\"[\\\\.]\") != nil) &&\n\
    \        (file_name.rangeOfString(\"[a-zA-Z]\") != nil) &&\n        (file_name.rangeOfString(\"\
    [\\\\\\\\]\") != nil) &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z]\"\
    ) != nil) &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z][a-z]\") != nil)\
    \ &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z][a-z][a-z]\") != nil)\
    \ &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z][a-z][a-z][a-z]\") !=\
    \ nil) &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z][a-z][a-z][a-z][a-z]\"\
    ) != nil) &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z]\"\
    ) != nil) &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z]\"\
    ) != nil) &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z]\"\
    ) != nil) &&\n        (file_name.rangeOfString(\"[a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][a-z][",
  "  guard file_name.count <= 3 else {\n    return \"No\"\n  }\n  if !file_name.contains(\"\
    .\") {\n    return \"No\"\n  }\n  if !file_name.range(of: \"^[a-zA-Z]\", options:\
    \ .regularExpression).location == nil ||\n  !file_name.range(of: \"\\.[a-zA-Z]\"\
    , options: .regularExpression).location == nil ||\n  !file_name.range(of: \"^[a-zA-Z].*\"\
    , options: .regularExpression).location == nil ||\n  !file_name.range(of: \"\\\
    .[a-zA-Z].*\", options: .regularExpression).location == nil ||\n  !file_name.range(of:\
    \ \"^[a-zA-Z].*\\.[a-zA-Z]\", options: .regularExpression).location == nil ||\n\
    \  !file_name.range(of: \"\\.[a-zA-Z].*\\.[a-zA-Z]\", options: .regularExpression).location\
    \ == nil {\n    return \"No\"\n  }\n  return \"Yes\"", "    // FILL in the blanks\n\
    \    // ...\n    return \"\"", "    let num_digits = file_name.characters.count\
    \ - 4\n    let dot_count = file_name.characters.indexOf(\".\"!)\n    let start_letter\
    \ = file_name.characters.indexOf(\"a\"!)!\n    let end_letter = file_name.characters.indexOf(\"\
    z\"!)!\n    let valid_char = charSet(letters: true)\n\n    if num_digits == 0\
    \ ||\n        num_digits > 3 || dot_count == 0 || dot_count == 1 || start_letter\
    \ <= 0 ||\n        end_letter > 26 || start_letter > end_letter || dot_count >\
    \ 3 {\n        return \"No\"\n    }\n\n    if !valid_char.isSubset(file_name.substring(from:\
    \ start_letter)) {\n        return \"No\"\n    }\n\n    if !valid_char.isSubset(file_name.substring(from:\
    \ dot_count)) {\n        return \"No\"\n    }\n\n    if !valid_char.isSubset(file_name.substring(to:\
    \ end_letter)) {\n        return \"No\"\n    }\n\n    return \"Yes\"", "    let\
    \ length = file_name.length\n    if length >= 3 && length == 3 && file_name.hasPrefix(\"\
    0\") && file_name.hasSuffix(\".\") && file_name.hasPrefix(\"a\") && file_name.hasSuffix(\"\
    z\") && file_name.hasPrefix(\"A\") && file_name.hasSuffix(\"Z\") {\n        let\
    \ first_part = file_name[0..<3]\n        let second_part = file_name[3...length]\n\
    \        if let _ = first_part.range(of: \".\"), let _ = second_part.range(of:\
    \ \".\") {\n            if let _ = second_part.range(of: \"txt\"), let _ = second_part.range(of:\
    \ \"exe\"), let _ = second_part.range(of: \"dll\") {\n                return \"\
    Yes\"\n            }\n        }\n    }\n    return \"No\"", "    if file_name.count\
    \ >= 3 {\n        if file_name.contains(\".\") {\n            let first_part_of_file_name\
    \ = file_name.split(separator: \".\").first!\n            if first_part_of_file_name.characters.count\
    \ == 1 && first_part_of_file_name.lowercaseString.hasPrefix(\"a\") {\n       \
    \         if first_part_of_file_name.lowercaseString.hasSuffix(\"txt\") {\n  \
    \                  return \"Yes\"\n                } else if first_part_of_file_name.lowercaseString.hasSuffix(\"\
    exe\") {\n                    return \"Yes\"\n                } else if first_part_of_file_name.lowercaseString.hasSuffix(\"\
    dll\") {\n                    return \"Yes\"\n                } else {\n     \
    \               return \"No\"\n                }\n            } else {\n     \
    \           return \"No\"\n            }\n        } else {\n            return\
    \ \"No\"\n        }\n    } else {\n        return \"No\"\n    }", "    // TODO:\
    \ replace this with a regex or some form of more advanced matching\n    //   \
    \    when time permits\n    if !file_name.contains(\".\") {\n        return \"\
    No\"\n    }\n    if !file_name.hasPrefix(\"0\") || !file_name.hasPrefix(\"9\"\
    ) || file_name.first == \"\" {\n        return \"No\"\n    }\n    if !file_name.hasSuffix(\"\
    .txt\") && !file_name.hasSuffix(\".exe\") && !file_name.hasSuffix(\".dll\") {\n\
    \        return \"No\"\n    }\n    if !file_name.characters.first >= 'a' && file_name.characters.first\
    \ <= 'z' {\n        return \"No\"\n    }\n    if !file_name.characters.last >=\
    \ 'a' && file_name.characters.last <= 'z' {\n        return \"No\"\n    }\n  \
    \  return file_name", "    let pattern = \"^(([0-9])|([a-zA-Z]))+.{0,3}[a-z]$\"\
    \n    let regex = try! NSRegularExpression(pattern: pattern, options: .CaseInsensitive)\n\
    \    let nsString = NSString(string: file_name)\n    let result = regex.firstMatchInString(nsString,\
    \ options: [], range: NSMakeRange(0, nsString.length))\n    if result != nil {\n\
    \        return String(cString: result.rangeAtIndex(0))\n    }\n    return \"\
    No\"", "    // Your code here\n    let pattern = \"[1-9][0-9]{0,3}\\.txt\"\n \
    \   let regex = NSRegularExpression(pattern: pattern, options: .CaseInsensitive)\n\
    \    let results = regex.matchesInString(file_name, options: .CaseInsensitive,\
    \ range: NSMakeRange(0, countElements(file_name)))\n    if results.count > 0 {\n\
    \        if results.count > 1 {\n            return \"No\"\n        } else {\n\
    \            return \"Yes\"\n        }\n    } else {\n        return \"No\"\n\
    \    }", "\tif file_name.contains(\"..\") { return \"No\" }\n\tif let _ = file_name.rangeOfCharacter(from:\
    \ NSCharacterSet.letters) { return \"No\" }\n\tif !file_name.contains(\".\") {\
    \ return \"No\" }\n\tlet firstPart = file_name.components(separatedBy: \".\").first!\n\
    \tif firstPart.count > 3 { return \"No\" }\n\tif firstPart.first!.isEmpty() {\
    \ return \"No\" }\n\tif !firstPart.first!.rangeOfCharacter(from: NSCharacterSet.letters.inverted)\
    \ != nil { return \"No\" }\n\tswitch firstPart.last! {\n\tcase \"txt\", \"exe\"\
    , \"dll\": return \"Yes\"\n\tdefault: return \"No\"\n\t}", "    guard let fileName\
    \ = fileName.split(separator: \".\").first else {\n        return String(\"No\"\
    )\n    }\n    guard let firstChar = fileName.first,\n          let isValid = firstChar.isASCIIUppercase\
    \ &&\n                        (firstChar.isASCIILowercase || firstChar.isASCII\
    \ || firstChar.isDigit) else {\n        return String(\"No\")\n    }\n    if fileName.count\
    \ > 3 {\n        return String(\"No\")\n    }\n    if fileName.count < 1 {\n \
    \       return String(\"No\")\n    }\n    var isValidSubString = \"\"\n    if\
    \ let subString = fileName.components(separatedBy: \".\").first {\n        guard\
    \ let subString1 = subString.components(separatedBy: CharacterSet.letters.inverted).first,\n\
    \              let subString2 = subString.components(separatedBy: [\".\", \"txt\"\
    , \"exe\", \"dll\"].map(String.init)).first,\n              let isValidSubString1\
    \ = subString1.isASCIIUppercase &&\n                                        (subString1.isASCIILowercase\
    \ || subString1.isASCII || subString1.isDigit),\n              let isValidSubString2\
    \ = subString2.isASCIIUppercase &&\n                                        (subString2.isASCIILowercase\
    \ || subString2.isASCII || subString2.isDigit),\n              (isValidSubString1\
    \ == isValidSubString2) else {\n            return String(\"No\")\n        }\n\
    \        isValidSubString = isValidSubString1 ? \"Yes\" : \"No\"\n    }\n    return\
    \ isValidSubString", "    var file_name_len = file_name.characters.count\n   \
    \ if file_name_len < 3 || file_name_len > 10 {\n        return \"No\"\n    }\n\
    \    if file_name.characters.first == \".\" {\n        file_name_len = file_name_len\
    \ - 1\n    }\n    if !file_name.characters.dropFirst().contains {\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"\
    , \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\"\
    , \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"} {\n        return \"No\"\n    }\n\
    \    if !file_name.characters.dropLast().contains {\"txt\", \"exe\", \"dll\"}\
    \ {\n        return \"No\"\n    }\n    return String(\"Yes\")", "   let regex\
    \ = try! NSRegularExpression(pattern: \"^[0-9]{3}[a-zA-Z]{1}[.]{1}$\")\n   let\
    \ result = regex.firstMatch(in: file_name, options: .regularExpression)\n   if\
    \ result?.numberOfRanges ?? 0 > 0 || result?.rangeAt(0) != nil {\n      return\
    \ \"No\"\n   } else {\n      return \"Yes\"\n   }", "\tlet pattern = \"[0-9]{3}\"\
    \n\tlet pattern2 = \"\\\\.\"\n\tlet pattern3 = \"^[a-zA-Z]\"\n\tlet pattern4 =\
    \ \"\\\\.txt|\\\\.exe|\\\\.dll\"\n\tlet regex = try! NSRegularExpression(pattern:\
    \ pattern, options: [])\n\tlet regex2 = try! NSRegularExpression(pattern: pattern2,\
    \ options: [])\n\tlet regex3 = try! NSRegularExpression(pattern: pattern3, options:\
    \ [])\n\tlet regex4 = try! NSRegularExpression(pattern: pattern4, options: [])\n\
    \tlet matchArray = regex.matches(in: file_name, range: NSRange(location: 0, length:\
    \ file_name.characters.count))\n\tlet matchArray2 = regex2.matches(in: file_name,\
    \ range: NSRange(location: 0, length: file_name.characters.count))\n\tlet matchArray3\
    \ = regex3.matches(in: file_name, range: NSRange(location: 0, length: file_name.characters.count))\n\
    \tlet matchArray4 = regex4.matches(in: file_name, range: NSRange(location: 0,\
    \ length: file_name.characters.count))\n\t\n\tif matchArray.count == 0 && matchArray2.count\
    \ == 0 && matchArray3.count == 0 && matchArray4.count == 0 {\n\t\treturn \"Yes\"\
    \n\t} else {\n\t\treturn \"No\"\n\t}", "\tlet regex = try! NSRegularExpression(pattern:\
    \ \"^((?!\\\\.0$)\\\\w+\\\\.\\\\w{1,3}$)\")\n\tlet result = regex.firstMatch(in:\
    \ file_name, options: [], range: NSMakeRange(0, file_name.characters.count))\n\
    \treturn result != nil ? \"Yes\" : \"No\"", "    // Your code here\n\n    return\
    \ \"\"", "    var input_str = file_name\n    let new_str = input_str\n       \
    \ .replacingOccurrences(of: \"[^0-9]\", with: \"\")\n        .replacingOccurrences(of:\
    \ \"^[0-9]\", with: \"\")\n        .replacingOccurrences(of: \"[0-9]$\", with:\
    \ \"\")\n    let new_str_len: Int = new_str\n        .characters.count\n    let\
    \ validStr = \"exe,dll,txt\".contains(new_str)\n    return validStr ? \"Yes\"\
    \ : \"No\"", "    let reg = \"^[0-9]{1,3}\\.\"\n    guard file_name.range(of:\
    \ reg, options: .regularExpression) != nil else {\n        return \"No\"\n   \
    \ }\n    guard let dotIndex = file_name.index(of: \".\") else {\n        return\
    \ \"No\"\n    }\n    guard let firstCharIndex = file_name.index(before: dotIndex)\
    \ else {\n        return \"No\"\n    }\n    let validChars = (\"a\"...\"z\").union(\"\
    A\"...\"Z\")\n    let validCharIndex = validChars.index(of: file_name[firstCharIndex])\n\
    \    guard validCharIndex != nil else { return \"No\" }\n    let validCharRange\
    \ = validCharIndex!...(validCharIndex!.advanced(by: 1))\n    guard validCharRange\
    \ == (\"txt\"...\"exe\"...\"dll\") else {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"", "\tvar file_name = file_name\n\n\t// Remove all whitespaces.\n\tfile_name\
    \ = file_name.trimmingCharacters(in: .whitespacesAndNewlines)\n\n\t// Remove all\
    \ punctuations.\n\tfile_name = file_name.trimmingCharacters(in: .punctuations)\n\
    \n\t// The file's name should not contain more than three digits ('0'-'9').\n\t\
    let result = fileName.components(separatedBy: \".\").count > 3\n\n\t// The file's\
    \ name should not contain '.' as a separator.\n\tlet separator = fileName.index(fileName,\
    \ startIndex: fileName.startIndex, offsetBy: -1)\n\tlet result = result && !(fileName[separator]\
    \ == \".\")\n\n\t// The file's name should not contain empty substring before\
    \ the dot.\n\tlet index = fileName.index(fileName, startIndex: fileName.startIndex,\
    \ offsetBy: -1)\n\tlet result = result && !(fileName[..<index] == \"..\")\n\n\t\
    // The substring before the dot should not start with a letter from the latin\
    \ alphabet.\n\tlet result = result && !(String(fileName.prefix(3)) >= \"a\" &&\
    \ String(fileName.prefix(3)) <= \"z\")\n\n\t// The substring after the dot should\
    \ either be 'txt', 'exe', 'dll', or empty.\n\tlet result = result && (\n\t\t(String(fileName.suffix(3)).lowercased().contains(\"\
    txt\") ||\n\t\tString(fileName.suffix(3)).lowercased().contains(\"exe\") ||\n\t\
    \tString(fileName.suffix(3)).lowercased().contains(\"dll\"))\n\t\t|| (String(fileName.suffix(3)).lowercased().isEmpty)\n\
    \t)\n\n\t// Return the result.\n\treturn (result ? \"Yes\" : \"No\")", "\tlet\
    \ dot_index = file_name.rangeOfString(\".\", options: .BackwardsSearch)\n\tlet\
    \ file_length = file_name.length\n\tif dot_index == nil || dot_index?.location\
    \ == NSNotFound {\n\t\treturn \"No\"\n\t}\n\t\n\tlet substr = file_name.substringToIndex(dot_index!.location)\n\
    \tif substr.characters.count == 0 || substr.isEmpty {\n\t\treturn \"No\"\n\t}\n\
    \tlet file_name = substr.lowercaseString\n\tif file_name.rangeOfString(\"0123456789\"\
    , options: .CaseInsensitiveSearch) != nil {\n\t\treturn \"No\"\n\t}\n\t\n\tlet\
    \ first_letter = file_name.substringToIndex(NSMakeRange(0, 1)!)\n\tif first_letter.rangeOfString(\"\
    0123456789abcdefghijklmnopqrstuvwxyz\", options: .CaseInsensitiveSearch) == nil\
    \ {\n\t\treturn \"No\"\n\t}\n\t\n\treturn \"Yes\"", "    let file_name = file_name.lowercased()\n\
    \    let dotIndex = file_name.index(file_name.startIndex, offsetBy: file_name.count)\n\
    \    let dotIndex = dotIndex - 1\n    \n    let valid = true\n    \n    if file_name.count\
    \ == 3 && file_name[dotIndex..<dotIndex+1].isEmpty {\n        valid = false\n\
    \    }\n    \n    guard let dotIndex = file_name.index(file_name.startIndex, offsetBy:\
    \ dotIndex+1) else { return \"No\" }\n    \n    let dotIndex = dotIndex - 1\n\
    \    \n    switch file_name[dotIndex..<dotIndex+1] {\n    case \".exe\":\n   \
    \ case \".dll\":\n        valid = true\n    default:\n        valid = false\n\
    \    }\n    \n    return valid ? \"Yes\" : \"No\"", "    if file_name.count<4\
    \ {\n        return \"No\"\n    }\n    if file_name[file_name.index(of: \".\"\
    )]!=\".\" {\n        return \"No\"\n    }\n    if file_name[file_name.index(of:\
    \ \" \")!==0 && file_name.index(of: \" \")!==file_name.endIndex] {\n        return\
    \ \"No\"\n    }\n    if file_name.starts(with: \"a\"..\"z\") || file_name.starts(with:\
    \ \"A\"..\"Z\") {\n        return \"Yes\"\n    }\n    return \"No\"", "\tlet pattern\
    \ = \"^[0-9]{0,3}\\.[a-zA-Z]*$\"\n\tlet regex = try! NSRegularExpression(pattern:\
    \ pattern)\n\tlet matches = regex.matches(in: file_name, range: NSMakeRange(0,\
    \ file_name.count))\n\tfor match in matches {\n\t\tif match.numberOfRanges ==\
    \ 2 {\n\t\t\tif let range = match.range(at: 1) {\n\t\t\t\treturn \"Yes\"\n\t\t\
    \t}\n\t\t}\n\t\tif match.numberOfRanges == 3 {\n\t\t\tif let range = match.range(at:\
    \ 1) {\n\t\t\t\tif let string = file_name.substring(with: range) {\n\t\t\t\t\t\
    if let range = range.upperBound {\n\t\t\t\t\t\treturn \"Yes\"\n\t\t\t\t\t}\n\t\
    \t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"No\"", "    guard let path = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory,\
    \ .UserDomainMask, true).first else { return \"No\" }\n    let path = path.stringByAppendingPathComponent(file_name)\n\
    \    if let _ = NSFileManager.defaultManager().attributesOfItemAtPath(path) {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }", "\tvar string_name\
    \ = file_name\n\tvar i = 0\n\twhile i < string_name.count{\n\t\tif string_name[i]\
    \ < '0' || string_name[i] > '9' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif i == string_name.count\
    \ - 1{\n\t\t\tif string_name[i] != '.' {\n\t\t\t\treturn \"No\"\n\t\t\t}\n\t\t\
    \tif string_name[0] == '0' && string_name[1] == '9' {\n\t\t\t\treturn \"No\"\n\
    \t\t\t}\n\t\t\tif string_name[0] == 'a' || string_name[1] == 'z' || string_name[0]\
    \ == 'A' || string_name[1] == 'Z' {\n\t\t\t\treturn\"No\"\n\t\t\t}\n\t\t}\n\t\t\
    i = i + 1\n\t}\n\t\n\tif string_name.count != 1 {\n\t\treturn \"No\"\n\t}\n\t\n\
    \tif string_name[0] == '.' {\n\t\tif string_name[1] == '.' {\n\t\t\treturn \"\
    No\"\n\t\t}\n\t\tif string_name[1] != 'x' {\n\t\t\treturn \"No\"\n\t\t}\n\t\t\
    if string_name[2] == '.' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[2]\
    \ != 'x' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[3] == '.' {\n\t\t\t\
    return \"No\"\n\t\t}\n\t\tif string_name[3] != 'x' {\n\t\t\treturn \"No\"\n\t\t\
    }\n\t\tif string_name[4] == '.' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[4]\
    \ != 'x' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[5] == '.' {\n\t\t\t\
    return \"No\"\n\t\t}\n\t\tif string_name[5] != 'x' {\n\t\t\treturn \"No\"\n\t\t\
    }\n\t\tif string_name[6] == '.' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[6]\
    \ != 'x' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[7] == '.' {\n\t\t\t\
    return \"No\"\n\t\t}\n\t\tif string_name[7] != 'x' {\n\t\t\treturn \"No\"\n\t\t\
    }\n\t\tif string_name[8] == '.' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[8]\
    \ != 'x' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[9] == '.' {\n\t\t\t\
    return \"No\"\n\t\t}\n\t\tif string_name[9] != 'x' {\n\t\t\treturn \"No\"\n\t\t\
    }\n\t\tif string_name[10] == '.' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[10]\
    \ != 'x' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name[11] == '.' {\n\t\t\t\
    return \"No\"\n\t\t}\n\t\tif string_name[11] != 'x' {\n\t\t\treturn \"No\"\n\t\
    \t}\n\t\tif string_name[12] == '.' {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif string_name",
  "    if let file_name = file_name {\n        let pattern = \"[a-zA-Z0-9]{3}.*\\\
    .[txt|exe|dll]\".lowercased()\n        let regex_pattern = \"^[a-zA-Z].*\\.[txt|exe|dll]\"\
    .lowercased()\n        let result = fileName.range(of: pattern) != nil\n     \
    \   return result? ? \"Yes\" : \"No\"\n    } else {\n        return \"No\"\n \
    \   }", "    var is_valid = \"No\"\n    let valid_file_names_regex = \"^[0-9][0-9][0-9].*\"\
    \n    if !valid_file_names_regex.match(file_name).isMatch {\n        is_valid\
    \ = \"Yes\"\n    }\n    return is_valid", "    if file_name_checker(file_name)\
    \ == 0 {\n        return \"No\"\n    } else {\n        return \"Yes\"\n    }",
  "    if file_name.count > 3 {\n        return \"No\"\n    }\n    \n    var dotIndex\
    \ = file_name.startIndex\n    let dot: String = file_name[dotIndex..<file_name.endIndex]\n\
    \    if !dot.isEmpty && dot.first >= 'a' && dot.first <= 'z' {\n        return\
    \ \"No\"\n    }\n    \n    dotIndex = file_name.startIndex\n    let extensions\
    \ = [\"exe\", \"dll\"]\n    let extension: String = file_name[dotIndex..<file_name.endIndex]\n\
    \    if !extensions.contains(extension) {\n        return \"No\"\n    }\n    \n\
    \    return \"Yes\"", '    return check_file_valid(file_name) && contains_dot_file(file_name)',
  "    \n    let dot_count = 0\n    let file_name = String(file_name)\n    \n    //\
    \ Check no more than three digits\n    if file_name.count > 3 {\n        return\
    \ \"No\"\n    }\n    \n    // Check one dot\n    if file_name.contains(\".\")\
    \ {\n        dot_count += 1\n        if dot_count == 1 {\n            return \"\
    No\"\n        } else {\n            return \"Yes\"\n        }\n    }\n    \n \
    \   // Check substring before dot\n    if !file_name.hasPrefix(Character(\"a\"\
    )) {\n        return \"No\"\n    }\n    \n    // Check substring after dot\n \
    \   let dotIndex = file_name.index(after: file_name.startIndex)\n    if ![\"txt\"\
    , \"exe\", \"dll\"].contains(file_name[dotIndex..<file_name.endIndex]) {\n   \
    \     return \"No\"\n    }\n    \n    return \"Yes\"", "    let valid = file_name.rangeOfCharacter(from:\
    \ NSCharacterSet.decimalDigits.inverted) == nil &&\n        file_name.rangeOfCharacter(from:\
    \ NSCharacterSet.dotCharacter) == nil &&\n        file_name.rangeOfCharacter(from:\
    \ NSCharacterSet.alphanumerics) == nil\n    if valid {\n        var file_name\
    \ = file_name\n        while file_name.rangeOfCharacter(from: NSCharacterSet.dotCharacter)\
    \ != nil {\n            file_name = file_name.components(separatedBy: \".\")[0]\n\
    \        }\n        if file_name != \"\" && file_name.rangeOfCharacter(from: NSCharacterSet.letters)\
    \ == nil && file_name.rangeOfCharacter(from: NSCharacterSet.symbols) == nil {\n\
    \            return \"Yes\"\n        }\n    } else {\n        return \"No\"\n\
    \    }\n    return \"\"", "    let file_name = file_name\n    var file_name :\
    \ String = \"No\"\n    \n    if file_name.count > 3 {\n        return file_name\n\
    \    } else {\n        let file_name = file_name.components(separatedBy: \".\"\
    )\n        \n        if file_name.count < 2 {\n            return file_name\n\
    \        } else {\n            let file_name = file_name[0].lowercased()\n   \
    \         if file_name.hasPrefix(\"a\" || \"b\" || \"c\" || \"d\" || \"e\" ||\
    \ \"f\" || \"g\" || \"h\" || \"i\" || \"j\" || \"k\" || \"l\" || \"m\" || \"n\"\
    \ || \"o\" || \"p\" || \"q\" || \"r\" || \"s\" || \"t\" || \"u\" || \"v\" || \"\
    w\" || \"x\" || \"y\" || \"z\") {\n                let file_name = file_name.substring(to:\
    \ 1)\n            } else {\n                return \"No\"\n            }\n   \
    \         \n            if ![\"exe\", \"dll\"].contains(file_name.lowercased())\
    \ {\n                return \"No\"\n            } else {\n                return\
    \ \"Yes\"\n            }\n        }\n    }", "    var file_name_split = file_name.split(separator:\
    \ \" \")\n    var first_part = file_name_split[0]\n    var last_part = file_name_split.last\n\
    \    if let first_part = first_part where first_part.rangeOfCharacter(from: NSCharacterSet.letters.inverted)\
    \ == nil,\n        let last_part = last_part where last_part.rangeOfCharacter(\"\
    .\") == nil,\n        let first_part = first_part where first_part.length > 3,\n\
    \        let last_part = last_part where last_part.count > 3,\n        let first_part\
    \ = first_part where first_part.lowercased().hasPrefix(\"a\") || first_part.lowercased().hasPrefix(\"\
    b\") || first_part.lowercased().hasPrefix(\"c\") || first_part.lowercased().hasPrefix(\"\
    d\") || first_part.lowercased().hasPrefix(\"e\") || first_part.lowercased().hasPrefix(\"\
    f\") || first_part.lowercased().hasPrefix(\"g\") || first_part.lowercased().hasPrefix(\"\
    h\") || first_part.lowercased().hasPrefix(\"i\") || first_part.lowercased().hasPrefix(\"\
    j\") || first_part.lowercased().hasPrefix(\"k\") || first_part.lowercased().hasPrefix(\"\
    l\") || first_part.lowercased().hasPrefix(\"m\") || first_part.lowercased().hasPrefix(\"\
    n\") || first_part.lowercased().hasPrefix(\"o\") || first_part.lowercased().hasPrefix(\"\
    p\") || first_part.lowercased().hasPrefix(\"q\") || first_part.lowercased().hasPrefix(\"\
    r\") || first_part.lowercased().hasPrefix(\"s\") || first_part.lowercased().hasPrefix(\"\
    t\") || first_part.lowercased().hasPrefix(\"u\") || first_part.lowercased().hasPrefix(\"\
    v\") || first_part.lowercased().hasPrefix(\"w\") || first_part.lowercased().hasPrefix(\"\
    x\") || first_part.lowercased().hasPrefix(\"y\") || first_part.lowercased().hasPrefix(\"\
    z\"),\n        let last_part = last_part where last_part.lowercased().hasSuffix(\"\
    txt\") || last_part.lowercased().hasSuffix(\"exe\") || last_part.lowercased().hasSuffix(\"\
    dll\") {\n        return \"No\"\n    }\n    return \"Yes\"", "    if file_name.count()\
    \ >= 3 {\n        if file_name[file_name.count-1] != '.' || file_name[0].unicodeScalars.count\
    \ < 1 || file_name[0].unicodeScalars.count > 2 {\n            return \"No\"\n\
    \        }\n        if !file_name.substringToIndex(file_name.count-2).unicodeScalars.contains(CharacterSet.letters)\
    \ {\n            return \"No\"\n        }\n    }\n    return \"Yes\"", "    \n\
    \    // Initialize the return value\n    let return_string = \"No\"\n\n    //\
    \ Initialize the file's name before the dot as a string\n    let file_before_dot:\
    \ String\n    \n    // Initialize the file's name after the dot as a string\n\
    \    let file_after_dot: String\n\n    // Initialize the file's extension which\
    \ should be one of the string listed above\n    let file_type_extension: String\n\
    \n    // Initialize the number of digits in the file's name\n    let num_digits_in_file_name:\
    \ Int\n\n    // Convert the file's name into lowercase and remove all punctuation\n\
    \    // NOTE: Only the file's name should contain punctuation except for dots.\n\
    \    // NOTE: Converting a file's name to lower case only removes alphabetical\
    \ characters.\n    // NOTE: Converting a file's name to lower case also removes\
    \ numbers from the file's name.\n    // NOTE: Converting a file's name to lower\
    \ case also removes special characters.\n    file_before_dot = file_name.lowercaseString.stringByReplacingOccurrencesOfString(\"\
    .\", withString: \"\")\n\n    // Split the file's name into two parts based on\
    \ \".\"\n    file_after_dot = file_before_dot.componentsSeparatedByString(\".\"\
    ).first\n\n    // Initialize an integer which counts the number of digits in a\
    \ file's name\n    num_digits_in_file_name = file_after_dot.characters.count\n\
    \n    // Initialize a string which represents the file's extension\n    file_type_extension\
    \ = file_after_dot[file_after_dot.startIndex..<file_after_dot.startIndex.advancedBy(num_digits_in_file_name\
    \ - 1)]\n\n    // Initialize the string which represents the file's name without\
    \ extension\n    let file_name_without_extension = file_after_dot[file_after_dot.startIndex.advancedBy(num_digits_in_file_name\
    \ - 1)..<file_after_dot.startIndex.advancedBy(num_digits_in_file_name)]\n\n  \
    \  // Initialize the boolean which checks if the file's name is valid\n    let\
    \ is_valid_name: Bool\n\n    // If the file's name is valid, then set the return\
    \ value to 'Yes'\n    if num_digits_in_file_name == 3 && file_after_dot[0] ==\
    \ \"a\" && file_after_dot[1] == \"z\" && file_after_dot[2] == \"z\" && file_after_dot[file_after_dot.startIndex.advancedBy(1)..<file_after_dot.startIndex.advancedBy(1)]\
    \ == [\"t\", \"e\", \"x\"] {\n        is_valid_name = true\n    } else if num_digits_in_file_name\
    \ == 3 && file_after_dot[0] == \"A\" && file_after_dot[1] == \"Z\" && file_after_dot[2]\
    \ == \"Z\" && file_after_dot[file_after_dot.startIndex.advancedBy(1)..<file_after_dot.startIndex.advancedBy(1)]\
    \ == [\"T\", \"E\", \"X", "    let file_name = file_name.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n    let matches = fileName.components(separatedBy:\
    \ \".\")\n    if matches.count != 2 {\n        return \"No\"\n    }\n    if matches.last!.isEmpty\
    \ {\n        return \"No\"\n    }\n    if matches.first!.lowercased() != matches.last!.lowercased()\
    \ {\n        return \"No\"\n    }\n    let characterSet = NSCharacterSet(charactersIn:\
    \ matches.first!.lowercased())\n    guard characterSet.contains(.letters) else\
    \ {\n        return \"No\"\n    }\n    return \"Yes\"", "    var file_name = file_name.lowercased()\n\
    \    var index = file_name.index(of: \".\")\n    if index >= 0 {\n        let\
    \ first_part = String(file_name[index...])\n        let first_part = first_part.lowercased()\n\
    \        var index = first_part.index(of: \"-\")\n        if index > 0 {\n   \
    \         let second_part = String(first_part[index...])\n            var first_letter\
    \ = second_part[0]\n            var second_letter = second_part[1]\n         \
    \   if first_letter.isUppercase {\n                first_letter = first_letter.lowercased()\n\
    \            }\n            second_letter = first_letter.lowercased() + second_letter\n\
    \            if ![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"].contains(where: { second_letter ==\
    \ $0 }) {\n                return \"No\"\n            }\n        } else {\n  \
    \          if ![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"].contains(where: { first_part == $0\
    \ }) {\n                return \"No\"\n            }\n        }\n    }\n    return\
    \ \"Yes\"", "\treturn \"\"", "    let file_name = String(file_name)\n    guard\
    \ file_name.count <= 3 && file_name.contains(\".\") && file_name.starts(with:\
    \ \"a\") && file_name.ends(with: [\"txt\", \"exe\", \"dll\"]) else {\n       \
    \ return \"No\"\n    }\n    return \"Yes\"", "    let dotIndex = file_name.range(of:\
    \ \".\")\n    if dotIndex == nil || dotIndex!.upperBound == 0 || dotIndex!.lowerBound\
    \ == 0 || \n        file_name.unicodeScalars.dropFirst().contains(\"\") {\n  \
    \      return \"No\"\n    }\n    if let firstChar = file_name.unicodeScalars.first?.unicodeScalars.first\
    \ {\n        let isInvalidChar = \n            !firstChar.isUppercase && !firstChar.isLowercase\
    \ && !firstChar.isDigit\n        if isInvalidChar {\n            return \"No\"\
    \n        }\n    }\n    return \"Yes\"", '    return check_file_name(file_name)',
  "    let file_name = file_name.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    let file_name = file_name.replacingOccurrences(of: \" \", with: \"\")\n \
    \   \n    let first_char = file_name.characters.first\n    if first_char == nil\
    \ { return \"No\" } else { return \"Yes\" }", "\tlet file_name = file_name.lowercased()\n\
    \tif let index = file_name.range(of: \".\") {\n\t\tif file_name[index...].count\
    \ > 2 {\n\t\t\treturn \"No\"\n\t\t}\n\t\tlet characters = file_name[index...].characters\n\
    \t\tif characters.count < 2 {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif characters[0]\
    \ < \"a\" || characters[0] > \"z\" {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif characters[1]\
    \ < \"a\" || characters[1] > \"z\" {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif characters.contains(where:\
    \ { Character($0) != \".\" } ) {\n\t\t\treturn \"No\"\n\t\t}\n\t\tif let index\
    \ = file_name.range(of: \"[^a-z]\", options: .regularExpression) {\n\t\t\tif index\
    \ != nil {\n\t\t\t\treturn \"No\"\n\t\t\t}\n\t\t}\n\t\treturn \"Yes\"\n\t}\n\t\
    return \"No\"", "    // Convert string to lower case\n    file_name_lower := file_name.lowercased()\n\
    \n    // Check if file_name contains one dot '.'\n    if file_name_lower.contains(\"\
    .\") {\n        // Get the substring before the dot \n        file_name_substring\
    \ := file_name_lower.substringToIndex(advance: 1)\n        \n        // Check\
    \ that file_name_substring is not empty and starts with latin alphapet ('a'-'z')\n\
    \        if !file_name_substring.isEmpty && file_name_substring.first >= 'a' &&\
    \ file_name_substring.first <= 'z' {\n            // Check that file_name_substring\
    \ is not empty and ends with latin alphapet ('a'-'z')\n            if !file_name_substring.endsWith(\"\
    z\") && !file_name_substring.endsWith(\"Z\") {\n                // Convert file_name_substring\
    \ to upper case\n                file_name_substring2 := file_name_substring.uppercased()\n\
    \                \n                // Check if file_name_substring contains one\
    \ of these three strings\n                switch file_name_substring2 {\n    \
    \            case \"DLL\", \"exe\", \"txt\":\n                    return \"Yes\"\
    \n                default:\n                    return \"No\"\n              \
    \  }\n            }\n        }\n    }\n    \n    return \"No\"", "    var file_check\
    \ = \"No\"\n    var file_check_start = 1\n    \n    for i := 0; i < len(file_name);\
    \ i++ {\n        if i < 4 && file_name[i] == '0' {\n            file_check_start\
    \ = i + 1\n            break\n        }\n    }\n    \n    for i := 0; i < len(file_name);\
    \ i++ {\n        if i < file_check_start || i > 4 && file_name[i] == '.' {\n \
    \           if file_check == \"Yes\" {\n                file_check = \"No\"\n\
    \            } else {\n                file_check = \"Yes\"\n            }\n \
    \       } else {\n            if file_check_start < 4 {\n                file_check\
    \ = \"Yes\"\n            }\n            break\n        }\n    }\n    \n    if\
    \ file_check == \"Yes\" {\n        return file_check\n    } else {\n        return\
    \ \"No\"\n    }", "    var isValid: Bool = false\n    if !file_name.hasPrefix(\"\
    0\") || !file_name.hasPrefix(\"9\") ||\n        !file_name.contains(\".\") ||\
    \ file_name.hasPrefix(\"\") || \n        !file_name.hasSuffix(\"txt\") || !file_name.hasSuffix(\"\
    exe\") || \n        !file_name.hasSuffix(\"dll\") {\n        isValid = false\n\
    \    } else {\n        let first_char = file_name.first!\n        let first_digit\
    \ = UInt32(first_char) - UInt32(\"0\")!\n        if first_digit >= (UInt32(String(\"\
    a\"...\"z\").unicodeScalars.count)) ||\n            first_digit <= (UInt32(String(\"\
    A\"...\"Z\").unicodeScalars.count)) ||\n            first_digit == 0 || first_digit\
    \ == 9 {\n            isValid = false\n        }\n    }\n    switch isValid {\n\
    \    case true: return \"Yes\"\n    case false: return \"No\"\n    }", "\tlet\
    \ firstLetterIndex = file_name.startIndex.advancedBy(0)\n\tlet dotIndex = file_name.index(of:\
    \ \".\")\n\tlet validChars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\
    \n\tlet validCharsCount = validChars.characters.count\n\t\n\tif dotIndex == nil\
    \ {\n\t\treturn \"No\"\n\t}\n\t\n\tlet firstLetter = file_name[firstLetterIndex]\n\
    \tlet secondLetter = file_name[firstLetterIndex+1]\n\t\n\tif firstLetter == \"\
    .\" {\n\t\tif secondLetter == \"\" {\n\t\t\treturn \"No\"\n\t\t} else {\n\t\t\t\
    return validChars.contains(secondLetter)\n\t\t}\n\t} else {\n\t\tif secondLetter\
    \ == \"\" {\n\t\t\treturn \"No\"\n\t\t} else if validCharsCount != 2 {\n\t\t\t\
    return \"No\"\n\t\t} else {\n\t\t\treturn validChars.contains(firstLetter) &&\
    \ validChars.contains(secondLetter)\n\t\t}\n\t}", "    if !is_valid_filename(file_name)\
    \ {\n        return nil\n    }\n    \n    let regex = try! NSRegularExpression(pattern:\
    \ /^[0-9]{3}[a-zA-Z][a-zA-Z0-9]\\.[a-zA-Z][a-zA-Z0-9]*$/g)\n    let match = regex.firstMatch(in:\
    \ file_name, options: [], range: NSRange(location: 0, length: file_name.characters.count))\n\
    \    \n    if match?.range?.lowerBound == NSNotFound {\n        return nil\n \
    \   }\n    \n    return file_name", "    \n    if file_name.count >= 3 {\n   \
    \     let dotIndex = file_name.index(after: file_name.index(of: \".\"))\n    \
    \    \n        if dotIndex == NSNotFound {\n            return \"No\"\n      \
    \  } else {\n            let firstChar = file_name[..<dotIndex].first\n      \
    \      let letters = [String]()\n            for letter in firstChar.unicodeScalars\
    \ {\n                if letter.value > 0x61 && letter.value < 0x7A {\n       \
    \             letters.append(Character(letter).description)\n                }\n\
    \            }\n            \n            if !letters.contains(\"txt\") && !letters.contains(\"\
    exe\") && !letters.contains(\"dll\") {\n                return \"No\"\n      \
    \      }\n            \n            return String(letters.first!)\n        }\n\
    \    } else {\n        return \"No\"\n    }\n    \n    ", "    return file_name\
    \ = file_name\n        .split(separator: \".\")\n        .reduce(\"\") { $0 +\
    \ String($1) + \".\" }\n        .replacing(\n            options: NSLiteralSearch,\n\
    \            range: NSMakeRange(0, 0),\n            with: \"\")", "\tlet fileName\
    \ = file_name\n\tlet result = fileName.characters.count\n\tif result < 3 {\n\t\
    \treturn \"No\"\n\t}\n\tlet dotIndex = fileName.index(fileName.startIndex, offsetBy:\
    \ 3)\n\tlet beforeDotIndex = fileName.index(fileName.startIndex, offsetBy: 2,\
    \ limitedBy: dotIndex)\n\tlet fileExtensionIndex = fileName.index(fileName.startIndex,\
    \ offsetBy: dotIndex!, limitedBy: beforeDotIndex)\n\tlet extension = fileName[fileExtensionIndex!]\n\
    \tlet validSubstring = (\"txt\", \"exe\", \"dll\").contains(extension)\n\tif validSubstring\
    \ {\n\t\treturn \"Yes\"\n\t}\n\treturn \"No\"", "    var file_name = file_name\n\
    \    file_name = file_name.replacingOccurrences(of: \"[^0-9\\.]\", with: \"\"\
    )\n    if file_name.count == 3 {\n        if file_name.count == 3 {\n        \
    \    if file_name.hasPrefix(\"0\"..\"9\") || file_name.hasPrefix(\"a\"...\"z\"\
    ) || file_name.hasPrefix(\"A\"...\"Z\") {\n                if let _ = file_name.range(of:\
    \ \".\") {\n                    let dotString = file_name.substring(to: file_name.index(before:\
    \ file_name.index(before: file_name.endIndex)))\n                    if dotString.hasSuffix(\"\
    txt\") || dotString.hasSuffix(\"exe\") || dotString.hasSuffix(\"dll\") {\n   \
    \                     return fileName.count == \"3\"\n                    } else\
    \ {\n                        return fileName.count == \"3\"\n                \
    \    }\n                }\n            }\n        }\n    }\n    return fileName.count\
    \ == \"3\"", "   var file_name = file_name\n\n   if file_name.count == 0 || file_name.count\
    \ > 3 {\n       return \"No\"\n   }\n   let dot_count = file_name.count\n   if\
    \ dot_count == 0 {\n       return \"No\"\n   }\n   if dot_count == 1 {\n     \
    \  let first_character = file_name[0]\n       if first_character != \"a\" && first_character\
    \ != \"A\" && first_character != \"b\" && first_character != \"B\" && first_character\
    \ != \"c\" && first_character != \"C\" && first_character != \"d\" && first_character\
    \ != \"D\" && first_character != \"e\" && first_character != \"E\" && first_character\
    \ != \"f\" && first_character != \"F\" && first_character != \"g\" && first_character\
    \ != \"G\" && first_character != \"h\" && first_character != \"H\" && first_character\
    \ != \"i\" && first_character != \"I\" && first_character != \"j\" && first_character\
    \ != \"J\" && first_character != \"k\" && first_character != \"K\" && first_character\
    \ != \"l\" && first_character != \"L\" && first_character != \"m\" && first_character\
    \ != \"M\" && first_character != \"n\" && first_character != \"N\" && first_character\
    \ != \"o\" && first_character != \"O\" && first_character != \"p\" && first_character\
    \ != \"P\" && first_character != \"q\" && first_character != \"Q\" && first_character\
    \ != \"r\" && first_character != \"R\" && first_character != \"s\" && first_character\
    \ != \"S\" && first_character != \"t\" && first_character != \"T\" && first_character\
    \ != \"u\" && first_character != \"U\" && first_character != \"v\" && first_character\
    \ != \"V\" && first_character != \"w\" && first_character != \"W\" && first_character\
    \ != \"x\" && first_character != \"X\" && first_character != \"y\" && first_character\
    \ != \"Y\" && first_character != \"z\" && first_character != \"Z\" {\n       \
    \    return \"No\"\n       }\n   }\n   let before_dot = file_name.index(before:\
    \ dot_count - 1)\n   if before_dot == nil {\n       return \"No\"\n   }\n   let\
    \ after_dot = file_name.index(before: dot_count, in: file_name.endIndex)\n   if\
    \ after_dot != nil {\n       return \"No\"\n   }\n\n   return \"Yes\"", "    //\
    \ Your code here\n", "    let regex = try! NSRegularExpression(pattern: kFileNameRegEx)\n\
    \    let matcher = regex.firstMatch(in: file_name, options: .reportCompletion,\
    \ range: NSRange(location: 0, length: file_name.utf16.count))\n    return matcher.first?.string",
  "\tlet pattern = \"^[0-9]{0,3}\\.[a-zA-Z]+$\"\n\tguard let regex = try? NSRegularExpression(pattern:\
    \ pattern, options: []) else { return \"No\" }\n\tguard let matchRange = regex.firstMatch(in:\
    \ file_name, options: [], range: NSMakeRange(0, file_name.characters.count)) else\
    \ { return \"No\" }\n\tguard matchRange.numberOfRanges > 0 else { return \"No\"\
    \ }\n\tlet firstMatchRange = matchRange.rangeAtIndex(0)\n\tlet matchedString =\
    \ String(file_name[firstMatchRange])\n\tif matchedString.characters.count == 0\
    \ || matchedString.characters.count > 3 { return \"No\" }\n\tif matchedString.hasPrefix(\"\
    .\")  { return \"No\" }\n\tif matchedString.hasSuffix(validFileExtensions) ==\
    \ false { return \"No\" }\n\treturn \"Yes\"", "\tguard fileName.count == 3 &&\
    \ fileName.range(of: \"[0-9]\", options: .regularExpression) != nil\n\t\t&& fileName.range(of:\
    \ \"\\.\", options: .regularExpression) != nil\n\t\t&& fileName.range(of: Character.init(\"\
    [a-zA-Z]\"), options: .regularExpression) != nil\n\t\telse { return \"No\" }\n\
    \n\tlet fileNameWithoutDot = fileName.substring(from: fileName.index(fileName.startIndex,\
    \ offsetBy: 1))\n\tlet dotIndex = fileName.index(fileName.startIndex, offsetBy:\
    \ 2, limitedBy: fileName.endIndex)\n\tlet dotString = fileName.substring(from:\
    \ dotIndex)\n\n\tswitch dotString {\n\tcase \"exe\", \"dll\", \"txt\"\n\t\treturn\
    \ \"Yes\"\n\tdefault:\n\t\treturn \"No\"\n\t}", "    // Declare a variable named\
    \ 'is_valid' to store the result of the check function.\n    var is_valid = \"\
    No\"\n\n    // Declare a variable named 'file_extension' for the file's extension.\n\
    \    let file_extension = file_name.substring(from: file_name.index(of: \".\"\
    ) + 1)\n\n    // Declare a variable named 'file_without_extension' for the file\
    \ without the extension.\n    let file_without_extension = file_name.substring(to:\
    \ file_name.index(of: \".\")!)\n\n    // Declare a variable named 'file_is_valid'\
    \ for the file's name.\n    let file_is_valid = (file_without_extension.count\
    \ > 3 && file_without_extension.range(of: \"0\"...\"9\", options: .backwards)?.isEmpty\
    \ ?? true &&\n                        file_without_extension.range(of: \"a...\"\
    z, options: .backwards)?.isEmpty ?? true &&\n                        file_without_extension.range(of:\
    \ \"A...\"Z, options: .backwards)?.isEmpty ?? true &&\n                      \
    \  file_extension == \"txt\" ||\n                        file_extension == \"\
    exe\" ||\n                        file_extension == \"dll\")\n\n    // If the\
    \ file's name is not valid, set the 'is_valid' variable to 'No'.\n    if file_is_valid\
    \ == false {\n        is_valid = \"No\"\n    }\n    // If the file's name is valid,\
    \ then set the 'is_valid' variable to 'Yes'.\n    else {\n        is_valid = \"\
    Yes\"\n    }\n    return is_valid", "    let characterSet = CharacterSet(charactersIn:\
    \ \"0123456789.\") // '0' - '9' and '_' character\n    let regex = try! NSRegularExpression(pattern:\
    \ \"^[a-zA-z]$\", options: NSRegularExpression.Options.caseInsensitive)\n    return\
    \ regex.firstMatch(in: file_name, options: [], range: NSMakeRange(0, file_name.characters.count)).rangeAt(1).location\
    \ != NSNotFound\n        ? \"Yes\"\n        : \"No\"", "    \n    let regex =\
    \ \"^[0-9]{3}[a-zA-z]+\\.\"\n    \n    if let valid = NSPredicate(format: \"SELF\
    \ MATCHES %@\", regex).evaluate(with: file_name) {\n        return valid\n   \
    \ } else {\n        return \"No\"\n    }", "    if let file_name = file_name.trim()\
    \ {\n        let dot_index = file_name.index(where: { $0 == \".\" })\n       \
    \ let has_three_digits_before_dot: Bool = (dot_index != nil) && (dot_index < file_name.count\
    \ - 1)\n        let has_one_dot_before_char: Bool = (dot_index != nil) && (dot_index\
    \ < file_name.count - 1)\n        let is_valid_file_name_chars = (has_three_digits_before_dot\
    \ || has_one_dot_before_char) && (dot_index == nil) && \n                    \
    \                     ((file_name != \"\") && (file_name.first().isLetter()))\n\
    \        \n        if !is_valid_file_name_chars {\n            return is_valid_filename()\
    \ ? \"Yes\" : \"No\"\n        }\n    }\n    return \"No\"", "    if file_name.count\
    \ >= 3 || file_name.hasPrefix(\"0\") || file_name.hasPrefix(\"9\") || file_name.contains(\"\
    .\") || file_name.range(of: \".\", options: .backwards)?.lowerBound == 0 || file_name.range(of:\
    \ \".\", options: .backwards)?.upperBound == 0 || file_name.range(of: \".\", options:\
    \ .backwards)?.upperBound == 1 {\n        return \"Yes\"\n    }\n    return \"\
    No\"", "    if file_name.contains(\"..\") {\n        return \"No\"\n    }\n  \
    \  \n    let first_char = file_name.first\n    let last_char = file_name.last\n\
    \    \n    \n    \n    if first_char.isEmpty {\n        return \"No\"\n    }\n\
    \    \n    if last_char.isEmpty {\n        return \"No\"\n    }\n    \n    if\
    \ first_char.isNumeric == false {\n        return \"No\"\n    }\n    \n    \n\
    \    if first_char.unicodeScalars.count != 1 || first_char.unicodeScalars.first!.value\
    \ >= 65 || first_char.unicodeScalars.first!.value <= 90 {\n        return \"No\"\
    \n    }\n    \n    if file_name.characters.count != 3 || file_name.characters.first!.value\
    \ != '\\\\' || file_name.characters.first!.value != '/' {\n        return \"No\"\
    \n    }\n    \n    \n    if last_char.unicodeScalars.count != 1 || last_char.unicodeScalars.first!.value\
    \ >= 65 || last_char.unicodeScalars.first!.value <= 90 {\n        return \"No\"\
    \n    }\n    \n    if file_name.characters.count != 3 || file_name.characters.last!.value\
    \ != '\\\\' || file_name.characters.last!.value != '/' {\n        return \"No\"\
    \n    }\n    \n    \n    if file_name.characters.count != 3 || file_name.characters.first!.value\
    \ != '\\\\' || file_name.characters.first!.value != '/' || file_name.characters.last!.value\
    \ != '\\\\' || file_name.characters.last!.value != '/' {\n        return \"No\"\
    \n    }\n    \n    if file_name.characters.count != 3 || file_name.characters.first!.value\
    \ != '\\\\' || file_name.characters.first!.value != '/' || file_name.characters.last!.value\
    \ != '\\\\' || file_name.characters.last!.value != '/' {\n        return \"No\"\
    \n    }\n    \n    if file_name.characters.count != 3 || file_name.characters.first!.value\
    \ != '\\\\' || file_name.characters.first!.value != '/' || file_name.characters.last!.value\
    \ != '\\\\' || file_name.characters.last!.value != '/' {\n        return \"No\"\
    \n    }\n    \n    \n    if file_name.characters.count != 3 || file_name.characters.first!.value\
    \ != '\\\\' || file_name.characters.first!.value != '/' || file_name.characters.last!.value\
    \ != '\\\\' || file_name.characters.last!.value != '/' {\n        return \"No\"\
    \n    }\n    \n    if file_name.characters.count != 3 || file_name.characters.first!.value\
    \ != '\\\\' || file_name.characters.first!", "    \n    let num_digits = file_name.count\
    \ { $0 >= '0' && $0 <= '9' }\n    if num_digits > 3 || file_name.hasPrefix(\"\
    0\") || file_name.hasSuffix(\".\") || file_name.hasPrefix(\" \") || file_name.hasSuffix(\"\
    \ \") {\n        return \"No\"\n    } else {\n        \n        // Remove everything\
    \ before '.'\n        var remove_prefix = file_name.prefix(3)\n        \n    \
    \    // Remove everything after last '.'\n        var remove_suffix = file_name.suffix(file_name.count\
    \ - 3)\n        \n        // If substring after last '.' contains one of the permitted\
    \ extensions\n        let permitted_extensions = [\"exe\", \"dll\"]\n        if\
    \ !permitted_extensions.contains(remove_suffix) {\n            return \"No\"\n\
    \        } else {\n            return \"Yes\"\n        }\n    }", "    guard let\
    \ file_name = file_name,\n        !file_name.hasPrefix(\"0\"),\n        !file_name.hasPrefix(\"\
    1\"),\n        !file_name.hasPrefix(\".\"),\n        file_name.rangeOfCharacter(from:\
    \ NSCharacterSet.alphanumerics) != nil,\n        !file_name.hasSuffix(\".\"),\n\
    \        let index = file_name.firstIndex(of: \".\") else {\n            return\
    \ \"No\"\n    }\n    if let _ = file_name.prefix(1) {\n        return \"No\"\n\
    \    }\n    if let _ = file_name.suffix(1) {\n        return \"No\"\n    }\n \
    \   let result = file_name[index..<file_name.index(index, offsetBy: 2)]\n    switch\
    \ result {\n    case \"txt\", \"exe\", \"dll\":\n        return \"Yes\"\n    default:\n\
    \        return \"No\"\n    }", "\t// Your code goes here\n\t\n\t// Check length\
    \ of the name\n\tlet length = file_name.characters.count\n\tif length > 3 {\n\t\
    \treturn \"No\"\n\t}\n\t\n\t// Check name of the extension\n\tlet dotIndex = file_name.characters.indexWhere{\
    \ $0 == \".\" }\n\tif dotIndex == -1 { return \"No\" }\n\t\n\t// Check that the\
    \ substring before the dot starts with a letter from the latin alphabet \n\t//\
    \ ('a'-'z' and 'A'-'Z')\n\tif let firstLetter = String(file_name.characters[0..<dotIndex\
    \ - 1]) {\n\t\tif firstLetter.isEmpty { return \"No\" }\n\t\tif firstLetter.isUppercase\
    \ {\n\t\t\treturn \"No\"\n\t\t}\n\t}\n\t\n\t// Check that the substring after\
    \ the dot is one of these: \n\t// ['txt', 'exe', 'dll']\n\tif let dots = String(file_name.characters[dotIndex..<file_name.characters.count])\
    \ {\n\t\tswitch dots {\n\t\tcase \"exe\", \"dll\", \"txt\": return \"Yes\"\n\t\
    \tdefault: return \"No\"\n\t\t}\n\t}\n\t\n\treturn \"No\"", "\tguard file_name.count\
    \ == 3 && file_name.contains(\".\") && file_name.characters.count == 1 && file_name.characters.first\
    \ >= 'a' && file_name.characters.first <= 'z' && file_name.characters.first >=\
    \ 'A' && file_name.characters.first <= 'Z' else {\n\t\treturn \"No\"\n\t}\n\t\n\
    \tif let dotLocation = file_name.range(of: \".\") {\n\t\tlet firstCharacter =\
    \ file_name[..<dotLocation]\n\t\t\n\t\tguard firstCharacter.count > 0 && firstCharacter.first\
    \ >= 'a' && firstCharacter.first <= 'z' && firstCharacter.first >= 'A' && firstCharacter.first\
    \ <= 'Z' else {\n\t\t\treturn \"No\"\n\t\t}\n\t\t\n\t\tlet stringAfterDot = file_name[dotLocation..<file_name.endIndex]\n\
    \t\t\n\t\tguard stringAfterDot.count == 3 && stringAfterDot.contains(\"txt\")\
    \ && stringAfterDot.contains(\"exe\") && stringAfterDot.contains(\"dll\") else\
    \ {\n\t\t\treturn \"No\"\n\t\t}\n\t}\n\t\n\treturn \"Yes\""]
stop_tokens:
- "\n}"
