language: swift
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif string == \"\
    \" {\n\t\treturn 0\n\t}\n\n\tvar result Int = 0\n\tvar startIndex = string.index(substring,\
    \ startIndex: 0)\n\tvar lastIndex = string.index(substring, startIndex: string.index(string,\
    \ startIndex))\n\tif startIndex == lastIndex {\n\t\tresult++\n\t}\n\n\twhile startIndex\
    \ != lastIndex {\n\t\tstartIndex = string.index(substring, startIndex: startIndex+1)\n\
    \t\tlastIndex = string.index(substring, startIndex: string.index(string, startIndex))\n\
    \t\tif startIndex == lastIndex {\n\t\t\tresult++\n\t\t}\n\t}\n\n\treturn result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph5eulqnt.swift:14:13: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var result Int\
    \ = 0\n                   ^\n/tmp/tmph5eulqnt.swift:14:13: note: join the identifiers\
    \ together\n        var result Int = 0\n            ~~~~~~~^~~\n            resultInt\n\
    /tmp/tmph5eulqnt.swift:15:26: error: no exact matches in call to instance method\
    \ 'index'\n        var startIndex = string.index(substring, startIndex: 0)\n \
    \                               ^\n/tmp/tmph5eulqnt.swift:15:26: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  var startIndex = string.index(substring, startIndex: 0)\n                 \
    \               ^\n/tmp/tmph5eulqnt.swift:15:26: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        var startIndex\
    \ = string.index(substring, startIndex: 0)\n                                ^\n\
    /tmp/tmph5eulqnt.swift:15:26: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        var startIndex = string.index(substring,\
    \ startIndex: 0)\n                                ^\n/tmp/tmph5eulqnt.swift:16:61:\
    \ error: no exact matches in call to instance method 'index'\n        var lastIndex\
    \ = string.index(substring, startIndex: string.index(string, startIndex))\n  \
    \                                                                 ^\n/tmp/tmph5eulqnt.swift:16:61:\
    \ note: found candidate with type '(String.Index, Int) -> String.Index'\n    \
    \    var lastIndex = string.index(substring, startIndex: string.index(string,\
    \ startIndex))\n                                                             \
    \      ^\n/tmp/tmph5eulqnt.swift:16:30: error: incorrect argument label in call\
    \ (have '_:startIndex:', expected '_:offsetBy:')\n        var lastIndex = string.index(substring,\
    \ startIndex: string.index(string, startIndex))\n                            \
    \        ^           ~~~~~~~~~~\n                                            \
    \    offsetBy\n/tmp/tmph5eulqnt.swift:16:31: error: cannot convert value of type\
    \ '"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // Return 1\
    \ if substring is not found\n    if string.find(substring) == nil {\n        return\
    \ 0;\n    }\n    // Loop through string and count overlaping characters\n    var\
    \ counter = 0;\n    for idxChar in string.characters {\n        if idxChar ==\
    \ substring.characters.first {\n            counter = counter + 1;\n        }\n\
    \        if idxChar == substring.characters.last {\n            counter = counter\
    \ + 1;\n        }\n    }\n    return counter;\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplz8ios2e.swift:11:15: error: value of type 'String' has no member\
    \ 'find'\n    if string.find(substring) == nil {\n       ~~~~~~ ^~~~\n/tmp/tmplz8ios2e.swift:16:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    for idxChar\
    \ in string.characters {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmplz8ios2e.swift:17:33: error: 'characters'\
    \ is unavailable: Please use String directly\n        if idxChar == substring.characters.first\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmplz8ios2e.swift:20:33: error: 'characters' is unavailable:\
    \ Please use String directly\n        if idxChar == substring.characters.last\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasPrefix(substring)\
    \ {\n        return string.count(substring)\n    }\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring) + 1\n    }\n    if string.hasPrefix(\"\
    (?i)\\(substring)\") {\n        return string.count(substring)\n    }\n    if\
    \ string.hasSuffix(\"(?i)\\(substring)\") {\n        return string.count(substring)\
    \ + 1\n    }\n    if substring.isEmpty {\n        return 0\n    }\n    return\
    \ string.countSubstrings(substring) + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3l4isdog.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n\
    /tmp/tmp3l4isdog.swift:14:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring) + 1\n                      ^\n/tmp/tmp3l4isdog.swift:17:23:\
    \ error: cannot call value of non-function type 'Int'\n        return string.count(substring)\n\
    \                      ^\n/tmp/tmp3l4isdog.swift:20:23: error: cannot call value\
    \ of non-function type 'Int'\n        return string.count(substring) + 1\n   \
    \                   ^\n/tmp/tmp3l4isdog.swift:25:19: error: value of type 'String'\
    \ has no member 'countSubstrings'\n    return string.countSubstrings(substring)\
    \ + 1\n           ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var result =\
    \ 0\n    var start_index = string.startIndex\n    while start_index != string.endIndex\
    \ {\n        let index = string.index(start_index, offsetBy: substring.characters.count)\n\
    \        if start_index != index {\n            start_index = index\n        \
    \    continue\n        }\n        if index == string.endIndex {\n            start_index\
    \ = index\n        }\n        result = result + 1\n        if start_index == string.endIndex\
    \ {\n            break\n        }\n        start_index = index\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdjqpwywq.swift:13:67: error: 'characters' is unavailable: Please\
    \ use String directly\n        let index = string.index(start_index, offsetBy:\
    \ substring.characters.count)\n                                              \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.count\
    \ < substring.count {\n        return 0\n    }\n    \n    if string.characters.count\
    \ < substring.characters.count {\n        return 0\n    }\n    \n    let start\
    \ = min(string.startIndex, substring.startIndex)\n    let end = max(string.endIndex,\
    \ substring.endIndex)\n    \n    var count = 0\n    for idx in 0..<(end - start)\
    \ {\n        if string.substring(from: start + idx).isEqual(substring) {\n   \
    \         count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcb71n9jn.swift:14:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count < substring.characters.count\
    \ {\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpcb71n9jn.swift:14:44: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count < substring.characters.count\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpcb71n9jn.swift:22:25: error: referencing\
    \ operator function '-' on 'Strideable' requires that 'String.Index' conform to\
    \ '_Pointer'\n    for idx in 0..<(end - start) {\n                        ^\n\
    Swift.Strideable:1:11: note: where 'Self' = 'String.Index'\nextension Strideable\
    \ where Self : _Pointer {\n          ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif substring ==\
    \ \"\" {\n\t\treturn 0\n\t}\n\n\tvar startIndex = string.startIndex.advancedBy(0,\
    \ offset)\n\tvar endIndex = string.endIndex.advancedBy(len(substring), offset)\n\
    \n\tvar count = 0\n\tvar index = startIndex.advancedBy(0, offset)\n\tfor ; index\
    \ < endIndex; index = index.advancedBy(1, offset) {\n\t\tif string[index] != substring[0]\
    \ {\n\t\t\tbreak\n\t\t}\n\n\t\tcount++\n\t}\n\n\treturn count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpekbw36ww.swift:19:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for ; index < endIndex; index = index.advancedBy(1, offset)\
    \ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpekbw36ww.swift:14:51:\
    \ error: cannot find 'offset' in scope\n        var startIndex = string.startIndex.advancedBy(0,\
    \ offset)\n                                                         ^~~~~~\n/tmp/tmpekbw36ww.swift:14:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        var\
    \ startIndex = string.startIndex.advancedBy(0, offset)\n                     \
    \    ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpekbw36ww.swift:15:44: error: cannot\
    \ find 'len' in scope\n        var endIndex = string.endIndex.advancedBy(len(substring),\
    \ offset)\n                                                  ^~~\n/tmp/tmpekbw36ww.swift:15:60:\
    \ error: cannot find 'offset' in scope\n        var endIndex = string.endIndex.advancedBy(len(substring),\
    \ offset)\n                                                                  ^~~~~~\n\
    /tmp/tmpekbw36ww.swift:15:33: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n        var endIndex = string.endIndex.advancedBy(len(substring),\
    \ offset)\n                       ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpekbw36ww.swift:18:39:\
    \ error: cannot find 'offset' in scope\n        var index = startIndex.advancedBy(0,\
    \ offset)\n                                             ^~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.rangeOfString(substring)\
    \ != nil {\n        return string.rangeOfString(substring).length\n    }\n   \
    \ return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp69dqxc5a.swift:10:15: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    if string.rangeOfString(substring) != nil {\n       ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmp69dqxc5a.swift:11:23: error: value of type 'String' has\
    \ no member 'rangeOfString'\n        return string.rangeOfString(substring).length\n\
    \               ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_occurrences(string,\
    \ substring: substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3iv84w4a.swift:10:12: error: cannot find 'count_occurrences' in\
    \ scope\n    return count_occurrences(string, substring: substring)\n        \
    \   ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.rangeOfString(substring)\
    \ == nil || string.rangeOfString(substring!) != nil && string.rangeOfString(substring!,\
    \ options: .CaseInsensitive).location == index.location {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpe98ehx90.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpe98ehx90.swift:12:19: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        if string.rangeOfString(substring) == nil || string.rangeOfString(substring!)\
    \ != nil && string.rangeOfString(substring!, options: .CaseInsensitive).location\
    \ == index.location {\n           ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe98ehx90.swift:12:61:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        if string.rangeOfString(substring)\
    \ == nil || string.rangeOfString(substring!) != nil && string.rangeOfString(substring!,\
    \ options: .CaseInsensitive).location == index.location {\n                  \
    \                                   ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe98ehx90.swift:12:104:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        if string.rangeOfString(substring)\
    \ == nil || string.rangeOfString(substring!) != nil && string.rangeOfString(substring!,\
    \ options: .CaseInsensitive).location == index.location {\n                  \
    \                                                                            \
    \  ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe98ehx90.swift:12:175: error: value of type 'Int'\
    \ has no member 'location'\n        if string.rangeOfString(substring) == nil\
    \ || string.rangeOfString(substring!) != nil && string.rangeOfString(substring!,\
    \ options: .CaseInsensitive).location == index.location {\n                  \
    \                                                                            \
    \                                                                          ~~~~~\
    \ ^~~~~~~~\n/tmp/tmpe98ehx90.swift:12:140: error: cannot infer contextual base\
    \ in reference to member 'CaseInsensitive'\n        if string.rangeOfString(substring)\
    \ == nil || string.rangeOfString(substring!) != nil && string.rangeOfString(substring!,\
    \ opti"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tlet range = (string\
    \ as NSString).range(of: substring)\n\t\n\tvar count = 0\n\t\n\twhile range.location\
    \ != NSNotFound {\n\t\tcount += 1\n\t\t\n\t\tlet location = string.index(range.lowerBound,\
    \ offsetBy: 1)\n\t\tlet searchRange = NSRange(location: location, length: substring.length)\n\
    \t\t\n\t\trange = (string as NSString).range(of: substring, options: [], range:\
    \ searchRange)\n\t}\n\t\n\treturn count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbvxwhchc.swift:10:25: error: cannot find type 'NSString' in scope\n\
    \        let range = (string as NSString).range(of: substring)\n             \
    \                  ^~~~~~~~\n/tmp/tmpbvxwhchc.swift:10:35: error: value of type\
    \ 'String' has no member 'range'\n        let range = (string as NSString).range(of:\
    \ substring)\n                    ~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpbvxwhchc.swift:14:26:\
    \ error: cannot find 'NSNotFound' in scope\n        while range.location != NSNotFound\
    \ {\n                                ^~~~~~~~~~\n/tmp/tmpbvxwhchc.swift:18:21:\
    \ error: cannot find 'NSRange' in scope\n                let searchRange = NSRange(location:\
    \ location, length: substring.length)\n                                  ^~~~~~~\n\
    /tmp/tmpbvxwhchc.swift:18:67: error: value of type 'String' has no member 'length'\n\
    \                let searchRange = NSRange(location: location, length: substring.length)\n\
    \                                                                      ~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpbvxwhchc.swift:20:22: error: cannot find type 'NSString' in\
    \ scope\n                range = (string as NSString).range(of: substring, options:\
    \ [], range: searchRange)\n                                   ^~~~~~~~\n/tmp/tmpbvxwhchc.swift:20:32:\
    \ error: value of type 'String' has no member 'range'\n                range =\
    \ (string as NSString).range(of: substring, options: [], range: searchRange)\n\
    \                        ~~~~~~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    let start = string.startIndex(of: substring)\n    if start == nil { return\
    \ 0 }\n\n    for _ in 0..<string.distance(from: string.startIndex, to: start)\
    \ {\n        let end = string.index(start, offsetBy: substring.count, limitedBy:\
    \ string.endIndex)\n        guard end != nil else { continue }\n        let range\
    \ = start..<end!\n        count += range.count\n        start = end!\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpafx8ea8t.swift:11:24: error: cannot call value of non-function\
    \ type 'String.Index'\n    let start = string.startIndex(of: substring)\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advanced(by: substring.startIndex.distanceTo(string.startIndex))\n\
    \    let end = string.endIndex.advanced(by: substring.startIndex.distanceTo(string.startIndex))\n\
    \    if string.hasPrefix(substring) {\n        if string.endIndex.distanceTo(start)\
    \ >= substring.endIndex.distanceTo(string.startIndex) {\n            return substring.distanceTo(start)\
    \ - string.startIndex.distanceTo(substring.startIndex)\n        } else {\n   \
    \         return 0\n        }\n    } else if string.endIndex.distanceTo(start)\
    \ >= substring.startIndex.distanceTo(string.startIndex) {\n        return string.endIndex.distanceTo(start)\
    \ - substring.startIndex.distanceTo(string.startIndex)\n    } else {\n       \
    \ return 0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmrrcrp3i.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advanced'\n    let start = string.startIndex.advanced(by: substring.startIndex.distanceTo(string.startIndex))\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpmrrcrp3i.swift:10:69: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let start = string.startIndex.advanced(by:\
    \ substring.startIndex.distanceTo(string.startIndex))\n                      \
    \                         ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpmrrcrp3i.swift:11:31:\
    \ error: value of type 'String.Index' has no member 'advanced'\n    let end =\
    \ string.endIndex.advanced(by: substring.startIndex.distanceTo(string.startIndex))\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpmrrcrp3i.swift:11:65: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.endIndex.advanced(by:\
    \ substring.startIndex.distanceTo(string.startIndex))\n                      \
    \                     ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpmrrcrp3i.swift:13:28:\
    \ error: value of type 'String.Index' has no member 'distanceTo'\n        if string.endIndex.distanceTo(start)\
    \ >= substring.endIndex.distanceTo(string.startIndex) {\n           ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpmrrcrp3i.swift:13:68: error: value of type 'String.Index'\
    \ has no member 'distanceTo'\n        if string.endIndex.distanceTo(start) >=\
    \ substring.endIndex.distanceTo(string.startIndex) {\n                       \
    \                         ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpmrrcrp3i.swift:14:30:\
    \ error: value of type 'String' has no member 'distanceTo'\n            return\
    \ substring.distanceTo(start) - string.startIndex.distanceTo(substring.startIndex)\n\
    \                   ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpmrrcrp3i.swift:14:68: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n            return\
    \ substring.distanceTo(start) - string.startIndex.distanceTo(substring.startIndex)\n\
    \                                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpmrrcrp3i.swift:18:31: error: value of type 'String"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.isEmpty\
    \ {\n        return 0\n    }\n    guard let index = string.index(of: substring)\
    \ else {\n        return 0\n    }\n    var count = 0\n    for i in 0 ..< string.count\
    \ {\n        if i != index {\n            let char = string[i]\n            if\
    \ string.index(after: i) != index.advanced(by: 1) {\n                count +=\
    \ 1\n            }\n            if string.index(before: i) != index.advanced(by:\
    \ -1) {\n                count += 1\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpht_f0c2_.swift:13:40: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    guard let\
    \ index = string.index(of: substring) else {\n                               \
    \        ^\n/tmp/tmpht_f0c2_.swift:19:24: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   let char = string[i]\n                       ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpht_f0c2_.swift:20:36:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \            if string.index(after: i) != index.advanced(by: 1) {\n          \
    \                         ^\n/tmp/tmpht_f0c2_.swift:23:37: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String.Index'\n            if\
    \ string.index(before: i) != index.advanced(by: -1) {\n                      \
    \              ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let substrings\
    \ = substring.characters.map({ String($0) })\n    var count = 0\n    for index\
    \ in string.characters.indices {\n        for substring_index in substrings.indices\
    \ {\n            if string.characters.elementAt(index) == substrings.elementAt(substring_index)\
    \ {\n                count = count + 1\n                break\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1kej2ch6.swift:10:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let substrings = substring.characters.map({ String($0)\
    \ })\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1kej2ch6.swift:12:25: error: 'characters' is unavailable:\
    \ Please use String directly\n    for index in string.characters.indices {\n \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp1kej2ch6.swift:14:34: error: value of type 'String' has\
    \ no member 'elementAt'\n            if string.characters.elementAt(index) ==\
    \ substrings.elementAt(substring_index) {\n               ~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n\
    /tmp/tmp1kej2ch6.swift:14:65: error: value of type '[String]' has no member 'elementAt'\n\
    \            if string.characters.elementAt(index) == substrings.elementAt(substring_index)\
    \ {\n                                                     ~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    \n    var count\
    \ = 0\n    \n    if string != \"\" {\n        let splitString = string.lowercased().components(separatedBy:\
    \ substring)\n        let stringArray = splitString.flatMap { $0 }\n        for\
    \ subString in stringArray {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpprvutwuk.swift:14:47: error: value of type 'String' has no member\
    \ 'components'\n        let splitString = string.lowercased().components(separatedBy:\
    \ substring)\n                          ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if let foundIndex\
    \ = string.firstIndex(of: substring) {\n        let originalLength = string.distance(from:\
    \ string.startIndex, to: foundIndex)\n        return originalLength / substring.length\n\
    \    } else {\n        return 0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmy4z8e8k.swift:10:47: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    if let foundIndex\
    \ = string.firstIndex(of: substring) {\n                                     \
    \         ^\n/tmp/tmpmy4z8e8k.swift:12:31: error: cannot convert return expression\
    \ of type 'Duration' to return type 'Int'\n        return originalLength / substring.length\n\
    \               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpmy4z8e8k.swift:12:43:\
    \ error: value of type 'String' has no member 'length'\n        return originalLength\
    \ / substring.length\n                                ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.lowercased().index(substring.lowercased(), options: .caseInsensitive)\n\
    \    return index == nil ? 0 : index!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpflko7e30.swift:10:37: error: no exact matches in call to instance\
    \ method 'index'\n    let index = string.lowercased().index(substring.lowercased(),\
    \ options: .caseInsensitive)\n                                    ^\n/tmp/tmpflko7e30.swift:10:37:\
    \ note: found candidate with type '(String.Index) -> String.Index'\n    let index\
    \ = string.lowercased().index(substring.lowercased(), options: .caseInsensitive)\n\
    \                                    ^\n/tmp/tmpflko7e30.swift:10:37: note: found\
    \ candidate with type '(String.Index) -> String.Index'\n    let index = string.lowercased().index(substring.lowercased(),\
    \ options: .caseInsensitive)\n                                    ^\n/tmp/tmpflko7e30.swift:10:37:\
    \ note: found candidate with type '((String.Element) throws -> Bool) throws ->\
    \ String.Index?' (aka '((Character) throws -> Bool) throws -> Optional<String.Index>')\n\
    \    let index = string.lowercased().index(substring.lowercased(), options: .caseInsensitive)\n\
    \                                    ^\n/tmp/tmpflko7e30.swift:10:37: note: found\
    \ candidate with type '(String.Element) -> String.Index?' (aka '(Character) ->\
    \ Optional<String.Index>')\n    let index = string.lowercased().index(substring.lowercased(),\
    \ options: .caseInsensitive)\n                                    ^\n/tmp/tmpflko7e30.swift:10:77:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \    let index = string.lowercased().index(substring.lowercased(), options: .caseInsensitive)\n\
    \                                                                           ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string:\
    \ &string, substring: &substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwu9_y0bn.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string: &string, substring: &substring)\n           ^~~~~\n/tmp/tmpwu9_y0bn.swift:10:26:\
    \ error: cannot pass immutable value as inout argument: 'string' is a 'let' constant\n\
    \    return count(string: &string, substring: &substring)\n                  \
    \       ^~~~~~~\n/tmp/tmpwu9_y0bn.swift:10:46: error: cannot pass immutable value\
    \ as inout argument: 'substring' is a 'let' constant\n    return count(string:\
    \ &string, substring: &substring)\n                                          \
    \   ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.contains(substring)\
    \ {\n        return string.count{ $0 == substring }\n    } else {\n        return\
    \ -1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9cy5adhv.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count{ $0 == substring }\n               \
    \       ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n\n    var counter = 0\n    var idx = 0\n  \
    \  while idx < string.characters.count {\n        if substring[idx] != string[idx]\
    \ {\n            break\n        }\n\n        counter += 1\n        idx += 1\n\
    \    }\n\n    return counter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbybnqoor.swift:16:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    while idx < string.characters.count {\n           \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpbybnqoor.swift:17:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if substring[idx] !=\
    \ string[idx] {\n           ^~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpbybnqoor.swift:17:30: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if substring[idx] != string[idx] {\n                             ^~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let characters\
    \ = (string as NSString).characters.map() { $0 }\n    var count = 0\n    var start\
    \ = characters.index(of: substring)\n    while start != NSNotFound  {\n      \
    \  count += substring.length\n        start = characters.index(of: substring,\
    \ in: start + 1..<characters.count)\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_bauvvja.swift:10:33: error: cannot find type 'NSString' in scope\n\
    \    let characters = (string as NSString).characters.map() { $0 }\n         \
    \                       ^~~~~~~~\n/tmp/tmp_bauvvja.swift:13:20: error: cannot\
    \ find 'NSNotFound' in scope\n    while start != NSNotFound  {\n             \
    \      ^~~~~~~~~~\n/tmp/tmp_bauvvja.swift:14:28: error: value of type 'String'\
    \ has no member 'length'\n        count += substring.length\n                \
    \ ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var i = 0\n\
    \    var count = 0\n    \n    for i in 0..<string.count {\n        let index =\
    \ string.index(string.startIndex, offsetBy: i)\n        let foundIndex = string.index(index,\
    \ offsetBy: substring.count)\n        \n        if foundIndex != nil {\n     \
    \       count = 1 + min(count, foundIndex!.distance(from: string.startIndex))\n\
    \        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplql8b4gr.swift:17:23: warning: comparing non-optional value of\
    \ type 'String.Index' to 'nil' always returns true\n        if foundIndex != nil\
    \ {\n           ~~~~~~~~~~ ^  ~~~\n/tmp/tmplql8b4gr.swift:18:46: error: cannot\
    \ force unwrap value of non-optional type 'String.Index'\n            count =\
    \ 1 + min(count, foundIndex!.distance(from: string.startIndex))\n            \
    \                       ~~~~~~~~~~^\n                                        \
    \     \n/tmp/tmplql8b4gr.swift:18:48: error: value of type 'String.Index' has\
    \ no member 'distance'\n            count = 1 + min(count, foundIndex!.distance(from:\
    \ string.startIndex))\n                                   ~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.count\
    \ < substring.count {\n        return -1\n    }\n\n    var times = 0\n    var\
    \ start = string.startIndex\n    var end = string.endIndex\n\n    while start\
    \ < end {\n        if string.substring(start, end) == substring {\n          \
    \  times += 1\n            start = start + string.count\n            end = string.endIndex\n\
    \        }\n        else {\n            start = string.startIndex\n          \
    \  end = string.endIndex\n        }\n    }\n\n    return times\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2s94pj7s.swift:19:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(start, end) == substring {\n      \
    \     ~~~~~~ ^~~~~~~~~\n/tmp/tmp2s94pj7s.swift:21:27: error: binary operator '+'\
    \ cannot be applied to operands of type 'String.Index' and 'Int'\n           \
    \ start = start + string.count\n                    ~~~~~ ^ ~~~~~~~~~~~~\n/tmp/tmp2s94pj7s.swift:21:27:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n            start = start + string.count\n                     \
    \     ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn count_occurrence(string:\
    \ String, substring: substring, count: 0) + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwpzo5opn.swift:10:9: error: cannot find 'count_occurrence' in scope\n\
    \        return count_occurrence(string: String, substring: substring, count:\
    \ 0) + 1\n               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring) + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz24xznz9.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring) + 1\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let substringIndex\
    \ = string.firstIndex(of: substring) else { return 0 }\n\n    // If the string\
    \ is empty, return 0.\n    if substringIndex == string.endIndex { return 0 }\n\
    \n    // If the substring is found at the beginning of the string, return 1.\n\
    \    if substringIndex == 0 { return 1 }\n\n    // If the substring is found at\
    \ the end of the string, return 0.\n    if substringIndex == string.index(before:\
    \ string.endIndex) { return 0 }\n\n    // If the substring is found somewhere\
    \ in the middle, return the number of times the substring can be found on the\
    \ string\n    // before it and the substring itself after the string.\n    return\
    \ 1 + how_many_times(string: string.substring(from: substringIndex), substring:\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsiq5ggz9.swift:10:54: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    guard let\
    \ substringIndex = string.firstIndex(of: substring) else { return 0 }\n      \
    \                                               ^\n/tmp/tmpsiq5ggz9.swift:23:46:\
    \ error: value of type 'String' has no member 'substring'\n    return 1 + how_many_times(string:\
    \ string.substring(from: substringIndex), substring: substring)\n            \
    \                          ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    guard string.contains(substring) else { return 0 }\n    if let index\
    \ = string.range(of: substring, options: .caseInsensitive) {\n        var start\
    \ = index\n        while start < string.endIndex,\n               let rangeEnd\
    \ = string.range(of: substring, options: .caseInsensitive, range: start..<index),\n\
    \               rangeEnd.upperBound > rangeEnd.lowerBound\n        {\n       \
    \     start = rangeEnd\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuycz342r.swift:12:27: error: value of type 'String' has no member\
    \ 'range'\n    if let index = string.range(of: substring, options: .caseInsensitive)\
    \ {\n                   ~~~~~~ ^~~~~\n/tmp/tmpuycz342r.swift:12:58: error: cannot\
    \ infer contextual base in reference to member 'caseInsensitive'\n    if let index\
    \ = string.range(of: substring, options: .caseInsensitive) {\n               \
    \                                         ~^~~~~~~~~~~~~~~\n/tmp/tmpuycz342r.swift:15:38:\
    \ error: value of type 'String' has no member 'range'\n               let rangeEnd\
    \ = string.range(of: substring, options: .caseInsensitive, range: start..<index),\n\
    \                              ~~~~~~ ^~~~~\n/tmp/tmpuycz342r.swift:15:69: error:\
    \ cannot infer contextual base in reference to member 'caseInsensitive'\n    \
    \           let rangeEnd = string.range(of: substring, options: .caseInsensitive,\
    \ range: start..<index),\n                                                   \
    \                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ {\n        return string.countSuffix(substring)\n    } else {\n        return\
    \ string.countSubstring(substring)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5f5o8wuj.swift:11:23: error: value of type 'String' has no member\
    \ 'countSuffix'\n        return string.countSuffix(substring)\n              \
    \ ~~~~~~ ^~~~~~~~~~~\n/tmp/tmp5f5o8wuj.swift:13:23: error: value of type 'String'\
    \ has no member 'countSubstring'\n        return string.countSubstring(substring)\n\
    \               ~~~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.count {\n        guard let index = string.distance(from:\
    \ string.startIndex, to: index) == 0 else {\n            continue // No match\
    \ at all\n        }\n        if string[index] == substring {\n            count\
    \ += 1\n        } else {\n            if string[index] == substring[substring.length\
    \ - 1], string.index(before: index) == nil {\n                count += 2\n   \
    \         }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbsn4c0j2.swift:12:72: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        guard let index = string.distance(from:\
    \ string.startIndex, to: index) == 0 else {\n                                \
    \                                       ^\n/tmp/tmpbsn4c0j2.swift:18:53: error:\
    \ value of type 'String' has no member 'length'\n            if string[index]\
    \ == substring[substring.length - 1], string.index(before: index) == nil {\n \
    \                                         ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif string == \"\
    \" || substring == \"\" {\n\t\treturn 0\n\t}\n\n\tlet lower = string.startIndex.map({\
    \ $0 == string.startIndex.lowerBound })\n\tlet upper = string.index(string.startIndex,\
    \ offsetBy: substring.count)\n\n\tlet lowerUpper = (lower, upper) |> Seq.zip\n\
    \n\tvar lowerUpperCount = 0\n\n\tfor (lo, hi) <- lowerUpper {\n\t\tif lo == false\
    \ && hi == false {\n\t\t\tbreak\n\t\t}\n\n\t\tif lo == false {\n\t\t\tlowerUpperCount\
    \ += 1\n\t\t}\n\n\t\tif hi == false {\n\t\t\tlowerUpperCount += 1\n\t\t}\n\n\t\
    \tif lo == true {\n\t\t\tlowerUpperCount += hi.count + 1\n\t\t}\n\n\t\tif hi ==\
    \ true {\n\t\t\tlowerUpperCount += lo.count + 1\n\t\t}\n\t}\n\n\treturn lowerUpperCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqxeye_1e.swift:21:15: error: expected 'in' after for-each pattern\n\
    \        for (lo, hi) <- lowerUpper {\n                     ^\n/tmp/tmpqxeye_1e.swift:21:15:\
    \ error: unary operator cannot be separated from its operand\n        for (lo,\
    \ hi) <- lowerUpper {\n                     ^ ~\n                       \n/tmp/tmpqxeye_1e.swift:14:32:\
    \ error: value of type 'String.Index' has no member 'map'\n        let lower =\
    \ string.startIndex.map({ $0 == string.startIndex.lowerBound })\n            \
    \        ~~~~~~~~~~~~~~~~~ ^~~\n/tmp/tmpqxeye_1e.swift:14:62: error: value of\
    \ type 'String.Index' has no member 'lowerBound'\n        let lower = string.startIndex.map({\
    \ $0 == string.startIndex.lowerBound })\n                                    \
    \              ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqxeye_1e.swift:17:34: error:\
    \ cannot find operator '|>' in scope\n        let lowerUpper = (lower, upper)\
    \ |> Seq.zip\n                                        ^~\n/tmp/tmpqxeye_1e.swift:17:37:\
    \ error: cannot find 'Seq' in scope\n        let lowerUpper = (lower, upper) |>\
    \ Seq.zip\n                                           ^~~\n/tmp/tmpqxeye_1e.swift:21:15:\
    \ error: cannot find operator '<-' in scope\n        for (lo, hi) <- lowerUpper\
    \ {\n                     ^~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var index =\
    \ 0\n    while index < string.characters.count && index < substring.characters.count\
    \ {\n        if string.characters.contains(substring.characters.suffix(from: index))\
    \ {\n            index += 1\n        }\n        if string.characters.contains(substring.characters.prefix(from:\
    \ index)) {\n            index += 1\n        }\n        index += 1\n    }\n  \
    \  return index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp082klqnp.swift:11:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    while index < string.characters.count && index < substring.characters.count\
    \ {\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp082klqnp.swift:11:64: error: 'characters' is unavailable:\
    \ Please use String directly\n    while index < string.characters.count && index\
    \ < substring.characters.count {\n                                           \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp082klqnp.swift:12:73: error: cannot convert value of type 'Int' to\
    \ expected argument type 'String.Index'\n        if string.characters.contains(substring.characters.suffix(from:\
    \ index)) {\n                                                                \
    \        ^\n/tmp/tmp082klqnp.swift:15:66: error: extraneous argument label 'from:'\
    \ in call\n        if string.characters.contains(substring.characters.prefix(from:\
    \ index)) {\n                                                                \
    \ ^~~~~~~\n                                                                  \n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    let start = string.startIndex.advanced(by:\
    \ substring.startIndex)\n    let end = string.endIndex.advanced(by: substring.startIndex).advanced(by:\
    \ substring.count)\n    return string.distance(from: start, to: end) + 1\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps_mz_4t1.swift:14:35: error: value of type 'String.Index' has no\
    \ member 'advanced'\n    let start = string.startIndex.advanced(by: substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmps_mz_4t1.swift:15:31: error:\
    \ value of type 'String.Index' has no member 'advanced'\n    let end = string.endIndex.advanced(by:\
    \ substring.startIndex).advanced(by: substring.count)\n              ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_occurrences(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0mthzj1n.swift:10:12: error: cannot find 'count_occurrences' in\
    \ scope\n    return count_occurrences(string, substring)\n           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824886
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.characters.index(of: substring)\n    return index == nil ? 0 : index!\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfgl4447y.swift:10:45: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.characters.index(of: substring)\n                                 \
    \           ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tlet searchRange\
    \ = string.startIndex..<string.endIndex.advanced(by: -string.count)\n\treturn\
    \ (string.unicodeScalars.filter { unicodeScalar.compare(substring!, to: $0) !=\
    \ .orderedSame }\n\t\t\t.map({ unicodeScalar.decomposedString.count(for: string.unicodeScalars.filter({\
    \ unicodeScalar.compare(substring!, to: $0) != .orderedSame }) }) ?? 0 }).sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0x2mqb0f.swift:12:145: error: expected ',' separator\n        \
    \                .map({ unicodeScalar.decomposedString.count(for: string.unicodeScalars.filter({\
    \ unicodeScalar.compare(substring!, to: $0) != .orderedSame }) }) ?? 0 }).sum\n\
    \                                                                            \
    \                                                                            \
    \             ^\n                                                            \
    \                                                                            \
    \                            ,\n/tmp/tmp0x2mqb0f.swift:12:145: error: expected\
    \ expression in list of expressions\n                        .map({ unicodeScalar.decomposedString.count(for:\
    \ string.unicodeScalars.filter({ unicodeScalar.compare(substring!, to: $0) !=\
    \ .orderedSame }) }) ?? 0 }).sum\n                                           \
    \                                                                            \
    \                                              ^\n/tmp/tmp0x2mqb0f.swift:12:153:\
    \ error: expected ',' separator\n                        .map({ unicodeScalar.decomposedString.count(for:\
    \ string.unicodeScalars.filter({ unicodeScalar.compare(substring!, to: $0) !=\
    \ .orderedSame }) }) ?? 0 }).sum\n                                           \
    \                                                                            \
    \                                                      ^\n                   \
    \                                                                            \
    \                                                                            \
    \ ,\n/tmp/tmp0x2mqb0f.swift:12:153: error: expected expression in list of expressions\n\
    \                        .map({ unicodeScalar.decomposedString.count(for: string.unicodeScalars.filter({\
    \ unicodeScalar.compare(substring!, to: $0) != .orderedSame }) }) ?? 0 }).sum\n\
    \                                                                            \
    \                                                                            \
    \                     ^\n/tmp/tmp0x2mqb0f.swi"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // Handle case\
    \ where there is no substring\n    if substring == \"\" {\n        return 0\n\
    \    }\n    var count = 0\n    for character in string.characters.reversed() {\n\
    \        if character == substring.characters.first {\n            count += 1\n\
    \        } else {\n            break\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9p1lha5w.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in string.characters.reversed() {\n \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9p1lha5w.swift:16:35: error: 'characters' is unavailable:\
    \ Please use String directly\n        if character == substring.characters.first\
    \ {\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard string.hasSuffix(substring)\
    \ else { return 0 }\n    var counter = 0\n    var startIndex = string.startIndex\n\
    \    while startIndex < string.endIndex {\n        let start = startIndex\n  \
    \      let end = startIndex + substring.length\n        if let range = string.range(of:\
    \ substring, range: start..<end) {\n            counter += 1\n            startIndex\
    \ = range.upperBound\n        } else {\n            break\n        }\n    }\n\
    \    return counter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4viss33v.swift:15:42: error: value of type 'String' has no member\
    \ 'length'\n        let end = startIndex + substring.length\n                \
    \               ~~~~~~~~~ ^~~~~~\n/tmp/tmp4viss33v.swift:16:31: error: value of\
    \ type 'String' has no member 'range'\n        if let range = string.range(of:\
    \ substring, range: start..<end) {\n                       ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard string.rangeOfString(substring)\
    \ != nil else { return 0 }\n    guard string.lowercaseString.rangeOfString(substring)\
    \ != nil else { return 0 }\n    let lowercaseString = string.lowercaseString\n\
    \    let substringRange = string.rangeOfString(substring)\n    let substringLength\
    \ = substringRange.endIndex - substringRange.startIndex\n    let string = lowercaseString.substringWithRange(substringRange)\n\
    \    let count = lowercaseString.countSubstrings(in: string)\n    return count\
    \ + (substringLength / 2.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7jm19ktg.swift:10:18: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard string.rangeOfString(substring) != nil else { return\
    \ 0 }\n          ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp7jm19ktg.swift:11:18: error: value\
    \ of type 'String' has no member 'lowercaseString'\n    guard string.lowercaseString.rangeOfString(substring)\
    \ != nil else { return 0 }\n          ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp7jm19ktg.swift:12:34:\
    \ error: value of type 'String' has no member 'lowercaseString'\n    let lowercaseString\
    \ = string.lowercaseString\n                          ~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp7jm19ktg.swift:13:33: error: value of type 'String' has no member 'rangeOfString'\n\
    \    let substringRange = string.rangeOfString(substring)\n                  \
    \       ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp7jm19ktg.swift:17:18: error: no '+' candidates\
    \ produce the expected contextual result type 'Int'\n    return count + (substringLength\
    \ / 2.0)\n                 ^\nSwift.Double:2:24: note: '+' produces 'Double',\
    \ not the expected contextual result type 'Int'\n    public static func + (lhs:\
    \ Double, rhs: Double) -> Double\n                       ^\nSwift.Duration:6:24:\
    \ note: '+' produces 'Duration', not the expected contextual result type 'Int'\n\
    \    public static func + (lhs: Duration, rhs: Duration) -> Duration\n       \
    \                ^\n_Concurrency.ContinuousClock.Instant:9:35: note: '+' produces\
    \ 'ContinuousClock.Instant', not the expected contextual result type 'Int'\n \
    \   @inlinable public static func + (lhs: ContinuousClock.Instant, rhs: Duration)\
    \ -> ContinuousClock.Instant\n                                  ^\n_Concurrency.SuspendingClock.Instant:16:24:\
    \ note: '+' produces 'SuspendingClock.Instant', not the expected contextual result\
    \ type 'Int'\n    public static func + (lhs: SuspendingClock.Instant, rhs: Duration)\
    \ -> SuspendingClock.Instant\n                       ^\nSwift.AdditiveArithmetic:3:17:\
    \ note: '+' produces 'Duration', not the expected contextual result type 'Int'\n\
    \    static func + (lhs: Self, rhs: Self) -> Self\n                ^\nSwift.Double:2:2"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var count = 0\n  \
    \  var startIndex = string.startIndex\n    var endIndex = string.endIndex\n  \
    \  while startIndex < endIndex {\n        let index = startIndex.distanceTo(substring,\
    \ matchingPolicy: .BackwardsSearch)\n        guard index < string.count else {\n\
    \            return count\n        }\n        if index == 0 {\n            count\
    \ += 1\n        }\n        if string.substring(index, length: substring.length).starts(with:\
    \ substring) {\n            count += 1\n        }\n        startIndex = string.index(startIndex,\
    \ offsetBy: substring.length)\n        endIndex = string.index(startIndex, offsetBy:\
    \ substring.length, limitedBy: string.endIndex) ?? string.endIndex\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzxxfsk_e.swift:17:32: error: value of type 'String.Index' has no\
    \ member 'distanceTo'\n        let index = startIndex.distanceTo(substring, matchingPolicy:\
    \ .BackwardsSearch)\n                    ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpzxxfsk_e.swift:17:71:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \        let index = startIndex.distanceTo(substring, matchingPolicy: .BackwardsSearch)\n\
    \                                                                     ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpzxxfsk_e.swift:24:19: error: value of type 'String' has no member 'substring'\n\
    \        if string.substring(index, length: substring.length).starts(with: substring)\
    \ {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmpzxxfsk_e.swift:24:54: error: value of\
    \ type 'String' has no member 'length'\n        if string.substring(index, length:\
    \ substring.length).starts(with: substring) {\n                              \
    \             ~~~~~~~~~ ^~~~~~\n/tmp/tmpzxxfsk_e.swift:27:67: error: value of\
    \ type 'String' has no member 'length'\n        startIndex = string.index(startIndex,\
    \ offsetBy: substring.length)\n                                              \
    \          ~~~~~~~~~ ^~~~~~\n/tmp/tmpzxxfsk_e.swift:28:65: error: value of type\
    \ 'String' has no member 'length'\n        endIndex = string.index(startIndex,\
    \ offsetBy: substring.length, limitedBy: string.endIndex) ?? string.endIndex\n\
    \                                                      ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    \n    var count =\
    \ 0\n    \n    if substring.hasPrefix(string) {\n        count = 1 + how_many_times(substring[string.startIndex],\
    \ string)\n    }\n    \n    if substring.hasSuffix(string) {\n        count =\
    \ 1 + how_many_times(string, substring[string.endIndex..<string.endIndex.advancedBy(-1)])\n\
    \    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptaq6i6tz.swift:17:35: error: missing argument labels 'string:substring:'\
    \ in call\n        count = 1 + how_many_times(substring[string.startIndex], string)\n\
    \                                  ^\n                                   string:\
    \                       substring: \n/tmp/tmptaq6i6tz.swift:17:45: error: subscript\
    \ 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \        count = 1 + how_many_times(substring[string.startIndex], string)\n  \
    \                                          ^\nSwift.String:5:12: note: where 'R'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmptaq6i6tz.swift:21:35: error: missing\
    \ argument labels 'string:substring:' in call\n        count = 1 + how_many_times(string,\
    \ substring[string.endIndex..<string.endIndex.advancedBy(-1)])\n             \
    \                     ^\n                                   string: substring:\
    \ \n/tmp/tmptaq6i6tz.swift:21:53: error: subscript 'subscript(_:)' requires the\
    \ types 'String.Index' and 'Int' be equivalent\n        count = 1 + how_many_times(string,\
    \ substring[string.endIndex..<string.endIndex.advancedBy(-1)])\n             \
    \                                       ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmptaq6i6tz.swift:21:88: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n        count = 1 + how_many_times(string,\
    \ substring[string.endIndex..<string.endIndex.advancedBy(-1)])\n             \
    \                                                          ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.filter({\
    \ $0.contains(substring) }).count {\n        substring, $0.contains(substring)\
    \ == true\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd9v920t2.swift:11:18: error: consecutive statements on a line must\
    \ be separated by ';'\n        substring, $0.contains(substring) == true\n   \
    \              ^\n                 ;\n/tmp/tmpd9v920t2.swift:11:18: error: expected\
    \ expression\n        substring, $0.contains(substring) == true\n            \
    \     ^\n/tmp/tmpd9v920t2.swift:10:54: error: cannot call value of non-function\
    \ type 'Int'\n    return string.filter({ $0.contains(substring) }).count {\n \
    \                                                    ^\n/tmp/tmpd9v920t2.swift:10:31:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'contains'\n\
    \    return string.filter({ $0.contains(substring) }).count {\n              \
    \             ~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.utf16CountContaining(substring.utf16s)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc7zubyfb.swift:10:19: error: value of type 'String' has no member\
    \ 'utf16CountContaining'\n    return string.utf16CountContaining(substring.utf16s)\n\
    \           ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpc7zubyfb.swift:10:50: error:\
    \ value of type 'String' has no member 'utf16s'\n    return string.utf16CountContaining(substring.utf16s)\n\
    \                                       ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let stringRange\
    \ = Range(string.startIndex..<string.endIndex, in: string),\n        let substringRange\
    \ = Range(substring.startIndex..<substring.endIndex, in: substring),\n       \
    \ let foundRange = string.range(of: substring) else {\n        return 0\n    }\n\
    \    return foundRange.lowerBound == stringRange.lowerBound ? stringRange.upperBound\
    \ - foundRange.upperBound + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp44i0x810.swift:15:60: error: expected ':' after '? ...' in ternary\
    \ expression\n    return foundRange.lowerBound == stringRange.lowerBound ? stringRange.upperBound\
    \ - foundRange.upperBound + 1\n                                              \
    \             ^\n/tmp/tmp44i0x810.swift:10:29: error: generic parameter 'Bound'\
    \ could not be inferred\n    guard let stringRange = Range(string.startIndex..<string.endIndex,\
    \ in: string),\n                            ^\n/tmp/tmp44i0x810.swift:10:29: note:\
    \ explicitly specify the generic arguments to fix this issue\n    guard let stringRange\
    \ = Range(string.startIndex..<string.endIndex, in: string),\n                \
    \            ^\n                                 <<#Bound: Comparable#>>\n/tmp/tmp44i0x810.swift:10:34:\
    \ error: initializer expects a single parameter of type '(lower: Bound, upper:\
    \ Bound)' [with Bound = Bound]\n    guard let stringRange = Range(string.startIndex..<string.endIndex,\
    \ in: string),\n                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                  (                                         \
    \     )\n/tmp/tmp44i0x810.swift:10:52: error: cannot convert value of type '(Range<String.Index>,\
    \ in: String)' to expected argument type '(lower: Bound, upper: Bound)'\n    guard\
    \ let stringRange = Range(string.startIndex..<string.endIndex, in: string),\n\
    \                                                   ^\n/tmp/tmp44i0x810.swift:11:30:\
    \ error: generic parameter 'Bound' could not be inferred\n        let substringRange\
    \ = Range(substring.startIndex..<substring.endIndex, in: substring),\n       \
    \                      ^\n/tmp/tmp44i0x810.swift:11:30: note: explicitly specify\
    \ the generic arguments to fix this issue\n        let substringRange = Range(substring.startIndex..<substring.endIndex,\
    \ in: substring),\n                             ^\n                          \
    \        <<#Bound: Comparable#>>\n/tmp/tmp44i0x810.swift:11:35: error: initializer\
    \ expects a single parameter of type '(lower: Bound, upper: Bound)' [with Bound\
    \ = Bound]\n        let substr"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring.hasPrefix(string)\
    \ {\n        let lowerCaseSubstring = substring\n            .characters.map({\
    \ String($0) })\n            .map(String.init)\n            .map(String.init)\n\
    \            .map(String.init)\n            .map { String($0) }\n            .map(String.init)\n\
    \            .map(String.init)\n            .map { $0.lowercased() }\n       \
    \     .map(String.init)\n            .map(String.init)\n            .map { $0.uppercased()\
    \ }\n            .map(String.init)\n            .map(String.init)\n          \
    \  .map { $0.capitalized() }\n            .map(String.init)\n            .map\
    \ { $0.localizedStandardCompare(string) == ComparisonResult.orderedSame }\n  \
    \          .compactMap({ $0 })\n            .count\n        return lowerCaseSubstring\n\
    \    }\n    else {\n        let upperCaseSubstring = string\n            .characters.map({\
    \ String($0) })\n            .map(String.init)\n            .map(String.init)\n\
    \            .map(String.init)\n            .map { String($0) }\n            .map(String.init)\n\
    \            .map(String.init)\n            .map { $0.uppercased() }\n       \
    \     .map(String.init)\n            .map(String.init)\n            .map { $0.capitalized()\
    \ }\n            .map(String.init)\n            .map { $0.localizedStandardCompare(string)\
    \ == ComparisonResult.orderedSame }\n            .compactMap({ $0 })\n       \
    \     .count\n        return upperCaseSubstring\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpifgv3c_n.swift:27:59: error: cannot find 'ComparisonResult' in\
    \ scope\n            .map { $0.localizedStandardCompare(string) == ComparisonResult.orderedSame\
    \ }\n                                                          ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpifgv3c_n.swift:46:59: error: cannot find 'ComparisonResult' in scope\n\
    \            .map { $0.localizedStandardCompare(string) == ComparisonResult.orderedSame\
    \ }\n                                                          ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn count_overlapping_chars(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz6dbrob6.swift:10:9: error: cannot find 'count_overlapping_chars'\
    \ in scope\n        return count_overlapping_chars(string, substring)\n      \
    \         ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.characters.filter({\
    \ string.distance(from: $0, to: substring.starts(with: substring)) != 0 }).count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpayqtg18a.swift:10:61: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String.Index'\n    return string.characters.filter({\
    \ string.distance(from: $0, to: substring.starts(with: substring)) != 0 }).count\n\
    \                                                            ^\n/tmp/tmpayqtg18a.swift:10:79:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'String.Index'\n\
    \    return string.characters.filter({ string.distance(from: $0, to: substring.starts(with:\
    \ substring)) != 0 }).count\n                                                \
    \                              ^\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn countOccurrences(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprzpez59u.swift:10:9: error: cannot find 'countOccurrences' in scope\n\
    \        return countOccurrences(string, substring)\n               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif string == \"\
    \" {\n\t\treturn 0\n\t}\n\tlet start = string.startIndex(of: substring)\n\tlet\
    \ end = string.index(start, offsetBy: substring.length)\n\tif end != nil {\n\t\
    \treturn Int(end - start) + 1\n\t}\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbmorepy6.swift:13:21: error: cannot call value of non-function\
    \ type 'String.Index'\n        let start = string.startIndex(of: substring)\n\
    \                           ^\n/tmp/tmpbmorepy6.swift:14:52: error: value of type\
    \ 'String' has no member 'length'\n        let end = string.index(start, offsetBy:\
    \ substring.length)\n                                                ~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpbmorepy6.swift:16:10: error: no exact matches in call to initializer\
    \ \n                return Int(end - start) + 1\n                       ^\n/tmp/tmpbmorepy6.swift:16:10:\
    \ note: found candidate with type '(Float16) -> Int'\n                return Int(end\
    \ - start) + 1\n                       ^\n/tmp/tmpbmorepy6.swift:16:10: note:\
    \ found candidate with type '(Float) -> Int'\n                return Int(end -\
    \ start) + 1\n                       ^\n/tmp/tmpbmorepy6.swift:16:10: note: found\
    \ candidate with type '(Double) -> Int'\n                return Int(end - start)\
    \ + 1\n                       ^\n/tmp/tmpbmorepy6.swift:16:10: note: found candidate\
    \ with type '(Float80) -> Int'\n                return Int(end - start) + 1\n\
    \                       ^\n/tmp/tmpbmorepy6.swift:16:10: note: found candidate\
    \ with type '(Builtin.Int64) -> Int'\n                return Int(end - start)\
    \ + 1\n                       ^\n/tmp/tmpbmorepy6.swift:16:10: note: found candidate\
    \ with type '(Builtin.Word) -> Int'\n                return Int(end - start) +\
    \ 1\n                       ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return\
    \ 1\n    }\n    if substring[0] == string[0] {\n        return how_many_times(string[1..<string.characters.count],\
    \ substring[1:])\n    } else {\n        let substringCharacters = substring.characters\n\
    \        var count = 0\n        for (i, _) in string.enumerated() {\n        \
    \    if substringCharacters.contains(string[i]) {\n                count += 1\n\
    \                if count > 1 {\n                    return count\n          \
    \      }\n            }\n        }\n        return count\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0eeez_yo.swift:17:79: error: expected ',' separator\n        return\
    \ how_many_times(string[1..<string.characters.count], substring[1:])\n       \
    \                                                                       ^\n  \
    \                                                                            ,\n\
    /tmp/tmp0eeez_yo.swift:17:79: error: expected expression in list of expressions\n\
    \        return how_many_times(string[1..<string.characters.count], substring[1:])\n\
    \                                                                            \
    \  ^\n/tmp/tmp0eeez_yo.swift:16:8: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    if substring[0]\
    \ == string[0] {\n       ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp0eeez_yo.swift:16:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    if substring[0] == string[0] {\n                       ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp0eeez_yo.swift:17:30:\
    \ error: missing argument labels 'string:substring:' in call\n        return how_many_times(string[1..<string.characters.count],\
    \ substring[1:])\n                             ^\n                           \
    \   string:                              substring: \n/tmp/tmp0eeez_yo.swift:17:77:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        return how_many_times(string[1..<string.characters.count], substring[1:])\n\
    \                                                                            ^\n\
    /tmp/tmp0eeez_yo.swift:19:45: error: 'characters' is unavailable: Please use String\
    \ directly\n        let substringCharacters = substring.characters\n         \
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift "
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.distance(from: substring)\n    return (index + substring.length - 1).quotientAndRemainder()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz8m9___u.swift:10:24: error: no exact matches in call to instance\
    \ method 'distance'\n    let index = string.distance(from: substring)\n      \
    \                 ^\n/tmp/tmpz8m9___u.swift:10:24: note: candidate has partially\
    \ matching parameter list (from: String.Index, to: String.Index)\n    let index\
    \ = string.distance(from: substring)\n                       ^\n/tmp/tmpz8m9___u.swift:10:24:\
    \ note: candidate has partially matching parameter list (from: String.Index, to:\
    \ String.Index)\n    let index = string.distance(from: substring)\n          \
    \             ^\n/tmp/tmpz8m9___u.swift:10:24: note: candidate has partially matching\
    \ parameter list (from: String.Index, to: String.Index)\n    let index = string.distance(from:\
    \ substring)\n                       ^\n/tmp/tmpz8m9___u.swift:11:38: error: binary\
    \ operator '-' cannot be applied to operands of type 'String' and 'Float16'\n\
    \    return (index + substring.length - 1).quotientAndRemainder()\n          \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n/tmp/tmpz8m9___u.swift:11:38: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double, Double),\
    \ (Float, Float), (Float16, Float16), (Float80, Float80)\n    return (index +\
    \ substring.length - 1).quotientAndRemainder()\n                             \
    \        ^\n/tmp/tmpz8m9___u.swift:11:31: error: value of type 'String' has no\
    \ member 'length'\n    return (index + substring.length - 1).quotientAndRemainder()\n\
    \                    ~~~~~~~~~ ^~~~~~\n/tmp/tmpz8m9___u.swift:11:43: error: reference\
    \ to member 'quotientAndRemainder' cannot be resolved without a contextual type\n\
    \    return (index + substring.length - 1).quotientAndRemainder()\n          \
    \                                ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.hasSuffix(substring)\
    \ && string.hasPrefix(substring) {\n        let range = string.startIndex..<string.endIndex.advanced(by:\
    \ string.distance(from: string.startIndex, to: string.endIndex.advancedBy(-substring.count)))\n\
    \        return string.distance(from: string.startIndex, to: string.endIndex.advancedBy(range.count))\n\
    \    }\n    if string.hasSuffix(substring) {\n        let range = string.startIndex..<string.endIndex.advanced(by:\
    \ string.distance(from: string.startIndex, to: string.endIndex.advancedBy(-substring.count)))\n\
    \        return range.count\n    }\n    if string.hasPrefix(substring) {\n   \
    \     let range = string.startIndex.advanced(by: substring.count)..<string.endIndex\n\
    \        return string.distance(from: string.startIndex, to: string.endIndex.advancedBy(range.count))\n\
    \    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8blchj48.swift:11:57: error: value of type 'String.Index' has no\
    \ member 'advanced'\n        let range = string.startIndex..<string.endIndex.advanced(by:\
    \ string.distance(from: string.startIndex, to: string.endIndex.advancedBy(-substring.count)))\n\
    \                                        ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp8blchj48.swift:11:131:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ range = string.startIndex..<string.endIndex.advanced(by: string.distance(from:\
    \ string.startIndex, to: string.endIndex.advancedBy(-substring.count)))\n    \
    \                                                                            \
    \                                  ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp8blchj48.swift:12:77:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        return\
    \ string.distance(from: string.startIndex, to: string.endIndex.advancedBy(range.count))\n\
    \                                                            ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8blchj48.swift:15:57: error: value of type 'String.Index' has no member\
    \ 'advanced'\n        let range = string.startIndex..<string.endIndex.advanced(by:\
    \ string.distance(from: string.startIndex, to: string.endIndex.advancedBy(-substring.count)))\n\
    \                                        ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp8blchj48.swift:15:131:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ range = string.startIndex..<string.endIndex.advanced(by: string.distance(from:\
    \ string.startIndex, to: string.endIndex.advancedBy(-substring.count)))\n    \
    \                                                                            \
    \                                  ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp8blchj48.swift:19:39:\
    \ error: value of type 'String.Index' has no member 'advanced'\n        let range\
    \ = string.startIndex.advanced(by: substring.count)..<string.endIndex\n      \
    \              ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmp8blchj48.swift:20:77: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n        return string.di"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif substring ==\
    \ \"\" {\n\t\treturn 0\n\t}\n\n\tlet characters = string.characters.split(separator:\
    \ substring)\n\treturn characters.count + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp035c9svb.swift:14:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        let characters = string.characters.split(separator:\
    \ substring)\n                                ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.rangeOfString(substring, options: .CaseInsensitiveSearch)!\n    let end\
    \ = string.rangeOfString(substring, options: .CaseInsensitiveSearch, range: start..<string.endIndex)\n\
    \    return end.location - start.location + 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxtnvn_ax.swift:10:24: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    let start = string.rangeOfString(substring, options: .CaseInsensitiveSearch)!\n\
    \                ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxtnvn_ax.swift:10:59: error: cannot\
    \ infer contextual base in reference to member 'CaseInsensitiveSearch'\n    let\
    \ start = string.rangeOfString(substring, options: .CaseInsensitiveSearch)!\n\
    \                                                         ~^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxtnvn_ax.swift:11:22: error: value of type 'String' has no member 'rangeOfString'\n\
    \    let end = string.rangeOfString(substring, options: .CaseInsensitiveSearch,\
    \ range: start..<string.endIndex)\n              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpxtnvn_ax.swift:11:57:\
    \ error: cannot infer contextual base in reference to member 'CaseInsensitiveSearch'\n\
    \    let end = string.rangeOfString(substring, options: .CaseInsensitiveSearch,\
    \ range: start..<string.endIndex)\n                                          \
    \             ~^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif string.find(substring)\
    \ == String::npos {\n\t\treturn 0\n\t} else {\n\t\tlet index = string.find(substring)\n\
    \t\tlet count = substring.length\n\t\tlet firstMatch = index\n\t\tlet lastMatch\
    \ = index\n\t\tif count > 1 {\n\t\t\tlastMatch = string.distance(from: string.startIndex,\
    \ to: index) + index\n\t\t}\n\t\treturn lastMatch - firstMatch + 1\n\t}\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpglfpa1n6.swift:10:37: error: expected '{' after 'if' condition\n\
    \        if string.find(substring) == String::npos {\n                       \
    \                    ^\n/tmp/tmpglfpa1n6.swift:10:12: error: value of type 'String'\
    \ has no member 'find'\n        if string.find(substring) == String::npos {\n\
    \           ~~~~~~ ^~~~\n/tmp/tmpglfpa1n6.swift:13:22: error: value of type 'String'\
    \ has no member 'find'\n                let index = string.find(substring)\n \
    \                           ~~~~~~ ^~~~\n/tmp/tmpglfpa1n6.swift:14:25: error:\
    \ value of type 'String' has no member 'length'\n                let count = substring.length\n\
    \                            ~~~~~~~~~ ^~~~~~\n/tmp/tmpglfpa1n6.swift:20:20: error:\
    \ cannot convert value of type 'Duration' to expected argument type 'Int'\n  \
    \              return lastMatch - firstMatch + 1\n                           \
    \      ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.count\
    \ { $0 == substring }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpp7e7q2is.swift:10:19: error: cannot call value of non-function\
    \ type 'Int'\n    return string.count { $0 == substring }\n                  ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.split(substring).count\
    \ ?? 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpob15t6k9.swift:10:25: error: missing argument label 'separator:'\
    \ in call\n    return string.split(substring).count ?? 0\n                   \
    \     ^\n                        separator: \n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.countOfString(substring)\
    \ == 0 {\n        return 0\n    }\n\n    if string.rangeOfString(substring) !=\
    \ nil {\n        return 2\n    }\n\n    if string.rangeOfString(substring, options:\
    \ NSStringCompareOptions.CaseInsensitiveSearch) != nil {\n        return 2\n \
    \   }\n\n    return 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpikp0yk4_.swift:10:15: error: value of type 'String' has no member\
    \ 'countOfString'\n    if string.countOfString(substring) == 0 {\n       ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpikp0yk4_.swift:14:15: error: value of type 'String' has\
    \ no member 'rangeOfString'\n    if string.rangeOfString(substring) != nil {\n\
    \       ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpikp0yk4_.swift:18:49: error: cannot find\
    \ 'NSStringCompareOptions' in scope\n    if string.rangeOfString(substring, options:\
    \ NSStringCompareOptions.CaseInsensitiveSearch) != nil {\n                   \
    \                             ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpikp0yk4_.swift:18:15:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    if string.rangeOfString(substring,\
    \ options: NSStringCompareOptions.CaseInsensitiveSearch) != nil {\n       ~~~~~~\
    \ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn count_overlapping_cases(string,\
    \ substring, true, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph4uolphr.swift:10:9: error: cannot find 'count_overlapping_cases'\
    \ in scope\n        return count_overlapping_cases(string, substring, true, true)\n\
    \               ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.lowercase().characters.reduce(0)\
    \ { memo, letter in\n        if let index = string.lowercase().characters.indexOf(letter)\
    \ {\n            memo += 1\n        }\n        return memo\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc7fms87l.swift:10:19: error: value of type 'String' has no member\
    \ 'lowercase'\n    return string.lowercase().characters.reduce(0) { memo, letter\
    \ in\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmpc7fms87l.swift:11:31: error: value\
    \ of type 'String' has no member 'lowercase'\n        if let index = string.lowercase().characters.indexOf(letter)\
    \ {\n                       ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    \n    let mut\
    \ count = 1\n    var index = string.startIndex\n    while index != string.endIndex\
    \ {\n        index = string.index(in: substring, range: nil, locale: nil)\n  \
    \      if index != string.endIndex {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvuqyu7x6.swift:11:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut count =\
    \ 1\n            ^\n/tmp/tmpvuqyu7x6.swift:11:13: note: join the identifiers together\n\
    \    let mut count = 1\n        ~~~~^~~~~\n        mutcount\n/tmp/tmpvuqyu7x6.swift:11:13:\
    \ note: join the identifiers together with camel-case\n    let mut count = 1\n\
    \        ~~~~^~~~~\n        mutCount\n/tmp/tmpvuqyu7x6.swift:14:24: error: no\
    \ exact matches in call to instance method 'index'\n        index = string.index(in:\
    \ substring, range: nil, locale: nil)\n                       ^\n/tmp/tmpvuqyu7x6.swift:14:24:\
    \ note: found candidate with type '(String.Index, Int, String.Index) -> String.Index?'\n\
    \        index = string.index(in: substring, range: nil, locale: nil)\n      \
    \                 ^\n/tmp/tmpvuqyu7x6.swift:14:24: error: value of optional type\
    \ 'String.Index?' must be unwrapped to a value of type 'String.Index'\n      \
    \  index = string.index(in: substring, range: nil, locale: nil)\n            \
    \           ^\n/tmp/tmpvuqyu7x6.swift:14:24: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        index = string.index(in:\
    \ substring, range: nil, locale: nil)\n                       ^\n            \
    \                                                         ?? <#default value#>\n\
    /tmp/tmpvuqyu7x6.swift:14:24: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        index = string.index(in: substring,\
    \ range: nil, locale: nil)\n                       ^\n                       \
    \                                             !\n/tmp/tmpvuqyu7x6.swift:16:13:\
    \ error: cannot find 'count' in scope\n            count += 1\n            ^~~~~\n\
    /tmp/tmpvuqyu7x6.swift:19:12: error: cannot find 'count' in scope\n    return\
    \ count\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let count =\
    \ (string.lowercased().count).times {\n        string.lowercased().prefix(1).contains(substring).suffix(1).lowercased()\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptysf2zlp.swift:10:45: error: value of type 'Int' has no member\
    \ 'times'\n    let count = (string.lowercased().count).times {\n             \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmptysf2zlp.swift:11:59: error: value\
    \ of type 'Bool' has no member 'suffix'\n        string.lowercased().prefix(1).contains(substring).suffix(1).lowercased()\n\
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let substring\
    \ = substring.lowercased()\n    let start = string.startIndex.lowercased().distance(from:\
    \ string.startIndex.lowercased(), to: substring)\n    let stop = string.endIndex.lowercased().distance(from:\
    \ string.startIndex.lowercased(), to: substring)\n    return (string.distance(from:\
    \ string, to: start) + string.distance(from: start, to: stop) - string.distance(from:\
    \ start, to: string.endIndex.lowercased()))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzikx_bxf.swift:11:35: error: value of type 'String.Index' has no\
    \ member 'lowercased'\n    let start = string.startIndex.lowercased().distance(from:\
    \ string.startIndex.lowercased(), to: substring)\n                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpzikx_bxf.swift:11:81: error: value of type 'String.Index'\
    \ has no member 'lowercased'\n    let start = string.startIndex.lowercased().distance(from:\
    \ string.startIndex.lowercased(), to: substring)\n                           \
    \                                   ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpzikx_bxf.swift:12:32:\
    \ error: value of type 'String.Index' has no member 'lowercased'\n    let stop\
    \ = string.endIndex.lowercased().distance(from: string.startIndex.lowercased(),\
    \ to: substring)\n               ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpzikx_bxf.swift:12:78:\
    \ error: value of type 'String.Index' has no member 'lowercased'\n    let stop\
    \ = string.endIndex.lowercased().distance(from: string.startIndex.lowercased(),\
    \ to: substring)\n                                                           ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpzikx_bxf.swift:13:146: error: value of type 'String.Index'\
    \ has no member 'lowercased'\n    return (string.distance(from: string, to: start)\
    \ + string.distance(from: start, to: stop) - string.distance(from: start, to:\
    \ string.endIndex.lowercased()))\n                                           \
    \                                                                            \
    \          ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpzikx_bxf.swift:13:35: error: cannot\
    \ convert value of type 'String' to expected argument type 'String.Index'\n  \
    \  return (string.distance(from: string, to: start) + string.distance(from: start,\
    \ to: stop) - string.distance(from: start, to: string.endIndex.lowercased()))\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.count\
    \ == 0 || substring.count == 0 {\n        return 0\n    }\n\n    guard let start\
    \ = string.range(of: substring) else { return 0 }\n    guard let end = string.range(of:\
    \ substring, options: .backwards) else { return 0 }\n\n    return Int((end.location\
    \ - start.location) + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy_s9fvwe.swift:14:30: error: value of type 'String' has no member\
    \ 'range'\n    guard let start = string.range(of: substring) else { return 0 }\n\
    \                      ~~~~~~ ^~~~~\n/tmp/tmpy_s9fvwe.swift:15:28: error: value\
    \ of type 'String' has no member 'range'\n    guard let end = string.range(of:\
    \ substring, options: .backwards) else { return 0 }\n                    ~~~~~~\
    \ ^~~~~\n/tmp/tmpy_s9fvwe.swift:15:59: error: cannot infer contextual base in\
    \ reference to member 'backwards'\n    guard let end = string.range(of: substring,\
    \ options: .backwards) else { return 0 }\n                                   \
    \                      ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substrings(string,\
    \ substring, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpp4le0b3v.swift:10:12: error: cannot find 'count_substrings' in\
    \ scope\n    return count_substrings(string, substring, 0)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let range =\
    \ (string as NSString).range(of: substring)\n    let count = range?.upperBound\n\
    \    if let count = count {\n        return count\n    }\n    return 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuw9686jn.swift:10:28: error: cannot find type 'NSString' in scope\n\
    \    let range = (string as NSString).range(of: substring)\n                 \
    \          ^~~~~~~~\n/tmp/tmpuw9686jn.swift:10:38: error: value of type 'String'\
    \ has no member 'range'\n    let range = (string as NSString).range(of: substring)\n\
    \                ~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpuw9686jn.swift:11:24: error:\
    \ type of expression is ambiguous without more context\n    let count = range?.upperBound\n\
    \                ~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_times(string:\
    \ &string, substring: &substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4p3zr0d5.swift:10:12: error: cannot find 'count_times' in scope\n\
    \    return count_times(string: &string, substring: &substring)\n           ^~~~~~~~~~~\n\
    /tmp/tmp4p3zr0d5.swift:10:32: error: cannot pass immutable value as inout argument:\
    \ 'string' is a 'let' constant\n    return count_times(string: &string, substring:\
    \ &substring)\n                               ^~~~~~~\n/tmp/tmp4p3zr0d5.swift:10:52:\
    \ error: cannot pass immutable value as inout argument: 'substring' is a 'let'\
    \ constant\n    return count_times(string: &string, substring: &substring)\n \
    \                                                  ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif string.starts(with:\
    \ substring) == false && string.contains(substring) == false {\n\t\treturn 0\n\
    \t}\n\treturn string.range(of: substring, options: .caseInsensitive, range: nil,\
    \ locale: nil)?.lowerBound ?? string.count(of: substring)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8a4puf8t.swift:13:111: error: cannot call value of non-function\
    \ type 'Int'\n        return string.range(of: substring, options: .caseInsensitive,\
    \ range: nil, locale: nil)?.lowerBound ?? string.count(of: substring)\n      \
    \                                                                            \
    \                                   ^\n/tmp/tmp8a4puf8t.swift:13:16: error: value\
    \ of type 'String' has no member 'range'\n        return string.range(of: substring,\
    \ options: .caseInsensitive, range: nil, locale: nil)?.lowerBound ?? string.count(of:\
    \ substring)\n               ~~~~~~ ^~~~~\n/tmp/tmp8a4puf8t.swift:13:47: error:\
    \ cannot infer contextual base in reference to member 'caseInsensitive'\n    \
    \    return string.range(of: substring, options: .caseInsensitive, range: nil,\
    \ locale: nil)?.lowerBound ?? string.count(of: substring)\n                  \
    \                                  ~^~~~~~~~~~~~~~~\n/tmp/tmp8a4puf8t.swift:13:71:\
    \ error: 'nil' requires a contextual type\n        return string.range(of: substring,\
    \ options: .caseInsensitive, range: nil, locale: nil)?.lowerBound ?? string.count(of:\
    \ substring)\n                                                               \
    \              ^\n/tmp/tmp8a4puf8t.swift:13:84: error: 'nil' requires a contextual\
    \ type\n        return string.range(of: substring, options: .caseInsensitive,\
    \ range: nil, locale: nil)?.lowerBound ?? string.count(of: substring)\n      \
    \                                                                            \
    \        ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return strings.Count(substring,\
    \ options: .AnchoredSearch)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdtwv23ys.swift:10:12: error: cannot find 'strings' in scope\n \
    \   return strings.Count(substring, options: .AnchoredSearch)\n           ^~~~~~~\n\
    /tmp/tmpdtwv23ys.swift:10:47: error: cannot infer contextual base in reference\
    \ to member 'AnchoredSearch'\n    return strings.Count(substring, options: .AnchoredSearch)\n\
    \                                             ~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let startIndex\
    \ = string.startIndex.distance(string: substring)\n    let endIndex = string.endIndex.distance(string:\
    \ substring)\n    if startIndex == 0 || endIndex == 0 {\n        return 0\n  \
    \  }\n    return string.distance(from: string.startIndex, to: endIndex) - startIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppot6drzh.swift:10:40: error: value of type 'String.Index' has no\
    \ member 'distance'\n    let startIndex = string.startIndex.distance(string: substring)\n\
    \                     ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmppot6drzh.swift:11:36:\
    \ error: value of type 'String.Index' has no member 'distance'\n    let endIndex\
    \ = string.endIndex.distance(string: substring)\n                   ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.index(of: substring)\n    return index != nil ? index.flatMap { string.index(after:\
    \ $0 + 1) ?? string.endIndex }\n        .compactMap { $0 }\n        .count\n \
    \       : 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpok1z_is2.swift:10:34: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.index(of: substring)\n                                 ^\n/tmp/tmpok1z_is2.swift:11:66:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \    return index != nil ? index.flatMap { string.index(after: $0 + 1) ?? string.endIndex\
    \ }\n                                                                 ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // TODO: Make\
    \ this work in all cases\n    return how_many_times_with_overlapping_cases(string,\
    \ substring, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpo4hrpx2j.swift:11:12: error: cannot find 'how_many_times_with_overlapping_cases'\
    \ in scope\n    return how_many_times_with_overlapping_cases(string, substring,\
    \ false)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tlet start = string.startIndex.advanced(by:\
    \ find(string, substring))\n\tlet end = find(string, substring).advanced(by: substring.length)\n\
    \treturn max(0, end - start)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl0pz9ax5.swift:10:45: error: cannot find 'find' in scope\n    \
    \    let start = string.startIndex.advanced(by: find(string, substring))\n   \
    \                                                ^~~~\n/tmp/tmpl0pz9ax5.swift:10:32:\
    \ error: value of type 'String.Index' has no member 'advanced'\n        let start\
    \ = string.startIndex.advanced(by: find(string, substring))\n                \
    \    ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpl0pz9ax5.swift:11:12: error: cannot find\
    \ 'find' in scope\n        let end = find(string, substring).advanced(by: substring.length)\n\
    \                  ^~~~\n/tmp/tmpl0pz9ax5.swift:11:59: error: value of type 'String'\
    \ has no member 'length'\n        let end = find(string, substring).advanced(by:\
    \ substring.length)\n                                                       ~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpl0pz9ax5.swift:12:20: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return max(0, end - start)\n      \
    \                    ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    var count = 0\n    var startIndex = 0\n\
    \    var endIndex = string.characters.count\n    for subStringIndex in 0..<string.characters.count\
    \ {\n        let subStringLength = substring.length\n        for i in\n      \
    \      0..<subStringLength {\n                if string.characters.count - startIndex\
    \ >= subStringLength {\n                    break\n                }\n       \
    \         let index = string.index(string.startIndex, offsetBy: startIndex + i)\n\
    \                let substringIndex = string.index(index, offsetBy: subStringIndex)\n\
    \                if substringIndex < startIndex || substringIndex >= endIndex\
    \ {\n                    continue\n                }\n                count +=\
    \ 1\n                startIndex = substringIndex\n                endIndex = string.characters.count\n\
    \            }\n        }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpokl4j1f5.swift:15:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    var endIndex = string.characters.count\n          \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpokl4j1f5.swift:16:38: error: 'characters' is unavailable: Please\
    \ use String directly\n    for subStringIndex in 0..<string.characters.count {\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpokl4j1f5.swift:17:41: error: value of type 'String'\
    \ has no member 'length'\n        let subStringLength = substring.length\n   \
    \                           ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    \n    var count\
    \ = 0\n    \n    for index in 0..<string.characters.count {\n        \n      \
    \  if string.substring(from: index).lowercased() == substring.lowercased() {\n\
    \            count += 1\n        } else if string.substring(from: index).lowercased()\
    \ > substring.lowercased() {\n            count += 1\n        } else {\n     \
    \       count -= 1\n        }\n        \n    }\n    \n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy2ulpvp0.swift:13:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpy2ulpvp0.swift:15:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmpy2ulpvp0.swift:17:26: error: value of\
    \ type 'String' has no member 'substring'\n        } else if string.substring(from:\
    \ index).lowercased() > substring.lowercased() {\n                  ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var occurrences\
    \ = 0\n    if string == \"\" {\n        return occurrences\n    }\n\n    if substring\
    \ == \"\" {\n        return occurrences\n    }\n\n    for i in  string.characters.indices\
    \ {\n        if string.characters.elements[i].description == substring {\n   \
    \         occurrences += 1\n            if string.characters.elements[i+1].description\
    \ == substring {\n                occurrences += 1\n                if string.characters.elements[i+2].description\
    \ == substring {\n                    occurrences += 1\n                }\n  \
    \          }\n        }\n    }\n    return occurrences\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphyokttso.swift:19:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in  string.characters.indices {\n           \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmphyokttso.swift:20:30: error: value of type 'String' has no member 'elements'\n\
    \        if string.characters.elements[i].description == substring {\n       \
    \    ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmphyokttso.swift:22:43: error: cannot convert\
    \ value of type 'DefaultIndices<String>.Element' (aka 'String.Index') to expected\
    \ argument type 'Int'\n            if string.characters.elements[i+1].description\
    \ == substring {\n                                          ^\n/tmp/tmphyokttso.swift:22:34:\
    \ error: value of type 'String' has no member 'elements'\n            if string.characters.elements[i+1].description\
    \ == substring {\n               ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmphyokttso.swift:24:47:\
    \ error: cannot convert value of type 'DefaultIndices<String>.Element' (aka 'String.Index')\
    \ to expected argument type 'Int'\n                if string.characters.elements[i+2].description\
    \ == substring {\n                                              ^\n/tmp/tmphyokttso.swift:24:38:\
    \ error: value of type 'String' has no member 'elements'\n                if string.characters.elements[i+2].description\
    \ == substring {\n                   ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n    \n    var count = 0\n    for index in\
    \ 0..<string.characters.count {\n        let isSame = string.characters.index(string.startIndex,\
    \ offsetBy: index) == string.characters.index(string.startIndex, offsetBy: index\
    \ + substring.length)\n        let isStartIndex = string.characters.index(string.startIndex,\
    \ offsetBy: index) == string.characters.index(string.startIndex, offsetBy: 0)\n\
    \        let isEndIndex = string.characters.index(string.startIndex, offsetBy:\
    \ index + substring.length) == string.characters.index(string.startIndex, offsetBy:\
    \ string.characters.count - substring.length)\n        if !isSame && !isStartIndex\
    \ && !isEndIndex {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpx9fzrqzl.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpx9fzrqzl.swift:16:156: error: value of type 'String' has no member\
    \ 'length'\n        let isSame = string.characters.index(string.startIndex, offsetBy:\
    \ index) == string.characters.index(string.startIndex, offsetBy: index + substring.length)\n\
    \                                                                            \
    \                                                                     ~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpx9fzrqzl.swift:17:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        let isStartIndex = string.characters.index(string.startIndex,\
    \ offsetBy: index) == string.characters.index(string.startIndex, offsetBy: 0)\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpx9fzrqzl.swift:17:98: error: 'characters' is unavailable:\
    \ Please use String directly\n        let isStartIndex = string.characters.index(string.startIndex,\
    \ offsetBy: index) == string.characters.index(string.startIndex, offsetBy: 0)\n\
    \                                                                            \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpx9fzrqzl.swift:18:97: error: value of type 'String' has no member\
    \ 'length'\n        let isEndIndex = string.characters.index(string.startIndex,\
    \ offsetBy: index + substring.length) == string.characters.index(string.startIndex,\
    \ offsetBy: string.characters.count - substring.length)\n                    \
    \                                                                  ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpx9fzrqzl.swift:18:197: error: value of type 'St"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let index\
    \ = string.firstIndex(of: substring) else { return 0 }\n    let stringIndex =\
    \ string.distance(from: string.startIndex, to: index)\n    guard let stringRange\
    \ = Range(string.startIndex, stringIndex + substring.length),\n        let stringRangeCount\
    \ = string.distance(from: string.startIndex, to: index + substring.length)\n \
    \       else { return 0 }\n    return stringRangeCount / stringRange.count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpr9p_l80i.swift:10:45: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    guard let\
    \ index = string.firstIndex(of: substring) else { return 0 }\n               \
    \                             ^\n/tmp/tmpr9p_l80i.swift:12:78: error: value of\
    \ type 'String' has no member 'length'\n    guard let stringRange = Range(string.startIndex,\
    \ stringIndex + substring.length),\n                                         \
    \                          ~~~~~~~~~ ^~~~~~\n/tmp/tmpr9p_l80i.swift:13:83: error:\
    \ cannot convert value of type 'String' to expected argument type 'String.Index'\n\
    \        let stringRangeCount = string.distance(from: string.startIndex, to: index\
    \ + substring.length)\n                                                      \
    \                            ^\n/tmp/tmpr9p_l80i.swift:13:95: error: value of\
    \ type 'String' has no member 'length'\n        let stringRangeCount = string.distance(from:\
    \ string.startIndex, to: index + substring.length)\n                         \
    \                                                           ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index1 =\
    \ string.index(of: substring)\n    let index2 = string.index(of: substring, in:\
    \ index1!, offsetBy: 1)\n    let index3 = string.index(of: substring, in: index2!,\
    \ offsetBy: 1)\n    let index4 = string.index(of: substring, in: index3!, offsetBy:\
    \ 1)\n    let index5 = string.index(of: substring, in: index4!, offsetBy: 1)\n\
    \    let index6 = string.index(of: substring, in: index5!, offsetBy: 1)\n    let\
    \ index7 = string.index(of: substring, in: index6!, offsetBy: 1)\n    let index8\
    \ = string.index(of: substring, in: index7!, offsetBy: 1)\n    let index9 = string.index(of:\
    \ substring, in: index8!, offsetBy: 1)\n    let index10 = string.index(of: substring,\
    \ in: index9!, offsetBy: 1)\n    let index11 = string.index(of: substring, in:\
    \ index10!, offsetBy: 1)\n    let index12 = string.index(of: substring, in: index11!,\
    \ offsetBy: 1)\n\n    if index1 != nil {\n        return index1!.advanced(by:\
    \ index2!.advanced(by: index3!.advanced(by: index4!.advanced(by: index5!.advanced(by:\
    \ index6!.advanced(by: index7!.advanced(by: index8!.advanced(by: index9!.advanced(by:\
    \ index10!.advanced(by: index11!.advanced(by: index12!)))))) ))!\n    }\n    if\
    \ index2 != nil {\n        return index2!.advanced(by: index3!.advanced(by: index4!.advanced(by:\
    \ index5!.advanced(by: index6!.advanced(by: index7!.advanced(by: index8!.advanced(by:\
    \ index9!.advanced(by: index10!.advanced(by: index11!)))))) ))!\n    }\n    if\
    \ index3 != nil {\n        return index3!.advanced(by: index4!.advanced(by: index5!.advanced(by:\
    \ index6!.advanced(by: index7!.advanced(by: index8!.advanced(by: index9!.advanced(by:\
    \ index10!.advanced(by: index11!)))))) ))!\n    }\n    if index4 != nil {\n  \
    \      return index4!.advanced(by: index5!.advanced(by: index6!.advanced(by: index7!.advance\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmbzwsy2a.swift:25:5: error: expected ')' in expression list\n \
    \   }\n    ^\n/tmp/tmpmbzwsy2a.swift:24:74: note: to match this opening '('\n\
    \        return index1!.advanced(by: index2!.advanced(by: index3!.advanced(by:\
    \ index4!.advanced(by: index5!.advanced(by: index6!.advanced(by: index7!.advanced(by:\
    \ index8!.advanced(by: index9!.advanced(by: index10!.advanced(by: index11!.advanced(by:\
    \ index12!)))))) ))!\n                                                       \
    \                  ^\n/tmp/tmpmbzwsy2a.swift:28:5: error: expected ')' in expression\
    \ list\n    }\n    ^\n/tmp/tmpmbzwsy2a.swift:27:32: note: to match this opening\
    \ '('\n        return index2!.advanced(by: index3!.advanced(by: index4!.advanced(by:\
    \ index5!.advanced(by: index6!.advanced(by: index7!.advanced(by: index8!.advanced(by:\
    \ index9!.advanced(by: index10!.advanced(by: index11!)))))) ))!\n            \
    \                   ^\n/tmp/tmpmbzwsy2a.swift:34:1: error: expected ')' in expression\
    \ list\n}\n^\n/tmp/tmpmbzwsy2a.swift:33:74: note: to match this opening '('\n\
    \        return index4!.advanced(by: index5!.advanced(by: index6!.advanced(by:\
    \ index7!.advance\n                                                          \
    \               ^\n/tmp/tmpmbzwsy2a.swift:52:67: error: expected '}' at end of\
    \ brace statement\nassert(how_many_times(string: \"john doe\", substring: \"john\"\
    ) == 1)\n                                                                  ^\n\
    /tmp/tmpmbzwsy2a.swift:9:63: note: to match this opening '{'\nfunc how_many_times(string:\
    \ String, substring: String) -> Int {\n                                      \
    \                        ^\n/tmp/tmpmbzwsy2a.swift:10:35: error: cannot convert\
    \ value of type 'String' to expected argument type 'String.Element' (aka 'Character')\n\
    \    let index1 = string.index(of: substring)\n                              \
    \    ^\n/tmp/tmpmbzwsy2a.swift:11:56: error: extra argument 'in' in call\n   \
    \ let index2 = string.index(of: substring, in: index1!, offsetBy: 1)\n       \
    \                      ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpmbzwsy2a.swift:11:35:\
    \ error: c"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ substrings.count\n    for sub in substrings {\n        if string.hasPrefix(sub)\
    \ {\n            count += 1\n        } else if string.hasSuffix(sub) {\n     \
    \       count -= 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyqx0fina.swift:10:17: error: cannot find 'substrings' in scope\n\
    \    var count = substrings.count\n                ^~~~~~~~~~\n/tmp/tmpyqx0fina.swift:11:16:\
    \ error: cannot find 'substrings' in scope\n    for sub in substrings {\n    \
    \           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n\n    for idx in string.characters.indices {\n        if string[idx] != substring[0]\
    \ {\n            continue\n        }\n\n        let idxNext = idx + 1\n\n    \
    \    if idxNext == string.characters.characters.count {\n            return count\
    \ + 1\n        }\n\n        if string[idxNext] != substring[1] {\n           \
    \ count += 0\n            continue\n        }\n\n        count += how_many_times(string[idxNext\
    \ + 1 : string.characters.count], substring)\n    }\n\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3akq3sfs.swift:28:52: error: expected ',' separator\n        count\
    \ += how_many_times(string[idxNext + 1 : string.characters.count], substring)\n\
    \                                                   ^\n                      \
    \                            ,\n/tmp/tmp3akq3sfs.swift:28:52: error: expected\
    \ expression in list of expressions\n        count += how_many_times(string[idxNext\
    \ + 1 : string.characters.count], substring)\n                               \
    \                    ^\n/tmp/tmp3akq3sfs.swift:12:23: error: 'characters' is unavailable:\
    \ Please use String directly\n    for idx in string.characters.indices {\n   \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3akq3sfs.swift:13:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[idx]\
    \ != substring[0] {\n                          ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3akq3sfs.swift:17:23:\
    \ error: cannot convert value of type 'DefaultIndices<String>.Element' (aka 'String.Index')\
    \ to expected argument type 'Int'\n        let idxNext = idx + 1\n           \
    \           ^\n/tmp/tmp3akq3sfs.swift:28:32: error: missing argument labels 'string:substring:'\
    \ in call\n        count += how_many_times(string[idxNext + 1 : string.characters.count],\
    \ substring)\n                               ^\n                             \
    \   string:                                        substring: \n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for idx in 0..<string.characters.count {\n        let startIdx = idx\n\
    \        var substringIdx = idx\n        while substringIdx < string.characters.count\
    \ {\n            if string[substringIdx] != string[substringIdx+1],\n        \
    \       string[substringIdx] == string[startIdx] {\n                substringIdx\
    \ += 1\n            } else {\n                count += 1\n                substringIdx\
    \ += 1 // Keep iterating until we find a character that differs from string[idx]\
    \ and string[idx+1]\n                break\n            }\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpl6l5ubbv.swift:11:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for idx in 0..<string.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpl6l5ubbv.swift:14:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        while substringIdx < string.characters.count {\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpl6l5ubbv.swift:15:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if string[substringIdx] != string[substringIdx+1],\n               ^~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpl6l5ubbv.swift:15:40:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if string[substringIdx] != string[substringIdx+1],\n\
    \                                       ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpl6l5ubbv.swift:16:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n               string[substringIdx] == string[startIdx]\
    \ {\n               ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpl6l5ubbv.swift:16:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \               string[substringIdx] == string[startIdx] {\n                 \
    \                      ^~~~~~~~~~~~~~~~\nSwift.Stri"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring\
    \ {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzq0aitz_.swift:11:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpzq0aitz_.swift:11:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmpzq0aitz_.swift:11:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tvar count = 0\n\
    \tfor idx in 0..<string.characters.count {\n\t\tif string[idx] == substring[0]\
    \ {\n\t\t\tif string[idx] == substring[1] {\n\t\t\t\tif string[idx] == substring[2]\
    \ {\n\t\t\t\t\tcount += 1\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif string[idx] ==\
    \ substring[2] {\n\t\t\t\t\tcount += 2\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7mudjklr.swift:11:24: error: 'characters' is unavailable: Please\
    \ use String directly\n        for idx in 0..<string.characters.count {\n    \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp7mudjklr.swift:12:6: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       if string[idx] == substring[0] {\n                   ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7mudjklr.swift:12:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if string[idx] == substring[0]\
    \ {\n                                  ^~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp7mudjklr.swift:13:7: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n                        if string[idx] == substring[1] {\n       \
    \                    ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp7mudjklr.swift:13:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                        if string[idx] == substring[1] {\n                  \
    \                        ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp7mudjklr.swift:14:8: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                                if string[idx] == substring[2] {\n          \
    \                   "
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    if string == \"\" {\n        return 0\n    }\n\n    if substring == \"\
    \" {\n        return count\n    }\n\n    var start = -1\n    var end = string.utf16Count\n\
    \    end = min(end, string.utf16Count)\n\n    while start < end {\n        if\
    \ string[start] == substring[0] {\n            start = start + substring.length\n\
    \            if start < end && string[start] == substring[0] {\n             \
    \   start = start + substring.length\n                if start < end && string[start]\
    \ == substring[0] {\n                    start = start + substring.length\n  \
    \                  if start < end && string[start] == substring[0] {\n       \
    \                 start = start + substring.length\n                        if\
    \ start < end && string[start] == substring[0] {\n                           \
    \ start = start + substring.length\n                            if start < end\
    \ && string[start] == substring[0] {\n                                count =\
    \ count + 1\n                                start = end - substring.length\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        else {\n          \
    \  start = start+1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsu574sab.swift:20:22: error: value of type 'String' has no member\
    \ 'utf16Count'\n    var end = string.utf16Count\n              ~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpsu574sab.swift:21:27: error: value of type 'String' has no member 'utf16Count'\n\
    \    end = min(end, string.utf16Count)\n                   ~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpsu574sab.swift:24:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[start] ==\
    \ substring[0] {\n           ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpsu574sab.swift:24:29: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[start] == substring[0] {\n                            ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpsu574sab.swift:25:39:\
    \ error: value of type 'String' has no member 'length'\n            start = start\
    \ + substring.length\n                            ~~~~~~~~~ ^~~~~~\n/tmp/tmpsu574sab.swift:27:43:\
    \ error: value of type 'String' has no member 'length'\n                start\
    \ = start + substring.length\n                                ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpsu574sab.swift:29:47: error: value of type 'String' has no member 'length'\n\
    \                    start = start + substring.length\n                      \
    \              ~~~~~~~~~ ^~~~~~\n/tmp/tmpsu574sab.swift:31:51: error: value of\
    \ type 'String' has no member 'length'\n                        start = start\
    \ + substring.length\n                                        ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpsu574sab.swift:33:55: error: value of type 'String' has no member 'length'\n\
    \                            start = start + substring.length\n              \
    \                              ~~~~~~~~~ ^~~~~~\n/tmp/tmpsu574sab.swift:36:45:\
    \ error: cannot assign value of type 'Duration"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for index in 0..<string.characters.count {\n        if string.characters.contains(\"\
    \\(substring)\", at: index) {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1hokou53.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp1hokou53.swift:12:59: error: extra argument 'at' in call\n      \
    \  if string.characters.contains(\"\\(substring)\", at: index) {\n           \
    \                          ~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    var pos = 0\n    while pos < string.characters.count {\n        var start\
    \ = pos\n        while pos + 1 < string.characters.count && string.characters[pos]\
    \ == string.characters[pos + 1] {\n            pos += 1 + 1\n        }\n     \
    \   var end = pos - 1\n        if start < end {\n            if string.substring(with:\
    \ start..<end).contains(substring) {\n                count += 1\n           \
    \ }\n        }\n        pos = end + 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvuxyj_9l.swift:12:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    while pos < string.characters.count {\n           \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpvuxyj_9l.swift:14:32: error: 'characters' is unavailable: Please use String\
    \ directly\n        while pos + 1 < string.characters.count && string.characters[pos]\
    \ == string.characters[pos + 1] {\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvuxyj_9l.swift:14:52:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        while pos + 1 < string.characters.count\
    \ && string.characters[pos] == string.characters[pos + 1] {\n                \
    \                                   ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvuxyj_9l.swift:14:59:\
    \ error: 'characters' is unavailable: Please use String directly\n        while\
    \ pos + 1 < string.characters.count && string.characters[pos] == string.characters[pos\
    \ + 1] {\n                                                          ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvuxyj_9l.swift:14:78:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        while pos + 1 < string.characters.count\
    \ && string.characters[pos] == string.characters[pos + 1] {\n                \
    \                                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvuxyj_9l.swift:14:85:\
    \ er"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_overlapping_cases(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxl_7hiyz.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824884
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.startIndex(of:\
    \ substring) == nil { return 0 }\n    var counter: Int = 0\n    for c in string\
    \ {\n        if c == substring {\n            counter += 1\n        }\n      \
    \  if c == 'a' {\n            counter += 1\n        }\n        if c == 'z' {\n\
    \            counter += 2\n        }\n    }\n    return counter\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph6g2ji51.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == 'a' {\n                ^~~\n                \"a\"\n\
    /tmp/tmph6g2ji51.swift:19:17: error: single-quoted string literal found, use '\"\
    '\n        if c == 'z' {\n                ^~~\n                \"z\"\n/tmp/tmph6g2ji51.swift:10:15:\
    \ error: cannot call value of non-function type 'String.Index'\n    if string.startIndex(of:\
    \ substring) == nil { return 0 }\n              ^\n/tmp/tmph6g2ji51.swift:13:14:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n        if c == substring {\n           ~ ^  ~~~~~~~~~\n/tmp/tmph6g2ji51.swift:13:14:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if c == substring {\n    \
    \         ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    if substring[string.startIndex]\
    \ == \"a\" && substring[string.startIndex+substring.count] == \"a\" {\n      \
    \  return 1\n    }\n\n    if substring[string.startIndex] == string[string.startIndex]\
    \ && substring[string.startIndex+substring.count] == string[string.startIndex+substring.count]\
    \ {\n        return 1 + how_many_times(string: String(string[string.startIndex+substring.count]),\
    \ substring: String(substring[string.startIndex]))\n    }\n\n    if substring[string.startIndex]\
    \ == string[string.startIndex] && substring[string.startIndex+substring.count+1]\
    \ == string[string.startIndex+substring.count+1] {\n        return 1 + how_many_times(string:\
    \ String(string[string.startIndex+substring.count+2]), substring: String(substring[string.startIndex+substring.count]))\n\
    \    }\n\n    if substring[string.startIndex] == string[string.startIndex] &&\
    \ substring[string.startIndex+substring.count-1] == string[string.startIndex+substring.count-1]\
    \ {\n        return 1 + how_many_times(string: String(string[string.startIndex+substring.count-2]),\
    \ substring: String(substring[string.startIndex+substring.count]))\n    }\n\n\
    \    if substring[string.startIndex] == string[string.startIndex] && substring[string.startIndex+substring.count]\
    \ == string[string.startIndex+substring.count] {\n        return 1 + how_many_times(string:\
    \ String(string[string.startIndex+substring.count]), substring: String(substring[string.startIndex+substring.count]))\n\
    \    }\n\n    if substring[string.startIndex] == string[string.startIndex] &&\
    \ substring[string.startIndex+substring.count+1] == string[string.startIndex+substring.count+1]\
    \ {\n        return 1 + how_many_times(string: String(string[string.startIndex+substring.count+2]),\
    \ substring: String(substring[string.startIndex+substring.count]))\n    }\n\n\
    \    if substring[string.startIndex] == string[string.startIndex] && substring[string.startIndex+substring.count-1]\
    \ == string[string.startIndex+substring.count-1] {\n        return 1 + how_many_times(string:\
    \ String(string[string.startIndex+substring.count-2]), substring: String(substring[string.startIndex+substring.count]))\n\
    \    }\n\n    if substring[string.startIndex] == string[string.startIndex] &&\
    \ substring[string.startIndex+substring.count] == string[string.startIndex+substring.count]\
    \ {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphi9_w2er.swift:61:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmphi9_w2er.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmphi9_w2er.swift:14:64: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    if substring[string.startIndex] == \"a\"\
    \ && substring[string.startIndex+substring.count] == \"a\" {\n               \
    \                                                ^\n/tmp/tmphi9_w2er.swift:18:86:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n    if substring[string.startIndex] == string[string.startIndex] && substring[string.startIndex+substring.count]\
    \ == string[string.startIndex+substring.count] {\n                           \
    \                                                          ^\n/tmp/tmphi9_w2er.swift:18:131:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n    if substring[string.startIndex] == string[string.startIndex] && substring[string.startIndex+substring.count]\
    \ == string[string.startIndex+substring.count] {\n                           \
    \                                                                            \
    \                           ^\n/tmp/tmphi9_w2er.swift:19:64: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n        return\
    \ 1 + how_many_times(string: String(string[string.startIndex+substring.count]),\
    \ substring: String(substring[string.startIndex]))\n                         \
    \                                      ^\n/tmp/tmphi9_w2er.swift:22:86: error:\
    \ cannot convert value of type 'String.Index' to expected argument type 'Int'\n\
    \    if substring[string.startIndex] == string[string.startIndex] && substring[string.startIndex+substring.count+1]\
    \ == string[string.startIndex+substring.count+1] {\n       "
  stdout: ''
  timestamp: 1660009356
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string\n\
    \        .characters\n        .filter { string[$0] == substring[$0] }\n      \
    \  .count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjuw9nkb4.swift:12:26: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String.Index'\n        .filter\
    \ { string[$0] == substring[$0] }\n                         ^\n/tmp/tmpjuw9nkb4.swift:12:43:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String.Index'\n        .filter { string[$0] == substring[$0]\
    \ }\n                                          ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n\n    if substring == \"\" {\n        return\
    \ count(string)\n    }\n\n    let start = find(string, substring)\n    let end\
    \ = find(string, substring, start: start+1)\n\n    if end == nil {\n        return\
    \ 0\n    }\n\n    return end - start\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc3bkikfo.swift:15:16: error: cannot find 'count' in scope\n   \
    \     return count(string)\n               ^~~~~\n/tmp/tmpc3bkikfo.swift:18:17:\
    \ error: cannot find 'find' in scope\n    let start = find(string, substring)\n\
    \                ^~~~\n/tmp/tmpc3bkikfo.swift:19:15: error: cannot find 'find'\
    \ in scope\n    let end = find(string, substring, start: start+1)\n          \
    \    ^~~~\n/tmp/tmpc3bkikfo.swift:25:16: error: cannot convert return expression\
    \ of type 'Duration' to return type 'Int'\n    return end - start\n          \
    \ ~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.contains(substring)\
    \ == true {\n        return string.characters.indexOf(substring, from: string.startIndex,\
    \ effectiveRange: nil) ?? 0\n    } else {\n        return 0\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprtqkaxvy.swift:11:34: error: value of type 'String' has no member\
    \ 'indexOf'\n        return string.characters.indexOf(substring, from: string.startIndex,\
    \ effectiveRange: nil) ?? 0\n               ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmprtqkaxvy.swift:11:94:\
    \ error: 'nil' requires a contextual type\n        return string.characters.indexOf(substring,\
    \ from: string.startIndex, effectiveRange: nil) ?? 0\n                       \
    \                                                                      ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let index\
    \ = string.range(of: substring) else {\n        return 0\n    }\n    guard let\
    \ endIndex = string.range(of: substring, options: .backwards) else {\n       \
    \ return 0\n    }\n    let range = index...endIndex\n    return range.count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd0er0rvf.swift:10:30: error: value of type 'String' has no member\
    \ 'range'\n    guard let index = string.range(of: substring) else {\n        \
    \              ~~~~~~ ^~~~~\n/tmp/tmpd0er0rvf.swift:13:33: error: value of type\
    \ 'String' has no member 'range'\n    guard let endIndex = string.range(of: substring,\
    \ options: .backwards) else {\n                         ~~~~~~ ^~~~~\n/tmp/tmpd0er0rvf.swift:13:64:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \ guard let endIndex = string.range(of: substring, options: .backwards) else {\n\
    \                                                              ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif substring ==\
    \ \"\" {\n\t\treturn 0\n\t}\n\tlet firstIndex = string.startIndex.advancedBy(0,\
    \ offset)\n\tlet lastIndex = string.endIndex.advancedBy(0, offset)\n\tlet indexAfterSubstring\
    \ = string.index(after: firstIndex, offsetBy: substring.count)\n\tlet lastFound\
    \ = string.rangeOfString(substring)\n\tlet firstFound = string.rangeOfString(substring,\
    \ options: .backwards)\n\tif firstFound == nil && lastFound == nil {\n\t\treturn\
    \ 0\n\t}\n\tguard let foundIndex = firstFound else { return 0 }\n\tguard let lastIndex\
    \ = lastFound else { return 0 }\n\tif indexAfterSubstring < lastIndex {\n\t\t\
    return 0\n\t}\n\tlet subStringLength = substring.count\n\tlet subStringRange =\
    \ string.rangeOfString(substring, options: .CaseInsensitive)\n\tif subStringRange\
    \ == nil {\n\t\treturn 0\n\t}\n\tlet substringRange = string.rangeOfString(substring,\
    \ options: .Backwards)\n\tif substringRange == nil {\n\t\treturn 0\n\t}\n\tguard\
    \ substringRange.lowerBound < subStringRange.lowerBound else { return 0 }\n\t\
    guard substringRange.upperBound > lastIndex && substringRange.upperBound > subStringRange.upperBound\
    \ else { return 0 }\n\treturn substringRange.upperBound - substringRange.lowerBound\
    \ + subStringLength - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphyjtvowa.swift:13:51: error: cannot find 'offset' in scope\n  \
    \      let firstIndex = string.startIndex.advancedBy(0, offset)\n            \
    \                                             ^~~~~~\n/tmp/tmphyjtvowa.swift:13:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ firstIndex = string.startIndex.advancedBy(0, offset)\n                     \
    \    ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmphyjtvowa.swift:14:48: error: cannot\
    \ find 'offset' in scope\n        let lastIndex = string.endIndex.advancedBy(0,\
    \ offset)\n                                                      ^~~~~~\n/tmp/tmphyjtvowa.swift:14:34:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ lastIndex = string.endIndex.advancedBy(0, offset)\n                        ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmphyjtvowa.swift:15:35: error: no exact matches in call to\
    \ instance method 'index'\n        let indexAfterSubstring = string.index(after:\
    \ firstIndex, offsetBy: substring.count)\n                                   \
    \      ^\n/tmp/tmphyjtvowa.swift:15:35: note: found candidate with type '(String.Index,\
    \ Int) -> String.Index'\n        let indexAfterSubstring = string.index(after:\
    \ firstIndex, offsetBy: substring.count)\n                                   \
    \      ^\n/tmp/tmphyjtvowa.swift:16:25: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let lastFound = string.rangeOfString(substring)\n \
    \                       ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmphyjtvowa.swift:17:26: error:\
    \ value of type 'String' has no member 'rangeOfString'\n        let firstFound\
    \ = string.rangeOfString(substring, options: .backwards)\n                   \
    \      ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmphyjtvowa.swift:17:61: error: cannot infer\
    \ contextual base in reference to member 'backwards'\n        let firstFound =\
    \ string.rangeOfString(substring, options: .backwards)\n                     \
    \                                             ~^~~~~~~~~\n/tmp/tmphyjtvowa.swift:27:30:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let subStringRange\
    \ = str"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let substrings\
    \ = string.components(separatedBy: substring) else {\n        return 0\n    }\n\
    \    return substrings.count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvbaw52s3.swift:10:35: error: value of type 'String' has no member\
    \ 'components'\n    guard let substrings = string.components(separatedBy: substring)\
    \ else {\n                           ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return strings.Count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptbctwow5.swift:10:12: error: cannot find 'strings' in scope\n \
    \   return strings.Count(string, substring)\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.isEmpty\
    \ {\n        return 0\n    }\n    if string.rangeOfString(substring).count ==\
    \ 0 {\n        return 0\n    }\n    let index = string.rangeOfString(substring).lowerBound\n\
    \    var count = 0\n    var start = index\n    var end = string.count\n    while\
    \ index != end && start != end {\n        start = index\n        end = string.rangeOfString(substring,\
    \ range: NSRange(location: start + 1, length: substring.length)).lowerBound\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbiavst42.swift:13:15: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    if string.rangeOfString(substring).count == 0 {\n     \
    \  ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpbiavst42.swift:16:24: error: value of type 'String'\
    \ has no member 'rangeOfString'\n    let index = string.rangeOfString(substring).lowerBound\n\
    \                ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpbiavst42.swift:22:54: error: cannot\
    \ find 'NSRange' in scope\n        end = string.rangeOfString(substring, range:\
    \ NSRange(location: start + 1, length: substring.length)).lowerBound\n       \
    \                                              ^~~~~~~\n/tmp/tmpbiavst42.swift:22:22:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        end = string.rangeOfString(substring,\
    \ range: NSRange(location: start + 1, length: substring.length)).lowerBound\n\
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpbiavst42.swift:22:101: error: value\
    \ of type 'String' has no member 'length'\n        end = string.rangeOfString(substring,\
    \ range: NSRange(location: start + 1, length: substring.length)).lowerBound\n\
    \                                                                            \
    \              ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count(string,\
    \ substring, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgc72l5ye.swift:10:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring, true)\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tlet index1 = string.index(of:\
    \ substring)\n\tlet index2 = string.index(of: substring, offsetBy: index1)\n\t\
    guard index1 != nil, index2 != nil else { return 0 }\n\treturn index2! - index1!\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcg58vl4t.swift:10:32: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n        let index1\
    \ = string.index(of: substring)\n                                      ^\n/tmp/tmpcg58vl4t.swift:11:22:\
    \ error: no exact matches in call to instance method 'index'\n        let index2\
    \ = string.index(of: substring, offsetBy: index1)\n                          \
    \  ^\n/tmp/tmpcg58vl4t.swift:11:22: note: found candidate with type '(String.Index,\
    \ Int) -> String.Index'\n        let index2 = string.index(of: substring, offsetBy:\
    \ index1)\n                            ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.countSubstring(substring:\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpt8og7f0i.swift:10:19: error: value of type 'String' has no member\
    \ 'countSubstring'\n    return string.countSubstring(substring: substring)\n \
    \          ~~~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn strings.Count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkg0vfawt.swift:10:9: error: cannot find 'strings' in scope\n  \
    \      return strings.Count(string, substring)\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // TODO: Optimize\
    \ using str.Contains method or regular expressions\n    var count = 0\n    for\
    \ index in 0..<string.characters.count {\n        if string[index] != substring[0]\
    \ {\n            continue\n        }\n        for index2 in 1..<string.characters.count\
    \ {\n            if string[index] == substring[index2] && index < index2 {\n \
    \               count += 1\n                break\n            }\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6y1lof25.swift:12:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp6y1lof25.swift:13:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[index]\
    \ != substring[0] {\n           ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6y1lof25.swift:13:29: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[index] != substring[0] {\n                            ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6y1lof25.swift:16:34:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ index2 in 1..<string.characters.count {\n                                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6y1lof25.swift:17:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if string[index] == substring[index2]\
    \ && index < index2 {\n               ^~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp6y1lof25.swift:17:33: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            if string[index] == substring[index2] && index < index2\
    \ {\n                                ^~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unava"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let count =\
    \ string.characters.reduce(0) { (sum, ch) -> (Int, Character) in\n        if let\
    \ index = string.firstIndex(of: ch) {\n            let substring_index = substring.firstIndex(of:\
    \ ch)\n            if substring_index < 0 {\n                return (sum, ch)\n\
    \            } else if substring_index == index {\n                let substring\
    \ = substring[..<substring_index!]\n                if let index = string.range(of:\
    \ substring) {\n                    return (sum + index.count, substring)\n  \
    \              } else {\n                    return (sum, ch)\n              \
    \  }\n            } else {\n                let substring = substring[..<substring_index!]\n\
    \                if let index = string.range(of: substring) {\n              \
    \      return (sum + index.count, substring)\n                } else {\n     \
    \               return (sum, ch)\n                }\n            }\n        }\
    \ else {\n            return sum\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpewbakls6.swift:10:42: error: cannot convert value of type 'Int'\
    \ to expected argument type '(Int, Character)'\n    let count = string.characters.reduce(0)\
    \ { (sum, ch) -> (Int, Character) in\n                                       \
    \  ^\n/tmp/tmpewbakls6.swift:13:16: error: cannot convert value of type 'String.Index?'\
    \ to expected argument type 'Int'\n            if substring_index < 0 {\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    if let string =\
    \ string.lowercaseString.rangeOfString(substring) {\n        // `substring` exists\
    \ in the original string\n        let start_index = string.startIndex\n      \
    \  let end_index = string.startIndex + string.length - substring.length\n    \
    \    let count = end_index - start_index + 1\n        return count\n    }\n\n\
    \    // `substring` does not exist in the original string\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpygcxbkk8.swift:14:28: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    if let string = string.lowercaseString.rangeOfString(substring)\
    \ {\n                    ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpygcxbkk8.swift:17:71:\
    \ error: value of type 'String' has no member 'length'\n        let end_index\
    \ = string.startIndex + string.length - substring.length\n                   \
    \                                         ~~~~~~~~~ ^~~~~~\n/tmp/tmpygcxbkk8.swift:18:45:\
    \ error: binary operator '+' cannot be applied to operands of type 'Duration'\
    \ and 'Int'\n        let count = end_index - start_index + 1\n               \
    \     ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n/tmp/tmpygcxbkk8.swift:18:45: note: overloads\
    \ for '+' exist with these partially matching parameter lists: (Duration, Duration),\
    \ (Int, Int)\n        let count = end_index - start_index + 1\n              \
    \                              ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let index\
    \ = string.index(of: substring) else { return 0 }\n    var count = 0\n    repeat\
    \ {\n        count += 1\n        index = string.index(index, offsetBy: 1)\n  \
    \  } while (index != string.endIndex)\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzwijsxnx.swift:10:40: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    guard let\
    \ index = string.index(of: substring) else { return 0 }\n                    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n    let startIndex: Int = string.startIndex.distanceTo(string.startIndex,\
    \ from: substring.startIndex)\n    let endIndex: Int = string.startIndex.distanceTo(string.startIndex,\
    \ from: substring.startIndex, to: string.endIndex)\n\n    return endIndex - startIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprqeetmmv.swift:13:45: error: value of type 'String.Index' has no\
    \ member 'distanceTo'\n    let startIndex: Int = string.startIndex.distanceTo(string.startIndex,\
    \ from: substring.startIndex)\n                          ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmprqeetmmv.swift:14:43: error: value of type 'String.Index' has no member\
    \ 'distanceTo'\n    let endIndex: Int = string.startIndex.distanceTo(string.startIndex,\
    \ from: substring.startIndex, to: string.endIndex)\n                        ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    var count = 0\n    var start = string.startIndex\n\
    \    var end = string.endIndex\n    while start != end {\n        start = string.index(after:\
    \ start)\n        if let index = string.distance(from: start, to: end, options:\
    \ .searchBackwards) {\n            if string.substring(from: index) == substring\
    \ {\n                count += 1\n                start = index\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpi2b28tmx.swift:18:72: error: extra argument 'options' in call\n\
    \        if let index = string.distance(from: start, to: end, options: .searchBackwards)\
    \ {\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n\
    /tmp/tmpi2b28tmx.swift:18:72: error: cannot infer contextual base in reference\
    \ to member 'searchBackwards'\n        if let index = string.distance(from: start,\
    \ to: end, options: .searchBackwards) {\n                                    \
    \                                  ~^~~~~~~~~~~~~~~\n/tmp/tmpi2b28tmx.swift:19:23:\
    \ error: value of type 'String' has no member 'substring'\n            if string.substring(from:\
    \ index) == substring {\n               ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var total =\
    \ 0\n    for c in string.unicodeScalars {\n        if c == substring {\n     \
    \       total += 1\n        } else if string.unicodeScalars.isSuperset(of: substring)\
    \ {\n            total += 2\n        }\n    }\n    return total\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuota9_vz.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n/tmp/tmpuota9_vz.swift:14:41:\
    \ error: value of type 'String.UnicodeScalarView' has no member 'isSuperset'\n\
    \        } else if string.unicodeScalars.isSuperset(of: substring) {\n       \
    \           ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif string == \"\
    \" {\n\t\treturn 0\n\t}\n\tvar count = 0\n\tswitch {\n\tcase substring != \"\"\
    \ && substring[0] < string[0]:\n\t\tfor i := 0; i < len(string); i++ {\n\t\t\t\
    if string[i] == substring[0] {\n\t\t\t\tcount += 1\n\t\t\t\tif substring[1:] ==\
    \ string[i:i+len(substring)] {\n\t\t\t\t\treturn count\n\t\t\t\t}\n\t\t\t}\n\t\
    \t}\n\tcase substring == \"\":\n\t\treturn len(string)\n\tcase substring[0] <\
    \ string[0]:\n\t\treturn 0\n\tdefault:\n\t\tfor i := 0; i < len(string); i++ {\n\
    \t\t\tif string[i] == substring[0] {\n\t\t\t\tcount += 1\n\t\t\t\tif i+len(substring)-1\
    \ < len(string) {\n\t\t\t\t\tif string[i+len(substring)-1] == substring[len(substring)-1]\
    \ {\n\t\t\t\t\t\treturn count\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\
    \ 0\n\t}\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphyxdap6u.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmphyxdap6u.swift:16:10: error: expected\
    \ type\n                for i := 0; i < len(string); i++ {\n                 \
    \      ^\n                        <#type#>\n/tmp/tmphyxdap6u.swift:16:10: error:\
    \ expected 'in' after for-each pattern\n                for i := 0; i < len(string);\
    \ i++ {\n                       ^\n/tmp/tmphyxdap6u.swift:16:10: error: expected\
    \ Sequence expression for for-each loop\n                for i := 0; i < len(string);\
    \ i++ {\n                       ^\n/tmp/tmphyxdap6u.swift:19:19: error: expected\
    \ ',' separator\n                                if substring[1:] == string[i:i+len(substring)]\
    \ {\n                                              ^\n                       \
    \                       ,\n/tmp/tmphyxdap6u.swift:19:19: error: expected expression\
    \ in list of expressions\n                                if substring[1:] ==\
    \ string[i:i+len(substring)] {\n                                             \
    \ ^\n/tmp/tmphyxdap6u.swift:29:10: error: expected type\n                for i\
    \ := 0; i < len(string); i++ {\n                       ^\n                   \
    \     <#type#>\n/tmp/tmphyxdap6u.swift:29:10: error: expected 'in' after for-each\
    \ pattern\n                for i := 0; i < len(string); i++ {\n              \
    \         ^\n/tmp/tmphyxdap6u.swift:29:10: error: expected Sequence expression\
    \ for for-each loop\n                for i := 0; i < len(string); i++ {\n    \
    \                   ^\n/tmp/tmphyxdap6u.swift:25:10: error: cannot find 'len'\
    \ in scope\n                return len(string)\n                       ^~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.countSubstring(substring)\
    \ == 0 {\n        return 0\n    }\n    var count = 0\n    for start in 0..<string.countSubstring(substring)\
    \ {\n        let end = min(string.countSubstring(substring), start+string.countSubstring(substring)-1)\n\
    \        for end in start..<end {\n            count += string.countSubstring(substring[start..<end])\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpv3z45nnt.swift:10:15: error: value of type 'String' has no member\
    \ 'countSubstring'\n    if string.countSubstring(substring) == 0 {\n       ~~~~~~\
    \ ^~~~~~~~~~~~~~\n/tmp/tmpv3z45nnt.swift:14:29: error: value of type 'String'\
    \ has no member 'countSubstring'\n    for start in 0..<string.countSubstring(substring)\
    \ {\n                     ~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpv3z45nnt.swift:15:30:\
    \ error: value of type 'String' has no member 'countSubstring'\n        let end\
    \ = min(string.countSubstring(substring), start+string.countSubstring(substring)-1)\n\
    \                      ~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpv3z45nnt.swift:15:70: error:\
    \ value of type 'String' has no member 'countSubstring'\n        let end = min(string.countSubstring(substring),\
    \ start+string.countSubstring(substring)-1)\n                                \
    \                              ~~~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var result =\
    \ 0\n    var position = 0\n    for i := 0; i < len(string); i++ {\n        for\
    \ j := i; j < len(string); j++ {\n            if string[i] == substring[0] {\n\
    \                for k := 1; k < len(substring); k++ {\n                    position\
    \ = j\n                    j = strings.Index(string[j+k:], substring)\n      \
    \              if j == -1 {\n                        break\n                 \
    \   }\n                    result = result + (j - position)\n                }\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3ffh9372.swift:12:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3ffh9372.swift:12:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmp3ffh9372.swift:12:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmp3ffh9372.swift:13:16: error: expected type\n        for j :=\
    \ i; j < len(string); j++ {\n               ^\n                <#type#>\n/tmp/tmp3ffh9372.swift:13:16:\
    \ error: expected 'in' after for-each pattern\n        for j := i; j < len(string);\
    \ j++ {\n               ^\n/tmp/tmp3ffh9372.swift:13:16: error: expected Sequence\
    \ expression for for-each loop\n        for j := i; j < len(string); j++ {\n \
    \              ^\n/tmp/tmp3ffh9372.swift:15:24: error: expected type\n       \
    \         for k := 1; k < len(substring); k++ {\n                       ^\n  \
    \                      <#type#>\n/tmp/tmp3ffh9372.swift:15:24: error: expected\
    \ 'in' after for-each pattern\n                for k := 1; k < len(substring);\
    \ k++ {\n                       ^\n/tmp/tmp3ffh9372.swift:15:24: error: expected\
    \ Sequence expression for for-each loop\n                for k := 1; k < len(substring);\
    \ k++ {\n                       ^\n/tmp/tmp3ffh9372.swift:17:49: error: expected\
    \ ',' separator\n                    j = strings.Index(string[j+k:], substring)\n\
    \                                                ^\n                         \
    \                       ,\n/tmp/tmp3ffh9372.swift:17:49: error: expected expression\
    \ in list of expressions\n                    j = strings.Index(string[j+k:],\
    \ substring)\n                                                ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.utf8.countIndex(of:\
    \ substring, options: .noSearch)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpnu9yp288.swift:10:24: error: value of type 'String.UTF8View' has\
    \ no member 'countIndex'\n    return string.utf8.countIndex(of: substring, options:\
    \ .noSearch)\n           ~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpnu9yp288.swift:10:60:\
    \ error: cannot infer contextual base in reference to member 'noSearch'\n    return\
    \ string.utf8.countIndex(of: substring, options: .noSearch)\n                \
    \                                          ~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard !string.isEmpty\
    \ else { return 0 }\n    guard !substring.isEmpty else { return 0 }\n    \n  \
    \  var count = 0\n    var start = string.startIndex\n    var end = string.endIndex\n\
    \    while start < end {\n        guard start < end else { return 0 }\n      \
    \  guard let index = string.index(of: substring, range: start..<end) else {\n\
    \            return count\n        }\n        \n        count += 1\n        start\
    \ = index\n        end = index\n    }\n    \n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpnuj088wq.swift:18:67: error: extra argument 'range' in call\n \
    \       guard let index = string.index(of: substring, range: start..<end) else\
    \ {\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpnuj088wq.swift:18:44: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n        guard let\
    \ index = string.index(of: substring, range: start..<end) else {\n           \
    \                                ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.characters.count\
    \ < substring.length {\n        return 0\n    }\n    var count = 1\n    for index\
    \ in 0..<string.characters.count {\n        if string.substring(from: index).lowercased()\
    \ == substring.lowercased() {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpuvrho4z7.swift:10:44: error: value of type 'String' has no member\
    \ 'length'\n    if string.characters.count < substring.length {\n            \
    \                     ~~~~~~~~~ ^~~~~~\n/tmp/tmpuvrho4z7.swift:14:29: error: 'characters'\
    \ is unavailable: Please use String directly\n    for index in 0..<string.characters.count\
    \ {\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpuvrho4z7.swift:15:19: error: value of type 'String'\
    \ has no member 'substring'\n        if string.substring(from: index).lowercased()\
    \ == substring.lowercased() {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: -4
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // TODO: implement\
    \ me\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: Exception
  stderr: 'tmp8tq7twi3/tmp8tq7twi3.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11d99e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11d96e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11d96e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11d96df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8tq7twi3                        0x000055ea707b4372 <unavailable> + 4978

    5    libc.so.6                          0x00002b11d9bd5460 __libc_start_main +
    245

    6    tmp8tq7twi3                        0x000055ea707b3ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let string\
    \ = string.lowercased() else {\n        return 0;\n    }\n    guard let substring\
    \ = substring.lowercased() else {\n        return 0;\n    }\n\n    var count =\
    \ 0\n    var startIndex = 0\n    var endIndex = string.count\n    while startIndex\
    \ < endIndex {\n        let index = string.lowercased().firstIndex(of: substring)!\n\
    \        if index == startIndex {\n            count += 1\n            startIndex\
    \ = index + 1\n        }\n        else {\n            count = 0\n            startIndex\
    \ = index\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjq4g3ga9.swift:10:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let string = string.lowercased()\
    \ else {\n          ^            ~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjq4g3ga9.swift:13:11:\
    \ error: initializer for conditional binding must have Optional type, not 'String'\n\
    \    guard let substring = substring.lowercased() else {\n          ^        \
    \       ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjq4g3ga9.swift:21:56: error: cannot convert\
    \ value of type 'String' to expected argument type 'String.Element' (aka 'Character')\n\
    \        let index = string.lowercased().firstIndex(of: substring)!\n        \
    \                                               ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substrings(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjp8o7ff7.swift:10:12: error: cannot find 'count_substrings' in\
    \ scope\n    return count_substrings(string, substring)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard substring.characters.count\
    \ == string.characters.count else {\n        return 0\n    }\n    guard let _\
    \ = string.range(of: substring) else {\n        return 0\n    }\n    let index\
    \ = string.index(before: string.index(string.startIndex, offsetBy: substring.characters.count))\n\
    \    return index - string.startIndex\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpahhh98u6.swift:10:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard substring.characters.count == string.characters.count\
    \ else {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpahhh98u6.swift:10:48: error: 'characters' is unavailable:\
    \ Please use String directly\n    guard substring.characters.count == string.characters.count\
    \ else {\n                                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpahhh98u6.swift:13:26: error: value of\
    \ type 'String' has no member 'range'\n    guard let _ = string.range(of: substring)\
    \ else {\n                  ~~~~~~ ^~~~~\n/tmp/tmpahhh98u6.swift:16:90: error:\
    \ 'characters' is unavailable: Please use String directly\n    let index = string.index(before:\
    \ string.index(string.startIndex, offsetBy: substring.characters.count))\n   \
    \                                                                            \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpahhh98u6.swift:17:18: error: referencing operator function '-' on 'Strideable'\
    \ requires that 'String.Index' conform to '_Pointer'\n    return index - string.startIndex\n\
    \                 ^\nSwift.Strideable:1:11: note: where 'Self' = 'String.Index'\n\
    extension Strideable where Self : _Pointer {\n          ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn string.count(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp3k84nf_m.swift:10:16: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring)\n                      ^\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.lowercased().range(of: substring.lowercased())\n    let start_index =\
    \ index!.lowerBound\n    let end_index = start_index + substring.length\n    return\
    \ end_index - start_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzrc2_rhi.swift:10:37: error: value of type 'String' has no member\
    \ 'range'\n    let index = string.lowercased().range(of: substring.lowercased())\n\
    \                ~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpzrc2_rhi.swift:12:45: error:\
    \ value of type 'String' has no member 'length'\n    let end_index = start_index\
    \ + substring.length\n                                  ~~~~~~~~~ ^~~~~~\n/tmp/tmpzrc2_rhi.swift:13:22:\
    \ error: cannot convert return expression of type 'Duration' to return type 'Int'\n\
    \    return end_index - start_index\n           ~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif let index =\
    \ string.range(of: substring) {\n\t\treturn 1 + count(string.index(index, offsetBy:\
    \ 0), string.index(index, offsetBy: substring.count))\n\t}\n\treturn 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9fnc9yk0.swift:10:24: error: value of type 'String' has no member\
    \ 'range'\n        if let index = string.range(of: substring) {\n            \
    \           ~~~~~~ ^~~~~\n/tmp/tmp9fnc9yk0.swift:11:14: error: cannot find 'count'\
    \ in scope\n                return 1 + count(string.index(index, offsetBy: 0),\
    \ string.index(index, offsetBy: substring.count))\n                          \
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ substring {\n        return string.count\n    }\n    var count = 0\n    let\
    \ start = string.startIndex\n    let end = string.endIndex\n    let sStart = string.index(start,\
    \ offsetBy: substring.startIndex)\n    let eStart = string.index(start, offsetBy:\
    \ substring.endIndex)\n    let sEnd = string.index(end, offsetBy: substring.startIndex)\n\
    \    let eEnd = string.index(end, offsetBy: substring.endIndex)\n\n    var stringRange\
    \ = string.substringWithRange(Range<String.Index>(start: sStart, end: eStart))\n\
    \    while stringRange != nil {\n        if stringRange.contains(substring) {\n\
    \            count += 1\n        }\n        stringRange = string.substringWithRange(Range<String.Index>(start:\
    \ sEnd, end: eEnd))\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpr4cla3wc.swift:16:18: error: instance method 'index(_:offsetBy:)'\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n    let sStart = string.index(start,\
    \ offsetBy: substring.startIndex)\n                 ^\nSwift.Collection:3:17:\
    \ note: where 'T' = 'String.Index'\n    public func index<T>(_ i: Self.Index,\
    \ offsetBy n: T) -> Self.Index where T : BinaryInteger\n                ^\n/tmp/tmpr4cla3wc.swift:17:18:\
    \ error: instance method 'index(_:offsetBy:)' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n    let eStart = string.index(start, offsetBy: substring.endIndex)\n\
    \                 ^\nSwift.Collection:3:17: note: where 'T' = 'String.Index'\n\
    \    public func index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where\
    \ T : BinaryInteger\n                ^\n/tmp/tmpr4cla3wc.swift:18:16: error: instance\
    \ method 'index(_:offsetBy:)' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    let sEnd = string.index(end, offsetBy: substring.startIndex)\n          \
    \     ^\nSwift.Collection:3:17: note: where 'T' = 'String.Index'\n    public func\
    \ index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where T : BinaryInteger\n\
    \                ^\n/tmp/tmpr4cla3wc.swift:19:16: error: instance method 'index(_:offsetBy:)'\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n    let eEnd = string.index(end,\
    \ offsetBy: substring.endIndex)\n               ^\nSwift.Collection:3:17: note:\
    \ where 'T' = 'String.Index'\n    public func index<T>(_ i: Self.Index, offsetBy\
    \ n: T) -> Self.Index where T : BinaryInteger\n                ^\n/tmp/tmpr4cla3wc.swift:21:30:\
    \ error: value of type 'String' has no member 'substringWithRange'\n    var stringRange\
    \ = string.substringWithRange(Range<String.Index>(start: sStart, end: eStart))\n\
    \                      ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpr4cla3wc.swift:21:49:\
    \ error: referencing initializer 'init(_:)' on 'Range' requires that 'String.Index'\
    \ conform to 'Strideable'\n    var stringRange = string.substringWithRange(Range<String.Index>(start:\
    \ sStart, end: eStart))\n                                           "
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    if string.hasSuffix(substring)\
    \ {\n        return string.count(substring) + string.count(substring).incr(substring)\n\
    \    } else {\n        return string.count(substring) + how_many_times(string,\
    \ substring)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkut_bkgw.swift:14:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring) + string.count(substring).incr(substring)\n\
    \                      ^\n/tmp/tmpkut_bkgw.swift:14:49: error: cannot call value\
    \ of non-function type 'Int'\n        return string.count(substring) + string.count(substring).incr(substring)\n\
    \                                                ^\n/tmp/tmpkut_bkgw.swift:16:23:\
    \ error: cannot call value of non-function type 'Int'\n        return string.count(substring)\
    \ + how_many_times(string, substring)\n                      ^\n/tmp/tmpkut_bkgw.swift:16:56:\
    \ error: missing argument labels 'string:substring:' in call\n        return string.count(substring)\
    \ + how_many_times(string, substring)\n                                      \
    \                 ^\n                                                        string:\
    \ substring: \n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // Create a\
    \ map of substrings to counts\n    var substrings = Dictionary<String, Int>()\n\
    \    for i in string.characters.indices {\n        let index = string.index(i,\
    \ offsetBy: substring.characters.count)\n        if string.startIndex < index\
    \ {\n            substrings[substring] = substrings[substring] + 1\n        }\
    \ else {\n            substrings[substring] = 1\n        }\n    }\n    // Return\
    \ the count of substrings\n    return substrings.values.reduce(0, +)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpr7uik3vi.swift:12:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in string.characters.indices {\n            \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpr7uik3vi.swift:13:57:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ index = string.index(i, offsetBy: substring.characters.count)\n            \
    \                                            ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpr7uik3vi.swift:15:47: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n            substrings[substring]\
    \ = substrings[substring] + 1\n                                              ^\n\
    /tmp/tmpr7uik3vi.swift:15:47: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n            substrings[substring] = substrings[substring]\
    \ + 1\n                                              ^\n                     \
    \               (                     ?? <#default value#>)\n/tmp/tmpr7uik3vi.swift:15:47:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            substrings[substring] = substrings[substring] + 1\n     \
    \                                         ^\n                                \
    \                         !\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index1 =\
    \ string.indexOf(substring)\n    if index1 == -1 {\n        return 0\n    }\n\
    \    let index2 = string.index(index1 + substring.length, offsetBy: 1)\n    if\
    \ index2 == -1 {\n        return 0\n    }\n    return string.distance(from: string.startIndex,\
    \ to: index2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjq_5prx0.swift:10:25: error: value of type 'String' has no member\
    \ 'indexOf'\n    let index1 = string.indexOf(substring)\n                 ~~~~~~\
    \ ^~~~~~~\n/tmp/tmpjq_5prx0.swift:14:38: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Index'\n    let index2 = string.index(index1\
    \ + substring.length, offsetBy: 1)\n                                     ^\n/tmp/tmpjq_5prx0.swift:14:50:\
    \ error: value of type 'String' has no member 'length'\n    let index2 = string.index(index1\
    \ + substring.length, offsetBy: 1)\n                                       ~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn countOccurrences(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprzpez59u.swift:10:9: error: cannot find 'countOccurrences' in scope\n\
    \        return countOccurrences(string, substring)\n               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009309
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard string.hasSuffix(substring)\
    \ && string.hasPrefix(substring) else {\n        return -1\n    }\n\n    let index\
    \ = string.firstIndex(of: substring)\n    guard index != nil else { return 0 }\n\
    \n    let length = (string.index(string.startIndex, offsetBy: index!) + string.index(string.startIndex,\
    \ offsetBy: index + substring.length)) - string.index(string.startIndex, offsetBy:\
    \ index)\n    return max(length, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbxqwu99m.swift:14:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n\
    /tmp/tmpbxqwu99m.swift:17:69: error: referencing operator function '+' on 'FloatingPoint'\
    \ requires that 'String.Index' conform to 'FloatingPoint'\n    let length = (string.index(string.startIndex,\
    \ offsetBy: index!) + string.index(string.startIndex, offsetBy: index + substring.length))\
    \ - string.index(string.startIndex, offsetBy: index)\n                       \
    \                                             ^\nSwift.FloatingPoint:1:17: note:\
    \ where 'Self' = 'String.Index'\npublic protocol FloatingPoint : Hashable, SignedNumeric,\
    \ Strideable where Self == Self.Magnitude {\n                ^\n/tmp/tmpbxqwu99m.swift:17:119:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \    let length = (string.index(string.startIndex, offsetBy: index!) + string.index(string.startIndex,\
    \ offsetBy: index + substring.length)) - string.index(string.startIndex, offsetBy:\
    \ index)\n                                                                   \
    \                                                   ^\n/tmp/tmpbxqwu99m.swift:17:131:\
    \ error: value of type 'String' has no member 'length'\n    let length = (string.index(string.startIndex,\
    \ offsetBy: index!) + string.index(string.startIndex, offsetBy: index + substring.length))\
    \ - string.index(string.startIndex, offsetBy: index)\n                       \
    \                                                                            \
    \                     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009312
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n\n    var count = 0\n    for index1 in string.indices(of:\
    \ substring) {\n        guard index1 < string.endIndex else { break }\n      \
    \  for index2 in string.indices(of: substring) {\n            guard index2 < string.endIndex\
    \ else { break }\n            count += (index1 - index2) > 0\n        }\n    }\n\
    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy4jgncs8.swift:15:26: error: cannot call value of non-function\
    \ type 'DefaultIndices<String>'\n    for index1 in string.indices(of: substring)\
    \ {\n                         ^\n/tmp/tmpy4jgncs8.swift:17:30: error: cannot call\
    \ value of non-function type 'DefaultIndices<String>'\n        for index2 in string.indices(of:\
    \ substring) {\n                             ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var startIndex\
    \ = 0\n    var endIndex = 0\n    var count = 0\n    if string.contains(substring)\
    \ {\n        for (_, char) in string.range(of: substring) {\n            if char\
    \ != ' ' {\n                endIndex = startIndex + string.count(substring: substring,\
    \ range: NSRange(location: startIndex, length: 1))\n                count = count\
    \ + 1\n            }\n            startIndex = string.index(char.successor(),\
    \ in: string.startIndex..<string.endIndex)\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqkpajbda.swift:15:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char != ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmpqkpajbda.swift:14:9: error: failed to produce\
    \ diagnostic for expression; please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n        for (_, char) in string.range(of: substring)\
    \ {\n        ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n    let index = string.firstIndex(of: substring)\n\
    \    if index == nil {\n        return 0\n    }\n    var count = 0\n    var index2\
    \ = 0\n    while index != nil {\n        count += 1\n        index2 = index! +\
    \ substring.count\n        guard index2 > string.count else {\n            break\n\
    \        }\n        index = string.index(index2..<string.endIndex, offsetBy: 1)\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp13dsedj_.swift:13:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n\
    /tmp/tmp13dsedj_.swift:25:24: error: no exact matches in call to instance method\
    \ 'index'\n        index = string.index(index2..<string.endIndex, offsetBy: 1)\n\
    \                       ^\n/tmp/tmp13dsedj_.swift:25:24: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        index = string.index(index2..<string.endIndex,\
    \ offsetBy: 1)\n                       ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n\n    if let start = string.index(of: substring)\
    \ {\n        return 1 + how_many_times(string.suffix(from: start + substring.length),\
    \ substring)\n    }\n\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6ue4pi8w.swift:14:37: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    if let start\
    \ = string.index(of: substring) {\n                                    ^\n/tmp/tmp6ue4pi8w.swift:15:34:\
    \ error: missing argument labels 'string:substring:' in call\n        return 1\
    \ + how_many_times(string.suffix(from: start + substring.length), substring)\n\
    \                                 ^\n                                  string:\
    \                                        substring: \n/tmp/tmp6ue4pi8w.swift:15:42:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        return 1 + how_many_times(string.suffix(from:\
    \ start + substring.length), substring)\n                                    \
    \     ^\n                                  String(                           \
    \           )\n/tmp/tmp6ue4pi8w.swift:15:61: error: cannot convert value of type\
    \ 'String' to expected argument type 'String.Index'\n        return 1 + how_many_times(string.suffix(from:\
    \ start + substring.length), substring)\n                                    \
    \                        ^\n/tmp/tmp6ue4pi8w.swift:15:73: error: value of type\
    \ 'String' has no member 'length'\n        return 1 + how_many_times(string.suffix(from:\
    \ start + substring.length), substring)\n                                    \
    \                          ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n    var result = -1\n    for _ in 0..<string.characters.count\
    \ {\n        if string.characters.contains(substring) {\n            result +=\
    \ 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfr9b5a18.swift:14:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in 0..<string.characters.count {\n          \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfr9b5a18.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.contains(substring) {\n  \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring.isEmpty\
    \ {\n        return 0\n    }\n    \n    let startIndex = string.firstIndex(of:\
    \ substring)\n    if startIndex == nil {\n        return 0\n    }\n    \n    let\
    \ endIndex = string.index(startIndex, offsetBy: substring.length, limitedBy: string.endIndex)\n\
    \    \n    let count = string.distance(from: startIndex, to: endIndex)\n    \n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpoo3boqyf.swift:14:44: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let startIndex\
    \ = string.firstIndex(of: substring)\n                                       \
    \    ^\n/tmp/tmpoo3boqyf.swift:19:65: error: value of type 'String' has no member\
    \ 'length'\n    let endIndex = string.index(startIndex, offsetBy: substring.length,\
    \ limitedBy: string.endIndex)\n                                              \
    \        ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n\n    if string == substring {\n        return\
    \ 1\n    }\n\n    if substring.isEmpty {\n        return string.count\n    }\n\
    \n    // Find the first index and length\n    var startIndex = string.startIndex.advanced(by:\
    \ 0)\n    var subLength = 0\n\n    var foundStart = false\n    if let index =\
    \ string.index(of: substring) {\n        subLength = index - startIndex\n    \
    \    foundStart = true\n    }\n\n    var substringCount = 1\n    for _ in 0 ..<\
    \ string.count {\n        // Find the next index and length\n        let index\
    \ = string.index(startIndex, offsetBy: subLength)\n        if let index = index\
    \ {\n            subLength += index - startIndex\n        } else {\n         \
    \   // If we couldn't find the substring after a while then we have failed\n \
    \           return substringCount\n        }\n\n        if index == 0 && !foundStart\
    \ {\n            // If we didn't find the substring before a while then we succeeded\
    \ but we couldn't find it\n            return substringCount\n        }\n\n  \
    \      if string[index..<index+subLength] == substring {\n            substringCount\
    \ += 1\n            if substringCount == substrings.count {\n                break\n\
    \            }\n        }\n    }\n\n    return substringCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptj015ndd.swift:23:40: error: value of type 'String.Index' has no\
    \ member 'advanced'\n    var startIndex = string.startIndex.advanced(by: 0)\n\
    \                     ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmptj015ndd.swift:27:37:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n    if let index = string.index(of: substring) {\n      \
    \                              ^\n/tmp/tmptj015ndd.swift:28:27: error: cannot\
    \ assign value of type 'Duration' to type 'Int'\n        subLength = index - startIndex\n\
    \                    ~~~~~~^~~~~~~~~~~~\n/tmp/tmptj015ndd.swift:37:32: error:\
    \ cannot convert value of type 'Duration' to expected argument type 'Int'\n  \
    \          subLength += index - startIndex\n                               ^\n\
    /tmp/tmptj015ndd.swift:50:34: error: cannot find 'substrings' in scope\n     \
    \       if substringCount == substrings.count {\n                            \
    \     ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // Find length\
    \ of substring\n    var len = string.length\n    while strings.find_first_index(string,\
    \ substring) != nil {\n        len -= 1\n    }\n    // Add length of substring\
    \ to the string\n    var count = 0\n    while strings.find_first_index(string,\
    \ substring, len) != nil {\n        count += 1\n        len -= 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc44g32rd.swift:11:22: error: value of type 'String' has no member\
    \ 'length'\n    var len = string.length\n              ~~~~~~ ^~~~~~\n/tmp/tmpc44g32rd.swift:12:11:\
    \ error: cannot find 'strings' in scope\n    while strings.find_first_index(string,\
    \ substring) != nil {\n          ^~~~~~~\n/tmp/tmpc44g32rd.swift:17:11: error:\
    \ cannot find 'strings' in scope\n    while strings.find_first_index(string, substring,\
    \ len) != nil {\n          ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n\n    guard let start = string.firstIndex(of:\
    \ substring) else { return 0 }\n    guard let end = string.index(start, offsetBy:\
    \ substring.count) else { return 0 }\n\n    return string.distance(from: start,\
    \ to: end)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9m1syoeg.swift:14:45: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    guard let\
    \ start = string.firstIndex(of: substring) else { return 0 }\n               \
    \                             ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.count\
    \ < substring.length {\n        return 0\n    }\n    var count = 0\n    var i\
    \ = 0\n    for j in 0 ..< string.count {\n        let char = string[j]\n     \
    \   if i >= substring.length {\n            break\n        }\n        let char2\
    \ = substring[i]\n        if char == char2 {\n            count += 1\n       \
    \     i += 1\n        } else {\n            count = 0\n            i += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpam5r_12m.swift:10:33: error: value of type 'String' has no member\
    \ 'length'\n    if string.count < substring.length {\n                      ~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpam5r_12m.swift:16:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ char = string[j]\n                   ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpam5r_12m.swift:17:27: error: value\
    \ of type 'String' has no member 'length'\n        if i >= substring.length {\n\
    \                ~~~~~~~~~ ^~~~~~\n/tmp/tmpam5r_12m.swift:20:21: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let char2 = substring[i]\n                    ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return find(string,\
    \ substring, false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgurep2rq.swift:10:12: error: cannot find 'find' in scope\n    return\
    \ find(string, substring, false)\n           ^~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // if string\
    \ and substring are empty or null\n    if string == \"\" || substring == \"\"\
    \ || string == \"\" || substring == \"\" {\n        return 0\n    }\n    var substring_index\
    \ = 0\n    var string_char_index = 0\n    var i = 0\n    for index in string.indices(of:\
    \ substring) {\n        if string_char_index == substring_index {\n          \
    \  i += 1\n        }\n        if i == string.count {\n            return i\n \
    \       }\n        substring_index += 1\n        string_char_index += 1\n    \
    \    i += 1\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9xa4ptbz.swift:17:25: error: cannot call value of non-function\
    \ type 'DefaultIndices<String>'\n    for index in string.indices(of: substring)\
    \ {\n                        ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substring(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp053d206r.swift:10:12: error: cannot find 'count_substring' in scope\n\
    \    return count_substring(string, substring)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn strings.Count(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkg0vfawt.swift:10:9: error: cannot find 'strings' in scope\n  \
    \      return strings.Count(string, substring)\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009310
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.lowercased().contains(substring.lowercased())\
    \ {\n        return 1 + how_many_times(string[string.lowercased().index(substring.lowercased())..<string.lowercased().endIndex],\
    \ substring)\n    } else {\n        return how_many_times(string, substring[substring.lowercased().startIndex..<substring.lowercased().endIndex])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps2m5lljs.swift:11:62: error: no exact matches in call to instance\
    \ method 'index'\n        return 1 + how_many_times(string[string.lowercased().index(substring.lowercased())..<string.lowercased().endIndex],\
    \ substring)\n                                                             ^\n\
    /tmp/tmps2m5lljs.swift:11:62: note: found candidate with type '(String.Index)\
    \ -> String.Index'\n        return 1 + how_many_times(string[string.lowercased().index(substring.lowercased())..<string.lowercased().endIndex],\
    \ substring)\n                                                             ^\n\
    /tmp/tmps2m5lljs.swift:11:62: note: found candidate with type '(String.Index)\
    \ -> String.Index'\n        return 1 + how_many_times(string[string.lowercased().index(substring.lowercased())..<string.lowercased().endIndex],\
    \ substring)\n                                                             ^\n\
    /tmp/tmps2m5lljs.swift:11:34: error: missing argument labels 'string:substring:'\
    \ in call\n        return 1 + how_many_times(string[string.lowercased().index(substring.lowercased())..<string.lowercased().endIndex],\
    \ substring)\n                                 ^\n                           \
    \       string:                                                              \
    \                     substring: \n/tmp/tmps2m5lljs.swift:13:30: error: missing\
    \ argument labels 'string:substring:' in call\n        return how_many_times(string,\
    \ substring[substring.lowercased().startIndex..<substring.lowercased().endIndex])\n\
    \                             ^\n                              string: substring:\
    \ \n/tmp/tmps2m5lljs.swift:13:48: error: subscript 'subscript(_:)' requires the\
    \ types 'String.Index' and 'Int' be equivalent\n        return how_many_times(string,\
    \ substring[substring.lowercased().startIndex..<substring.lowercased().endIndex])\n\
    \                                               ^\nSwift.String:5:12: note: where\
    \ 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n    var currentCount = 0\n    var currentIndex\
    \ = string.startIndex\n    while currentIndex != string.endIndex {\n        currentCount\
    \ = currentCount + string.distance(from: currentIndex, to: substring.endIndex)\n\
    \        currentIndex = string.index(from: currentIndex, offsetBy: 1)\n    }\n\
    \    return currentCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2gt7el6s.swift:17:31: error: no exact matches in call to instance\
    \ method 'index'\n        currentIndex = string.index(from: currentIndex, offsetBy:\
    \ 1)\n                              ^\nSwift.String:9:17: note: incorrect labels\
    \ for candidate (have: '(from:offsetBy:)', expected: '(_:offsetBy:)')\n    public\
    \ func index(_ i: String.Index, offsetBy distance: Int) -> String.Index\n    \
    \            ^\nSwift.Collection:6:28: note: incorrect labels for candidate (have:\
    \ '(from:offsetBy:)', expected: '(_:offsetBy:)')\n    @inlinable public func index(_\
    \ i: Self.Index, offsetBy distance: Int) -> Self.Index\n                     \
    \      ^\nSwift.BidirectionalCollection:3:28: note: incorrect labels for candidate\
    \ (have: '(from:offsetBy:)', expected: '(_:offsetBy:)')\n    @inlinable public\
    \ func index(_ i: Self.Index, offsetBy distance: Int) -> Self.Index\n        \
    \                   ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring.isEmpty()\
    \ {\n        return 0\n    }\n\n    if string.contains(substring) {\n        let\
    \ substringCount = string.count(substring)\n        let countBefore = string.firstIndex(of:\
    \ substring, options: .backwards)\n        let countAfter = string.lastIndex(of:\
    \ substring, options: .backwards)\n        return substringCount + countBefore\
    \ + countAfter\n    }\n\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpirml8cd5.swift:10:18: error: cannot call value of non-function\
    \ type 'Bool'\n    if substring.isEmpty() {\n                 ^      ~~\n    \
    \                    \n/tmp/tmpirml8cd5.swift:15:37: error: cannot call value\
    \ of non-function type 'Int'\n        let substringCount = string.count(substring)\n\
    \                                    ^\n/tmp/tmpirml8cd5.swift:16:70: error: extra\
    \ argument 'options' in call\n        let countBefore = string.firstIndex(of:\
    \ substring, options: .backwards)\n                                          \
    \ ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n/tmp/tmpirml8cd5.swift:16:49: error: cannot\
    \ convert value of type 'String' to expected argument type 'String.Element' (aka\
    \ 'Character')\n        let countBefore = string.firstIndex(of: substring, options:\
    \ .backwards)\n                                                ^\n/tmp/tmpirml8cd5.swift:16:70:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \     let countBefore = string.firstIndex(of: substring, options: .backwards)\n\
    \                                                                    ~^~~~~~~~~\n\
    /tmp/tmpirml8cd5.swift:17:68: error: extra argument 'options' in call\n      \
    \  let countAfter = string.lastIndex(of: substring, options: .backwards)\n   \
    \                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpirml8cd5.swift:17:47: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n        let countAfter\
    \ = string.lastIndex(of: substring, options: .backwards)\n                   \
    \                           ^\n/tmp/tmpirml8cd5.swift:17:68: error: cannot infer\
    \ contextual base in reference to member 'backwards'\n        let countAfter =\
    \ string.lastIndex(of: substring, options: .backwards)\n                     \
    \                                             ~^~~~~~~~~\n/tmp/tmpirml8cd5.swift:18:45:\
    \ error: cannot convert return expression of type 'String' to return type 'Int'\n\
    \        return substringCount + countBefore + countAfter\n               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return strings.Count(string.startsWith,\
    \ substring.startsWith) + strings.Count(substring, string.startsWith)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj4dg16er.swift:10:12: error: cannot find 'strings' in scope\n \
    \   return strings.Count(string.startsWith, substring.startsWith) + strings.Count(substring,\
    \ string.startsWith)\n           ^~~~~~~\n/tmp/tmpj4dg16er.swift:10:69: error:\
    \ cannot find 'strings' in scope\n    return strings.Count(string.startsWith,\
    \ substring.startsWith) + strings.Count(substring, string.startsWith)\n      \
    \                                                              ^~~~~~~\n/tmp/tmpj4dg16er.swift:10:33:\
    \ error: value of type 'String' has no member 'startsWith'\n    return strings.Count(string.startsWith,\
    \ substring.startsWith) + strings.Count(substring, string.startsWith)\n      \
    \                   ~~~~~~ ^~~~~~~~~~\n/tmp/tmpj4dg16er.swift:10:55: error: value\
    \ of type 'String' has no member 'startsWith'\n    return strings.Count(string.startsWith,\
    \ substring.startsWith) + strings.Count(substring, string.startsWith)\n      \
    \                                      ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpj4dg16er.swift:10:101:\
    \ error: value of type 'String' has no member 'startsWith'\n    return strings.Count(string.startsWith,\
    \ substring.startsWith) + strings.Count(substring, string.startsWith)\n      \
    \                                                                            \
    \           ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substring(string,\
    \ substring, true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp11l_fnbu.swift:10:12: error: cannot find 'count_substring' in scope\n\
    \    return count_substring(string, substring, true)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009229
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.firstIndex(of: substring)\n    let end = string.firstIndex(of: substring,\
    \ from: start!)\n    return end! - start!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplpck329b.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let start\
    \ = string.firstIndex(of: substring)\n                                      ^\n\
    /tmp/tmplpck329b.swift:11:59: error: extra argument 'from' in call\n    let end\
    \ = string.firstIndex(of: substring, from: start!)\n                         \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmplpck329b.swift:11:37: error: cannot\
    \ convert value of type 'String' to expected argument type 'String.Element' (aka\
    \ 'Character')\n    let end = string.firstIndex(of: substring, from: start!)\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return string.split(substring).count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdz0u328p.swift:10:25: error: missing argument label 'separator:'\
    \ in call\n    return string.split(substring).count\n                        ^\n\
    \                        separator: \n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n    var count = 0\n    var start = 0\n    var\
    \ i = 0\n    while i < string.count {\n        if string.contains(substring, start)\
    \ {\n            count += 1\n            start = start + 1\n        }\n      \
    \  i = i + 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0b9eaui6.swift:17:39: error: extra argument in call\n        if\
    \ string.contains(substring, start) {\n                          ~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let stringToSearch\
    \ = string.lowercased()\n    let substringToSearch = substring.lowercased()\n\
    \    var count = 0\n    var index = -1\n    while stringToSearch.hasPrefix(substringToSearch)\
    \ && count < substringToSearch.characters.count {\n        index = string.lowercased().distance(from:\
    \ stringToSearch.lowercased(), to: substringToSearch)\n        if index == 0 {\n\
    \            break\n        }\n        count += 1\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9qabb5o2.swift:14:84: error: 'characters' is unavailable: Please\
    \ use String directly\n    while stringToSearch.hasPrefix(substringToSearch) &&\
    \ count < substringToSearch.characters.count {\n                             \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9qabb5o2.swift:15:37: error: no exact\
    \ matches in call to instance method 'distance'\n        index = string.lowercased().distance(from:\
    \ stringToSearch.lowercased(), to: substringToSearch)\n                      \
    \              ^\n/tmp/tmp9qabb5o2.swift:15:37: note: candidate has partially\
    \ matching parameter list (from: String.Index, to: String.Index)\n        index\
    \ = string.lowercased().distance(from: stringToSearch.lowercased(), to: substringToSearch)\n\
    \                                    ^\n/tmp/tmp9qabb5o2.swift:15:37: note: candidate\
    \ has partially matching parameter list (from: String.Index, to: String.Index)\n\
    \        index = string.lowercased().distance(from: stringToSearch.lowercased(),\
    \ to: substringToSearch)\n                                    ^\n/tmp/tmp9qabb5o2.swift:15:37:\
    \ note: candidate has partially matching parameter list (from: String.Index, to:\
    \ String.Index)\n        index = string.lowercased().distance(from: stringToSearch.lowercased(),\
    \ to: substringToSearch)\n                                    ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.starts(with:\
    \ substring) == false && string.ends(with: substring) == false {\n        return\
    \ 0\n    }\n    let count = string.distance(from: string.starts(with: substring)!,\
    \ to: string.ends(with: substring)!)\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4aqfrxsv.swift:10:58: error: value of type 'String' has no member\
    \ 'ends'\n    if string.starts(with: substring) == false && string.ends(with:\
    \ substring) == false {\n                                                  ~~~~~~\
    \ ^~~~\n/tmp/tmp4aqfrxsv.swift:13:69: error: cannot convert value of type 'Bool'\
    \ to expected argument type 'String.Index'\n    let count = string.distance(from:\
    \ string.starts(with: substring)!, to: string.ends(with: substring)!)\n      \
    \                                                              ^\n/tmp/tmp4aqfrxsv.swift:13:69:\
    \ error: cannot force unwrap value of non-optional type 'Bool'\n    let count\
    \ = string.distance(from: string.starts(with: substring)!, to: string.ends(with:\
    \ substring)!)\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                    \n/tmp/tmp4aqfrxsv.swift:13:83:\
    \ error: value of type 'String' has no member 'ends'\n    let count = string.distance(from:\
    \ string.starts(with: substring)!, to: string.ends(with: substring)!)\n      \
    \                                                                     ~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for idx, char in enumerate(string) {\n        if char == substring {\n\
    \            count += 1\n        }\n        if idx > 0 && (idx+len(substring))\
    \ <= len(string) {\n            if string.substring(idx) == substring {\n    \
    \            count += 1\n            }\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph96bthdk.swift:11:12: error: expected 'in' after for-each pattern\n\
    \    for idx, char in enumerate(string) {\n           ^\n/tmp/tmph96bthdk.swift:11:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, char in\
    \ enumerate(string) {\n           ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // TODO: Write\
    \ a more efficient implementation, avoiding calls to String.IndexOf\n    return\
    \ count_substring(string, substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6q3057ro.swift:11:12: error: cannot find 'count_substring' in scope\n\
    \    return count_substring(string, substring)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n    \n    if let start = find(string, substring)\
    \ {\n        let end = string.distance(from: start, to: string.endIndex, options:\
    \ .backwards)\n        \n        return end - start\n    }\n    \n    return 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkds2lnj7.swift:14:20: error: cannot find 'find' in scope\n    if\
    \ let start = find(string, substring) {\n                   ^~~~\n/tmp/tmpkds2lnj7.swift:15:79:\
    \ error: extra argument 'options' in call\n        let end = string.distance(from:\
    \ start, to: string.endIndex, options: .backwards)\n                         \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n/tmp/tmpkds2lnj7.swift:15:79:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \     let end = string.distance(from: start, to: string.endIndex, options: .backwards)\n\
    \                                                                            \
    \ ~^~~~~~~~~\n/tmp/tmpkds2lnj7.swift:17:20: error: cannot convert return expression\
    \ of type 'Duration' to return type 'Int'\n        return end - start\n      \
    \         ~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.starts(substring)\
    \ && string.ends(substring) {\n        return string.count(substring)\n    } else\
    \ {\n        var n = 0\n        for ch in string.unicodeScalars {\n          \
    \  if ch != unichar(string).unicodeScalars.last! {\n                if substring.isPrefixOfString(String(ch))\
    \ {\n                    n += substring.length\n                }\n          \
    \  }\n        }\n        return n\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7fu_jjqj.swift:10:22: error: missing argument label 'with:' in\
    \ call\n    if string.starts(substring) && string.ends(substring) {\n        \
    \             ^\n                     with: \n/tmp/tmp7fu_jjqj.swift:10:43: error:\
    \ value of type 'String' has no member 'ends'\n    if string.starts(substring)\
    \ && string.ends(substring) {\n                                   ~~~~~~ ^~~~\n\
    /tmp/tmp7fu_jjqj.swift:11:23: error: cannot call value of non-function type 'Int'\n\
    \        return string.count(substring)\n                      ^\n/tmp/tmp7fu_jjqj.swift:15:22:\
    \ error: cannot find 'unichar' in scope\n            if ch != unichar(string).unicodeScalars.last!\
    \ {\n                     ^~~~~~~\n/tmp/tmp7fu_jjqj.swift:16:30: error: value\
    \ of type 'String' has no member 'isPrefixOfString'\n                if substring.isPrefixOfString(String(ch))\
    \ {\n                   ~~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp7fu_jjqj.swift:17:36:\
    \ error: value of type 'String' has no member 'length'\n                    n\
    \ += substring.length\n                         ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let start\
    \ = string.firstIndex(of: substring) else {\n        return 0\n    }\n    var\
    \ i = 0\n    var count = 0\n    while i < string.count {\n        if i == start\
    \ {\n            count += 1\n        }\n        if string.index(string.startIndex,\
    \ offsetBy: i + substring.count) == start {\n            count += 1\n        }\n\
    \        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpx4cljb3h.swift:10:45: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    guard let\
    \ start = string.firstIndex(of: substring) else {\n                          \
    \                  ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tif substring ==\
    \ \"\" {\n\t\treturn 0\n\t}\n\t\n\treturn strings.Count(string, substring)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpthhke0_9.swift:14:9: error: cannot find 'strings' in scope\n  \
    \      return strings.Count(string, substring)\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.isEmpty\
    \ || substring.isEmpty {\n        return 0\n    }\n    return count(string, substring,\
    \ true) + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppzgn1cjs.swift:13:12: error: cannot find 'count' in scope\n   \
    \ return count(string, substring, true) + 1\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n\n    var count = 0\n    let indexes = Array(string.characters).indices\
    \ {\n        if $0 == substring.characters.first {\n            count++\n    \
    \    }\n        if $0 == substring.characters.last {\n            count++\n  \
    \      }\n    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyvk17bjp.swift:21:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            count++\n                 ^~\n/tmp/tmpyvk17bjp.swift:24:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  count++\n                 ^~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count: Int\
    \ = 0\n\n    var index = 0\n    while index < string.characters.count && substring.characters.count\
    \ > 0 {\n        if string.characters[index] != substring.characters[0] {\n  \
    \          break\n        }\n        count += 1\n        index++\n    }\n\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjnwjk2x_.swift:13:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    while index < string.characters.count && substring.characters.count\
    \ > 0 {\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjnwjk2x_.swift:13:56: error: 'characters' is unavailable:\
    \ Please use String directly\n    while index < string.characters.count && substring.characters.count\
    \ > 0 {\n                                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpjnwjk2x_.swift:14:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] != substring.characters[0] {\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpjnwjk2x_.swift:14:19: error: 'characters' is\
    \ unavailable: Please use String directly\n        if string.characters[index]\
    \ != substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpjnwjk2x_.swift:14:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] != substring.characters[0] {\n          \
    \                             ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpjnwjk2x_.swift:14:50: error:\
    \ 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ != substring.characters[0] {\n                                             \
    \    ^~~~~~~~~~\nSwift.String:5:16: not"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    if let pos = string.lowercaseString.find(substring.lowercaseString)\
    \ {\n        return pos + substring.length\n    }\n    return 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpyrfmcg83.swift:13:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    if let pos = string.lowercaseString.find(substring.lowercaseString)\
    \ {\n                 ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpyrfmcg83.swift:13:56: error:\
    \ value of type 'String' has no member 'lowercaseString'\n    if let pos = string.lowercaseString.find(substring.lowercaseString)\
    \ {\n                                             ~~~~~~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmpyrfmcg83.swift:14:20: error: cannot convert return expression of type\
    \ 'String' to return type 'Int'\n        return pos + substring.length\n     \
    \          ~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpyrfmcg83.swift:14:32: error: value\
    \ of type 'String' has no member 'length'\n        return pos + substring.length\n\
    \                     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring.isEmpty\
    \ {\n        return string.isEmpty ? 0 : 0\n    }\n    return string.countSubstring(substring)\
    \ + how_many_times(string, substring[1..<string.count])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpntlhlome.swift:13:19: error: value of type 'String' has no member\
    \ 'countSubstring'\n    return string.countSubstring(substring) + how_many_times(string,\
    \ substring[1..<string.count])\n           ~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmpntlhlome.swift:13:61:\
    \ error: missing argument labels 'string:substring:' in call\n    return string.countSubstring(substring)\
    \ + how_many_times(string, substring[1..<string.count])\n                    \
    \                                        ^\n                                 \
    \                            string: substring: \n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\treturn how_many_times_n(string,\
    \ substring, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp26rjrwld.swift:10:9: error: cannot find 'how_many_times_n' in scope\n\
    \        return how_many_times_n(string, substring, 0)\n               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.contains(substring)\
    \ {\n        return string.count(substring, options: .caseInsensitive)\n    }\
    \ else {\n        return -1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvxovr143.swift:11:23: error: cannot call value of non-function\
    \ type 'Int'\n        return string.count(substring, options: .caseInsensitive)\n\
    \                      ^\n/tmp/tmpvxovr143.swift:11:50: error: cannot infer contextual\
    \ base in reference to member 'caseInsensitive'\n        return string.count(substring,\
    \ options: .caseInsensitive)\n                                               \
    \ ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.startIndex(of:\
    \ substring) == nil || string.endIndex(of: substring) == nil {\n        return\
    \ 0\n    }\n    if string.startIndex(of: substring) != string.endIndex(of: substring)\
    \ {\n        guard let start = string.startIndex(of: substring) else { return\
    \ 0 }\n        guard let end = string.endIndex(of: substring) else { return 0\
    \ }\n        let range = start..<end\n        return range.map { string.distance(from:\
    \ string[$0], to: string[$0]) }.max()\n    } else {\n        return 2\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_fo89tb1.swift:10:15: error: cannot call value of non-function\
    \ type 'String.Index'\n    if string.startIndex(of: substring) == nil || string.endIndex(of:\
    \ substring) == nil {\n              ^\n/tmp/tmp_fo89tb1.swift:10:58: error: cannot\
    \ call value of non-function type 'String.Index'\n    if string.startIndex(of:\
    \ substring) == nil || string.endIndex(of: substring) == nil {\n             \
    \                                            ^\n/tmp/tmp_fo89tb1.swift:13:15:\
    \ error: cannot call value of non-function type 'String.Index'\n    if string.startIndex(of:\
    \ substring) != string.endIndex(of: substring) {\n              ^\n/tmp/tmp_fo89tb1.swift:13:51:\
    \ error: cannot call value of non-function type 'String.Index'\n    if string.startIndex(of:\
    \ substring) != string.endIndex(of: substring) {\n                           \
    \                       ^\n/tmp/tmp_fo89tb1.swift:14:34: error: cannot call value\
    \ of non-function type 'String.Index'\n        guard let start = string.startIndex(of:\
    \ substring) else { return 0 }\n                                 ^\n/tmp/tmp_fo89tb1.swift:15:32:\
    \ error: cannot call value of non-function type 'String.Index'\n        guard\
    \ let end = string.endIndex(of: substring) else { return 0 }\n               \
    \                ^\n/tmp/tmp_fo89tb1.swift:17:35: error: no exact matches in call\
    \ to instance method 'distance'\n        return range.map { string.distance(from:\
    \ string[$0], to: string[$0]) }.max()\n                                  ^\n/tmp/tmp_fo89tb1.swift:17:35:\
    \ note: found candidate with type '(String.Index, String.Index) -> Int'\n    \
    \    return range.map { string.distance(from: string[$0], to: string[$0]) }.max()\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let searchIndex\
    \ = string.index(of: substring)\n    if searchIndex == nil {\n        return 0\n\
    \    }\n    return searchIndex?.distance(from: startIndex) ?? 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpv4mvs6md.swift:10:40: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let searchIndex\
    \ = string.index(of: substring)\n                                       ^\n/tmp/tmpv4mvs6md.swift:14:40:\
    \ error: cannot find 'startIndex' in scope\n    return searchIndex?.distance(from:\
    \ startIndex) ?? 0\n                                       ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.lowercased().hasSuffix(substring)\
    \ {\n        return string.lowercased().lowercased().suffix(substring).count {\
    \ substring.lowercased().contains($0) }\n    }\n    return string.lowercased().lowercased().containingSubstring(substring).count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpddtqkxml.swift:11:56: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        return string.lowercased().lowercased().suffix(substring).count\
    \ { substring.lowercased().contains($0) }\n                                  \
    \                     ^\n/tmp/tmpddtqkxml.swift:11:67: error: cannot call value\
    \ of non-function type 'Int'\n        return string.lowercased().lowercased().suffix(substring).count\
    \ { substring.lowercased().contains($0) }\n                                  \
    \                                ^\n/tmp/tmpddtqkxml.swift:13:45: error: value\
    \ of type 'String' has no member 'containingSubstring'\n    return string.lowercased().lowercased().containingSubstring(substring).count\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let pos = string.firstIndex(of:\
    \ substring)\n    return pos == nil ? 0 : 1 + string.distance(from: string.startIndex,\
    \ to: pos!)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6k61b5yi.swift:10:37: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let pos =\
    \ string.firstIndex(of: substring)\n                                    ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    let index = string.firstIndex(of: substring)\n    if index != nil {\n\
    \        count = index + string.distance(from: string.startIndex, to: index!)\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpojt9d4a_.swift:11:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.rangeOfString(substring).location\n    return string.distance(from: string.startIndex,\
    \ to: index)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7_jx4l4e.swift:10:24: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    let index = string.rangeOfString(substring).location\n\
    \                ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for _ in string.enumerated() {\n        if let range = string.rangeOfString(substring)\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc_idc610.swift:12:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        if let range = string.rangeOfString(substring) {\n\
    \                       ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_times(string,\
    \ substring: substring, mode: .any)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk9xka4zb.swift:10:12: error: cannot find 'count_times' in scope\n\
    \    return count_times(string, substring: substring, mode: .any)\n          \
    \ ^~~~~~~~~~~\n/tmp/tmpk9xka4zb.swift:10:61: error: cannot infer contextual base\
    \ in reference to member 'any'\n    return count_times(string, substring: substring,\
    \ mode: .any)\n                                                           ~^~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count = 0\n\
    \    var startIndex = string.startIndex\n    var endIndex = string.endIndex\n\
    \    while startIndex < endIndex {\n        if string.substring(startIndex, endIndex).starts(with:\
    \ substring) {\n            count += 1\n        }\n        startIndex = string.index(startIndex,\
    \ offsetBy: 1)\n        endIndex = string.index(endIndex, offsetBy: -1)\n    }\n\
    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvr7ixtu7.swift:18:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(startIndex, endIndex).starts(with:\
    \ substring) {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard let string\
    \ = string.lowercased() else {\n        return 0\n    }\n\n    if let substring\
    \ = substring.lowercased() {\n        if let index = string.lowerString.index(string.lowerString.startIndex,\
    \ offsetBy: substring.lowerString.count) {\n            return string.lowerString.distance(from:\
    \ string.lowerString.startIndex, to: index)\n        } else {\n            return\
    \ 0\n        }\n    } else {\n        return 0\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxqg3gaki.swift:10:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let string = string.lowercased()\
    \ else {\n          ^            ~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxqg3gaki.swift:15:31:\
    \ error: value of type 'String' has no member 'lowerString'\n        if let index\
    \ = string.lowerString.index(string.lowerString.startIndex, offsetBy: substring.lowerString.count)\
    \ {\n                       ~~~~~~ ^~~~~~~~~~~\n/tmp/tmpxqg3gaki.swift:15:56:\
    \ error: value of type 'String' has no member 'lowerString'\n        if let index\
    \ = string.lowerString.index(string.lowerString.startIndex, offsetBy: substring.lowerString.count)\
    \ {\n                                                ~~~~~~ ^~~~~~~~~~~\n/tmp/tmpxqg3gaki.swift:15:100:\
    \ error: value of type 'String' has no member 'lowerString'\n        if let index\
    \ = string.lowerString.index(string.lowerString.startIndex, offsetBy: substring.lowerString.count)\
    \ {\n                                                                        \
    \                 ~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpxqg3gaki.swift:16:27: error:\
    \ value of type 'String' has no member 'lowerString'\n            return string.lowerString.distance(from:\
    \ string.lowerString.startIndex, to: index)\n                   ~~~~~~ ^~~~~~~~~~~\n\
    /tmp/tmpxqg3gaki.swift:16:61: error: value of type 'String' has no member 'lowerString'\n\
    \            return string.lowerString.distance(from: string.lowerString.startIndex,\
    \ to: index)\n                                                     ~~~~~~ ^~~~~~~~~~~\n\
    /tmp/tmpxqg3gaki.swift:14:8: error: initializer for conditional binding must have\
    \ Optional type, not 'String'\n    if let substring = substring.lowercased() {\n\
    \       ^               ~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // TODO: use\
    \ regexp\n    guard let firstIndex: NSRange = string.rangeOfString(substring)\
    \ else {\n        return 0\n    }\n    return string.rangeOfString(substring,\
    \ options: NSStringCompareOptions.CaseInsensitiveSearch).location - firstIndex.location\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphpa6rk3j.swift:11:27: error: cannot find type 'NSRange' in scope\n\
    \    guard let firstIndex: NSRange = string.rangeOfString(substring) else {\n\
    \                          ^~~~~~~\n/tmp/tmphpa6rk3j.swift:11:44: error: cannot\
    \ convert value of type '_' to specified type '<<error type>>?'\n    guard let\
    \ firstIndex: NSRange = string.rangeOfString(substring) else {\n             \
    \                       ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphpa6rk3j.swift:11:44:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    guard let firstIndex:\
    \ NSRange = string.rangeOfString(substring) else {\n                         \
    \           ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmphpa6rk3j.swift:14:53: error: cannot\
    \ find 'NSStringCompareOptions' in scope\n    return string.rangeOfString(substring,\
    \ options: NSStringCompareOptions.CaseInsensitiveSearch).location - firstIndex.location\n\
    \                                                    ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphpa6rk3j.swift:14:19: error: value of type 'String' has no member 'rangeOfString'\n\
    \    return string.rangeOfString(substring, options: NSStringCompareOptions.CaseInsensitiveSearch).location\
    \ - firstIndex.location\n           ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex\n    let end = string.endIndex\n    let subStartIndex = string.startIndex.distanceTo(substring.startIndex)\n\
    \    let subEndIndex = string.endIndex.distanceTo(substring.endIndex)\n\n    let\
    \ indexCount = 0\n    while start < end {\n        if string[start] == substring[subStartIndex]\
    \ && string[end] == substring[subEndIndex] {\n            indexCount++\n     \
    \       if indexCount == substring.count {\n                return indexCount\n\
    \            }\n            start++\n            end--\n        }\n        else\
    \ {\n            start++\n        }\n    }\n    return indexCount\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbvtgs4sd.swift:12:43: error: value of type 'String.Index' has no\
    \ member 'distanceTo'\n    let subStartIndex = string.startIndex.distanceTo(substring.startIndex)\n\
    \                        ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpbvtgs4sd.swift:13:39:\
    \ error: value of type 'String.Index' has no member 'distanceTo'\n    let subEndIndex\
    \ = string.endIndex.distanceTo(substring.endIndex)\n                      ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpbvtgs4sd.swift:18:23: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n            indexCount++\n                    \
    \  ^~\n/tmp/tmpbvtgs4sd.swift:22:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            start++\n                 ^~\n/tmp/tmpbvtgs4sd.swift:23:16:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  end--\n               ^~\n/tmp/tmpbvtgs4sd.swift:26:18: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            start++\n        \
    \         ^~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.isEmpty\
    \ || substring.isEmpty {\n        return 0\n    }\n\n    var substringCount =\
    \ substring\n        .unicodeScalars\n        .filter() { $0 != CharacterSet.whiteSpace\
    \ }\n        .filter() { $0 != CharacterSet.alphanumerics }\n        .filter()\
    \ { $0 != CharacterSet.symbols }\n        .filter() { $0 != CharacterSet.newlines\
    \ }\n        .filter() { $0 != CharacterSet.lineSeparator }\n        .filter()\
    \ { $0 != CharacterSet.controlCharacters }\n        .filter() { $0 != CharacterSet.newlines}\n\
    \        .count\n\n    while !string.hasSuffix(substring) {\n        if string.hasPrefix(substring)\
    \ {\n            substringCount += 1\n        }\n        substringCount -= 1\n\
    \        string = string.dropLast()\n    }\n\n    return substringCount\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp29vwyqf3.swift:16:27: error: cannot find 'CharacterSet' in scope\n\
    \        .filter() { $0 != CharacterSet.whiteSpace }\n                       \
    \   ^~~~~~~~~~~~\n/tmp/tmp29vwyqf3.swift:17:27: error: cannot find 'CharacterSet'\
    \ in scope\n        .filter() { $0 != CharacterSet.alphanumerics }\n         \
    \                 ^~~~~~~~~~~~\n/tmp/tmp29vwyqf3.swift:18:27: error: cannot find\
    \ 'CharacterSet' in scope\n        .filter() { $0 != CharacterSet.symbols }\n\
    \                          ^~~~~~~~~~~~\n/tmp/tmp29vwyqf3.swift:19:27: error:\
    \ cannot find 'CharacterSet' in scope\n        .filter() { $0 != CharacterSet.newlines\
    \ }\n                          ^~~~~~~~~~~~\n/tmp/tmp29vwyqf3.swift:20:27: error:\
    \ cannot find 'CharacterSet' in scope\n        .filter() { $0 != CharacterSet.lineSeparator\
    \ }\n                          ^~~~~~~~~~~~\n/tmp/tmp29vwyqf3.swift:21:27: error:\
    \ cannot find 'CharacterSet' in scope\n        .filter() { $0 != CharacterSet.controlCharacters\
    \ }\n                          ^~~~~~~~~~~~\n/tmp/tmp29vwyqf3.swift:22:27: error:\
    \ cannot find 'CharacterSet' in scope\n        .filter() { $0 != CharacterSet.newlines}\n\
    \                          ^~~~~~~~~~~~\n/tmp/tmp29vwyqf3.swift:30:9: error: cannot\
    \ assign to value: 'string' is a 'let' constant\n        string = string.dropLast()\n\
    \        ^~~~~~\n/tmp/tmp29vwyqf3.swift:30:25: error: no 'dropLast' candidates\
    \ produce the expected contextual result type 'String'\n        string = string.dropLast()\n\
    \                        ^\nSwift.Sequence:5:40: note: 'dropLast' produces '[String.Element]'\
    \ (aka 'Array<Character>'), not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func dropLast(_ k: Int = 1) -> [Self.Element]\n\
    \                                       ^\nSwift.Collection:4:40: note: 'dropLast'\
    \ produces 'String.SubSequence' (aka 'Substring'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func dropLast(_ k: Int\
    \ = 1) -> Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let lower =\
    \ string.lowercased()\n    let upper = string.uppercased()\n    var count = 0\n\
    \    var index = lower\n    while index < upper.characters.count {\n        if\
    \ substring.characters.contains(index..<index + 1) {\n            count += 1\n\
    \        }\n        index++\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpckq5hqxz.swift:14:17: error: binary operator '<' cannot be applied\
    \ to operands of type 'String' and 'Int'\n    while index < upper.characters.count\
    \ {\n          ~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpckq5hqxz.swift:14:17: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int), (String, String)\n    while index < upper.characters.count {\n       \
    \         ^\n/tmp/tmpckq5hqxz.swift:15:58: error: cannot convert value of type\
    \ 'Int' to expected argument type 'String'\n        if substring.characters.contains(index..<index\
    \ + 1) {\n                                                         ^\n/tmp/tmpckq5hqxz.swift:15:47:\
    \ error: cannot convert value of type 'Range<String>' to expected argument type\
    \ 'String.Element' (aka 'Character')\n        if substring.characters.contains(index..<index\
    \ + 1) {\n                                              ^\n/tmp/tmpckq5hqxz.swift:18:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var index =\
    \ string.startIndex\n\n    for char in substring {\n        if index == string.endIndex\
    \ || string[index] != char {\n            return 0\n        }\n\n        index++\n\
    \    }\n\n    return index - string.startIndex\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpj6ekri7_.swift:17:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n/tmp/tmpj6ekri7_.swift:20:18:\
    \ error: referencing operator function '-' on 'Strideable' requires that 'String.Index'\
    \ conform to '_Pointer'\n    return index - string.startIndex\n              \
    \   ^\nSwift.Strideable:1:11: note: where 'Self' = 'String.Index'\nextension Strideable\
    \ where Self : _Pointer {\n          ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0\n    for char in string.characters.reversed() {\n        if char == substring\
    \ {\n            count += 1\n        }\n        if char == substring.first {\n\
    \            if count > 0 {\n                count += 1\n            }\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpjbe1i87o.swift:11:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters.reversed() {\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjbe1i87o.swift:12:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if char == substring {\n           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpjbe1i87o.swift:12:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == substring {\n \
    \               ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard string\
    \ != nil else { return 0 }\n    guard substring != nil else { return 0 }\n   \
    \ let len = string.count\n    let slen = substring.count\n    var count = 0\n\
    \    var pos = 0\n    while pos < len {\n        let searchStart = min(pos + slen,\
    \ len)\n        let index = string.range(of: substring, options: .backwards)?.lowerBound\n\
    \        if index == searchStart {\n            count += 1\n        }\n      \
    \  pos = searchStart + 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6pwzhowt.swift:10:18: warning: comparing non-optional value of\
    \ type 'String' to 'nil' always returns true\n    guard string != nil else { return\
    \ 0 }\n          ~~~~~~ ^  ~~~\n/tmp/tmp6pwzhowt.swift:11:21: warning: comparing\
    \ non-optional value of type 'String' to 'nil' always returns true\n    guard\
    \ substring != nil else { return 0 }\n          ~~~~~~~~~ ^  ~~~\n/tmp/tmp6pwzhowt.swift:18:71:\
    \ error: type of expression is ambiguous without more context\n        let index\
    \ = string.range(of: substring, options: .backwards)?.lowerBound\n           \
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return strings.Count(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpo0ngyl01.swift:10:12: error: cannot find 'strings' in scope\n \
    \   return strings.Count(substring)\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string.countIfString(substring)\
    \ == 0 {\n        return 0\n    }\n    return string.countIfString(substring)\
    \ + how_many_times(string.stringByReplacingOccurrencesOfString(substring, withString:\
    \ \"\", options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6i9vovnb.swift:10:15: error: value of type 'String' has no member\
    \ 'countIfString'\n    if string.countIfString(substring) == 0 {\n       ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmp6i9vovnb.swift:13:141: error: cannot find 'NSStringCompareOptions'\
    \ in scope\n    return string.countIfString(substring) + how_many_times(string.stringByReplacingOccurrencesOfString(substring,\
    \ withString: \"\", options: NSStringCompareOptions.CaseInsensitiveSearch, range:\
    \ nil))\n                                                                    \
    \                                                                        ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp6i9vovnb.swift:13:19: error: value of type 'String' has no member 'countIfString'\n\
    \    return string.countIfString(substring) + how_many_times(string.stringByReplacingOccurrencesOfString(substring,\
    \ withString: \"\", options: NSStringCompareOptions.CaseInsensitiveSearch, range:\
    \ nil))\n           ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp6i9vovnb.swift:13:61: error:\
    \ missing argument label 'string:' in call\n    return string.countIfString(substring)\
    \ + how_many_times(string.stringByReplacingOccurrencesOfString(substring, withString:\
    \ \"\", options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil))\n\
    \                                                            ^\n             \
    \                                               string: \n/tmp/tmp6i9vovnb.swift:13:198:\
    \ error: missing argument for parameter 'substring' in call\n    return string.countIfString(substring)\
    \ + how_many_times(string.stringByReplacingOccurrencesOfString(substring, withString:\
    \ \"\", options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil))\n\
    \                                                                            \
    \                                                                            \
    \                                             ^\n                            \
    \                                                                            \
    \                                                                            \
    \                 , substring: <#String#>\n/"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    var substring_index:\
    \ Int = string.characters.index\n    if substring_index == string.characters.count\
    \ {\n        return substring_index.count\n    }\n    var substring_index2: Int\
    \ = string.characters.index\n    var found_index: Int = 0\n    while substring_index\
    \ < string.characters.count && substring_index2 > substring_index {\n        if\
    \ string[substring_index] == substring[substring_index2] {\n            found_index\
    \ = substring_index2 + 1\n        }\n        substring_index2 = substring_index\
    \ + 1\n    }\n    if substring_index > substring_index2 {\n        return substring_index.count\
    \ - found_index\n    }\n    return substring_index.count - substring_index2.count\
    \ + found_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpidqhrlye.swift:13:50: error: no 'index' candidates produce the\
    \ expected contextual result type 'Int'\n    var substring_index: Int = string.characters.index\n\
    \                                                 ^\nSwift.String:7:17: note:\
    \ found candidate with type '(String.Index) -> String.Index'\n    public func\
    \ index(after i: String.Index) -> String.Index\n                ^\nSwift.String:8:17:\
    \ note: found candidate with type '(String.Index) -> String.Index'\n    public\
    \ func index(before i: String.Index) -> String.Index\n                ^\nSwift.String:9:17:\
    \ note: found candidate with type '(String.Index, Int) -> String.Index'\n    public\
    \ func index(_ i: String.Index, offsetBy distance: Int) -> String.Index\n    \
    \            ^\nSwift.String:10:17: note: found candidate with type '(String.Index,\
    \ Int, String.Index) -> String.Index?'\n    public func index(_ i: String.Index,\
    \ offsetBy distance: Int, limitedBy limit: String.Index) -> String.Index?\n  \
    \              ^\nSwift.Collection:6:28: note: found candidate with type '(String.Index,\
    \ Int) -> String.Index'\n    @inlinable public func index(_ i: Self.Index, offsetBy\
    \ distance: Int) -> Self.Index\n                           ^\nSwift.Collection:7:28:\
    \ note: found candidate with type '(String.Index, Int, String.Index) -> String.Index?'\n\
    \    @inlinable public func index(_ i: Self.Index, offsetBy distance: Int, limitedBy\
    \ limit: Self.Index) -> Self.Index?\n                           ^\nSwift.Collection:3:28:\
    \ note: found candidate with type '((String.Element) throws -> Bool) throws ->\
    \ String.Index?' (aka '((Character) throws -> Bool) throws -> Optional<String.Index>')\n\
    \    @inlinable public func index(where _predicate: (Self.Element) throws -> Bool)\
    \ rethrows -> Self.Index?\n                           ^\nSwift.Collection:3:28:\
    \ note: found candidate with type '(String.Element) -> String.Index?' (aka '(Character)\
    \ -> Optional<String.Index>')\n    @inlinable public func index(of element: Self.Element)\
    \ -> Self.Index?\n                           ^\nSwift.BidirectionalCollection:3:28:\
    \ note: found candidate"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring\
    \ == \"\" {\n        return 0\n    }\n    var count = 0\n    guard let start =\
    \ string.index(of: substring) else { return 0 }\n    let end = start.advanced(by:\
    \ substring.count)\n    if start < end {\n        count = string.distance(from:\
    \ start, end: end)\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppcsi4urd.swift:14:40: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    guard let\
    \ start = string.index(of: substring) else { return 0 }\n                    \
    \                   ^\n/tmp/tmppcsi4urd.swift:17:24: error: no exact matches in\
    \ call to instance method 'distance'\n        count = string.distance(from: start,\
    \ end: end)\n                       ^\n/tmp/tmppcsi4urd.swift:17:24: note: found\
    \ candidate with type '(String.Index, String.Index) -> Int'\n        count = string.distance(from:\
    \ start, end: end)\n                       ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return strings.Index(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0z2hlrkl.swift:10:12: error: cannot find 'strings' in scope\n \
    \   return strings.Index(string, substring)\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n\n    if substring == \"\" {\n        return\
    \ string.count\n    }\n\n    // The length of substring is greater than string\n\
    \    if string.count < substring.count {\n        return -1\n    }\n\n    var\
    \ count = 0\n    for ch in string {\n        if ch == substring[0] {\n       \
    \     count += string.count(substring)\n        } else {\n            count +=\
    \ string.count(substring)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpixzx0jaf.swift:25:18: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if ch ==\
    \ substring[0] {\n                 ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpixzx0jaf.swift:26:29: error: cannot\
    \ call value of non-function type 'Int'\n            count += string.count(substring)\n\
    \                            ^\n/tmp/tmpixzx0jaf.swift:28:29: error: cannot call\
    \ value of non-function type 'Int'\n            count += string.count(substring)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" {\n        return 0\n    }\n\n    let substringLength = string.length -\
    \ substring.length\n    if substringLength == 0 {\n        return 1\n    }\n\n\
    \    var count = 0\n    var startIndex = string.startIndex\n\n    while startIndex\
    \ < string.endIndex {\n        let startIndex = string.index(in: startIndex, offsetBy:\
    \ substring.length, limitedBy: string.endIndex) ?? string.endIndex\n        let\
    \ endIndex = string.index(in: startIndex, offsetBy: substring.length, limitedBy:\
    \ string.endIndex) ?? string.endIndex\n\n        let char = string[startIndex...endIndex]\n\
    \        if char == substring {\n            count += 1\n        }\n        startIndex\
    \ = endIndex\n    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbdksqjd2.swift:14:34: error: value of type 'String' has no member\
    \ 'length'\n    let substringLength = string.length - substring.length\n     \
    \                     ~~~~~~ ^~~~~~\n/tmp/tmpbdksqjd2.swift:14:53: error: value\
    \ of type 'String' has no member 'length'\n    let substringLength = string.length\
    \ - substring.length\n                                          ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpbdksqjd2.swift:23:33: error: no exact matches in call to instance method\
    \ 'index'\n        let startIndex = string.index(in: startIndex, offsetBy: substring.length,\
    \ limitedBy: string.endIndex) ?? string.endIndex\n                           \
    \     ^\n/tmp/tmpbdksqjd2.swift:23:33: note: found candidate with type '(String.Index,\
    \ Int, String.Index) -> String.Index?'\n        let startIndex = string.index(in:\
    \ startIndex, offsetBy: substring.length, limitedBy: string.endIndex) ?? string.endIndex\n\
    \                                ^\n/tmp/tmpbdksqjd2.swift:23:75: error: value\
    \ of type 'String' has no member 'length'\n        let startIndex = string.index(in:\
    \ startIndex, offsetBy: substring.length, limitedBy: string.endIndex) ?? string.endIndex\n\
    \                                                                ~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpbdksqjd2.swift:24:31: error: no exact matches in call to instance method\
    \ 'index'\n        let endIndex = string.index(in: startIndex, offsetBy: substring.length,\
    \ limitedBy: string.endIndex) ?? string.endIndex\n                           \
    \   ^\n/tmp/tmpbdksqjd2.swift:24:31: note: found candidate with type '(String.Index,\
    \ Int, String.Index) -> String.Index?'\n        let endIndex = string.index(in:\
    \ startIndex, offsetBy: substring.length, limitedBy: string.endIndex) ?? string.endIndex\n\
    \                              ^\n/tmp/tmpbdksqjd2.swift:24:73: error: value of\
    \ type 'String' has no member 'length'\n        let endIndex = string.index(in:\
    \ startIndex, offsetBy: substring.length, limitedBy: string.endIndex) ?? string.endIndex\n\
    \                                                              ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    var count =\
    \ 0, pos = string.startIndex\n    while true {\n        pos = string.index(substring,\
    \ pos)\n        if pos == NSNotFound {\n            break\n        }\n       \
    \ count += 1\n        pos = pos + substring.count\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd29aw7hc.swift:12:27: error: missing argument label 'offsetBy:'\
    \ in call\n        pos = string.index(substring, pos)\n                      \
    \    ^\n                                      offsetBy: \n/tmp/tmpd29aw7hc.swift:12:28:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Index'\n\
    \        pos = string.index(substring, pos)\n                           ^\n/tmp/tmpd29aw7hc.swift:12:15:\
    \ error: instance method 'index(_:offsetBy:)' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n        pos = string.index(substring, pos)\n           \
    \   ^\nSwift.Collection:3:17: note: where 'T' = 'String.Index'\n    public func\
    \ index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where T : BinaryInteger\n\
    \                ^\n/tmp/tmpd29aw7hc.swift:13:19: error: cannot find 'NSNotFound'\
    \ in scope\n        if pos == NSNotFound {\n                  ^~~~~~~~~~\n/tmp/tmpd29aw7hc.swift:17:19:\
    \ error: binary operator '+' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n        pos = pos + substring.count\n              ~~~ ^ ~~~~~~~~~~~~~~~\n\
    /tmp/tmpd29aw7hc.swift:17:19: note: overloads for '+' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        pos = pos + substring.count\n\
    \                  ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let count =\
    \ substring.characters.reduce(0) { (result, element) -> Int in\n        if let\
    \ index = string.characters.index(of: element),\n           index != NSNotFound\n\
    \        {\n            return result + 1\n        }\n        return result\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdti3uzyz.swift:12:21: error: cannot find 'NSNotFound' in scope\n\
    \           index != NSNotFound\n                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    guard string.hasSuffix(substring)\
    \ && string.hasPrefix(substring) else {\n        return 0\n    }\n    return string.countSubstrings(substring)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwq1g7cpb.swift:13:19: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    return string.countSubstrings(substring)\n          \
    \ ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    return count_substring(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp053d206r.swift:10:12: error: cannot find 'count_substring' in scope\n\
    \    return count_substring(string, substring)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009227
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let char_count\
    \ = string.characters.count\n    let substring_index = string.range(of: substring)\n\
    \    return char_count.distance(to: substring_index.upperBound)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4jfutj_0.swift:10:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    let char_count = string.characters.count\n        \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4jfutj_0.swift:11:34: error: value of type 'String' has no member\
    \ 'range'\n    let substring_index = string.range(of: substring)\n           \
    \               ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let start =\
    \ string.startIndex.advancedBy(substring.startIndex, offsetBy: 0)\n    let end\
    \ = string.endIndex.advancedBy(substring.endIndex, offsetBy: 0)\n    return countSubstring(string,\
    \ start: start, end: end) - countSubstring(string, start: start, end: start) +\
    \ 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(how_many_times(string: \"\",\
    \ substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5dmy3ln0.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex,\
    \ offsetBy: 0)\n                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5dmy3ln0.swift:11:31:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let end\
    \ = string.endIndex.advancedBy(substring.endIndex, offsetBy: 0)\n            \
    \  ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5dmy3ln0.swift:12:12: error: cannot find\
    \ 'countSubstring' in scope\n    return countSubstring(string, start: start, end:\
    \ end) - countSubstring(string, start: start, end: start) + 1\n           ^~~~~~~~~~~~~~\n\
    /tmp/tmp5dmy3ln0.swift:12:61: error: cannot find 'countSubstring' in scope\n \
    \   return countSubstring(string, start: start, end: end) - countSubstring(string,\
    \ start: start, end: start) + 1\n                                            \
    \                ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if string ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n\n    let string_lowercase\
    \ = string.lowercased()\n\n    var position = 0\n    var count = 0\n    var i\
    \ = 0\n\n    for i = position_of_substring_in_lowercase(string: string_lowercase,\
    \ substring: substring)\n        ; i < string.length && string.lowercased().contains(substring);\
    \ i++ {\n        let position_substring_lowercase = string_lowercase.distance(from:\
    \ string.lowercased()[position], to: string.lowercased()[i])\n\n        let position_substring\
    \ = substring.distance(from: string[position], to: string[i])\n        count =\
    \ count + min(position_substring, position_substring_lowercase)\n\n        if\
    \ position_substring < position_substring_lowercase {\n            position =\
    \ i\n        }\n    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2ikb_ktd.swift:20:11: error: expected 'in' after for-each pattern\n\
    \    for i = position_of_substring_in_lowercase(string: string_lowercase, substring:\
    \ substring)\n          ^\n/tmp/tmp2ikb_ktd.swift:20:11: error: expected Sequence\
    \ expression for for-each loop\n    for i = position_of_substring_in_lowercase(string:\
    \ string_lowercase, substring: substring)\n          ^\n/tmp/tmp2ikb_ktd.swift:22:61:\
    \ error: no exact matches in call to instance method 'distance'\n        let position_substring_lowercase\
    \ = string_lowercase.distance(from: string.lowercased()[position], to: string.lowercased()[i])\n\
    \                                                            ^\n/tmp/tmp2ikb_ktd.swift:22:61:\
    \ note: found candidate with type '(String.Index, String.Index) -> Int'\n    \
    \    let position_substring_lowercase = string_lowercase.distance(from: string.lowercased()[position],\
    \ to: string.lowercased()[i])\n                                              \
    \              ^\n/tmp/tmp2ikb_ktd.swift:24:44: error: no exact matches in call\
    \ to instance method 'distance'\n        let position_substring = substring.distance(from:\
    \ string[position], to: string[i])\n                                         \
    \  ^\n/tmp/tmp2ikb_ktd.swift:24:44: note: found candidate with type '(String.Index,\
    \ String.Index) -> Int'\n        let position_substring = substring.distance(from:\
    \ string[position], to: string[i])\n                                         \
    \  ^\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    // TODO: Optimize\
    \ with String.HasSubstring()\n    if string.IsEmpty() || substrings.ContainsKey(substring)\
    \ {\n        return 0\n    }\n    if string.StartsWith(substring) {\n        return\
    \ substrings[substring] + 1\n    }\n    if string.Contains(substring) {\n    \
    \    return substrings[substring] + 1\n    }\n    if string.EndsWith(substring)\
    \ {\n        return substrings[substring] + 1\n    }\n    if substrings[substring]\
    \ > 0 {\n        return substrings[substring]\n    }\n    return 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp36inblnx.swift:11:28: error: cannot find 'substrings' in scope\n\
    \    if string.IsEmpty() || substrings.ContainsKey(substring) {\n            \
    \               ^~~~~~~~~~\n/tmp/tmp36inblnx.swift:11:15: error: value of type\
    \ 'String' has no member 'IsEmpty'\n    if string.IsEmpty() || substrings.ContainsKey(substring)\
    \ {\n       ~~~~~~ ^~~~~~~\n/tmp/tmp36inblnx.swift:14:15: error: value of type\
    \ 'String' has no member 'StartsWith'\n    if string.StartsWith(substring) {\n\
    \       ~~~~~~ ^~~~~~~~~~\n/tmp/tmp36inblnx.swift:15:16: error: cannot find 'substrings'\
    \ in scope\n        return substrings[substring] + 1\n               ^~~~~~~~~~\n\
    /tmp/tmp36inblnx.swift:17:15: error: value of type 'String' has no member 'Contains'\n\
    \    if string.Contains(substring) {\n       ~~~~~~ ^~~~~~~~\n/tmp/tmp36inblnx.swift:18:16:\
    \ error: cannot find 'substrings' in scope\n        return substrings[substring]\
    \ + 1\n               ^~~~~~~~~~\n/tmp/tmp36inblnx.swift:20:15: error: value of\
    \ type 'String' has no member 'EndsWith'\n    if string.EndsWith(substring) {\n\
    \       ~~~~~~ ^~~~~~~~\n/tmp/tmp36inblnx.swift:21:16: error: cannot find 'substrings'\
    \ in scope\n        return substrings[substring] + 1\n               ^~~~~~~~~~\n\
    /tmp/tmp36inblnx.swift:23:8: error: cannot find 'substrings' in scope\n    if\
    \ substrings[substring] > 0 {\n       ^~~~~~~~~~\n/tmp/tmp36inblnx.swift:24:16:\
    \ error: cannot find 'substrings' in scope\n        return substrings[substring]\n\
    \               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let subStringLen\
    \ = substring.characters.count\n    if subStringLen <= string.characters.count\
    \ {\n        // No need to calculate the length of the original string.\n    \
    \    return subStringLen\n    }\n    let startIdx = string.range(of: substring)\n\
    \    // If substring was not found, return 0 because the substring was not found.\n\
    \    if startIdx == nil { return 0 }\n    // If substring was found, calculate\
    \ the original string length\n    // and subtract the substring length from the\
    \ original string length.\n    var result = 0\n    if let rangeString = string.range(of:\
    \ substring) {\n        result = string.count - rangeString.upperBound - 1\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbfuvl4fw.swift:10:34: error: 'characters' is unavailable: Please\
    \ use String directly\n    let subStringLen = substring.characters.count\n   \
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbfuvl4fw.swift:11:31: error: 'characters' is unavailable:\
    \ Please use String directly\n    if subStringLen <= string.characters.count {\n\
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbfuvl4fw.swift:15:27: error: value of type 'String'\
    \ has no member 'range'\n    let startIdx = string.range(of: substring)\n    \
    \               ~~~~~~ ^~~~~\n/tmp/tmpbfuvl4fw.swift:21:33: error: value of type\
    \ 'String' has no member 'range'\n    if let rangeString = string.range(of: substring)\
    \ {\n                         ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n\tvar count = 0\n\
    \tlet start = string.startIndex.advanced(by: substring.startIndex)\n\tlet end\
    \ = string.endIndex.advanced(by: substring.endIndex)\n\tlet stringLength = string.characters.count\n\
    \tlet substringLength = substring.characters.count\n\t\n\tif substringLength >\
    \ stringLength {\n\t\tsubstring = substring.replacingOccurrences(of: String(repeating:\
    \ substring[substringLength], count: stringLength - substringLength), with: \"\
    \")\n\t}\n\n\tif substringLength > 0 && substringLength <= stringLength {\n\t\t\
    if start >= 0 && end <= stringLength && start < end {\n\t\t\tif string[start]!\
    \ == substring[0] {\n\t\t\t\tcount += substringLength - 1\n\t\t\t\tlet substringLength\
    \ = substring.characters.count\n\t\t\t\tif substringLength > 1 {\n\t\t\t\t\tlet\
    \ substringLength = substring.characters.count\n\t\t\t\t\tif substringLength >\
    \ 1 {\n\t\t\t\t\t\tif string[start+1] == substring[1] {\n\t\t\t\t\t\t\tcount +=\
    \ substringLength - 2\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t}\n\t\n\treturn count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpoh1p51xt.swift:11:32: error: value of type 'String.Index' has no\
    \ member 'advanced'\n        let start = string.startIndex.advanced(by: substring.startIndex)\n\
    \                    ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpoh1p51xt.swift:12:28:\
    \ error: value of type 'String.Index' has no member 'advanced'\n        let end\
    \ = string.endIndex.advanced(by: substring.endIndex)\n                  ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n/tmp/tmpoh1p51xt.swift:13:28: error: 'characters' is unavailable:\
    \ Please use String directly\n        let stringLength = string.characters.count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpoh1p51xt.swift:14:34: error: 'characters' is unavailable:\
    \ Please use String directly\n        let substringLength = substring.characters.count\n\
    \                                        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpoh1p51xt.swift:17:25: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n                substring = substring.replacingOccurrences(of:\
    \ String(repeating: substring[substringLength], count: stringLength - substringLength),\
    \ with: \"\")\n                            ~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoh1p51xt.swift:17:3:\
    \ error: cannot assign to value: 'substring' is a 'let' constant\n           \
    \     substring = substring.replacingOccurrences(of: String(repeating: substring[substringLength],\
    \ count: stringLength - substringLength), with: \"\")\n                ^~~~~~~~~\n\
    /tmp/tmpoh1p51xt.swift:22:20: error: cannot force unwrap value of non-optional\
    \ type 'Character'\n                        if string[start]! == substring[0]\
    \ {\n                           ~~~~~~~~~~~~~^\n                             \
    \           \n/tmp/tmpoh1p51xt.swift:24:37: error: 'characters' is unavailable:\
    \ Please use String directly\n                                let substringLength\
    \ = substring.ch"
  stdout: ''
  timestamp: 1660009312
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    if substring.isEmpty\
    \ {\n        return 0\n    }\n    var count = 0\n    for c in string {\n     \
    \   if c == substring {\n            count += 1\n        } else if c.isUpper()\
    \ {\n            if count > 0 {\n                count -= 1\n            }\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmjac4ptg.swift:15:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == substring {\n\
    \           ~ ^  ~~~~~~~~~\n/tmp/tmpmjac4ptg.swift:15:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == substring {\n             ^\n/tmp/tmpmjac4ptg.swift:17:21:\
    \ error: value of type 'Character' has no member 'isUpper'\n        } else if\
    \ c.isUpper() {\n                  ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009311
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
    \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
    \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n    let index =\
    \ string.firstIndex(of: substring)\n    if index == nil {\n        return 0\n\
    \    } else {\n        return 1 + count(string, fromIndex: index!, toIndex: string.endIndex,\
    \ substring: substring)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpux768pmp.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n\
    /tmp/tmpux768pmp.swift:14:20: error: cannot find 'count' in scope\n        return\
    \ 1 + count(string, fromIndex: index!, toIndex: string.endIndex, substring: substring)\n\
    \                   ^~~~~\n"
  stdout: ''
  timestamp: 1660009311
