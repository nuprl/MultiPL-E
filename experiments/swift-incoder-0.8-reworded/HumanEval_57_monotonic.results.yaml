language: swift
name: HumanEval_57_monotonic
results:
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicWithCheck(l: l, check: { _ in true })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp81d20sux.swift:10:12: error: cannot find 'monotonicWithCheck' in\
    \ scope\n    return monotonicWithCheck(l: l, check: { _ in true })\n         \
    \  ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return _monotonic_impl.invoke1(l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcg26toyp.swift:10:10: error: cannot find '_monotonic_impl' in scope\n\
    \  return _monotonic_impl.invoke1(l)\n         ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tif l == nil || l.isEmpty {\n\t\treturn true\n\t}\n\tl +=\
    \ l[l.startIndex]\n\treturn l[0] > l[l.startIndex-1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_grnv_kf.swift:10:7: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n        if l == nil || l.isEmpty {\n\
    \           ~ ^  ~~~\n/tmp/tmp_grnv_kf.swift:13:2: error: cannot convert value\
    \ of type '[Int]' to expected argument type 'Int'\n        l += l[l.startIndex]\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonic(l, options: .strictlyIncreasing)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmptwihml5j.swift:10:32: error: extra argument 'options' in call\n\
    \        return monotonic(l, options: .strictlyIncreasing)\n                 \
    \       ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmptwihml5j.swift:10:32: error:\
    \ cannot infer contextual base in reference to member 'strictlyIncreasing'\n \
    \       return monotonic(l, options: .strictlyIncreasing)\n                  \
    \                   ~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 0: return true\n\tcase 1: return\
    \ l[0] > l[1]\n\tcase 2: return l[0] < l[1]\n\tdefault: return l[0] < l[1] &&\
    \ l[1] < l[2]\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpmdmwe7ue/tmpmdmwe7ue.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab16fa79c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab16f770b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab16f770988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab16f76f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmdmwe7ue                        0x000055732cbb8621 <unavailable> + 5665

    5    libc.so.6                          0x00002ab16fc65460 __libc_start_main +
    245

    6    tmpmdmwe7ue                        0x000055732cbb8019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let len = l.count\n    if len == 1 {\n        return true\n\
    \    }\n    var prev = -128\n    var cur = Int64(0)\n    for i in 0..<len - 1\
    \ {\n        cur = Int64(l.count) + Int64(prev)\n        prev = cur\n    }\n \
    \   return cur <= 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_uus8kbj.swift:18:16: error: cannot assign value of type 'Int64'\
    \ to type 'Int'\n        prev = cur\n               ^~~\n               Int( )\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicImpl(l, compareToFunc: lessThan)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpybu9radv.swift:10:12: error: cannot find 'monotonicImpl' in scope\n\
    \    return monotonicImpl(l, compareToFunc: lessThan)\n           ^~~~~~~~~~~~~\n\
    /tmp/tmpybu9radv.swift:10:44: error: cannot find 'lessThan' in scope\n    return\
    \ monotonicImpl(l, compareToFunc: lessThan)\n                                \
    \           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    // If l has same length, then monotonic can be determined\
    \ by comparing corresponding pairs of elements\n    // If l has different length,\
    \ then monotonic can only be determined by comparing corresponding pairs of elements\n\
    \    if len(l) <= 1 {\n        return true\n    }\n\n    if l.count == 2 {\n \
    \       let (lhs, rhs) = l\n        return lhs > rhs || lhs < rhs\n    }\n\n \
    \   var lhs = l[0]\n    var rhs = l[1]\n    for i in 1..<l.count {\n        let\
    \ (lhsNext, rhsNext) = l[i]\n        if lhsNext < rhs {\n            return false\n\
    \        } else if lhsNext > rhs {\n            return true\n        }\n     \
    \   lhs = lhsNext\n        rhs = rhsNext\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpaak9zbn1.swift:12:8: error: cannot find 'len' in scope\n    if\
    \ len(l) <= 1 {\n       ^~~\n/tmp/tmpaak9zbn1.swift:17:26: error: cannot convert\
    \ value of type '[Int]' to specified type '(_, _)'\n        let (lhs, rhs) = l\n\
    \                         ^\n/tmp/tmpaak9zbn1.swift:24:35: error: cannot convert\
    \ value of type 'Int' to specified type '(_, _)'\n        let (lhsNext, rhsNext)\
    \ = l[i]\n                                 ~^~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  if l.isEmpty() {\n    return true\n  }\n\n  var lmax = l.max()\n\
    \  if lmax > l.first {\n    return false\n  }\n\n  var umax = l.last\n  if umax\
    \ < l.first {\n    return false\n  }\n\n  var i, imax = umax, imin = lmax\n  for\
    \ i = 1, i < imax {\n    let lv = l[i]\n    let uv = umax\n    while (uv < l &&\
    \ lv <= uv) {\n      uv = l[umax]\n    }\n    if uv < l {\n      imin = i\n  \
    \  }\n    if umax < i {\n      lmax = i\n    }\n  }\n  return imax == imin\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3j4bljie.swift:25:9: error: expected 'in' after for-each pattern\n\
    \  for i = 1, i < imax {\n        ^\n/tmp/tmp3j4bljie.swift:25:9: error: expected\
    \ Sequence expression for for-each loop\n  for i = 1, i < imax {\n        ^\n\
    /tmp/tmp3j4bljie.swift:10:8: error: cannot call value of non-function type 'Bool'\n\
    \  if l.isEmpty() {\n       ^      ~~\n              \n/tmp/tmp3j4bljie.swift:15:11:\
    \ error: binary operator '>' cannot be applied to two 'Int?' operands\n  if lmax\
    \ > l.first {\n     ~~~~ ^ ~~~~~~~\n/tmp/tmp3j4bljie.swift:15:11: note: overloads\
    \ for '>' exist with these partially matching parameter lists: (Int, Int)\n  if\
    \ lmax > l.first {\n          ^\n/tmp/tmp3j4bljie.swift:20:11: error: binary operator\
    \ '<' cannot be applied to two 'Int?' operands\n  if umax < l.first {\n     ~~~~\
    \ ^ ~~~~~~~\n/tmp/tmp3j4bljie.swift:20:11: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n  if umax < l.first {\n\
    \          ^\n/tmp/tmp3j4bljie.swift:24:7: error: type annotation missing in pattern\n\
    \  var i, imax = umax, imin = lmax\n      ^\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let length = l.count\n    if length < 2 { return true\
    \ }\n\n    var lastValue = l[0]\n    for x in l.dropFirst() {\n        if x >\
    \ lastValue { return false }\n        lastValue = x\n    }\n\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpif87nrvn/tmpif87nrvn.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b104d271c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b104cf68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b104cf68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b104cf677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpif87nrvn                        0x0000556e00700612 <unavailable> + 5650

    5    libc.so.6                          0x00002b104d45d460 __libc_start_main +
    245

    6    tmpif87nrvn                        0x0000556e00700279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonic(l, lessThan)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprlyb9znr.swift:10:25: error: cannot find 'lessThan' in scope\n\
    \    return monotonic(l, lessThan)\n                        ^~~~~~~~\n/tmp/tmprlyb9znr.swift:10:25:\
    \ error: extra argument in call\n    return monotonic(l, lessThan)\n         \
    \           ~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonicWithOptionsHelper(l, .IgnoreNonincreasing)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprgc6odxx.swift:10:10: error: cannot find 'monotonicWithOptionsHelper'\
    \ in scope\n  return monotonicWithOptionsHelper(l, .IgnoreNonincreasing)\n   \
    \      ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprgc6odxx.swift:10:41: error: cannot\
    \ infer contextual base in reference to member 'IgnoreNonincreasing'\n  return\
    \ monotonicWithOptionsHelper(l, .IgnoreNonincreasing)\n                      \
    \                 ~^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var max: Int = 0\n  var min: Int = 0\n  for _ in 0 ..< l.count\
    \ {\n    let cur = l.max()\n    if cur > max { max = cur }\n    if cur < min {\
    \ min = cur }\n  }\n  guard min < max else { return false }\n  for _ in 0 ..<\
    \ l.count {\n    if l[max] < l[min] { return false }\n  }\n  return true\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpodvdodiw.swift:14:8: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    if cur > max { max = cur }\n    \
    \   ^\n/tmp/tmpodvdodiw.swift:14:8: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n    if cur > max { max = cur }\n   \
    \    ^\n           ?? <#default value#>\n/tmp/tmpodvdodiw.swift:14:8: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    if cur\
    \ > max { max = cur }\n       ^\n          !\n/tmp/tmpodvdodiw.swift:14:26: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \   if cur > max { max = cur }\n                         ^\n/tmp/tmpodvdodiw.swift:14:26:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if cur > max { max = cur }\n                         ^\n        \
    \                     ?? <#default value#>\n/tmp/tmpodvdodiw.swift:14:26: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    if cur > max { max = cur }\n                         ^\n                \
    \            !\n/tmp/tmpodvdodiw.swift:15:8: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    if cur < min { min = cur }\n\
    \       ^\n/tmp/tmpodvdodiw.swift:15:8: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n    if cur < min { min = cur\
    \ }\n       ^\n           ?? <#default value#>\n/tmp/tmpodvdodiw.swift:15:8: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    if cur < min { min = cur }\n       ^\n          !\n/tmp/tmpodvdodiw.swift:15:26:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    if cur < min { min = cur }\n                         ^\n/tmp/tmpodvdodiw.swift:15:26:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if cur < min { min = cur }\n                         ^\n        \
    \                     ?? <#default value#>\n/tmp/tmpodvdodiw.swift:15:26: note:\
    \ force-unwrap using '!"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  switch l.count {\n  case 1: return true\n  case 0: return\
    \ false\n  default:\n    let l = l.slice()\n    var inc = true\n    var dec =\
    \ true\n    for idx in 0..<l.count {\n      let value = l[idx]\n      if value\
    \ > l[idx - 1] {\n        inc = false\n        break\n      }\n      if value\
    \ < l[idx - 1] {\n        dec = false\n        break\n      }\n    }\n    return\
    \ inc || dec\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuk90ginb.swift:14:15: error: value of type '[Int]' has no member\
    \ 'slice'\n    let l = l.slice()\n            ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var a = l\n  var b = l\n  for i := 0; i < len(a); i++ {\n\
    \    for j := 1; j < len(a); j++ {\n      if a[i] < a[j] {\n        a, b = b,\
    \ a\n      }\n      if a[i] > a[j] {\n        a, b = b, a\n      }\n    }\n  }\n\
    \  return b == a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc24p6sd_.swift:12:10: error: expected type\n  for i := 0; i < len(a);\
    \ i++ {\n         ^\n          <#type#>\n/tmp/tmpc24p6sd_.swift:12:10: error:\
    \ expected 'in' after for-each pattern\n  for i := 0; i < len(a); i++ {\n    \
    \     ^\n/tmp/tmpc24p6sd_.swift:12:10: error: expected Sequence expression for\
    \ for-each loop\n  for i := 0; i < len(a); i++ {\n         ^\n/tmp/tmpc24p6sd_.swift:13:12:\
    \ error: expected type\n    for j := 1; j < len(a); j++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmpc24p6sd_.swift:13:12: error: expected 'in' after for-each\
    \ pattern\n    for j := 1; j < len(a); j++ {\n           ^\n/tmp/tmpc24p6sd_.swift:13:12:\
    \ error: expected Sequence expression for for-each loop\n    for j := 1; j < len(a);\
    \ j++ {\n           ^\n/tmp/tmpc24p6sd_.swift:15:10: error: consecutive statements\
    \ on a line must be separated by ';'\n        a, b = b, a\n         ^\n      \
    \   ;\n/tmp/tmpc24p6sd_.swift:15:10: error: expected expression\n        a, b\
    \ = b, a\n         ^\n/tmp/tmpc24p6sd_.swift:18:10: error: consecutive statements\
    \ on a line must be separated by ';'\n        a, b = b, a\n         ^\n      \
    \   ;\n/tmp/tmpc24p6sd_.swift:18:10: error: expected expression\n        a, b\
    \ = b, a\n         ^\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var i = 0\n    for x in l {\n        if x > l[i] {\n \
    \           return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpfzoi5jcp/tmpfzoi5jcp.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4857158c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4856e4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4856e4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4856e4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfzoi5jcp                        0x0000564e77c3064e <unavailable> + 5710

    5    libc.so.6                          0x00002b4857344460 __libc_start_main +
    245

    6    tmpfzoi5jcp                        0x0000564e77c30129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicIntsLessThanOrEqualTo(l, l)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe9xqu60s.swift:10:9: error: cannot find 'monotonicIntsLessThanOrEqualTo'\
    \ in scope\n        return monotonicIntsLessThanOrEqualTo(l, l)\n            \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonicWithOptions(l, [])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpi98_xnjk.swift:10:10: error: cannot find 'monotonicWithOptions'\
    \ in scope\n  return monotonicWithOptions(l, [])\n         ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0:\n        return false\n\
    \    case 1:\n        return true\n    default:\n        let max = l.reduce(0){\
    \ max, _ in\n            if max < $1 {\n                max = $1\n           \
    \ }\n            return max\n        }\n        return l.first! < max\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpws6tn7h_.swift:17:22: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments\n            if max < $1\
    \ {\n                     ^\n/tmp/tmpws6tn7h_.swift:18:23: error: anonymous closure\
    \ arguments cannot be used inside a closure that has explicit arguments\n    \
    \            max = $1\n                      ^\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let sorted = l.sorted()\n    if sorted.isEmpty { return\
    \ false }\n    if sorted.first > sorted.last { return true }\n    for i in 0..<(sorted.first..<sorted.last)\
    \ {\n        if sorted[i] < sorted[i-1] { return false }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphz3pr5dv.swift:12:21: error: binary operator '>' cannot be applied\
    \ to two 'Int?' operands\n    if sorted.first > sorted.last { return true }\n\
    \       ~~~~~~~~~~~~ ^ ~~~~~~~~~~~\n/tmp/tmphz3pr5dv.swift:12:21: note: overloads\
    \ for '>' exist with these partially matching parameter lists: (Int, Int)\n  \
    \  if sorted.first > sorted.last { return true }\n                    ^\n/tmp/tmphz3pr5dv.swift:13:31:\
    \ error: type '((Int) throws -> Bool) throws -> Int?' cannot conform to 'Comparable'\n\
    \    for i in 0..<(sorted.first..<sorted.last) {\n                           \
    \   ^\n/tmp/tmphz3pr5dv.swift:13:31: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n    for i in 0..<(sorted.first..<sorted.last)\
    \ {\n                              ^\n/tmp/tmphz3pr5dv.swift:13:31: note: required\
    \ by referencing operator function '..<' on 'Comparable' where 'Self' = '((Int)\
    \ throws -> Bool) throws -> Int?'\n    for i in 0..<(sorted.first..<sorted.last)\
    \ {\n                              ^\n/tmp/tmphz3pr5dv.swift:13:31: error: cannot\
    \ convert value of type 'Range<((Int) throws -> Bool) throws -> Int?>' to expected\
    \ argument type 'Int'\n    for i in 0..<(sorted.first..<sorted.last) {\n     \
    \                         ^\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tif l == nil || len(l) == 0 {\n\t\treturn false\n\t}\n\n\t\
    return arrayLessThan(l, l[0])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpi_y9af9r.swift:10:17: error: cannot find 'len' in scope\n     \
    \   if l == nil || len(l) == 0 {\n                       ^~~\n/tmp/tmpi_y9af9r.swift:14:9:\
    \ error: cannot find 'arrayLessThan' in scope\n        return arrayLessThan(l,\
    \ l[0])\n               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonicWithOptions(l, options: [])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1gdtwh0s.swift:10:10: error: cannot find 'monotonicWithOptions'\
    \ in scope\n  return monotonicWithOptions(l, options: [])\n         ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 0:\n\t\treturn false\n\tcase 1:\n\
    \t\treturn true\n\tdefault:\n\t\tswitch l[0] {\n\t\tcase 0:\n\t\t\tif l[1] < l[0]\
    \ {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif l[1] > l[0] {\n\t\t\t\treturn false\n\
    \t\t\t}\n\t\tcase 1:\n\t\t\treturn false\n\t\tdefault:\n\t\t\tif l[0] < l[1] {\n\
    \t\t\t\treturn true\n\t\t\t}\n\t\t\tif l[0] > l[1] {\n\t\t\t\treturn false\n\t\
    \t\t}\n\t\t}\n\t}\n\tpanic(\"unreachable\")\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2sjxwtl0.swift:35:2: error: cannot find 'panic' in scope\n    \
    \    panic(\"unreachable\")\n        ^~~~~\n"
  stdout: ''
  timestamp: 1660028785
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicOp(l, LessEqual)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp19chtdi9.swift:10:12: error: cannot find 'monotonicOp' in scope\n\
    \    return monotonicOp(l, LessEqual)\n           ^~~~~~~~~~~\n/tmp/tmp19chtdi9.swift:10:27:\
    \ error: cannot find 'LessEqual' in scope\n    return monotonicOp(l, LessEqual)\n\
    \                          ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var monotonic = true\n    var index = 0\n    let length\
    \ = l.count\n    while index < length {\n        if l[index] <= l[index + 1] {\n\
    \            monotonic = true\n        } else {\n            monotonic = false\n\
    \        }\n        index += 1\n    }\n    return monotonic\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b507eee6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b507ebdd561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b507ebdd286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b507ebdd13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b507ebdcbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b507e9dce83 <unavailable> + 188035

    6    tmpkt4ko01g                        0x000055688cdd3a8f <unavailable> + 6799

    7    tmpkt4ko01g                        0x000055688cdd333d <unavailable> + 4925

    8    libc.so.6                          0x00002b507f0d2460 __libc_start_main +
    245

    9    tmpkt4ko01g                        0x000055688cdd3019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  if l.isEmpty() {\n    return true\n  }\n  var pointer =\
    \ l[0]\n  for element in l[1..] {\n    if element < pointer {\n      return false\n\
    \    }\n    pointer = element\n  }\n  return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3ggcqv85.swift:10:8: error: cannot call value of non-function type\
    \ 'Bool'\n  if l.isEmpty() {\n       ^      ~~\n              \n/tmp/tmp3ggcqv85.swift:14:21:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n  for element\
    \ in l[1..] {\n                    ^~\n                    ...\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 1:\n\t\treturn l[0] >= l[1]\n\t\
    case 2:\n\t\treturn l[0] > l[1] && l[0] >= l[1]\n\tdefault:\n\t\tvar a [Int] =\
    \ Array(l.prefix(1))\n\t\tvar b [Int] = Array(l.suffix(1))\n\t\tfor len(a) > 0\
    \ && len(b) > 0 {\n\t\t\tif a[0] < b[0] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\
    \tif a[0] == b[0] && a[1] > b[1] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif a[0]\
    \ > b[0] && a[1] < b[1] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif a[0] == b[0]\
    \ && a[1] < b[1] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif a[0] < b[0] && a[1]\
    \ == b[1] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1ig13lkq.swift:16:8: error: consecutive statements on a line must\
    \ be separated by ';'\n                var a [Int] = Array(l.prefix(1))\n    \
    \                 ^\n                     ;\n/tmp/tmp1ig13lkq.swift:17:8: error:\
    \ consecutive statements on a line must be separated by ';'\n                var\
    \ b [Int] = Array(l.suffix(1))\n                     ^\n                     ;\n\
    /tmp/tmp1ig13lkq.swift:18:10: error: expected 'in' after for-each pattern\n  \
    \              for len(a) > 0 && len(b) > 0 {\n                       ^\n/tmp/tmp1ig13lkq.swift:16:7:\
    \ error: type annotation missing in pattern\n                var a [Int] = Array(l.prefix(1))\n\
    \                    ^\n/tmp/tmp1ig13lkq.swift:16:9: error: cannot assign to immutable\
    \ expression of type '[Int].Type'\n                var a [Int] = Array(l.prefix(1))\n\
    \                      ^~~~~\n/tmp/tmp1ig13lkq.swift:16:17: error: cannot assign\
    \ value of type 'Array<PrefixSequence<[Int]>.Iterator.Element>' (aka 'Array<Int>')\
    \ to type '[Int].Type'\n                var a [Int] = Array(l.prefix(1))\n   \
    \                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp1ig13lkq.swift:17:7: error:\
    \ type annotation missing in pattern\n                var b [Int] = Array(l.suffix(1))\n\
    \                    ^\n/tmp/tmp1ig13lkq.swift:17:9: error: cannot assign to immutable\
    \ expression of type '[Int].Type'\n                var b [Int] = Array(l.suffix(1))\n\
    \                      ^~~~~\n/tmp/tmp1ig13lkq.swift:17:17: error: cannot assign\
    \ value of type 'Array<Int>' to type '[Int].Type'\n                var b [Int]\
    \ = Array(l.suffix(1))\n                              ^~~~~~~~~~~~~~~~~~\n/tmp/tmp1ig13lkq.swift:18:21:\
    \ error: cannot find 'len' in scope\n                for len(a) > 0 && len(b)\
    \ > 0 {\n                                  ^~~\n/tmp/tmp1ig13lkq.swift:18:18:\
    \ error: for-in loop requires 'Bool' to conform to 'Sequence'\n              \
    \  for len(a) > 0 && len(b) > 0 {\n                       ~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 0:\n\t\treturn false\n\tcase 1:\n\
    \t\treturn true\n\tcase 2:\n\t\tswitch l[0] {\n\t\tcase l[1]:\n\t\t\treturn false\n\
    \t\t}\n\tdefault:\n\t\tswitch {\n\t\tcase l[0] <= l[1]:\n\t\t\treturn false\n\t\
    \tcase l[0] < l[1]:\n\t\t\treturn true\n\t\tcase l[0] == l[1]:\n\t\t\tswitch {\n\
    \t\t\tcase l.count == 3:\n\t\t\t\treturn l[2] <= l[1]\n\t\t\tcase l.count == 2:\n\
    \t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\tpanic(\"not reached\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpw47shya_.swift:21:10: error: expected expression in 'switch' statement\n\
    \                switch {\n                       ^\n/tmp/tmpw47shya_.swift:27:11:\
    \ error: expected expression in 'switch' statement\n                        switch\
    \ {\n                               ^\n/tmp/tmpw47shya_.swift:16:3: error: switch\
    \ must be exhaustive\n                switch l[0] {\n                ^\n/tmp/tmpw47shya_.swift:16:3:\
    \ note: do you want to add a default clause?\n                switch l[0] {\n\
    \                ^\n/tmp/tmpw47shya_.swift:35:2: error: cannot find 'panic' in\
    \ scope\n        panic(\"not reached\")\n        ^~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let len = l.count\n    var flag = 0\n    var next = 0\n\
    \    var j = len - 2\n    while j >= 0 {\n        if l[j] < l[j+1] {\n       \
    \     flag = 1\n            next = j\n        } else {\n            if flag ==\
    \ 0 {\n                return false\n            }\n            j = next\n   \
    \     }\n    }\n    return flag == 1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20])\
    \ == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660028791
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 0: return true\n\tcase 1: return\
    \ l[0] > l[1]\n\tdefault:\n\t\tsortAndCheck(l, true)\n\t\treturn l[0] < l[l.count-1]\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) ==\
    \ true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1,\
    \ 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpgqgpknzb.swift:14:3: error: cannot find 'sortAndCheck' in scope\n\
    \                sortAndCheck(l, true)\n                ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l.asCumulative())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpa6hxejqr.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l.asCumulative())\n           ^~~~~~~~~~~\n/tmp/tmpa6hxejqr.swift:10:26:\
    \ error: value of type '[Int]' has no member 'asCumulative'\n    return isMonotonic(l.asCumulative())\n\
    \                       ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l) || isMonotonicReverse(l)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9a17bwna.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l) || isMonotonicReverse(l)\n           ^~~~~~~~~~~\n\
    /tmp/tmp9a17bwna.swift:10:30: error: cannot find 'isMonotonicReverse' in scope\n\
    \    return isMonotonic(l) || isMonotonicReverse(l)\n                        \
    \     ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let length = l.count\n    switch length {\n    case 0:\n\
    \        return true\n    case 1:\n        return l[0] > l[1]\n    case 2:\n \
    \       return l[0] > l[1] || l[0] == l[1]\n    default:\n        let min = l[0]\n\
    \        let max = l[0]\n        for i in 1 ..< length {\n            let cur\
    \ = l[i]\n            if cur > max {\n                max = cur\n            }\n\
    \            if cur < min {\n                min = cur\n            }\n      \
    \  }\n        return min <= max\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20])\
    \ == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcvqdhtie.swift:24:17: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n                max = cur\n                ^~~\n/tmp/tmpcvqdhtie.swift:20:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let max = l[0]\n   \
    \     ^~~\n        var\n/tmp/tmpcvqdhtie.swift:27:17: error: cannot assign to\
    \ value: 'min' is a 'let' constant\n                min = cur\n              \
    \  ^~~\n/tmp/tmpcvqdhtie.swift:19:9: note: change 'let' to 'var' to make it mutable\n\
    \        let min = l[0]\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l == nil || l.Count == 0 {\n        return true\n \
    \   }\n\n    // Handle edge cases.\n    if l.Min() < 0 {\n        return false\n\
    \    }\n\n    var min = l.Min()\n    var max = l.Max()\n\n    if min > max {\n\
    \        return false\n    }\n\n    // Check if min is bigger than the biggest\
    \ value in l or is equal to min.\n    for i := 0; i < l.Count; i++ {\n       \
    \ if l.Element(i) == min {\n            return false\n        }\n\n        if\
    \ l.Element(i) > max {\n            return true\n        }\n    }\n\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4,\
    \ 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9hn4exq7.swift:27:12: error: expected type\n    for i := 0; i <\
    \ l.Count; i++ {\n           ^\n            <#type#>\n/tmp/tmp9hn4exq7.swift:27:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < l.Count; i++\
    \ {\n           ^\n/tmp/tmp9hn4exq7.swift:27:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < l.Count; i++ {\n           ^\n/tmp/tmp9hn4exq7.swift:10:22:\
    \ error: value of type '[Int]' has no member 'Count'\n    if l == nil || l.Count\
    \ == 0 {\n                   ~ ^~~~~\n/tmp/tmp9hn4exq7.swift:15:10: error: value\
    \ of type '[Int]' has no member 'Min'\n    if l.Min() < 0 {\n       ~ ^~~\n/tmp/tmp9hn4exq7.swift:19:17:\
    \ error: value of type '[Int]' has no member 'Min'\n    var min = l.Min()\n  \
    \            ~ ^~~\n/tmp/tmp9hn4exq7.swift:20:17: error: value of type '[Int]'\
    \ has no member 'Max'\n    var max = l.Max()\n              ~ ^~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var l = l.map { $0 < $1 ? $0 : -$0 }\n  return l == l.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbdw3r_5k.swift:10:17: error: contextual closure type '(Int) throws\
    \ -> Int' expects 1 argument, but 2 were used in closure body\n  var l = l.map\
    \ { $0 < $1 ? $0 : -$0 }\n                ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return binarySearch(l, isMonotonic)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl_lr4kdy.swift:10:12: error: cannot find 'binarySearch' in scope\n\
    \    return binarySearch(l, isMonotonic)\n           ^~~~~~~~~~~~\n/tmp/tmpl_lr4kdy.swift:10:28:\
    \ error: cannot find 'isMonotonic' in scope\n    return binarySearch(l, isMonotonic)\n\
    \                           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let length = l.count\n    if length == 0 {\n        return\
    \ true\n    }\n    if length == 1 {\n        return l[0] > l[0]\n    }\n    var\
    \ left = 0\n    var right = length - 1\n    var swapped: Bool = false\n\n    while\
    \ left < right {\n        guard left < right && l[left] <= l[right] else { break\
    \ }\n        if l[left] < l[right] {\n            left += 1\n        } else {\n\
    \            right -= 1\n        }\n        if left == right {\n            break\n\
    \        }\n        if l[left] > l[right] {\n            if left > 0 {\n     \
    \           left -= 1\n            } else {\n                right += 1\n    \
    \        }\n        } else {\n            if left < length - 1 {\n           \
    \     left += 1\n            } else {\n                right -= 1\n          \
    \  }\n        }\n        swapped = l[left] > l[right]\n    }\n    return !swapped\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660028791
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicSequence(l, isIncreasing)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcqzowdkf.swift:10:12: error: cannot find 'monotonicSequence' in\
    \ scope\n    return monotonicSequence(l, isIncreasing)\n           ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmpcqzowdkf.swift:10:33: error: cannot find 'isIncreasing' in scope\n   \
    \ return monotonicSequence(l, isIncreasing)\n                                ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwd3h19g8.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicRec(l, Int())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn_lk1hdv.swift:10:12: error: cannot find 'monotonicRec' in scope\n\
    \    return monotonicRec(l, Int())\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let sorted = l.sorted()\n    guard !sorted.isEmpty else\
    \ { return true }\n    let last = sorted[0]\n    for e in sorted {\n        if\
    \ e < last {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmp1cav8o1p/tmp1cav8o1p.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeead0b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeeacda7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeeacda7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeeacda67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1cav8o1p                        0x0000557b19df274e <unavailable> + 5966

    5    libc.so.6                          0x00002aeead29c460 __libc_start_main +
    245

    6    tmp1cav8o1p                        0x0000557b19df2229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return l.indices.contains(monotonicIndex(l))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpz63x6nc_.swift:10:31: error: cannot find 'monotonicIndex' in scope\n\
    \    return l.indices.contains(monotonicIndex(l))\n                          \
    \    ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isSorted(l, l: l)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwv19kap6.swift:10:12: error: cannot find 'isSorted' in scope\n\
    \    return isSorted(l, l: l)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var i = 0\n    var max = l.max()\n    for el in l {\n\
    \        if el > max {\n            return false\n        }\n        if el ==\
    \ max {\n            i += 1\n        }\n    }\n    return i == 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpf9x_1ksz.swift:13:17: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if el > max {\n             \
    \   ^\n/tmp/tmpf9x_1ksz.swift:13:17: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        if el > max {\n            \
    \    ^\n                    ?? <#default value#>\n/tmp/tmpf9x_1ksz.swift:13:17:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if el > max {\n                ^\n                   !\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  // FIXME: Switch this to i32 once we require Swift 4.2\n\
    \  let n = (l.count + 1) * (l.count + 1) / 2\n  let max = Float.greatestFiniteMagnitude\n\
    \  var current = 0\n  for idx in 0..<n {\n    let left = current\n    let right\
    \ = current + l.count - 1\n    let value = l[left]\n    while right >= left {\n\
    \      if l[right] > value {\n        break\n      }\n      current += 1\n   \
    \   right -= 1\n    }\n    if current > max {\n      current = value\n    }\n\
    \  }\n  return current <= max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkr2nw_dt.swift:23:13: error: left side of mutating operator isn't\
    \ mutable: 'right' is a 'let' constant\n      right -= 1\n      ~~~~~ ^\n/tmp/tmpkr2nw_dt.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let right = current + l.count\
    \ - 1\n    ^~~\n    var\n/tmp/tmpkr2nw_dt.swift:25:16: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'Float'\n    if current\
    \ > max {\n       ~~~~~~~ ^ ~~~\n/tmp/tmpkr2nw_dt.swift:25:16: note: overloads\
    \ for '>' exist with these partially matching parameter lists: (Int, Int)\n  \
    \  if current > max {\n               ^\n/tmp/tmpkr2nw_dt.swift:29:18: error:\
    \ binary operator '<=' cannot be applied to operands of type 'Int' and 'Float'\n\
    \  return current <= max\n         ~~~~~~~ ^  ~~~\n/tmp/tmpkr2nw_dt.swift:29:18:\
    \ note: overloads for '<=' exist with these partially matching parameter lists:\
    \ (Int, Int)\n  return current <= max\n                 ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return checkForMonotonic(l: l)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpkqbmq1hm.swift:10:12: error: cannot find 'checkForMonotonic' in\
    \ scope\n    return checkForMonotonic(l: l)\n           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonic(l, lessOrEqual)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpju7ac_1w.swift:10:23: error: cannot find 'lessOrEqual' in scope\n\
    \  return monotonic(l, lessOrEqual)\n                      ^~~~~~~~~~~\n/tmp/tmpju7ac_1w.swift:10:23:\
    \ error: extra argument in call\n  return monotonic(l, lessOrEqual)\n        \
    \          ~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicOp(l, LessOrEqual)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmj504vdf.swift:10:12: error: cannot find 'monotonicOp' in scope\n\
    \    return monotonicOp(l, LessOrEqual)\n           ^~~~~~~~~~~\n/tmp/tmpmj504vdf.swift:10:27:\
    \ error: cannot find 'LessOrEqual' in scope\n    return monotonicOp(l, LessOrEqual)\n\
    \                          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonicR(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp79twyqux.swift:10:10: error: cannot find 'monotonicR' in scope\n\
    \  return monotonicR(l)\n         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var minElement = l[0]\n  var maxElement = l[0]\n  for idx\
    \ in 1..<l.count {\n    if l[idx] < minElement {\n      minElement = l[idx]\n\
    \    }\n    if l[idx] > maxElement {\n      maxElement = l[idx]\n    }\n  }\n\
    \  return maxElement < minElement\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmp_uq1wyla/tmp_uq1wyla.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4386738c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b438642fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b438642f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b438642e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_uq1wyla                        0x0000559ac3ce3542 <unavailable> + 5442

    5    libc.so.6                          0x00002b4386924460 __libc_start_main +
    245

    6    tmp_uq1wyla                        0x0000559ac3ce31a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonic(l, true)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpd9fgkbwi.swift:10:22: error: extra argument in call\n        return\
    \ monotonic(l, true)\n                        ~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicImpl(l, l.startIndex, l.endIndex - l.startIndex)\
    \ >= 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4,\
    \ 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpp0bj7wpv.swift:10:12: error: cannot find 'monotonicImpl' in scope\n\
    \    return monotonicImpl(l, l.startIndex, l.endIndex - l.startIndex) >= 0\n \
    \          ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var monotonic = true\n    var prev = l[0]\n    for v in\
    \ l {\n        if monotonic == false {\n            return false\n        }\n\
    \        if v < prev {\n            monotonic = false\n        } else {\n    \
    \        prev = v\n        }\n    }\n    return monotonic\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmp3y86akxb/tmp3y86akxb.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b578d0bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b578cdb5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b578cdb5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b578cdb47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3y86akxb                        0x00005569af173731 <unavailable> + 5937

    5    libc.so.6                          0x00002b578d2aa460 __libc_start_main +
    245

    6    tmp3y86akxb                        0x00005569af173129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var l = l.slice()\n    var sorted = false\n    var curr,\
    \ prev Int?\n    for i := 0; i < len(l); i++ {\n        curr = l[i]\n        prev\
    \ = curr\n        if prev == nil {\n            sorted = true\n            l[i]\
    \ = nil\n        } else {\n            if curr == nil {\n                l[i]\
    \ = prev\n            } else {\n                if curr < prev {\n           \
    \         sorted = true\n                    l[i] = nil\n                } else\
    \ {\n                    prev =  curr\n                }\n            }\n    \
    \    }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpak9pbnsz.swift:12:20: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n    var curr, prev Int?\n\
    \                   ^\n/tmp/tmpak9pbnsz.swift:12:20: note: join the identifiers\
    \ together\n    var curr, prev Int?\n              ~~~~~^~~\n              prevInt\n\
    /tmp/tmpak9pbnsz.swift:12:23: error: consecutive statements on a line must be\
    \ separated by ';'\n    var curr, prev Int?\n                      ^\n       \
    \               ;\n/tmp/tmpak9pbnsz.swift:12:23: error: expected expression\n\
    \    var curr, prev Int?\n                      ^\n/tmp/tmpak9pbnsz.swift:13:12:\
    \ error: expected type\n    for i := 0; i < len(l); i++ {\n           ^\n    \
    \        <#type#>\n/tmp/tmpak9pbnsz.swift:13:12: error: expected 'in' after for-each\
    \ pattern\n    for i := 0; i < len(l); i++ {\n           ^\n/tmp/tmpak9pbnsz.swift:13:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < len(l);\
    \ i++ {\n           ^\n/tmp/tmpak9pbnsz.swift:10:15: error: value of type '[Int]'\
    \ has no member 'slice'\n    var l = l.slice()\n            ~ ^~~~~\n/tmp/tmpak9pbnsz.swift:12:9:\
    \ error: type annotation missing in pattern\n    var curr, prev Int?\n       \
    \ ^\n/tmp/tmpak9pbnsz.swift:12:15: error: type annotation missing in pattern\n\
    \    var curr, prev Int?\n              ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0: return true\n    case 1:\
    \ return (l[0] > l[1])\n    case 2: return (l[0] > l[1]) || ((l[0] == l[1]) &&\
    \ (l[0] > 0))\n    default: return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpkfewkl8r/tmpkfewkl8r.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b831d635c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b831d32cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b831d32c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b831d32b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkfewkl8r                        0x000055a3e37e03b2 <unavailable> + 5042

    5    libc.so.6                          0x00002b831d821460 __libc_start_main +
    245

    6    tmpkfewkl8r                        0x000055a3e37e0019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicImpl(l, l, 0, true)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp03uuzeuq.swift:10:12: error: cannot find 'monotonicImpl' in scope\n\
    \    return monotonicImpl(l, l, 0, true)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var i = 0\n    var n = l.count\n    while i < n {\n  \
    \      var j = n - 1\n        while j > i {\n            if l[i] <= l[j] {\n \
    \               i += 1\n            } else {\n                j -= 1\n       \
    \     }\n        }\n        if i < j {\n            l.swap(i, j)\n           \
    \ i += 1\n        }\n    }\n    return i == n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjrxrrgdl.swift:22:15: error: value of type '[Int]' has no member\
    \ 'swap'\n            l.swap(i, j)\n            ~ ^~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonicSorted(l, isMonotonic)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqdnxqky8.swift:10:10: error: cannot find 'monotonicSorted' in scope\n\
    \  return monotonicSorted(l, isMonotonic)\n         ^~~~~~~~~~~~~~~\n/tmp/tmpqdnxqky8.swift:10:29:\
    \ error: cannot find 'isMonotonic' in scope\n  return monotonicSorted(l, isMonotonic)\n\
    \                            ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicFunc(l, areInIncreasingOrder)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqwf2jj1l.swift:10:12: error: cannot find 'monotonicFunc' in scope\n\
    \    return monotonicFunc(l, areInIncreasingOrder)\n           ^~~~~~~~~~~~~\n\
    /tmp/tmpqwf2jj1l.swift:10:29: error: cannot find 'areInIncreasingOrder' in scope\n\
    \    return monotonicFunc(l, areInIncreasingOrder)\n                         \
    \   ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var sorted = false\n    var prev = 0\n    for ii in 0..<l.count\
    \ {\n        if !sorted {\n            sorted = true\n            prev = bsearch(l[ii],\
    \ l, 0)\n        }\n        if prev == ii {\n            continue\n        }\n\
    \        if l[ii] < l[prev] {\n            return false\n        } else {\n  \
    \          return true\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe6ykugv3.swift:15:20: error: cannot find 'bsearch' in scope\n \
    \           prev = bsearch(l[ii], l, 0)\n                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tl := l.slice()\n\tsort.Sort(&l)\n\treturn isIncreasing(l)\
    \ || isDecreasing(l)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpanpo9ngs.swift:10:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        l := l.slice()\n         ^\n         ;\n/tmp/tmpanpo9ngs.swift:10:4:\
    \ error: expected expression\n        l := l.slice()\n          ^\n/tmp/tmpanpo9ngs.swift:10:2:\
    \ warning: expression of type '[Int]' is unused\n        l := l.slice()\n    \
    \    ^\n/tmp/tmpanpo9ngs.swift:12:9: error: cannot find 'isIncreasing' in scope\n\
    \        return isIncreasing(l) || isDecreasing(l)\n               ^~~~~~~~~~~~\n\
    /tmp/tmpanpo9ngs.swift:12:28: error: cannot find 'isDecreasing' in scope\n   \
    \     return isIncreasing(l) || isDecreasing(l)\n                            \
    \      ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicWithContext(context.Background(), l)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbokcw3c4.swift:10:9: error: cannot find 'monotonicWithContext'\
    \ in scope\n        return monotonicWithContext(context.Background(), l)\n   \
    \            ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbokcw3c4.swift:10:30: error: cannot\
    \ find 'context' in scope\n        return monotonicWithContext(context.Background(),\
    \ l)\n                                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  switch l.count{\n  case 0: return true\n  case 1: return\
    \ l[0] < l[1]\n  default:\n    if l[0] < l[1]{\n      return false\n    }else{\n\
    \      var i = 0\n      var j = l.count\n      while i < j{\n        if l[i+1]\
    \ > l[i]{\n          return false\n        }\n        i += 2\n      }\n      return\
    \ true\n    }\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpvpvni71k/tmpvpvni71k.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0aa2492c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0aa2189b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0aa2189988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0aa21887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvpvni71k                        0x00005572c1a1a3b2 <unavailable> + 5042

    5    libc.so.6                          0x00002b0aa267e460 __libc_start_main +
    245

    6    tmpvpvni71k                        0x00005572c1a1a019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l == nil {\n        return false\n    }\n    let len\
    \ = l.count\n    let ptr = UnsafeMutablePointer<Int>(OpaquePointer(l._bridgeToObjectiveC()))\n\
    \    var minPtr = ptr\n    var maxPtr = ptr\n    if len > 0 {\n        ptr.advancedBy(0)\n\
    \        minPtr = ptr\n    }\n    ptr.advancedBy(len - 1)\n    maxPtr = ptr\n\
    \    var minValue = Int.min\n    var maxValue = Int.max\n    for idx in 0..<len\
    \ {\n        let v = l[idx]\n        let min = min(minValue, v)\n        let max\
    \ = max(maxValue, v)\n        if min > max {\n            return false\n     \
    \   }\n        minValue = min\n        maxValue = max\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6sv4wfya.swift:10:10: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if l == nil {\n       ~ ^  ~~~\n\
    /tmp/tmp6sv4wfya.swift:14:57: error: value of type '[Int]' has no member '_bridgeToObjectiveC'\n\
    \    let ptr = UnsafeMutablePointer<Int>(OpaquePointer(l._bridgeToObjectiveC()))\n\
    \                                                      ~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicTyped(l, Int64Type, Int64Type)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpshfe4cwx.swift:10:12: error: cannot find 'monotonicTyped' in scope\n\
    \    return monotonicTyped(l, Int64Type, Int64Type)\n           ^~~~~~~~~~~~~~\n\
    /tmp/tmpshfe4cwx.swift:10:30: error: cannot find 'Int64Type' in scope\n    return\
    \ monotonicTyped(l, Int64Type, Int64Type)\n                             ^~~~~~~~~\n\
    /tmp/tmpshfe4cwx.swift:10:41: error: cannot find 'Int64Type' in scope\n    return\
    \ monotonicTyped(l, Int64Type, Int64Type)\n                                  \
    \      ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var results = [Int]()\n  for element in l {\n    results.append(element)\n\
    \  }\n  results.append(0)\n  for i in 0..<results.count {\n    var j = i - 1\n\
    \    while j >= 0 && results[j] > results[i]{\n      j--\n    }\n    if j >= 0\
    \ {\n      if results[i] < results[j] {\n        return false\n      }\n    }\n\
    \  }\n  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9lxoadc5.swift:18:8: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n      j--\n       ^~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  if l.count < 2 { return false }\n  var prev: Int? = nil\n\
    \  for v in l {\n    guard let v = v else {\n      return false\n    }\n    if\
    \ v < prev { return false }\n    prev = v\n  }\n  return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvogw325l.swift:13:11: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n    guard let v = v else {\n          ^\
    \       ~\n/tmp/tmpvogw325l.swift:16:12: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    if v < prev { return false }\n\
    \           ^\n/tmp/tmpvogw325l.swift:16:12: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    if v < prev { return false\
    \ }\n           ^\n                ?? <#default value#>\n/tmp/tmpvogw325l.swift:16:12:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if v < prev { return false }\n           ^\n               !\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count(), l.stride() {\n    case (0 , 0):\n  \
    \      return true\n    case (0 , 1):\n        return true\n    case (0, _):\n\
    \        return true\n    case (1, _):\n        return false\n    }\n    var i,\
    \ j int\n    var lo, hi int\n    for i := 0; i < l.count(); i++ {\n        lo\
    \ = i\n        hi = i\n        for j = i+1; j < l.count(); j++ {\n           \
    \ if l[j] < l[hi] {\n                hi = j\n            }\n        }\n      \
    \  if hi > lo {\n            return false\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1ppo96ck.swift:10:21: error: expected '{' after 'switch' subject\
    \ expression\n    switch l.count(), l.stride() {\n                    ^\n/tmp/tmp1ppo96ck.swift:10:21:\
    \ error: consecutive statements on a line must be separated by ';'\n    switch\
    \ l.count(), l.stride() {\n                    ^\n                    ;\n/tmp/tmp1ppo96ck.swift:10:21:\
    \ error: expected expression\n    switch l.count(), l.stride() {\n           \
    \         ^\n/tmp/tmp1ppo96ck.swift:20:14: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n    var i, j int\n \
    \            ^\n/tmp/tmp1ppo96ck.swift:20:14: note: join the identifiers together\n\
    \    var i, j int\n           ~~^~~\n           jint\n/tmp/tmp1ppo96ck.swift:20:14:\
    \ note: join the identifiers together with camel-case\n    var i, j int\n    \
    \       ~~^~~\n           jInt\n/tmp/tmp1ppo96ck.swift:21:16: error: found an\
    \ unexpected second identifier in variable declaration; is there an accidental\
    \ break?\n    var lo, hi int\n               ^\n/tmp/tmp1ppo96ck.swift:21:16:\
    \ note: join the identifiers together\n    var lo, hi int\n            ~~~^~~\n\
    \            hiint\n/tmp/tmp1ppo96ck.swift:21:16: note: join the identifiers together\
    \ with camel-case\n    var lo, hi int\n            ~~~^~~\n            hiInt\n\
    /tmp/tmp1ppo96ck.swift:22:12: error: expected type\n    for i := 0; i < l.count();\
    \ i++ {\n           ^\n            <#type#>\n/tmp/tmp1ppo96ck.swift:22:12: error:\
    \ expected 'in' after for-each pattern\n    for i := 0; i < l.count(); i++ {\n\
    \           ^\n/tmp/tmp1ppo96ck.swift:22:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < l.count(); i++ {\n           ^\n/tmp/tmp1ppo96ck.swift:25:9:\
    \ error: C-style for statement has been removed in Swift 3\n        for j = i+1;\
    \ j < l.count(); j++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1ppo96ck.swift:10:14:\
    \ error: cannot call value of non-function type 'Int'\n    switch l.count(), l.stride()\
    \ {\n             ^    ~~\n                  \n/tmp/tmp1ppo96ck.swift:20:9: error:\
    \ type annotation missing in pattern\n    var"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicSort(l) == kOrderedSame\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6n5szo1i.swift:10:12: error: cannot find 'monotonicSort' in scope\n\
    \    return monotonicSort(l) == kOrderedSame\n           ^~~~~~~~~~~~~\n/tmp/tmp6n5szo1i.swift:10:32:\
    \ error: cannot find 'kOrderedSame' in scope\n    return monotonicSort(l) == kOrderedSame\n\
    \                               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tif l.isEmpty() {\n\t\treturn true\n\t}\n\tswitch l[0] {\n\
    \tcase l[1]:\n\t\treturn false\n\tcase l[0], l[1]:\n\t\treturn true\n\tcase l[0],\
    \ l[2]:\n\t\treturn true\n\tcase l[1], l[2], l[3]:\n\t\treturn true\n\tcase l[1],\
    \ l[3], l[4]:\n\t\treturn true\n\t}\n\treturn false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph2_kw2gk.swift:10:7: error: cannot call value of non-function type\
    \ 'Bool'\n        if l.isEmpty() {\n             ^      ~~\n                 \
    \   \n/tmp/tmph2_kw2gk.swift:13:2: error: switch must be exhaustive\n        switch\
    \ l[0] {\n        ^\n/tmp/tmph2_kw2gk.swift:13:2: note: do you want to add a default\
    \ clause?\n        switch l[0] {\n        ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicImpl(l, ln, ls)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp62md3gpz.swift:10:9: error: cannot find 'monotonicImpl' in scope\n\
    \        return monotonicImpl(l, ln, ls)\n               ^~~~~~~~~~~~~\n/tmp/tmp62md3gpz.swift:10:26:\
    \ error: cannot find 'ln' in scope\n        return monotonicImpl(l, ln, ls)\n\
    \                                ^~\n/tmp/tmp62md3gpz.swift:10:30: error: cannot\
    \ find 'ls' in scope\n        return monotonicImpl(l, ln, ls)\n              \
    \                      ^~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let length = l.count\n    for i in 0..<length {\n    \
    \    if l[i] < l[i - 1] {\n            return true\n        } else if l[i] > l[i\
    \ - 1] {\n            return false\n        }\n    }\n    return true\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1881ce3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b18819da561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b18819da286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b18819da13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b18819d9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b18817d9e83 <unavailable> + 188035

    6    tmphr3xeg2p                        0x000055cf34713d0c <unavailable> + 7436

    7    tmphr3xeg2p                        0x000055cf347134cd <unavailable> + 5325

    8    libc.so.6                          0x00002b1881ecf460 __libc_start_main +
    245

    9    tmphr3xeg2p                        0x000055cf347131a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    l.sort()\n    for idx, val in\n        l.enumerated()\
    \ where idx > 0 {\n        if val < l[idx - 1] {\n            return false\n \
    \       }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8e639u4k.swift:11:12: error: expected 'in' after for-each pattern\n\
    \    for idx, val in\n           ^\n/tmp/tmp8e639u4k.swift:11:12: error: expected\
    \ Sequence expression for for-each loop\n    for idx, val in\n           ^\n/tmp/tmp8e639u4k.swift:10:7:\
    \ error: cannot use mutating member on immutable value: 'l' is a 'let' constant\n\
    \    l.sort()\n    ~ ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  // For monotonicity we only need to check the first element\n\
    \  let first = l.first!\n  return l.last < first || l.last >= first\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpww0s4yq2.swift:12:12: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n  return l.last < first || l.last >=\
    \ first\n           ^\n/tmp/tmpww0s4yq2.swift:12:12: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n  return l.last\
    \ < first || l.last >= first\n           ^\n                ?? <#default value#>\n\
    /tmp/tmpww0s4yq2.swift:12:12: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n  return l.last < first || l.last >= first\n\
    \           ^\n               !\n/tmp/tmpww0s4yq2.swift:12:30: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n  return l.last\
    \ < first || l.last >= first\n                             ^\n/tmp/tmpww0s4yq2.swift:12:30:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n  return l.last < first || l.last >= first\n                        \
    \     ^\n                                  ?? <#default value#>\n/tmp/tmpww0s4yq2.swift:12:30:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n  return l.last < first || l.last >= first\n                        \
    \     ^\n                                 !\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicSorted(l).count == l.count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpekm2df3n.swift:10:9: error: cannot find 'monotonicSorted' in scope\n\
    \        return monotonicSorted(l).count == l.count\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    guard l.count > 0 else { return false }\n    var lIdx\
    \ = 0\n    var lCount = l.count\n    var lMax = l[l.startIndex]\n    while lIdx\
    \ < lCount {\n        let lCur = l[lIdx]\n        if lCur > lMax {\n         \
    \   lIdx += 1\n            lMax = l[lIdx]\n        } else if lCur < lMax {\n \
    \           lMax -= 1\n        }\n        if lIdx >= lCount {\n            return\
    \ false\n        }\n        lIdx += 1\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2b29d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2b26ce561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac2b26ce286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac2b26ce13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac2b26cdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac2b24cde83 <unavailable> + 188035

    6    tmpg47ofhqg                        0x0000559d2e55fb41 <unavailable> + 6977

    7    tmpg47ofhqg                        0x0000559d2e55f39d <unavailable> + 5021

    8    libc.so.6                          0x00002ac2b2bc3460 __libc_start_main +
    245

    9    tmpg47ofhqg                        0x0000559d2e55f079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    // Check arguments\n    switch l.count {\n    case 0:\
    \ return false\n    case 1: return l[0] >= l[1]\n    default:\n        let m =\
    \ min(l)\n        for i in 1...l.count {\n            if l[i-1] > m+1 || l[i]\
    \ < m-1 {\n                return false\n            }\n        }\n        return\
    \ true\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3ldiyy24.swift:15:22: error: missing argument for parameter #2\
    \ in call\n        let m = min(l)\n                     ^\n                  \
    \   , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l.stride(to: Int32.self))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg6a9qwoa.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l.stride(to: Int32.self))\n           ^~~~~~~~~~~\n/tmp/tmpg6a9qwoa.swift:10:26:\
    \ error: value of type '[Int]' has no member 'stride'\n    return isMonotonic(l.stride(to:\
    \ Int32.self))\n                       ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    // FIXME: should we use the native sort here?\n    return\
    \ sortInplaceByKey(l, ascending).isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20])\
    \ == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp92dol0e6.swift:11:12: error: cannot find 'sortInplaceByKey' in\
    \ scope\n    return sortInplaceByKey(l, ascending).isEmpty\n           ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp92dol0e6.swift:11:32: error: cannot find 'ascending' in scope\n    return\
    \ sortInplaceByKey(l, ascending).isEmpty\n                               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    // TODO: uncomment this when we have generic type inference\
    \ in Swift\n    //return genericMonotonic(l)\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpe3z5ka3a/tmpe3z5ka3a.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e3f1cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e3eec1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e3eec1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e3eec07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe3z5ka3a                        0x000055d5fa44f302 <unavailable> + 4866

    5    libc.so.6                          0x00002b4e3f3b6460 __libc_start_main +
    245

    6    tmpe3z5ka3a                        0x000055d5fa44ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let n = l.count\n    for i in 0..<n {\n        if l[i-1]\
    \ < l[i] || l[i-1] > l[i] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4,\
    \ 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b41547f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41544ed561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b41544ed286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b41544ed13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b41544ecbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b41542ece83 <unavailable> + 188035

    6    tmp0xc0ss44                        0x000055c093a2fce7 <unavailable> + 7399

    7    tmp0xc0ss44                        0x000055c093a2f4cd <unavailable> + 5325

    8    libc.so.6                          0x00002b41549e2460 __libc_start_main +
    245

    9    tmp0xc0ss44                        0x000055c093a2f1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 0:\n\t\treturn true\n\tcase 1:\n\
    \t\treturn l[0] >= l[0]\n\tdefault:\n\t\treturn monotonicHelper(l, 0)\n\t}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpvwtnucz0.swift:16:10: error: cannot find 'monotonicHelper' in scope\n\
    \                return monotonicHelper(l, 0)\n                       ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let maxIndex = l.count - 1\n    var maxValue = l[maxIndex]\n\
    \n    for i in 0 ..< maxIndex {\n        let val = l[i]\n        if val < 0 {\n\
    \            return false\n        } else if val > maxValue {\n            return\
    \ true\n        } else {\n            maxValue = val\n        }\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4,\
    \ 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpgyqn7sjm/tmpgyqn7sjm.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d749a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d746a0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d746a0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d7469f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgyqn7sjm                        0x0000564b701486ce <unavailable> + 5838

    5    libc.so.6                          0x00002b6d74b95460 __libc_start_main +
    245

    6    tmpgyqn7sjm                        0x0000564b701481a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return l.isMonotonic()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbi5jcg45.swift:10:14: error: value of type '[Int]' has no member\
    \ 'isMonotonic'\n    return l.isMonotonic()\n           ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    for i := 0; i < len(l); i++ {\n        if l[i] < l[i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpevuqv9s3.swift:10:12: error: expected type\n    for i := 0; i <\
    \ len(l); i++ {\n           ^\n            <#type#>\n/tmp/tmpevuqv9s3.swift:10:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(l); i++\
    \ {\n           ^\n/tmp/tmpevuqv9s3.swift:10:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(l); i++ {\n           ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var l = l.sort()\n    var monotonic = l[0] == l[1]\n \
    \   for i in l.indices {\n        if l[i] - l[i - 1] > 1 {\n            monotonic\
    \ = false\n            break\n        }\n    }\n    return monotonic\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpv55ywluo.swift:10:15: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    var l = l.sort()\n            ~ ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    // TODO: Use sort.\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpufsjgz_4/tmpufsjgz_4.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70afc7dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70af974b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70af974988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70af9737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpufsjgz_4                        0x00005573e30a048e <unavailable> + 5262

    5    libc.so.6                          0x00002b70afe69460 __libc_start_main +
    245

    6    tmpufsjgz_4                        0x00005573e309ff69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicWithContext(context.Background(), l)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbokcw3c4.swift:10:9: error: cannot find 'monotonicWithContext'\
    \ in scope\n        return monotonicWithContext(context.Background(), l)\n   \
    \            ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbokcw3c4.swift:10:30: error: cannot\
    \ find 'context' in scope\n        return monotonicWithContext(context.Background(),\
    \ l)\n                                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicWithBuilder(l, &[Int](repeating: 0, count:\
    \ l.count))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_cfwlz6r.swift:10:12: error: cannot find 'monotonicWithBuilder'\
    \ in scope\n    return monotonicWithBuilder(l, &[Int](repeating: 0, count: l.count))\n\
    \           ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_cfwlz6r.swift:10:36: error: cannot\
    \ pass immutable value as inout argument: function call returns immutable value\n\
    \    return monotonicWithBuilder(l, &[Int](repeating: 0, count: l.count))\n  \
    \                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonic1(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpxq1w2x1r.swift:10:12: error: cannot find 'monotonic1' in scope\n\
    \    return monotonic1(l)\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicWithOptionType(l.self, ArraySlice.Options.default())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpptbxt3j8.swift:10:12: error: cannot find 'monotonicWithOptionType'\
    \ in scope\n    return monotonicWithOptionType(l.self, ArraySlice.Options.default())\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpptbxt3j8.swift:10:44: error: generic\
    \ parameter 'Element' could not be inferred\n    return monotonicWithOptionType(l.self,\
    \ ArraySlice.Options.default())\n                                           ^\n\
    /tmp/tmpptbxt3j8.swift:10:44: note: explicitly specify the generic arguments to\
    \ fix this issue\n    return monotonicWithOptionType(l.self, ArraySlice.Options.default())\n\
    \                                           ^\n                              \
    \                       <Any>\n/tmp/tmpptbxt3j8.swift:10:55: error: type 'ArraySlice<Element>'\
    \ has no member 'Options'\n    return monotonicWithOptionType(l.self, ArraySlice.Options.default())\n\
    \                                           ~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  switch l.count {\n  case 0: return true\n  case 1: return\
    \ l[0] > l[1]\n  case 2: return l[0] > l[1] && l[0] < l[2]\n  case 3: return l[0]\
    \ > l[1] && l[2] > l[1] && l[2] < l[3]\n  case 4: return l[0] > l[1] && l[2] >\
    \ l[1] && l[3] > l[1] && l[3] < l[2]\n  case 5: return l[0] > l[1] && l[2] > l[1]\
    \ && l[3] > l[1] && l[3] > l[2] && l[3] < l[3]\n  case 6: return l[0] > l[1] &&\
    \ l[2] > l[1] && l[3] > l[1] && l[3] > l[2] && l[3] > l[3] && l[3] < l[4]\n  case\
    \ 7: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] && l[3] > l[2] && l[3] >\
    \ l[3] && l[3] > l[4] && l[3] < l[5]\n  case 8: return l[0] > l[1] && l[2] > l[1]\
    \ && l[3] > l[1] && l[3] > l[2] && l[3] > l[3] && l[3] > l[4] && l[3] > l[5] &&\
    \ l[3] < l[6]\n  case 9: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] && l[3]\
    \ > l[2] && l[3] > l[3] && l[3] > l[4] && l[3] > l[5] && l[3] > l[6] && l[3] <\
    \ l[7]\n  case 10: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] && l[3] >\
    \ l[2] && l[3] > l[3] && l[3] > l[4] && l[3] > l[5] && l[3] > l[6] && l[3] > l[7]\
    \ && l[3] > l[8]\n  case 11: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1]\
    \ && l[3] > l[2] && l[3] > l[3] && l[3] > l[4] && l[3] > l[5] && l[3] > l[6] &&\
    \ l[3] > l[7] && l[3] > l[8] && l[3] < l[9]\n  case 12: return l[0] > l[1] &&\
    \ l[2] > l[1] && l[3] > l[1] && l[3] > l[2] && l[3] > l[3] && l[3] > l[4] && l[3]\
    \ > l[5] && l[3] > l[6] && l[3] > l\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20])\
    \ == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpan18gk48.swift:46:43: error: expected '}' at end of brace statement\n\
    assert(monotonic(l: [9, 9, 9, 9]) == true)\n                                 \
    \         ^\n/tmp/tmpan18gk48.swift:9:34: note: to match this opening '{'\nfunc\
    \ monotonic(l: [Int]) -> Bool {\n                                 ^\n/tmp/tmpan18gk48.swift:23:146:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \  case 12: return l[0] > l[1] && l[2] > l[1] && l[3] > l[1] && l[3] > l[2] &&\
    \ l[3] > l[3] && l[3] > l[4] && l[3] > l[5] && l[3] > l[6] && l[3] > l\n     \
    \                                                                            \
    \                                                                ^\n/tmp/tmpan18gk48.swift:10:3:\
    \ error: switch must be exhaustive\n  switch l.count {\n  ^\n/tmp/tmpan18gk48.swift:10:3:\
    \ note: do you want to add a default clause?\n  switch l.count {\n  ^\n/tmp/tmpan18gk48.swift:27:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.length < 2 { return false }\n    let len = l.count\n\
    \    let minValue = l.minElement()\n    let maxValue = l.maxElement()\n    if\
    \ minValue < maxValue {\n        if l[0] != minValue {\n            return false\n\
    \        }\n        for i in 1..len - 1 {\n            if l[i] > l[i-1] {\n  \
    \              return false\n            }\n        }\n        return true\n \
    \   }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp9nziexif.swift:10:10: error: value of type '[Int]' has no member\
    \ 'length'\n    if l.length < 2 { return false }\n       ~ ^~~~~~\n/tmp/tmp9nziexif.swift:12:22:\
    \ error: value of type '[Int]' has no member 'minElement'\n    let minValue =\
    \ l.minElement()\n                   ~ ^~~~~~~~~~\n/tmp/tmp9nziexif.swift:13:22:\
    \ error: value of type '[Int]' has no member 'maxElement'\n    let maxValue =\
    \ l.maxElement()\n                   ~ ^~~~~~~~~~\n/tmp/tmp9nziexif.swift:18:19:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        for\
    \ i in 1..len - 1 {\n                  ^~\n                  ...\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn isMonotonic(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2_2l_dox.swift:10:9: error: cannot find 'isMonotonic' in scope\n\
    \        return isMonotonic(l)\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.count < 2 {\n        return true\n    }\n    var\
    \ last = 0\n    var i = 0\n    var j = l.count - 1\n    var k = l.count - 2\n\
    \    while i < j {\n        if l[i] > l[k] {\n            k = k - 1\n        }\
    \ else if l[i] < l[k] {\n            k = k + 1\n        } else {\n           \
    \ last = l[i]\n            i = i + 1\n            j = j - 1\n        }\n    }\n\
    \    return last > l[j]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aafd109ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafd0d91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aafd0d91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aafd0d9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aafd0d90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aafd0b90e83 <unavailable> + 188035

    6    tmpcs16qxvk                        0x00005571161aaae7 <unavailable> + 6887

    7    tmpcs16qxvk                        0x00005571161aa33d <unavailable> + 4925

    8    libc.so.6                          0x00002aafd1286460 __libc_start_main +
    245

    9    tmpcs16qxvk                        0x00005571161aa019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var i = 0\n    var n = l.count\n    var k = l.count\n\
    \    var p = k - 1\n    var q = 0\n\n    while (k > 0) {\n        if q == 0 ||\
    \ l[i] <= l[q - 1] {\n            p = k\n        } else {\n            q = k\n\
    \        }\n        i = (p + q) / 2\n        k = p - 1\n    }\n\n    return i\
    \ == k\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4,\
    \ 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpganx3m79/tmpganx3m79.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3bc647c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3bc33eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3bc33e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3bc33d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpganx3m79                        0x00005651301a45de <unavailable> + 5598

    5    libc.so.6                          0x00002ac3bc833460 __libc_start_main +
    245

    6    tmpganx3m79                        0x00005651301a40b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tvar a = make([]Int, l.count)\n\tcopy(l, a)\n\ta.sort()\n\
    \tfor i := 0; i < len(a); i++ {\n\t\tif a[i] != a[i-1] {\n\t\t\treturn true\n\t\
    \t}\n\t}\n\treturn false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfd2iz_4b.swift:10:17: error: expected ',' separator\n        var\
    \ a = make([]Int, l.count)\n                       ^\n                       ,\n\
    /tmp/tmpfd2iz_4b.swift:13:9: error: expected type\n        for i := 0; i < len(a);\
    \ i++ {\n               ^\n                <#type#>\n/tmp/tmpfd2iz_4b.swift:13:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(a);\
    \ i++ {\n               ^\n/tmp/tmpfd2iz_4b.swift:13:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(a); i++ {\n      \
    \         ^\n/tmp/tmpfd2iz_4b.swift:10:10: error: cannot find 'make' in scope\n\
    \        var a = make([]Int, l.count)\n                ^~~~\n/tmp/tmpfd2iz_4b.swift:11:2:\
    \ error: cannot find 'copy' in scope\n        copy(l, a)\n        ^~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.isEmpty {\n        return false\n    }\n    return\
    \ monotonic(l.slice(1, l.count), l.first!)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp82_lw2kp.swift:13:50: error: extra argument in call\n    return\
    \ monotonic(l.slice(1, l.count), l.first!)\n                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmp82_lw2kp.swift:13:24: error: value of type '[Int]' has no member 'slice'\n\
    \    return monotonic(l.slice(1, l.count), l.first!)\n                     ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicWithSeed(l, l[0])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_s4z_jsy.swift:10:12: error: cannot find 'monotonicWithSeed' in\
    \ scope\n    return monotonicWithSeed(l, l[0])\n           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.count < 2 {\n        return true\n    }\n\n    //\
    \ TODO: optimize to use map / sorted as in Python to avoid allocating temporary\
    \ storage\n\n    // compute delta of first and last element\n    let firstElement\
    \ = min(l)\n    let lastElement = max(l)\n    var delta: Int = 0\n    if firstElement\
    \ < lastElement {\n        delta = -lastElement - firstElement\n    }\n\n    //\
    \ for each element from second position on, increment delta and decrement it by\
    \ 1\n    for i in 1 ..< l.count {\n        if l[i] < firstElement {\n        \
    \    delta -= 1\n        }\n        if l[i] > lastElement {\n            delta\
    \ += 1\n        }\n    }\n    return delta <= 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpv9c_eu9v.swift:17:29: error: missing argument for parameter #2\
    \ in call\n    let firstElement = min(l)\n                            ^\n    \
    \                        , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n\
    @inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpv9c_eu9v.swift:18:28: error: missing argument for\
    \ parameter #2 in call\n    let lastElement = max(l)\n                       \
    \    ^\n                           , <#[Int]#>\nSwift.max:1:24: note: 'max' declared\
    \ here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpv9c_eu9v.swift:21:30: error: cannot assign\
    \ value of type 'Float16' to type 'Int'\n        delta = -lastElement - firstElement\n\
    \                ~~~~~~~~~~~~~^~~~~~~~~~~~~~\n                Int(           \
    \            )\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0: return true\n    case 1:\
    \ return (l[0] < l[1]) || (l[0] == l[1] && l[0] > 0)\n    default: return (l.min()\
    \ <= l.max()) || (l.min() < l.max() && monotonic(l.dropLast()))\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6t71wytt.swift:13:24: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    default: return (l.min() <= l.max())\
    \ || (l.min() < l.max() && monotonic(l.dropLast()))\n                       ^\n\
    /tmp/tmp6t71wytt.swift:13:24: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    default: return (l.min() <= l.max())\
    \ || (l.min() < l.max() && monotonic(l.dropLast()))\n                       ^\n\
    \                             ?? <#default value#>\n/tmp/tmp6t71wytt.swift:13:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    default: return (l.min() <= l.max()) || (l.min() < l.max() && monotonic(l.dropLast()))\n\
    \                       ^\n                            !\n/tmp/tmp6t71wytt.swift:13:35:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    default: return (l.min() <= l.max()) || (l.min() < l.max() && monotonic(l.dropLast()))\n\
    \                                  ^\n/tmp/tmp6t71wytt.swift:13:35: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ default: return (l.min() <= l.max()) || (l.min() < l.max() && monotonic(l.dropLast()))\n\
    \                                  ^\n                                       \
    \ ?? <#default value#>\n/tmp/tmp6t71wytt.swift:13:35: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    default: return\
    \ (l.min() <= l.max()) || (l.min() < l.max() && monotonic(l.dropLast()))\n   \
    \                               ^\n                                       !\n\
    /tmp/tmp6t71wytt.swift:13:48: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n    default: return (l.min() <= l.max()) || (l.min()\
    \ < l.max() && monotonic(l.dropLast()))\n                                    \
    \           ^\n/tmp/tmp6t71wytt.swift:13:48: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    default: return (l.min()\
    \ <= l.max()) || (l.min() < l.max() && monotonic(l.dropLast())"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwd3h19g8.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch len(l) {\n\tcase 0:\n\t\treturn true\n\tcase 1:\n\
    \t\treturn l[0] >= l[0]\n\tcase 2:\n\t\treturn l[0] > l[1]\n\tcase 3:\n\t\treturn\
    \ l[0] < l[1] && l[1] > l[2]\n\tcase 4:\n\t\treturn l[0] < l[1] && l[1] < l[2]\
    \ && l[2] > l[3]\n\tcase 5:\n\t\treturn l[0] < l[1] && l[1] < l[2] && l[2] < l[3]\
    \ && l[3] > l[4]\n\tdefault:\n\t\tswitch {\n\t\tcase l[0] > l[1] && l[1] > l[2]\
    \ && l[2] > l[3] && l[3] > l[4] && l[4] > l[5]:\n\t\t\treturn true\n\t\tcase l[0]\
    \ < l[1] && l[1] < l[2] && l[2] < l[3] && l[3] < l[4] && l[4] < l[5]:\n\t\t\t\
    return false\n\t\tdefault:\n\t\t\treturn l[0] < l[1] && l[1] < l[2] && l[2] <\
    \ l[3] && l[3] < l[4] && l[4] < l[5] && l[5] < l[6]\n\t\t}\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpw0ab7waz.swift:24:10: error: expected expression in 'switch' statement\n\
    \                switch {\n                       ^\n/tmp/tmpw0ab7waz.swift:10:9:\
    \ error: cannot find 'len' in scope\n        switch len(l) {\n               ^~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwd3h19g8.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var prev = l[0]\n    for idx in 1..<l.count {\n      \
    \  if prev < l[idx] {\n            return false\n        }\n        prev = l[idx]\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpijha4m32/tmpijha4m32.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b15428fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b15425f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b15425f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15425f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpijha4m32                        0x000055a0f19ee542 <unavailable> + 5442

    5    libc.so.6                          0x00002b1542ae8460 __libc_start_main +
    245

    6    tmpijha4m32                        0x000055a0f19ee1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var left = 0\n    var right = l.count - 1\n    while (left\
    \ < right) {\n        let mid = left + right >> 1\n        if l[mid] > l[mid+1]\
    \ {\n            right = mid\n        } else {\n            left = mid + 1\n \
    \       }\n    }\n    return left == right\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d90e79c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d90b70561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8d90b70286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8d90b7013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8d90b6fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8d90971e83 <unavailable> + 188035

    6    tmp6zkn7mrd                        0x00005559215cfbab <unavailable> + 7083

    7    tmp6zkn7mrd                        0x00005559215cf33d <unavailable> + 4925

    8    libc.so.6                          0x00002b8d91065460 __libc_start_main +
    245

    9    tmp6zkn7mrd                        0x00005559215cf019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let isInIncreasing = l.indices.contains(l.startIndex)\n\
    \    let isInDecreasing = l.indices.contains(l.endIndex) ~= isInIncreasing\n \
    \   return isInIncreasing || isInDecreasing\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpmm7naldy/tmpmm7naldy.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c55aa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c5579ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c5579a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c557997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmm7naldy                        0x0000560d0e4a262e <unavailable> + 5678

    5    libc.so.6                          0x00002b5c55c8f460 __libc_start_main +
    245

    6    tmpmm7naldy                        0x0000560d0e4a2109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicSort(l, 0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzot71cgk.swift:10:12: error: cannot find 'monotonicSort' in scope\n\
    \    return monotonicSort(l, 0)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    for x in l {\n        if x < l[0] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmp29axzr8g/tmp29axzr8g.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf744c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf741bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf741bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf741ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29axzr8g                        0x000055dc1867864e <unavailable> + 5710

    5    libc.so.6                          0x00002abf746b0460 __libc_start_main +
    245

    6    tmp29axzr8g                        0x000055dc18678129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.len() == 0 {\n        return true\n    }\n    var\
    \ left = 0\n    var right = l.count - 1\n    while left < right {\n        if\
    \ l[left] < l[right] {\n            return false\n        }\n        left += 1\n\
    \        right -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9op2ff0.swift:10:10: error: value of type '[Int]' has no member\
    \ 'len'\n    if l.len() == 0 {\n       ~ ^~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicWithMetatype(l, Int64.self)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4hghng_5.swift:10:12: error: cannot find 'monotonicWithMetatype'\
    \ in scope\n    return monotonicWithMetatype(l, Int64.self)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.isEmpty {\n        return true\n    }\n    var lMin\
    \ = l[0]\n    var lMax = l[0]\n    var isIncreasing = true\n    for _i in 1..<l.count\
    \ {\n        let curr = l[_i]\n        if curr < lMin {\n            lMin = curr\n\
    \        } else if curr > lMax {\n            lMax = curr\n        } else {\n\
    \            isIncreasing = false\n            break\n        }\n    }\n    return\
    \ isIncreasing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmp8w6fky4k/tmp8w6fky4k.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04c53fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04c50f4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04c50f4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04c50f37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8w6fky4k                        0x000055cf0b1cb924 <unavailable> + 6436

    5    libc.so.6                          0x00002b04c55e9460 __libc_start_main +
    245

    6    tmp8w6fky4k                        0x000055cf0b1cb239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var last = l.last\n    for x in l.prefix(l.count-1) {\n\
    \        if x > last {\n            return true\n        } else {\n          \
    \  last = x\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpa4zayqra.swift:12:16: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if x > last {\n             \
    \  ^\n/tmp/tmpa4zayqra.swift:12:16: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        if x > last {\n            \
    \   ^\n                    ?? <#default value#>\n/tmp/tmpa4zayqra.swift:12:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if x > last {\n               ^\n                   !\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return l.sorted.isMonotonic\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphtcdx4ol.swift:10:21: error: reference to member 'isMonotonic'\
    \ cannot be resolved without a contextual type\n    return l.sorted.isMonotonic\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0:\n        return true\n \
    \   case 1:\n        if l[0] < l[1] {\n            return true\n        }\n  \
    \      return false\n    case 2:\n        if l[0] < l[1] {\n            return\
    \ true\n        } else if l[1] < l[2] {\n            return true\n        }\n\
    \        return false\n    default:\n        if l[0] < l[1] {\n            if\
    \ l[2] < l[3] {\n                if l[4] < l[5] {\n                    return\
    \ true\n                }\n                return false\n            }\n     \
    \       return true\n        } else if l[1] < l[2] {\n            if l[1] < l[3]\
    \ {\n                if l[2] < l[4] {\n                    return true\n     \
    \           }\n                return false\n            }\n            if l[1]\
    \ < l[3] {\n                if l[2] < l[4] {\n                    return true\n\
    \                }\n                return false\n            }\n            return\
    \ true\n        } else if l[2] < l[3] {\n            if l[1] < l[2] {\n      \
    \          if l[1] < l[3] {\n                    if l[2] < l[4] {\n          \
    \              return true\n                    }\n                    return\
    \ false\n                }\n                return true\n            }\n     \
    \   }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9849b51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9849848561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9849848286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b984984813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9849847bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9849647e83 <unavailable> + 188035

    6    tmp7ijlx0wf                        0x000055d233c67c41 <unavailable> + 7233

    7    tmp7ijlx0wf                        0x000055d233c6733d <unavailable> + 4925

    8    libc.so.6                          0x00002b9849d3d460 __libc_start_main +
    245

    9    tmp7ijlx0wf                        0x000055d233c67019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.count == 0 {\n        return true\n    }\n\n    //\
    \ We start with the last element because the last element will never be\n    //\
    \ compared with a number less than it.\n    var cmp = -1\n\n    for index1 in\
    \ (l.count - 1) { //\n        let currentValue = l[index1]\n        for index2\
    \ in (index1 + 1, l.count) { //\n            let nextValue = l[index2]\n\n   \
    \         // If values are equal, they are monotonic, so we can just return that\n\
    \            // the first one is less than the second one.\n            if currentValue\
    \ == nextValue {\n                return false\n            }\n\n            //\
    \ If current value is greater than next value, we know it is not\n           \
    \ // monotonically increasing.\n            if currentValue > nextValue {\n  \
    \              return false\n            }\n\n            // If current value\
    \ is less than next value, we know it is not\n            // monotonically decreasing.\n\
    \            if currentValue < nextValue {\n                return true\n    \
    \        }\n\n            // If we get this far, there is no clear sign of monotonicity\
    \ so we\n            // assume that both values are monotonically increasing or\
    \ decreasing.\n            cmp = 0\n            if currentValue < nextValue {\n\
    \                cmp = 1\n            }\n        }\n    }\n\n    return cmp ==\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) ==\
    \ true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1,\
    \ 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp22h_vm__.swift:18:28: error: for-in loop requires 'Int' to conform\
    \ to 'Sequence'\n    for index1 in (l.count - 1) { //\n                  ~~~~~~~~~^~~~\n\
    /tmp/tmp22h_vm__.swift:20:23: error: for-in loop requires '(Int, Int)' to conform\
    \ to 'Sequence'\n        for index2 in (index1 + 1, l.count) { //\n          \
    \            ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 1:\n\t\treturn l[0] > l[1]\n\t\
    case 2:\n\t\treturn l[0] < l[1]\n\tcase 3:\n\t\treturn l[1] < l[2]\n\tdefault:\n\
    \t\treturn false\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpwo7fi4aq/tmpwo7fi4aq.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b972c3e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b972c0d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b972c0d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b972c0d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwo7fi4aq                        0x0000555939e443b2 <unavailable> + 5042

    5    libc.so.6                          0x00002b972c5cd460 __libc_start_main +
    245

    6    tmpwo7fi4aq                        0x0000555939e44019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonic(l, lessOrEqual)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpju7ac_1w.swift:10:23: error: cannot find 'lessOrEqual' in scope\n\
    \  return monotonic(l, lessOrEqual)\n                      ^~~~~~~~~~~\n/tmp/tmpju7ac_1w.swift:10:23:\
    \ error: extra argument in call\n  return monotonic(l, lessOrEqual)\n        \
    \          ~~~~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0: return true\n    case 1:\
    \ return !l.isEmpty && l[0] > l[0]\n    default: return isMonotonic(l, &l[0])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4,\
    \ 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp35drmy1l.swift:13:21: error: cannot find 'isMonotonic' in scope\n\
    \    default: return isMonotonic(l, &l[0])\n                    ^~~~~~~~~~~\n\
    /tmp/tmp35drmy1l.swift:13:36: error: cannot pass immutable value as inout argument:\
    \ 'l' is a 'let' constant\n    default: return isMonotonic(l, &l[0])\n       \
    \                            ^~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tif l == nil {\n\t\treturn false\n\t}\n\tsort.Sort(IntSlice(l))\n\
    \treturn monotonicSort(l) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpoojeg4tj.swift:10:7: warning: comparing non-optional value of type\
    \ '[Int]' to 'nil' always returns false\n        if l == nil {\n           ~ ^\
    \  ~~~\n/tmp/tmpoojeg4tj.swift:13:2: error: cannot find 'sort' in scope\n    \
    \    sort.Sort(IntSlice(l))\n        ^~~~\n/tmp/tmpoojeg4tj.swift:13:12: error:\
    \ cannot find 'IntSlice' in scope\n        sort.Sort(IntSlice(l))\n          \
    \        ^~~~~~~~\n/tmp/tmpoojeg4tj.swift:14:9: error: cannot find 'monotonicSort'\
    \ in scope\n        return monotonicSort(l) == 0\n               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tif l == nil || len(l) == 0 {\n\t\treturn false\n\t}\n\t\
    n := len(l)\n\tlast := l[0]\n\tdelta := l[1] - last\n\tfor i := 1; i < n; i++\
    \ {\n\t\tswitch {\n\t\tcase l[i] > last:\n\t\t\treturn false\n\t\tcase l[i] <\
    \ last:\n\t\t\treturn true\n\t\tcase delta > 0:\n\t\t\tdelta = l[i] - last\n\t\
    \t\tlast = l[i]\n\t\tdefault:\n\t\t\tdelta = l[n-i] - last\n\t\t\tlast = l[n-i]\n\
    \t\t}\n\t}\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbwnq25px.swift:13:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        n := len(l)\n         ^\n         ;\n/tmp/tmpbwnq25px.swift:13:4:\
    \ error: expected expression\n        n := len(l)\n          ^\n/tmp/tmpbwnq25px.swift:16:9:\
    \ error: expected type\n        for i := 1; i < n; i++ {\n               ^\n \
    \               <#type#>\n/tmp/tmpbwnq25px.swift:16:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 1; i < n; i++ {\n               ^\n/tmp/tmpbwnq25px.swift:16:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 1; i\
    \ < n; i++ {\n               ^\n/tmp/tmpbwnq25px.swift:17:10: error: expected\
    \ expression in 'switch' statement\n                switch {\n               \
    \        ^\n/tmp/tmpbwnq25px.swift:10:17: error: cannot find 'len' in scope\n\
    \        if l == nil || len(l) == 0 {\n                       ^~~\n/tmp/tmpbwnq25px.swift:13:2:\
    \ error: cannot find 'n' in scope\n        n := len(l)\n        ^\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    // Fast path for monotonically increasing array.\n   \
    \ if l.length == 0 {\n        return true\n    }\n    if l.count == 0 {\n    \
    \    return false\n    }\n\n    let m = l.count\n\n    for i in 0..<m {\n    \
    \    for j in 0..<m {\n            if i == j {\n                continue\n   \
    \         }\n            if l[i] > l[j] {\n                return false\n    \
    \        }\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyr665ila.swift:11:10: error: value of type '[Int]' has no member\
    \ 'length'\n    if l.length == 0 {\n       ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let sorted = l.sorted()\n    return sorted == l || sorted.isEmpty\
    \ || (sorted[0] != sorted[sorted.count - 1])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpxjglhjki/tmpxjglhjki.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeca273fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeca2436b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeca2436988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeca24357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxjglhjki                        0x00005579f35e26de <unavailable> + 5854

    5    libc.so.6                          0x00002aeca292b460 __libc_start_main +
    245

    6    tmpxjglhjki                        0x00005579f35e21b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let mut lastVal = l.first!\n    let mut lastIdx = 1\n\
    \    for elt in l {\n        if elt < lastVal {\n            return false\n  \
    \      }\n        if elt == lastVal {\n            lastIdx += 1\n        }\n \
    \       lastVal = elt\n    }\n    return lastIdx == l.count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpc3p16kzt.swift:10:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut lastVal\
    \ = l.first!\n            ^\n/tmp/tmpc3p16kzt.swift:10:13: note: join the identifiers\
    \ together\n    let mut lastVal = l.first!\n        ~~~~^~~~~~~\n        mutlastVal\n\
    /tmp/tmpc3p16kzt.swift:10:13: note: join the identifiers together with camel-case\n\
    \    let mut lastVal = l.first!\n        ~~~~^~~~~~~\n        mutLastVal\n/tmp/tmpc3p16kzt.swift:11:13:\
    \ error: found an unexpected second identifier in constant declaration; is there\
    \ an accidental break?\n    let mut lastIdx = 1\n            ^\n/tmp/tmpc3p16kzt.swift:11:13:\
    \ note: join the identifiers together\n    let mut lastIdx = 1\n        ~~~~^~~~~~~\n\
    \        mutlastIdx\n/tmp/tmpc3p16kzt.swift:11:13: note: join the identifiers\
    \ together with camel-case\n    let mut lastIdx = 1\n        ~~~~^~~~~~~\n   \
    \     mutLastIdx\n/tmp/tmpc3p16kzt.swift:11:9: error: invalid redeclaration of\
    \ 'mut'\n    let mut lastIdx = 1\n        ^\n/tmp/tmpc3p16kzt.swift:10:9: note:\
    \ 'mut' previously declared here\n    let mut lastVal = l.first!\n        ^\n\
    /tmp/tmpc3p16kzt.swift:13:18: error: cannot find 'lastVal' in scope\n        if\
    \ elt < lastVal {\n                 ^~~~~~~\n/tmp/tmpc3p16kzt.swift:16:19: error:\
    \ cannot find 'lastVal' in scope\n        if elt == lastVal {\n              \
    \    ^~~~~~~\n/tmp/tmpc3p16kzt.swift:17:13: error: cannot find 'lastIdx' in scope\n\
    \            lastIdx += 1\n            ^~~~~~~\n/tmp/tmpc3p16kzt.swift:19:9: error:\
    \ cannot find 'lastVal' in scope\n        lastVal = elt\n        ^~~~~~~\n/tmp/tmpc3p16kzt.swift:21:12:\
    \ error: cannot find 'lastIdx' in scope\n    return lastIdx == l.count\n     \
    \      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonic(l.slice())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplol93irc.swift:10:24: error: value of type '[Int]' has no member\
    \ 'slice'\n    return monotonic(l.slice())\n                     ~ ^~~~~\n/tmp/tmplol93irc.swift:10:22:\
    \ error: missing argument label 'l:' in call\n    return monotonic(l.slice())\n\
    \                     ^\n                     l: \n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let len = l.count\n    if len < 1 {\n        return false\n\
    \    }\n\n    var i = len - 1\n    var j = len - 2\n    var c = Int()\n    var\
    \ d = Int()\n\n    while i >= 0 {\n        c = l[i]\n        d = l[j]\n\n    \
    \    if c == d {\n            i -= 1\n            j -= 1\n        } else {\n \
    \           if c > d {\n                return false\n            }\n\n      \
    \      i -= 1\n        }\n    }\n\n    return j >= 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpzn5ur693/tmpzn5ur693.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1903c9bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1903992b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1903992988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19039917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzn5ur693                        0x000055e1360e83b2 <unavailable> + 5042

    5    libc.so.6                          0x00002b1903e87460 __libc_start_main +
    245

    6    tmpzn5ur693                        0x000055e1360e8019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicR(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdr7n1t9y.swift:10:12: error: cannot find 'monotonicR' in scope\n\
    \    return monotonicR(l)\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let sorted = l.sorted()\n    return sorted.first <= sorted.last\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4zjfagln.swift:11:25: error: binary operator '<=' cannot be applied\
    \ to two 'Int?' operands\n    return sorted.first <= sorted.last\n           ~~~~~~~~~~~~\
    \ ^  ~~~~~~~~~~~\n/tmp/tmp4zjfagln.swift:11:25: note: overloads for '<=' exist\
    \ with these partially matching parameter lists: (Int, Int)\n    return sorted.first\
    \ <= sorted.last\n                        ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var i = 0\n    var j = l.count\n    var k = j - 1\n  \
    \  var m = k + 1\n    var r = j - 2\n    var s = l as! [Int]\n\n    if j < 0 {\n\
    \        return false\n    }\n\n    while k >= 0 && m >= 0 {\n        if s > l[k]\
    \ {\n            if s > l[m] {\n                r = m\n            } else {\n\
    \                k = m\n            }\n        } else {\n            if s < l[k]\
    \ {\n                k = m\n            } else {\n                m = k\n    \
    \        }\n        }\n        i += 1\n        j -= 1\n        m -= 1\n    }\n\
    \n    if i < 0 {\n        return false\n    }\n\n    if j == 0 {\n        if l\
    \ as! [Int] == r {\n            return true\n        }\n        return false\n\
    \    }\n\n    if r < 0 {\n        return true\n    }\n\n    return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpleyes167.swift:15:15: warning: forced cast of '[Int]' to same type\
    \ has no effect\n    var s = l as! [Int]\n              ^~~~~~~~~\n          \
    \    \n/tmp/tmpleyes167.swift:22:12: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        if s > l[k] {\n           ^\n/tmp/tmpleyes167.swift:23:16:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \            if s > l[m] {\n               ^\n/tmp/tmpleyes167.swift:29:16: error:\
    \ cannot convert value of type '[Int]' to expected argument type 'Int'\n     \
    \       if s < l[k] {\n               ^\n/tmp/tmpleyes167.swift:45:24: error:\
    \ binary operator '==' cannot be applied to operands of type '[Int]' and 'Int'\n\
    \        if l as! [Int] == r {\n           ~~~~~~~~~~~ ^  ~\n/tmp/tmpleyes167.swift:45:24:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if l as! [Int] == r {\n                       ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var isIncreasing = true\n  var isDecreasing = true\n  for\
    \ idx in l.indices {\n    if idx < 0 || idx >= l.count {\n      return false\n\
    \    }\n    var currentElement = l.object(idx)\n    var previousElement = l.object(idx\
    \ - 1)\n    if currentElement < previousElement {\n      isIncreasing = false\n\
    \    } else if currentElement > previousElement {\n      isDecreasing = false\n\
    \    } else {\n      break\n    }\n  }\n  return isIncreasing || isDecreasing\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp53al8fcg.swift:16:28: error: value of type '[Int]' has no member\
    \ 'object'\n    var currentElement = l.object(idx)\n                         ~\
    \ ^~~~~~\n/tmp/tmp53al8fcg.swift:17:29: error: value of type '[Int]' has no member\
    \ 'object'\n    var previousElement = l.object(idx - 1)\n                    \
    \      ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0: return true\n    case 1:\
    \ return l[0] >= l[1]\n    case 2: return l[0] > l[1] || l[0] == l[1] && l[1]\
    \ >= l[2]\n    default: return l[0] > l[1] && l[1] > l[2] || l[0] == l[1] && l[1]\
    \ > l[2]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmp9yeplr4h/tmp9yeplr4h.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad36f6b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad36f3aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad36f3ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad36f3ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9yeplr4h                        0x0000560ba843a3b2 <unavailable> + 5042

    5    libc.so.6                          0x00002ad36f8a3460 __libc_start_main +
    245

    6    tmp9yeplr4h                        0x0000560ba843a019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicInPlace(self, l)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpzc9eae6f.swift:10:12: error: cannot find 'monotonicInPlace' in\
    \ scope\n    return monotonicInPlace(self, l)\n           ^~~~~~~~~~~~~~~~\n/tmp/tmpzc9eae6f.swift:10:29:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n    return monotonicInPlace(self, l)\n                           \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let d = l.map { abs($0) }\n    if let max = max.reduce(d)\
    \ { $0 > max }\n        else { return true }\n    if let min = min.reduce(d) {\
    \ $0 < min }\n        else { return false }\n    for i in 0..<min(l.count, d.count)\
    \ {\n        if !d[d[i]] < d[i] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7brc5fxz.swift:11:34: error: anonymous closure argument not contained\
    \ in a closure\n    if let max = max.reduce(d) { $0 > max }\n                \
    \                 ^\n/tmp/tmp7brc5fxz.swift:13:34: error: anonymous closure argument\
    \ not contained in a closure\n    if let min = min.reduce(d) { $0 < min }\n  \
    \                               ^\n/tmp/tmp7brc5fxz.swift:11:18: error: generic\
    \ parameter 'T' could not be inferred\n    if let max = max.reduce(d) { $0 > max\
    \ }\n                 ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp7brc5fxz.swift:11:22: error: reference to member 'reduce'\
    \ cannot be resolved without a contextual type\n    if let max = max.reduce(d)\
    \ { $0 > max }\n                     ^\n/tmp/tmp7brc5fxz.swift:13:18: error: generic\
    \ parameter 'T' could not be inferred\n    if let min = min.reduce(d) { $0 < min\
    \ }\n                 ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp7brc5fxz.swift:13:22: error: reference to member 'reduce'\
    \ cannot be resolved without a contextual type\n    if let min = min.reduce(d)\
    \ { $0 < min }\n                     ^\n/tmp/tmp7brc5fxz.swift:16:14: error: type\
    \ 'Int' cannot be used as a boolean; test for '== 0' instead\n        if !d[d[i]]\
    \ < d[i] {\n           ~ ^\n            (       == 0)\n/tmp/tmp7brc5fxz.swift:16:12:\
    \ error: cannot convert value of type 'Bool' to expected argument type 'Int'\n\
    \        if !d[d[i]] < d[i] {\n           ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicOpt(l, l, 0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5rq51ir5.swift:10:9: error: cannot find 'monotonicOpt' in scope\n\
    \        return monotonicOpt(l, l, 0)\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return hasUniqueElement(l) && isMonotonic(l)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0xk3u59s.swift:10:12: error: cannot find 'hasUniqueElement' in\
    \ scope\n    return hasUniqueElement(l) && isMonotonic(l)\n           ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp0xk3u59s.swift:10:35: error: cannot find 'isMonotonic' in scope\n    return\
    \ hasUniqueElement(l) && isMonotonic(l)\n                                  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicWithTolerance(l, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpz199gzk3.swift:10:9: error: cannot find 'monotonicWithTolerance'\
    \ in scope\n        return monotonicWithTolerance(l, 0)\n               ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0:\n        return true\n \
    \   case 1:\n        return l.first >= l.last\n    case 2:\n        return l.first\
    \ > l.second && l.first < l.last\n    default:\n        l.sort()\n        return\
    \ l.first > l.last\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8xs6atdu.swift:14:24: error: binary operator '>=' cannot be applied\
    \ to two 'Int?' operands\n        return l.first >= l.last\n               ~~~~~~~\
    \ ^  ~~~~~~\n/tmp/tmp8xs6atdu.swift:14:24: note: overloads for '>=' exist with\
    \ these partially matching parameter lists: (Int, Int)\n        return l.first\
    \ >= l.last\n                       ^\n/tmp/tmp8xs6atdu.swift:16:18: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ return l.first > l.second && l.first < l.last\n                 ^\n/tmp/tmp8xs6atdu.swift:16:18:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return l.first > l.second && l.first < l.last\n             \
    \    ^\n                       ?? <#default value#>\n/tmp/tmp8xs6atdu.swift:16:18:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return l.first > l.second && l.first < l.last\n             \
    \    ^\n                      !\n/tmp/tmp8xs6atdu.swift:16:28: error: value of\
    \ type '[Int]' has no member 'second'\n        return l.first > l.second && l.first\
    \ < l.last\n                         ~ ^~~~~~\n/tmp/tmp8xs6atdu.swift:16:40: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \       return l.first > l.second && l.first < l.last\n                      \
    \                 ^\n/tmp/tmp8xs6atdu.swift:16:40: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        return l.first\
    \ > l.second && l.first < l.last\n                                       ^\n \
    \                                            ?? <#default value#>\n/tmp/tmp8xs6atdu.swift:16:40:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return l.first > l.second && l.first < l.last\n             \
    \                          ^\n                                            !\n\
    /tmp/tmp8xs6atdu.swift:16:50: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n        return l.first > l.second && l.first < l.last\n\
    \      "
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicHelper(l.asSwift_Array())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpte7q_v0p.swift:10:9: error: cannot find 'monotonicHelper' in scope\n\
    \        return monotonicHelper(l.asSwift_Array())\n               ^~~~~~~~~~~~~~~\n\
    /tmp/tmpte7q_v0p.swift:10:27: error: value of type '[Int]' has no member 'asSwift_Array'\n\
    \        return monotonicHelper(l.asSwift_Array())\n                         \
    \      ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwd3h19g8.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonic(l.startIndex, l.endIndex, l.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo4zr27qy.swift:10:21: error: extra arguments at positions #2, #3\
    \ in call\n    return monotonic(l.startIndex, l.endIndex, l.count)\n         \
    \           ^\n/tmp/tmpo4zr27qy.swift:9:6: note: 'monotonic(l:)' declared here\n\
    func monotonic(l: [Int]) -> Bool {\n     ^\n/tmp/tmpo4zr27qy.swift:10:24: error:\
    \ cannot convert value of type 'Int' to expected argument type '[Int]'\n    return\
    \ monotonic(l.startIndex, l.endIndex, l.count)\n                       ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwd3h19g8.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicWithOption(\"monotonic\", l)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpnuulc_xw.swift:10:12: error: cannot find 'monotonicWithOption'\
    \ in scope\n    return monotonicWithOption(\"monotonic\", l)\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var first = true\n  for element in l {\n    if first {\n\
    \      first = false\n    } else {\n      if element < firstElement {\n      \
    \  return false\n      } else if element > lastElement {\n        return true\n\
    \      }\n    }\n  }\n  return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20])\
    \ == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpz9f46oy7.swift:15:20: error: cannot find 'firstElement' in scope\n\
    \      if element < firstElement {\n                   ^~~~~~~~~~~~\n/tmp/tmpz9f46oy7.swift:17:27:\
    \ error: cannot find 'lastElement' in scope\n      } else if element > lastElement\
    \ {\n                          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonic(l, l, 0)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpju4lf3hq.swift:10:18: error: extra arguments at positions #2, #3\
    \ in call\n        return monotonic(l, l, 0)\n                        ^\n/tmp/tmpju4lf3hq.swift:9:6:\
    \ note: 'monotonic(l:)' declared here\nfunc monotonic(l: [Int]) -> Bool {\n  \
    \   ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var isIncreasing = true\n    for v in l {\n        if\
    \ v < v {\n            isIncreasing = false\n            break\n        }\n  \
    \  }\n    return isIncreasing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpjsh9l9kg/tmpjsh9l9kg.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b0c67ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b0c375b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b0c375988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b0c3747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjsh9l9kg                        0x00005565a6f975fe <unavailable> + 5630

    5    libc.so.6                          0x00002b4b0c86a460 __libc_start_main +
    245

    6    tmpjsh9l9kg                        0x00005565a6f970d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicWithAuxiliary(l, l, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfp39nx7e.swift:10:12: error: cannot find 'monotonicWithAuxiliary'\
    \ in scope\n    return monotonicWithAuxiliary(l, l, 0)\n           ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0:\n        return true\n \
    \   case 1:\n        return true\n    case 2:\n        return l[0] > l[1]\n  \
    \  case 3:\n        return l[0] > l[1] && l[0] > l[2]\n    case 4:\n        return\
    \ l[0] > l[1] && l[0] > l[2] && l[0] > l[3]\n    case 5:\n        return l[0]\
    \ > l[1] && l[0] > l[2] && l[0] > l[3] && l[0] > l[4]\n    case 6:\n        return\
    \ l[0] > l[1] && l[0] > l[2] && l[0] > l[3] && l[0] > l[4] && l[0] > l[5]\n  \
    \  case 7:\n        return l[0] > l[1] && l[0] > l[2] && l[0] > l[3] && l[0] >\
    \ l[4] && l[0] > l[5] && l[0] > l[6]\n    case 8:\n        return l[0] > l[1]\
    \ && l[0] > l[2] && l[0] > l[3] && l[0] > l[4] && l[0] > l[5] && l[0] > l[6] &&\
    \ l[0] > l[7]\n    case 9:\n        return l[0] > l[1] && l[0] > l[2] && l[0]\
    \ > l[3] && l[0] > l[4] && l[0] > l[5] && l[0] > l[6] && l[0] > l[7] && l[0] >\
    \ l[8]\n    case 10:\n        return l[0] > l[1] && l[0] > l[2] && l[0] > l[3]\
    \ && l[0] > l[4] && l[0] > l[5] && l[0] > l[6] && l[0] > l[7] && l[0] > l[8] &&\
    \ l[0] > l[9]\n    default:\n        fatalError()\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpwq6oznw7/tmpwq6oznw7.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7175c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7172b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7172b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7172b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwq6oznw7                        0x0000561e480323b2 <unavailable> + 5042

    5    libc.so.6                          0x00002ae7177ac460 __libc_start_main +
    245

    6    tmpwq6oznw7                        0x0000561e48032019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonicImpl(l, Int)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphe0n287r.swift:10:10: error: cannot find 'monotonicImpl' in scope\n\
    \  return monotonicImpl(l, Int)\n         ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicHelper(l, 0) == nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpycbvvdml.swift:10:9: error: cannot find 'monotonicHelper' in scope\n\
    \        return monotonicHelper(l, 0) == nil\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let result = count(l.startIndex, l.endIndex) < 2\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfaxeoma5.swift:10:18: error: cannot find 'count' in scope\n   \
    \ let result = count(l.startIndex, l.endIndex) < 2\n                 ^~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return isMonotonic(l: l)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp3_ay2_q3.swift:10:12: error: cannot find 'isMonotonic' in scope\n\
    \    return isMonotonic(l: l)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.count == 0 {\n        return false\n    }\n    if\
    \ l.count == 1 {\n        return true\n    }\n    var left = 0\n    var right\
    \ = l.count - 1\n    var mid = 0\n    var diff = 0\n    while left <= right {\n\
    \        mid = left + (right - left) / 2\n        diff = l[mid] - l[mid]\n   \
    \     if diff < 0 {\n            left = mid + 1\n        } else {\n          \
    \  right = mid - 1\n        }\n    }\n    return left <= right\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpnkaqa3lf/tmpnkaqa3lf.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83a4359c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83a4050b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83a4050988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83a404f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnkaqa3lf                        0x0000559ca2765452 <unavailable> + 5202

    5    libc.so.6                          0x00002b83a4545460 __libc_start_main +
    245

    6    tmpnkaqa3lf                        0x0000559ca27650b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var min = l[0]\n    for v in l {\n        if v < min {\n\
    \            min = v\n        }\n    }\n    return min < l[l.count-1]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmp8d4138am/tmp8d4138am.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9be7277c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9be6f6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9be6f6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9be6f6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8d4138am                        0x00005646327866ae <unavailable> + 5806

    5    libc.so.6                          0x00002b9be7463460 __libc_start_main +
    245

    6    tmp8d4138am                        0x0000564632786189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicOp(l, \">\", 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpugvwxadm.swift:10:12: error: cannot find 'monotonicOp' in scope\n\
    \    return monotonicOp(l, \">\", 0)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  // For a monotonic increasing or decreasing array, check\
    \ if any\n  // element in the array is NaN.\n  // If so, return true\n  // if\
    \ not, check if any element in the array is smaller than its predecessor\n  if\
    \ !l.isEmpty {\n    if l.last.isNaN {\n      return true\n    }\n    if l.first\
    \ == l.last {\n      // This should only happen at the end of an increasing array\n\
    \      return false\n    }\n  }\n  // Check if the array is monotonically\n  //\
    \ increasing with respect to its predecessor\n  // If so, return true\n  if !l.first.isNaN\
    \ {\n    if l.last.lt(l.first) {\n      return true\n    }\n  }\n  // Check if\
    \ the array is monotonically\n  // decreasing with respect to its predecessor\n\
    \  if !l.last.isNaN {\n    if l.first.gt(l.last) {\n      return true\n    }\n\
    \  }\n  // If all of the elements are NaN, return false\n  return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyy_2qv77.swift:15:15: error: value of type 'Int?' has no member\
    \ 'isNaN'\n    if l.last.isNaN {\n       ~~~~~~ ^~~~~\n/tmp/tmpyy_2qv77.swift:26:15:\
    \ error: value of type 'Int?' has no member 'isNaN'\n  if !l.first.isNaN {\n \
    \     ~~~~~~~ ^~~~~\n/tmp/tmpyy_2qv77.swift:27:15: error: value of type 'Int?'\
    \ has no member 'lt'\n    if l.last.lt(l.first) {\n       ~~~~~~ ^~\n/tmp/tmpyy_2qv77.swift:33:14:\
    \ error: value of type 'Int?' has no member 'isNaN'\n  if !l.last.isNaN {\n  \
    \    ~~~~~~ ^~~~~\n/tmp/tmpyy_2qv77.swift:34:16: error: value of type 'Int?' has\
    \ no member 'gt'\n    if l.first.gt(l.last) {\n       ~~~~~~~ ^~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0:\n        return true\n \
    \   case 1:\n        return l[0] >= 0\n    case 2:\n        return l[1] > l[0]\n\
    \    default:\n        return l[1] > l[0] && l[2] > l[1] && l[3] > l[2] && monotonic(l[1\
    \ ..< l.count])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpiopm0kxw.swift:18:71: error: missing argument label 'l:' in call\n\
    \        return l[1] > l[0] && l[2] > l[1] && l[3] > l[2] && monotonic(l[1 ..<\
    \ l.count])\n                                                                \
    \      ^\n                                                                   \
    \   l: \n/tmp/tmpiopm0kxw.swift:18:72: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n        return l[1] > l[0] && l[2] > l[1]\
    \ && l[3] > l[2] && monotonic(l[1 ..< l.count])\n                            \
    \                                           ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let n = l.count\n    for i in 0..<n {\n        for j in\
    \ (i + 1)..<n {\n            if l[i] > l[j] {\n                return false\n\
    \            } else if l[i] < l[j] {\n                return true\n          \
    \  }\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20])\
    \ == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpojc3ch1o/tmpojc3ch1o.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ce3f5ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ce3c51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ce3c51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ce3c507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpojc3ch1o                        0x00005583d50cb6ce <unavailable> + 5838

    5    libc.so.6                          0x00002b0ce4146460 __libc_start_main +
    245

    6    tmpojc3ch1o                        0x00005583d50cb1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.isEmpty() {\n        return true\n    }\n    let\
    \ length = l.count\n    if length == 1 {\n        return true\n    }\n    if length\
    \ == 2 {\n        let v1 = l[0]\n        let v2 = l[1]\n        return v1 <= v2\n\
    \    }\n    if length == 3 {\n        let v1 = l[0]\n        let v2 = l[1]\n \
    \       let v3 = l[2]\n        return v1 <= v2 && v2 <= v3\n    }\n    let mid\
    \ = length >> 1\n    let v1 = l[mid]\n    let v2 = l[mid+1]\n    return v1 <=\
    \ v2 && v2 < v1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl4ghq6g5.swift:10:10: error: cannot call value of non-function\
    \ type 'Bool'\n    if l.isEmpty() {\n         ^      ~~\n                \n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicHelper(l, Int()) == .Ordered\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpteia8j30.swift:10:12: error: cannot find 'monotonicHelper' in scope\n\
    \    return monotonicHelper(l, Int()) == .Ordered\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 0:\n\t\treturn false\n\tcase 1:\n\
    \t\treturn true\n\tdefault:\n\t\treturn monotonic(l[1...])\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppdot44xo.swift:16:20: error: missing argument label 'l:' in call\n\
    \                return monotonic(l[1...])\n                                 ^\n\
    \                                 l: \n/tmp/tmppdot44xo.swift:16:21: error: cannot\
    \ convert value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n\
    \                return monotonic(l[1...])\n                                 \
    \ ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 0: return true\n\tcase 1: return\
    \ l[0] >= l[1]\n\tdefault:\n\t\tif l[0] < l[1] {\n\t\t\treturn false\n\t\t}\n\t\
    \tif l[0] > l[1] {\n\t\t\treturn true\n\t\t}\n\t\treturn monotonic(l[1...])\n\t\
    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpesz0_a31.swift:20:20: error: missing argument label 'l:' in call\n\
    \                return monotonic(l[1...])\n                                 ^\n\
    \                                 l: \n/tmp/tmpesz0_a31.swift:20:21: error: cannot\
    \ convert value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n\
    \                return monotonic(l[1...])\n                                 \
    \ ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var lo = 0\n  var hi = l.count\n\n  while lo < hi {\n  \
    \  var mid = lo + (hi - lo) / 2\n    if l[mid] > l[mid+1] {\n      hi = mid -\
    \ 1\n    } else if l[mid] < l[mid+1] {\n      lo = mid + 1\n    } else {\n   \
    \   lo = mid\n      hi = mid - 1\n    }\n  }\n  return lo < hi\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af5ee59ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5ee295561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af5ee295286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af5ee29513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af5ee294bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af5ee094e83 <unavailable> + 188035

    6    tmpze2vhxqg                        0x0000559a7443bbad <unavailable> + 7085

    7    tmpze2vhxqg                        0x0000559a7443b3dd <unavailable> + 5085

    8    libc.so.6                          0x00002af5ee78a460 __libc_start_main +
    245

    9    tmpze2vhxqg                        0x0000559a7443b0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let l0 = l.count\n    if l0 == 1 {\n        return true\n\
    \    }\n    if l0 < 1 {\n        return false\n    }\n    let l = l.sorted()\n\
    \    for i in\n        0 ..< l0 - 1 {\n        if l[i] <= l[i + 1] {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpaqiq2ctp/tmpaqiq2ctp.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6946c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6943c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6943c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6943bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaqiq2ctp                        0x000056435344d5e2 <unavailable> + 5602

    5    libc.so.6                          0x00002ae6948b5460 __libc_start_main +
    245

    6    tmpaqiq2ctp                        0x000056435344d249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return monotonicImpl(l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpi26bgdyg.swift:10:10: error: cannot find 'monotonicImpl' in scope\n\
    \  return monotonicImpl(l)\n         ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0: return true\n    case 1:\
    \ return l.first <= l.last\n    case 2: return l.first < l.last\n    default:\
    \ return monotonic(l.prefix(l.count - 1)) && monotonic(l.suffix(l.count - 1))\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4,\
    \ 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdrv8_v5s.swift:12:28: error: binary operator '<=' cannot be applied\
    \ to two 'Int?' operands\n    case 1: return l.first <= l.last\n             \
    \      ~~~~~~~ ^  ~~~~~~\n/tmp/tmpdrv8_v5s.swift:12:28: note: overloads for '<='\
    \ exist with these partially matching parameter lists: (Int, Int)\n    case 1:\
    \ return l.first <= l.last\n                           ^\n/tmp/tmpdrv8_v5s.swift:13:28:\
    \ error: binary operator '<' cannot be applied to two 'Int?' operands\n    case\
    \ 2: return l.first < l.last\n                   ~~~~~~~ ^ ~~~~~~\n/tmp/tmpdrv8_v5s.swift:13:28:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    case 2: return l.first < l.last\n                          \
    \ ^\n/tmp/tmpdrv8_v5s.swift:14:31: error: missing argument label 'l:' in call\n\
    \    default: return monotonic(l.prefix(l.count - 1)) && monotonic(l.suffix(l.count\
    \ - 1))\n                              ^\n                              l: \n\
    /tmp/tmpdrv8_v5s.swift:14:33: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    default: return monotonic(l.prefix(l.count\
    \ - 1)) && monotonic(l.suffix(l.count - 1))\n                                ^\n\
    /tmp/tmpdrv8_v5s.swift:14:67: error: missing argument label 'l:' in call\n   \
    \ default: return monotonic(l.prefix(l.count - 1)) && monotonic(l.suffix(l.count\
    \ - 1))\n                                                                  ^\n\
    \                                                                  l: \n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let counts = l.enumerated().map{ (i, e) in (i, e) }\n\
    \    let (lo, hi) = counts.partition{ (lo, hi) in\n        lo < hi\n    }\n  \
    \  return hi > lo\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg1gwwfpd.swift:11:27: error: no exact matches in call to instance\
    \ method 'partition'\n    let (lo, hi) = counts.partition{ (lo, hi) in\n     \
    \                     ^\n/tmp/tmpg1gwwfpd.swift:11:27: note: found candidate with\
    \ type '(((Int, Int)) throws -> Bool) throws -> Array<(Int, Int)>.Index' (aka\
    \ '(((Int, Int)) throws -> Bool) throws -> Int')\n    let (lo, hi) = counts.partition{\
    \ (lo, hi) in\n                          ^\n/tmp/tmpg1gwwfpd.swift:11:27: error:\
    \ cannot convert value of type 'Array<(Int, Int)>.Index' (aka 'Int') to specified\
    \ type '(_, _)'\n    let (lo, hi) = counts.partition{ (lo, hi) in\n          \
    \         ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicTyped(l, IntType())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmplu6qsypq.swift:10:12: error: cannot find 'monotonicTyped' in scope\n\
    \    return monotonicTyped(l, IntType())\n           ^~~~~~~~~~~~~~\n/tmp/tmplu6qsypq.swift:10:30:\
    \ error: cannot find 'IntType' in scope\n    return monotonicTyped(l, IntType())\n\
    \                             ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn monotonicWithContext(context.Background(), l)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbokcw3c4.swift:10:9: error: cannot find 'monotonicWithContext'\
    \ in scope\n        return monotonicWithContext(context.Background(), l)\n   \
    \            ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbokcw3c4.swift:10:30: error: cannot\
    \ find 'context' in scope\n        return monotonicWithContext(context.Background(),\
    \ l)\n                                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028786
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let c = l.count\n    if c == 0 {\n        return true\n\
    \    }\n    \n    let d = l[c - 1]\n    for var i = 0; i < c - 1; i++ {\n    \
    \    let d = l[i]\n        if d < i {\n            return false\n        }\n \
    \       if d == i {\n            return true\n        }\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpilv982l3.swift:16:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 0; i < c - 1; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var monotonic = true\n    if l.count <= 1 {\n        return\
    \ true\n    }\n    var current = l[0]\n    for var i = 1; i < l.count; i++ {\n\
    \        if current < l[i] {\n            monotonic = false\n            break\n\
    \        }\n        current = l[i]\n    }\n    return monotonic\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4vu6rzd8.swift:15:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 1; i < l.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tif l.isEmpty() {\n\t\treturn true\n\t}\n\ts := l.slice()\n\
    \tsort.Sort(s)\n\treturn s[0] < s[len(s)-1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp16bsy_po.swift:13:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        s := l.slice()\n         ^\n         ;\n/tmp/tmp16bsy_po.swift:13:4:\
    \ error: expected expression\n        s := l.slice()\n          ^\n/tmp/tmp16bsy_po.swift:10:7:\
    \ error: cannot call value of non-function type 'Bool'\n        if l.isEmpty()\
    \ {\n             ^      ~~\n                    \n/tmp/tmp16bsy_po.swift:13:2:\
    \ error: cannot find 's' in scope\n        s := l.slice()\n        ^\n/tmp/tmp16bsy_po.swift:15:9:\
    \ error: cannot find 's' in scope\n        return s[0] < s[len(s)-1]\n       \
    \        ^\n/tmp/tmp16bsy_po.swift:15:16: error: cannot find 's' in scope\n  \
    \      return s[0] < s[len(s)-1]\n                      ^\n/tmp/tmp16bsy_po.swift:15:18:\
    \ error: cannot find 'len' in scope\n        return s[0] < s[len(s)-1]\n     \
    \                   ^~~\n/tmp/tmp16bsy_po.swift:15:22: error: cannot find 's'\
    \ in scope\n        return s[0] < s[len(s)-1]\n                            ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tvar prev Int = 0\n\tfor i := 0; i < len(l); i++ {\n\t\t\
    if l[i] > prev {\n\t\t\treturn false\n\t\t}\n\t\tprev = l[i]\n\t}\n\treturn true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2q9_00wt.swift:10:11: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var prev Int\
    \ = 0\n                 ^\n/tmp/tmp2q9_00wt.swift:10:11: note: join the identifiers\
    \ together\n        var prev Int = 0\n            ~~~~~^~~\n            prevInt\n\
    /tmp/tmp2q9_00wt.swift:11:9: error: expected type\n        for i := 0; i < len(l);\
    \ i++ {\n               ^\n                <#type#>\n/tmp/tmp2q9_00wt.swift:11:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(l);\
    \ i++ {\n               ^\n/tmp/tmp2q9_00wt.swift:11:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(l); i++ {\n      \
    \         ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  let len = l.count\n  var cur = l.endIndex\n  guard cur >=\
    \ l.startIndex else { return true }\n  var next: Int = 0\n  var first = true\n\
    \  while cur != next.advanced(by: 1) {\n    guard first else { first = false }\n\
    \    guard let el = cur + 1 else {\n      return false\n    }\n    if l[el] >\
    \ l[cur] { break }\n    next = el\n  }\n  return next == len\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpbmf04q5n.swift:17:11: error: initializer for conditional binding\
    \ must have Optional type, not 'Int'\n    guard let el = cur + 1 else {\n    \
    \      ^        ~~~~~~~\n/tmp/tmpbmf04q5n.swift:11:7: warning: variable 'cur'\
    \ was never mutated; consider changing to 'let' constant\n  var cur = l.endIndex\n\
    \  ~~~ ^\n  let\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.isEmpty {\n        return true\n    }\n    let len\
    \ = l.count\n    var i = 0\n    var j = len - 1\n    var k = len - 2\n    var\
    \ m = i\n    var n = j\n    let a0 = l[(m * k) + n] // a0 <= l[(m * k) + n]\n\
    \    var r = l[m]\n    var s = l[n]\n    while i < j {\n        while i < j &&\
    \ l[i] < r {\n            i += 1\n        }\n        while i < j && l[j] > r {\n\
    \            j -= 1\n        }\n        if i < j {\n            // if i is greater\
    \ than or equal to j\n            if l[i] < r {\n                i += 1\n    \
    \            // if i is still less than j, increment k\n                if i <\
    \ j {\n                    k += 1\n                }\n            }\n        \
    \    else {\n                j -= 1\n                // if i is greater than j,\
    \ decrement k\n                if i < j {\n                    k -= 1\n      \
    \          }\n            }\n        }\n        m = i\n        n = j\n       \
    \ r = l[m]\n        s = l[n]\n    }\n    i = j\n    j = len - 1\n    k = len -\
    \ 2\n    m = i\n    n = j\n    let a1 = l[(m * k) + n] // a1 >= l[(m * k) + n]\n\
    \    // if a0 <= a1, they are equal, no need to test further\n    return a0 ==\
    \ a1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) ==\
    \ true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1,\
    \ 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmppdq71be8/tmppdq71be8.swift:76: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae790501c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7901f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7901f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7901f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppdq71be8                        0x000055e6175d65ce <unavailable> + 5582

    5    libc.so.6                          0x00002ae7906ed460 __libc_start_main +
    245

    6    tmppdq71be8                        0x000055e6175d60a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return l.sorted { (left, right) -> Bool in\n        return\
    \ left < right\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp_rd5z8fo.swift:10:14: error: cannot convert return expression of\
    \ type '[Int]' to return type 'Bool'\n    return l.sorted { (left, right) -> Bool\
    \ in\n           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var min: Int = 0\n    for _i in l {\n        if _i < min\
    \ {\n            min = _i\n        }\n    }\n    for _i in l {\n        if _i\
    \ > min {\n            return true\n        }\n    }\n    return false\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmp8ltjfoqv/tmp8ltjfoqv.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0ba9bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0ba6b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0ba6b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0ba6b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ltjfoqv                        0x000055e8560415fe <unavailable> + 5630

    5    libc.so.6                          0x00002ae0baba9460 __libc_start_main +
    245

    6    tmp8ltjfoqv                        0x000055e8560410d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var i = 0\n    var j = l.count - 1\n    while i < j {\n\
    \        if l[i] < l[j] {\n            i += 1\n        } else if l[i] > l[j] {\n\
    \            j -= 1\n        } else {\n            return true\n        }\n  \
    \  }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpkfq7nfhy/tmpkfq7nfhy.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b082bd11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b082ba08b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b082ba08988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b082ba077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkfq7nfhy                        0x0000555fe19ca3b2 <unavailable> + 5042

    5    libc.so.6                          0x00002b082befd460 __libc_start_main +
    245

    6    tmpkfq7nfhy                        0x0000555fe19ca019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0:\n        return true\n \
    \   case 1:\n        return l[0] < l[1]\n    default:\n        var first = 1\n\
    \        var last = l[0]\n        for last > l[1] { first = last }\n        for\
    \ first < l[0] { last = first }\n        return first < last\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0kz92y4d.swift:18:18: error: expected 'in' after for-each pattern\n\
    \        for last > l[1] { first = last }\n                 ^\n/tmp/tmp0kz92y4d.swift:18:18:\
    \ error: unary operator cannot be separated from its operand\n        for last\
    \ > l[1] { first = last }\n                 ^~\n                  \n/tmp/tmp0kz92y4d.swift:19:19:\
    \ error: expected 'in' after for-each pattern\n        for first < l[0] { last\
    \ = first }\n                  ^\n/tmp/tmp0kz92y4d.swift:19:19: error: unary operator\
    \ cannot be separated from its operand\n        for first < l[0] { last = first\
    \ }\n                  ^~\n                   \n/tmp/tmp0kz92y4d.swift:18:18:\
    \ error: '>' is not a prefix unary operator\n        for last > l[1] { first =\
    \ last }\n                 ^\n/tmp/tmp0kz92y4d.swift:19:19: error: '<' is not\
    \ a prefix unary operator\n        for first < l[0] { last = first }\n       \
    \           ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    switch l.count {\n    case 0:\n        return false\n\
    \    case 1:\n        return true\n    case 2:\n        return l.first >= l.last\n\
    \    case 3:\n        return l.first < l.last && l.first <= l.last\n    default:\n\
    \        var lo = l.first\n        var hi = l.last\n        var x = lo\n     \
    \   var y = hi\n        var less = true\n        var lesses = false\n        var\
    \ greaters = false\n        while x < hi {\n            if y < lo {\n        \
    \        lesses = true\n            } else {\n                greater = true\n\
    \            }\n            y = hi\n            lo += 1\n            hi -= 1\n\
    \            less = false\n            greater = false\n            if x == hi\
    \ {\n                if y > hi {\n                    return false\n         \
    \       }\n                return true\n            }\n            if y < hi {\n\
    \                y = hi\n            }\n            if x < hi {\n            \
    \    x = hi\n            }\n        }\n        return !less && !greaters\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) ==\
    \ true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1,\
    \ 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpd8nusksu.swift:16:24: error: binary operator '>=' cannot be applied\
    \ to two 'Int?' operands\n        return l.first >= l.last\n               ~~~~~~~\
    \ ^  ~~~~~~\n/tmp/tmpd8nusksu.swift:16:24: note: overloads for '>=' exist with\
    \ these partially matching parameter lists: (Int, Int)\n        return l.first\
    \ >= l.last\n                       ^\n/tmp/tmpd8nusksu.swift:18:18: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ return l.first < l.last && l.first <= l.last\n                 ^\n/tmp/tmpd8nusksu.swift:18:18:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return l.first < l.last && l.first <= l.last\n              \
    \   ^\n                       ?? <#default value#>\n/tmp/tmpd8nusksu.swift:18:18:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return l.first < l.last && l.first <= l.last\n              \
    \   ^\n                      !\n/tmp/tmpd8nusksu.swift:18:28: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n        return\
    \ l.first < l.last && l.first <= l.last\n                           ^\n/tmp/tmpd8nusksu.swift:18:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return l.first < l.last && l.first <= l.last\n              \
    \             ^\n                                ?? <#default value#>\n/tmp/tmpd8nusksu.swift:18:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return l.first < l.last && l.first <= l.last\n              \
    \             ^\n                               !\n/tmp/tmpd8nusksu.swift:18:38:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        return l.first < l.last && l.first <= l.last\n                      \
    \               ^\n/tmp/tmpd8nusksu.swift:18:38: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        return l.first\
    \ < l.last && l.first <= l.last\n                                     "
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  let l = l.sorted()\n  return l.startIndex < l.endIndex &&\
    \ l[l.startIndex] == l[l.endIndex - 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20])\
    \ == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpr02sh_o7/tmpr02sh_o7.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63c30f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63c2df0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63c2df0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63c2def7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr02sh_o7                        0x0000564314e1b4b2 <unavailable> + 5298

    5    libc.so.6                          0x00002b63c32e5460 __libc_start_main +
    245

    6    tmpr02sh_o7                        0x0000564314e1b119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicGeneric(l: l, isOrdered: isOrdered)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx7klr_4m.swift:10:12: error: cannot find 'monotonicGeneric' in\
    \ scope\n    return monotonicGeneric(l: l, isOrdered: isOrdered)\n           ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpx7klr_4m.swift:10:46: error: cannot find 'isOrdered' in scope\n    return\
    \ monotonicGeneric(l: l, isOrdered: isOrdered)\n                             \
    \                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var result = true\n    for element in l {\n        if\
    \ element < l[l.index(element)-1] {\n            result = false\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpb3egm5e0.swift:12:26: error: no exact matches in call to instance\
    \ method 'index'\n        if element < l[l.index(element)-1] {\n             \
    \            ^\nSwift.Array:7:28: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(after:)')\n    @inlinable public func index(after i: Int)\
    \ -> Int\n                           ^\nSwift.Array:9:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Int) -> Int\n                           ^\nSwift.RandomAccessCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Self.Index) -> Self.Index\n       \
    \                    ^\nSwift.RandomAccessCollection:4:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Self.Index) -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let len = l.count\n    if len < 1 {\n        return true\n\
    \    }\n    if len == 1 {\n        return false\n    }\n    var prev = 0\n   \
    \ var curr = 1\n    for i in 0..<len - 1 {\n        if l[i] < prev {\n       \
    \     return false\n        }\n        prev = curr\n        curr = l[i]\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpu5525ah4/tmpu5525ah4.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba1d47f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1d44ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1d44eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1d44ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu5525ah4                        0x0000556bdcc786ce <unavailable> + 5838

    5    libc.so.6                          0x00002ba1d49e0460 __libc_start_main +
    245

    6    tmpu5525ah4                        0x0000556bdcc781a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\treturn isMonotonic(l.makeIterator())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpejzchf7p.swift:10:9: error: cannot find 'isMonotonic' in scope\n\
    \        return isMonotonic(l.makeIterator())\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicType(l.selfType, l.count)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwq7dzw8f.swift:10:12: error: cannot find 'monotonicType' in scope\n\
    \    return monotonicType(l.selfType, l.count)\n           ^~~~~~~~~~~~~\n/tmp/tmpwq7dzw8f.swift:10:28:\
    \ error: value of type '[Int]' has no member 'selfType'\n    return monotonicType(l.selfType,\
    \ l.count)\n                         ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var lo = l.first!\n  var hi = l.last!\n  while lo < hi {\n\
    \    var mid = lo + ((hi - lo) / 2)\n    if l[mid] > mid {\n      lo = mid + 1\n\
    \    } else {\n      hi = mid\n    }\n  }\n  return lo < l.last!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b43fa8bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43fa5b1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b43fa5b1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b43fa5b113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b43fa5b0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b43fa3b0e83 <unavailable> + 188035

    6    tmpqg01zd10                        0x0000558be9808e0e <unavailable> + 7694

    7    tmpqg01zd10                        0x0000558be98084ad <unavailable> + 5293

    8    libc.so.6                          0x00002b43faaa6460 __libc_start_main +
    245

    9    tmpqg01zd10                        0x0000558be9808189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  var min: Int = 0\n  var max: Int = Int(l.count)\n  repeat\
    \ {\n    min = 0\n    max -= 1\n    if l[min] > l[max] {\n      min += 1\n   \
    \ }\n  } while max > min\n  return min == max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmp16rsoy11/tmp16rsoy11.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab465a32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab465729b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab465729988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4657287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16rsoy11                        0x000055de55d1566e <unavailable> + 5742

    5    libc.so.6                          0x00002ab465c1e460 __libc_start_main +
    245

    6    tmp16rsoy11                        0x000055de55d15149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let min = l.min()\n    let max = l.max()\n    return min\
    \ < max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4,\
    \ 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdts74pda.swift:12:16: error: binary operator '<' cannot be applied\
    \ to two 'Int?' operands\n    return min < max\n           ~~~ ^ ~~~\n/tmp/tmpdts74pda.swift:12:16:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    return min < max\n               ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tlet sorted = l.sorted()\n\tguard sorted.count > 1 else {\
    \ return true }\n\n\tlet first = sorted[0]\n\tlet last = sorted[sorted.count -\
    \ 1]\n\n\tif first >= last {\n\t\treturn true\n\t}\n\n\tvar prev: Int\n\tif sorted.count\
    \ > 2 {\n\t\tprev = sorted[1]\n\t} else {\n\t\tprev = last\n\t}\n\n\treturn first\
    \ >= prev\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2,\
    \ 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmpt24w5z74/tmpt24w5z74.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33e3d48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33e3a3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33e3a3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33e3a3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt24w5z74                        0x0000562067bac452 <unavailable> + 5202

    5    libc.so.6                          0x00002b33e3f34460 __libc_start_main +
    245

    6    tmpt24w5z74                        0x0000562067bac0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n  return isMonotonic(l: l)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2,\
    \ 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfy00tbtl.swift:10:10: error: cannot find 'isMonotonic' in scope\n\
    \  return isMonotonic(l: l)\n         ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var l = l // force evaluation\n    var j = l.startIndex\n\
    \    var m = Int64(0)\n    while j < l.endIndex {\n        if m*(m+1)/2 <= l[j]\
    \ {\n            if m > j {\n                m = l[j]\n            }\n       \
    \ } else {\n            j = j + 1\n        }\n    }\n    return m == l[j]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpta3j6616.swift:16:22: error: cannot assign value of type 'Int'\
    \ to type 'Int64'\n                m = l[j]\n                    ~^~~\n      \
    \              Int64( )\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let sw = l.sort()\n    return sw == l\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyubb63vu.swift:10:16: error: cannot use mutating member on immutable\
    \ value: 'l' is a 'let' constant\n    let sw = l.sort()\n             ~ ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    var a = l.count\n    if a == 0 {\n        return true\n\
    \    }\n\n    if a > 2 {\n        return false\n    }\n\n    var b = l.count\n\
    \    while b > 2 {\n        if l[b-1] > l[b-2] == true {\n            return false\n\
    \        }\n        if l[b-1] < l[b-2] == false {\n            return true\n \
    \       }\n        if b == 1 {\n            return true\n        }\n        b\
    \ /= 2\n    }\n\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6sst47w4.swift:21:19: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n        if l[b-1] > l[b-2] == true\
    \ {\n                  ^        ~~\n/tmp/tmp6sst47w4.swift:24:19: error: adjacent\
    \ operators are in non-associative precedence group 'ComparisonPrecedence'\n \
    \       if l[b-1] < l[b-2] == false {\n                  ^        ~~\n/tmp/tmp6sst47w4.swift:10:9:\
    \ warning: variable 'a' was never mutated; consider changing to 'let' constant\n\
    \    var a = l.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tvar left, right int\n\tfor i := range l {\n\t\tif i < right\
    \ {\n\t\t\tif left <= i {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tleft = i\n\t\t\
    }\n\t\tif i > left {\n\t\t\tif right <= i {\n\t\t\t\treturn false\n\t\t\t}\n\t\
    \t\tright = i\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20])\
    \ == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuomg7jzc.swift:10:18: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var left, right\
    \ int\n                        ^\n/tmp/tmpuomg7jzc.swift:10:18: note: join the\
    \ identifiers together\n        var left, right int\n                  ~~~~~~^~~\n\
    \                  rightint\n/tmp/tmpuomg7jzc.swift:10:18: note: join the identifiers\
    \ together with camel-case\n        var left, right int\n                  ~~~~~~^~~\n\
    \                  rightInt\n/tmp/tmpuomg7jzc.swift:11:9: error: expected type\n\
    \        for i := range l {\n               ^\n                <#type#>\n/tmp/tmpuomg7jzc.swift:11:9:\
    \ error: expected 'in' after for-each pattern\n        for i := range l {\n  \
    \             ^\n/tmp/tmpuomg7jzc.swift:11:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := range l {\n               ^\n/tmp/tmpuomg7jzc.swift:10:6:\
    \ error: type annotation missing in pattern\n        var left, right int\n   \
    \         ^\n/tmp/tmpuomg7jzc.swift:10:12: error: type annotation missing in pattern\n\
    \        var left, right int\n                  ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonicArray(l, true, nil)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpsccoplfl.swift:10:12: error: cannot find 'monotonicArray' in scope\n\
    \    return monotonicArray(l, true, nil)\n           ^~~~~~~~~~~~~~\n/tmp/tmpsccoplfl.swift:10:36:\
    \ error: 'nil' requires a contextual type\n    return monotonicArray(l, true,\
    \ nil)\n                                   ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    for index, _ := range l {\n        if index < 1 {\n  \
    \          return false\n        }\n    }\n\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqr1o4d66.swift:10:14: error: expected 'in' after for-each pattern\n\
    \    for index, _ := range l {\n             ^\n/tmp/tmpqr1o4d66.swift:10:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, _ := range\
    \ l {\n             ^\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n\tswitch l.count {\n\tcase 0:\n\t\treturn true\n\tcase 1:\n\
    \t\treturn l[0] < l[0]\n\tdefault:\n\t\tlet minV = l.min()!\n\t\tvar v = minV\n\
    \t\tfor _ in 1..<(l.count - 1) {\n\t\t\tv = l[0] + v\n\t\t}\n\t\treturn v > minV\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) ==\
    \ true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1,\
    \ 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'tmp8k12zvyj/tmp8k12zvyj.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b02ff3bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02ff0b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b02ff0b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02ff0b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8k12zvyj                        0x000055faa45d676e <unavailable> + 5998

    5    libc.so.6                          0x00002b02ff5ab460 __libc_start_main +
    245

    6    tmp8k12zvyj                        0x000055faa45d6249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: 1
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    return monotonic0(l.startIndex, l.endIndex, l.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpicx8a1c2.swift:10:12: error: cannot find 'monotonic0' in scope\n\
    \    return monotonic0(l.startIndex, l.endIndex, l.count)\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    let sorted = l.sorted()\n    return sorted.first == sorted.last\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
    \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
    \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
    \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) ==\
    \ true)\nassert(monotonic(l: [9, 9, 9, 9]) == true)"
  status: Exception
  stderr: 'tmpt8z9q66o/tmpt8z9q66o.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650bf4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad6508ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad6508eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6508ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt8z9q66o                        0x0000555a238234e2 <unavailable> + 5346

    5    libc.so.6                          0x00002ad650de0460 __libc_start_main +
    245

    6    tmpt8z9q66o                        0x0000555a23823149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660028787
- exit_code: -4
  program: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
    /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4,\
    \ 10])\n/// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l:\
    \ [Int]) -> Bool {\n    if l.count < 2 {\n        return true\n    }\n    for\
    \ i in 0..<l.count {\n        if l[i] < l[i-1] {\n            return false\n \
    \       }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(monotonic(l:\
    \ [1, 2, 4, 10]) == true)\nassert(monotonic(l: [1, 2, 4, 20]) == true)\nassert(monotonic(l:\
    \ [1, 20, 4, 10]) == false)\nassert(monotonic(l: [4, 1, 0, -10]) == true)\nassert(monotonic(l:\
    \ [4, 1, 1, 0]) == true)\nassert(monotonic(l: [1, 2, 3, 2, 5, 60]) == false)\n\
    assert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\nassert(monotonic(l: [9, 9,\
    \ 9, 9]) == true)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b508fbc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b508f8bc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b508f8bc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b508f8bc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b508f8bbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b508f6bbe83 <unavailable> + 188035

    6    tmpjvhrv9wk                        0x000055e602462cfb <unavailable> + 7419

    7    tmpjvhrv9wk                        0x000055e6024624cd <unavailable> + 5325

    8    libc.so.6                          0x00002b508fdb1460 __libc_start_main +
    245

    9    tmpjvhrv9wk                        0x000055e6024621a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660028787
