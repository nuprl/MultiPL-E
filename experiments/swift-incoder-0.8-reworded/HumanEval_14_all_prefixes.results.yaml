language: swift
name: HumanEval_14_all_prefixes
results:
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tlet stringArray = string.characters.split{$0\
    \ == $0}\n\treturn stringArray.filter{$0.isPrefix}.map{$0.dropLast()}\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6kflxezl.swift:6:27: error: 'characters' is unavailable: Please\
    \ use String directly\n        let stringArray = string.characters.split{$0 ==\
    \ $0}\n                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6kflxezl.swift:7:31: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'isPrefix'\n        return stringArray.filter{$0.isPrefix}.map{$0.dropLast()}\n\
    \                                  ~~ ^~~~~~~~\n/tmp/tmp6kflxezl.swift:7:48: error:\
    \ cannot convert value of type 'Substring.SubSequence' (aka 'Substring') to closure\
    \ result type 'String'\n        return stringArray.filter{$0.isPrefix}.map{$0.dropLast()}\n\
    \                                                   ~~~^~~~~~~~~~\n          \
    \                                         String(      )\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\treturn all_prefixes_(string,\
    \ \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\
    \") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"\
    as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppmewqdjf.swift:6:9: error: cannot find 'all_prefixes_' in scope\n\
    \        return all_prefixes_(string, \"\")\n               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    var currentCharIndex = 0\n    var lastPrefix: String = \"\"\n\n    while\
    \ currentCharIndex < string.characters.count {\n        if string.starts(with:\
    \ lastPrefix) {\n            result.append(lastPrefix)\n            currentCharIndex\
    \ += lastPrefix.count\n            lastPrefix = \"\"\n        } else {\n     \
    \       lastPrefix = lastPrefix + string.substring(from: currentCharIndex)\n \
    \       }\n        currentCharIndex += 1\n    }\n\n    result.append(lastPrefix)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_ev4qz7k.swift:10:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    while currentCharIndex < string.characters.count {\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_ev4qz7k.swift:16:46: error: value of type 'String'\
    \ has no member 'substring'\n            lastPrefix = lastPrefix + string.substring(from:\
    \ currentCharIndex)\n                                      ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \n\tfor len(string) > 0 {\n\t\tprefixes.append(String(string))\n\t\tstring = string[..<len(string)]\n\
    \t}\n\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmps0vy835p.swift:8:9: error: expected 'in' after for-each pattern\n\
    \        for len(string) > 0 {\n               ^\n/tmp/tmps0vy835p.swift:8:18:\
    \ error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for len(string)\
    \ > 0 {\n               ~~~~~~~~~^~~\n/tmp/tmps0vy835p.swift:8:10: error: cannot\
    \ convert value of type 'String' to expected argument type 'Int'\n        for\
    \ len(string) > 0 {\n                ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var substring = string\n\n    while substring.count > 0 {\n        let prefixLength\
    \ = substring.characters.count + string.characters.count\n        let prefixSubstring\
    \ = substring(from: prefixLength)\n        prefixes.append(prefixSubstring)\n\
    \        substring = prefixSubstring\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj322_6zf.swift:10:38: error: 'characters' is unavailable: Please\
    \ use String directly\n        let prefixLength = substring.characters.count +\
    \ string.characters.count\n                                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpj322_6zf.swift:10:64: error: 'characters'\
    \ is unavailable: Please use String directly\n        let prefixLength = substring.characters.count\
    \ + string.characters.count\n                                                \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpj322_6zf.swift:11:31: error: cannot call value of non-function type\
    \ 'String'\n        let prefixSubstring = substring(from: prefixLength)\n    \
    \                          ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar arr = [String]()\n\tprefixes\
    \ {\n\t\tarr.append($0)\n\t}\n\treturn arr\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp86p2yz5r.swift:7:2: error: cannot find 'prefixes' in scope\n  \
    \      prefixes {\n        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" {\n   \
    \     return []\n    }\n    var prefixes: [String] = []\n    var len = string.count\n\
    \    var index = 0\n    repeat {\n        prefixes.append(string.prefix(index))\n\
    \        index = index + 1\n    } while (index != len)\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0rgwh8ve.swift:13:18: error: no exact matches in call to instance\
    \ method 'append'\n        prefixes.append(string.prefix(index))\n           \
    \      ^\nSwift.Array:6:37: note: candidate expects value of type 'String' for\
    \ parameter #1 (got 'PrefixSequence<String>')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'PrefixSequence<String>')\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Self.Element)\n          \
    \                          ^\n/tmp/tmp0rgwh8ve.swift:13:18: note: found candidate\
    \ with type '(__owned PrefixSequence<String>) -> ()'\n        prefixes.append(string.prefix(index))\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefix = \"\"\n    var\
    \ prefixes = [String]()\n\n    for c in string.utf8 {\n        prefix += String(c)\n\
    \        if prefixes.contains(prefix) {\n            continue\n        }\n\n \
    \       prefixes.append(prefix)\n        prefix = \"\"\n    }\n\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpytdwaag6/tmpytdwaag6.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3146db7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3146aaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3146aae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3146aad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpytdwaag6                        0x000055cb8287db28 <unavailable> + 6952

    5    libc.so.6                          0x00002b3146fa3460 __libc_start_main +
    245

    6    tmpytdwaag6                        0x000055cb8287d589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, shortest:\
    \ true, longest: false).map { $0.prefixString }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxkgxuo0g.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, shortest: true, longest: false).map { $0.prefixString\
    \ }\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \t\n\tlet stringLength = string.characters.count\n\t\n\t// If string is empty\n\
    \tif stringLength < 1 {\n\t\treturn prefixes\n\t}\n\t\n\tvar characterIndex =\
    \ 0\n\tvar characterValue = string.characters.first!\n\t\n\t// Loop through the\
    \ string\n\tfor characterIndex < stringLength {\n\t\tif characterValue != string.characters.last!\
    \ {\n\t\t\tprefixes.append(String(characterValue))\n\t\t}\n\t\t\n\t\tcharacterIndex\
    \ += 1\n\t\tcharacterValue = string.characters.enumerated().last!.element\n\t\
    }\n\t\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi77_15xm.swift:19:21: error: expected 'in' after for-each pattern\n\
    \        for characterIndex < stringLength {\n                           ^\n/tmp/tmpi77_15xm.swift:19:21:\
    \ error: unary operator cannot be separated from its operand\n        for characterIndex\
    \ < stringLength {\n                           ^~\n                          \
    \  \n/tmp/tmpi77_15xm.swift:8:28: error: 'characters' is unavailable: Please use\
    \ String directly\n        let stringLength = string.characters.count\n      \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpi77_15xm.swift:16:30: error: 'characters' is unavailable:\
    \ Please use String directly\n        var characterValue = string.characters.first!\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpi77_15xm.swift:19:21: error: '<' is not a prefix unary\
    \ operator\n        for characterIndex < stringLength {\n                    \
    \       ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var res = Array(count: string.count,\
    \ repeatedValue: \"\")\n    for ch in string.unicodeScalars {\n        res.append(String(ch))\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi7t7nopx.swift:6:15: error: no exact matches in call to initializer\
    \ \n    var res = Array(count: string.count, repeatedValue: \"\")\n          \
    \    ^\n/tmp/tmpi7t7nopx.swift:6:15: note: candidate has partially matching parameter\
    \ list (repeating: _, count: Int)\n    var res = Array(count: string.count, repeatedValue:\
    \ \"\")\n              ^\n/tmp/tmpi7t7nopx.swift:6:15: note: candidate has partially\
    \ matching parameter list (repeating: _, count: Int)\n    var res = Array(count:\
    \ string.count, repeatedValue: \"\")\n              ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    for start in 0..<string.characters.count {\n        var prefix = string[start]\n\
    \        for _ in 0..<(string.characters.count - start) {\n            prefix\
    \ += string[start + 1]\n            result.append(prefix)\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmphgo2wnpa.swift:7:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for start in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphgo2wnpa.swift:8:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        var prefix\
    \ = string[start]\n                     ^~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmphgo2wnpa.swift:9:30: error:\
    \ 'characters' is unavailable: Please use String directly\n        for _ in 0..<(string.characters.count\
    \ - start) {\n                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmphgo2wnpa.swift:10:20: error: binary operator\
    \ '+=' cannot be applied to two 'Character' operands\n            prefix += string[start\
    \ + 1]\n                   ^\nSwift.FloatingPoint:1:17: note: candidate requires\
    \ that 'Character' conform to 'FloatingPoint' (requirement specified as 'Self'\
    \ : 'FloatingPoint')\npublic protocol FloatingPoint : Hashable, SignedNumeric,\
    \ Strideable where Self == Self.Magnitude {\n                ^\n/tmp/tmphgo2wnpa.swift:11:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result.append(prefix)\n                          ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tif let index = string.startIndex\
    \ {\n\t\tif string.hasPrefix(string[index...]) {\n\t\t\treturn [string[...index]...].flatMap\
    \ { all_prefixes(string: $0) }\n\t\t}\n\t}\n\treturn []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkg42y7iu.swift:8:28: error: cannot convert value of type 'PartialRangeFrom<String.SubSequence>'\
    \ (aka 'PartialRangeFrom<Substring>') to expected element type 'String'\n    \
    \                    return [string[...index]...].flatMap { all_prefixes(string:\
    \ $0) }\n                                                ^\n/tmp/tmpkg42y7iu.swift:6:5:\
    \ error: initializer for conditional binding must have Optional type, not 'String.Index'\n\
    \        if let index = string.startIndex {\n           ^           ~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefix = \"\"\n    var\
    \ prefix_array = [String]()\n    for c in string.characters {\n        if c.isLetterOrDigit()\
    \ {\n            prefix += c\n        } else {\n            if prefix != \"\"\
    \ {\n                prefix_array.append(prefix)\n                prefix = \"\"\
    \n            }\n        }\n    }\n    if prefix != \"\" {\n        prefix_array.append(prefix)\n\
    \    }\n    return prefix_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdmc_e5ey.swift:8:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdmc_e5ey.swift:9:14:\
    \ error: value of type 'Character' has no member 'isLetterOrDigit'\n        if\
    \ c.isLetterOrDigit() {\n           ~ ^~~~~~~~~~~~~~~\n/tmp/tmpdmc_e5ey.swift:10:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefix += c\n                      ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj7evbu6k.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string).reversed()\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result = Array<String>()\n\
    \    var current = \"\"\n    for character in string {\n        if character ==\
    \ \"\" {\n            current = \"\"\n        } else {\n            current =\
    \ current + String(character)\n        }\n        if current.count > result.count\
    \ {\n            result = current\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6zdga65p.swift:9:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if character == \"\" {\n\
    \           ~~~~~~~~~ ^  ~~\n/tmp/tmp6zdga65p.swift:9:22: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if character == \"\" {\n                     ^\n/tmp/tmp6zdga65p.swift:15:22:\
    \ error: cannot assign value of type 'String' to type '[String]'\n           \
    \ result = current\n                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var stringWithoutPrefixes = string\n    for c in stringWithoutPrefixes {\n\
    \        prefixes += all_prefixes(stringWithoutPrefixes.substringToIndex(0))\n\
    \        prefixes.append(c)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy78yikmh.swift:9:34: error: missing argument label 'string:' in\
    \ call\n        prefixes += all_prefixes(stringWithoutPrefixes.substringToIndex(0))\n\
    \                                 ^\n                                 string:\
    \ \n/tmp/tmpy78yikmh.swift:9:56: error: value of type 'String' has no member 'substringToIndex'\n\
    \        prefixes += all_prefixes(stringWithoutPrefixes.substringToIndex(0))\n\
    \                                 ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpy78yikmh.swift:10:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        prefixes.append(c)\n                        ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\treturn _all_prefixes.call(unsafeUnretainedPointer(mutatingSelf(string)),\
    \ string)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnbvtdqkf.swift:6:9: error: cannot find '_all_prefixes' in scope\n\
    \        return _all_prefixes.call(unsafeUnretainedPointer(mutatingSelf(string)),\
    \ string)\n               ^~~~~~~~~~~~~\n/tmp/tmpnbvtdqkf.swift:6:28: error: cannot\
    \ find 'unsafeUnretainedPointer' in scope\n        return _all_prefixes.call(unsafeUnretainedPointer(mutatingSelf(string)),\
    \ string)\n                                  ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnbvtdqkf.swift:6:52:\
    \ error: cannot find 'mutatingSelf' in scope\n        return _all_prefixes.call(unsafeUnretainedPointer(mutatingSelf(string)),\
    \ string)\n                                                          ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, 0)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpp57tx2om.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, 0)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\treturn string[1..<string.count].split(separator:\
    \ \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\
    \") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"\
    as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmvhh2zfv.swift:6:34: error: cannot convert return expression of\
    \ type '[String.SubSequence]' (aka 'Array<Substring>') to return type '[String]'\n\
    \        return string[1..<string.count].split(separator: \"\")\n            \
    \                            ^\n/tmp/tmpmvhh2zfv.swift:6:34: note: arguments to\
    \ generic parameter 'Element' ('String.SubSequence' (aka 'Substring') and 'String')\
    \ are expected to be equal\n        return string[1..<string.count].split(separator:\
    \ \"\")\n                                        ^\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] =\
    \ []\n    var stringArray: [String] = string.characters.split(separator: \".\"\
    ).map(String.init)\n    for i in 0..<stringArray.count {\n        var prefix =\
    \ \"\"\n        let element = stringArray[i]\n        for j in i..<stringArray.count\
    \ {\n            let element = stringArray[j]\n            if element != \"\"\
    \ {\n                prefix += element\n                prefixes.append(prefix)\n\
    \                prefix = \"\"\n            }\n        }\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpke9nkbyk.swift:7:40: error: 'characters' is unavailable: Please\
    \ use String directly\n    var stringArray: [String] = string.characters.split(separator:\
    \ \".\").map(String.init)\n                                       ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpke9nkbyk.swift:7:9:\
    \ warning: variable 'stringArray' was never mutated; consider changing to 'let'\
    \ constant\n    var stringArray: [String] = string.characters.split(separator:\
    \ \".\").map(String.init)\n    ~~~ ^\n    let\n/tmp/tmpke9nkbyk.swift:10:13: warning:\
    \ initialization of immutable value 'element' was never used; consider replacing\
    \ with assignment to '_' or removing it\n        let element = stringArray[i]\n\
    \        ~~~~^~~~~~~\n        _\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let short = string.prefix(string.length)\n\
    \    return Array(short.suffix(1))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmptvjvs2mx.swift:6:38: error: value of type 'String' has no member\
    \ 'length'\n    let short = string.prefix(string.length)\n                   \
    \           ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result = [String]()\n\
    \    for s in string.split(separator: \".\") {\n        let trimmed = s.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \".\")!)\n        if !trimmed.isEmpty {\n       \
    \     result.append(trimmed)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpws1zv1g4.swift:8:48: error: cannot find 'CharacterSet' in scope\n\
    \        let trimmed = s.trimmingCharacters(in: CharacterSet(charactersIn: \"\
    .\")!)\n                                               ^~~~~~~~~~~~\n/tmp/tmpws1zv1g4.swift:8:25:\
    \ error: value of type 'String.SubSequence' (aka 'Substring') has no member 'trimmingCharacters'\n\
    \        let trimmed = s.trimmingCharacters(in: CharacterSet(charactersIn: \"\
    .\")!)\n                      ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return strings.Prefixes(string).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1fw1lw3g.swift:6:12: error: cannot find 'strings' in scope\n  \
    \  return strings.Prefixes(string).sorted()\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_helper(string)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdh0_7fww.swift:6:12: error: cannot find 'all_prefixes_helper' in\
    \ scope\n    return all_prefixes_helper(string)\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" { return\
    \ [] }\n    var maxLength = 0\n    var prefixes = [String]()\n    for char in\
    \ string {\n        if maxLength > 0 {\n            prefixes.append(String(char)\
    \ + String(string[string.startIndex.advancedBy(maxLength - 1)]))\n        }\n\
    \        maxLength = max(maxLength, string.countCharacters(in: String(char)))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjcv4rrk4.swift:11:76: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n            prefixes.append(String(char) + String(string[string.startIndex.advancedBy(maxLength\
    \ - 1)]))\n                                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpjcv4rrk4.swift:13:43: error: value of type 'String' has\
    \ no member 'countCharacters'\n        maxLength = max(maxLength, string.countCharacters(in:\
    \ String(char)))\n                                   ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" {\n   \
    \     return nil\n    }\n\n    let start = string[0]\n    var prefixes: [String]\
    \ = []\n    var current = start\n    for c in string {\n        if c == current\
    \ {\n            prefixes.append(current)\n        } else {\n            prefixes.append(current)\n\
    \            prefixes.append(c)\n        }\n        current = c\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv1nqwitf.swift:7:16: error: 'nil' is incompatible with return type\
    \ '[String]'\n        return nil\n               ^\n/tmp/tmpv1nqwitf.swift:10:17:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n    let start = string[0]\n                ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpv1nqwitf.swift:15:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefixes.append(current)\n                            ^\n/tmp/tmpv1nqwitf.swift:17:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefixes.append(current)\n                            ^\n/tmp/tmpv1nqwitf.swift:18:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefixes.append(c)\n                            ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" {\n   \
    \     return [0]\n    }\n    var prefix_array = [String]()\n    var prefix_count\
    \ = 0\n    var char_index = 0\n    for _ in 0..<string.characters.count {\n  \
    \      char_index += 1\n        prefix_count = char_index\n        if let last_index\
    \ = string.characters.index(of: String(string.characters[char_index]), from: char_index)\
    \ {\n            prefix_array.append(String(string.characters[last_index...]))\n\
    \            prefix_array.append(String(string.characters[char_index...]))\n \
    \       } else {\n            prefix_array.append(String(string.characters[char_index...]))\n\
    \        }\n    }\n    return prefix_array\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpestfje61.swift:7:17: error: cannot convert value of type 'Int'\
    \ to expected element type 'String'\n        return [0]\n                ^\n/tmp/tmpestfje61.swift:12:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    for _ in\
    \ 0..<string.characters.count {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpestfje61.swift:15:102: error: extra argument\
    \ 'from' in call\n        if let last_index = string.characters.index(of: String(string.characters[char_index]),\
    \ from: char_index) {\n                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n\
    /tmp/tmpestfje61.swift:15:57: error: cannot convert value of type 'String' to\
    \ expected argument type 'String.Element' (aka 'Character')\n        if let last_index\
    \ = string.characters.index(of: String(string.characters[char_index]), from: char_index)\
    \ {\n                                                        ^\n/tmp/tmpestfje61.swift:16:57:\
    \ error: no exact matches in call to subscript \n            prefix_array.append(String(string.characters[last_index...]))\n\
    \                                                        ^\n/tmp/tmpestfje61.swift:16:57:\
    \ note: found candidate with type '(String.Index) -> Character'\n            prefix_array.append(String(string.characters[last_index...]))\n\
    \                                                        ^\n/tmp/tmpestfje61.swift:16:57:\
    \ note: found candidate with type '(Range<String.Index>) -> Substring'\n     \
    \       prefix_array.append(String(string.characters[last_index...]))\n      \
    \                                                  ^\n/tmp/tmpestfje61.swift:16:57:\
    \ note: found candidate with type '(()) -> String.SubSequence' (aka '(()) -> Substring')\n\
    \            prefix_array.append(String(string.characters[last_index...]))\n \
    \                                                       ^\n/tmp/tmpestfje61.swift:16:57:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for let index = string.firstIndex(of: \"\") {\n        prefixes.append(String(string.suffixFrom(index)))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpums0ry9b.swift:7:9: error: 'let' pattern cannot appear nested in\
    \ an already immutable context\n    for let index = string.firstIndex(of: \"\"\
    ) {\n        ^\n/tmp/tmpums0ry9b.swift:7:19: error: expected 'in' after for-each\
    \ pattern\n    for let index = string.firstIndex(of: \"\") {\n               \
    \   ^\n/tmp/tmpums0ry9b.swift:7:19: error: expected Sequence expression for for-each\
    \ loop\n    for let index = string.firstIndex(of: \"\") {\n                  ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq_p5i73o.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, 1)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    result.reserveCapacity(strings.Length)\n    for c in string {\n        result.append(string[..<string.IndexOf(c)].trimmed())\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpywuork_j.swift:7:28: error: cannot find 'strings' in scope\n  \
    \  result.reserveCapacity(strings.Length)\n                           ^~~~~~~\n\
    /tmp/tmpywuork_j.swift:9:40: error: value of type 'String' has no member 'IndexOf'\n\
    \        result.append(string[..<string.IndexOf(c)].trimmed())\n             \
    \                   ~~~~~~ ^~~~~~~\n/tmp/tmpywuork_j.swift:9:52: error: value\
    \ of type 'String.SubSequence' (aka 'Substring') has no member 'trimmed'\n   \
    \     result.append(string[..<string.IndexOf(c)].trimmed())\n                \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let prefixesMutable = string.mutableCopy()\
    \ as! NSMutableString\n    let prefixes = Array(prefixesMutable.componentsSeparatedByString(\"\
    \"))\n    prefixesMutable.removeLast()\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwwmhd7_1.swift:6:52: error: cannot find type 'NSMutableString'\
    \ in scope\n    let prefixesMutable = string.mutableCopy() as! NSMutableString\n\
    \                                                   ^~~~~~~~~~~~~~~\n/tmp/tmpwwmhd7_1.swift:6:34:\
    \ error: value of type 'String' has no member 'mutableCopy'\n    let prefixesMutable\
    \ = string.mutableCopy() as! NSMutableString\n                          ~~~~~~\
    \ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \n    for start in 0..<string.characters.count {\n        let end = string.distance(from:\
    \ String.Index(encodedOffset: start), to: String.Index(encodedOffset: string.characters.count))\n\
    \        let prefix = string.substring(with: String.Index(string: string, offsetBy:\
    \ start))\n        result.append(prefix)\n    }\n\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmphnef0yij.swift:8:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for start in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphnef0yij.swift:9:48: warning: 'init(encodedOffset:)' is deprecated:\
    \ encodedOffset has been deprecated as most common usage is incorrect. Use String.Index(utf16Offset:in:)\
    \ to achieve the same behavior.\n        let end = string.distance(from: String.Index(encodedOffset:\
    \ start), to: String.Index(encodedOffset: string.characters.count))\n        \
    \                                       ^\n/tmp/tmphnef0yij.swift:9:88: warning:\
    \ 'init(encodedOffset:)' is deprecated: encodedOffset has been deprecated as most\
    \ common usage is incorrect. Use String.Index(utf16Offset:in:) to achieve the\
    \ same behavior.\n        let end = string.distance(from: String.Index(encodedOffset:\
    \ start), to: String.Index(encodedOffset: string.characters.count))\n        \
    \                                                                            \
    \   ^\n/tmp/tmphnef0yij.swift:9:116: error: 'characters' is unavailable: Please\
    \ use String directly\n        let end = string.distance(from: String.Index(encodedOffset:\
    \ start), to: String.Index(encodedOffset: string.characters.count))\n        \
    \                                                                            \
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphnef0yij.swift:10:29: error: value of type 'String'\
    \ has no member 'substring'\n        let prefix = string.substring(with: String.Index(string:\
    \ string, offsetBy: start))\n                     ~~~~~~ ^~~~~~~~~\n/tmp/tmphnef0yij.swift:10:57:\
    \ error: incorrect argument labels in call (have 'string:offsetBy:', expected\
    \ '_:within:')\n        let prefix = string.substring(with: String.Index(string:\
    \ string, offsetBy: start))\n            "
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tif string == \"\" {\n\t\treturn\
    \ []\n\t}\n\tprefixes = [\"\"]\n\tvar current = \"\"\n\tfor i := 0; i < len(string);\
    \ i++ {\n\t\tcurrent += string[i]\n\t\tprefixes = append(prefixes, current)\n\t\
    \tcurrent = \"\"\n\t}\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0hy3xy__.swift:11:9: error: expected type\n        for i := 0;\
    \ i < len(string); i++ {\n               ^\n                <#type#>\n/tmp/tmp0hy3xy__.swift:11:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(string);\
    \ i++ {\n               ^\n/tmp/tmp0hy3xy__.swift:11:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(string); i++ {\n \
    \              ^\n/tmp/tmp0hy3xy__.swift:9:2: error: cannot find 'prefixes' in\
    \ scope\n        prefixes = [\"\"]\n        ^~~~~~~~\n/tmp/tmp0hy3xy__.swift:16:9:\
    \ error: cannot find 'prefixes' in scope\n        return prefixes\n          \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if let splitString = string.characters,\
    \ !splitString.isEmpty {\n        var prefixes = [String]()\n        var currentPrefix\
    \ = \"\"\n        for char in splitString {\n            if char <= ' ' {\n  \
    \              prefixes.append(currentPrefix)\n                currentPrefix =\
    \ \"\"\n                continue\n            }\n            if char == ' ' {\n\
    \                prefixes.append(currentPrefix)\n            }\n            currentPrefix\
    \ = currentPrefix + String(char)\n        }\n        prefixes.append(currentPrefix)\n\
    \        return prefixes\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7yf1dfhr.swift:10:24: error: single-quoted string literal found,\
    \ use '\"'\n            if char <= ' ' {\n                       ^~~\n       \
    \                \" \"\n/tmp/tmp7yf1dfhr.swift:15:24: error: single-quoted string\
    \ literal found, use '\"'\n            if char == ' ' {\n                    \
    \   ^~~\n                       \" \"\n/tmp/tmp7yf1dfhr.swift:6:33: error: 'characters'\
    \ is unavailable: Please use String directly\n    if let splitString = string.characters,\
    \ !splitString.isEmpty {\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp7yf1dfhr.swift:6:8: error: initializer\
    \ for conditional binding must have Optional type, not 'String'\n    if let splitString\
    \ = string.characters, !splitString.isEmpty {\n       ^                 ~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentPrefix = \"\"\n    for character in string.characters {\n    \
    \    let prefix = currentPrefix\n        let isBeginningOfNewPrefix = currentPrefix.characters.count\
    \ < character.characters.count\n        currentPrefix = currentPrefix.appending(character)\n\
    \        prefixes.append(prefix)\n        if !isBeginningOfNewPrefix {\n     \
    \       return prefixes\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgrw_o2ri.swift:8:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in string.characters {\n            \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpgrw_o2ri.swift:10:81: error: value of type 'Character' has no member\
    \ 'characters'\n        let isBeginningOfNewPrefix = currentPrefix.characters.count\
    \ < character.characters.count\n                                             \
    \                         ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpgrw_o2ri.swift:11:39:\
    \ error: value of type 'String' has no member 'appending'\n        currentPrefix\
    \ = currentPrefix.appending(character)\n                        ~~~~~~~~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return getPrefixes(string,\
    \ minimumLength: 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp10oi7r1d.swift:6:12: error: cannot find 'getPrefixes' in scope\n\
    \    return getPrefixes(string, minimumLength: 1)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" {\n   \
    \     return nil\n    }\n    return prefixes(string, len(string))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpab13eszl.swift:7:16: error: 'nil' is incompatible with return type\
    \ '[String]'\n        return nil\n               ^\n/tmp/tmpab13eszl.swift:9:12:\
    \ error: cannot find 'prefixes' in scope\n    return prefixes(string, len(string))\n\
    \           ^~~~~~~~\n/tmp/tmpab13eszl.swift:9:29: error: cannot find 'len' in\
    \ scope\n    return prefixes(string, len(string))\n                          \
    \  ^~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result = [String]()\n\
    \    for s in string.split(separator: \"\") {\n        if s.count > 1 {\n    \
    \        result.append((s[0] + String(s.dropFirst()).capitalized))\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl8pghnej.swift:9:29: error: no exact matches in call to subscript\
    \ \n            result.append((s[0] + String(s.dropFirst()).capitalized))\n  \
    \                          ^\n/tmp/tmpl8pghnej.swift:9:29: note: found candidate\
    \ with type '(Range<Substring.Index>) -> Substring' (aka '(Range<String.Index>)\
    \ -> Substring')\n            result.append((s[0] + String(s.dropFirst()).capitalized))\n\
    \                            ^\n/tmp/tmpl8pghnej.swift:9:29: note: found candidate\
    \ with type '((UnboundedRange_) -> ()) -> Substring.SubSequence' (aka '((UnboundedRange_)\
    \ -> ()) -> Substring')\n            result.append((s[0] + String(s.dropFirst()).capitalized))\n\
    \                            ^\n/tmp/tmpl8pghnej.swift:9:57: error: value of type\
    \ 'String' has no member 'capitalized'\n            result.append((s[0] + String(s.dropFirst()).capitalized))\n\
    \                                  ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return split(string) {\n\
    \        prefix in\n        let splitAt = string.index(prefix, offsetBy: prefix.characters.count)\n\
    \        return splitAt != string.endIndex\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5ak24_8a.swift:6:12: error: cannot find 'split' in scope\n    return\
    \ split(string) {\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string.isEmpty {\n   \
    \     return []\n    }\n    var prefixes = [String]()\n    var curPrefix = \"\"\
    \n    for c in string {\n        if c == curPrefix {\n            prefixes.append(curPrefix)\n\
    \        } else {\n            curPrefix = c\n            prefixes.append(c)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5k3_y4pq.swift:12:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == curPrefix {\n\
    \           ~ ^  ~~~~~~~~~\n/tmp/tmp5k3_y4pq.swift:12:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == curPrefix {\n             ^\n/tmp/tmp5k3_y4pq.swift:15:25:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  curPrefix = c\n                        ^\n/tmp/tmp5k3_y4pq.swift:16:29: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            prefixes.append(c)\n                            ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_recursion(string:\
    \ string)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzem8qz4b.swift:6:12: error: cannot find 'all_prefixes_recursion'\
    \ in scope\n    return all_prefixes_recursion(string: string)\n           ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string: string,\
    \ from: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmptb9cd6e4.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string: string, from: 0)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tif string == \"\" {\n\t\treturn\
    \ []\n\t}\n\tprefixes := [String]()\n\tcurrent := string\n\tfor {\n\t\tprefixes.append(current)\n\
    \t\tcurrent = prefixes.suffix(current)\n\t\tif current == \"\" {\n\t\t\tbreak\n\
    \t\t}\n\t}\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxpukuhly.swift:9:10: error: consecutive statements on a line must\
    \ be separated by ';'\n        prefixes := [String]()\n                ^\n   \
    \             ;\n/tmp/tmpxpukuhly.swift:9:11: error: expected expression\n   \
    \     prefixes := [String]()\n                 ^\n/tmp/tmpxpukuhly.swift:11:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpxpukuhly.swift:11:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpxpukuhly.swift:9:2: error: cannot find 'prefixes' in scope\n\
    \        prefixes := [String]()\n        ^~~~~~~~\n/tmp/tmpxpukuhly.swift:18:9:\
    \ error: cannot find 'prefixes' in scope\n        return prefixes\n          \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let mut prefixes = [String]()\n\
    \    let mut str = string\n    loop {\n        prefixes.append(str)\n        str\
    \ = str.substringToIndex(advance(str.startIndex, len(str)))\n        if str.isEmpty\
    \ {\n            break\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvsn3bqfj.swift:6:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut prefixes\
    \ = [String]()\n            ^\n/tmp/tmpvsn3bqfj.swift:6:13: note: join the identifiers\
    \ together\n    let mut prefixes = [String]()\n        ~~~~^~~~~~~~\n        mutprefixes\n\
    /tmp/tmpvsn3bqfj.swift:6:13: note: join the identifiers together with camel-case\n\
    \    let mut prefixes = [String]()\n        ~~~~^~~~~~~~\n        mutPrefixes\n\
    /tmp/tmpvsn3bqfj.swift:7:13: error: found an unexpected second identifier in constant\
    \ declaration; is there an accidental break?\n    let mut str = string\n     \
    \       ^\n/tmp/tmpvsn3bqfj.swift:7:13: note: join the identifiers together\n\
    \    let mut str = string\n        ~~~~^~~\n        mutstr\n/tmp/tmpvsn3bqfj.swift:7:13:\
    \ note: join the identifiers together with camel-case\n    let mut str = string\n\
    \        ~~~~^~~\n        mutStr\n/tmp/tmpvsn3bqfj.swift:7:9: error: invalid redeclaration\
    \ of 'mut'\n    let mut str = string\n        ^\n/tmp/tmpvsn3bqfj.swift:6:9: note:\
    \ 'mut' previously declared here\n    let mut prefixes = [String]()\n        ^\n\
    /tmp/tmpvsn3bqfj.swift:8:5: error: cannot find 'loop' in scope\n    loop {\n \
    \   ^~~~\n/tmp/tmpvsn3bqfj.swift:9:9: error: cannot find 'prefixes' in scope\n\
    \        prefixes.append(str)\n        ^~~~~~~~\n/tmp/tmpvsn3bqfj.swift:9:25:\
    \ error: cannot find 'str' in scope\n        prefixes.append(str)\n          \
    \              ^~~\n/tmp/tmpvsn3bqfj.swift:10:9: error: cannot find 'str' in scope\n\
    \        str = str.substringToIndex(advance(str.startIndex, len(str)))\n     \
    \   ^~~\n/tmp/tmpvsn3bqfj.swift:10:15: error: cannot find 'str' in scope\n   \
    \     str = str.substringToIndex(advance(str.startIndex, len(str)))\n        \
    \      ^~~\n/tmp/tmpvsn3bqfj.swift:10:36: error: cannot find 'advance' in scope\n\
    \        str = str.substringToIndex(advance(str.startIndex, len(str)))\n     \
    \                              ^~~~~~~\n/tmp/tmpvsn3bqfj.swift:10:44: error: cannot\
    \ find 'str' in scope\n        str = str.substringToIndex(advance(str.startIndex,\
    \ len(str)))\n           "
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return string.prefixes_(string.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnrdfypo9.swift:6:19: error: value of type 'String' has no member\
    \ 'prefixes_'\n    return string.prefixes_(string.count)\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    // Write your code here\n\
    \    if let range = string.unicodeScalars.first?.range(of: String(string.unicodeScalars.dropFirst().first!))\
    \ {\n        return Array(string.unicodeScalars[range.upperBound...])\n    }\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcdb936j_.swift:7:49: error: value of type 'Unicode.Scalar' has\
    \ no member 'range'\n    if let range = string.unicodeScalars.first?.range(of:\
    \ String(string.unicodeScalars.dropFirst().first!)) {\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~\n/tmp/tmpcdb936j_.swift:8:16: error: no exact matches in call to initializer\
    \ \n        return Array(string.unicodeScalars[range.upperBound...])\n       \
    \        ^\n/tmp/tmpcdb936j_.swift:8:16: note: found candidate with type '(String.UnicodeScalarView.SubSequence)\
    \ -> Array<String>' (aka '(Substring.UnicodeScalarView) -> Array<String>')\n \
    \       return Array(string.unicodeScalars[range.upperBound...])\n           \
    \    ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar result = [String]()\n\t\
    let strings = string.characters.split{$0 == \" \"}.map(String.init)\n\tfor string\
    \ in strings {\n\t\tif let lastIndex = string.characters.index(of: \" \") {\n\t\
    \t\tresult.appendContentsOf(string.substring(from: lastIndex + 1))\n\t\t}\n\t\
    }\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpemyshl5i.swift:7:23: error: 'characters' is unavailable: Please\
    \ use String directly\n        let strings = string.characters.split{$0 == \"\
    \ \"}.map(String.init)\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpemyshl5i.swift:9:29: error: 'characters'\
    \ is unavailable: Please use String directly\n                if let lastIndex\
    \ = string.characters.index(of: \" \") {\n                                   \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpemyshl5i.swift:9:40:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        \
    \        if let lastIndex = string.characters.index(of: \" \") {\n           \
    \                                          ^\n/tmp/tmpemyshl5i.swift:9:40: note:\
    \ use 'firstIndex(of:)' instead\n                if let lastIndex = string.characters.index(of:\
    \ \" \") {\n                                                     ^~~~~\n     \
    \                                                firstIndex\n/tmp/tmpemyshl5i.swift:10:51:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n                        result.appendContentsOf(string.substring(from:\
    \ lastIndex + 1))\n                                                          \
    \             ^\n/tmp/tmpemyshl5i.swift:10:11: error: value of type '[String]'\
    \ has no member 'appendContentsOf'\n                        result.appendContentsOf(string.substring(from:\
    \ lastIndex + 1))\n                        ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpemyshl5i.swift:10:35:\
    \ error: value of type 'String' has no member 'substring'\n                  \
    \      result.appendContentsOf(string.substring(from: lastIndex + 1))\n      \
    \                                          ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" {\n   \
    \     return []\n    }\n    if string[0] == \"\" {\n        return [string]\n\
    \    }\n\n    return all_prefixes(string: string.characters) +\n        prefix(string:\
    \ string.characters.dropFirst())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvx_1cx4b.swift:9:14: error: no exact matches in call to subscript\
    \ \n    if string[0] == \"\" {\n             ^\nSwift.String:3:12: note: candidate\
    \ expects value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n \
    \   public subscript(r: Range<String.Index>) -> Substring { get }\n          \
    \ ^\nSwift.Collection:3:23: note: candidate expects value of type '(UnboundedRange_)\
    \ -> ()' for parameter #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_)\
    \ -> ()) -> Self.SubSequence { get }\n                      ^\n/tmp/tmpvx_1cx4b.swift:14:9:\
    \ error: cannot find 'prefix' in scope\n        prefix(string: string.characters.dropFirst())\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] =\
    \ []\n    var shortest: String = string\n    var longest: String = string\n  \
    \  prefix {\n        for (i, _) in string.enumerated() {\n            if i > 0\
    \ {\n                prefixes.append(longest)\n            }\n            if shortest\
    \ == \"\" {\n                shortest = string\n                longest = string\n\
    \            } else {\n                shortest = longest\n                longest\
    \ = string\n            }\n        }\n    }\n    prefixes.append(longest)\n  \
    \  return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7px034_z.swift:9:5: error: cannot find 'prefix' in scope\n    prefix\
    \ {\n    ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string {\n        prefixes.append(s)\n        prefixes.removeLast()\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmptvn9quyz.swift:8:25: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefixes.append(s)\n           \
    \             ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return string.prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9kc2q45a.swift:6:19: error: value of type 'String' has no member\
    \ 'prefixes'\n    return string.prefixes\n           ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for letter in string {\n        if let index = string.index(of:\
    \ letter) {\n            prefix = string[index..<index]\n            prefixes.append(prefix)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp96igw0tr.swift:9:31: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        if let index = string.index(of: letter) {\n  \
    \                            ^\n/tmp/tmp96igw0tr.swift:9:31: note: use 'firstIndex(of:)'\
    \ instead\n        if let index = string.index(of: letter) {\n               \
    \               ^~~~~\n                              firstIndex\n/tmp/tmp96igw0tr.swift:10:28:\
    \ error: cannot assign value of type 'Substring' to type 'String'\n          \
    \  prefix = string[index..<index]\n                     ~~~~~~^~~~~~~~~~~~~~~\n\
    \                     String(              )\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, shortestLength:\
    \ 1, longestLength: -1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp04385bex.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, shortestLength: 1, longestLength: -1)\n          \
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let lengths: [Int] = countLongestCommonPrefix(string)\n\
    \    let results: [String] = [String]()\n    for length in lengths {\n       \
    \ let prefix = string[..<length]\n        results.append(prefix)\n    }\n    return\
    \ results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg4m6aw5i.swift:6:26: error: cannot find 'countLongestCommonPrefix'\
    \ in scope\n    let lengths: [Int] = countLongestCommonPrefix(string)\n      \
    \                   ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpg4m6aw5i.swift:9:22: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an integer range,\
    \ use a String.Index range instead.\n        let prefix = string[..<length]\n\
    \                     ^~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpg4m6aw5i.swift:10:17: error: cannot use mutating member on immutable value:\
    \ 'results' is a 'let' constant\n        results.append(prefix)\n        ~~~~~~~\
    \ ^\n/tmp/tmpg4m6aw5i.swift:7:5: note: change 'let' to 'var' to make it mutable\n\
    \    let results: [String] = [String]()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\treturn all_prefixes_recursive(string).reverse()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnnhqphgw.swift:6:9: error: cannot find 'all_prefixes_recursive'\
    \ in scope\n        return all_prefixes_recursive(string).reverse()\n        \
    \       ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\t\n\tvar prefixes = [String]()\n\
    \t\n\tif let prefixes = string._prefixes {\n\t\tfor prefix in prefixes {\n\t\t\
    \tprefixes.append(prefix)\n\t\t}\n\t}\n\t\n\treturn prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4fgaio_v.swift:9:27: error: value of type 'String' has no member\
    \ '_prefixes'\n        if let prefixes = string._prefixes {\n                \
    \          ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    for ch in string {\n        if !result.contains(ch) {\n            result.append(ch)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj2pd8et4.swift:8:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if !result.contains(ch) {\n    \
    \                        ^\n/tmp/tmpj2pd8et4.swift:9:27: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            result.append(ch)\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n  return prefixes(string, min_length:\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") ==\
    \ [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\",\
    \ \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\"\
    ) == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5zn_8bgv.swift:6:10: error: cannot find 'prefixes' in scope\n \
    \ return prefixes(string, min_length: 1)\n         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if let rangeOfFirstCharacter\
    \ = string.firstIndex(of: \"^\") {\n        return string[rangeOfFirstCharacter\
    \ + 1..<string.endIndex].split(separator: \"^\").map { $0 }\n    }\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") ==\
    \ [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\",\
    \ \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\"\
    ) == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyptkpxtt.swift:7:45: error: binary operator '+' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n        return string[rangeOfFirstCharacter\
    \ + 1..<string.endIndex].split(separator: \"^\").map { $0 }\n                \
    \      ~~~~~~~~~~~~~~~~~~~~~ ^ ~\n/tmp/tmpyptkpxtt.swift:7:96: error: cannot convert\
    \ value of type 'Substring.SubSequence' (aka 'Substring') to closure result type\
    \ 'String'\n        return string[rangeOfFirstCharacter + 1..<string.endIndex].split(separator:\
    \ \"^\").map { $0 }\n                                                        \
    \                                       ^~\n                                 \
    \                                                              String( )\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return string.prefixes(from:\
    \ 0, to: string.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqx_ju0nh.swift:6:19: error: value of type 'String' has no member\
    \ 'prefixes'\n    return string.prefixes(from: 0, to: string.count)\n        \
    \   ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    if string.characters.count < 2 {\n        return prefixes\n    }\n    var\
    \ i = 0\n    var current = \"\"\n    var previous = \"\"\n    for char in string.characters\
    \ {\n        if char == previous {\n            prefixes.append(current)\n   \
    \         current = \"\"\n        } else {\n            current = (current + String(char))\
    \ + String(previous)\n        }\n        previous = char\n    }\n    prefixes.append(current)\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8xtxue2y.swift:7:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count < 2 {\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp8xtxue2y.swift:13:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in string.characters {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8xtxue2y.swift:14:17: error: binary operator\
    \ '==' cannot be applied to operands of type 'Character' and 'String'\n      \
    \  if char == previous {\n           ~~~~ ^  ~~~~~~~~\n/tmp/tmp8xtxue2y.swift:14:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if char == previous {\n  \
    \              ^\n/tmp/tmp8xtxue2y.swift:20:20: error: cannot assign value of\
    \ type 'Character' to type 'String'\n        previous = char\n               \
    \    ^~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string.characters.count\
    \ == 0 {\n        return []\n    }\n    let count = string.characters.count\n\
    \    var prefix = [String]()\n    for n in 0..<count {\n        prefix.append(string.prefix(upTo:\
    \ n))\n    }\n    return prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi_l7y0em.swift:6:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count == 0 {\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpi_l7y0em.swift:9:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    let count\
    \ = string.characters.count\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpi_l7y0em.swift:12:16: error: no exact\
    \ matches in call to instance method 'append'\n        prefix.append(string.prefix(upTo:\
    \ n))\n               ^\n/tmp/tmpi_l7y0em.swift:12:16: note: candidate expects\
    \ value of type 'String' for parameter #1 (got 'Int')\n        prefix.append(string.prefix(upTo:\
    \ n))\n               ^\n/tmp/tmpi_l7y0em.swift:12:16: note: candidate expects\
    \ value of type 'String' for parameter #1 (got 'Int')\n        prefix.append(string.prefix(upTo:\
    \ n))\n               ^\n/tmp/tmpi_l7y0em.swift:12:16: note: found candidate with\
    \ type '(__owned String.SubSequence) -> ()' (aka '(__owned Substring) -> ()')\n\
    \        prefix.append(string.prefix(upTo: n))\n               ^\n/tmp/tmpi_l7y0em.swift:12:43:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \        prefix.append(string.prefix(upTo: n))\n                             \
    \             ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result = [String]()\n\
    \    var shortest = string.characters.count\n    var longest = 0\n    for c in\
    \ string.characters {\n        longest = max(longest, c.count)\n        if shortest\
    \ > c.count {\n            shortest = c.count\n            result = result + [String]()\n\
    \        }\n        result.append(c.suffix(longest))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4nn3xhgw.swift:7:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    var shortest = string.characters.count\n          \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4nn3xhgw.swift:9:21: error: 'characters' is unavailable: Please use\
    \ String directly\n    for c in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4nn3xhgw.swift:10:34:\
    \ error: value of type 'Character' has no member 'count'\n        longest = max(longest,\
    \ c.count)\n                               ~ ^~~~~\n/tmp/tmp4nn3xhgw.swift:11:25:\
    \ error: value of type 'Character' has no member 'count'\n        if shortest\
    \ > c.count {\n                      ~ ^~~~~\n/tmp/tmp4nn3xhgw.swift:12:26: error:\
    \ value of type 'Character' has no member 'count'\n            shortest = c.count\n\
    \                       ~ ^~~~~\n/tmp/tmp4nn3xhgw.swift:15:25: error: value of\
    \ type 'Character' has no member 'suffix'\n        result.append(c.suffix(longest))\n\
    \                      ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_helper(string).all\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjg8top8p.swift:6:12: error: cannot find 'all_prefixes_helper' in\
    \ scope\n    return all_prefixes_helper(string).all\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var stringCopy = string\n    while let currentChar = stringCopy.characters.first\
    \ {\n        let lastChar = stringCopy.characters.last\n        prefixes.append(String(currentChar))\n\
    \        stringCopy = stringCopy.substring(to: lastChar)\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjn7ndobq.swift:8:40: error: 'characters' is unavailable: Please\
    \ use String directly\n    while let currentChar = stringCopy.characters.first\
    \ {\n                                       ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpjn7ndobq.swift:9:35: error: 'characters'\
    \ is unavailable: Please use String directly\n        let lastChar = stringCopy.characters.last\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjn7ndobq.swift:11:33: error: value of type 'String'\
    \ has no member 'substring'\n        stringCopy = stringCopy.substring(to: lastChar)\n\
    \                     ~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tif string == \"\" {\n\t\treturn\
    \ []\n\t}\n\n\tprefixes := []String{}\n\tcharIndex := 0\n\tlength := len(string)\n\
    \n\tfor {\n\t\tif charIndex == length {\n\t\t\tbreak\n\t\t}\n\n\t\tprefix := string[charIndex]\n\
    \t\tprefixes = append(prefixes, prefix)\n\t\tcharIndex++\n\n\t\tif charIndex ==\
    \ length {\n\t\t\tbreak\n\t\t}\n\n\t\tprefix = string[charIndex]\n\t\tif prefix\
    \ == \"*\" {\n\t\t\tcharIndex++\n\t\t\tif charIndex == length {\n\t\t\t\tbreak\n\
    \t\t\t}\n\t\t\tprefix = string[charIndex]\n\t\t}\n\t}\n\n\treturn prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxco7hwxo.swift:10:10: error: consecutive statements on a line must\
    \ be separated by ';'\n        prefixes := []String{}\n                ^\n   \
    \             ;\n/tmp/tmpxco7hwxo.swift:10:11: error: expected expression\n  \
    \      prefixes := []String{}\n                 ^\n/tmp/tmpxco7hwxo.swift:14:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpxco7hwxo.swift:14:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpxco7hwxo.swift:19:9: error: consecutive statements on a line\
    \ must be separated by ';'\n                prefix := string[charIndex]\n    \
    \                  ^\n                      ;\n/tmp/tmpxco7hwxo.swift:19:10: error:\
    \ expected expression\n                prefix := string[charIndex]\n         \
    \              ^\n/tmp/tmpxco7hwxo.swift:10:2: error: cannot find 'prefixes' in\
    \ scope\n        prefixes := []String{}\n        ^~~~~~~~\n/tmp/tmpxco7hwxo.swift:37:9:\
    \ error: cannot find 'prefixes' in scope\n        return prefixes\n          \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] =\
    \ []\n    for start in stride(from: string.characters.count - 1, through: 0, by:\
    \ -1) {\n        var end = string.characters.count - 1\n        let index = string.index(string.startIndex,\
    \ offsetBy: start)\n        while end >= 0 && string.characters.characters.count\
    \ > end {\n            end -= 1\n            index = string.index(index, offsetBy:\
    \ 1)\n        }\n        prefixes.append(string.substring(to: index))\n    }\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3d775fl6.swift:7:38: error: 'characters' is unavailable: Please\
    \ use String directly\n    for start in stride(from: string.characters.count -\
    \ 1, through: 0, by: -1) {\n                                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3d775fl6.swift:8:26:\
    \ error: 'characters' is unavailable: Please use String directly\n        var\
    \ end = string.characters.count - 1\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp3d775fl6.swift:10:34: error: 'characters'\
    \ is unavailable: Please use String directly\n        while end >= 0 && string.characters.characters.count\
    \ > end {\n                                 ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp3d775fl6.swift:10:45: error: 'characters'\
    \ is unavailable: Please use String directly\n        while end >= 0 && string.characters.characters.count\
    \ > end {\n                                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp3d775fl6.swift:12:13: error: cannot assign\
    \ to value: 'index' is a 'let' constant\n            index = string.index(index,\
    \ offsetBy: 1)\n            ^~~~~\n/tmp/tmp3d775fl6.swift:9:9: note: change 'let'\
    \ to 'var' to make it mutable\n        let index = string.index(string.startIndex,\
    \ offsetBy: start)\n        ^~~\n        var\n/tmp/tmp3d775fl6.swift:14:32: error:\
    \ value of type 'String' has no member 'substring'\n        prefixes.append(string.substring(to:\
    \ index))\n                        ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_internal(string,\
    \ 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\") ==\
    \ [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\",\
    \ \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\"\
    ) == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjsdw40go.swift:6:12: error: cannot find 'all_prefixes_internal'\
    \ in scope\n    return all_prefixes_internal(string, 1)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var longest = string\n  \
    \  var shortest = \"\"\n    for char in string.characters {\n        if longest.characters.count\
    \ < char.characters.count {\n            longest = char.prefix(string)\n     \
    \   }\n        if shortest == \"\" { shortest = char }\n        else if char.characters.count\
    \ < shortest.characters.count {\n            shortest = char.suffix(string)\n\
    \        }\n    }\n    return [shortest, longest]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0s3wkw36.swift:8:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in string.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp0s3wkw36.swift:9:44:\
    \ error: value of type 'Character' has no member 'characters'\n        if longest.characters.count\
    \ < char.characters.count {\n                                      ~~~~ ^~~~~~~~~~\n\
    /tmp/tmp0s3wkw36.swift:10:28: error: value of type 'Character' has no member 'prefix'\n\
    \            longest = char.prefix(string)\n                      ~~~~ ^~~~~~\n\
    /tmp/tmp0s3wkw36.swift:12:40: error: cannot assign value of type 'Character' to\
    \ type 'String'\n        if shortest == \"\" { shortest = char }\n           \
    \                            ^~~~\n/tmp/tmp0s3wkw36.swift:13:22: error: value\
    \ of type 'Character' has no member 'characters'\n        else if char.characters.count\
    \ < shortest.characters.count {\n                ~~~~ ^~~~~~~~~~\n/tmp/tmp0s3wkw36.swift:14:29:\
    \ error: value of type 'Character' has no member 'suffix'\n            shortest\
    \ = char.suffix(string)\n                       ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string.isEmpty {\n   \
    \     return []\n    }\n\n    var prefixes = [String]()\n    var substring = string\n\
    \    var substringIndex = 0\n    while !substring.isEmpty {\n        var lastSubstringIndex\
    \ = -1\n        for index in 0..<string.count {\n            if string.substring(index,\
    \ substringIndex) == substring {\n                lastSubstringIndex = index\n\
    \                break\n            }\n        }\n        prefixes.insert(string.substring(substringIndex,\
    \ lastSubstringIndex), at: prefixes.count)\n        substringIndex = lastSubstringIndex\n\
    \        substring = string.substring(substringIndex, string.count)\n    }\n \
    \   return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmr7gl7lt.swift:16:23: error: value of type 'String' has no member\
    \ 'substring'\n            if string.substring(index, substringIndex) == substring\
    \ {\n               ~~~~~~ ^~~~~~~~~\n/tmp/tmpmr7gl7lt.swift:21:32: error: value\
    \ of type 'String' has no member 'substring'\n        prefixes.insert(string.substring(substringIndex,\
    \ lastSubstringIndex), at: prefixes.count)\n                        ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpmr7gl7lt.swift:23:28: error: value of type 'String' has no member 'substring'\n\
    \        substring = string.substring(substringIndex, string.count)\n        \
    \            ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" {\n   \
    \     return []\n    }\n    var prefixes = [String]()\n    for ch in string.unicodeScalars\
    \ {\n        if let _ = ch {\n            prefixes.append(String(ch))\n      \
    \  }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyfdrx704.swift:11:12: error: initializer for conditional binding\
    \ must have Optional type, not 'Unicode.Scalar'\n        if let _ = ch {\n   \
    \        ^       ~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \t\n\tvar i = 0\n\t\n\tfor i < string.count {\n\t\tif prefixes.count >= 3 {\n\t\
    \t\tbreak\n\t\t}\n\t\tprefixes.append(string.prefix(at: i))\n\t\ti += 1\n\t}\n\
    \t\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd75ff249.swift:10:8: error: expected 'in' after for-each pattern\n\
    \        for i < string.count {\n              ^\n/tmp/tmpd75ff249.swift:10:8:\
    \ error: unary operator cannot be separated from its operand\n        for i <\
    \ string.count {\n              ^~\n               \n/tmp/tmpd75ff249.swift:10:8:\
    \ error: '<' is not a prefix unary operator\n        for i < string.count {\n\
    \              ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tlet prefixes = [\"\"]\n\tfor\
    \ i in 0..<string.count {\n\t\tprefixes[0] += string[i]\n\t\tfor prefix in prefixes\
    \ {\n\t\t\tif string.hasPrefix(prefix) {\n\t\t\t\treturn prefixes\n\t\t\t}\n\t\
    \t}\n\t\tprefixes.append(string[i])\n\t}\n\treturn prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpekhhz9t0.swift:8:25: error: cannot convert value of type 'Int'\
    \ to expected argument type 'Range<String.Index>'\n                prefixes[0]\
    \ += string[i]\n                                      ^\n/tmp/tmpekhhz9t0.swift:14:12:\
    \ error: no exact matches in call to instance method 'append'\n              \
    \  prefixes.append(string[i])\n                         ^\n/tmp/tmpekhhz9t0.swift:14:12:\
    \ note: found candidate with type '(__owned String) -> ()'\n                prefixes.append(string[i])\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\treturn all_prefixes_with_max_len(string,\
    \ string.characters.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1oqdy_3i.swift:6:9: error: cannot find 'all_prefixes_with_max_len'\
    \ in scope\n        return all_prefixes_with_max_len(string, string.characters.count)\n\
    \               ^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefix = \"\"\n\tvar result\
    \ : [String] = []\n\tfor char in string.characters {\n\t\tif prefix != \"\" {\n\
    \t\t\tresult = append(result, prefix)\n\t\t\tprefix = \"\"\n\t\t}\n\t\tprefix\
    \ += char\n\t}\n\tif prefix != \"\" {\n\t\tresult = append(result, prefix)\n\t\
    }\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfw7xcyht.swift:8:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        for char in string.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfw7xcyht.swift:10:13: error: cannot find 'append' in scope\n    \
    \                    result = append(result, prefix)\n                       \
    \          ^~~~~~\n/tmp/tmpfw7xcyht.swift:13:13: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n                prefix\
    \ += char\n                          ^\n/tmp/tmpfw7xcyht.swift:16:12: error: cannot\
    \ find 'append' in scope\n                result = append(result, prefix)\n  \
    \                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixesOf(string,\
    \ count: longest(string))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0o3hahg5.swift:6:12: error: cannot find 'prefixesOf' in scope\n\
    \    return prefixesOf(string, count: longest(string))\n           ^~~~~~~~~~\n\
    /tmp/tmp0o3hahg5.swift:6:38: error: cannot find 'longest' in scope\n    return\
    \ prefixesOf(string, count: longest(string))\n                               \
    \      ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    for _ in string.characters.reverse() {\n        result.append(string[i..<string.characters.count])\n\
    \        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpakqmrk9j.swift:8:32: error: value of type 'String' has no member\
    \ 'reverse'\n    for _ in string.characters.reverse() {\n             ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n  return get_prefixes_helper(string).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyolwhi7_.swift:6:10: error: cannot find 'get_prefixes_helper' in\
    \ scope\n  return get_prefixes_helper(string).reversed()\n         ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    \n    let prefixes = Array(string.prefixes)\n\
    \    return prefixes.map { String($0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprv5jkfnd.swift:7:33: error: value of type 'String' has no member\
    \ 'prefixes'\n    let prefixes = Array(string.prefixes)\n                    \
    \     ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" {\n   \
    \     return []\n    }\n    return string.characters.dropLast().map(String.init)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl5aj47ti.swift:9:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    return string.characters.dropLast().map(String.init)\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string.characters.count\
    \ == 0 {\n        return []\n    }\n\n    var prefixes = make([][String], 0)\n\
    \    var currentPrefixes = [String]()\n    for character in string.characters\
    \ {\n        currentPrefixes.append(String(character))\n\n        if currentPrefixes.count\
    \ > prefixes.count {\n            prefixes = currentPrefixes\n        }\n    }\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxnicu4eg.swift:6:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count == 0 {\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxnicu4eg.swift:10:20:\
    \ error: cannot find 'make' in scope\n    var prefixes = make([][String], 0)\n\
    \                   ^~~~\n/tmp/tmpxnicu4eg.swift:10:27: error: no exact matches\
    \ in call to subscript \n    var prefixes = make([][String], 0)\n            \
    \              ^\n/tmp/tmpxnicu4eg.swift:10:27: note: found candidate with type\
    \ '(Int) -> Any'\n    var prefixes = make([][String], 0)\n                   \
    \       ^\n/tmp/tmpxnicu4eg.swift:10:27: note: found candidate with type '(Range<Int>)\
    \ -> ArraySlice<Any>'\n    var prefixes = make([][String], 0)\n              \
    \            ^\n/tmp/tmpxnicu4eg.swift:10:27: note: found candidate with type\
    \ '(String.Type) -> ArraySlice<Any>'\n    var prefixes = make([][String], 0)\n\
    \                          ^\n/tmp/tmpxnicu4eg.swift:10:27: note: found candidate\
    \ with type '((UnboundedRange_) -> ()) -> ArraySlice<Any>'\n    var prefixes =\
    \ make([][String], 0)\n                          ^\n/tmp/tmpxnicu4eg.swift:12:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    for character\
    \ in string.characters {\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    var i = 0\n    while i < string.count {\n        i += 1\n        if string.hasPrefix(string[i..<string.count])\
    \ {\n            result = result + [string[i..<string.count]]\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2ot7e66z.swift:10:29: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        if string.hasPrefix(string[i..<string.count]) {\n                   \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript<R>(bounds: R)\
    \ -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmp2ot7e66z.swift:11:32: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n          \
    \  result = result + [string[i..<string.count]]\n                            \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    string.enumerateSubstrings(in: Range<String.Index>(start: string.startIndex,\
    \ end: string.endIndex)) {\n        (substring, substringRange, enclosingRange,\
    \ _) in\n        if substringRange.upperBound == nil {\n            prefixes.append(substring)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp94l0mxo3.swift:7:12: error: value of type 'String' has no member\
    \ 'enumerateSubstrings'\n    string.enumerateSubstrings(in: Range<String.Index>(start:\
    \ string.startIndex, end: string.endIndex)) {\n    ~~~~~~ ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp94l0mxo3.swift:7:36: error: referencing initializer 'init(_:)' on 'Range'\
    \ requires that 'String.Index' conform to 'Strideable'\n    string.enumerateSubstrings(in:\
    \ Range<String.Index>(start: string.startIndex, end: string.endIndex)) {\n   \
    \                                ^\nSwift.Range:1:11: note: where 'Bound' = 'String.Index'\n\
    extension Range where Bound : Strideable, Bound.Stride : SignedInteger {\n   \
    \       ^\n/tmp/tmp94l0mxo3.swift:7:94: error: extra argument 'end' in call\n\
    \    string.enumerateSubstrings(in: Range<String.Index>(start: string.startIndex,\
    \ end: string.endIndex)) {\n                                                 \
    \     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmp94l0mxo3.swift:7:70:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'ClosedRange<String.Index>'\n    string.enumerateSubstrings(in: Range<String.Index>(start:\
    \ string.startIndex, end: string.endIndex)) {\n                              \
    \                                       ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n  var prefixes = [String]()\n\
    \n  for char in string {\n    if string.startsWith(String(char)) {\n      prefixes.append(String(char))\n\
    \    }\n  }\n  return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwbf1tzdq.swift:9:15: error: value of type 'String' has no member\
    \ 'startsWith'\n    if string.startsWith(String(char)) {\n       ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\treturn prefixesArray(string,\
    \ true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\
    \") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"\
    as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4b9sn47b.swift:6:9: error: cannot find 'prefixesArray' in scope\n\
    \        return prefixesArray(string, true)\n               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_helper(string)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdh0_7fww.swift:6:12: error: cannot find 'all_prefixes_helper' in\
    \ scope\n    return all_prefixes_helper(string)\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var last = \"\"\n    for character in string {\n        if last.hasPrefix(character)\
    \ {\n            prefixes.append(last)\n        }\n        last = String(character)\n\
    \    }\n    prefixes.append(last)\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpe_p688lq.swift:9:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if last.hasPrefix(character) {\n\
    \                          ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.characters {\n        prefixes.append(String(repeating: s,\
    \ count: min(string.count - 1, s.count)))\n    }\n    return prefixes\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm63ppmuh.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpm63ppmuh.swift:8:77:\
    \ error: value of type 'Character' has no member 'count'\n        prefixes.append(String(repeating:\
    \ s, count: min(string.count - 1, s.count)))\n                               \
    \                                           ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, shortestToLongest:\
    \ true)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\
    \") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"\
    as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpk6ec_cwl.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, shortestToLongest: true)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentString: String = \"\"\n\n    for i in 0 ..< string.characters.count\
    \ {\n        let currentChar = String(string.character(at: i))\n        currentString\
    \ += currentChar\n        if currentString.characters.count > 0 {\n          \
    \  prefixes.append(currentString)\n        }\n        currentString = \"\"\n \
    \   }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_q_x0aqw.swift:9:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0 ..< string.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_q_x0aqw.swift:10:41: error: value of type 'String' has no member\
    \ 'character'\n        let currentChar = String(string.character(at: i))\n   \
    \                              ~~~~~~ ^~~~~~~~~\n/tmp/tmp_q_x0aqw.swift:12:26:\
    \ error: 'characters' is unavailable: Please use String directly\n        if currentString.characters.count\
    \ > 0 {\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \t\n\tfor _ in 0..<string.count {\n\t\t\n\t\tif string.isEmpty {\n\t\t\treturn\
    \ prefixes\n\t\t}\n\t\t\n\t\tlet start = string.index(string.startIndex, offsetBy:\
    \ 1)\n\t\tlet end = string.index(start, offsetBy: -1)\n\t\t\n\t\tprefixes.append(String(string.substringWithRange(start..<end)))\n\
    \t\t\n\t\tstring = String(string.substring(start..<end))\n\t}\n\t\n\treturn prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl_078hkx.swift:17:33: error: value of type 'String' has no member\
    \ 'substringWithRange'\n                prefixes.append(String(string.substringWithRange(start..<end)))\n\
    \                                       ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpl_078hkx.swift:19:26:\
    \ error: value of type 'String' has no member 'substring'\n                string\
    \ = String(string.substring(start..<end))\n                                ~~~~~~\
    \ ^~~~~~~~~\n/tmp/tmpl_078hkx.swift:19:3: error: cannot assign to value: 'string'\
    \ is a 'let' constant\n                string = String(string.substring(start..<end))\n\
    \                ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_internal(string)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx56zq85g.swift:6:12: error: cannot find 'all_prefixes_internal'\
    \ in scope\n    return all_prefixes_internal(string)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if let count = count(string)\
    \ {\n        var prefixes: [String] = []\n        for _ in 0..<count {\n     \
    \       prefixes.append(\"\")\n        }\n        var s = count\n        while\
    \ s > 0 {\n            prefixes.last! += string[s-1]\n            s -= 1\n   \
    \     }\n        return prefixes\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq_ehdpd2.swift:6:20: error: cannot find 'count' in scope\n    if\
    \ let count = count(string) {\n                   ^~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result = [String]()\n\
    \    var prefix = [String]()\n    for s in string.split(\"\") {\n        prefix.append(s)\n\
    \        if prefix.count > result.count {\n            result = prefix\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb_ut6328.swift:8:27: error: missing argument label 'separator:'\
    \ in call\n    for s in string.split(\"\") {\n                          ^\n  \
    \                        separator: \n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    guard let shorter = string.characters.prefix(min(string.characters.count,\
    \ 5)), let longer = string.characters.suffix(max(string.characters.count, 5))\
    \ else { return [] }\n    return shorter..longer\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9fda4d87.swift:6:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let shorter = string.characters.prefix(min(string.characters.count,\
    \ 5)), let longer = string.characters.suffix(max(string.characters.count, 5))\
    \ else { return [] }\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9fda4d87.swift:6:61: error: 'characters'\
    \ is unavailable: Please use String directly\n    guard let shorter = string.characters.prefix(min(string.characters.count,\
    \ 5)), let longer = string.characters.suffix(max(string.characters.count, 5))\
    \ else { return [] }\n                                                       \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9fda4d87.swift:6:104:\
    \ error: 'characters' is unavailable: Please use String directly\n    guard let\
    \ shorter = string.characters.prefix(min(string.characters.count, 5)), let longer\
    \ = string.characters.suffix(max(string.characters.count, 5)) else { return []\
    \ }\n                                                                        \
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9fda4d87.swift:6:133: error: 'characters' is unavailable:\
    \ Please use String directly\n    guard let shorter = string.characters.prefix(min(string.characters.count,\
    \ 5)), let longer = string.characters.suffix(max(string.characters.count, 5))\
    \ else { return [] }\n                                                       \
    \                                                                            \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp9fda4d87.swift:6:11:\
    \ error: initializer for conditional binding must have Optional type, not 'St"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes_helper(string,\
    \ \"\", \"\", false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfgac6ejp.swift:6:12: error: cannot find 'prefixes_helper' in scope\n\
    \    return prefixes_helper(string, \"\", \"\", false)\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    guard let input = string.cStringUsingEncoding(NSUTF8StringEncoding)\
    \ else {\n        return []\n    }\n    var output = [String]()\n    var length\
    \ = 0\n    for i in 0..<input.count {\n        if input[i] != 0 {\n          \
    \  let string = String(bytes: &input[i..<i+1], count: 1)\n            output.append(string)\n\
    \            length += string.count\n        }\n    }\n    if length == 0 {\n\
    \        return output\n    }\n    let reversedString = output.map { String($0)\
    \ }.reversed()\n    return reversedString.prefix(length).map { String($0) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdn12nnma.swift:6:51: error: cannot find 'NSUTF8StringEncoding'\
    \ in scope\n    guard let input = string.cStringUsingEncoding(NSUTF8StringEncoding)\
    \ else {\n                                                  ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdn12nnma.swift:6:30: error: value of type 'String' has no member 'cStringUsingEncoding'\n\
    \    guard let input = string.cStringUsingEncoding(NSUTF8StringEncoding) else\
    \ {\n                      ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdn12nnma.swift:13:26:\
    \ error: no exact matches in call to initializer \n            let string = String(bytes:\
    \ &input[i..<i+1], count: 1)\n                         ^\n/tmp/tmpdn12nnma.swift:13:26:\
    \ note: found candidate with type '(String, Int) -> String'\n            let string\
    \ = String(bytes: &input[i..<i+1], count: 1)\n                         ^\n/tmp/tmpdn12nnma.swift:13:26:\
    \ note: found candidate with type '(Character, Int) -> String'\n            let\
    \ string = String(bytes: &input[i..<i+1], count: 1)\n                        \
    \ ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    let shortest = string\n    let longest = shortest.prefix(string: string.endIndex).suffix(string:\
    \ string.startIndex).string\n    shortest.enumerateSubstrings(in: longest.unicodeScalars.startIndex..<longest.unicodeScalars.endIndex)\
    \ { (substring, substringRange, enclosingRange, _) in\n        prefixes.append(substring)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpiwshh56k.swift:8:66: error: incorrect argument label in call (have\
    \ 'string:', expected 'from:')\n    let longest = shortest.prefix(string: string.endIndex).suffix(string:\
    \ string.startIndex).string\n                                                \
    \                 ^~~~~~~\n                                                  \
    \                from\n/tmp/tmpiwshh56k.swift:8:28: error: no exact matches in\
    \ call to instance method 'prefix'\n    let longest = shortest.prefix(string:\
    \ string.endIndex).suffix(string: string.startIndex).string\n                \
    \           ^\n/tmp/tmpiwshh56k.swift:8:28: note: found candidate with type '(String.Index)\
    \ -> String.SubSequence' (aka '(String.Index) -> Substring')\n    let longest\
    \ = shortest.prefix(string: string.endIndex).suffix(string: string.startIndex).string\n\
    \                           ^\n/tmp/tmpiwshh56k.swift:8:28: note: found candidate\
    \ with type '(String.Index) -> String.SubSequence' (aka '(String.Index) -> Substring')\n\
    \    let longest = shortest.prefix(string: string.endIndex).suffix(string: string.startIndex).string\n\
    \                           ^\n/tmp/tmpiwshh56k.swift:8:94: error: value of type\
    \ 'Substring.SubSequence' (aka 'Substring') has no member 'string'\n    let longest\
    \ = shortest.prefix(string: string.endIndex).suffix(string: string.startIndex).string\n\
    \                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpiwshh56k.swift:9:14: error: value of type 'String' has no member\
    \ 'enumerateSubstrings'\n    shortest.enumerateSubstrings(in: longest.unicodeScalars.startIndex..<longest.unicodeScalars.endIndex)\
    \ { (substring, substringRange, enclosingRange, _) in\n    ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq_p5i73o.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, 1)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tlet str = string.characters.sorted()\n\
    \tvar result: [String] = []\n\tlet count = str.count\n\n\tfor let i = 0; i < count;\
    \ i++ {\n\t\tif i < count - 1 {\n\t\t\tlet prefixes = str[..<i+1].sorted()\n\t\
    \t\tresult.append(String(prefixes))\n\t\t}\n\t}\n\n\treturn result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfn6026qg.swift:10:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for let i = 0; i < count; i++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfn6026qg.swift:6:19: error: 'characters' is unavailable: Please use String\
    \ directly\n        let str = string.characters.sorted()\n                   \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpfn6026qg.swift:12:26:\
    \ error: cannot find 'i' in scope\n                        let prefixes = str[..<i+1].sorted()\n\
    \                                              ^\n/tmp/tmpfn6026qg.swift:12:23:\
    \ error: cannot convert value of type 'PartialRangeUpTo<Self>' to expected argument\
    \ type 'Int'\n                        let prefixes = str[..<i+1].sorted()\n  \
    \                                         ^\n/tmp/tmpfn6026qg.swift:12:22: error:\
    \ no exact matches in call to subscript \n                        let prefixes\
    \ = str[..<i+1].sorted()\n                                          ^\n/tmp/tmpfn6026qg.swift:12:22:\
    \ note: found candidate with type '(Range<Int>) -> ArraySlice<String.Element>'\
    \ (aka '(Range<Int>) -> ArraySlice<Character>')\n                        let prefixes\
    \ = str[..<i+1].sorted()\n                                          ^\n/tmp/tmpfn6026qg.swift:12:22:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> ArraySlice<String.Element>'\
    \ (aka '((UnboundedRange_) -> ()) -> ArraySlice<Character>')\n               \
    \         let prefixes = str[..<i+1].sorted()\n                              \
    \            ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] =\
    \ []\n    var len = string.characters.count\n    for i in 0 ..< len {\n      \
    \  prefixes.append(string.prefix(len))\n    }\n    return prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmph8oqagm0.swift:7:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var len = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmph8oqagm0.swift:9:18:\
    \ error: no exact matches in call to instance method 'append'\n        prefixes.append(string.prefix(len))\n\
    \                 ^\nSwift.Array:6:37: note: candidate expects value of type 'String'\
    \ for parameter #1 (got 'PrefixSequence<String>')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'PrefixSequence<String>')\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Self.Element)\n          \
    \                          ^\n/tmp/tmph8oqagm0.swift:9:18: note: found candidate\
    \ with type '(__owned PrefixSequence<String>) -> ()'\n        prefixes.append(string.prefix(len))\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" { return\
    \ [] }\n    let start = string.startIndex\n    let end = string.endIndex\n   \
    \ let prefix = string.prefix(from: start)\n    if prefix == nil { return [] }\n\
    \    var prefix = prefix!\n    let prefix2 = prefix.prefix(from: end)\n    guard\
    \ prefix2 != nil else { return [] }\n    return Array(repeating: prefix, count:\
    \ prefix2.count - prefix.count)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmproapccdo.swift:9:25: error: no exact matches in call to instance\
    \ method 'prefix'\n    let prefix = string.prefix(from: start)\n             \
    \           ^\nSwift.Collection:9:40: note: incorrect labels for candidate (have:\
    \ '(from:)', expected: '(upTo:)')\n    @inlinable public __consuming func prefix(upTo\
    \ end: Self.Index) -> Self.SubSequence\n                                     \
    \  ^\nSwift.Collection:11:40: note: incorrect labels for candidate (have: '(from:)',\
    \ expected: '(through:)')\n    @inlinable public __consuming func prefix(through\
    \ position: Self.Index) -> Self.SubSequence\n                                \
    \       ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_sorted(string).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3sw4k998.swift:6:12: error: cannot find 'all_prefixes_sorted' in\
    \ scope\n    return all_prefixes_sorted(string).reversed()\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for ch in string {\n        prefixes = append(prefixes, prefix + ch)\n  \
    \  }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpscbo6rbf.swift:8:20: error: cannot find 'append' in scope\n   \
    \     prefixes = append(prefixes, prefix + ch)\n                   ^~~~~~\n/tmp/tmpscbo6rbf.swift:8:37:\
    \ error: cannot find 'prefix' in scope\n        prefixes = append(prefixes, prefix\
    \ + ch)\n                                    ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    prefixes : Array = [string]\n\
    \    let prefixLength = string.characters.count\n    for characters in string.characters.reverse()\
    \ {\n        guard prefixes.contains(String(repeating: characters, count: prefixLength))\
    \ else {\n            prefixes.append(String(repeating: characters, count: prefixLength))\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp70s8ihs_.swift:6:13: error: consecutive statements on a line must\
    \ be separated by ';'\n    prefixes : Array = [string]\n            ^\n      \
    \      ;\n/tmp/tmp70s8ihs_.swift:6:14: error: expected expression\n    prefixes\
    \ : Array = [string]\n             ^\n/tmp/tmp70s8ihs_.swift:6:5: error: cannot\
    \ find 'prefixes' in scope\n    prefixes : Array = [string]\n    ^~~~~~~~\n/tmp/tmp70s8ihs_.swift:7:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    let prefixLength\
    \ = string.characters.count\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp70s8ihs_.swift:8:41: error: value of\
    \ type 'String' has no member 'reverse'\n    for characters in string.characters.reverse()\
    \ {\n                      ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp70s8ihs_.swift:13:12:\
    \ error: cannot find 'prefixes' in scope\n    return prefixes\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let prefixes = string.prefixes\n\
    \    var result = [String]()\n    for prefix in prefixes {\n        result.append(prefix[0..<string.count])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp68x5vwnj.swift:6:27: error: value of type 'String' has no member\
    \ 'prefixes'\n    let prefixes = string.prefixes\n                   ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return Array((string.prefixes\
    \ ?? [])).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpuh8y7iuu.swift:6:26: error: value of type 'String' has no member\
    \ 'prefixes'\n    return Array((string.prefixes ?? [])).sorted()\n           \
    \       ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let start = string.startIndex\n\
    \    let end = string.endIndex\n    var prefixes = Array<T>()\n    var i: Int\n\
    \    for i = start + 1; end > i; i = i + 1 {\n        prefixes.append(string[(i-1)\
    \ as Int])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyygrs7kg.swift:10:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = start + 1; end > i; i = i + 1 {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyygrs7kg.swift:8:26: error: cannot find type 'T' in scope\n    var prefixes\
    \ = Array<T>()\n                         ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar result: [String] = []\n\
    \tfor item in string.characters.reversed(){\n\t\tresult.append(String(item))\n\
    \t}\n\tresult.reverse()\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcjexx_ow.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        for item in string.characters.reversed(){\n   \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefix = \"\"\n    var\
    \ arr = [String]()\n    for str in string.characters {\n        for char in str.unicodeScalars\
    \ {\n            if char.isUpperCase {\n                prefix += char\n     \
    \           break\n            } else {\n                prefix += char.lowercaseValue\n\
    \                break\n            }\n        }\n        arr.append(prefix)\n\
    \        prefix = \"\"\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg_636df0.swift:8:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for str in string.characters {\n                  \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpg_636df0.swift:10:21:\
    \ error: value of type 'Unicode.Scalar' has no member 'isUpperCase'\n        \
    \    if char.isUpperCase {\n               ~~~~ ^~~~~~~~~~~\n/tmp/tmpg_636df0.swift:11:24:\
    \ error: operator function '+=' requires that 'Unicode.Scalar' conform to 'Sequence'\n\
    \                prefix += char\n                       ^\nSwift.RangeReplaceableCollection:4:35:\
    \ note: where 'Other' = 'Unicode.Scalar'\n    @inlinable public static func +=\
    \ <Other>(lhs: inout Self, rhs: Other) where Other : Sequence, Self.Element ==\
    \ Other.Element\n                                  ^\n/tmp/tmpg_636df0.swift:14:32:\
    \ error: value of type 'Unicode.Scalar' has no member 'lowercaseValue'\n     \
    \           prefix += char.lowercaseValue\n                          ~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let length: Int = string.count\n\
    \    if length == 0 {\n        return nil\n    }\n    var prefixes = Array(string.prefix(length))\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpu8k3zt45.swift:8:16: error: 'nil' is incompatible with return type\
    \ '[String]'\n        return nil\n               ^\n/tmp/tmpu8k3zt45.swift:11:12:\
    \ error: cannot convert return expression of type '[Character]' to return type\
    \ '[String]'\n    return prefixes\n           ^\n/tmp/tmpu8k3zt45.swift:11:12:\
    \ note: arguments to generic parameter 'Element' ('Character' and 'String') are\
    \ expected to be equal\n    return prefixes\n           ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    var currentPrefix: String = \"\"\n    for c in string {\n        currentPrefix\
    \ = currentPrefix + String(c)\n        result.insert(currentPrefix, at: 0)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmptk0ez_h1/tmptk0ez_h1.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba55d85bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba55d552b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba55d552988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba55d5517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptk0ez_h1                        0x000055f11395b828 <unavailable> + 6184

    5    libc.so.6                          0x00002ba55da47460 __libc_start_main +
    245

    6    tmptk0ez_h1                        0x000055f11395b289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return Array(zip(string.prefix,\
    \ string))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9kk_4_4l.swift:6:12: error: no exact matches in call to initializer\
    \ \n    return Array(zip(string.prefix, string))\n           ^\n/tmp/tmp9kk_4_4l.swift:6:12:\
    \ note: found candidate with type '(Zip2Sequence<(Int) -> PrefixSequence<String>,\
    \ String>) -> Array<String>'\n    return Array(zip(string.prefix, string))\n \
    \          ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string.prefixes == nil\
    \ {\n        var prefix = \"\"\n        for c in string.unicodeScalars {\n   \
    \         prefix += string[c]\n        }\n        prefix = prefix[prefixIndex(string):]\n\
    \        string.prefixes = &prefix\n    }\n    return *string.prefixes\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpimay6ygy.swift:11:44: error: expected ',' separator\n        prefix\
    \ = prefix[prefixIndex(string):]\n                                           ^\n\
    \                                           ,\n/tmp/tmpimay6ygy.swift:11:44: error:\
    \ expected expression in list of expressions\n        prefix = prefix[prefixIndex(string):]\n\
    \                                           ^\n/tmp/tmpimay6ygy.swift:6:15: error:\
    \ value of type 'String' has no member 'prefixes'\n    if string.prefixes == nil\
    \ {\n       ~~~~~~ ^~~~~~~~\n/tmp/tmpimay6ygy.swift:9:29: error: subscript 'subscript(_:)'\
    \ requires that 'Unicode.Scalar' conform to 'RangeExpression'\n            prefix\
    \ += string[c]\n                            ^\nSwift.Collection:2:23: note: where\
    \ 'R' = 'Unicode.Scalar'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\n/tmp/tmpimay6ygy.swift:11:25: error: cannot find 'prefixIndex' in scope\n\
    \        prefix = prefix[prefixIndex(string):]\n                        ^~~~~~~~~~~\n\
    /tmp/tmpimay6ygy.swift:12:16: error: value of type 'String' has no member 'prefixes'\n\
    \        string.prefixes = &prefix\n        ~~~~~~ ^~~~~~~~\n/tmp/tmpimay6ygy.swift:12:27:\
    \ error: '&' may only be used to pass an argument to inout parameter\n       \
    \ string.prefixes = &prefix\n                          ^\n/tmp/tmpimay6ygy.swift:14:12:\
    \ error: '*' is not a prefix unary operator\n    return *string.prefixes\n   \
    \        ^\n/tmp/tmpimay6ygy.swift:14:20: error: value of type 'String' has no\
    \ member 'prefixes'\n    return *string.prefixes\n            ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefixStart = 0\n    var stringLength = string.characters.count\n   \
    \ while prefixStart < stringLength {\n        prefixes += [string.substring(prefixStart,\
    \ min(prefixStart + maxPrefixLength, stringLength))]\n        prefixStart = prefixStart\
    \ + maxPrefixLength\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2_e0666p.swift:8:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    var stringLength = string.characters.count\n      \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2_e0666p.swift:10:70: error: cannot find 'maxPrefixLength'\
    \ in scope\n        prefixes += [string.substring(prefixStart, min(prefixStart\
    \ + maxPrefixLength, stringLength))]\n                                       \
    \                              ^~~~~~~~~~~~~~~\n/tmp/tmp2_e0666p.swift:10:29:\
    \ error: value of type 'String' has no member 'substring'\n        prefixes +=\
    \ [string.substring(prefixStart, min(prefixStart + maxPrefixLength, stringLength))]\n\
    \                     ~~~~~~ ^~~~~~~~~\n/tmp/tmp2_e0666p.swift:11:37: error: cannot\
    \ find 'maxPrefixLength' in scope\n        prefixStart = prefixStart + maxPrefixLength\n\
    \                                    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix: String = \"\"\n    for ch in string.unicodeScalars.reverse()\
    \ {\n        if prefix == \"\" {\n            prefix = String(ch)\n        } else\
    \ {\n            prefix = prefix + String(ch)\n        }\n        prefixes.append(prefix)\n\
    \    }\n    return prefixes.reverse()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7gby0gok.swift:8:37: error: value of type 'String.UnicodeScalarView'\
    \ has no member 'reverse'\n    for ch in string.unicodeScalars.reverse() {\n \
    \             ~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp7gby0gok.swift:16:21: error:\
    \ cannot convert return expression of type '()' to return type '[String]'\n  \
    \  return prefixes.reverse()\n           ~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let startIndex = string.index(string.startIndex,\
    \ offsetBy: 0)\n    let endIndex = string.index(startIndex, offsetBy: string.characters.count)\n\
    \    var prefixes = [String]()\n    while startIndex != endIndex {\n        prefixes.append(string[startIndex])\n\
    \        startIndex = string.index(startIndex, offsetBy: 1)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8ekjf2oq.swift:7:62: error: 'characters' is unavailable: Please\
    \ use String directly\n    let endIndex = string.index(startIndex, offsetBy: string.characters.count)\n\
    \                                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8ekjf2oq.swift:10:31: error: subscript\
    \ 'subscript(_:)' requires that 'String.Index' conform to 'RangeExpression'\n\
    \        prefixes.append(string[startIndex])\n                              ^\n\
    Swift.String:5:12: note: where 'R' = 'String.Index'\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmp8ekjf2oq.swift:11:9: error: cannot assign to value: 'startIndex' is a\
    \ 'let' constant\n        startIndex = string.index(startIndex, offsetBy: 1)\n\
    \        ^~~~~~~~~~\n/tmp/tmp8ekjf2oq.swift:6:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let startIndex = string.index(string.startIndex, offsetBy:\
    \ 0)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \n    for _ in 0 ..< string.count {\n        prefixes.append(string[0..<string.count])\n\
    \    }\n\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpogxyo1_c.swift:9:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        prefixes.append(string[0..<string.count])\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \tfor _,character in string.enumerated() {\n\t\tprefixes.insert(String(character),\
    \ at: 0)\n\t}\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmplqlgbsur.swift:7:7: error: expected 'in' after for-each pattern\n\
    \        for _,character in string.enumerated() {\n             ^\n/tmp/tmplqlgbsur.swift:7:7:\
    \ error: expected Sequence expression for for-each loop\n        for _,character\
    \ in string.enumerated() {\n             ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \tprefix = longest(string)\n\tif prefix == nil {\n\t\treturn prefixes\n\t}\n\t\
    for _, c := range prefix {\n\t\tprefixes = append(prefixes, string[c...])\n\t\
    }\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn8pf7fpg.swift:11:7: error: expected 'in' after for-each pattern\n\
    \        for _, c := range prefix {\n             ^\n/tmp/tmpn8pf7fpg.swift:11:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, c := range\
    \ prefix {\n             ^\n/tmp/tmpn8pf7fpg.swift:7:2: error: cannot find 'prefix'\
    \ in scope\n        prefix = longest(string)\n        ^~~~~~\n/tmp/tmpn8pf7fpg.swift:7:11:\
    \ error: cannot find 'longest' in scope\n        prefix = longest(string)\n  \
    \               ^~~~~~~\n/tmp/tmpn8pf7fpg.swift:8:5: error: cannot find 'prefix'\
    \ in scope\n        if prefix == nil {\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n  var prefixes = [String]()\n\
    \  var i: Int = 0\n  while i < string.count {\n    let start = string.index(string.startIndex,\
    \ offsetBy: i)\n    let end = string.index(start, offsetBy: 1)\n    if end ==\
    \ nil {\n      prefixes.append(String(string.substring(from: start)))\n      i\
    \ += 1\n      continue\n    }\n    let prefix = String(string.substring(from:\
    \ start))\n    let suffix = String(string.substring(from: end!))\n    prefixes.append(prefix+suffix)\n\
    \    i += 1\n  }\n  return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyzt32rrw.swift:11:12: warning: comparing non-optional value of\
    \ type 'String.Index' to 'nil' always returns false\n    if end == nil {\n   \
    \    ~~~ ^  ~~~\n/tmp/tmpyzt32rrw.swift:12:37: error: value of type 'String' has\
    \ no member 'substring'\n      prefixes.append(String(string.substring(from: start)))\n\
    \                             ~~~~~~ ^~~~~~~~~\n/tmp/tmpyzt32rrw.swift:16:32:\
    \ error: value of type 'String' has no member 'substring'\n    let prefix = String(string.substring(from:\
    \ start))\n                        ~~~~~~ ^~~~~~~~~\n/tmp/tmpyzt32rrw.swift:17:32:\
    \ error: value of type 'String' has no member 'substring'\n    let suffix = String(string.substring(from:\
    \ end!))\n                        ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    guard string.hasPrefix(string[0])\
    \ else { return [string] }\n    var prefixes = [String]()\n    for c in string.characters\
    \ {\n        for prefix in all_prefixes(string: String(string[string.index(before:\
    \ c)])) {\n            prefixes.append(prefix + String(string[c]))\n        }\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmplrqrn2eb.swift:6:34: error: no exact matches in call to subscript\
    \ \n    guard string.hasPrefix(string[0]) else { return [string] }\n         \
    \                        ^\nSwift.String:3:12: note: candidate expects value of\
    \ type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmplrqrn2eb.swift:8:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    for c in\
    \ string.characters {\n                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmplrqrn2eb.swift:9:79: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String.Index'\n       \
    \ for prefix in all_prefixes(string: String(string[string.index(before: c)]))\
    \ {\n                                                                        \
    \      ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let prefixes = string.prefixes(of:\
    \ String(string))\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyqo2u9yx.swift:6:27: error: value of type 'String' has no member\
    \ 'prefixes'\n    let prefixes = string.prefixes(of: String(string))\n       \
    \            ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let result = prefixes(string)\n\
    \    var strings = [string]\n    while !string.isEmpty {\n        strings.append(string)\n\
    \        if let index = find(string) { strings.remove(at: index) } else { break\
    \ }\n    }\n    return strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2fywr9_g.swift:6:18: error: cannot find 'prefixes' in scope\n \
    \   let result = prefixes(string)\n                 ^~~~~~~~\n/tmp/tmp2fywr9_g.swift:10:24:\
    \ error: cannot find 'find' in scope\n        if let index = find(string) { strings.remove(at:\
    \ index) } else { break }\n                       ^~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    // prefix -> last index\n\
    \    var prefix: [Int: Int] = [:]\n    var current = 1\n    for i in string.characters.reversed().enumerated()\
    \ {\n        if prefix[String(current)] != nil {\n            current = prefix[String(current)]!\
    \ + 1\n        } else {\n            prefix[String(current)] = i\n           \
    \ current = 1\n        }\n    }\n    var output: [String] = []\n    var prefixLen\
    \ = Int.max\n    for (key) in prefix {\n        let key = String(key)\n      \
    \  let len = prefix[key] - String(key).characters.first!\n        if len > prefixLen\
    \ {\n            prefixLen = len\n            output = key.characters.reversed()\n\
    \        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvfj8ym7a.swift:9:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in string.characters.reversed().enumerated()\
    \ {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpvfj8ym7a.swift:10:19: error: cannot convert value of type\
    \ 'String' to expected argument type 'Int'\n        if prefix[String(current)]\
    \ != nil {\n                  ^\n/tmp/tmpvfj8ym7a.swift:11:30: error: cannot convert\
    \ value of type 'String' to expected argument type 'Int'\n            current\
    \ = prefix[String(current)]! + 1\n                             ^\n/tmp/tmpvfj8ym7a.swift:13:20:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \            prefix[String(current)] = i\n                   ^\n/tmp/tmpvfj8ym7a.swift:13:39:\
    \ error: cannot assign value of type '(offset: Int, element: ReversedCollection<String>.Element)'\
    \ (aka '(offset: Int, element: Character)') to subscript of type 'Int'\n     \
    \       prefix[String(current)] = i\n                                      ^\n\
    /tmp/tmpvfj8ym7a.swift:20:19: error: no exact matches in call to initializer \n\
    \        let key = String(key)\n                  ^\nSwift.String:4:23: note:\
    \ candidate requires that '(key: Int, value: Int)' conform to 'LosslessStringConvertible'\
    \ (requirement specified as 'T' : 'LosslessStringConvertible')\n    @inlinable\
    \ public init<T>(_ value: T) where T : LosslessStringConvertible\n           \
    \           ^\nSwift.String:2:12: note: candidate requires that '(key: Int, value:\
    \ Int)' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n\
    \    public init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where\
    \ T : BinaryInteger\n           ^\nSwift.String:2:12: note: incorrect labels for\
    \ candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:6:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(reflecting:)')\n    publi"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let length  = string.characters.count\n\
    \    var prefixes = [String]()\n    for i in 0...length {\n        prefixes.append(String(string.characters[i...i]))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9icbo23p.swift:6:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length  = string.characters.count\n           \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp9icbo23p.swift:9:32: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        prefixes.append(String(string.characters[i...i]))\n                 \
    \              ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmp9icbo23p.swift:9:39: error: 'characters' is unavailable: Please use String\
    \ directly\n        prefixes.append(String(string.characters[i...i]))\n      \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefix = \"\"\n    var\
    \ prefixes = [String]()\n    var i = 0\n    while i < string.count {\n       \
    \ prefix = string.prefix(i)\n        if prefix == \"\" {\n            break\n\
    \        }\n        prefixes.append(prefix)\n        i += 1\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpywes3zgj.swift:10:25: error: no 'prefix' candidates produce the\
    \ expected contextual result type 'String'\n        prefix = string.prefix(i)\n\
    \                        ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>',\
    \ not the expected contextual result type 'String'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'String.SubSequence'\
    \ (aka 'Substring'), not the expected contextual result type 'String'\n    @inlinable\
    \ public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n     \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    string.enumerateSubstrings(in: NSMakeRange(0, string.count)) { (substring,\
    \ substringRange, enclosingRange, stop) in\n        result.append(substring)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq_ieqdvg.swift:7:36: error: cannot find 'NSMakeRange' in scope\n\
    \    string.enumerateSubstrings(in: NSMakeRange(0, string.count)) { (substring,\
    \ substringRange, enclosingRange, stop) in\n                                 \
    \  ^~~~~~~~~~~\n/tmp/tmpq_ieqdvg.swift:7:12: error: value of type 'String' has\
    \ no member 'enumerateSubstrings'\n    string.enumerateSubstrings(in: NSMakeRange(0,\
    \ string.count)) { (substring, substringRange, enclosingRange, stop) in\n    ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let stringParts = string.characters.split{$0\
    \ == string[0]}\n    return stringParts.reversed().prefix(stringParts.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4eyput09.swift:6:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let stringParts = string.characters.split{$0 == string[0]}\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp4eyput09.swift:6:53: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    let stringParts\
    \ = string.characters.split{$0 == string[0]}\n                               \
    \                     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp4eyput09.swift:7:35: error: no 'prefix' candidates\
    \ produce the expected contextual result type '[String]'\n    return stringParts.reversed().prefix(stringParts.count)\n\
    \                                  ^\nSwift.Sequence:7:40: note: 'prefix' produces\
    \ 'PrefixSequence<[String.SubSequence]>' (aka 'PrefixSequence<Array<Substring>>'),\
    \ not the expected contextual result type '[String]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n                    \
    \                   ^\nSwift.Collection:6:40: note: 'prefix' produces 'ArraySlice<String.SubSequence>'\
    \ (aka 'ArraySlice<Substring>'), not the expected contextual result type '[String]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> Self.SubSequence\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'Slice<ReversedCollection<[String.SubSequence]>>' (aka 'Slice<ReversedCollection<Array<Substring>>>'),\
    \ not the expected contextual result type '[String]'\n    @inlinable public __consuming\
    \ func prefix(_ maxLength: Int) -> Self.SubSequence\n                        \
    \               ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<ReversedCollection<[String.SubSequence]>>'\
    \ (aka 'PrefixSequence<ReversedCollection<Array<Substring>>>'), not the expected\
    \ context"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let maxLength = (string.characters.count\
    \ - 1)\n    if maxLength == 0 {\n        return [\"\"]\n    }\n    var prefixes\
    \ = [String]()\n    for i in 0..<string.characters.count {\n        if i == 0\
    \ {\n            prefixes.append(String(string.characters[i]))\n        } else\
    \ {\n            prefixes.append(String(string.characters[i]) + String(string.characters[i\
    \ - 1]))\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxfyuq_e1.swift:6:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    let maxLength = (string.characters.count - 1)\n   \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpxfyuq_e1.swift:11:25: error: 'characters' is unavailable:\
    \ Please use String directly\n    for i in 0..<string.characters.count {\n   \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxfyuq_e1.swift:13:36: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            prefixes.append(String(string.characters[i]))\n\
    \                                   ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpxfyuq_e1.swift:13:43: error:\
    \ 'characters' is unavailable: Please use String directly\n            prefixes.append(String(string.characters[i]))\n\
    \                                          ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpxfyuq_e1.swift:15:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            prefixes.append(String(string.characters[i]) + String(string.characters[i\
    \ - 1]))\n                                   ^~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxfyuq_e1.swift:15:43:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ prefixes.append(String(string.characters[i]) + String(string.characters[i -\
    \ 1]))\n                                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was "
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n  return prefixes(string, []())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3963nqtf.swift:6:10: error: cannot find 'prefixes' in scope\n \
    \ return prefixes(string, []())\n         ^~~~~~~~\n/tmp/tmp3963nqtf.swift:6:27:\
    \ error: cannot call value of non-function type '[Any]'\n  return prefixes(string,\
    \ []())\n                          ^ ~~\n                            \n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    if let stringRange = string.range(of: String(\"\")) {\n        for stringIdx\
    \ in stringRange {\n            if stringIdx < string.endIndex {\n           \
    \     prefixes.append(String(string.prefix(upTo: stringIdx + 1)))\n          \
    \  }\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc_c90fwu.swift:7:33: error: value of type 'String' has no member\
    \ 'range'\n    if let stringRange = string.range(of: String(\"\")) {\n       \
    \                  ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    for letter in string.characters {\n        result.append(String(letter))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpylgbq9d1.swift:7:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in string.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    if string == \"\" {\n        return prefixes\n    }\n    let prefixLength\
    \ = string.prefix(with: 0).count\n    prefixes.append(String(string.prefix(with:\
    \ prefixLength)))\n    return all_prefixes(string: string.dropFirst(prefixLength))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9a7eunr5.swift:10:37: error: extraneous argument label 'with:'\
    \ in call\n    let prefixLength = string.prefix(with: 0).count\n             \
    \                       ^~~~~~~\n                                     \n/tmp/tmp9a7eunr5.swift:11:35:\
    \ error: no exact matches in call to instance method 'prefix'\n    prefixes.append(String(string.prefix(with:\
    \ prefixLength)))\n                                  ^\n/tmp/tmp9a7eunr5.swift:11:35:\
    \ note: found candidate with type '(Int) -> PrefixSequence<String>'\n    prefixes.append(String(string.prefix(with:\
    \ prefixLength)))\n                                  ^\n/tmp/tmp9a7eunr5.swift:11:35:\
    \ note: found candidate with type '(Int) -> String.SubSequence' (aka '(Int) ->\
    \ Substring')\n    prefixes.append(String(string.prefix(with: prefixLength)))\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    var prefix = \"\"\n    for c in string {\n        if c == \"-\" {\n     \
    \       for x in result {\n                prefix += x\n            }\n      \
    \      result = []\n        } else {\n            prefix += c\n            result.append(prefix)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpua0jjlr1.swift:15:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            prefix += c\n              \
    \        ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \n    for character in string.characters {\n        if let index = string.index(of:\
    \ character) {\n            if let prefix = string.prefix(from: index).map(String.init)\
    \ {\n                result.append(prefix)\n            }\n        }\n    }\n\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4yqhdgyg.swift:8:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in string.characters {\n            \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4yqhdgyg.swift:9:31: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        if let index = string.index(of: character) {\n\
    \                              ^\n/tmp/tmp4yqhdgyg.swift:9:31: note: use 'firstIndex(of:)'\
    \ instead\n        if let index = string.index(of: character) {\n            \
    \                  ^~~~~\n                              firstIndex\n/tmp/tmp4yqhdgyg.swift:10:36:\
    \ error: no exact matches in call to instance method 'prefix'\n            if\
    \ let prefix = string.prefix(from: index).map(String.init) {\n               \
    \                    ^\nSwift.Collection:9:40: note: incorrect labels for candidate\
    \ (have: '(from:)', expected: '(upTo:)')\n    @inlinable public __consuming func\
    \ prefix(upTo end: Self.Index) -> Self.SubSequence\n                         \
    \              ^\nSwift.Collection:11:40: note: incorrect labels for candidate\
    \ (have: '(from:)', expected: '(through:)')\n    @inlinable public __consuming\
    \ func prefix(through position: Self.Index) -> Self.SubSequence\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if let range = getAllPrefixesRange(string:\
    \ string) {\n        let prefix = getPrefix(string: string)\n        let suffixes\
    \ = getSuffix(string: string)\n        var prefixes = [String]()\n        for\
    \ character in range.toRange().lowerBound ..< range.toRange().upperBound {\n \
    \           prefixes.append(prefix + String(character))\n        }\n        return\
    \ prefixes.sorted()\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpplzt6fm0.swift:6:20: error: cannot find 'getAllPrefixesRange' in\
    \ scope\n    if let range = getAllPrefixesRange(string: string) {\n          \
    \         ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpplzt6fm0.swift:7:22: error: cannot find\
    \ 'getPrefix' in scope\n        let prefix = getPrefix(string: string)\n     \
    \                ^~~~~~~~~\n/tmp/tmpplzt6fm0.swift:8:24: error: cannot find 'getSuffix'\
    \ in scope\n        let suffixes = getSuffix(string: string)\n               \
    \        ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return Array(strings.AsciiRanges(string)).prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxwpjojkz.swift:6:18: error: cannot find 'strings' in scope\n  \
    \  return Array(strings.AsciiRanges(string)).prefixes\n                 ^~~~~~~\n\
    /tmp/tmpxwpjojkz.swift:6:47: error: value of type 'Array<_>' has no member 'prefixes'\n\
    \    return Array(strings.AsciiRanges(string)).prefixes\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] =\
    \ []\n    string.characters.forEach { (ch) in\n        prefixes.insert(String(ch),\
    \ at: 0)\n    }\n    return prefixes.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp75sd0m0x.swift:7:12: error: 'characters' is unavailable: Please\
    \ use String directly\n    string.characters.forEach { (ch) in\n           ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    var currentPrefix: String = \"\"\n    for character in string {\n       \
    \ currentPrefix = currentPrefix + String(character)\n        if string.range(of:\
    \ currentPrefix, options: String.CompareOptions.literal, range: nil, locale: nil)\
    \ != nil {\n            result.append(currentPrefix)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl0cgm0r8.swift:10:19: error: value of type 'String' has no member\
    \ 'range'\n        if string.range(of: currentPrefix, options: String.CompareOptions.literal,\
    \ range: nil, locale: nil) != nil {\n           ~~~~~~ ^~~~~\n/tmp/tmpl0cgm0r8.swift:10:60:\
    \ error: type 'String' has no member 'CompareOptions'\n        if string.range(of:\
    \ currentPrefix, options: String.CompareOptions.literal, range: nil, locale: nil)\
    \ != nil {\n                                                    ~~~~~~ ^~~~~~~~~~~~~~\n\
    /tmp/tmpl0cgm0r8.swift:10:91: error: 'nil' requires a contextual type\n      \
    \  if string.range(of: currentPrefix, options: String.CompareOptions.literal,\
    \ range: nil, locale: nil) != nil {\n                                        \
    \                                                  ^\n/tmp/tmpl0cgm0r8.swift:10:104:\
    \ error: 'nil' requires a contextual type\n        if string.range(of: currentPrefix,\
    \ options: String.CompareOptions.literal, range: nil, locale: nil) != nil {\n\
    \                                                                            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for s in string.characters.reversed() {\n        if !prefixes.contains(s)\
    \ {\n            prefixes.append(s)\n        }\n    }\n    return prefixes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmqpu227w.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in string.characters.reversed() {\n         \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpmqpu227w.swift:8:31: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        if !prefixes.contains(s)\
    \ {\n                              ^\n/tmp/tmpmqpu227w.swift:9:29: error: cannot\
    \ convert value of type 'String.Element' (aka 'Character') to expected argument\
    \ type 'String'\n            prefixes.append(s)\n                            ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let len = string.characters.count\n\
    \    var result: [String] = []\n    for i in 0..<len {\n        var prefix = string\n\
    \        let end = string.index(string.startIndex, offsetBy: i)\n        prefix.remove(at:\
    \ end.offset, length: 1)\n        result.append(prefix)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5d4dejy1.swift:6:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let len = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp5d4dejy1.swift:11:47:\
    \ error: extra argument 'length' in call\n        prefix.remove(at: end.offset,\
    \ length: 1)\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~^~\n/tmp/tmp5d4dejy1.swift:11:31:\
    \ error: value of type 'String.Index' has no member 'offset'\n        prefix.remove(at:\
    \ end.offset, length: 1)\n                          ~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var maxLength = 0\n    for (_, s) in string.enumerated() {\n        maxLength\
    \ = max(maxLength, s.count)\n        prefixes.append(String(s[0...maxLength]))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbcddp418.swift:9:38: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'count'\n        maxLength = max(maxLength, s.count)\n\
    \                                   ~ ^~~~~\n/tmp/tmpbcddp418.swift:10:33: error:\
    \ value of type 'String.Element' (aka 'Character') has no subscripts\n       \
    \ prefixes.append(String(s[0...maxLength]))\n                               ~^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return Array(string).prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_z_2dxnx.swift:6:26: error: value of type '[String.Element]' (aka\
    \ 'Array<Character>') has no member 'prefixes'\n    return Array(string).prefixes\n\
    \           ~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result = [String]()\n\
    \    for s in string.characters {\n        for i : Int in stride(from: s.offset,\
    \ to: string.characters.count, by: -1) {\n            result.append(string.prefix(from:\
    \ i, length: 1))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxk42v3fh.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for s in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxk42v3fh.swift:8:39:\
    \ error: value of type 'Character' has no member 'offset'\n        for i : Int\
    \ in stride(from: s.offset, to: string.characters.count, by: -1) {\n         \
    \                           ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \tvar i = string.count - 1\n\twhile i >= 0 {\n\t\tprefixes.append(string[i..<string.count])\n\
    \t\ti--\n\t}\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm40wempt.swift:9:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \                prefixes.append(string[i..<string.count])\n                 \
    \               ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpm40wempt.swift:10:4: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n                i--\n                 ^~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string.characters.count\
    \ == 0 {\n        return [] // for empty strings\n    }\n    var prefixes = [String]()\n\
    \    if let lastChar = string.characters.last {\n        prefixes.append(String(lastChar))\n\
    \    }\n    for firstChar in string.characters.dropLast() {\n        prefixes.append(String(firstChar))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkul0vfcv.swift:6:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    if string.characters.count == 0 {\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkul0vfcv.swift:10:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    if let lastChar\
    \ = string.characters.last {\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpkul0vfcv.swift:13:29: error: 'characters'\
    \ is unavailable: Please use String directly\n    for firstChar in string.characters.dropLast()\
    \ {\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = Array<String>()\n\
    \    for character in string {\n        prefixes.insert(character, for: character)\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmphkyhysw6.swift:8:24: error: incorrect argument labels in call (have\
    \ '_:for:', expected 'contentsOf:at:')\n        prefixes.insert(character, for:\
    \ character)\n                       ^           ~~~\n                       \
    \ contentsOf:  at\n/tmp/tmphkyhysw6.swift:8:41: error: cannot convert value of\
    \ type 'Character' to expected argument type 'Array<String>.Index' (aka 'Int')\n\
    \        prefixes.insert(character, for: character)\n                        \
    \                ^\n/tmp/tmphkyhysw6.swift:8:9: error: instance method 'insert(contentsOf:at:)'\
    \ requires that 'Character' conform to 'Collection'\n        prefixes.insert(character,\
    \ for: character)\n        ^\nSwift.RangeReplaceableCollection:7:37: note: where\
    \ 'C' = 'Character'\n    @inlinable public mutating func insert<C>(contentsOf\
    \ newElements: __owned C, at i: Self.Index) where C : Collection, Self.Element\
    \ == C.Element\n                                    ^\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return scan(string, []func(string)\
    \ bool{len(string) <= 0}, func(prefix string) bool { return strings.HasPrefix(string,\
    \ prefix) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_ke4d3ld.swift:6:27: error: expected ',' separator\n    return\
    \ scan(string, []func(string) bool{len(string) <= 0}, func(prefix string) bool\
    \ { return strings.HasPrefix(string, prefix) })\n                          ^\n\
    \                          ,\n/tmp/tmp_ke4d3ld.swift:6:27: error: expected expression\
    \ in list of expressions\n    return scan(string, []func(string) bool{len(string)\
    \ <= 0}, func(prefix string) bool { return strings.HasPrefix(string, prefix) })\n\
    \                          ^\n/tmp/tmp_ke4d3ld.swift:6:31: error: expected identifier\
    \ in function declaration\n    return scan(string, []func(string) bool{len(string)\
    \ <= 0}, func(prefix string) bool { return strings.HasPrefix(string, prefix) })\n\
    \                              ^\n/tmp/tmp_ke4d3ld.swift:6:68: error: expected\
    \ identifier in function declaration\n    return scan(string, []func(string) bool{len(string)\
    \ <= 0}, func(prefix string) bool { return strings.HasPrefix(string, prefix) })\n\
    \                                                                   ^\n/tmp/tmp_ke4d3ld.swift:6:12:\
    \ error: cannot find 'scan' in scope\n    return scan(string, []func(string) bool{len(string)\
    \ <= 0}, func(prefix string) bool { return strings.HasPrefix(string, prefix) })\n\
    \           ^~~~\n"
  stdout: ''
  timestamp: 1660014338
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for letter in string.characters {\n        if let index = string.firstIndex(of:\
    \ String(letter)) {\n            prefixes.append(String(string.prefix(upTo: index)))\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo17dgam4.swift:7:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in string.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpo17dgam4.swift:8:46: error: cannot convert value of type 'String' to expected\
    \ argument type 'String.Element' (aka 'Character')\n        if let index = string.firstIndex(of:\
    \ String(letter)) {\n                                             ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var currentChar = string[0]\n    var currentPos = 1\n    var i = 0\n    for\
    \ string in string.characters {\n        for _ in 0..<currentPos {\n         \
    \   currentChar += string[i]\n            i += 1\n        }\n        if currentChar\
    \ == string[i] {\n            currentPos += 1\n        } else {\n            prefixes.append(currentChar)\n\
    \            currentChar = string[i]\n            currentPos = 1\n        }\n\
    \    }\n    if currentPos != 1 {\n        prefixes.append(currentChar)\n    }\n\
    \    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjkmeocnw.swift:7:23: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    var currentChar\
    \ = string[0]\n                      ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpjkmeocnw.swift:10:26: error: 'characters'\
    \ is unavailable: Please use String directly\n    for string in string.characters\
    \ {\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjkmeocnw.swift:12:25: error: binary operator '+=' cannot\
    \ be applied to operands of type 'Character' and '_'\n            currentChar\
    \ += string[i]\n                        ^\nSwift.RangeReplaceableCollection:1:11:\
    \ note: candidate requires that 'Character' conform to 'RangeReplaceableCollection'\
    \ (requirement specified as 'Self' : 'RangeReplaceableCollection')\nextension\
    \ RangeReplaceableCollection {\n          ^\n/tmp/tmpjkmeocnw.swift:12:34: error:\
    \ value of type 'Character' has no subscripts\n            currentChar += string[i]\n\
    \                           ~~~~~~^\n/tmp/tmpjkmeocnw.swift:15:33: error: value\
    \ of type 'Character' has no subscripts\n        if currentChar == string[i] {\n\
    \                          ~~~~~~^\n/tmp/tmpjkmeocnw.swift:18:29: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       prefixes.append(currentChar)\n                            ^\n/tmp/tmpjkmeocnw.swift:19:33:\
    \ error: value of type 'Character' has no subscripts\n            currentChar\
    \ = string[i]\n                          ~~~~~~^\n/tmp/tmpjkmeocnw.swift:24:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        prefixes.append(currentChar)\n                        ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    var prefix: [String] = []\n    for i in 0 ..< string.count {\n        if\
    \ i == 0 || string.prefix(i - 1).isEmpty {\n            result.append(prefix[0])\n\
    \            prefix = []\n        } else {\n            prefix.append(string.prefix(i\
    \ - 1))\n        }\n    }\n    result.append(prefix[0])\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1_wbqzbm.swift:13:20: error: no exact matches in call to instance\
    \ method 'append'\n            prefix.append(string.prefix(i - 1))\n         \
    \          ^\nSwift.Array:6:37: note: candidate expects value of type 'String'\
    \ for parameter #1 (got 'PrefixSequence<String>')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'PrefixSequence<String>')\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Self.Element)\n          \
    \                          ^\n/tmp/tmp1_wbqzbm.swift:13:20: note: found candidate\
    \ with type '(__owned PrefixSequence<String>) -> ()'\n            prefix.append(string.prefix(i\
    \ - 1))\n                   ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var shortest = string\n    var longest = string\n    for character in string.characters\
    \ {\n        shortest = longest\n        longest = character\n    }\n    for character\
    \ in shortest.characters {\n        prefixes.append(character)\n    }\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnlhi69qy.swift:9:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in string.characters {\n            \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpnlhi69qy.swift:11:19: error: cannot assign value of type 'Character'\
    \ to type 'String'\n        longest = character\n                  ^~~~~~~~~\n\
    /tmp/tmpnlhi69qy.swift:13:31: error: 'characters' is unavailable: Please use String\
    \ directly\n    for character in shortest.characters {\n                     \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnlhi69qy.swift:14:25:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        prefixes.append(character)\n                        ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let prefix = Array(string.prefix(string.characters.count))\n\
    \    return prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy9u60tir.swift:6:45: error: 'characters' is unavailable: Please\
    \ use String directly\n    let prefix = Array(string.prefix(string.characters.count))\n\
    \                                            ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpy9u60tir.swift:7:12: error: cannot convert\
    \ return expression of type '[Character]' to return type '[String]'\n    return\
    \ prefix\n           ^\n/tmp/tmpy9u60tir.swift:7:12: note: arguments to generic\
    \ parameter 'Element' ('Character' and 'String') are expected to be equal\n  \
    \  return prefix\n           ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_helper(string,\
    \ nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(all_prefixes(string: \"\
    \") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\", \"\
    as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa65x7_72.swift:6:12: error: cannot find 'all_prefixes_helper' in\
    \ scope\n    return all_prefixes_helper(string, nil)\n           ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa65x7_72.swift:6:40: error: 'nil' requires a contextual type\n    return\
    \ all_prefixes_helper(string, nil)\n                                       ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var current = String()\n    for c in string {\n        if !c.isEmpty {\n\
    \            current = current + c\n        }\n        prefixes.append(current)\n\
    \        current = \"\"\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoz8wmm0_.swift:9:15: error: value of type 'Character' has no member\
    \ 'isEmpty'\n        if !c.isEmpty {\n            ~ ^~~~~~~\n/tmp/tmpoz8wmm0_.swift:10:33:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            current = current + c\n                                ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let count = string.characters.count\n\
    \    let prefixes = [String]()\n    var currentPrefix: String = \"\"\n\n    for\
    \ i in 0..<count {\n        currentPrefix = String(string.characters[0..<i]) +\
    \ currentPrefix\n        prefixes.append(currentPrefix)\n    }\n    return prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqkgubr8e.swift:6:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let count = string.characters.count\n             \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpqkgubr8e.swift:11:32: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n        currentPrefix\
    \ = String(string.characters[0..<i]) + currentPrefix\n                       \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript<R>(bounds: R)\
    \ -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpqkgubr8e.swift:11:39: error: 'characters' is unavailable: Please use String\
    \ directly\n        currentPrefix = String(string.characters[0..<i]) + currentPrefix\n\
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpqkgubr8e.swift:12:18: error: cannot use mutating member\
    \ on immutable value: 'prefixes' is a 'let' constant\n        prefixes.append(currentPrefix)\n\
    \        ~~~~~~~~ ^\n/tmp/tmpqkgubr8e.swift:7:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let prefixes = [String]()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] =\
    \ []\n    var lastLength = 0\n    for currentLength in string.utf16.count {\n\
    \        if lastLength == 0 {\n            prefixes.append(String(string.utf16[currentLength...]))\n\
    \            lastLength = currentLength\n            continue\n        }\n   \
    \     if currentLength == lastLength {\n            prefixes.append(String(string.utf16[currentLength...]))\n\
    \            lastLength = currentLength\n        } else {\n            lastLength\
    \ = currentLength\n        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmplktptg43.swift:8:39: error: for-in loop requires 'Int' to conform\
    \ to 'Sequence'\n    for currentLength in string.utf16.count {\n             \
    \            ~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix: String = \"\"\n\n    for c in string.characters {\n        if\
    \ prefix != \"\" {\n            if c == prefix {\n                prefixes.append(prefix)\n\
    \                prefix = \"\"\n            } else {\n                prefixes.append(prefix)\n\
    \                prefix = \"\"\n            }\n        }\n        prefix += String(c)\n\
    \    }\n\n    prefixes.append(prefix)\n\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbmz2lv8g.swift:9:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbmz2lv8g.swift:11:18:\
    \ error: binary operator '==' cannot be applied to operands of type 'Character'\
    \ and 'String'\n            if c == prefix {\n               ~ ^  ~~~~~~\n/tmp/tmpbmz2lv8g.swift:11:18:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            if c == prefix {\n   \
    \              ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return strings.SplitN(string,\n\
    \                         maxSplit: 1).toList()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3flnhi4a.swift:6:12: error: cannot find 'strings' in scope\n  \
    \  return strings.SplitN(string,\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        if !contains(prefixes, c) { prefixes.append(c)\
    \ }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1rn_cne0.swift:8:13: error: cannot find 'contains' in scope\n \
    \       if !contains(prefixes, c) { prefixes.append(c) }\n            ^~~~~~~~\n\
    /tmp/tmp1rn_cne0.swift:8:53: error: cannot convert value of type 'Character' to\
    \ expected argument type 'String'\n        if !contains(prefixes, c) { prefixes.append(c)\
    \ }\n                                                    ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefix = []\n    for\
    \ letter in string {\n        prefix += prefixOfString(letter)\n    }\n    return\
    \ prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxumizwol.swift:6:18: error: empty collection literal requires an\
    \ explicit type\n    var prefix = []\n                 ^~\n/tmp/tmpxumizwol.swift:8:19:\
    \ error: cannot find 'prefixOfString' in scope\n        prefix += prefixOfString(letter)\n\
    \                  ^~~~~~~~~~~~~~\n/tmp/tmpxumizwol.swift:10:12: error: cannot\
    \ convert return expression of type '[Any]' to return type '[String]'\n    return\
    \ prefix\n           ^\n/tmp/tmpxumizwol.swift:10:12: note: arguments to generic\
    \ parameter 'Element' ('Any' and 'String') are expected to be equal\n    return\
    \ prefix\n           ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var allPrefixes: [String]\
    \ = []\n    for index in range(string.count) {\n        let prefix = string[index..<string.count]\n\
    \        allPrefixes.append(prefix)\n    }\n    return allPrefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc8kpt1kv.swift:7:18: error: cannot find 'range' in scope\n    for\
    \ index in range(string.count) {\n                 ^~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result = Array(string.utf16)\n\
    \    var length = 0\n    for element in result {\n        length += 1\n      \
    \  if element == 0 {\n            result.remove(at: 0)\n        }\n    }\n   \
    \ guard length > 0 else {\n        return result\n    }\n    var prefix = String()\n\
    \    while length > 0 {\n        let index = result.index(of: 0)\n        if index\
    \ == -1 { break }\n        prefix = String(result[index..<result.index(before:\
    \ index)])\n        result.remove(at: index)\n        length += 1\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq5i1qyb5.swift:15:16: error: cannot convert return expression of\
    \ type '[UTF16.CodeUnit]' (aka 'Array<UInt16>') to return type '[String]'\n  \
    \      return result\n               ^\n/tmp/tmpq5i1qyb5.swift:15:16: note: arguments\
    \ to generic parameter 'Element' ('UTF16.CodeUnit' (aka 'UInt16') and 'String')\
    \ are expected to be equal\n        return result\n               ^\n/tmp/tmpq5i1qyb5.swift:19:28:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = result.index(of: 0)\n                           ^\n/tmp/tmpq5i1qyb5.swift:19:28:\
    \ note: use 'firstIndex(of:)' instead\n        let index = result.index(of: 0)\n\
    \                           ^~~~~\n                           firstIndex\n/tmp/tmpq5i1qyb5.swift:21:61:\
    \ error: value of optional type 'Array<UTF16.CodeUnit>.Index?' (aka 'Optional<Int>')\
    \ must be unwrapped to a value of type 'Array<UTF16.CodeUnit>.Index' (aka 'Int')\n\
    \        prefix = String(result[index..<result.index(before: index)])\n      \
    \                                                      ^\n/tmp/tmpq5i1qyb5.swift:21:61:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        prefix = String(result[index..<result.index(before: index)])\n\
    \                                                            ^\n             \
    \                                                     ?? <#default value#>\n/tmp/tmpq5i1qyb5.swift:21:61:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        prefix = String(result[index..<result.index(before: index)])\n\
    \                                                            ^\n             \
    \                                                    !\n/tmp/tmpq5i1qyb5.swift:21:18:\
    \ error: no exact matches in call to initializer \n        prefix = String(result[index..<result.index(before:\
    \ index)])\n                 ^\n/tmp/tmpq5i1qyb5.swift:21:18: note: found candidate\
    \ with type '(ArraySlice<UTF16.CodeUnit>) -> String' (aka '(ArraySlice<UInt16>)\
    \ -> String')\n        prefix = String(result[index..<result.index(befo"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return reduce(into: []) {\
    \ $0 += String($1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprf2ppec1.swift:6:12: error: cannot find 'reduce' in scope\n   \
    \ return reduce(into: []) { $0 += String($1) }\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if let prefixes = string.prefixes\
    \ {\n        return prefixes.map { String($0) }\n    }\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3y7h4l37.swift:6:30: error: value of type 'String' has no member\
    \ 'prefixes'\n    if let prefixes = string.prefixes {\n                      ~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    for c in string.characters{\n        if !result.contains(where: {$0 === String(format:\
    \ \"%@%@\", c, \"\")}) {\n            result.append(String(format: \"%@%@\", c,\
    \ \"\"))\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4ytei7g3.swift:7:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in string.characters{\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4ytei7g3.swift:8:37:\
    \ error: argument type 'String' expected to be an instance of a class or class-constrained\
    \ type\n        if !result.contains(where: {$0 === String(format: \"%@%@\", c,\
    \ \"\")}) {\n                                    ^\n/tmp/tmp4ytei7g3.swift:8:44:\
    \ error: argument type 'String' expected to be an instance of a class or class-constrained\
    \ type\n        if !result.contains(where: {$0 === String(format: \"%@%@\", c,\
    \ \"\")}) {\n                                           ^\n/tmp/tmp4ytei7g3.swift:8:50:\
    \ error: extra arguments at positions #2, #3 in call\n        if !result.contains(where:\
    \ {$0 === String(format: \"%@%@\", c, \"\")}) {\n                            \
    \                     ^\nSwift.String:3:12: note: 'init(_:)' declared here\n \
    \   public init<S>(_ other: S) where S : LosslessStringConvertible, S : Sequence,\
    \ S.Element == Character\n           ^\n/tmp/tmp4ytei7g3.swift:9:33: error: extra\
    \ arguments at positions #2, #3 in call\n            result.append(String(format:\
    \ \"%@%@\", c, \"\"))\n                                ^\nSwift.String:4:23: note:\
    \ 'init(_:)' declared here\n    @inlinable public init<T>(_ value: T) where T\
    \ : LosslessStringConvertible\n                      ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_suffixes(string).reverse()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjplwts7z.swift:6:12: error: cannot find 'all_suffixes' in scope\n\
    \    return all_suffixes(string).reverse()\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var allPrefixes = [String]()\n\
    \    for character in string {\n        allPrefixes.append(String(character))\n\
    \    }\n    return allPrefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmpvk0r1g08/tmpvk0r1g08.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7cf1b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7ceeadb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7ceead988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7ceeac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvk0r1g08                        0x0000557b1149f828 <unavailable> + 6184

    5    libc.so.6                          0x00002ad7cf3a2460 __libc_start_main +
    245

    6    tmpvk0r1g08                        0x0000557b1149f289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for _ in 0..<string.count {\n        prefixes.append(string.prefix(string.startIndex))\n\
    \    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8age_od7.swift:8:32: error: no exact matches in call to instance\
    \ method 'prefix'\n        prefixes.append(string.prefix(string.startIndex))\n\
    \                               ^\n/tmp/tmp8age_od7.swift:8:32: note: candidate\
    \ expects value of type 'String.Index' for parameter #1 (got 'String.Index')\n\
    \        prefixes.append(string.prefix(string.startIndex))\n                 \
    \              ^\n/tmp/tmp8age_od7.swift:8:32: note: candidate expects value of\
    \ type 'String.Index' for parameter #1 (got 'String.Index')\n        prefixes.append(string.prefix(string.startIndex))\n\
    \                               ^\n/tmp/tmp8age_od7.swift:8:18: error: no exact\
    \ matches in call to instance method 'append'\n        prefixes.append(string.prefix(string.startIndex))\n\
    \                 ^\n/tmp/tmp8age_od7.swift:8:18: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'String.Index')\n        prefixes.append(string.prefix(string.startIndex))\n\
    \                 ^\n/tmp/tmp8age_od7.swift:8:18: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'String.Index')\n        prefixes.append(string.prefix(string.startIndex))\n\
    \                 ^\n/tmp/tmp8age_od7.swift:8:18: note: found candidate with type\
    \ '(__owned String.SubSequence) -> ()' (aka '(__owned Substring) -> ()')\n   \
    \     prefixes.append(string.prefix(string.startIndex))\n                 ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes: [String] =\
    \ []\n    var currentPrefix: String = \"\"\n\n    for character in string {\n\
    \        currentPrefix = currentPrefix + character\n\n        if let index = find(prefixes,\
    \ currentPrefix) {\n            prefixes[index] = currentPrefix\n        } else\
    \ {\n            prefixes.append(currentPrefix)\n        }\n    }\n\n    return\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmozz11rk.swift:10:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        currentPrefix = currentPrefix +\
    \ character\n                                        ^\n/tmp/tmpmozz11rk.swift:12:24:\
    \ error: cannot find 'find' in scope\n        if let index = find(prefixes, currentPrefix)\
    \ {\n                       ^~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let arr = string.characters.map\
    \ { String($0) }\n    var result = [String]()\n    var prefix = String()\n   \
    \ for char in arr {\n        if char.count < prefix.count {\n            prefix\
    \ = String(char)\n        }\n        if char.count == prefix.count {\n       \
    \     result.append(prefix)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq7y3edu7.swift:6:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arr = string.characters.map { String($0) }\n  \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var result: [String] = []\n\
    \    var currentIndex = 0\n\n    while currentIndex < string.count {\n       \
    \ result.append(string.prefix(currentIndex))\n        currentIndex = string.index(string.startIndex,\
    \ offsetBy: currentIndex + 1)\n    }\n\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmprscoyf1k.swift:10:16: error: no exact matches in call to instance\
    \ method 'append'\n        result.append(string.prefix(currentIndex))\n      \
    \         ^\nSwift.Array:6:37: note: candidate expects value of type 'String'\
    \ for parameter #1 (got 'PrefixSequence<String>')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'String' for parameter #1 (got 'PrefixSequence<String>')\n    @inlinable\
    \ public mutating func append(_ newElement: __owned Self.Element)\n          \
    \                          ^\n/tmp/tmprscoyf1k.swift:10:16: note: found candidate\
    \ with type '(__owned PrefixSequence<String>) -> ()'\n        result.append(string.prefix(currentIndex))\n\
    \               ^\n/tmp/tmprscoyf1k.swift:11:31: error: cannot assign value of\
    \ type 'String.Index' to type 'Int'\n        currentIndex = string.index(string.startIndex,\
    \ offsetBy: currentIndex + 1)\n                       ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: -4
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = \"\"\n    for c in string.unicodeScalars {\n        prefix +=\
    \ String(describing: c)\n        prefixes.append(prefix)\n        prefix = \"\"\
    \n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: Exception
  stderr: 'tmp3f9_o2a8/tmp3f9_o2a8.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4566acfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45667c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45667c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45667c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3f9_o2a8                        0x0000561ec26b6a68 <unavailable> + 6760

    5    libc.so.6                          0x00002b4566cbb460 __libc_start_main +
    245

    6    tmp3f9_o2a8                        0x0000561ec26b64c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var length = 0\n    for ch in string {\n        prefix := string([]rune(ch)[0:length])\n\
    \        prefixes.append(prefix)\n        length = length + prefixes.count\n \
    \   }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgjcde5kf.swift:9:15: error: consecutive statements on a line must\
    \ be separated by ';'\n        prefix := string([]rune(ch)[0:length])\n      \
    \        ^\n              ;\n/tmp/tmpgjcde5kf.swift:9:16: error: expected expression\n\
    \        prefix := string([]rune(ch)[0:length])\n               ^\n/tmp/tmpgjcde5kf.swift:9:9:\
    \ error: cannot find 'prefix' in scope\n        prefix := string([]rune(ch)[0:length])\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tprefix := [String]()\n\t\n\t\
    for i := 0; i < len(string); i++ {\n\t\tif len(prefix) == 0 || prefix[len(prefix)-1]\
    \ < string[i] {\n\t\t\tprefix = append(prefix, string[i])\n\t\t}\n\t}\n\treturn\
    \ prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7s6p1stp.swift:6:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        prefix := [String]()\n              ^\n       \
    \       ;\n/tmp/tmp7s6p1stp.swift:6:9: error: expected expression\n        prefix\
    \ := [String]()\n               ^\n/tmp/tmp7s6p1stp.swift:8:9: error: expected\
    \ type\n        for i := 0; i < len(string); i++ {\n               ^\n       \
    \         <#type#>\n/tmp/tmp7s6p1stp.swift:8:9: error: expected 'in' after for-each\
    \ pattern\n        for i := 0; i < len(string); i++ {\n               ^\n/tmp/tmp7s6p1stp.swift:8:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < len(string); i++ {\n               ^\n/tmp/tmp7s6p1stp.swift:6:2: error: cannot\
    \ find 'prefix' in scope\n        prefix := [String]()\n        ^~~~~~\n/tmp/tmp7s6p1stp.swift:13:9:\
    \ error: cannot find 'prefix' in scope\n        return prefix\n              \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \tvar shortestLength = min(len(string), 3)\n\n\tprefixes.appendContentsOf(prefix(string:\
    \ string, shortestLength: shortestLength))\n\n\tprefixes.removeAll(where: { (string)\
    \ -> Bool in\n\t\treturn string == \"\"\n\t})\n\n\treturn prefixes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpugm5nvx2.swift:7:27: error: cannot find 'len' in scope\n      \
    \  var shortestLength = min(len(string), 3)\n                                \
    \ ^~~\n/tmp/tmpugm5nvx2.swift:9:28: error: cannot find 'prefix' in scope\n   \
    \     prefixes.appendContentsOf(prefix(string: string, shortestLength: shortestLength))\n\
    \                                  ^~~~~~\n/tmp/tmpugm5nvx2.swift:9:11: error:\
    \ value of type '[String]' has no member 'appendContentsOf'\n        prefixes.appendContentsOf(prefix(string:\
    \ string, shortestLength: shortestLength))\n        ~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefix = \"\"\n\tvar longest\
    \ = string\n\tvar shortest = string\n\tfor len(longest) > 0 && len(shortest) >\
    \ 0 {\n\t\tif longest[len(longest) - 1] == ' ' && shortest[0] != '\\0' {\n\t\t\
    \tprefix = longest[0:len(longest) - 1]\n\t\t\tlongest = longest[1 : len(longest)]\n\
    \t\t\tshortest = shortest[1 : len(shortest)]\n\t\t} else {\n\t\t\tbreak\n\t\t\
    }\n\t}\n\treturn [prefix] + all_prefixes(string)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6qdmplxl.swift:9:9: error: expected 'in' after for-each pattern\n\
    \        for len(longest) > 0 && len(shortest) > 0 {\n               ^\n/tmp/tmp6qdmplxl.swift:10:35:\
    \ error: single-quoted string literal found, use '\"'\n                if longest[len(longest)\
    \ - 1] == ' ' && shortest[0] != '\\0' {\n                                    \
    \            ^~~\n                                                \" \"\n/tmp/tmp6qdmplxl.swift:10:57:\
    \ error: single-quoted string literal found, use '\"'\n                if longest[len(longest)\
    \ - 1] == ' ' && shortest[0] != '\\0' {\n                                    \
    \                                  ^~~~\n                                    \
    \                                  \"\\0\"\n/tmp/tmp6qdmplxl.swift:11:22: error:\
    \ expected ',' separator\n                        prefix = longest[0:len(longest)\
    \ - 1]\n                                          ^\n                        \
    \                  ,\n/tmp/tmp6qdmplxl.swift:11:22: error: expected expression\
    \ in list of expressions\n                        prefix = longest[0:len(longest)\
    \ - 1]\n                                          ^\n/tmp/tmp6qdmplxl.swift:12:24:\
    \ error: expected ',' separator\n                        longest = longest[1 :\
    \ len(longest)]\n                                            ^\n             \
    \                              ,\n/tmp/tmp6qdmplxl.swift:12:24: error: expected\
    \ expression in list of expressions\n                        longest = longest[1\
    \ : len(longest)]\n                                            ^\n/tmp/tmp6qdmplxl.swift:13:26:\
    \ error: expected ',' separator\n                        shortest = shortest[1\
    \ : len(shortest)]\n                                              ^\n        \
    \                                     ,\n/tmp/tmp6qdmplxl.swift:13:26: error:\
    \ expected expression in list of expressions\n                        shortest\
    \ = shortest[1 : len(shortest)]\n                                            \
    \  ^\n/tmp/tmp6qdmplxl.swift:9:26: error: cannot find 'len' in scope\n       \
    \ for len(longest) > 0 && len(shortest) > 0 {\n                      "
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes: [String] = []\n\
    \t\n\tlet input_length = string.characters.count\n\t\n\tvar start = string.startIndex\n\
    \t\n\tfor prefix in prefixes {\n\t\tif start.isGreaterThan(input_length) && start.isLessThan(input_length\
    \ + 1) {\n\t\t\tbreak\n\t\t} else {\n\t\t\tprefixes.insert(string.substring(from:\
    \ start), at: prefixes.count)\n\t\t\tstart += 1\n\t\t}\n\t}\n\t\n\treturn prefixes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8fedrj62.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        let input_length = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8fedrj62.swift:13:12: error: value of type 'String.Index'\
    \ has no member 'isGreaterThan'\n                if start.isGreaterThan(input_length)\
    \ && start.isLessThan(input_length + 1) {\n                   ~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp8fedrj62.swift:13:49: error: value of type 'String.Index' has no member\
    \ 'isLessThan'\n                if start.isGreaterThan(input_length) && start.isLessThan(input_length\
    \ + 1) {\n                                                        ~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8fedrj62.swift:16:27: error: value of type 'String' has no member 'substring'\n\
    \                        prefixes.insert(string.substring(from: start), at: prefixes.count)\n\
    \                                        ~~~~~~ ^~~~~~~~~\n/tmp/tmp8fedrj62.swift:17:10:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n                        start += 1\n                        ~~~~~\
    \ ^  ~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    var prefix = String()\n\n    for ch in string {\n        prefix += ch\n \
    \       prefixes.append(prefix)\n    }\n\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaswzhwrd.swift:10:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        prefix += ch\n                 \
    \ ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tlet maxSize = min(string.count,\
    \ 32)\n\tvar results = [String]()\n\n\tvar prefix: String = \"\"\n\tfor _ in 0..<maxSize\
    \ {\n\t\tprefix += string[0]\n\t\tstring.removeAtIndex(string.startIndex)\n\t\t\
    if string.count <= 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tresults.append(prefix)\n\n\
    \treturn results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpc6tlpvnt.swift:11:19: error: no exact matches in call to subscript\
    \ \n                prefix += string[0]\n                                ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n/tmp/tmpc6tlpvnt.swift:12:10: error: value of type 'String'\
    \ has no member 'removeAtIndex'\n                string.removeAtIndex(string.startIndex)\n\
    \                ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if let ranges = string.unicodeScalars.map\
    \ {\n        return (0..<ranges.count).map { String(string[ranges[$0]...], radix:\
    \ 16) }\n    }.flatMap({ $0 }), let prefix = string.unicodeScalars.first?.value\
    \ {\n        return prefix <= 0xFFFF ? ranges.map { String(string[ranges[$0]...],\
    \ radix: 16) } + [prefix] : ranges.map { String(string[ranges[$0]...], radix:\
    \ 16) }\n    } else {\n        return []\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0qu1hpbg.swift:8:6: error: consecutive statements on a line must\
    \ be separated by ';'\n    }.flatMap({ $0 }), let prefix = string.unicodeScalars.first?.value\
    \ {\n     ^\n     ;\n/tmp/tmp0qu1hpbg.swift:8:22: error: consecutive statements\
    \ on a line must be separated by ';'\n    }.flatMap({ $0 }), let prefix = string.unicodeScalars.first?.value\
    \ {\n                     ^\n                     ;\n/tmp/tmp0qu1hpbg.swift:8:22:\
    \ error: expected expression\n    }.flatMap({ $0 }), let prefix = string.unicodeScalars.first?.value\
    \ {\n                     ^\n/tmp/tmp0qu1hpbg.swift:10:6: error: consecutive statements\
    \ on a line must be separated by ';'\n    } else {\n     ^\n     ;\n/tmp/tmp0qu1hpbg.swift:10:7:\
    \ error: expected expression\n    } else {\n      ^\n/tmp/tmp0qu1hpbg.swift:6:28:\
    \ error: generic parameter 'T' could not be inferred\n    if let ranges = string.unicodeScalars.map\
    \ {\n                           ^\nSwift.Collection:2:28: note: in call to function\
    \ 'map'\n    @inlinable public func map<T>(_ transform: (Self.Element) throws\
    \ -> T) rethrows -> [T]\n                           ^\n/tmp/tmp0qu1hpbg.swift:7:41:\
    \ error: initializer 'init(_:radix:uppercase:)' requires that 'String.SubSequence'\
    \ (aka 'Substring') conform to 'BinaryInteger'\n        return (0..<ranges.count).map\
    \ { String(string[ranges[$0]...], radix: 16) }\n                             \
    \           ^\nSwift.String:2:12: note: where 'T' = 'String.SubSequence' (aka\
    \ 'Substring')\n    public init<T>(_ value: T, radix: Int = 10, uppercase: Bool\
    \ = false) where T : BinaryInteger\n           ^\n/tmp/tmp0qu1hpbg.swift:8:7:\
    \ error: reference to member 'flatMap' cannot be resolved without a contextual\
    \ type\n    }.flatMap({ $0 }), let prefix = string.unicodeScalars.first?.value\
    \ {\n     ~^~~~~~~\n/tmp/tmp0qu1hpbg.swift:9:35: error: cannot find 'ranges' in\
    \ scope\n        return prefix <= 0xFFFF ? ranges.map { String(string[ranges[$0]...],\
    \ radix: 16) } + [prefix] : ranges.map { String(string[ranges[$0]...], radix:\
    \ 16) }\n                                  ^~~~~~\n/tmp/tmp0qu1hpbg.swift:9:62:\
    \ error: cannot f"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq_p5i73o.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, 1)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpq_p5i73o.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, 1)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014337
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string == \"\" {\n   \
    \     return []\n    }\n    var prefixes = [String]()\n    var candidate = string\n\
    \    for _ in 0..<string.characters.count {\n        candidate = candidate.dropFirst()\n\
    \        if string.starts(candidate) {\n            prefixes.append(candidate)\n\
    \        }\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8k9oyj1l.swift:11:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for _ in 0..<string.characters.count {\n          \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8k9oyj1l.swift:12:31: error: no 'dropFirst' candidates produce the\
    \ expected contextual result type 'String'\n        candidate = candidate.dropFirst()\n\
    \                              ^\nSwift.Sequence:4:40: note: 'dropFirst' produces\
    \ 'DropFirstSequence<String>', not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func dropFirst(_ k: Int = 1) -> DropFirstSequence<Self>\n\
    \                                       ^\nSwift.Collection:3:40: note: 'dropFirst'\
    \ produces 'String.SubSequence' (aka 'Substring'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func dropFirst(_ k:\
    \ Int = 1) -> Self.SubSequence\n                                       ^\n/tmp/tmp8k9oyj1l.swift:13:26:\
    \ error: missing argument label 'with:' in call\n        if string.starts(candidate)\
    \ {\n                         ^\n                         with: \n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var prefixes = [String]()\n\
    \    for c in string {\n        prefixes.append(string[0 ..< string.firstIndex.advanced(by:\
    \ Int(c))])\n    }\n    return prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi9w44gx3.swift:8:69: error: no exact matches in call to initializer\
    \ \n        prefixes.append(string[0 ..< string.firstIndex.advanced(by: Int(c))])\n\
    \                                                                    ^\n/tmp/tmpi9w44gx3.swift:8:69:\
    \ note: found candidate with type '(Float16) -> Int'\n        prefixes.append(string[0\
    \ ..< string.firstIndex.advanced(by: Int(c))])\n                             \
    \                                       ^\n/tmp/tmpi9w44gx3.swift:8:69: note:\
    \ found candidate with type '(Float) -> Int'\n        prefixes.append(string[0\
    \ ..< string.firstIndex.advanced(by: Int(c))])\n                             \
    \                                       ^\n/tmp/tmpi9w44gx3.swift:8:69: note:\
    \ found candidate with type '(Double) -> Int'\n        prefixes.append(string[0\
    \ ..< string.firstIndex.advanced(by: Int(c))])\n                             \
    \                                       ^\n/tmp/tmpi9w44gx3.swift:8:69: note:\
    \ found candidate with type '(Float80) -> Int'\n        prefixes.append(string[0\
    \ ..< string.firstIndex.advanced(by: Int(c))])\n                             \
    \                                       ^\n/tmp/tmpi9w44gx3.swift:8:69: note:\
    \ found candidate with type '(Builtin.Int64) -> Int'\n        prefixes.append(string[0\
    \ ..< string.firstIndex.advanced(by: Int(c))])\n                             \
    \                                       ^\n/tmp/tmpi9w44gx3.swift:8:69: note:\
    \ found candidate with type '(Builtin.Word) -> Int'\n        prefixes.append(string[0\
    \ ..< string.firstIndex.advanced(by: Int(c))])\n                             \
    \                                       ^\n/tmp/tmpi9w44gx3.swift:8:69: note:\
    \ found candidate with type '(String) -> Int?'\n        prefixes.append(string[0\
    \ ..< string.firstIndex.advanced(by: Int(c))])\n                             \
    \                                       ^\n/tmp/tmpi9w44gx3.swift:8:56: error:\
    \ reference to member 'advanced' cannot be resolved without a contextual type\n\
    \        prefixes.append(string[0 ..< string.firstIndex.advanced(by: Int(c))])\n\
    \                             "
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tlet prefixes: [String] = []\n\
    \tlet stringLength = string.characters.count\n\tvar currentPrefixIndex = stringLength\
    \ - 1\n\tfor _ in 0 ..< stringLength {\n\t\tif currentPrefixIndex == -1 {\n\t\t\
    \tbreak\n\t\t}\n\t\tprefixes.append(string.substring(from: currentPrefixIndex))\n\
    \t\tcurrentPrefixIndex -= 1\n\t}\n\treturn prefixes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpty6u7q3_.swift:7:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        let stringLength = string.characters.count\n  \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpty6u7q3_.swift:13:12: error: no exact matches in call\
    \ to instance method 'append'\n                prefixes.append(string.substring(from:\
    \ currentPrefixIndex))\n                         ^\n/tmp/tmpty6u7q3_.swift:13:12:\
    \ note: found candidate with type '(__owned String) -> ()'\n                prefixes.append(string.substring(from:\
    \ currentPrefixIndex))\n                         ^\n/tmp/tmpty6u7q3_.swift:13:26:\
    \ error: value of type 'String' has no member 'substring'\n                prefixes.append(string.substring(from:\
    \ currentPrefixIndex))\n                                ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let prefixes = [String]()\n\
    \    var current = string\n    while current != \"\" {\n        prefixes.append(current)\n\
    \        current = String(string.dropLast())\n    }\n    return prefixes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbtv81yhh.swift:9:18: error: cannot use mutating member on immutable\
    \ value: 'prefixes' is a 'let' constant\n        prefixes.append(current)\n  \
    \      ~~~~~~~~ ^\n/tmp/tmpbtv81yhh.swift:6:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let prefixes = [String]()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    \n    let shortest = string.prefix(0)\n\
    \    let longest = string.prefix(string.characters.count - 1)\n    \n    return\
    \ shortest.prefix(longest.characters.count - 1) // longest is prefix of shortest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpib6aj11q.swift:8:40: error: 'characters' is unavailable: Please\
    \ use String directly\n    let longest = string.prefix(string.characters.count\
    \ - 1)\n                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpib6aj11q.swift:10:21: error: no 'prefix'\
    \ candidates produce the expected contextual result type '[String]'\n    return\
    \ shortest.prefix(longest.characters.count - 1) // longest is prefix of shortest\n\
    \                    ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String.SubSequence>'\
    \ (aka 'PrefixSequence<Substring>'), not the expected contextual result type '[String]'\n\
    \    @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self>\n\
    \                                       ^\nSwift.Collection:6:40: note: 'prefix'\
    \ produces 'Substring.SubSequence' (aka 'Substring'), not the expected contextual\
    \ result type '[String]'\n    @inlinable public __consuming func prefix(_ maxLength:\
    \ Int) -> Self.SubSequence\n                                       ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string.count < 2 {\n \
    \       return [string]\n    }\n    var results = [String]()\n    var strings\
    \ = [String]()\n    for c in string.characters {\n        if strings.count ==\
    \ 0 {\n            strings.append(c._cfstring)\n        } else {\n           \
    \ if strings.last!.hasPrefix(c._cfstring) {\n                results.append(strings.last!)\n\
    \                strings.append(c._cfstring)\n            }\n        }\n    }\n\
    \    results.append(strings.last!)\n    return results\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9m4vl6u6.swift:11:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in string.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp9m4vl6u6.swift:13:30:\
    \ error: value of type 'Character' has no member '_cfstring'\n            strings.append(c._cfstring)\n\
    \                           ~ ^~~~~~~~~\n/tmp/tmp9m4vl6u6.swift:15:42: error:\
    \ value of type 'Character' has no member '_cfstring'\n            if strings.last!.hasPrefix(c._cfstring)\
    \ {\n                                       ~ ^~~~~~~~~\n/tmp/tmp9m4vl6u6.swift:17:34:\
    \ error: value of type 'Character' has no member '_cfstring'\n               \
    \ strings.append(c._cfstring)\n                               ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var arr = [String]()\n  \
    \  for c in string.characters.reverse() {\n        for s in arr.suffix(string.characters.count\
    \ - 1) {\n            if s.characters.count <= c {\n                break\n  \
    \          }\n            arr.append(String(Array[c..<s]))\n        }\n    }\n\
    \    return arr.reverse()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd87kzzyd.swift:7:32: error: value of type 'String' has no member\
    \ 'reverse'\n    for c in string.characters.reverse() {\n             ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpd87kzzyd.swift:15:16: error: cannot convert return expression\
    \ of type '()' to return type '[String]'\n    return arr.reverse()\n         \
    \  ~~~~^~~~~~~~~\n/tmp/tmpd87kzzyd.swift:8:36: error: 'characters' is unavailable:\
    \ Please use String directly\n        for s in arr.suffix(string.characters.count\
    \ - 1) {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if let _ = string.characters.first\
    \ {\n        return []\n    }\n    var prefixes: [String] = []\n    var index\
    \ = string.startIndex\n    while index < string.endIndex {\n        prefixes.append(String(string.characters[index]))\n\
    \        index = string.index(after: index)\n    }\n    return prefixes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmppbwm6gpm.swift:6:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    if let _ = string.characters.first {\n            \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmppbwm6gpm.swift:12:39: error: 'characters' is unavailable: Please use String\
    \ directly\n        prefixes.append(String(string.characters[index]))\n      \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    array = Array(string.characters)\n\
    \    start = index(array, char: \"a\")\n    end = index(array, char: \"z\")\n\
    \    prefix = [String]()\n    for i = start ... end {\n        prefix.append(String(array[i]))\n\
    \    }\n    return prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpesjezhku.swift:10:11: error: expected 'in' after for-each pattern\n\
    \    for i = start ... end {\n          ^\n/tmp/tmpesjezhku.swift:10:11: error:\
    \ expected Sequence expression for for-each loop\n    for i = start ... end {\n\
    \          ^\n/tmp/tmpesjezhku.swift:6:5: error: cannot find 'array' in scope\n\
    \    array = Array(string.characters)\n    ^~~~~\n/tmp/tmpesjezhku.swift:7:5:\
    \ error: cannot find 'start' in scope\n    start = index(array, char: \"a\")\n\
    \    ^~~~~\n/tmp/tmpesjezhku.swift:7:13: error: cannot find 'index' in scope\n\
    \    start = index(array, char: \"a\")\n            ^~~~~\n/tmp/tmpesjezhku.swift:7:19:\
    \ error: cannot find 'array' in scope\n    start = index(array, char: \"a\")\n\
    \                  ^~~~~\n/tmp/tmpesjezhku.swift:8:5: error: cannot find 'end'\
    \ in scope\n    end = index(array, char: \"z\")\n    ^~~\n/tmp/tmpesjezhku.swift:8:11:\
    \ error: cannot find 'index' in scope\n    end = index(array, char: \"z\")\n \
    \         ^~~~~\n/tmp/tmpesjezhku.swift:8:17: error: cannot find 'array' in scope\n\
    \    end = index(array, char: \"z\")\n                ^~~~~\n/tmp/tmpesjezhku.swift:9:5:\
    \ error: cannot find 'prefix' in scope\n    prefix = [String]()\n    ^~~~~~\n\
    /tmp/tmpesjezhku.swift:13:12: error: cannot find 'prefix' in scope\n    return\
    \ prefix\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return all_prefixes_with_sentinel(string:\
    \ string, sentinel: String())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2jvfuu1z.swift:6:12: error: cannot find 'all_prefixes_with_sentinel'\
    \ in scope\n    return all_prefixes_with_sentinel(string: string, sentinel: String())\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    if string.isEmpty {\n   \
    \     return []\n    }\n    let prefixes = (0..<string.count).map {\n        return\
    \ string.substringToIndex($0)\n    }\n    return prefixes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(all_prefixes(string: \"\") == [] as [String])\nassert(all_prefixes(string:\
    \ \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\n\
    assert(all_prefixes(string: \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1wcqgbya.swift:10:23: error: value of type 'String' has no member\
    \ 'substringToIndex'\n        return string.substringToIndex($0)\n           \
    \    ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n\tvar prefixes = [String]()\n\
    \tlet firstChar = string[0]\n\tvar prefixLength = 1\n\t\n\t// find first and second\
    \ character\n\tif firstChar == \"_\" {\n\t\tprefixLength = 0\n\t} else {\n\t\t\
    if firstChar == string.first {\n\t\t\tfor c in string.dropFirst() {\n\t\t\t\t\
    if c.isLower {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tprefixLength += 1\n\t\t\t\
    }\n\t\t}\n\t}\n\t\n\t\n\tfor c in string.dropFirst() {\n\t\tprefixes.append(String(repeating:\
    \ \"_\", count: prefixLength))\n\t\tprefixes[prefixes.count-1] += c\n\t}\n\treturn\
    \ prefixes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(all_prefixes(string:\
    \ \"\") == [] as [String])\nassert(all_prefixes(string: \"asdfgh\") == [\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string:\
    \ \"WWW\") == [\"W\", \"WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn30j4_36.swift:7:18: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let firstChar\
    \ = string[0]\n                        ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpn30j4_36.swift:16:10: error: value\
    \ of type 'Character' has no member 'isLower'\n                              \
    \  if c.isLower {\n                                   ~ ^~~~~~~\n/tmp/tmpn30j4_36.swift:27:33:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                prefixes[prefixes.count-1] += c\n                           \
    \                   ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    return prefixes(string, nil)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjxi4qjcf.swift:6:12: error: cannot find 'prefixes' in scope\n \
    \   return prefixes(string, nil)\n           ^~~~~~~~\n/tmp/tmpjxi4qjcf.swift:6:29:\
    \ error: 'nil' requires a contextual type\n    return prefixes(string, nil)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    var output: [String] = []\n\
    \    if string == \"\" {\n        return output\n    }\n    for i in 0..<string.count\
    \ {\n        var j = i - 1\n        let prefix = string[j..<i]\n        if prefix\
    \ != \"\" {\n            output.append(prefix)\n        }\n    }\n    return output\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1zfeqz75.swift:12:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \        let prefix = string[j..<i]\n                     ^~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmp1zfeqz75.swift:11:13: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n        var j = i - 1\n\
    \        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660014339
- exit_code: 1
  program: "\n/// Return array of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes(string: \"abc\")\n/// [\"a\", \"ab\", \"abc\"]\n\
    func all_prefixes(string: String) -> [String] {\n    let index = string.characters.reduce(0,\
    \ { (sum, char) -> Int in\n        if char != \"a\" {\n            return sum\n\
    \        }\n        return sum + 1\n    })\n    return Array(string.characters.prefix(index...)).map(String.init)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(all_prefixes(string: \"\") == [] as [String])\n\
    assert(all_prefixes(string: \"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"])\nassert(all_prefixes(string: \"WWW\") == [\"W\", \"\
    WW\", \"WWW\"])"
  status: SyntaxError
  stderr: "/tmp/tmpto7rjhrk.swift:6:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let index = string.characters.reduce(0, { (sum, char)\
    \ -> Int in\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpto7rjhrk.swift:12:48: error: cannot convert value of\
    \ type 'PartialRangeFrom<Int>' to expected argument type 'Int'\n    return Array(string.characters.prefix(index...)).map(String.init)\n\
    \                                               ^\n"
  stdout: ''
  timestamp: 1660014339
