name: HumanEval_101_words_string
language: swift
prompt: "\n/// You will be given a string of words separated by commas or spaces.\
  \ Your task is\n/// to split the string into words and return an array of the words.\n\
  /// For example:\n/// >>> words_string(s: \"Hi, my name is John\")\n/// [\"Hi\"\
  , \"my\", \"name\", \"is\", \"John\"]\n/// >>> words_string(s: \"One, two, three,\
  \ four, five, six\")\n/// [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"\
  ]\nfunc words_string(s: String) -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(words_string(s: \"Hi, my name is John\"\
  ) == [\"Hi\", \"my\", \"name\", \"is\", \"John\"])\nassert(words_string(s: \"One,\
  \ two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\"\
  , \"six\"])\nassert(words_string(s: \"Hi, my name\") == [\"Hi\", \"my\", \"name\"\
  ])\nassert(words_string(s: \"One,, two, three, four, five, six,\") == [\"One\",\
  \ \"two\", \"three\", \"four\", \"five\", \"six\"])\nassert(words_string(s: \"\"\
  ) == [] as [String])\nassert(words_string(s: \"ahmed     , gamal\") == [\"ahmed\"\
  , \"gamal\"])"
completions: ["\tlet wordCharacters = Array(s.characters)\n\treturn wordCharacters.map\
    \ { String($0) }", "    var words: [String] = []\n\n    let scanner = Scanner(string:\
    \ s)\n    scanner.scanUpToCharactersFromSet(\",\".unicodeScalars.filter { !$0.isASCII\
    \ }, intoString: nil)\n\n    if scanner.atEnd {\n        return words\n    }\n\
    \n    scanner.scanUpToCharactersFromSet(\"\".unicodeScalars.filter { !$0.isASCII\
    \ }, intoString: &words)\n\n    return words", "\treturn s.components(separatedBy:\
    \ \",\")", "    let words = s.components(separatedBy: \",\")\n    let result =\
    \ words.map { String($0) }\n    return result", "    // Your code here\n    \n\
    \    return words.wordsString(s.split(separator: \"\\s\"))", "    let delimiters\
    \ = CharacterSet(charactersIn: \",\")\n    var words = s.components(separatedBy:\
    \ delimiters)\n    words = words.flatMap { $0 }\n    return words", "    var words:\
    \ [String] = []\n    for s in s.components(separatedBy: \", \") {\n        for\
    \ s in s.components(separatedBy: \" \") {\n            words.append(s)\n     \
    \   }\n    }\n    return words", "    var words: [String] = []\n    for word,\
    \ _ in words_chars(s: s) {\n        words.append(word)\n    }\n    return words",
  "    var words: [String] = []\n\n    var currentString = \"\"\n    for char in s\
    \ {\n        if char == ' ' || char == ',' {\n            if currentString.isEmpty\
    \ {\n                continue\n            }\n            words.append(currentString)\n\
    \            currentString = \"\"\n        } else {\n            currentString\
    \ += char\n        }\n    }\n    if currentString.isEmpty {\n        words.append(currentString)\n\
    \    }\n    return words", "\tlet a = s.characters.split(separator: \",\", omittingEmptySubsequences:\
    \ false)\n\t\t.map { String($0) }\n\t\t.reduce(into: [String]()) { (result, word)\
    \ in\n\t\t\tif result.last == \"\" {\n\t\t\t\tresult.last.append(word)\n\t\t\t\
    } else {\n\t\t\t\tresult.append(word)\n\t\t\t}\n\t\t}\n\treturn a", '  return
    s.components(separatedBy: ", ").map { $0.components(separatedBy: " ") }', "  \
    \  let words = s.components(separatedBy: \",\")\n    return words.flatMap { $0.components(separatedBy:\
    \ \" \") }", "\treturn strings.Split(s, \" \")", "    var words: [String] = []\n\
    \    s.split(separator: \",\").forEach({ (word) in\n        words.append(word)\n\
    \    })\n    return words", "    if s == \"\" {\n        return []\n    }\n\n\
    \    let chars = s.characters\n    var words = [String]()\n    var i = 0\n\n \
    \   while i < chars.count {\n        if chars[i] == ',' {\n            i += 1\n\
    \            if i < chars.count {\n                words.append(String(chars[i\
    \ ..< chars.count]))\n            }\n        } else {\n            words.append(String(chars[i]))\n\
    \            i += 1\n        }\n    }\n    return words", '    return s.split(separator:
    ",").map{ String($0) }.map{ String($0) }.map{ String($0) }', "\treturn s.characters.split(separator:\
    \ \",\")", "    var arr = [String]()\n    if let split = s.components(separatedBy:\
    \ \",\").map {\n        arr += split\n    }\n\n    if let split = s.components(separatedBy:\
    \ \" \").map {\n        arr += split\n    }\n\n    return arr", "    scanner :=\
    \ bufio.NewScanner(strings.NewReader(s))\n    var words []string\n\n    for scanner.Scan()\
    \ {\n        words = append(words, scanner.Text())\n    }\n\n    return words",
  '  return wordsString(s, "", true)', '    return s.components(separatedBy: ",")',
  "    // Your code here\n    func split(string: String) -> [String] {\n        return\
    \ string.components(separatedBy: \",\")\n    }\n    return split(string: s)",
  '  return s.components(separatedBy: ",")', "\treturn s.split(separator: \",\", omittingEmptySubsequences:\
    \ true).flatMap { $0.split(separator: \" \", omittingEmptySubsequences: true)\
    \ }", '    splitStrings(s, ", ").map(String.init)', "\treturn strings.Split(s,\
    \ \", \")", "    // Your code here\n\n    let words = s.componentsSeparatedByString(\"\
    \ \")\n    return words.map{\n        String($0)\n    }\n", "  return strings.FieldsFunc(s,\
    \ func(r rune) bool {\n    switch r {\n    case ',':\n    case ' ':\n    case\
    \ '.':\n    case ':':\n    case '!':\n      return false\n    }\n    return true\n\
    \  })", "\tsplits := strings.Split(s, \",\")\n\tout := make([]string, len(splits))\n\
    \tfor i, s := range splits {\n\t\tout[i] = strings.Trim(s, \"\\\"\")\n\t}\n\t\
    return out", "    var words = s.characters.split {\n        let char = $0\n  \
    \      let isSpace = Character(char) == \" \" || char == \",\"\n        !isSpace\n\
    \    }\n    return Array(words)", "    let s = string_split(s, \"\\\\s+\")\n \
    \   return s", "  let words = s.componentsSeparatedByString(\" \")\n  return words",
  '  return words.splitEach(s, { $0.split(separator: ",").map(String.init) })', '  return
    s.components(separatedBy: ", ")', '    return split(s, ", ").map{ String($0) }',
  "\treturn s.tokenize(\", \")", "    var words: [String] = []\n    var word = \"\"\
    \n    for c in s {\n        if c != \" \" {\n            word += c\n        }\
    \ else {\n            words.append(word)\n            word = \"\"\n        }\n\
    \    }\n    if word != \"\" {\n        words.append(word)\n    }\n    return words",
  '    return s.components(separatedBy: ",")', "\treturn s.componentsSeparatedByString(\"\
    , \")", '    return s.components(separatedBy: ",")', "    let words: [String]\
    \ = s.components(separatedBy: \" \")\n    return words", '    return s.trimmingCharacters(in:
    .whitespacesAndNewlines).components(separatedBy: ", ").filter({ !$0.isEmpty })',
  '    return words.SplitString(s)', '    return s.components(separatedBy: ",")',
  '    return s.split(separator: ",").map { String($0) }', "    let chars = s.characters.split(separator:\
    \ \",\")\n    return chars.flatMap({ String($0).characters.split(separator: \"\
    \ \") })", '  return s.characters.split{$0 == ","}', "    var result = [String]()\n\
    \    \n    if let input = s {\n        \n        let components = input.components(separatedBy:\
    \ \", \")\n        \n        for component in components {\n            result.append(component)\n\
    \        }\n        \n    }\n    \n    return result", "    let chars = s.characters\n\
    \    var words = [String]()\n    var charPos = s.startIndex\n    while charPos\
    \ != s.endIndex {\n        if chars[charPos] == ',' || chars[charPos] == ' ' {\n\
    \            if charPos != s.startIndex {\n                words.append(String(chars[charPos\
    \ - 1]))\n            }\n            charPos = chars[charPos].advanced(by: 1)\n\
    \        } else {\n            charPos = chars[charPos].advanced(by: 1)\n    \
    \    }\n    }\n    if charPos != s.endIndex {\n        words.append(String(chars[charPos\
    \ - 1]))\n    }\n    return words", '    return s.characters.split{$0 == ","}.map(String.init).filter
    { !$0.isEmpty }.map { $0.trim() }', "    let pattern = \"\\\\W+\"\n    let regex\
    \ = try! NSRegularExpression(pattern: pattern, options: [])\n    return regex.componentsSeparatedByString(s)",
  '  return s.components(separatedBy: ",").flatMap { String($0) }', "\twords := strings.Split(s,\
    \ \" \")\n\tvar output [100]string\n\tfor i := 0; i < len(words); i++ {\n\t\t\
    output[i] = words[i]\n\t}\n\treturn output", '    return s.characters.split(separator:
    ",", omittingEmptySubsequences: true)', "    // Split string into words.\n   \
    \ let words = s.components(separatedBy: \" \")\n    // Split words back into strings.\n\
    \    let strings = words.map { String($0) }\n    // Return array of words.\n \
    \   return strings", '    return s.components(separatedBy: ",")', "  var words\
    \ = s.characters.split(\", \")\n  return words.map { String($0) }", "\treturn\
    \ s.components(separatedBy: \",\")", '    return s.components(separatedBy: ",")',
  "    var result = [String]()\n    var words = [String]()\n    var word = String()\n\
    \    \n    let chars = s.characters.split(separator: \",\")\n    for char in chars\
    \ {\n        word = char.trimmingCharacters(in: .whitespacesAndNewlines)\n   \
    \     words.append(word)\n    }\n    \n    words = words.flatMap({ $0.split(separator:\
    \ \" \") })\n    \n    for word in words {\n        result.append(word)\n    }\n\
    \    \n    return result", "    let words = s.split(separator: \",\")\n    return\
    \ words.map{String($0)}", '    return s.components(separatedBy: ",")', '    return
    s.components(separatedBy: ",")', '    return s.split(separator: ",", omittingEmptySubsequences:
    false).map(String.init)', "    let words: [String] = s.components(separatedBy:\
    \ CharacterSet(charactersIn: \".,\"))\n    return words", "\tlet wordList = s.components(separatedBy:\
    \ \",\")\n\twordList.removeLast()\n\treturn wordList", '    return s.componentsSeparatedByString("
    ").filter({$0 != ""})', '    return s.components(separatedBy: ",")', "    var\
    \ words: [String] = []\n    var word = String()\n    for ch in s.unicodeScalars\
    \ {\n        switch ch {\n        case .Letter:\n            word = String()\n\
    \        case .OtherLetter:\n            word = String()\n        case .Space:\n\
    \            word = String()\n        case .OtherSpace:\n            word = String()\n\
    \        case .Newline:\n            word = String()\n        case .Control:\n\
    \            word = String()\n        case .OtherControl:\n            word =\
    \ String()\n        case .Delimiter:\n            word = String()\n        case\
    \ .OtherDelimiter:\n            word = String()\n        case .Start:\n      \
    \      word = String()\n        case .OtherStart:\n            word = String()\n\
    \        case .UppercaseLetter:\n            word = String()\n        case .OtherUppercaseLetter:\n\
    \            word = String()\n        case .Mark:\n            word = String()\n\
    \        case .OtherMark:\n            word = String()\n        case .LetterNumber:\n\
    \            word = String()\n        case .OtherLetterNumber:\n            word\
    \ = String()\n        case .DecimalDigit:\n            word = String()\n     \
    \   case .OtherDecimalDigit:\n            word = String()\n        case .Extender:\n\
    \            word = String()\n        case .OtherExtender:\n            word =\
    \ String()\n        }\n        if word != \"\" {\n            words.append(word)\n\
    \        }\n    }\n    return words", "    if s == \"\" {\n        return nil\n\
    \    }\n    let words = s.components(separatedBy: \",\")\n    let arr = words.map\
    \ {\n        String($0)\n    }\n    return arr", '    return s.components(separatedBy:
    ",")', '    return s.components(separatedBy: ", ")', '    return s.components(separatedBy:
    ",")', "    return s.componentsSeparatedByCharactersInSet(\n        NSCharacterSet.whitespaceAndNewlineCharacterSet())",
  '    return s.components(separatedBy: ", ").filter({ !$0.isEmpty })', "  var words\
    \ = s.characters\n  words.removeLast()\n  return words.reversed().map {\n    let\
    \ (index, letter) = String($0).index($0)\n    return String(s[..index]).uppercased()\n\
    \  }.reversed()", '    return s.components(separatedBy: ",").flatMap(String.init)',
  "    var words = s.components(separatedBy: \",\")\n    words = words.map(String.init)\n\
    \    return words", "    if s == \"\" {\n        return []\n    }\n\n    let words\
    \ = s.componentsSeparatedByString(\" \")\n    if words.count > 1 {\n        return\
    \ words\n    } else {\n        return [s]\n    }", "\treturn s.components(separatedBy:\
    \ \",\")", "    let scanner = Scanner(string: s)\n    var words: [String] = []\n\
    \n    if scanner.scanUpTo(whitespace()) { words.append(scanner.scan()) }\n\n \
    \   scanner.scanUpTo(commaOrSpace()) { words.append(scanner.scan()) }\n\n    if\
    \ scanner.scanUpTo(whitespace()) { words.append(scanner.scan()) }\n\n    scanner.scanUpTo(whitespace())\
    \ { words.append(scanner.scan()) }\n\n    if scanner.scanUpTo(whitespace()) {\
    \ words.append(scanner.scan()) }\n\n    if scanner.scanUpTo(whitespace()) { words.append(scanner.scan())\
    \ }\n\n    if scanner.scanUpTo(whitespace()) { words.append(scanner.scan()) }\n\
    \n    return words", "    words = s.characters.split{$0 == \",\"}\n    if words.count\
    \ < 1 {\n        words = s.characters.split{$0 == \" \"}.map(String.init)\n  \
    \  }\n    return words", "    if let split = s.components(separatedBy: \",\").map({\
    \ $0.trimmingCharacters(in: CharacterSet.whitespaces) }) {\n        return split.compactMap\
    \ { $0.components(separatedBy: \" \") }\n    } else {\n        return s.split(separator:\
    \ \" \")\n    }", "    var words = split(s)\n    \n    if words.count > 1 {\n\
    \        let lastWord = words[words.count - 1]\n        if lastWord.contains(\"\
    ,\") {\n            words[words.count - 1] = lastWord.components(separatedBy:\
    \ \",\").joined(separator: \" \")\n        }\n    }\n    return words", '    return
    s.split(separator: ",", maxSplits: Int(math.pow(Double(s.characters.count), Double(3))))',
  '    return s.components(separatedBy: ",")', '    return s.componentsSeparatedByString("
    ")', "    let words: [String] = s.components(separatedBy: \",\")\n    .map { $0.trimmingCharacters(in:\
    \ CharacterSet.whitespaces)}\n    return words", '    return s.components(separatedBy:
    ",")', '    return split(s, ", ")', "\tvar result = Array<String>()\n\tlet words\
    \ = s.components(separatedBy: \",\")\n\tfor word in words {\n\t\tlet words = word.components(separatedBy:\
    \ \" \")\n\t\tfor word in words {\n\t\t\tresult.append(word)\n\t\t}\n\t}\n\treturn\
    \ result", "\treturn strings.Split(s, \" \")", '  return strings.Fields(s)', " \
    \   let words = s.components(separatedBy: \", \")\n    return words.map { $0.split(separator:\
    \ \", \").map(String.init) }", "    var words: [String] = []\n    split(s, \"\
    , \").forEach({ words.append(String($0)) })\n    return words", "\treturn s.trim().split(separator:\
    \ \",\").map { String(($0).trimmingCharacters(in: \" \")).lowercased() }", " \
    \   let words: [String] = s.components(separatedBy: \",?\")\n    return words",
  "    let words = s.componentsSeparatedByString(\" \")\n    return words", "    if\
    \ s.isEmpty {\n        return []\n    }\n    var words = s.componentsSeparatedByString(\"\
    \ \")\n    var result = [String]()\n    for word in words {\n        if word.hasPrefix(\"\
    \\\"\") {\n            word = word.dropFirst()\n        }\n        if word.hasSuffix(\"\
    \\\"\") {\n            word = word.dropLast()\n        }\n        if let index\
    \ = word.index(of: \",\", options: .backwards) {\n            word = word.suffix(from:\
    \ index)\n        }\n        word = word.lowercased()\n        result.append(word)\n\
    \    }\n    return result", "    var wordsArray: [String] = []\n    let words\
    \ = s.componentsSeparatedByString(\", \")\n    for word in words {\n        if\
    \ !wordsArray.contains(word) {\n            wordsArray.append(word)\n        }\n\
    \    }\n    return wordsArray", "    let tokens = s.characters.split(\", \").map(String.init)\n\
    \    return tokens", "    var words: [String] = []\n    var i = 0\n    var word\
    \ = \"\"\n\n    for i = 0; i <= s.count; i++ {\n        word = s.substring(i,\
    \ i)\n\n        if word != \",\" {\n            words.append(word)\n        }\n\
    \    }\n\n    return words", '    return s.components(separatedBy: ",")', "  \
    \  let words = s.componentsSeparatedByString(\" \")\n    return words", "    let\
    \ words = s.components(separatedBy: \",\")\n    let result: [String] = []\n  \
    \  for word in words {\n        let trimmedWord = word.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n        result.append(trimmedWord)\n \
    \   }\n    return result", "\treturn s.components(separatedBy: \",\".unicodeScalars.map\
    \ { String($0) })", "    words = s.characters.split(separator: \",\", omittingEmptySubsequences:\
    \ false)\n    return words", "    \n    var words = [String]()\n    \n    var\
    \ words = s.components(separatedBy: \",\")\n    \n    for word in words {\n  \
    \      words = words + word.components(separatedBy: \" \")\n    }\n    \n    return\
    \ words", "    \n    var array: [String] = []\n    \n    if let words: Array<String>\
    \ = s.components(separatedBy: \",\").flatMap({ $0.components(separatedBy: \" \"\
    ) }) {\n        array = words\n    }\n    \n    return array", '    return s.components(separatedBy:
    ",")', "    // split on space, comma, newline, return, tab\n    let words = s.components(separatedBy:\
    \ CharacterSet.init(charactersIn: \",;\\n\\r\\t\"))\n    return words", "    let\
    \ words = s.components(separatedBy: \" \")\n    return words.map{ $0.components(separatedBy:\
    \ \",\").map(String.init)}", "\tlet a = s.components(separatedBy: \" \")\n\tvar\
    \ a2 = Array(a!)\n\tvar a3 = Array()\n\tfor var i = 0; i < a.count; i++ {\n\t\t\
    a3.append(a2[i])\n\t}\n\treturn a3", "\treturn strings.Split(s, \",\")", "   \
    \ let arr = s.components(separatedBy: \", \")\n    return arr", "    words = s.components(separatedBy:\
    \ \",\")\n    return words", '    return s.componentsSeparatedByString(" ")',
  "    var words: [String] = []\n    var splits: String = \"\"\n    for char in s\
    \ {\n        splits += char + \",\"\n        if char == ',' {\n            splits\
    \ += \"\\\\s\"\n        }\n    }\n    splits += \"\\\\s\"\n    \n    let regex\
    \ = try! NSRegularExpression(pattern: \"^\" + splits, options: [])\n    for match\
    \ in regex.matchesInString(s, options: [], range: NSRange(location: 0, length:\
    \ s.characters.count)) {\n        words.append(s[Range(match.range, in: s)!])\n\
    \    }\n    return words", '    return strings.FieldsFunc(s, func(s string) bool
    { return s != "" && s != "\n" })', '    return s.split(separators: ",\\s*")',
  "\treturn s.split(\", \")", "    var words = [String]()\n    for c in s.unicodeScalars.reversed()\
    \ {\n        let word = [String]()\n        if c.isPlus || c.isComma {\n     \
    \       words.append(String(c.scalar))\n        } else {\n            word.extend(words_string(string(s:\
    \ c)))\n        }\n        words = word.reversed()\n    }\n    return words",
  "  return s.components(separatedBy: \",\", excludeExtras: true).map {\n    String($0)\n\
    \  }", '    return s.components(separatedBy: ", ").filter({ return !$0.isEmpty
    })', "    var words = s.split(separators: \",\", omittingEmptySubsequences: false)\n\
    \    if let lastWord = words.last {\n        words.append(lastWord)\n    }\n \
    \   return words", '    return s.components(separatedBy: CharacterSet(charactersIn:
    " "))', "\tvar a = s.componentsSeparatedByString(\" \")\n\tvar b = [String]()\n\
    \tfor var i = 0; i < a.count; i++ {\n\t\tif a.count < i {\n\t\t\tbreak\n\t\t}\n\
    \t\tlet a = a[i].componentsSeparatedByString(\",\")\n\t\tfor i in 0..<a.count\
    \ {\n\t\t\tb.append(a[i])\n\t\t}\n\t}\n\treturn b", "    if s == \"\" {\n    \
    \    return []\n    }\n    let strings = s.components(separatedBy: \",\")\n  \
    \  let words1 = strings.flatMap { $0.components(separatedBy: \" \") }\n    let\
    \ words2 = words1.flatMap { $0.components(separatedBy: \" \") }\n    return words2",
  "\treturn strings.Split(s, \", \")", "    let words: [String]\n\n    switch s.count\
    \ {\n    case 0:\n        words = []\n    case 1:\n        words = [s.split(separator:\
    \ \",\")]\n    case 2:\n        words = [s.split(separator: \",\")] + [\"and\"\
    ]\n    case 3:\n        words = [s.split(separator: \",\")] + [\"and\", s.split(separator:\
    \ \" \")[s.split(separator: \",\").count - 1]]\n    default:\n        let sep\
    \ = s.substring(from: s.index(s.endIndex, offsetBy: 1))\n        words = [s.split(separator:\
    \ sep)] + [s.split(separator: \" \")[s.split(separator: \",\").count - 1], \"\
    and\", s.split(separator: sep)[s.split(separator: \",\").count - 1]]\n    }\n\n\
    \    return words", '  return s.componentsSeparatedByString(" ")', "    let chars\
    \ = s.characters()\n    var words = Array<String>()\n\n    for char in chars {\n\
    \        let word = String(char)\n        if word != \",\" && word != \" \" {\n\
    \            words.append(word)\n        }\n    }\n\n    return words", "    guard\
    \ let str = s.split(separator: \",\", maxSplits: -1) else { return [\"\"] }\n\
    \    return str.map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }", " \
    \   return s.components(separatedBy: \", \").flatMap { str -> [String] in\n  \
    \      return str.components(separatedBy: \" \")\n    }", "    var words: [String]\
    \ = []\n    s.characters.split(separator: \",\", omittingEmptySubsequences: false).forEach\
    \ {\n        words.append(String($0))\n    }\n    return words", "    var words\
    \ = [String]()\n    s = s.trimmingCharacters(in: CharacterSet.whitespaces)\n \
    \   var i = 0\n    var j = s.startIndex\n\n    while i < s.endIndex {\n      \
    \  var k = j\n        if s[i] == ',' || s[i] == ' ' {\n            j = s.index(after:\
    \ j)\n            words.append(String(s[j...]))\n            i = k\n        }\
    \ else {\n            j = s.index(after: j)\n        }\n    }\n    words.append(String(j...))\n\
    \    return words", "    var words = [String]()\n    var words = s.components(separatedBy:\
    \ \",\")\n    for word in words {\n        let words = word.components(separatedBy:\
    \ \" \")\n        words = words.joined(separator: \" \")\n        words.append(\"\
    \ \")\n        words = words.joined(separator: \" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        words.append(\"\
    \ \")\n        words.append(\" \")\n        words.append(\" \")\n        word",
  "    // Split each string separated by a comma or a space.\n    return split(s,\
    \ \", \")", '    return s.components(separatedBy: ",")', '    // Good luck!',
  '    return s.components(separatedBy: ",")', '    return s.components(separatedBy:
    ",")', "    var words: [String] = []\n    if s == \"\" {\n        return words\n\
    \    }\n    let items = s.componentsSeparatedByString(\" \")\n    for item in\
    \ items {\n        words.append(item)\n    }\n    return words", "\tlet splitter\
    \ = CharacterSet.whitespacesAndNewlines\n\tlet delimiter = \",\"\n\tlet components\
    \ = s.components(separatedBy: splitter)\n\tlet delimiters = components.map({ String(describing:\
    \ $0) })\n\treturn delimiters.map { String($0) }", "    let words = s.componentsSeparatedByString(\"\
    \ \")\n    return words", '    return s.characters.split(", ").map(String.init)',
  "    // TODO: Modify the code below to return a list of strings. Use split\n   \
    \ // string method to convert comma separated string to an array of strings.\n\
    \    // If your solution uses map function, then modify it to use map function.\n\
    \    let words = s.components(separatedBy: \",\")\n    return words", "\treturn\
    \ s.tokenize(\", \")", '    return s.characters.split { $0 == "," || $0 == " "
    }.map { String($0) }', '    return s.components(separatedBy: ",")', "    \n  \
    \  return s.componentsSeparatedByString(\" \")", '    return s.components(separatedBy:
    ",".unicodeScalars).flatMap(String.init)', "\treturn strings.Split(s, \", \")",
  '    return s.components(separatedBy: ",")', '    return s.components(separatedBy:
    ",").map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }', '    return
    s.componentsSeparatedByString(" ")', '    return s.components(separatedBy: ",
    ")', '    return s.components(separatedBy: ",")', "\tlet words: [String] = s.components(separatedBy:\
    \ CharacterSet.whitespacesAndNewlines)\n\treturn words", '    return s.components(separatedBy:
    ",".unicodeScalars)', '    return s.components(separatedBy: CharacterSet.whitespaces)',
  "    guard let inputString = s.data(using: .utf8) else { return [] }\n    let words\
    \ = inputString.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \    return words.map(String.init)", "\treturn split(s, \",\")", "    guard !s.isEmpty\
    \ else { return [] }\n    var words = s.characters\n    var newWords = [String]()\n\
    \    var lastWord: String = \"\"\n    var word: String = String()\n    var nextWord:\
    \ String = \"\"\n    var startIndex = 0\n    while startIndex < words.count {\n\
    \        word = String(words[startIndex])\n        if lastWord.isEmpty {\n   \
    \         newWords.append(word)\n            startIndex += 1\n        } else {\n\
    \            if lastWord != word {\n                newWords.append(lastWord)\n\
    \                lastWord = word\n            }\n            nextWord = String(words[startIndex])\n\
    \            newWords.append(nextWord)\n            startIndex += 1\n        }\n\
    \    }\n    if lastWord.isEmpty {\n        newWords.append(String(words[startIndex]))\n\
    \    }\n    return newWords", "    words = split(s, \",\", false)\n    return\
    \ words", "    let wordRanges: [Range<String.Index>] = s.characters.enumerate().map({\
    \ (index, char) -> Range<String.Index> in\n        let index = index(of: char,\
    \ in: s)!\n        return index..<index\n    })\n    let words = compactMap(wordRanges,\
    \ { s[$0] })\n    return words", "    let words = s.components(separatedBy: CharacterSet.whitespacesAndNewlines)\n\
    \        .filter({!$0.isWhitespace && $0 != \",\"})\n        .filter({!$0.isWhitespace\
    \ && $0 != \"\\n\"})\n        .map({$0.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)})\n\
    \    return words", "    // Split on the string '|', and remove the empty string\
    \ at the end.\n    return s.components(separatedBy: \"|\").dropLast()", "    \n\
    \    // BEGIN PT-SOURCE: words_string\n    // Create a regular expression that\
    \ matches an optional trailing period.\n    // It matches zero or one periods\
    \ in the string.\n    \n    let trailing_period_regex = \"\\\\.?\"\n    \n   \
    \ // Create a regular expression that matches a sequence of non-white-space characters\
    \ that\n    // optionally contains a period.\n    // It matches zero or more characters\
    \ that optionally contain a period.\n    \n    let optionalPeriodRegex = \"[^\\\
    \\s\\\\.]+\"\n    \n    // Create a regular expression that matches any sequence\
    \ of non-white-space characters\n    // that optionally begins with an uppercase\
    \ letter and continues with zero or more\n    // non-white-space characters that\
    \ optionally contains a period.\n    \n    let optionalUppercaseLetterRegex =\
    \ \"[A-Z]+[^\\\\s\\\\.]+\"\n    \n    // Create a regular expression that matches\
    \ any sequence of non-white-space characters that\n    // optionally begins with\
    \ an uppercase letter and continues with zero or more\n    // non-white-space\
    \ characters that optionally contains a period, comma, question mark,\n    //\
    \ exclamation point, or underscore.\n    \n    let optionalUppercaseLetterWithPeriodRegex\
    \ = \"[A-Z]+[^\\\\s\\\\.,?_]+\"\n    \n    // The string \"\\\\W\" matches a non-word\
    \ character.\n    // It matches any character that is not a-z, A-Z, 0-9, or a\
    \ period.\n    // If this regular expression matches a character in the string,\
    \ the next expression will\n    // match that same character, and so on.\n   \
    \ \n    let nonWordRegex = \"\\\\W+\"\n    \n    // The string \"\\\\w+\" matches\
    \ a word character\n    // It matches any character that is a letter, digit, underscore,\
    \ or period.\n    \n    let wordRegex = \"\\\\w+\"\n    \n    // Create an array\
    \ of words from a string separated by commas or spaces.\n    // It matches any\
    \ sequence of characters separated by a comma or space\n    // that begins with\
    \ an uppercase letter and continues with zero or more characters\n    // that\
    \ optionally contains a period.\n    \n    let wordArray = s.components(separatedBy:\
    \ \",?\\\\s*\")\n    \n    // Remove all periods from each word in the array.\n\
    \    // It removes periods from the beginning and end of a word.\n    \n    for\
    \ word in wordArray {\n        word.replaceOccurrences(of: \"\\\\.\", with: \"\
    \", options: .regularExpression, range: nil)\n    }\n    \n    // Split each word\
    \ in the array into an array of non-whitespace, non-period, non-letter\n    //\
    \ characters that does not include the period, comma, exclamation point, or underscore.\n\
    \    \n    let wordArrayWithoutPeriods = wordArray.map { (word: String", "   \
    \ var words = s.componentsSeparatedByString(\" \")\n    words = [String](words.map\
    \ { $0.stringByTrimmingCharactersInSet(.whitespaceCharacters) })\n    return words",
  '    // your code here', '    return s.components(separatedBy: ",")', "    let mut\
    \ words = s.characters.split(separator: \",\").map(String::init)\n    let mut\
    \ words = words.filter(!{\n        !$0.isBlank\n    })\n    words = words.filter(!{\n\
    \        !$0.isWhitespace\n    })\n    words.reserveCapacity(words.count)\n  \
    \  return words", '    return s.components(separatedBy: ",")', "    // BEGIN Practice:\n\
    \    // Split words by space, then by comma.\n    let arr = [s.components(separatedBy:\
    \ \" \"), s.components(separatedBy: \", \")]\n    return arr\n    // END Practice",
  "\tvar arr: [String] = []\n\tfor word in s.split(separator: \" \") {\n\t\tarr.append(word)\n\
    \t}\n\treturn arr", "    if s == \"\" {\n        return []\n    }\n    var words\
    \ = s.characters\n    var result = [String]()\n    var lastWord = \"\"\n    var\
    \ lastWordIndex = -1\n    for index in 0..<s.characters.count {\n        let char\
    \ = s[index] // Take a character in the string s\n        if char == \",\" ||\
    \ char == \" \" {\n            words.append(lastWord)\n            result.append(lastWord)\n\
    \            lastWord = \"\"\n            lastWordIndex = index\n        } else\
    \ if char == \".\" || char == \"!\" || char == \"?\" {\n            words.append(lastWord)\n\
    \            lastWord = \"\"\n            lastWordIndex = index\n        } else\
    \ {\n            lastWord += String(char)\n        }\n    }\n    words.append(lastWord)\n\
    \    result.append(lastWord)\n    return result", '    return s.components(separatedBy:
    ",").map(String.init)', "    var splitStrings = s\n    let delimiter = \", \"\n\
    \    var components: [String] = []\n    var component = \"\"\n    var word = \"\
    \"\n    var words = [:]\n\n    while splitStrings.characters.count > 0 {\n   \
    \     component = splitStrings.characters.prefix(delimiter)\n        splitStrings\
    \ = splitStrings.substring(component!.characters.count)\n\n        if component.isEmpty\
    \ {\n            words[component!] = word\n            components.append(component!)\n\
    \            word = \"\"\n            continue\n        }\n\n        word += component!\
    \ + \",\"\n    }\n\n    for component in components {\n        if let value =\
    \ words[component] {\n            words[component] = nil\n            words[value]\
    \ = nil\n        }\n    }\n\n    return components.flatMap { $0 }", "    let split\
    \ = s.componentsSeparatedByString(\", \")\n    return split", "    var words =\
    \ s.components(separatedBy: \",\")\n    return words.map(String.init)", "\treturn\
    \ s.componentsSeparatedByString(\" \")", "    var words = s.componentsSeparatedByString(\"\
    \ \")\n    words.removeFirst()\n    return words", '    return s.split(separator:
    ",").map(String.init)', '    return s.components(separatedBy: ",")', "    // Split\
    \ on white space and comma\n    let wordsArray = s.components(separatedBy: \"\
    \ ,\").map { String($0) }\n    return wordsArray", '  return s.characters.split(separator:
    ",", maxSplit: Int.max, omittingEmptySubsequences: false)', '    return s.components(separatedBy:
    ",")', "    // Split on commas.\n    let words = s.components(separatedBy: \"\
    ,\")\n    return words", "    var result = [String]()\n    for word in s.split(separators:\
    \ \",\".unicodeScalars) {\n        result.insert(word, at: 0)\n    }\n    return\
    \ result", "\treturn split(s, \", \")", "\tlet words: [String] = []\n\tlet word:\
    \ String = \"\"\n\tlet words = s.characters.split{$0 == \",\"}\n\t\n\tfor w in\
    \ words {\n\t\tword += w\n\t\tif w == \"\\n\" {\n\t\t\twords.append(word)\n\t\t\
    \tword = \"\"\n\t\t}\n\t}\n\t\n\twords.append(word)\n\t\n\treturn words", '    return
    split(s.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines))', "    var\
    \ words: [String] = []\n    var current: String = \"\"\n    for letter in s {\n\
    \        current = letter\n        if letter == \" \" {\n            words.append(current)\n\
    \            current = \"\"\n        }\n    }\n    if current != \"\" {\n    \
    \    words.append(current)\n    }\n    return words", '    return s.componentsSeparatedByString("
    ")', "    guard let wordArray = s.components(separatedBy: \",\") else {\n    \
    \    return []\n    }\n    return wordArray", "    // Split string s into words\n\
    \    return s.components(separatedBy: \", \")", "\treturn tokenize(stringToArray(s))",
  "    var words: [String] = []\n    for word in s.split(separator: \",\").map(String.init)\
    \ {\n        words.append(String(word))\n    }\n    return words", "    // split\
    \ on comma and remove leading and trailing space\n    let words = s.componentsSeparatedByString(\"\
    , \").map { $0.trimmingCharacters(in: .whitespaces) }\n    // map to array of\
    \ strings\n    return words.map { String($0) }"]
stop_tokens:
- "\n}"
