name: HumanEval_156_int_to_mini_roman
language: swift
prompt: "\n/// Given a positive integer, obtain its roman numeral equivalent as a\
  \ string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
  /// Examples:\n/// >>> int_to_mini_roman(number: 19)\n/// \"xix\"\n/// >>> int_to_mini_roman(number:\
  \ 152)\n/// \"clii\"\n/// >>> int_to_mini_roman(number: 426)\n/// \"cdxxvi\"\nfunc\
  \ int_to_mini_roman(number: Int) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\"\
  )\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
  \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
  \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
  \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
  \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
  \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
  \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
completions: ["    guard number > 0 else { return \"\" }\n    guard number < 1000\
    \ else { return \"\" }\n    var roman = \"\"\n    for _ in 0..number {\n     \
    \   let value = number % 1000\n        let index = value / 100\n        roman\
    \ = (value % 100) + roman + mini_roman[index]\n        number = (number - value)\
    \ / 100\n    }\n    return roman.lowercased()", "    let strings = int_to_string(number:\
    \ number)\n    let result = strings.reduce(\"\") { $0 + mini_roman_to_string(character:\
    \ $1) + $2 }\n    guard result.count == 2 else result", "    let letters = [\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\",\n        \"L\", \"XL\", \"XC\",\
    \ \"C\", \"CD\",\n        \"M\", \"MM\", \"MN\", \"MU\", \"Y\",\n        \"K\"\
    , \"KK\", \"KM\", \"KD\", \"CM\",\n        \"G\", \"GG\", \"NG\", \"NG\", \"NG\"\
    , \"NG\",\n        \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\",\n        \"\
    S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\",\n        \"I\"\n    ]\n    let\
    \ digits = [\n        \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\"\
    , \"six\", \"seven\", \"eight\", \"nine\"\n    ]\n    let tens = [\n        \"\
    ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"\
    eighty\", \"ninety\"\n    ]\n    let units: [String] = [\"V\", \"IV\", \"I\"]\n\
    \    let thousands = [\n        \"thousand\", \"million\", \"billion\", \"trillion\"\
    , \"quadrillion\", \"quintillion\",\n        \"sextillion\", \"septillion\", \"\
    octillion\", \"nonillion\", \"decillion\", \"undecillion\",\n        \"duodecillion\"\
    \n    ]\n    var string = \"\"\n    var letter = 0\n    var digit = 0\n    var\
    \ ten = 0\n    var unit = 0\n    var thousand = 0\n    var digits: [String] =\
    \ [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\"\
    , \"eight\", \"nine\"]\n    if number < 1000 {\n        return String(number)\n\
    \    } else {\n        let index = Int(number / 1000)\n        digit = number\
    \ % 1000\n        let hundreds = String(String(String(index).characters.dropLast().reduce(\"\
    \", combine: \"\")))\n        if hundreds.isEmpty {\n            hundreds = \"\
    0\"\n        }\n        thousand = String(String(String(String(hundreds).characters.dropLast().reduce(\"\
    \", combine: \"\")))\n        if thousand.isEmpty {\n            thousand = \"\
    0\"\n        }\n        letter = String(String(String(String(String(index).characters.dropLast().reduce(\"\
    \", combine: \"\")))\n            .characters.dropLast().reduce(\"\", combine:\
    \ \"\"))\n        if letter.isEmpty {\n            letter = \"0\"\n        }\n\
    \        index = Int(number / 100)\n        digit = number % 100\n        let\
    \ tens = String(String(String(String(index).characters.dropLast().reduce(\"\"\
    , combine: \"\")))\n            .characters.dropLast().reduce(\"\", combine: \"\
    \"))\n        if tens.isEmpty {\n            tens = \"0\"\n        }\n       \
    \ unit = ", "    guard number >= 1 && number <= 1000 else {\n        throw IllegalArgumentException()\n\
    \    }\n    let miniRoman: String =\n        miniRomanRepresentation[number %\
    \ 1000].map { Character($0) }.joined()\n    return miniRoman.lowercased()", " \
    \   var mini_roman = \"\"\n    var roman_numerals = [String]()\n    for n in 1...number\
    \ {\n        roman_numerals.append(mini_roman)\n        mini_roman = \"\"\n  \
    \      for m in 1...n {\n            mini_roman += \"m\" // we start at 1 because\
    \ the first roman numeral is \"m\"\n        }\n    }\n    return mini_roman",
  "    if number < 1 || number > 1000 {\n        throw PythonError(\n            \"\
    int_to_mini_roman() expects 1 <= num <= 1000, not \\(number)\",\n        )\n \
    \   }\n\n    let roman_digits = Array(\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\"\
    , \"XC\", \"C\", \"CXX\", \"CXXX\", \"CD\", \"D\", \"DC\",\n        \"DCC\", \"\
    DCCC\", \"CM\", \"M\", \"MM\", \"MMM\",\n    )\n\n    let roman_numeral = Array(\n\
    \        \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\"\
    , \"IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\"\
    , \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXIX\"\
    ,\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", \"C\", \"CXX\", \"\
    CXXX\", \"CD\", \"D\", \"DC\",\n        \"DCC\", \"DCCC\", \"CM\", \"M\", \"MM\"\
    , \"MMM\",\n    )\n\n    let mut result: String = \"\"\n\n    if number <= 500\
    \ {\n        result = roman_numeral[number]\n    } else {\n        let first_half\
    \ = number / 1000\n        let second_half = number % 1000\n\n        let first_half_result\
    \ = roman_digits[first_half]\n        let second_half_result = roman_digits[second_half]\n\
    \n        if number >= 1000 && number < 1000000 {\n            result = first_half_result\
    \ + second_half_result\n        } else {\n            result = first_half_result\
    \ + second_half_result + \"M\"\n        }\n    }\n\n    return result", "    var\
    \ roman = \"\"\n    let n = number\n    // check for a negative number\n    if\
    \ n < 0 {\n        roman = \"-\"\n        n = -n\n    }\n    // base cases\n \
    \   if n == 0 { return \"0\" }\n    if n == 1 { return \"i\" }\n    // roman =\
    \ (n//(10**i)) * \"M\" where M is 1000 or 999\n    let powers = (0..<Int32(log10(Double(n)))).map\
    \ { Int(pow(10.0, $0)) }\n    let i = powers.index(of: Int32(log10(Double(n))))\
    \ + 1\n    roman += String((n%10).map(String.init)).joined(separator: \"\")\n\
    \    switch i {\n    case 0: roman = \"i\"\n    case 1: roman = \"v\"\n    case\
    \ 2: roman = \"vi\"\n    case 3: roman = \"vii\"\n    case 4: roman = \"viii\"\
    \n    case 5: roman = \"ix\"\n    case 6: roman = \"x\"\n    case 7: roman = \"\
    ix\"\n    case 8: roman = \"x\"\n    case 9: roman = \"l\"\n    case 10: roman\
    \ = \"l\"\n    case 11: roman = \"li\"\n    case 12: roman = \"l\"\n    case 13:\
    \ roman = \"l\"\n    case 14: roman = \"l\"\n    case 15: roman = \"xl\"\n   \
    \ case 16: roman = \"l\"\n    case 17: roman = \"l\"\n    case 18: roman = \"\
    l\"\n    case 19: roman = \"l\"\n    case 20: roman = \"l\"\n    case 21: roman\
    \ = \"xl\"\n    case 22: roman = \"l\"\n    case 23: roman = \"l\"\n    case 24:\
    \ roman = \"l\"\n    case 25: roman = \"l\"\n    case 26: roman = \"l\"\n    case\
    \ 27: roman = \"l\"\n    case 28: roman = \"l\"\n    case 29: roman = \"l\"\n\
    \    case 30: roman = \"l\"\n    case 31: roman = \"l\"\n    case 32: roman =\
    \ \"l\"\n    case 33: roman = \"l\"\n    case 34: roman = \"l\"\n    case 35:\
    \ roman = \"l\"\n    case 36: roman = \"l\"\n    case 37: roman = \"l\"\n    case\
    \ 38: roman = \"l\"\n    case 39: roman = \"l\"\n    case 40: roman = \"l\"\n\
    \    case 41: roman = \"l\"\n    case 42", "    var str = String()\n    var i\
    \ = Int(number)\n    while i >= 100 {\n        i /= 100\n        str += \"M\"\n\
    \    }\n    while i >= 1000 {\n        i /= 1000\n        str += \"CM\"\n    }\n\
    \    while i >= 900 {\n        i /= 900\n        str += \"D\"\n    }\n    while\
    \ i >= 500 {\n        i /= 500\n        str += \"CD\"\n    }\n    while i >= 400\
    \ {\n        i /= 400\n        str += \"C\"\n    }\n    while i >= 100 {\n   \
    \     i /= 100\n        str += \"XC\"\n    }\n    while i >= 90 {\n        i /=\
    \ 90\n        str += \"L\"\n    }\n    while i >= 50 {\n        i /= 50\n    \
    \    str += \"XL\"\n    }\n    while i >= 40 {\n        i /= 40\n        str +=\
    \ \"X\"\n    }\n    while i >= 9 {\n        i /= 9\n        str += \"IX\"\n  \
    \  }\n    while i >= 5 {\n        i /= 5\n        str += \"V\"\n    }\n    while\
    \ i >= 40 {\n        i /= 40\n        str += \"IV\"\n    }\n    while i >= 9 {\n\
    \        i /= 9\n        str += \"I\"\n    }\n    while i >= 5 {\n        i /=\
    \ 5\n        str += \"I\"\n    }\n    while i >= 40 {\n        i /= 40\n     \
    \   str += \"I\"\n    }\n    while i >= 9 {\n        i /= 9\n        str += \"\
    I\"\n    }\n    while i >= 5 {\n        i /= 5\n        str += \"I\"\n    }\n\
    \    while i >= 40 {\n        i /= 40\n        str += \"I\"\n    }\n    while\
    \ i >= 9 {\n        i /= 9\n        str += \"I\"\n    }\n    while i >= 5 {\n\
    \        i /= 5\n        str += \"I\"\n    }\n    while i >= 40 {\n        i /=\
    \ 40\n        str += \"I\"\n    }\n    while i >= 9 {\n        i /= 9\n      \
    \  str += \"I\"\n    }\n    while i >= 5 {\n        i /= 5\n        str += \"\
    I\"\n    }\n    while i >= 40 {\n        i /= 40\n        str += \"I\"\n    }\n\
    \    while i >= 9 {\n        i /= 9\n        str += \"I\"\n    }\n    while i\
    \ >= 5 {\n        i /= 5\n        str += \"I\"\n    }\n    while i >= 40 {\n \
    \       i /= 40\n        str += \"I\"\n    }\n    while i >= 9 {\n        i /=\
    \ 9\n        str += \"I\"", "    var result = \"\"\n    func addDigit(number :\
    \ Int, num : Int) {\n        let newNumber = number + num\n        if (newNumber\
    \ >= 1000) {\n            result += mini_roman[newNumber / 1000]\n           \
    \ addDigit(newNumber % 1000, 1000)\n        } else {\n            result += mini_roman[newNumber]\n\
    \        }\n    }\n    addDigit(number, 1)\n    return result", "    switch number\
    \ {\n    case 1:\n        return \"x\"\n    case 5:\n        return \"v\"\n  \
    \  case 10:\n        return \"l\"\n    case 20:\n        return \"xl\"\n    case\
    \ 50:\n        return \"lb\"\n    case 100:\n        return \"c\"\n    case 200:\n\
    \        return \"cc\"\n    case 500:\n        return \"cd\"\n    case 1000:\n\
    \        return \"cm\"\n    case 10000:\n        return \"d\"\n    case 100000:\n\
    \        return \"dc\"\n    case 1000000:\n        return \"cm\"\n    case 1000000000:\n\
    \        return \"d\"\n    case 1000000000000:\n        return \"d\"\n    case\
    \ 100000000000000:\n        return \"dc\"\n    case 1000000000000000000:\n   \
    \     return \"d\"\n    default:\n        var romanString = \"\"\n        var\
    \ onesCount = 0\n        var tensCount = 0\n        var hundredsCount = 0\n  \
    \      var thousandsCount = 0\n        var romanNum = number\n        while romanNum\
    \ > 0 {\n            let digit = romanNum % 100\n            romanNum = romanNum\
    \ / 100\n            onesCount += 1\n            if digit > 0 {\n            \
    \    tensCount += 1\n                if digit > 1 && digit < 5 && tensCount >\
    \ 1 {\n                    romanString += \"m\"\n                    onesCount\
    \ = 0\n                    tensCount = 0\n                }\n            }\n \
    \           if digit > 0 && digit < 5 && tensCount == 1 {\n                romanString\
    \ += \"c\"\n                onesCount = 0\n                tensCount = 0\n   \
    \         }\n            if digit > 5 && digit < 10 && tensCount > 0 {\n     \
    \           romanString += \"x\"\n                onesCount = 0\n            \
    \    tensCount = 0\n            }\n            if digit > 10 && digit < 20 &&\
    \ tensCount == 0 {\n                romanString += \"l\"\n                onesCount\
    \ = 0\n                tensCount = 0\n            }\n            if digit > 20\
    \ && digit < 30 && tensCount > 1 {\n                romanString += \"xl\"\n  \
    \              onesCount = 0\n                tensCount = 0\n            }\n \
    \           if digit > 30 && digit < 40 && tensCount == 2 {\n                romanString\
    \ += \"lb\"\n                onesCount = 0\n                tensCount = 0\n  \
    \          }\n            if digit > 40 && digit < 50 && tensCount == 1 {\n  \
    \              romanString += \"c\"\n                onesCount = 0\n         \
    \       tensCount = 0\n            }\n            if digit > 50 && digit < 60\
    \ && tensCount == 1 {\n                romanString += \"cc\"\n               \
    \ onesCount = 0\n                tensCount = 0\n            }\n            if\
    \ digit > 6", "    var roman = \"\"\n    var remainder = 0\n\n    for _ in 1...number\
    \ {\n        remainder = (number / 10) % 10\n        roman = roman.characters.last!\
    \ + String(repeating: \"X\", count: (10 - remainder))\n        number -= 10\n\
    \    }\n\n    return roman.lowercased()", "    let romanNumerals: [String] = [\"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\
    , \"xi\", \"xii\", \"xiv\", \"xix\"]\n    let numeral = Int(number) % 100\n  \
    \  return romanNumerals[numeral]", "    if number <= 1000 {\n        let roman:\
    \ String.Index = number.map { IntToRoman($0) }\n        return roman.dropLast().lowercased()\n\
    \    }\n    return \"\"", "    let roman = String(\n        charactersIn: String(number).unicodeScalars\n\
    \            .filter { $0.isASCII }\n            .sorted()\n            .reversed()\n\
    \            .reduce(\"i\", { $0 + String($1).unicodeScalars.first }))\n    return\
    \ roman", "    // Get number of digits\n    let numberOfDigits = Int(log10(Double(number)))\
    \ + 1 // +1 for decimals\n\n    // Prepare the return value\n    var ret = String()\n\
    \n    // Calculate the roman\n    for _ in 0..<numberOfDigits {\n        // Find\
    \ the largest multiple of 5 that is smaller than the number\n        let largest_five_digit_roman\
    \ = roman(Int((number / 5) * 5 + 5))\n        // If the current digit is less\
    \ than the largest multiple of 5\n        // then decrease number by that digit\n\
    \        if number < Int(largest_five_digit_roman) {\n            number -= Int(largest_five_digit_roman)\n\
    \        } else {\n            // Append the roman of the number\n           \
    \ ret += String(largest_five_digit_roman)\n            break // Break the loop\n\
    \        }\n    }\n\n    // Return result as a lowercased string\n    return ret.lowercased()",
  "    var roman = String()\n    for _ in 1...4 {\n        if number >= 1000 { break\
    \ }\n        var remainder = number % 1000\n        var digits = (remainder *\
    \ 1000).truncatingRemainder(dividingBy: 1000)\n        roman = roman.prefix(roman.characters.count\
    \ + digits)\n        number = number - remainder\n    }\n    roman = roman.prefix(roman.characters.count\
    \ + number)\n    return roman.lowercased()", '    return number_to_mini_roman(number,
    1)', "    let romanNumerals = [\n        \"M\",\n        \"CM\",\n        \"D\"\
    ,\n        \"CD\",\n        \"C\",\n        \"XC\",\n        \"L\",\n        \"\
    XL\",\n        \"X\",\n        \"IX\",\n        \"V\",\n        \"IV\",\n    \
    \    \"I\"\n    ]\n\n    // Convert input number to array of digits\n    let digits\
    \ = String(number).characters.map { Int($0) }\n\n    // Get the length of each\
    \ array element\n    let digitLengths = digits.map { $0.count }\n\n    // If no\
    \ digits were passed in, return an empty string\n    guard digitLengths.count\
    \ == 0 else { return \"\" }\n\n    // Create a mutable array to store output string\n\
    \    var output = [String]()\n\n    // Iterate through each digit in the input\
    \ number\n    for index in 0..<digitLengths.count {\n        // If the current\
    \ digit has a length of 1 (i.e. a single digit), append it to our output array\n\
    \        if digitLengths[index] == 1 {\n            output.append(romanNumerals[index])\n\
    \        // Else, we need to calculate how many Roman numerals are required to\
    \ obtain the input digit\n        // We know that a single Roman numeral is required\
    \ to be in the output array if its length is 1, or 0 otherwise\n        } else\
    \ {\n            // Get the Roman numeral equivalent of the input digit\n    \
    \        let numeral = romanNumerals[index] + (digits[index] - Int(digits[index]))\
    \ * Int(digitLengths[index])\n\n            // If the Roman numeral length is\
    \ 0, append a 0 to the output array\n            if numeral.count == 0 {\n   \
    \             output.append(0)\n            // Else, we append the Roman numeral\
    \ to our output array\n            } else {\n                output.append(numeral)\n\
    \            }\n        }\n    }\n\n    // We need to append a final 0 to our\
    \ output array if a 0 was appended to the Roman numeral above\n    if output.count\
    \ == 0 {\n        output.append(0)\n    }\n\n    return String(output)", "  let\
    \ mini_roman = MiniRomanNumerals()\n\n  let roman = mini_roman.romans[number %\
    \ 1000]\n\n  let rest = number % 100\n\n  if rest == 100 {\n    return roman.lowercased()\n\
    \  } else if rest == 500 {\n    let twos = mini_roman.romans[rest] as String\n\
    \n    return twos + roman.lowercased()\n  } else {\n    let num = (rest / 100)\
    \ as String\n\n    let hundred = mini_roman.romans[rest%100] as String\n\n   \
    \ return num + hundred + roman.lowercased()\n  }", "  let romanNumerals = [\n\
    \    \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\
    , \"x\", \"xi\",\n    \"xii\", \"xiii\", \"xiv\", \"xv\", \"xvi\", \"xvii\", \"\
    xviii\", \"xix\", \"xx\",\n    \"xxi\", \"xxii\", \"xxiii\", \"xxiv\", \"xxv\"\
    , \"xxvi\", \"xxvii\", \"xxviii\",\n    \"xxix\", \"xxx\", \"xxxx\", \"xxxxi\"\
    , \"xxxxii\", \"xxxxiii\", \"xxxxiv\", \"xxxxv\",\n    \"xxxxvi\", \"xxxxvii\"\
    , \"xxxxviii\", \"xxxxix\", \"xxxxx\", \"xxxxxi\", \"xxxxxii\",\n    \"xxxxxiii\"\
    , \"xxxxxiv\", \"xxxxxv\", \"xxxxxvi\", \"xxxxxvii\", \"xxxxxviii\",\n    \"xxxxix\"\
    , \"xxxxx\", \"xxxxxi\", \"xxxxxii\", \"xxxxxiii\", \"xxxxxiv\", \"xxxxxv\",\n\
    \    \"xxxxxvi\", \"xxxxxvii\", \"xxxxxviii\", \"xxxxix\", \"xxxxx\", \"xxxxxi\"\
    , \"xxxxxii\",\n    \"xxxxxiii\", \"xxxxxiv\", \"xxxxxv\", \"xxxxxvi\", \"xxxxxvii\"\
    , \"xxxxxviii\",\n    \"xxxxix\", \"xxxxx\", \"xxxxxi\", \"xxxxxii\", \"xxxxxiii\"\
    , \"xxxxxiv\", \"xxxxxv\",\n    \"xxxxxvi\", \"xxxxxvii\", \"xxxxxviii\", \"xxxxix\"\
    , \"xxxxx\", \"xxxxxi\", \"xxxxxii\",\n    \"xxxxxiii\", \"xxxxxiv\", \"xxxxxv\"\
    , \"xxxxxvi\", \"xxxxxvii\", \"xxxxxviii\",\n    \"xxxxix\", \"xxxxx\", \"xxxxxi\"\
    , \"xxxxxii\", \"xxxxxiii\", \"xxxxxiv\", \"xxxxxv\",\n    \"xxxxxvi\", \"xxxxxvii\"\
    , \"xxxxxviii\", \"xxxxix\", \"xxxxx\", \"xxxxxi\", \"xxxxxii\",\n    \"xxxxxiii\"\
    , \"xxxxxiv\", \"xxxxxv\", \"xxxxxvi\", \"xxxxxvii\", \"xxxxxviii\",\n    \"xxxxix\"\
    , \"xxxxx\", \"xxxxxi\", \"xxxxxii\", \"xxxxxiii\", \"xxxxxiv\", \"xxxxxv\",\n\
    \    \"xxxxxvi\", \"xxxxxvii\", \"xxxxxviii\", \"xxxxix\", \"xxxxx\", \"xxxxxi\"\
    , \"xxxxxii\",\n    \"xxxxxiii\", \"xxxxxiv\", \"xxxxxv\", \"xxxxxvi\", \"xxxxxvii\"\
    , \"xxxxxviii\",\n    \"xxxxix\", \"xxxxx\", \"xxxxxi\", \"xxxxxii\", \"xxxxxiii\"\
    , \"xxxxxiv\", \"xxxxxv\",", "    guard number <= 1000 else {\n        return\
    \ String(number)\n    }\n\n    var roman = \"\"\n    var num = 0\n    while number\
    \ > 0 {\n        guard number >= 1000 else {\n            return String(number)\n\
    \        }\n        roman = String(number % 1000) + (roman == \"\" ? \"\" : roman)\n\
    \        number /= 1000\n    }\n    guard let lastChar = roman.last,\n       \
    \ lastChar == roman.first else {\n        return roman\n    }\n    roman = String(lastChar)\
    \ + roman.suffix(2)\n    return roman", '    return mini_romans[number]', "  \
    \  let roman = mini_roman\n    let romandum = mini_roman[Int(number)-2]\n    let\
    \ romandam = mini_roman[Int(number)-1]\n    \n    var miniRoman = \"\"\n    \n\
    \    if number >= 100 {\n        miniRoman = \"cdxxvi\"[Int(number)-100]\n   \
    \ } else if number >= 90 {\n        miniRoman = \"cdvi\"[Int(number)-90]\n   \
    \ } else if number >= 80 {\n        miniRoman = \"cvi\"[Int(number)-80]\n    }\
    \ else if number >= 70 {\n        miniRoman = \"vi\"[Int(number)-70]\n    } else\
    \ if number >= 60 {\n        miniRoman = \"ix\"[Int(number)-60]\n    } else if\
    \ number >= 50 {\n        miniRoman = \"x\"[Int(number)-50]\n    } else if number\
    \ >= 40 {\n        miniRoman = \"l\"[Int(number)-40]\n    } else if number >=\
    \ 30 {\n        miniRoman = \"c\"[Int(number)-30]\n    } else if number >= 20\
    \ {\n        miniRoman = \"m\"[Int(number)-20]\n    } else if number >= 10 {\n\
    \        miniRoman = \"d\"[Int(number)-10]\n    }\n    \n    return miniRoman",
  "    let roman = StringBuilder(\"\")\n    let numeral = Int64(number)\n    var i\
    \ = Int64(numeral)\n    while i < Int64(1001) {\n        if i < 10 {\n       \
    \     roman.append(\"x\")\n        }\n        roman.append(\"cm\")\n        i\
    \ += 1\n    }\n    while i < Int64(1000 * 1000) {\n        if i < 100 {\n    \
    \        roman.append(\"d\")\n        }\n        roman.append(\"cd\")\n      \
    \  i += 1\n    }\n    while i < Int64(1000 * 1000 * 1000) {\n        if i < 1000\
    \ {\n            roman.append(\"l\")\n        }\n        roman.append(\"xl\")\n\
    \        i += 1\n    }\n    while i < Int64(1000 * 1000 * 1000 * 1000) {\n   \
    \     if i < 1000000 {\n            roman.append(\"c\")\n        }\n        roman.append(\"\
    xc\")\n        i += 1\n    }\n    while i < Int64(1000 * 1000 * 1000 * 1000 *\
    \ 1000) {\n        if i < 1000000000 {\n            roman.append(\"m\")\n    \
    \    }\n        roman.append(\"xm\")\n        i += 1\n    }\n    while i < Int64(1000\
    \ * 1000 * 1000 * 1000 * 1000 * 1000) {\n        if i < 1000000000000 {\n    \
    \        roman.append(\"b\")\n        }\n        roman.append(\"xb\")\n      \
    \  i += 1\n    }\n    while i < Int64(1000 * 1000 * 1000 * 1000 * 1000 * 1000\
    \ * 1000) {\n        if i < 1000000000000000 {\n            roman.append(\"d\"\
    )\n        }\n        roman.append(\"xd\")\n        i += 1\n    }\n    while i\
    \ < Int64(1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000) {\n        if\
    \ i < 1000000000000000000 {\n            roman.append(\"t\")\n        }\n    \
    \    roman.append(\"xt\")\n        i += 1\n    }\n    while i < Int64(1000 * 1000\
    \ * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000) {\n        if i < 1000000000000000000000\
    \ {\n            roman.append(\"q\")\n        }\n        roman.append(\"xx\")\n\
    \        i += 1\n    }\n    while i < Int64(1000 * 1000 * 1000 * 1000 * 1000 *\
    \ 1000 * 1000 * 1000 * 1000 * 1000) {\n        if i < 1000000000000000000000000\
    \ {\n            roman.append(\"k\")\n        }\n        roman.append(\"xxk\"\
    )\n        i += 1\n    }\n    while i < Int64(1000 * 1000 * 1000 * 1000 * 1000\
    \ * 1000 * 1000 * 1000 * 1000 * 1000 * 1000) {\n        if i < 10000000000000000000000000000\
    \ {\n            roman.append(\"m\")\n        }\n        roman.append(\"xxm\"\
    )\n        i += 1\n    }\n    while i < Int64(", "    guard number <= 1000 else\
    \ { return \"\" }\n\n    var roman = \"\"\n    var roman_number = 0\n\n    for\
    \ num in 0 ..< number {\n        roman_number += roman_table[(number - num) %\
    \  10]\n        roman += roman_table[(number - num) %  10]\n    }\n\n    return\
    \ roman", "    // Convert to roman\n    var roman = \"\"\n    var n = number\n\
    \n    for i := 1; i <= 4; i++ {\n        if (number / i) >= 4 {\n            roman\
    \ += roman_numeral[((number / i) - 4)]\n        } else {\n            roman +=\
    \ roman_numeral[((number / i) - 1)]\n        }\n    }\n\n    for i := 5; i <=\
    \ 9; i++ {\n        roman += roman_numeral[((n / i) - 1)]\n    }\n\n    return\
    \ roman", "    let romanToNum: [String: Int] = [\"I\": 1, \"V\": 5, \"X\": 10,\
    \ \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, \"IU\": 5000, \"IV\": 50000,\
    \ \"IX\": 100000, \"XC\": 500000, \"LV\": 5000000, \"LC\": 100000000, \"LD\":\
    \ 500000000, \"MU\": 1000000000, \"MIV\": 5000000000, \"MXC\": 100000000000, \"\
    MXD\": 500000000000, \"MUX\": 5000000000000, \"IVC\": 50000000000000000, \"IVD\"\
    : 500000000000000000, \"IXC\": 1000000000000000000, \"IXD\": 5000000000000000000,\
    \ \"XCC\": 10000000000000000000, \"XCD\": 500000000000000000000, \"XLV\": 50000000000000000000000,\
    \ \"XCL\": 1000000000000000000000, \"XCDL\": 500000000000000000000000, \"LXI\"\
    : 50000000000000000000000000, \"CXL\": 1000000000000000000000000, \"XIX\": 10000000000000000000000000_,\
    \ \"XXIV\": 5000000000000000000000000000, \"XXIC\": 100000000000000000000000000000,\
    \ \"XXICL\": 500000000000000000000000000000, \"XXII\": 10000000000000000000000000000000,\
    \ \"XXIIC\": 50000000000000000000000000000000, \"XXIIIC\": 1000000000000000000000000000000000,\
    \ \"XXXIV\": 50000000000000000000000000000000_, \"XXXIC\": 1000000000000000000000000000000000_,\
    \ \"XXXICL\": 5000000000000000000000000000000000, \"XXXI\": 100000000000000000000000000000000000,\
    \ \"XXXIIC\": 500000000000000000000000000000000000, \"XXXII\": 10000000000000000000000000000000000000,\
    \ \"XXXIIIC\": 50000000000000000000000000000000000000, \"XXXIIX\": 1000000000000000000000000000000000000000,\
    \ \"XXXIVX\": 5000000000000000000000000000000000000000_, \"XXXIX\": 100000000000000000000000000000000000000000_,\
    \ \"XXXIXX\": 50000000000000000000000000000000_]\n\n    return romanToNum[String(number)]",
  "    var roman = \"\"\n    var i = 1\n\n    while i < number {\n        let roman_string\
    \ = roman_number[i]\n        if roman == \"\" {\n            roman = roman_string\n\
    \        } else {\n            roman = \"\\(roman) \\(roman_string)\"\n      \
    \  }\n        i += 1\n    }\n\n    return roman.lowercased()", "    var roman_numeral\
    \ = \"\"\n    var roman_integer = 0\n    var roman_numeral_index = 0\n    var\
    \ roman_numeral_temp = 0\n    var roman_numeral_temp2 = 0\n    var roman_numeral_temp3\
    \ = 0\n    var roman_numeral_temp4 = 0\n\n    for _ in 0..<number {\n        if\
    \ number % 10 == 0 {\n            if roman_integer == 0 {\n                roman_integer\
    \ = number\n            } else {\n                roman_integer = roman_integer\
    \ * 10 + number % 10\n            }\n            roman_numeral += String(roman_integer%10)\n\
    \            roman_integer = roman_integer/10\n        } else {\n            roman_integer\
    \ = roman_integer * 10 + number % 10\n        }\n    }\n    if roman_integer !=\
    \ 0 {\n        roman_numeral += String(roman_integer)\n    }\n    return roman_numeral.lowercased()",
  "    let num: Int = number\n    var roman: String = String()\n    var numDigits:\
    \ Int = 0\n    var remainder: Int = 0\n\n    while num != 0 {\n        numDigits\
    \ = num % 10\n        remainder = num % 100\n        roman = (remainder * 10)\
    \ + roman\n        num = num / 100\n    }\n\n    if numDigits != 0 {\n       \
    \ roman = (numDigits * 10) + roman\n    }\n\n    return roman.lowercased()", " \
    \   switch number {\n    case 1000:\n        return \"mi\"\n    case 900:\n  \
    \      return \"vi\"\n    case 500:\n        return \"vii\"\n    case 400:\n \
    \       return \"ix\"\n    case 100:\n        return \"ix\"\n    case 9:\n   \
    \     return \"ix\"\n    case 5:\n        return \"v\"\n    case 4:\n        return\
    \ \"v\"\n    case 3:\n        return \"v\"\n    case 2:\n        return \"vi\"\
    \n    case 1:\n        return \"vi\"\n    default:\n        return \"\"\n    }",
  "    let roman = StringBuffer()\n    let num2roman: [[String]] = [\n        [\"\
    M\", \"MM\", \"MMM\"],\n        [\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\"\
    , \"DCC\", \"DCCC\", \"CM\"],\n        [\"X\", \"XL\", \"XC\"],\n        [\"L\"\
    , \"LX\", \"LXX\", \"XLX\", \"XLL\", \"XLLL\", \"XLXL\"],\n        [\"V\", \"\
    VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XX\", \"XXX\"],\n        [\"I\"],\n\
    \    ]\n\n    for _ in 0 ..< number {\n        roman.append(\"<\")\n        roman.append(num2roman[number\
    \ % 1000][0])\n        roman.append(\">\")\n        number /= 1000\n    }\n  \
    \  return roman.string(using: String.Encoding.lowercase)", "  let numStr = String(number)\n\
    \  var roman = \"\"\n\n  if number < 1 || number > 1000 {\n    return \"Invalid\
    \ input for int_to_mini_roman(): number=\"\n      + String(number)\n  }\n\n  for\
    \ _ in 0..<numStr.characters.count {\n    var remainder = numStr.characters\n\
    \    guard remainder.count > 0 else {\n      return \"Invalid input for int_to_mini_roman():\
    \ number=\"\n        + String(number)\n    }\n    let digit = remainder[0]\n \
    \   if digit >= \"a\" && digit <= \"m\" {\n      remainder.remove(at: 0)\n   \
    \   roman += String(Int(digit) - Int(97))\n    } else if digit >= \"w\" && digit\
    \ <= \"z\" {\n      remainder.remove(at: 0)\n      roman += String(Int(digit)\
    \ - Int(91) + 10)\n    } else {\n      remainder.remove(at: 0)\n      roman +=\
    \ digit\n    }\n  }\n\n  return roman.lowercased()", "  let numerals = [\"\",\
    \ \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"\
    m\", \"mm\", \"mmm\"]\n  let romans = (0..<1000).map { ($0.0 + $0.1) * 1000 +\
    \ $0.2 }\n  let index = romans.firstIndex(where: { (roman) -> Bool in\n    roman\
    \ >= (number % 1000) && (roman <= (number % 1000 + 999))\n  })\n  let roman =\
    \ romans[index]\n  return numerals[roman]", '    return number_to_mini_roman(number)',
  "    let num = number\n    let num_str = num.description\n    let roman = IntToRoman(num)\n\
    \    let roman =  roman.characters\n    let output = String()\n    var i = 0\n\
    \    var j = 0\n\n    while i < num_str.characters.count {\n        var found\
    \ = false\n        if i == 0 {\n            output.append(roman[j])\n        \
    \    j += 1\n            i += 1\n            continue\n        }\n\n        while\
    \ j < roman.count && !found {\n            var c = roman[j]\n            if c\
    \ == \"0\" {\n                output.append(c)\n                j += 1\n     \
    \           i += 1\n                continue\n            } else {\n         \
    \       let newchar = c - String(c).characters.first!\n                output.append(newchar.description)\n\
    \                found = true\n            }\n        }\n\n        if !found {\n\
    \            while i < num_str.characters.count && i < roman.count {\n       \
    \         if num_str[i] == \"0\" {\n                    output.append(roman[i])\n\
    \                    i += 1\n                } else {\n                    output.append(roman[i])\n\
    \                    i += 1\n                }\n            }\n        }\n   \
    \ }\n\n    return output.lowercased()", '    return mini_roman_map[number]', " \
    \   if number < 1 || number > 1000 {\n        fail(\"Expected 1 <= num <= 1000,\
    \ got\", number, \".\")\n    }\n\n    // Handle special cases\n    if number ==\
    \ 1 {\n        return \"x\"\n    }\n    if number == 5 {\n        return \"v\"\
    \n    }\n    if number == 10 {\n        return \"l\"\n    }\n    if number ==\
    \ 50 {\n        return \"l'\"\n    }\n    if number == 100 {\n        return \"\
    c'\"\n    }\n\n    // Build first word to start with\n    var firstWord = \"\"\
    \n    if number >= 1000 {\n        firstWord = mini_roman_digits[(number / 1000)\
    \ % 10]\n    }\n\n    // Build rest of word\n    var rest = number % 1000\n  \
    \  if rest == 0 {\n        return firstWord\n    }\n\n    // Add roman numerals\
    \ to first word\n    var romNumerals = mini_roman_numerals[rest % 10]\n    if\
    \ rest >= 100 {\n        romNumerals = \"M\" + romNumerals\n    }\n    firstWord\
    \ += romNumerals\n\n    // Add digits to rest of word\n    rest = rest / 10\n\
    \    var digits = mini_roman_digits[rest % 10]\n    if rest >= 10 {\n        digits\
    \ = \"D\" + digits\n    }\n    rest /= 10\n\n    // Add last digit to rest of\
    \ word\n    if rest == 0 {\n        digits = \"M\" + digits\n    }\n    firstWord\
    \ += digits\n\n    // Return concatenated words\n    return firstWord", "    var\
    \ roman = \"\"\n    let base = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\",\
    \ \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\n    for _ in 1...number\
    \ {\n        let remaining = number % 100\n        if remaining == 0 {\n     \
    \       roman += base[Int(number / 100) - 1]\n        } else {\n            roman\
    \ += base[Int(remaining / 10)]\n            roman += \"L\"\n            number\
    \ -= remaining\n        }\n    }\n    return roman.lowercased()", "    let digits\
    \ = IntToStringDigits(number)\n\n    var ret = \"\"\n\n    for i in 0..<digits.count\
    \ {\n        let digit = digits[i]\n        let code = Int(digit * 4)\n      \
    \  let lowerCaseCode = code.lowercased()\n        let roman = IntToRoman[lowerCaseCode]\n\
    \n        ret += roman\n    }\n\n    return ret.lowercased()", "    guard number\
    \ >= 1 &&\n        number <= 1000 else {\n            return \"\"\n    }\n   \
    \ var roman = roman_map()\n    for i in 1...number {\n        roman = roman.map\
    \ { $0[i] }\n    }\n    return roman.map(String.init).joined(separator: \"\")",
  "    let digits = String(number)\n\n    // Sanity checks\n    guard digits.count\
    \ >= 1 else {\n        return \"\"\n    }\n\n    guard digits.count <= 3 else\
    \ {\n        return \"\"\n    }\n\n    // Simplify the string\n    if digits ==\
    \ \"1\" {\n        return \"x\"\n    } else if digits == \"2\" {\n        return\
    \ \"ix\"\n    } else if digits == \"3\" {\n        return \"lb\"\n    }\n\n  \
    \  // Now it's some really complex math\n    guard let firstChar = String(digits.prefix(1)),\
    \ let secondChar = String(digits.prefix(2)),\n        let thirdChar = String(digits.prefix(3)),\n\
    \        let fourthChar = String(digits.prefix(4)),\n        let fifthChar = String(digits.prefix(5)),\n\
    \        let sixthChar = String(digits.prefix(6)),\n        let seventhChar =\
    \ String(digits.prefix(7)),\n        let eighthChar = String(digits.prefix(8)),\n\
    \        let ninthChar = String(digits.prefix(9)),\n        let tenthChar = String(digits.prefix(10))\n\
    \    else {\n        return \"\"\n    }\n\n    guard firstChar != \"M\", firstChar.lowercased()\
    \ == firstChar else {\n        return \"\"\n    }\n\n    let baseMiniRomanString\
    \ = (\n        if firstChar == \"M\" {\n            baseMiniRomanString(from:\
    \ secondChar)\n        } else if secondChar == \"M\" {\n            baseMiniRomanString(from:\
    \ thirdChar)\n        } else if thirdChar == \"M\" {\n            baseMiniRomanString(from:\
    \ fourthChar)\n        } else if fourthChar == \"M\" {\n            baseMiniRomanString(from:\
    \ fifthChar)\n        } else if fifthChar == \"M\" {\n            baseMiniRomanString(from:\
    \ sixthChar)\n        } else if sixthChar == \"M\" {\n            baseMiniRomanString(from:\
    \ seventhChar)\n        } else if seventhChar == \"M\" {\n            baseMiniRomanString(from:\
    \ eighthChar)\n        } else if eighthChar == \"M\" {\n            baseMiniRomanString(from:\
    \ ninthChar)\n        } else if ninthChar == \"M\" {\n            baseMiniRomanString(from:\
    \ tenthChar)\n        } else {\n            baseMiniRomanString(from: firstChar)\n\
    \        }\n    )\n\n    guard let baseMiniRomanString = baseMiniRomanString,\n\
    \        let baseMiniRomanString = baseMiniRomanString.lowercased() else {\n \
    \           return \"\"\n    }\n\n    return ", "    if number < 1 || number >\
    \ 1000 {\n        return String()\n    }\n\n    var roman: String {\n        willSet\
    \ {\n            if newValue != oldValue {\n                roman = \"\"\n   \
    \         }\n        }\n    }\n    var digit: Int\n    var denominator: Int\n\
    \    var num: Int\n    var remainder: Int\n\n    num = number\n    denominator\
    \ = 1000\n\n    do {\n        digit = num % denominator\n        roman = String(roman[roman.index(roman.startIndex,\
    \ offsetBy: 1)...]).append(String(numeral_digits[digit]))\n        remainder =\
    \ num / denominator\n        num = remainder\n        denominator = denominator\
    \ / 10\n    }\n    while num > 0\n\n    return roman.lowercased()", "    var romanNum\
    \ = String(number).characters.map { Int(String($0)) }\n    romanNum = romanNum.filter{$0\
    \ > 0} // remove negatives\n    romanNum = romanNum.filter{$0 <= 1000} // remove\
    \ non-numeric entries\n    let romanString = romanNum.map { MiniRoman($0) }.joined()\n\
    \    return romanString.lowercased()", "    var romanStr = \"\"\n    var digitCount\
    \ = 0\n    let romanValue = [\n        [\"M\", 1000],\n        [\"CM\", 900],\n\
    \        [\"D\", 500],\n        [\"CD\", 400],\n        [\"C\", 100],\n      \
    \  [\"XC\", 90],\n        [\"L\", 50],\n        [\"XL\", 40],\n        [\"X\"\
    , 10],\n        [\"IX\", 9],\n        [\"V\", 5],\n        [\"IV\", 4],\n    \
    \    [\"I\", 1]\n    ]\n\n    for romanLetter in romanValue {\n        let letter\
    \ = romanLetter[0]\n\n        while number >= romanLetter[1] {\n            number\
    \ -= romanLetter[1]\n            digitCount++\n        }\n\n        if digitCount\
    \ == 0 {\n            romanStr += letter\n        } else {\n            romanStr\
    \ += String(digitCount)\n            romanStr += letter\n        }\n    }\n\n\
    \    return romanStr.lowercased()", "    var roman = \"\"\n    var roman_digit_count:\
    \ UInt = 0\n    if number == 0 {\n        return roman\n    }\n    let numDigits\
    \ = 10\n    let numDigitsInBase10 = log10f(Float(number)).truncatingRemainder(dividingBy:\
    \ numDigits)\n    switch numDigitsInBase10 {\n    case 0: break\n    case 1:\n\
    \        if number < 1_000_000 {\n            roman += \"I\"\n        } else {\n\
    \            if number < 1_000_000 {\n                roman += \"V\"\n       \
    \     } else {\n                if number < 1_000_000 {\n                    roman\
    \ += \"X\"\n                } else {\n                    if number < 1_000_000\
    \ {\n                        roman += \"C\"\n                    } else {\n  \
    \                      roman += \"D\"\n                    }\n               \
    \ }\n            }\n        }\n    case 2:\n        if number < 1_000_000 {\n\
    \            roman += \"II\"\n        } else {\n            if number < 1_000_000\
    \ {\n                roman += \"III\"\n            } else {\n                if\
    \ number < 1_000_000 {\n                    roman += \"IV\"\n                }\
    \ else {\n                    if number < 1_000_000 {\n                      \
    \  roman += \"V\"\n                    } else {\n                        if number\
    \ < 1_000_000 {\n                            roman += \"VI\"\n               \
    \         } else {\n                            if number < 1_000_000 {\n    \
    \                            roman += \"VII\"\n                            } else\
    \ {\n                                if number < 1_000_000 {\n               \
    \                     roman += \"IX\"\n                                } else\
    \ {\n                                    if number < 1_000_000 {\n           \
    \                             roman += \"X\"\n                               \
    \     } else {\n                                        if number < 1_000_000\
    \ {\n                                            roman += \"XI\"\n           \
    \                             } else {\n                                     \
    \       if number < 1_000_000 {\n                                            \
    \    roman += \"XII\"\n                                            } else {\n\
    \                                                if number < 1_000_000 {\n   \
    \                                                 roman += \"XIII\"\n        \
    \                                        } else {\n                          \
    \                          if number < 1_000_000 {\n                         \
    \                               roman += \"XIV\"\n                           \
    \                         } else {\n                                         \
    \               if number < 1_000_000 {\n                                    \
    \                        roman += \"XV\"\n                                   \
    \                     } else {\n                                             \
    \               if number < 1_000_000 {\n                                    \
    \                            roman += \"XVI\"\n                              \
    \                              } else {\n                                    \
    \                            if number < 1_000_000 {\n                       \
    \                                             roman += \"XVII\"\n            \
    \                                                    } else {\n              \
    \                                                      if number < 1_000_000 {\n\
    \                                                                        roman\
    \ += \"XIX\"\n                                                               \
    \     } else {\n                                                             \
    \           if number < 1_000_000 {\n                                        \
    \                                    roman += \"XX\"\n                       \
    \                                                 } else {\n", "    let romanNumberString\
    \ = \"v\"\n    let romanNumberStrings = (0..<number.toInt()).map { romanNumberString.append(letterToRoman($0)).lowercased()\
    \ }\n    return romanNumberStrings.joined()", '    return int_to_mini_roman2(number:
    number, is_reverse: false)', "    var roman = \"\"\n    if number > 1000 { fatalError(\"\
    Number must be <= 1000\") }\n    let digits = Int64.bitPattern\n    let romanDigits\
    \ = digits\n        .filter { $0 % 10 }\n        .reduce(\"\") { $0 + String($1)\
    \ }\n\n    for i in 0..<Int(number) {\n        if i > 0 {\n            roman +=\
    \ String(romanDigits[i])\n        }\n    }\n    \n    return roman.lowercased()",
  "    let digits = String(number).characters\n    var roman = \"\"\n    var index\
    \ = 0\n    while index < digits.count {\n        if index + 1 == digits.count\
    \ {\n            roman += digits[index]\n            break\n        }\n      \
    \  let digit = digits[index].unicodeScalars\n            .filter { $0.isDigit\
    \ }\n            .first!\n        roman += digits[index].unicodeScalars\n    \
    \        .filter { $0 != digit }\n            .prefix(3)\n            .map { Int(String($0)\
    \ + digit) }\n            .sorted(by: >)\n            .prefix(3)\n           \
    \ .map(String.init)\n            .map(String.init)\n            .joined(separator:\
    \ \"-\")\n        index += 3\n    }\n    return roman", "    guard number >= 1\
    \ && number <= 1000 else {\n        fatalError()\n    }\n    let roman = String(repeating:\
    \ LONGEST_ROMAN_DIGITS[number - 1], count: 4)\n    return roman.lowercased()",
  "    var roman = \"\"\n    if number < 1 {\n        return roman\n    }\n    if\
    \ number < 500 {\n        if number % 10 == 0 {\n            roman = \"c\"\n \
    \       } else if number % 10 == 1 {\n            roman = \"x\"\n        } else\
    \ if number % 10 == 2 {\n            roman = \"l\"\n        } else if number %\
    \ 10 == 3 {\n            roman = \"i\"\n        } else if number % 10 == 4 {\n\
    \            roman = \"v\"\n        } else if number % 10 == 5 || number % 10\
    \ == 7 {\n            roman = \"i\"\n        } else if number % 10 == 6 || number\
    \ % 10 == 8 {\n            roman = \"x\"\n        } else if number % 10 == 9 {\n\
    \            roman = \"l\"\n        } else if number % 10 >= 11 && number % 10\
    \ <= 13 {\n            roman = \"c\"\n        } else if number % 10 >= 14 && number\
    \ % 10 <= 17 {\n            roman = \"l\"\n        } else if number % 10 >= 18\
    \ && number % 10 <= 19 {\n            roman = \"x\"\n        } else {\n      \
    \      roman = \"c\"\n        }\n    } else {\n        if number % 100 == 0 {\n\
    \            roman = \"cd\"\n        } else if number % 100 == 1 {\n         \
    \   roman = \"iv\"\n        } else if number % 100 == 2 {\n            roman =\
    \ \"lv\"\n        } else if number % 100 == 3 {\n            roman = \"i\"\n \
    \       } else if number % 100 == 4 {\n            roman = \"vi\"\n        } else\
    \ if number % 100 == 5 {\n            roman = \"x\"\n        } else if number\
    \ % 100 == 6 {\n            roman = \"lx\"\n        } else if number % 100 ==\
    \ 7 {\n            roman = \"ix\"\n        } else if number % 100 == 8 {\n   \
    \         roman = \"v\"\n        } else if number % 100 == 9 {\n            roman\
    \ = \"iv\"\n        } else if number % 100 >= 10 && number % 100 <= 19 {\n   \
    \         roman = \"lv\"\n        } else if number % 100 >= 20 && number % 100\
    \ <= 29 {\n            roman = \"lx\"\n        } else if number % 100 >= 30 &&\
    \ number % 100 <= 39 {\n            roman = \"ix\"\n        } else if number %\
    \ 100 >= 40 && number % 100 <= 49 {\n            roman = \"v\"\n        } else\
    \ if number % 100 >= 50 && number % 100 <= 59 {\n            roman = \"", "  \
    \  var roman = \"\"\n    if number <= 0 {\n        return roman\n    }\n\n   \
    \ var n = 1\n    var i = number - 1\n\n    while i > 0 {\n        let remainder\
    \ = i % 1000\n        roman = remainder.description + roman\n        i /= 1000\n\
    \    }\n\n    for _ in 1...number {\n        let letter = _\n        roman +=\
    \ String(letter) + String(i) + String(n)\n        n += 1\n    }\n\n    let index\
    \ = roman.characters.index(of: \"\")!\n    return roman.substring(from: index)",
  "    let num = number\n    let romandate = Int8(numberToRomanNumerals(num))\n  \
    \  return String(cString: romandate)", "    guard number >= 1 && number <= 1000\
    \ else {\n        throw Errors.InvalidArgumentError(number: number, expectedType:\
    \ Int.self)\n    }\n    let thousand = number/1000\n    let hundred = number%1000/100\n\
    \    let tens = number%100/10\n    let ones = number%10\n\n    let thousandRoman\
    \ = int_to_mini_roman(number: thousand)\n    let hundredRoman = int_to_mini_roman(number:\
    \ hundred)\n    let tensRoman = int_to_mini_roman(number: tens)\n    let onesRoman\
    \ = int_to_mini_roman(number: ones)\n\n    return thousandRoman + hundredRoman\
    \ + tensRoman + onesRoman", "    let mut result: String = \"\"\n    let num: &str\
    \ = number_to_string(number)\n    if number >= 1000 {\n        while num.len()\
    \ <= 2 {\n            num += \"0\"\n        }\n        let idx = num.len()-2\n\
    \        let sub = &num[idx..<idx+3]\n        result.append(mini_roman_prefix(sub[0])\
    \ + mini_roman_suffix(sub[1]))\n    } else {\n        result.append(mini_roman_prefix(num[0]))\n\
    \    }\n    result", '    return int_to_mini_romanString(number)', "    guard\
    \ number >= 1 && number <= 1000 else {\n        return \"0\"\n    }\n\n    func\
    \ int_to_roman(n: Int) -> String {\n        var roman = String()\n        var\
    \ index = 0\n\n        while n >= 1000 {\n            roman += String((n - n%1000)/1000)\
    \ + i1000[index%10]\n            n -= n%1000\n            index += 1\n       \
    \ }\n\n        if n%1000 {\n            roman += String(n/1000) + i1000[index%10]\n\
    \        }\n\n        return roman\n    }\n\n    let roman = int_to_roman(number)\n\
    \    return roman.lowercased()", "    var result = \"\"\n    \n    for numeral\
    \ in 0..<3 {\n        let num = number / 1000\n        let remainder = number\
    \ % 1000\n        \n        if num < 0 {\n            if num == 0 {\n        \
    \        result = \".\"\n            }\n            \n            switch remainder\
    \ {\n            case 2:\n                result = \".\" + result\n          \
    \  case 3:\n                result = \"m\" + result\n            case 5:\n   \
    \             result = \"m\" + result\n            case 7:\n                result\
    \ = \"cm\" + result\n            case 11:\n                result = \"cm\" + result\n\
    \            case 13:\n                result = \"d\" + result\n            case\
    \ 15:\n                result = \"d\" + result\n            case 17:\n       \
    \         result = \"dx\" + result\n            case 19:\n                result\
    \ = \"dx\" + result\n            case 21:\n                result = \"i\" + result\n\
    \            case 23:\n                result = \"i\" + result\n            case\
    \ 25:\n                result = \"ii\" + result\n            case 27:\n      \
    \          result = \"ii\" + result\n            case 29:\n                result\
    \ = \"v\" + result\n            case 31:\n                result = \"v\" + result\n\
    \            default:\n                break\n            }\n        } else {\n\
    \            switch remainder {\n            case 3:\n                result =\
    \ \"l\" + result\n            case 5:\n                result = \"l\" + result\n\
    \            case 7:\n                result = \"xl\" + result\n            case\
    \ 11:\n                result = \"xl\" + result\n            case 13:\n      \
    \          result = \"lx\" + result\n            case 15:\n                result\
    \ = \"lx\" + result\n            case 17:\n                result = \"xc\" + result\n\
    \            case 19:\n                result = \"xc\" + result\n            case\
    \ 21:\n                result = \"x\" + result\n            case 23:\n       \
    \         result = \"x\" + result\n            case 25:\n                result\
    \ = \"ix\" + result\n            case 27:\n                result = \"ix\" + result\n\
    \            case 29:\n                result = \"v\" + result\n            case\
    \ 31:\n                result = \"v\" + result\n            default:\n       \
    \         break\n            }\n        }\n        \n        number = num\n  \
    \  }\n    \n    return result", "    // https://leetcode.com/discuss/interview-question/1280680/\n\
    \    var result: String = \"\"\n    \n    // Step 1: calculate the number of different\
    \ characters\n    var numChars = countChars(number)\n    \n    if numChars ==\
    \ 1 {\n        result = miniRomanNumeral[number]\n    } else {\n        // Step\
    \ 2: calculate the character count for the largest possible number\n        //\
    \ that can be divided by the number of different characters\n        var maxNum\
    \ = Int(ceil(Double(number) / Double(numChars)))\n        \n        // Step 3:\
    \ calculate the number of different characters for all\n        // possible numbers,\
    \ up to maxNum\n        var nextNumChars = countChars(maxNum)\n        \n    \
    \    // Step 4: calculate the character count for the smallest number\n      \
    \  // that can't be divided by the number of different characters\n        var\
    \ minNum = Int(floor(Double(number) / Double(nextNumChars)))\n        \n     \
    \   // Step 5: calculate what character is to be appended to the result\n    \
    \    var lastChar = miniRomanNumeral[minNum]\n        \n        // Step 6: calculate\
    \ what character is to be appended to the result\n        // for the largest number\
    \ that can be divided by the number of different\n        // characters\n    \
    \    var nextLastChar = miniRomanNumeral[maxNum]\n        \n        // Step 7:\
    \ calculate what character is to be appended to the result\n        // for the\
    \ smallest number that can't be divided by the number of different\n        //\
    \ characters\n        var nextNextLastChar = miniRomanNumeral[minNum]\n      \
    \  \n        // Step 8: calculate the result of the above calculations\n     \
    \   \n        // Add the last character\n        result = lastChar + result\n\
    \        \n        // Add the next last character\n        result = nextLastChar\
    \ + result\n        \n        // Add the next next last character\n        result\
    \ = nextNextLastChar + result\n    }\n    \n    return result", "    let numToRoman\
    \ = numberToRoman(number: number)\n    return miniRomanToInt(roman: numToRoman)",
  "    var romanString: String = \"\"\n    for number > 1000 {\n        var remaining\
    \ = number % 100\n        number /= 100\n        remaining /= 10\n        romanString\
    \ = String((10 - remaining.toInt()) * \"M\") + romanString\n    }\n    if number\
    \ > 0 {\n        romanString = String((10 - number.toInt()) * \"M\") + romanString\n\
    \    }\n    return romanString", "    let mini_roman = map(number: number) {\n\
    \        number in\n        if number >= 1_000 && number <= 999 {\n          \
    \  switch number {\n            case 1_000: return \"mio\"\n            case 999:\
    \ return \"ci\"\n            default: return \"x\"\n            }\n        } else\
    \ if number >= 1000 && number <= 9999 {\n            switch number {\n       \
    \     case 1_000: return \"dm\"\n            case 1_500: return \"cm\"\n     \
    \       case 2_000: return \"l\"\n            case 9_000: return \"xc\"\n    \
    \        default: return \"vi\"\n            }\n        } else if number >= 10000\
    \ && number <= 19999 {\n            switch number {\n            case 1_000: return\
    \ \"dvi\"\n            case 1_500: return \"dc\"\n            case 2_000: return\
    \ \"dl\"\n            case 9_000: return \"xxc\"\n            default: return\
    \ \"ix\"\n            }\n        } else if number >= 20000 && number <= 49999\
    \ {\n            switch number {\n            case 1_000: return \"dii\"\n   \
    \         case 1_500: return \"dcx\"\n            case 2_000: return \"dcl\"\n\
    \            case 9_000: return \"xxc\"\n            default: return \"ivi\"\n\
    \            }\n        } else if number >= 50000 && number <= 99999 {\n     \
    \       switch number {\n            case 1_000: return \"dvii\"\n           \
    \ case 1_500: return \"dcv\"\n            case 2_000: return \"dl\"\n        \
    \    case 9_000: return \"xxc\"\n            default: return \"iix\"\n       \
    \     }\n        } else if number >= 100000 && number <= 199999 {\n          \
    \  switch number {\n            case 1_000: return \"dvvi\"\n            case\
    \ 1_500: return \"dcvx\"\n            case 2_000: return \"dlc\"\n           \
    \ case 9_000: return \"xxc\"\n            default: return \"ivx\"\n          \
    \  }\n        } else if number >= 200000 && number <= 4999999 {\n            switch\
    \ number {\n            case 1_000: return \"dvvii\"\n            case 1_500:\
    \ return \"dcvcx\"\n            case 2_000: return \"dldl\"\n            case\
    \ 9_000: return \"xxc\"\n            default: return \"ivix\"\n            }\n\
    \        } else if number >= 500000 && number <= 999999999 {\n            switch\
    \ number {\n            case 1_000: return \"dvviii\"\n            case 1_500:\
    \ return \"dcvcdx\"\n            case 2_000: return \"dldld\"\n            case\
    \ 9_000: return \"xxc\"\n            default: return \"iviix\"\n            }\n\
    \        } else ", "    var miniRoman = \"\"\n    var currentInt: Int\n    var\
    \ currentLetter: Character\n    if number == 0 || number == 1 {\n        currentLetter\
    \ = 'x'\n        currentInt = number\n    } else if number < 0 || number > 1000\
    \ {\n        currentLetter = 'i'\n        currentInt = number\n    } else {\n\
    \        miniRoman = \"<not implemented>\"\n        return\n    }\n    var currentSubNumber:\
    \ Int\n    var currentSubLetter: Character\n    for currentInt == 1 {\n      \
    \  currentLetter = 'x'\n        currentSubNumber = 1\n        currentSubLetter\
    \ = 'x'\n    } else if number == 2 {\n        currentLetter = 'l'\n        currentSubNumber\
    \ = 2\n        currentSubLetter = 'l'\n    } else if number == 3 {\n        currentLetter\
    \ = 'v'\n        currentSubNumber = 3\n        currentSubLetter = 'v'\n    } else\
    \ if number == 4 {\n        currentLetter = 'i'\n        currentSubNumber = 4\n\
    \        currentSubLetter = 'i'\n    } else if number == 5 {\n        currentLetter\
    \ = 'x'\n        currentSubNumber = 5\n        currentSubLetter = 'x'\n    } else\
    \ if number == 6 {\n        currentLetter = 'l'\n        currentSubNumber = 6\n\
    \        currentSubLetter = 'l'\n    } else if number == 7 {\n        currentLetter\
    \ = 'v'\n        currentSubNumber = 7\n        currentSubLetter = 'v'\n    } else\
    \ if number == 8 {\n        currentLetter = 'i'\n        currentSubNumber = 8\n\
    \        currentSubLetter = 'i'\n    } else if number == 9 {\n        currentLetter\
    \ = 'x'\n        currentSubNumber = 9\n        currentSubLetter = 'x'\n    } else\
    \ if number == 10 {\n        currentLetter = 'l'\n        currentSubNumber = 10\n\
    \        currentSubLetter = 'l'\n    } else if number == 11 {\n        currentLetter\
    \ = 'v'\n        currentSubNumber = 11\n        currentSubLetter = 'v'\n    }\
    \ else if number == 12 {\n        currentLetter = 'i'\n        currentSubNumber\
    \ = 12\n        currentSubLetter = 'i'\n    } else if number == 13 {\n       \
    \ currentLetter = 'x'\n        currentSubNumber = 13\n        currentSubLetter\
    \ = 'x'\n    } else if number == 14 {\n        currentLetter = 'l'\n        currentSubNumber\
    \ = 14\n        currentSubLetter = 'l'\n    } else if number == 15 {\n       \
    \ currentLetter = 'v'\n        currentSubNumber = 15\n        currentSubLetter\
    \ = 'v'\n    } else if number == 16 {\n        currentLetter = 'i'\n        currentSubNumber\
    \ = 16\n        currentSubLetter = 'i'\n    } else if number == 17 {\n       \
    \ currentLetter = 'x'\n        currentSubNumber = 17\n        currentSubLetter\
    \ = 'x'\n    } else if ", "    switch number {\n    case 0: return \"\"\n    case\
    \ 1: return \"x\"\n    case 2: return \"c\"\n    case 3: return \"m\"\n    case\
    \ 4: return \"b\"\n    case 5: return \"d\"\n    case 6: return \"xix\"\n    case\
    \ 7: return \"cl\"\n    case 8: return \"xix\"\n    case 9: return \"ix\"\n  \
    \  case 10: return \"iv\"\n    case 11: return \"v\"\n    case 12: return \"ix\"\
    \n    case 13: return \"vi\"\n    case 14: return \"vii\"\n    case 15: return\
    \ \"i\"\n    case 16: return \"ii\"\n    case 17: return \"v\"\n    case 18: return\
    \ \"vi\"\n    case 19: return \"ix\"\n    case 20: return \"i\"\n    case 21:\
    \ return \"ii\"\n    case 22: return \"iii\"\n    case 23: return \"iv\"\n   \
    \ case 24: return \"v\"\n    case 25: return \"v\"\n    case 26: return \"ix\"\
    \n    case 27: return \"x\"\n    case 28: return \"c\"\n    case 29: return \"\
    m\"\n    case 30: return \"b\"\n    case 31: return \"d\"\n    case 32: return\
    \ \"x\"\n    case 33: return \"c\"\n    case 34: return \"m\"\n    case 35: return\
    \ \"b\"\n    case 36: return \"d\"\n    case 37: return \"x\"\n    case 38: return\
    \ \"c\"\n    case 39: return \"m\"\n    case 40: return \"b\"\n    case 41: return\
    \ \"d\"\n    case 42: return \"x\"\n    case 43: return \"c\"\n    case 44: return\
    \ \"m\"\n    case 45: return \"b\"\n    case 46: return \"d\"\n    case 47: return\
    \ \"x\"\n    case 48: return \"c\"\n    case 49: return \"m\"\n    case 50: return\
    \ \"b\"\n    case 51: return \"d\"\n    case 52: return \"x\"\n    case 53: return\
    \ \"c\"\n    case 54: return \"m\"\n    case 55: return \"b\"\n    case 56: return\
    \ \"d\"\n    case 57: return \"x\"\n    case 58: return \"c\"\n    case 59: return\
    \ \"m\"\n    case 60: return \"b\"\n    case 61: return \"d\"\n    case 62: return\
    \ \"x\"\n    case 63: return \"c\"\n    case 64: return \"m\"\n    case 65: return\
    \ \"b\"\n    case 66: return \"d\"\n    case 67: return \"x\"\n    case 68: return\
    \ \"c\"\n    case 69: return \"m\"\n    case 70: return \"b\"\n    case 71: return\
    \ \"d\"\n    case 72: return \"x\"\n    case 73: return \"c\"\n    case 74: return\
    \ \"m\"\n    case 75: return \"b\"\n    case 76", "    let romanString = int_to_roman(number)\n\
    \    romanString.lowercased()", '    return String(int_to_mini_roman_helper(number:
    number))', "    let roman = StringBuilder()\n    for _ in 0..<number {\n     \
    \   roman.append(\"M\")\n    }\n    roman.deleteCharAt(roman.endIndex.predecessor())\n\
    \    return roman.string", "    var roman = \"\"\n    for number > 0 {\n     \
    \   let remainder = number % 10\n        roman += Int(remainder).description\n\
    \        number /= 10\n    }\n    return roman.lowercased()", "    let mut roman\
    \ = String::new();\n\n    // Determine if number is evenly divisible by 1000.\
    \ If it is, divide it\n    // by 1000 repeatedly until it isn't. Otherwise, subtract\
    \ 1000 and divide\n    // by 10 to get to the next digit.\n    let mut last =\
    \ 0;\n    for i in 1..number.signum() {\n        if number % i == 0 {\n      \
    \      number /= i;\n        } else {\n            number -= i;\n            last\
    \ = i;\n        }\n    }\n\n    // Add leading zero to numbers that are too large\
    \ to be expressed as a single\n    // integer in Roman numerals.\n    if number\
    \ > 100 {\n        roman.append(\"0\");\n        number = number - 100;\n    }\n\
    \n    while number != 0 {\n        // Add the next digit to Roman numeral.\n \
    \       if number >= last * 10 + 1 {\n            roman.append(\"i\");\n     \
    \       number -= last * 10 + 1;\n        } else {\n            roman.append(roman[roman.len()\
    \ - 1] + String(number % last));\n            number /= last;\n        }\n   \
    \     last++;\n    }\n\n    roman.lowercase()", "    if number < 1 || number >\
    \ 999 {\n        return \"Error - invalid input\"\n    }\n    let roman_numerals:\
    \ [String] = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\",\n\
    \        \"viii\", \"ix\", \"x\", \"xi\", \"xii\", \"xiii\", \"xiv\", \"xvi\"\
    , \"xvii\", \"xviii\",\n        \"xix\", \"xx\", \"xxi\", \"xxii\", \"xxiii\"\
    , \"xxiv\", \"xxv\", \"xxvi\", \"xxvii\",\n        \"xxviii\", \"xxix\", \"xxx\"\
    , \"xxxx\", \"xxxxi\", \"xxxxii\", \"xxxxiii\", \"xxxxiv\",\n        \"xxxxv\"\
    , \"xxxxvi\", \"xxxxvii\", \"xxxxviii\", \"xxxxix\"]\n    return roman_numerals[number]",
  "    // TODO: Implement me!\n    return \"\"", "    var result = String()\n    let\
    \ romanNumerals = createRoman {\n        let romanNumeral = String(romanNumerals[number])\n\
    \        result.append(romanNumeral)\n    }\n    return result.lowercased()",
  "    var roman = \"\"\n    for index in 0..(number / IX_TO_ROMAN_DIGITS.count) {\n\
    \        let romanDigit = IX_TO_ROMAN_DIGITS[index]\n        let romanNumeralDigit\
    \ = number % IX_TO_ROMAN_DIGITS.count\n        roman += romanDigit + romanNumeralDigit\n\
    \        number /= IX_TO_ROMAN_DIGITS.count\n    }\n    for _ in 0..(number %\
    \ IX_TO_ROMAN_DIGITS.count) {\n        roman += \"M\"\n        number /= IX_TO_ROMAN_DIGITS.count\n\
    \    }\n    return roman.lowercased()", "    switch number {\n    case 100:\n\
    \        return \"m\"\n    case 50:\n        return \"d\"\n    case 10:\n    \
    \    return \"c\"\n    case 5:\n        return \"x\"\n    case 1:\n        return\
    \ \"l\"\n    default:\n        switch number % 10 {\n        case 0:\n       \
    \     return \"l\"\n        case 1:\n            return \"c\"\n        case 2:\n\
    \            return \"d\"\n        case 3:\n            return \"x\"\n       \
    \ case 4:\n            return \"l\"\n        case 5:\n            return \"x\"\
    \n        case 6:\n            return \"c\"\n        case 7:\n            return\
    \ \"d\"\n        case 8:\n            return \"x\"\n        case 9:\n        \
    \    return \"l\"\n        }\n    }", "    let roman = roman {\n        switch\
    \ number {\n        case 1:\n            return \"c\"\n        case 2:\n     \
    \       return \"cc\"\n        case 3:\n            return \"cd\"\n        case\
    \ 4:\n            return \"cde\"\n        case 5:\n            return \"ce\"\n\
    \        case 6:\n            return \"cf\"\n        case 7:\n            return\
    \ \"cx\"\n        case 8:\n            return \"ccc\"\n        case 9:\n     \
    \       return \"cdxx\"\n        case 10:\n            return \"cdxxx\"\n    \
    \    case 11:\n            return \"cddxx\"\n        case 12:\n            return\
    \ \"cdddd\"\n        case 13:\n            return \"cddddx\"\n        case 14:\n\
    \            return \"cddddd\"\n        case 15:\n            return \"cdddddx\"\
    \n        case 16:\n            return \"cddddde\"\n        case 17:\n       \
    \     return \"cdddddex\"\n        case 18:\n            return \"cdddddex\"\n\
    \        case 19:\n            return \"cdddddeex\"\n        case 20:\n      \
    \      return \"cdddddeexx\"\n        case 21:\n            return \"cdddddexxx\"\
    \n        case 22:\n            return \"cdddddexxx\"\n        case 23:\n    \
    \        return \"cdddddexxy\"\n        case 24:\n            return \"cdddddexxyy\"\
    \n        case 25:\n            return \"cdddddexxxyy\"\n        case 26:\n  \
    \          return \"cdddddexxyyy\"\n        case 27:\n            return \"cdddddexxxyyy\"\
    \n        case 28:\n            return \"cdddddexxyyy\"\n        case 29:\n  \
    \          return \"cdddddexxyyzz\"\n        case 30:\n            return \"cdddddexxxyyyy\"\
    \n        case 31:\n            return \"cdddddexxyyzz\"\n        case 32:\n \
    \           return \"cdddddexxyyzzz\"\n        case 33:\n            return \"\
    cdddddexxxyyyyy\"\n        case 34:\n            return \"cdddddexxyyzzz\"\n \
    \       case 35:\n            return \"cdddddexxyyzzzz\"\n        case 36:\n \
    \           return \"cdddddexxxyyyyyy\"\n        case 37:\n            return\
    \ \"cdddddexxyyzzzz\"\n        case 38:\n            return \"cdddddexxyyzzzzz\"\
    \n        case 39:\n            return \"cdddddexxxyyyyyyy\"\n        case 40:\n\
    \            return \"cdddddexxyyzzzzzz\"\n        case 41:\n            return\
    \ \"cdddddexxyyzzzzzzz\"\n        case 42:\n            return \"cdddddexxxyyyyyyyy\"\
    \n        case 43:\n            return \"cdddddexxyyzzzzzzzz\"\n        case 44:\n\
    \            return \"cdddddexxyyzzzzzzzzz\"\n        case 45:\n            return\
    \ \"cdddddexxxyyyyyyyyy\"", "    let roman_digits = [\"\", \"c\", \"d\", \"x\"\
    , \"l\", \"m\", \"c\", \"l\", \"v\", \"x\"]\n    let letters = [\"m\", \"c\",\
    \ \"d\", \"x\", \"l\", \"v\", \"x\"]\n    let letters_roman_digits = [\"\", \"\
    m\", \"c\", \"d\", \"x\", \"l\", \"v\", \"x\"]\n    var result = \"\"\n    if\
    \ number == 0 || number == 1000 {\n        return String(number)\n    }\n    var\
    \ remainder = number % 1000\n    let hundreds = int_to_mini_roman(remainder)\n\
    \    if hundreds.isEmpty() {\n        hundreds = \"0\"\n    }\n    if number >=\
    \ 100 && number < 200 {\n        return String((number / 100).truncatingRemainder(dividingBy:\
    \ 1000) + hundreds + roman_digits[number % 100])\n    }\n    if number >= 200\
    \ && number < 300 {\n        let hundreds_length = roman_digits[number % 100].count\n\
    \        let hundreds_roman_length = roman_digits[number % 100].count - 1\n  \
    \      return String((number / 100).truncatingRemainder(dividingBy: 1000) + hundreds\
    \ + roman_digits[number % 100] + roman_digits[number % 100 + hundreds_length -\
    \ 1] + hundreds_roman_length + letters[number % 100 + hundreds_length - 1] + hundreds_roman_length)\n\
    \    }\n    if number >= 300 && number < 400 {\n        let hundreds_length =\
    \ roman_digits[number % 100].count\n        let hundreds_roman_length = roman_digits[number\
    \ % 100].count - 1\n        let hundreds_roman_length2 = roman_digits[number %\
    \ 100].count - 2\n        return String((number / 100).truncatingRemainder(dividingBy:\
    \ 1000) + hundreds + roman_digits[number % 100] + roman_digits[number % 100 +\
    \ hundreds_length - 1] + hundreds_roman_length + roman_digits[number % 100 + hundreds_length\
    \ - 2] + hundreds_roman_length2 + letters[number % 100 + hundreds_length - 1]\
    \ + hundreds_roman_length2)\n    }\n    if number >= 400 && number < 500 {\n \
    \       let hundreds_length = roman_digits[number % 100].count\n        let hundreds_roman_length\
    \ = roman_digits[number % 100].count - 1\n        let hundreds_roman_length2 =\
    \ roman_digits[number % 100].count - 2\n        let hundreds_roman_length3 = roman_digits[number\
    \ % 100].count - 3\n        return String((", "    if number == 0 {\n        return\
    \ \"i\"\n    }\n    guard number > 0 && number <= 1000 else {\n        return\
    \ \"?\"\n    }\n    let roman_numerals: [String] = [\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\", \"xi\", \"xii\"]\n    var\
    \ result = \"\"\n    for i in 0..<roman_numerals.count {\n        if roman_numerals.count\
    \ - 1 < number {\n            result = result + roman_numerals[i]\n          \
    \  break\n        } else {\n            number -= roman_numerals.count - i\n \
    \           if number >= 1000 {\n                let index = roman_numerals.count\
    \ - 1\n                if number >= index {\n                    result = result\
    \ + roman_numerals[index]\n                } else {\n                    let remainder\
    \ = number % index\n                    result = result + roman_numerals[index]\
    \ + roman_numerals[remainder]\n                }\n            } else {\n     \
    \           result = result + roman_numerals[number]\n            }\n        }\n\
    \    }\n    if result.isEmpty() {\n        result = \"?\"\n    }\n    return result.lowercased()",
  "    guard number >= 1 && number <= 1000 else {\n        preconditionFailure(\"\
    number should be in range of 1 to 1000\")\n    }\n    return String(\n       \
    \ UnicodeScalar(number) &\n            (UnicodeScalar(0x05BE).value) << 8 &\n\
    \            (UnicodeScalar(0x05BE).value) << 16 &\n            (UnicodeScalar(0x0610).value)\
    \ << 24 &\n            (UnicodeScalar(0x0610).value) << 32 &\n            (UnicodeScalar(0x0610).value)\
    \ << 40 &\n            (UnicodeScalar(0x0610).value) << 48)", "    var roman =\
    \ \"\"\n    let intToRoman = IntToRoman(number)\n    for char in intToRoman {\n\
    \        roman += char\n    }\n    return roman.lowercased()", "    // check input\n\
    \    if number < 1 || number > 1000 {\n        throw PyValueError.new_args(\n\
    \            PyValueError.new_args(\n                \"Invalid arguments: Invalid\
    \ input value for int_to_mini_roman()\",\n                PyValueError.new_args(\n\
    \                    \"The number must be between 1 and 999.\",\n            \
    \        \"The number passed was \\(number)\",\n                    PyValueError.new_args(\n\
    \                        \"Invalid input value for int_to_mini_roman()\",\n  \
    \                      \"The number must be between 1 and 999.\")))\n    }\n \
    \   // return output\n    let int_str_array = Array(1...number).map {\n      \
    \  // create new array for roman numeral string\n        var roman_numeral_array:\
    \ [String] = []\n        // loop through each digit\n        for _ in 0..<$0 {\n\
    \            // add new digit to array if it's not already in there\n        \
    \    if !roman_numeral_array.contains({$0.contains(UnicodeScalar($1))}) {\n  \
    \              roman_numeral_array.append(UnicodeScalar($1))\n            }\n\
    \        }\n        // convert array to string and return\n        return roman_numeral_array.map\
    \ { UnicodeScalar($0).description }\n    }\n    return String(int_str_array)",
  "    if number <= 0 {\n        return \"\"\n    }\n    switch number {\n    case\
    \ 1:\n        return \"I\"\n    case 5:\n        return \"V\"\n    case 10:\n\
    \        return \"X\"\n    case 20:\n        return \"C\"\n    case 50:\n    \
    \    return \"D\"\n    case 100:\n        return \"M\"\n    case 200:\n      \
    \  return \"L\"\n    case 400:\n        return \"C\"\n    case 1000:\n       \
    \ return \"X\"\n    default:\n        return \"\"\n    }", "    let romanStr =\
    \ \"MCMXCIV\"\n    let index = romanStr.index(romanStr, startIndex: number-1)\n\
    \    return romanStr[index...].lowercased()", "    let numToStr: [(Int, String)]\
    \ = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n\
    \        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n      \
    \  (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"\
    ),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\"),\n    ]\n\n\
    \    var numberString = String(number)\n    for i in 1...numberString.count {\n\
    \        let temp = Int(String(numberString[numberString.index(numberString.startIndex,\
    \ offsetBy: i)] + numberString[numberString.index(numberString.startIndex, offsetBy:\
    \ i+1)]).uppercased())\n        if temp > numToStr.endIndex {\n            break\n\
    \        }\n        if temp == 0 {\n            numberString = String(numToStr[numToStr.endIndex\
    \ - 1][1])\n        } else {\n            numberString = String(numToStr[temp-1][1])\n\
    \        }\n    }\n    return numberString.lowercased()", "    // Base\n    let\
    \ base: String = \"M\"\n    // Value of digit 1\n    let value1: String\n    if\
    \ number < 1_000 {\n        value1 = \"C\"\n    } else {\n        value1 = \"\
    M\"\n    }\n    // Value of digit 2\n    let value2: String\n    if number < 1_500\
    \ {\n        value2 = \"D\"\n    } else {\n        value2 = \"C\"\n    }\n   \
    \ // Value of digit 3\n    let value3: String\n    if number < 1_100 {\n     \
    \   value3 = \"C\"\n    } else if number < 1_500 {\n        value3 = \"X\"\n \
    \   } else if number < 1_1000 {\n        value3 = \"L\"\n    } else {\n      \
    \  value3 = \"C\"\n    }\n    // Value of digit 4\n    let value4: String\n  \
    \  if number < 1_100 {\n        value4 = \"L\"\n    } else if number < 1_500 {\n\
    \        value4 = \"X\"\n    } else if number < 1_1000 {\n        value4 = \"\
    C\"\n    } else {\n        value4 = \"L\"\n    }\n    // Value of digit 5\n  \
    \  let value5: String\n    if number < 1_100 {\n        value5 = \"C\"\n    }\
    \ else if number < 1_500 {\n        value5 = \"X\"\n    } else if number < 1_1000\
    \ {\n        value5 = \"C\"\n    } else {\n        value5 = \"L\"\n    }\n   \
    \ // Value of digit 6\n    let value6: String\n    if number < 1_100 {\n     \
    \   value6 = \"L\"\n    } else if number < 1_500 {\n        value6 = \"X\"\n \
    \   } else if number < 1_1000 {\n        value6 = \"C\"\n    } else {\n      \
    \  value6 = \"L\"\n    }\n    // Value of digit 7\n    let value7: String\n  \
    \  if number < 1_100 {\n        value7 = \"C\"\n    } else if number < 1_500 {\n\
    \        value7 = \"X\"\n    } else if number < 1_1000 {\n        value7 = \"\
    C\"\n    } else {\n        value7 = \"L\"\n    }\n    // Value of digit 8\n  \
    \  let value8: String\n    if number < 1_100 {\n        value8 = \"L\"\n    }\
    \ else if number < 1_500 {\n        value8 = \"X\"\n    } else if number < 1_1000\
    \ {\n        value8 = \"C\"\n    } else {\n        value8 = \"L\"\n    }\n   \
    \ // Value of digit 9\n    let value9: String\n    if number < 1_100 {\n     \
    \   value9 = \"C\"\n    } else if number < 1_500 {\n        value9 = \"X\"\n \
    \   } else if number < 1_1000 {\n        value9", "    var miniRoman = \"\"\n\
    \    var numberToCheck = number\n\n    let romandate = {\n        let roman: Character\
    \ = \"I\"\n        let letters: [Character] = [\"I\", \"V\", \"X\", \"L\", \"\
    C\", \"D\", \"M\", \"M\"]\n        var str = \"\"\n        for i in 0..<numbers.count\
    \ {\n            str += letters[numberToCheck % 10]\n            numberToCheck\
    \ /= 10\n        }\n        return str + roman\n    }\n\n    func checkNum(x:\
    \ Int) -> Bool {\n        if x == 0 {\n            return true\n        }\n  \
    \      if x > 0 && x > numberToCheck {\n            return false\n        }\n\
    \        if numberToCheck % x == 0 {\n            return false\n        }\n  \
    \      return true\n    }\n\n    while checkNum(numberToCheck) {\n        miniRoman\
    \ = romandate()\n    }\n    return miniRoman.lowercased()", "    let result =\
    \ StringBuilder(\"\")\n    guard number > 0 else {\n        return result\n  \
    \  }\n\n    for _ in 1...number {\n        result.append(\"x\")\n    }\n\n   \
    \ return result.lowercased()", "    let n = number\n    var numerals: [String]\
    \ = []\n\n    let numeralLetters: [String] = \"M\"\n    let numeralSuffixes: [String]\
    \ = \"D\"\n    let numeralLetterSuffixes: [String] = \"\"\n\n    let numeralSuffixesLetters:\
    \ [String] = \"I\"\n    let numeralSuffixesLetterSuffixes: [String] = \"\"\n\n\
    \    let numeralDigits: [String] = \"C\"\n    let numeralDigitSuffixes: [String]\
    \ = \"X\"\n    let numeralDigitSuffixesLetters: [String] = \"V\"\n    let numeralDigitSuffixesLetterSuffixes:\
    \ [String] = \"I\"\n\n    var numeralCounter = Int()\n\n    // Find the right\
    \ letter for each value\n    for var i = 0; i < n; i++ {\n        numeralCounter\
    \ += 1\n        if numeralCounter == 1 {\n            numerals.append(numeralLetters[numeralCounter-1])\n\
    \        } else if numeralCounter == 2 && i % 5 == 0 {\n            numerals.append(numeralLetterSuffixes[numeralCounter\
    \ - 2])\n        } else if numeralCounter == 2 && i % 5 == 4 {\n            numerals.append(numeralLetterSuffixes[numeralCounter\
    \ - 2])\n        } else if numeralCounter == 3 && i % 10 == 0 {\n            numerals.append(numeralDigits[numeralCounter\
    \ - 3])\n        } else if numeralCounter == 3 && i % 10 == 4 {\n            numerals.append(numeralDigits[numeralCounter\
    \ - 3])\n        } else if numeralCounter == 3 && i % 10 == 9 {\n            numerals.append(numeralDigits[numeralCounter\
    \ - 3])\n        } else if numeralCounter == 3 && i % 10 == 99 {\n           \
    \ numerals.append(numeralDigits[numeralCounter - 3])\n        } else if numeralCounter\
    \ == 4 {\n            numerals.append(numeralSuffixes[numeralCounter - 4])\n \
    \       } else if numeralCounter == 5 && i % 10 == 0 {\n            numerals.append(numeralSuffixesLetters[numeralCounter\
    \ - 5])\n        } else if numeralCounter == 5 && i % 10 == 4 {\n            numerals.append(numeralSuffixesLetters[numeralCounter\
    \ - 5])\n        } else if numeralCounter == 5 && i % 10 == 9 {\n            numerals.append(numeralSuffixesLetters[numeralCounter\
    \ - 5])\n        } else if numeralCounter == 5 && i % 10 == 99 {\n           \
    \ numerals.append(numeralSuffixesLetters[numeralCounter - 5])\n        } else\
    \ if numeralCounter == 6 {\n            numerals.append(numeralDigitSuffixes[numeralCounter\
    \ - 6])\n        } else if numeralCounter == 7 && i % 10 == ", "    var result:\
    \ String = String()\n    var previous: Int = 0\n    for number > 0 {\n       \
    \ var numeral: String\n        let currentDigit = number % 10\n        let nextDigit\
    \ = number / 10\n        if previous == 0 {\n            numeral = String(currentDigit\
    \ + String(nextDigit))\n        } else {\n            numeral = String(currentDigit\
    \ - previous + String(nextDigit))\n        }\n        result += numeral\n    \
    \    previous = currentDigit\n        number /= 10\n    }\n    return result",
  "    let romanNumerals = [\n        \"M\",\n        \"CM\",\n        \"D\",\n  \
    \      \"CD\",\n        \"C\",\n        \"XC\",\n        \"L\",\n        \"XL\"\
    ,\n        \"X\",\n        \"IX\",\n        \"V\",\n        \"IV\",\n        \"\
    I\",\n    ]\n\n    var romanNumeral = \"\"\n    for _ in 0..<Int(number / 3) {\n\
    \        romanNumeral += romanNumerals[Int(number / 3)]\n        number -= Int(number\
    \ / 3)\n    }\n\n    if number > 0 {\n        let remainder = number % 3\n   \
    \     let index = romanNumerals.index(romanNumeral)\n        romanNumeral += romanNumerals[index\
    \ + remainder]\n    }\n    return romanNumeral.lowercased()", "    // https://developers.google.com/edu/python/code/exercises/code\n\
    \    let romanMap = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\", \"x\", \"xi\",\n        \"xii\", \"xiii\", \"\
    xiv\", \"xv\", \"xvi\", \"xvii\", \"xviii\", \"xix\", \"xx\", \"xxi\",\n     \
    \   \"xxii\", \"xxiii\", \"xxiv\", \"xxv\", \"xxvi\", \"xxvii\", \"xxviii\", \"\
    xxix\", \"xxx\",\n        \"xxxi\", \"xxxii\", \"xxxiii\", \"xxxiv\", \"xxxv\"\
    , \"xxxvi\", \"xxxvii\", \"xxxviii\",\n        \"xxxix\", \"xxxx\", \"xxxxi\"\
    , \"xxxxii\", \"xxxxiii\", \"xxxxiv\", \"xxxxv\", \"xxxxvi\",\n        \"xxxxvii\"\
    , \"xxxxviii\", \"xxxxix\", \"xxx\", \"xxxi\", \"xxxii\", \"xxxiii\", \"xxxiv\"\
    ,\n        \"xxxv\", \"xxxvi\", \"xxxvii\", \"xxxviii\", \"xxxix\", \"xxxx\",\
    \ \"xxxxi\", \"xxxxii\",\n        \"xxxxiii\", \"xxxxiv\", \"xxxxv\", \"xxxxvi\"\
    , \"xxxxvii\", \"xxxxviii\", \"xxxxix\"]\n\n    var miniRoman = \"\"\n    var\
    \ index = 0\n    for _ in 0..<number {\n        let roman = romanMap[index]\n\
    \        miniRoman += roman\n        index += 1\n    }\n    miniRoman = miniRoman.lowercased()\n\
    \    return miniRoman", "    guard number >= 1 && number <= 1000 else {\n    \
    \    return \"\"\n    }\n    var result: String = \"\"\n    for _ in 0..<number/10\
    \ {\n        result += \"m\" + String(number % 10)\n        number /= 10\n   \
    \ }\n    if number > 0 {\n        result += \"k\" + String(number % 10)\n    }\n\
    \    return result", "    var numerals: [String] = []\n    var bases: [String]\
    \ = [\"\", \"c\", \"l\", \"d\", \"x\", \"x\", \"vi\", \"i\"]\n    for _ in 0..<number\
    \ {\n        var roman : String = String(Int((number % 100) * 400))\n        number\
    \ /= 100\n        for i in 0..<bases.count {\n            if number < 1 {\n  \
    \              break\n            }\n            if number >= bases.count {\n\
    \                numerals.append(roman)\n                break\n            }\n\
    \            if number == bases.count - 1 {\n                numerals.append(roman)\n\
    \                break\n            }\n            numerals.append(bases[i])\n\
    \            roman += String(Int((number % bases.count) * 100))\n            number\
    \ /= bases.count\n        }\n    }\n    return numerals.reduce(\"x\") { (first,\
    \ second) -> String in\n        return first + second\n    }", "    var roman_num\
    \ = \"\"\n    for num in String(number).characters {\n        switch num {\n \
    \       case 'I':\n            roman_num += \"x\"\n        default:\n        \
    \    roman_num += String(num)\n        }\n    }\n    return roman_num.lowercased()",
  "    guard number > 0 else {\n        return \"\"\n    }\n    let roman = RomanNumerals.shared.romans[number]\n\
    \    return roman.lowercase", "    let chars = \"xixvi\"\n    let charCounts =\
    \ chars.map({ $0.unicodeScalars.count })\n    let charCountPairs = charCounts.reduce(into:\
    \ [(String, Int)](), { $0.append($1.0, $1) })\n    let largest = charCountPairs.maxElement()!.0\n\
    \    var unicodeString = \"\"\n    let charPairs = charCountPairs.filter { $0.0\
    \ < largest }\n    for pair in charPairs {\n        let unicodeScalar = String(format:\
    \ \"\\\\u%04x\", pair.0)\n        unicodeString += String(unicodeScalar)\n   \
    \ }\n    return String(unicodeString.lowercased())", "    let romans = String::new()\n\
    \    let num: UInt32 = number\n\n    // Each line will start with a roman numeral\n\
    \    // Then an arbitrary number of digits\n    // Then the rest of the roman\
    \ numeral\n    let lineLength: Int = 9\n    let romanDigits = UInt32(0..<lineLength)\n\
    \    let romanStart: Int = num % 100\n    let romanEnd = romanStart + lineLength\n\
    \    let romanLength: Int = romanEnd - romanStart\n\n    // If the number is a\
    \ multiple of 3,5,7,9 then we have a new line\n    if romanLength == 3{\n    \
    \    romans.append(String::new())\n    }\n\n    // If the number is divisible\
    \ by 3, we just append the digit to our current line\n    if romanLength == 3\
    \ {\n        romans[romanStart] += String(UnicodeScalar(UInt32(num % 10)))\n \
    \   }\n\n    // If the number is a multiple of 5, we just append the digit to\
    \ our current line\n    if romanLength == 5{\n        romans[romanStart] += String(UnicodeScalar(UInt32(num\
    \ % 5)))\n    }\n\n    // If the number is a multiple of 7, we just append the\
    \ digit to our current line\n    if romanLength == 7{\n        romans[romanStart]\
    \ += String(UnicodeScalar(UInt32(num % 7)))\n    }\n\n    // If the number is\
    \ a multiple of 9, we just append the digit to our current line\n    if romanLength\
    \ == 9{\n        romans[romanStart] += String(UnicodeScalar(UInt32(num % 9)))\n\
    \    }\n\n    // If the number is not a multiple of 3, 5 or 7 then we append the\
    \ remainder of the number to the current line\n    romans[romanStart] += String(UnicodeScalar(UInt32(num%10)))\n\
    \n    // Return our converted string\n    return romans.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)", "    var result = \"\"\n    let a = mini_roman[number]\n\
    \    for b in mini_roman[number] {\n        result.append(b)\n    }\n    return\
    \ result", "    guard number >= 1 && number <= 999 else {\n        return \"\"\
    \n    }\n    switch number {\n    case 1:\n        return \"x\"\n    case 5:\n\
    \        return \"l\"\n    case 10:\n        return \"l\"\n    case 20:\n    \
    \    return \"c\"\n    case 50:\n        return \"m\"\n    case 100:\n       \
    \ return \"d\"\n    case 200:\n        return \"d\"\n    case 500:\n        return\
    \ \"c\"\n    case 1000:\n        return \"c\"\n    case 10000:\n        return\
    \ \"m\"\n    case 50000:\n        return \"m\"\n    case 100000:\n        return\
    \ \"d\"\n    case 500000:\n        return \"d\"\n    case 1000000:\n        return\
    \ \"d\"\n    case 5000000:\n        return \"d\"\n    case 10000000:\n       \
    \ return \"d\"\n    case 50000000:\n        return \"d\"\n    case 100000000:\n\
    \        return \"d\"\n    case 500000000:\n        return \"d\"\n    case 1000000000:\n\
    \        return \"d\"\n    case 5000000000:\n        return \"d\"\n    case 10000000000:\n\
    \        return \"m\"\n    case 50000000000:\n        return \"m\"\n    case 100000000000:\n\
    \        return \"m\"\n    case 500000000000:\n        return \"m\"\n    case\
    \ 1000000000000:\n        return \"m\"\n    case 5000000000000:\n        return\
    \ \"m\"\n    case 10000000000000:\n        return \"m\"\n    case 50000000000000:\n\
    \        return \"m\"\n    case 100000000000000:\n        return \"m\"\n    case\
    \ 500000000000000:\n        return \"m\"\n    case 1000000000000000:\n       \
    \ return \"m\"\n    case 5000000000000000:\n        return \"m\"\n    case 1000000000000000000:\n\
    \        return \"m\"\n    default:\n        guard number >= 100000 && number\
    \ <= 999999999 else {\n            return \"\"\n        }\n        let remainder\
    \ = number % 10000000\n        let hundred = number / 10000000\n        let thousand\
    \ = (number / 10000000) - hundred\n        let hundredThousand = (number / 10000000)\
    \ - thousand\n        let tens = number / 10000000 - hundredThousand\n       \
    \ let ones = number % 10000000 - tens\n        let hundreds = number / 10000000\
    \ - ones\n        let thousands = number / 10000000 - hundreds\n        let hundredThousands\
    \ = number / 10000000 - thousands\n        let tenThousands = number / 10000000\
    \ - hundredThousands\n        let oneThousands = number % 10000000 - tenThousands\n\
    \        let hundredThousands = number / 10000000 - oneThousands\n        let\
    \ thousandThousands = number / 10000000 - hundredThousands\n        let hundredThousandThousands\
    \ = number / 10000000 - thousandThousands\n        let oneThousandThousand", " \
    \   let mut numerals = [String::new()];\n    let mut i = 1;\n    while number\
    \ >= i {\n        numerals.insert(numerals.len(), String::new());\n        let\
    \ mut j = 1;\n        while number >= i * j {\n            numerals[i * j].insert(numerals[i\
    \ * j].len(), numerals[i * j - 1]);\n            j += 1;\n        }\n        numerals[i\
    \ * j - 1].insert(numerals[i * j - 1].len(), numerals[i]);\n        i += 1;\n\
    \    }\n    numerals.insert(0, String::new());\n    return numerals.iter()\n \
    \       .map(|x| x.iter()\n            .map(|y| y.to_ascii_lowercase().to_string())\n\
    \            .collect::<Vec<_>>())\n        .collect::<Vec<_>>()\n        .join(\"\
    \");", "    // TODO: Simplify this code.\n    // Make array of all digits in number\n\
    \    let digits = Array(0..<number)\n    // Loop through digits from left to right\n\
    \    for index in digits.reverse() {\n        // Find if digit is even or odd\n\
    \        var isOdd: Bool = false\n        if index % 2 == 0 {\n            isOdd\
    \ = true\n        }\n\n        // Find number of times digit appears in number\n\
    \        // NOTE: This is kind of weird. The number of times digit appears is\n\
    \        // equal to the number of times digit appears in the number divided by\
    \ 10.\n        // So it's like counting how many times '0' appears in the number.\n\
    \        var numberOfTimesDigitAppears: Int = number / 10\n        // Check if\
    \ number has more then one digit\n        if number % 10 != 0 {\n            //\
    \ If number has more than one digit\n            numberOfTimesDigitAppears +=\
    \ 1\n        }\n\n        // Make array of characters to put into string\n   \
    \     var characters = Array<Character>(count: numberOfTimesDigitAppears, repeatedValue:\
    \ Character(\"0\"))\n\n        // Check if digit is odd and put it into appropriate\
    \ array\n        if isOdd {\n            characters[numberOfTimesDigitAppears\
    \ - 1] = \"1\"\n        }\n\n        // Put character at appropriate index\n \
    \       characters[index] = String(format: \"%c\", characters[index])\n\n    \
    \    // Make string from character array\n        let miniRoman = characters.joinWithSeparator(\"\
    \")\n\n        // Make lowercase\n        return miniRoman.lowercased()\n    }",
  "    var roman = \"\"\n    let romans = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"\
    XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"]\n    \n    if number\
    \ < 0 || number > 1000 {\n        \n        let message = NSLocalizedString(\"\
    The number must be in the range 0-1000.\", comment: \"The input value out of range.\"\
    )\n        \n        return message\n    }\n    \n    for i in 0..<romans.count\
    \ {\n        \n        if romans.count > number {\n            \n            if\
    \ romans[i] == romans[number] {\n                \n                if i == 0 {\n\
    \                    \n                    roman = romans[0]\n               \
    \ }\n                \n                roman = romans[i] + roman\n           \
    \ }\n            \n            else {\n                \n                if number\
    \ - i >= 0 {\n                    \n                    roman = romans[number\
    \ - i] + roman\n                }\n            }\n        }\n        \n      \
    \  else {\n            \n            if romans[i] == romans[number] {\n      \
    \          \n                if i == 0 {\n                    \n             \
    \       roman = romans[0]\n                }\n                \n             \
    \   roman = romans[i] + roman\n            }\n            \n            else {\n\
    \                \n                if number - i >= 0 {\n                    \n\
    \                    roman = romans[number - i] + roman\n                }\n \
    \           }\n        }\n    }\n    \n    return roman.lowercased()", "    if\
    \ number < 1 || number > 1000 {\n        return \"\"\n    }\n    var roman = \"\
    \"\n    let roman_alphabet = \"MCMXCIV\"\n    for _ in 1..<number {\n        let\
    \ idx = roman_alphabet.index(roman_alphabet.startIndex, offsetBy: 1)\n       \
    \ let char = roman_alphabet[idx]\n        roman += char\n    }\n    return roman.lowercased()",
  "    guard number > 0 && number <= 1000 else {\n        return \"Invalid input\"\
    \n    }\n\n    var result = \"\"\n\n    // Romans\n    let hundredsAndUp = number\
    \ / 100\n    let onesAndUp = number % 100\n    switch onesAndUp {\n    case 10:\n\
    \        result += \"c\"\n    case 11:\n        result += \"l\"\n    case 12:\n\
    \        result += \"m\"\n    case 13:\n        result += \"x\"\n    case 14:\n\
    \        result += \"vi\"\n    case 15:\n        result += \"iv\"\n    case 16:\n\
    \        result += \"i\"\n    case 17:\n        result += \"ii\"\n    case 18:\n\
    \        result += \"xii\"\n    case 19:\n        result += \"ci\"\n    case 20:\n\
    \        result += \"vii\"\n    case 21:\n        result += \"viii\"\n    case\
    \ 22:\n        result += \"ix\"\n    case 23:\n        result += \"cix\"\n   \
    \ case 24:\n        result += \"lx\"\n    case 25:\n        result += \"ixl\"\n\
    \    case 26:\n        result += \"cxl\"\n    case 27:\n        result += \"iclx\"\
    \n    case 28:\n        result += \"ixcl\"\n    case 29:\n        result += \"\
    iclxl\"\n    case 30:\n        result += \"cixcl\"\n    case 31:\n        result\
    \ += \"vixcl\"\n    case 32:\n        result += \"viixl\"\n    case 33:\n    \
    \    result += \"ixvix\"\n    case 34:\n        result += \"clxxx\"\n    case\
    \ 35:\n        result += \"lxxx\"\n    case 36:\n        result += \"cxxx\"\n\
    \    case 37:\n        result += \"xvix\"\n    case 38:\n        result += \"\
    xxvix\"\n    case 39:\n        result += \"xixvi\"\n    case 40:\n        result\
    \ += \"xxvii\"\n    case 41:\n        result += \"xviii\"\n    case 42:\n    \
    \    result += \"cxxxii\"\n    case 43:\n        result += \"xviiii\"\n    case\
    \ 44:\n        result += \"xxxiii\"\n    case 45:\n        result += \"cxxxi\"\
    \n    case 46:\n        result += \"cvix\"\n    case 47:\n        result += \"\
    cvii\"\n    case 48:\n        result += \"cviii\"\n    case 49:\n        result\
    \ += \"clii\"\n    case 50:\n        result += \"clvi\"\n    case 51:\n      \
    \  result += \"clvii\"\n    case 52:\n        ", "    guard number >= 1 else {\n\
    \        return \"\"\n    }\n    var result = \"\"\n    let alphabet = miniRomanAlphabet()\n\
    \    let alphabetSize = alphabet.count\n    if number == 1 {\n        result =\
    \ alphabet[0]\n    }\n    if number > 1 { // special handling for numbers greater\
    \ than one\n        let remainder = number % 10\n        let quotient = number\
    \ / 10\n        if quotient == 0 {\n            result = \"0\"\n        }\n  \
    \      else if quotient > 0 {\n            if remainder >= alphabetSize {\n  \
    \              let diff = remainder - alphabetSize\n                result = \"\
    \\(alphabet[diff])\"\n            } else {\n                result = \"\\(alphabet[remainder])\"\
    \n            }\n        }\n    }\n    return result", "    // Find out how many\
    \ times to repeat the previous result\n    var romanRepeat = countOfDivisors(number:\
    \ number)\n\n    // Determine how many times this new result will go through the\
    \ previous result\n    var numRepeat = number / romanRepeat\n\n    // Repeat that\
    \ previous result this number of times\n    let miniRoman = repeatString(string:\
    \ mini_roman, number: romanRepeat)\n\n    // Add the result\n    return miniRoman\
    \ + repeatString(string: mini_roman, number: numRepeat)", "    if number < 1 ||\
    \ number > 999 {\n        fatalError(\"Int must be between 1 and 999\")\n    }\n\
    \    let miniRomanNumerals: String = {\n        switch number {\n        case\
    \ 1:\n            return \"i\"\n        case 2:\n            return \"ii\"\n \
    \       case 3:\n            return \"iii\"\n        case 4:\n            return\
    \ \"iv\"\n        case 5:\n            return \"v\"\n        case 6:\n       \
    \     return \"vi\"\n        case 7:\n            return \"vii\"\n        case\
    \ 8:\n            return \"viii\"\n        case 9:\n            return \"ix\"\n\
    \        case 10:\n            return \"x\"\n        case 11:\n            return\
    \ \"xi\"\n        case 12:\n            return \"xii\"\n        case 13:\n   \
    \         return \"xiii\"\n        case 14:\n            return \"xiv\"\n    \
    \    case 15:\n            return \"xv\"\n        case 16:\n            return\
    \ \"xvi\"\n        case 17:\n            return \"xvii\"\n        case 18:\n \
    \           return \"xviii\"\n        case 19:\n            return \"xix\"\n \
    \       case 20:\n            return \"xx\"\n        case 21:\n            return\
    \ \"xxi\"\n        case 22:\n            return \"xxii\"\n        case 23:\n \
    \           return \"xxiii\"\n        case 24:\n            return \"xxiv\"\n\
    \        case 25:\n            return \"xxv\"\n        case 26:\n            return\
    \ \"xxvi\"\n        case 27:\n            return \"xxvii\"\n        case 28:\n\
    \            return \"xxviii\"\n        case 29:\n            return \"xxix\"\n\
    \        case 30:\n            return \"xxx\"\n        case 31:\n            return\
    \ \"xxxi\"\n        case 32:\n            return \"xxxiv\"\n        case 33:\n\
    \            return \"xxxv\"\n        case 34:\n            return \"xxxi\"\n\
    \        case 35:\n            return \"xxvi\"\n        case 36:\n           \
    \ return \"xxvii\"\n        case 37:\n            return \"xxviii\"\n        case\
    \ 38:\n            return \"xxix\"\n        case 39:\n            return \"xxxiv\"\
    \n        case 40:\n            return \"xxv\"\n        case 41:\n           \
    \ return \"xxvi\"\n        case 42:\n            return \"xxvii\"\n        case\
    \ 43:\n            return \"xxviii\"\n        case 44:\n            return \"\
    xxi\"\n        case 45:\n            return \"xxii\"\n        case 46:\n     \
    \       return \"xxiii\"\n        case 47:\n            return \"xxiv\"\n    \
    \    case 48:\n            return \"xxv\"\n        case 49:\n            return\
    \ \"xxvi\"\n        case 50:\n            return \"xxvii\"\n        case 51:\n\
    \            return \"xxviii\"\n        case 52:\n            return \"xxi\"\n\
    \        case 53:\n            return \"xxii\"\n        case 54:\n           \
    \ return \"xxiii\"\n        case 55:\n            return \"xxiv\"\n        case\
    \ 56:\n", "    var result = \"\"\n    for number > 1000 { result += \"M\"\n  \
    \      number -= 1000\n    }\n    result += String(number % 1000) + String(number\
    \ / 1000)\n    return result", "    let numeral = MiniRomanNumber(number)\n  \
    \  return numeral.lowercased", "    if number < 1 || number > 1000 {\n       \
    \ return \"Invalid input\"\n    }\n    var result: String = \"\"\n    if number\
    \ == 1 {\n        result = \"x\"\n    }\n    if number == 5 {\n        result\
    \ = \"l\"\n    }\n    if number == 10 {\n        result = \"x\"\n    }\n    if\
    \ number == 50 {\n        result = \"l\"\n    }\n    if number == 100 {\n    \
    \    result = \"c\"\n    }\n    if number == 500 {\n        result = \"cc\"\n\
    \    }\n    if number == 1000 {\n        result = \"d\"\n    }\n    return result",
  '    return mini_roman(number: number)', "    let roman = Roman(number: number)\n\
    \    return roman.miniRomanNumeralLowercase()", "    var roman_numeral = String()\n\
    \    if number == 0 {\n        return \"\"\n    }\n\n    let mut roman_value =\
    \ 0\n    let mut current_roman_numeral = String()\n\n    // Initialize our roman/numeral\
    \ values using the following formulas:\n    //\n    // Roman/Numeral Value\n \
    \   // --------------\n    // I         1\n    // V         5\n    // X      \
    \   10\n    // L         50\n    // C         100\n    // D         500\n    //\
    \ M         1000\n    //\n    // Additionally we store a pointer to the next value\
    \ and the previous\n    // value in our struct, which will allow us to traverse\
    \ the list\n    // incrementally (by using the next_value & prev_value members).\n\
    \    //\n    // Example of how it works (we start at 'M'):\n    // M         \
    \    1000\n    // I             100\n    // N             1000\n    // V     \
    \        5\n    // X             10\n    // L             50\n    // C       \
    \      100\n    // D             500\n    // M             1000\n    //\n    //\
    \ As you can see we keep track of our current numeral and roman value\n    //\
    \ by storing the next value in our struct and our current roman\n    // value\
    \ in our struct.\n    //\n    // Also keep in mind that we are incrementally traversing\
    \ the list,\n    // so our current numeral and roman value will always be the\
    \ most\n    // recent value added to the list.\n\n    // Initialize our pointers\n\
    \    struct romanPointer {\n        roman_value : Int,\n        roman_numeral\
    \ : String,\n        prev_value : Int,\n        next_value : Int,\n    }\n\n \
    \   // Initialize our variables\n    let mut roman_numeral_pointer = romanPointer{\n\
    \        roman_value : 1,\n        roman_numeral : \"\",\n        prev_value :\
    \ 0,\n        next_value : 0,\n    }\n\n    // Initialize our current roman/numeral\n\
    \    current_roman_numeral = \"M\"\n\n    // Start traversing our list from our\
    \ current numeral and roman value\n    for num in 0..<number {\n\n        // Calculate\
    \ the next roman value\n        let roman_value = roman_numeral_pointer.roman_value\
    \ + roman_numeral_pointer.roman_numeral.count\n\n        // Calculate the next\
    \ numeral\n        let numeral = roman_value * roman_numeral_pointer.roman_numeral.characters.count\n\
    \n        // If the current numeral does not equal the previous numeral, and\n\
    \        // if we have an integer, add it to the string\n        if numeral ==\
    \ roman_numeral_pointer.prev_value && numeral % 1 == 0 {\n            roman_numer",
  "    var numerals: [String] = []\n    var counter: Int = 0\n    var numeral: Int\
    \ = 0\n    var roman: Int = 0\n    var previous: Int = 0\n    var temp: Int =\
    \ 0\n    var index: Int = 0\n\n    for numeral in numbersToRoman(number) {\n \
    \       if (numerals.count > index) {\n            numerals[index] = \"x\"\n \
    \       }\n        numerals[index] = numerals[numeral]\n        index += 1\n \
    \   }\n\n    while counter < 5 {\n        roman = counter * 10 + numerals.count\
    \ - 9\n        if (roman > previous) {\n            numerals.insertSubstringWithRange(NSMakeRange(previous,\
    \ 1), romanStringFromInt(roman))\n        } else {\n            numerals.insertSubstringWithRange(NSMakeRange(previous,\
    \ 1), romanStringFromInt(roman))\n            numerals.removeLast()\n        }\n\
    \        counter += 1\n        previous = roman\n    }\n\n    let romanString\
    \ = numerals.joinWithSeparator(\"\")\n    let lowercase = romanString.lowercaseString\n\
    \    return lowercase", "    let romanString = int_to_roman(number)\n    return\
    \ romanString.lowercased()", "  if number < 0 || number > 1000 {\n    return \"\
    \"\n  }\n  // Find the first thousand and multiply it by tens.\n  var thousand\
    \ = number\n  var result: String = \"\"\n  while thousand >= 1000 {\n    thousand\
    \ -= 1000\n    result += \"M\"\n  }\n  // Find the remaining thousand.\n  thousand\
    \ = number\n  while thousand >= 1000 {\n    thousand -= 1000\n    result += \"\
    CM\"\n  }\n  // Find the remaining thousand.\n  thousand = number\n  while thousand\
    \ >= 1000 {\n    thousand -= 1000\n    result += \"D\"\n  }\n  // Find the remaining\
    \ thousand.\n  thousand = number\n  while thousand >= 1000 {\n    thousand -=\
    \ 1000\n    result += \"CD\"\n  }\n  // Find the remaining thousand.\n  thousand\
    \ = number\n  while thousand >= 1000 {\n    thousand -= 1000\n    result += \"\
    C\"\n  }\n  // Find the remaining thousand.\n  thousand = number\n  while thousand\
    \ >= 1000 {\n    thousand -= 1000\n    result += \"XC\"\n  }\n  // Find the remaining\
    \ thousand.\n  thousand = number\n  while thousand >= 1000 {\n    thousand -=\
    \ 1000\n    result += \"L\"\n  }\n  // Find the remaining thousand.\n  thousand\
    \ = number\n  while thousand >= 1000 {\n    thousand -= 1000\n    result += \"\
    XL\"\n  }\n  // Find the remaining thousand.\n  thousand = number\n  while thousand\
    \ >= 1000 {\n    thousand -= 1000\n    result += \"X\"\n  }\n  // Find the remaining\
    \ thousand.\n  thousand = number\n  while thousand >= 1000 {\n    thousand -=\
    \ 1000\n    result += \"IX\"\n  }\n  // Find the remaining thousand.\n  thousand\
    \ = number\n  while thousand >= 1000 {\n    thousand -= 1000\n    result += \"\
    V\"\n  }\n  // Find the remaining thousand.\n  thousand = number\n  while thousand\
    \ >= 1000 {\n    thousand -= 1000\n    result += \"IV\"\n  }\n  // Find the remaining\
    \ thousand.\n  thousand = number\n  while thousand >= 1000 {\n    thousand -=\
    \ 1000\n    result += \"I\"\n  }\n  // Remove the final \"IX\" from the string.\n\
    \  if result.last == \"X\" {\n    result.removeLast()\n  }\n  return result",
  "  var ret = \"\"\n  for i in 0..<Int(number) {\n    let digit = number % 10\n \
    \   ret += mini_roman[digit]\n    number /= 10\n  }\n  return ret.lowercased()",
  "    guard number >= 1 && number <= 999 else {\n        return \"\"\n    }\n\n \
    \   let numberString = String(number)\n    var romanString = \"\"\n\n    // Round\
    \ down to nearest \"M\"\n    let roundedDown = floor(number / 1000)\n    let remainder\
    \ = number % 1000\n\n    // Convert remainder to roman\n    if remainder > 500\
    \ {\n        // Add \"C\" and subtract 1 to remainder\n        romanString = \"\
    C\" + romanString + \"x\"\n        number -= 1000\n    } else if remainder > 400\
    \ {\n        // Add \"D\" and subtract 1 to remainder\n        romanString = \"\
    D\" + romanString + \"x\"\n        number -= 100\n    } else if remainder > 300\
    \ {\n        // Add \"M\" and subtract 1 to remainder\n        romanString = \"\
    M\" + romanString + \"x\"\n        number -= 10\n    } else if remainder > 200\
    \ {\n        // Add \"CM\" and subtract 1 to remainder\n        romanString =\
    \ \"CM\" + romanString + \"x\"\n        number -= 5\n    } else if remainder >\
    \ 100 {\n        // Add \"DCC\" and subtract 1 to remainder\n        romanString\
    \ = \"DCC\" + romanString + \"x\"\n        number -= 4\n    } else if remainder\
    \ > 50 {\n        // Add \"CD\" and subtract 1 to remainder\n        romanString\
    \ = \"CD\" + romanString + \"x\"\n        number -= 3\n    } else if remainder\
    \ > 20 {\n        // Add \"C\" and subtract 1 to remainder\n        romanString\
    \ = \"C\" + romanString + \"x\"\n        number -= 1\n    } else if remainder\
    \ > 10 {\n        // Add \"XC\" and subtract 1 to remainder\n        romanString\
    \ = \"XC\" + romanString + \"x\"\n        number -= 1\n    } else if remainder\
    \ > 5 {\n        // Add \"L\" and subtract 1 to remainder\n        romanString\
    \ = \"L\" + romanString + \"x\"\n        number -= 1\n    } else if remainder\
    \ > 4 {\n        // Add \"XL\" and subtract 1 to remainder\n        romanString\
    \ = \"XL\" + romanString + \"x\"\n        number -= 1\n    } else if remainder\
    \ > 3 {\n        // Add \"X\" and subtract 1 to remainder\n        romanString\
    \ = \"X\" + romanString + \"x\"\n        number -= 1\n    } else if remainder\
    \ > 2 {\n        // Add \"IX\" and subtract 1 to remainder\n        romanString\
    \ = \"", "    if number < 1 || number > 1000 {\n        // Only a restricted subset\
    \ are allowed.\n        fatalError(\"Invalid roman_numeral number \\(number).\"\
    )\n    }\n\n    var result = \"\"\n    var numerals: [(Int,Int)] = []\n    var\
    \ numeral: Int\n    var remainder: Int\n    for numeral = number; numeral > 0;\
    \ numeral /= 10 {\n        remainder = numeral % 10\n        numerals.append((numeral,\
    \ remainder))\n    }\n\n    for numeral in numerals {\n        var numeralChar\
    \ = mini_roman_to_string(numeral.0)\n        if numeral.1 == 0 {\n           \
    \ return numeralChar\n        }\n\n        var numeralCharDigit = numeralChar\n\
    \        for _ in 0..<numeral.1 {\n            numeralCharDigit += mini_roman_to_string(numeral.1)\n\
    \        }\n        result += numeralCharDigit\n    }\n    return result", " \
    \   // Initialize variables\n    var roman = \"\"\n\n    // Convert the number\
    \ to its roman numeral equivalent as a string\n    switch number {\n    case 1:\n\
    \        roman = \"I\"\n    case 2:\n        roman = \"II\"\n    case 3:\n   \
    \     roman = \"III\"\n    case 4:\n        roman = \"IV\"\n    case 5:\n    \
    \    roman = \"V\"\n    case 6:\n        roman = \"VI\"\n    case 7:\n       \
    \ roman = \"VII\"\n    case 8:\n        roman = \"VIII\"\n    case 9:\n      \
    \  roman = \"IX\"\n    case 10:\n        roman = \"X\"\n    case 11:\n       \
    \ roman = \"XI\"\n    case 12:\n        roman = \"XII\"\n    case 13:\n      \
    \  roman = \"XIII\"\n    case 14:\n        roman = \"XIV\"\n    case 15:\n   \
    \     roman = \"XV\"\n    case 16:\n        roman = \"XVI\"\n    case 17:\n  \
    \      roman = \"XVII\"\n    case 18:\n        roman = \"XVIII\"\n    case 19:\n\
    \        roman = \"XIX\"\n    case 20:\n        roman = \"XX\"\n    case 21:\n\
    \        roman = \"XXI\"\n    case 22:\n        roman = \"XXII\"\n    case 23:\n\
    \        roman = \"XXIII\"\n    case 24:\n        roman = \"XXIV\"\n    case 25:\n\
    \        roman = \"XXV\"\n    case 26:\n        roman = \"XXVI\"\n    case 27:\n\
    \        roman = \"XXVII\"\n    case 28:\n        roman = \"XXVIII\"\n    case\
    \ 29:\n        roman = \"XXIX\"\n    case 30:\n        roman = \"XXX\"\n    case\
    \ 31:\n        roman = \"XXIII\"\n    case 32:\n        roman = \"XXIV\"\n   \
    \ case 33:\n        roman = \"XXV\"\n    case 34:\n        roman = \"XXVI\"\n\
    \    case 35:\n        roman = \"XXVII\"\n    case 36:\n        roman = \"XXVIII\"\
    \n    case 37:\n        roman = \"XXIX\"\n    case 38:\n        roman = \"XXXI\"\
    \n    case 39:\n        roman = \"XXXII\"\n    case 40:\n        roman = \"XXXIII\"\
    \n    case 41:\n        roman = \"XXXIV\"\n    case 42:\n        roman = \"XXXV",
  "    let roman = IntToRoman(number)\n\n    return roman.lowercaseString", "    let\
    \ roman = RomanNumerals.init(number)\n    let mut s = \"\"\n    for i in roman.roman_numerals()\
    \ {\n        s += i.to_lowercase()\n    }\n    strings.lowercase.add_prefix(s)\n\
    \    return s", "    guard number >= 1 && number <= 1000 else {\n        return\
    \ \"\"\n    }\n\n    let romanNumeral = createRomanNumeral(number)\n\n    return\
    \ romanNumeral.lowercased()", "    if number < 1 || number > 1000 {\n        Log.fatal(number,\
    \ \"Int must be between 1 and 1000\")\n    }\n\n    var roman = \"\"\n    var\
    \ currentNum = number\n\n    let numPerMiniRoman = \"xc\"\n    let numPerFullRoman\
    \ = \"dlxvi\"\n\n    var romanLength = 0\n\n    while (currentNum > 0) {\n   \
    \     let romanDigit = currentNum % 100\n\n        if romanDigit > 0 {\n     \
    \       currentNum = currentNum / 100\n            roman += numPerMiniRoman[romanDigit]\n\
    \        }\n\n        romanLength += 1\n\n        if (romanLength % 5) == 0 {\n\
    \            roman += numPerFullRoman[(romanLength / 5) % 10]\n        }\n   \
    \ }\n\n    return roman.lowercased()", "    guard number >= 1 && number <= 1000\
    \ else { return \"\" }\n    let result = \"\"\n    var remainder: Int = 0\n  \
    \  while number >= 10 {\n        remainder = number % 10\n        number -= remainder\n\
    \        result += \"m\" + String(remainder)\n    }\n    if number != 0 {\n  \
    \      remainder = number\n        result += \"m\" + String(remainder)\n    }\n\
    \    return result.lowercased()", "    if number < 1 || number > 1000 { return\
    \ \"\" }\n    var roman = \"\"\n    for number in 1...number {\n        var remainder:\
    \ Int\n        switch number % 100 {\n        case 12:\n            remainder\
    \ = number%10\n        case 11:\n            remainder = number%10+12\n      \
    \  case 10:\n            remainder = number%10+12\n        default:\n        \
    \    remainder = number%10\n        }\n        roman += mini_roman[remainder]\n\
    \    }\n    return roman.lowercased()", "    let int2roman = Int2Roman(number:\
    \ int)\n    return int2roman", "    guard number <= 1000 else { return \"\" }\n\
    \    let romanNumerals: [String?] = [\n        [\"M\", \"MM\", \"MMM\"],\n   \
    \     [\"C\", \"CC\", \"CCC\"],\n        [\"L\", \"XL\", \"XLI\"],\n        [\"\
    X\", \"XX\", \"XXX\"],\n        [\"V\", \"IV\", \"VII\"],\n        [\"I\", \"\
    II\", \"III\"],\n        [\"N\", \"NN\", \"NNN\"],\n        [\"D\", \"DD\", \"\
    DDD\"],\n        [\"C\", \"CC\", \"CCC\"],\n        [\"M\", \"MM\", \"MMM\"],\n\
    \        [\"D\", \"DD\", \"DDD\"],\n        [\"C\", \"CC\", \"CCC\"],\n      \
    \  [\"X\", \"XX\", \"XXX\"],\n        [\"V\", \"IV\", \"VII\"],\n        [\"I\"\
    , \"II\", \"III\"],\n        [\"N\", \"NN\", \"NNN\"],\n        [\"D\", \"DD\"\
    , \"DDD\"],\n        [\"C\", \"CC\", \"CCC\"],\n        [\"X\", \"XX\", \"XXX\"\
    ],\n        [\"V\", \"IV\", \"VII\"],\n        [\"I\", \"II\", \"III\"],\n   \
    \     [\"N\", \"NN\", \"NNN\"],\n        [\"D\", \"DD\", \"DDD\"],\n        [\"\
    C\", \"CC\", \"CCC\"],\n        [\"X\", \"XX\", \"XXX\"],\n        [\"V\", \"\
    IV\", \"VII\"],\n        [\"I\", \"II\", \"III\"],\n        [\"N\", \"NN\", \"\
    NNN\"],\n        [\"D\", \"DD\", \"DDD\"],\n        [\"C\", \"CC\", \"CCC\"],\n\
    \        [\"X\", \"XX\", \"XXX\"],\n        [\"V\", \"IV\", \"VII\"],\n      \
    \  [\"I\", \"II\", \"III\"],\n        [\"N\", \"NN\", \"NNN\"],\n        [\"D\"\
    , \"DD\", \"DDD\"],\n        [\"C\", \"CC\", \"CCC\"],\n        [\"X\", \"XX\"\
    , \"XXX\"],\n        [\"V\", \"IV\", \"VII\"],\n        [\"I\", \"II\", \"III\"\
    ],\n        [\"N\", \"NN\", \"NNN\"],\n        [\"D\", \"DD\", \"DDD\"],\n   \
    \     [\"C\", \"CC\", \"CCC\"],\n        [\"X\", \"XX\", \"XXX\"],\n        [\"\
    V\", \"IV\", \"VII\"],\n        [\"I\", \"II\", \"III\"],\n        [\"N\", \"\
    NN\", \"NNN\"],\n        [\"D\", \"DD\", \"DDD\"],\n        [\"C\", \"CC\", \"\
    CCC\"],\n        [\"X\", \"XX\", \"XXX\"],\n        [\"V\", \"IV\", \"VII\"],\n\
    \        ", "    if number == 0 {\n        return \"\"\n    }\n\n    func isDigit(_\
    \ c1: Character, _ c2: Character, _ num: Int) -> Bool {\n        let num = Int(num\
    \ * 10)\n        let mul = c2 != \"x\" ? String(num) : \"X\"\n        let mul2\
    \ = c2 != \"x\" ? String(num + 1) : \"C\"\n        let mul3 = c2 != \"x\" ? String(num\
    \ + 10) : \"D\"\n        let mul4 = c2 != \"x\" ? String(num + 100) : \"E\"\n\
    \        let mul5 = c2 != \"x\" ? String(num + 1000) : \"F\"\n        let mul6\
    \ = c2 != \"x\" ? String(num + 10000) : \"G\"\n        let mul7 = c2 != \"x\"\
    \ ? String(num + 100000) : \"H\"\n        let mul8 = c2 != \"x\" ? String(num\
    \ + 1000000) : \"I\"\n        let mul9 = c2 != \"x\" ? String(num + 10000000)\
    \ : \"J\"\n        let mul10 = c2 != \"x\" ? String(num + 100000000) : \"K\"\n\
    \        let mul11 = c2 != \"x\" ? String(num + 1000000000) : \"L\"\n        let\
    \ mul12 = c2 != \"x\" ? String(num + 10000000000) : \"M\"\n        let mul13 =\
    \ c2 != \"x\" ? String(num + 100000000000) : \"N\"\n        let mul14 = c2 !=\
    \ \"x\" ? String(num + 1000000000000) : \"O\"\n        let mul15 = c2 != \"x\"\
    \ ? String(num + 10000000000000) : \"P\"\n        let mul16 = c2 != \"x\" ? String(num\
    \ + 100000000000000) : \"Q\"\n        let mul17 = c2 != \"x\" ? String(num + 10000000000000000)\
    \ : \"R\"\n        let mul18 = c2 != \"x\" ? String(num + 100000000000000000)\
    \ : \"S\"\n        let mul19 = c2 != \"x\" ? String(num + 1000000000000000000)\
    \ : \"T\"\n        let mul20 = c2 != \"x\" ? String(num + 10000000000000000000)\
    \ : \"U\"\n        let mul21 = c2 != \"x\" ? String(num + 100000000000000000000)\
    \ : \"V\"\n        let mul22 = c2 != \"x\" ? String(num + 1000000000000000000000)\
    \ : \"W\"\n        let mul23 = c2 != \"x\" ? String(num + 10000000000000000000000)\
    \ : \"X\"\n        let mul24 = c2 != \"x\" ? String(num + 1000000000000000000000000)\
    \ : \"Y\"\n        let mul25 = c2 != \"x\" ? String(num + 10000000000000000000000000)\
    \ : \"Z\"\n        return c1 < mul && c2 < mul\n    }\n\n    var roman = \"\"\n\
    \    var romanString: String = \"\"\n\n    if number ", "    let romanNumerals:\
    \ [String] = [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\"\
    , \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\"\
    , \"XVIII\", \"XIX\"]\n    let minMax = [1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1]\n    var numeral: String = \"\"\n    var i = 0\n    guard number\
    \ > 0 else { return \"\" }\n    guard number <= maxInt else { return \"\" }\n\
    \    if number > minMax.last {\n        return \"\"\n    }\n    while i < minMax.first\
    \ {\n        numeral += romanNumerals[i]\n        i += 1\n    }\n    guard number\
    \ >= minMax.last, let firstNumber = number - minMax.last else { return \"\" }\n\
    \    let lastNumber = number + minMax.first\n    let currentIndex = 0\n    while\
    \ currentIndex < minMax.first {\n        if currentIndex + minMax[currentIndex]\
    \ < lastNumber {\n            numeral += romanNumerals[minMax[currentIndex]]\n\
    \            currentIndex += 1\n        } else {\n            numeral += romanNumerals[firstNumber\
    \ - minMax[currentIndex]]\n            break\n        }\n    }\n    return numeral.lowercased()",
  "\tlet str = \"\"\n\tlet i = number\n\n\tswitch i {\n\tcase 1:\n\t\tstr += \"i\"\
    \n\tcase 2:\n\t\tstr += \"ii\"\n\tcase 3:\n\t\tstr += \"iii\"\n\tcase 4:\n\t\t\
    str += \"iv\"\n\tcase 5:\n\t\tstr += \"v\"\n\tcase 6:\n\t\tstr += \"vi\"\n\tcase\
    \ 7:\n\t\tstr += \"vii\"\n\tcase 8:\n\t\tstr += \"viii\"\n\tcase 9:\n\t\tstr +=\
    \ \"ix\"\n\tcase 10:\n\t\tstr += \"x\"\n\tcase 11:\n\t\tstr += \"xi\"\n\tcase\
    \ 12:\n\t\tstr += \"xii\"\n\tcase 13:\n\t\tstr += \"xiii\"\n\tcase 14:\n\t\tstr\
    \ += \"xiv\"\n\tcase 15:\n\t\tstr += \"xv\"\n\tcase 16:\n\t\tstr += \"xvi\"\n\t\
    case 17:\n\t\tstr += \"xvii\"\n\tcase 18:\n\t\tstr += \"xviii\"\n\tcase 19:\n\t\
    \tstr += \"xx\"\n\tcase 20:\n\t\tstr += \"y\"\n\tcase 21:\n\t\tstr += \"yy\"\n\
    \tcase 22:\n\t\tstr += \"yyy\"\n\tcase 23:\n\t\tstr += \"yyyy\"\n\tcase 24:\n\t\
    \tstr += \"z\"\n\tcase 25:\n\t\tstr += \"z\"\n\tcase 26:\n\t\tstr += \"z\"\n\t\
    case 27:\n\t\tstr += \"z\"\n\tcase 28:\n\t\tstr += \"z\"\n\tcase 29:\n\t\tstr\
    \ += \"z\"\n\tcase 30:\n\t\tstr += \"z\"\n\tcase 31:\n\t\tstr += \"z\"\n\tcase\
    \ 32:\n\t\tstr += \"aa\"\n\tcase 33:\n\t\tstr += \"aaa\"\n\tcase 34:\n\t\tstr\
    \ += \"aaaa\"\n\tcase 35:\n\t\tstr += \"aaaaa\"\n\tcase 36:\n\t\tstr += \"aaaaaa\"\
    \n\tcase 37:\n\t\tstr += \"aaaaaaa\"\n\tcase 38:\n\t\tstr += \"aaaaaaaa\"\n\t\
    case 39:\n\t\tstr += \"aaaaaaaab\"\n\tcase 40:\n\t\tstr += \"aaaaaaaa\"\n\tcase\
    \ 41:\n\t\tstr += \"aaaaaaaaa\"\n\tcase 42:\n\t\tstr += \"aaaaaaaaaa\"\n\tcase\
    \ 43:\n\t\tstr += \"aaaaaaaaaaa\"\n\tcase 44:\n\t\tstr += \"aaaaaaaaaaaa\"\n\t\
    case 45:\n\t\tstr += \"aaaaaaaaaaaaa\"\n\tcase 46:\n\t\tstr += \"", "    if number\
    \ < 1 || number > 1000 {\n        return \"\"\n    }\n    // The Roman numeral\
    \ system starts with 1, and the first Roman numeral is I.\n    var roman : String\
    \ = String()\n\n    // Iterate over each digit, left to right, counting from 1\
    \ to N.\n    for digit in String(number, radix: 10, uppercase: false) {\n    \
    \    // Calculate the value of M (as M * 10 = N * 10 + M):\n        var m : Int?\n\
    \        if let n = Int(digit) {\n            m = Int(n * 10)\n        }\n   \
    \     if let m = m {\n            // The previous Roman numeral already has its\
    \ first digit\n            // subtracted, so M * 10 - M will equal N - M:\n  \
    \          m--\n        }\n\n        // Check if Roman numeral is M or larger\
    \ (in which case it can be skipped):\n        if m < 10 {\n            roman +=\
    \ \"i\"\n        } else {\n            // Set the appropriate numeral for this\
    \ digit:\n            switch m {\n            case 1:\n                roman +=\
    \ \"i\"\n            case 2:\n                roman += \"ii\"\n            case\
    \ 3:\n                roman += \"iii\"\n            case 4:\n                roman\
    \ += \"iv\"\n            case 5:\n                roman += \"v\"\n           \
    \ case 6:\n                roman += \"vi\"\n            case 7:\n            \
    \    roman += \"vii\"\n            case 8:\n                roman += \"viii\"\n\
    \            case 9:\n                roman += \"ix\"\n            case 10:\n\
    \                roman += \"x\"\n            default:\n                roman =\
    \ \"???\"\n            }\n        }\n    }\n    // Now that the roman numeral\
    \ is complete, remove trailing \"x\".\n    roman = roman.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n    return roman", "    let numberStr = String(number)\n\
    \    var roman = \"\"\n    for i in 0..<numberStr.characters.count {\n       \
    \ roman += mini_roman_to_int(character: numberStr.characters.utf16[i])\n    }\n\
    \    return roman.lowercased()", "    var roman = \"\"\n    if number < 0 || number\
    \ > 999 {\n        return \"\"\n    }\n    for num in 0...number {\n        let\
    \ str = int_to_roman(number)\n        if str.isEmpty {\n            return \"\"\
    \n        }\n        let char = str.first!\n        let roman = (roman + char).lowercased()\n\
    \        number = number / 10\n    }\n    return roman", "    let roman =\n  \
    \      mini_roman[number % 10]\n        + mini_roman[(number % 100) - (number\
    \ % 10)]\n        + \"x\"\n        + mini_roman[(number % 100) - (number % 10)\
    \ - 1]\n    return roman", "    let base: Roman =\n        numberToRoman {\n \
    \           let digit = Int64(number) % 100\n            let index = Int(Int64(number)\
    \ / 100)\n            let result = base.romanDigit(digit)\n            if index\
    \ == 0 {\n                return result\n            } else {\n              \
    \  return result + base.romanDigit(index)\n            }\n        }\n    return\
    \ base.toLower()", "  var roman = \"\"\n  for var i = number; i >= 1; i-- {\n\
    \    roman = (roman * 100) + roman_map[Int(i)]\n  }\n  return roman.lowercased()",
  "    // Only for positive numbers\n    if number <= 0 || number >= 1000 {\n    \
    \    return \"\"\n    }\n\n    // Round down to nearest 10\n    let tens = number\
    \ % 10\n    number /= 10\n\n    var roman : String = String()\n    for index in\
    \ 1...(Int(log10(number)) + 1) {\n        let value = (number / pow(10.0, Float(index))\
    \ * 100).rounded()\n        let numeral = String(value)\n        roman += numeral\n\
    \    }\n\n    roman += String(tens)\n    return roman.lowercased()", "    let\
    \ miniRoman = IntToRoman(number)\n    return miniRoman.lowercased()", "    let\
    \ roman = roman_to_int(number: number)\n    return mini_roman_to_int(roman: roman)",
  "    let roman =\n        [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"\
    XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n        let romanCode = String(roman.enumerated().filter\
    \ { $0.element == number }.map { $0.offset })\n    return String(romanCode).lowercased()",
  "    if number <= 0 || number > 1000 {\n        return \"\"\n    }\n\n    var roman_num\
    \ = \"\"\n\n    var digits = String()\n    var counter = 0\n\n    var is_first_digit\
    \ = true\n    while number > 0 || counter < 3 {\n        if number > 0 {\n   \
    \         digits = digits + String(number % 10)\n        }\n\n        number =\
    \ number / 10\n        counter += 1\n        is_first_digit = false\n    }\n\n\
    \    var roman_numerals = [\n        \"I\", \"IV\", \"III\", \"II\", \"I\",\n\
    \        \"V\", \"VII\", \"VIII\", \"VII\",\n        \"I\", \"IX\", \"X\", \"\
    XI\",\n        \"L\", \"LX\", \"L\", \"L\",\n        \"C\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\",\n        \"D\", \"DC\", \"DCC\"\
    , \"DCCC\", \"DCCCC\", \"DCCCXX\", \"DCCCXCX\", \"DCCXC\", \"DCCXCC\", \"DCCXCCC\"\
    , \"DCCXCXX\", \"DCCXCXCX\",\n        \"M\", \"MC\", \"MCC\", \"MCCC\", \"MCCCC\"\
    , \"MCCCXX\", \"MCCCXCX\", \"MCCXC\", \"MCCXCC\", \"MCCXCCC\", \"MCCXCXX\", \"\
    MCCXCXCX\",\n        \"C\", \"CC\", \"CCC\", \"CCCC\", \"CCCXX\", \"CCCXCX\",\
    \ \"CCXC\", \"CCXCC\", \"CCXCCC\", \"CCXCXX\", \"CCXCXCX\", \"CCXCCCXX\", \"CCXCCCXCX\"\
    ,\n        \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMMMM\",\n        \"X\", \"XX\"\
    , \"XXX\", \"XXXX\", \"XXXXX\",\n        \"L\", \"XL\", \"LX\", \"L\", \"L\",\n\
    \        \"C\", \"CX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"\
    CXXV\",\n        \"D\", \"DC\", \"DCC\", \"DCCC\", \"DCCCC\", \"DCCCXX\", \"DCCCXCX\"\
    , \"DCCXC\", \"DCCXCC\", \"DCCXCCC\", \"DCCXCXX\", \"DCCXCXCX\",\n        \"M\"\
    , \"MC\", \"MCC\", \"MCCC\", \"MCCCC\", \"MCCCXX\", \"MCCCXCX\", \"MCCXC\", \"\
    MCCXCC\", \"MCCXCCC\", \"MCCXCXX\", \"MCCXCXCX\",\n        \"C\", \"CC\", \"CCC\"\
    , \"CC", "    switch number {\n    case 1:\n        return \"xix\"\n    case 2:\n\
    \        return \"c\"\n    case 3:\n        return \"cl\"\n    case 4:\n     \
    \   return \"ix\"\n    case 5:\n        return \"v\"\n    case 6:\n        return\
    \ \"iv\"\n    case 7:\n        return \"vi\"\n    case 8:\n        return \"ix\"\
    \n    case 9:\n        return \"l\"\n    case 10:\n        return \"lx\"\n   \
    \ case 11:\n        return \"ll\"\n    case 12:\n        return \"lll\"\n    case\
    \ 13:\n        return \"lxx\"\n    case 14:\n        return \"lxxx\"\n    case\
    \ 15:\n        return \"xx\"\n    case 16:\n        return \"xxx\"\n    case 17:\n\
    \        return \"ixx\"\n    case 18:\n        return \"v\"\n    case 19:\n  \
    \      return \"iv\"\n    case 20:\n        return \"vi\"\n    case 21:\n    \
    \    return \"vii\"\n    case 22:\n        return \"ix\"\n    case 23:\n     \
    \   return \"l\"\n    case 24:\n        return \"lx\"\n    case 25:\n        return\
    \ \"ll\"\n    case 26:\n        return \"lll\"\n    case 27:\n        return \"\
    lxx\"\n    case 28:\n        return \"lxxx\"\n    case 29:\n        return \"\
    xx\"\n    case 30:\n        return \"xxx\"\n    case 31:\n        return \"ixx\"\
    \n    case 32:\n        return \"lv\"\n    case 33:\n        return \"lvi\"\n\
    \    case 34:\n        return \"vi\"\n    case 35:\n        return \"vii\"\n \
    \   case 36:\n        return \"ix\"\n    case 37:\n        return \"l\"\n    case\
    \ 38:\n        return \"lx\"\n    case 39:\n        return \"ll\"\n    case 40:\n\
    \        return \"lll\"\n    case 41:\n        return \"lxx\"\n    case 42:\n\
    \        return \"lxxx\"\n    case 43:\n        return \"xx\"\n    case 44:\n\
    \        return \"xxx\"\n    case 45:\n        return \"ixx\"\n    case 46:\n\
    \        return \"v\"\n    case 47:\n        return \"iv\"\n    case 48:\n   \
    \     return \"vi\"\n    case 49:\n        return \"vii\"\n    case 50:\n    \
    \    return \"ix\"\n    case 51:\n        return \"l\"\n    case 52:\n       \
    \ return \"lx\"\n    case 53:\n        return \"ll\"\n    case 54:\n        return\
    \ \"lll\"\n    case 55:\n        return \"lxx\"\n    case 56:\n        return\
    \ \"lxxx\"\n    case 57:\n        return \"xx\"\n    case 58:\n        return\
    \ \"xxx\"\n    case 59:\n        return \"ixx\"\n    case 60:\n        return\
    \ \"l\"\n    case 61:\n        return \"lx\"\n    case 62:\n        return \"\
    ll\"\n    case 63:\n        return \"lll\"\n    case 64", "    // Checks the range\n\
    \    if number < 1 || number > 1000 {\n        throw \"Invalid number\"\n    }\n\
    \n    // The number\n    var num = (number * 1000).rounded() / 1000\n\n    //\
    \ Initializes the resulting string\n    var mini_roman = \"\"\n\n    // If the\
    \ number is even\n    if num % 2 == 0 {\n        // If it's even add the character\
    \ 'i' at the beginning\n        mini_roman = \"i\" + mini_roman\n\n        //\
    \ If it's odd, subtract one\n    } else {\n        // If the number is odd, add\
    \ one\n        mini_roman = \"o\" + mini_roman\n    }\n\n    // Loops through\
    \ all the digits\n    for i in 0 ..< num {\n        // Gets the current digit\n\
    \        let digit = Int(num / 1000)\n\n        // Adds the digit to the string\n\
    \        mini_roman += mini_roman_digits[digit]\n    }\n\n    // Returns the result\n\
    \    return mini_roman", "    let result = mini_roman.map({ (roman: String, value:\
    \ Int) in\n        guard value >= 1 && value <= 1000 else { return \"\" }\n  \
    \      return roman[value-1] + String(value)\n    }).joinWithSeparator(\"\", \"\
    \")\n    guard number >= 1 && number <= 1000 else { return \"\" }\n    return\
    \ String(number)", "    // Initialize an empty string\n    var result = \"\"\n\
    \n    // If number is 0, just return an empty string\n    if number == 0 {\n \
    \       return \"\"\n    }\n\n    // Loop through all numbers in the thousands\
    \ place until number < 1000\n    for var i = 0; i < 30 && number >= 1000; i++\
    \ {\n        // If number is divisible by 1000, add it to result\n        if number\
    \ % 1000 == 0 {\n            // Add thousands separator\n            result +=\
    \ 1000\n        }\n\n        // Remove thousands separator from number\n     \
    \   number = number / 1000\n    }\n\n    // Loop through remaining numbers until\
    \ number is less than 1000\n    while number >= 1000 {\n        // Add hundreds\
    \ separator\n        result += 100\n        number = number / 100\n    }\n\n \
    \   // Add digits until number is less than 100\n    while number > 0 {\n    \
    \    // Add number to the result\n        result += String(number % 100)\n\n \
    \       // Remove number from the number\n        number = number / 100\n    }\n\
    \n    // Return the result string\n    return result", "    if number < 1 {\n\
    \        number = 0\n    }\n    \n    var roman = String()\n    var unit: String\n\
    \    \n    if number < 100 {\n        roman = \"mcm\"\n        unit = \"\"\n \
    \   } else if number < 500 {\n        roman = \"dm\"\n        unit = \"\"\n  \
    \  } else if number < 1000 {\n        roman = \"cm\"\n        unit = \"\"\n  \
    \  } else {\n        if number < 5000 {\n            roman = \"d\"\n         \
    \   unit = \"\"\n        } else {\n            roman = \"c\"\n            unit\
    \ = \"\"\n        }\n    }\n    \n    var remainder = number % 100\n    if remainder\
    \ >= 100 {\n        remainder = remainder - 100\n        roman = roman + \"cd\"\
    \n    }\n    \n    roman = roman + String(remainder)\n    \n    if number >= 1000\
    \ {\n        var thousand = number / 1000\n        var hundred = thousand % 100\n\
    \        thousand = thousand / 100\n        if hundred == 0 {\n            roman\
    \ = roman + \"m\"\n        } else {\n            roman = roman + \"mm\"\n    \
    \    }\n        if thousand == 0 {\n            roman = roman + \"k\"\n      \
    \  } else {\n            roman = roman + \"k\"\n        }\n    }\n    \n    roman\
    \ = roman + unit\n    \n    return roman.lowercased()", "    let romans = [\n\
    \        \"I\",\n        \"IV\",\n        \"III\",\n        \"II\",\n        \"\
    I\",\n        \"II\",\n        \"III\",\n        \"IV\",\n        \"V\",\n   \
    \     \"VI\",\n        \"VII\",\n        \"VIII\",\n        \"IX\",\n        \"\
    X\",\n        \"XI\",\n        \"XII\",\n        \"XIII\",\n        \"XIV\",\n\
    \        \"XV\",\n        \"XVI\",\n        \"XVII\",\n        \"XVIII\",\n  \
    \      \"XIX\",\n        \"XX\",\n        \"XXI\",\n        \"XXII\",\n      \
    \  \"XXIII\",\n        \"XXIV\",\n        \"XXV\",\n        \"XXVI\",\n      \
    \  \"XXVII\",\n        \"XXVIII\",\n        \"XXIX\",\n        \"XXX\",\n    \
    \    \"XXXI\",\n        \"XXXII\",\n        \"XXXIII\",\n        \"XXXIV\",\n\
    \        \"XXXV\",\n        \"XXXVI\",\n        \"XXXVII\",\n        \"XXXVIII\"\
    ,\n        \"XXXIX\",\n        \"XXXX\",\n        \"XXXXI\",\n        \"XXXXII\"\
    ,\n        \"XXXXIII\",\n        \"XXXXIV\",\n        \"XXXXV\",\n        \"XXXXVI\"\
    ,\n        \"XXXXVII\",\n        \"XXXXVIII\",\n        \"XXXXIX\",\n        \"\
    XXXXX\",\n        \"XXXXXI\",\n        \"XXXXXII\",\n        \"XXXXXIII\",\n \
    \       \"XXXXXIV\",\n        \"XXXXXV\",\n        \"XXXXXVI\",\n        \"XXXXXVII\"\
    ,\n        \"XXXXXVIII\",\n        \"XXXXXIX\",\n        \"XXXXXX\",\n       \
    \ \"XXXXXXI\",\n        \"XXXXXXII\",\n        \"XXXXXXIII\",\n        \"XXXXXXIV\"\
    ,\n        \"XXXXXXV\",\n        \"XXXXXXVI\",\n        \"XXXXXXVII\",\n     \
    \   \"XXXXXXVIII\",\n        \"XXXXXXIX\",\n        \"XXXXXXX\",\n        \"XXXXXXXI\"\
    ,\n        \"XXXXXXXII\",\n        \"XXXXXXXIII\",\n        \"XXXXXXXIV\",\n \
    \       \"XXXXXXXV\",\n        \"XXXXXXXVI\",\n        \"XXXXXXXVII\",\n     \
    \   \"XXXXXXXVIII\",\n        \"XXXXXXXIX\",\n        \"XXXXXXXX\",\n        \"\
    XXXXXXXXI\",\n        \"XXXXXXXXII\",\n        \"XXXXXXXXIII\",\n        \"XXXXXXXXIV\"\
    ,\n        \"XXXXXXXXV\",\n        \"XXXXXXXXVI\",", "    let num: Int = abs(number)\n\
    \    var result: String\n    var remainder: Int\n    let maxRomanDigit = 1000\n\
    \    guard number >= 1 else { return \"\" }\n    guard number <= maxRomanDigit\
    \ else { return \"\" }\n    switch number {\n    case 1:\n        result = \"\
    i\"\n    case 2:\n        result = \"ii\"\n    case 3:\n        result = \"iii\"\
    \n    case 4:\n        result = \"iv\"\n    case 5:\n        result = \"v\"\n\
    \    case 6:\n        result = \"vi\"\n    case 7:\n        result = \"vii\"\n\
    \    case 8:\n        result = \"viii\"\n    case 9:\n        result = \"ix\"\n\
    \    case 10:\n        result = \"x\"\n    case 11:\n        result = \"xii\"\n\
    \    case 12:\n        result = \"xiii\"\n    case 13:\n        result = \"xiv\"\
    \n    case 14:\n        result = \"xv\"\n    case 15:\n        result = \"xvi\"\
    \n    case 16:\n        result = \"xvii\"\n    case 17:\n        result = \"xvii\"\
    \n    case 18:\n        result = \"xix\"\n    case 19:\n        result = \"x\"\
    \n    case 20:\n        result = \"xx\"\n    case 21:\n        result = \"xxx\"\
    \n    case 22:\n        result = \"xl\"\n    case 23:\n        result = \"l\"\n\
    \    case 24:\n        result = \"lx\"\n    case 25:\n        result = \"lxx\"\
    \n    case 26:\n        result = \"lxxx\"\n    case 27:\n        result = \"xc\"\
    \n    case 28:\n        result = \"c\"\n    case 29:\n        result = \"cxx\"\
    \n    case 30:\n        result = \"cxxx\"\n    case 31:\n        result = \"cc\"\
    \n    case 32:\n        result = \"ccc\"\n    case 33:\n        result = \"ccc\"\
    \n    case 34:\n        result = \"cccc\"\n    case 35:\n        result = \"cc\"\
    \n    case 36:\n        result = \"ccc\"\n    case 37:\n        result = \"ccc\"\
    \n    case 38:\n        result = \"cccc\"\n    case 39:\n        result = \"ccc\"\
    \n    case 40:\n        result = \"ccc\"\n    case 41:\n        result = \"cccc\"\
    \n    case 42:\n        result = \"ccc\"\n    case 43:\n        result = \"ccc\"\
    \n    case 44:\n        result = \"ccc\"\n    case 45:\n        result = \"ccc\"\
    \n    case 46:\n        result = \"ccc\"\n    case 47:\n        result = \"ccc\"\
    \n    case 48:\n        result = \"ccc\"\n    case 49:\n        result = \"cccc\"\
    \n    case 50:\n        result = \"cc\"\n    case ", '    return mini_roman_to_int(number:
    number)', '    return mini_roman_to_int(number: number).lowercased()', "    let\
    \ romans = [\n        \"I\",\n        \"II\",\n        \"III\",\n        \"IV\"\
    ,\n        \"V\",\n        \"VI\",\n        \"VII\",\n        \"VIII\",\n    \
    \    \"IX\",\n        \"X\",\n        \"XI\",\n        \"XII\",\n        \"XIII\"\
    ,\n        \"XIV\",\n        \"XV\",\n        \"XVI\",\n        \"XVII\",\n  \
    \      \"XVIII\",\n        \"XIX\",\n        \"XX\",\n        \"XXI\",\n     \
    \   \"XXII\",\n        \"XXIII\",\n        \"XXIV\",\n        \"XXV\",\n     \
    \   \"XXVI\",\n        \"XXVII\",\n        \"XXVIII\",\n        \"XXIX\",\n  \
    \      \"XXX\",\n        \"XXXI\",\n        \"XXXII\",\n        \"XXXIII\",\n\
    \        \"XXXIV\",\n        \"XXXV\",\n        \"XXXVI\",\n        \"XXXVII\"\
    ,\n        \"XXXVIII\",\n        \"XXXIX\",\n        \"XL\",\n        \"L\",\n\
    \        \"LX\",\n        \"LX\",\n        \"LX\",\n        \"LX\",\n        \"\
    LX\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n      \
    \  \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n  \
    \      \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n\
    \        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\"\
    ,\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"\
    L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n       \
    \ \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n   \
    \     \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n\
    \        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\"\
    ,\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"\
    L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n       \
    \ \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n   \
    \     \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n\
    \        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\"\
    ,\n        \"L\",\n", "    var roman = \"\"\n    let roman_numerals = [\"\", \"\
    C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", \"\"]\n\
    \    guard number > 0 && number <= 1000 else {\n        return roman\n    }\n\
    \    for i in 1..<10 {\n        roman += roman_numerals[i-1]\n    }\n    if number\
    \ > 100 { //if num is more than 100\n        roman += roman_numerals[9] * String(number\
    \ / 100)\n        roman = roman.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \        let remainder = number % 100\n        roman += roman_numerals[9+remainder]\n\
    \    }\n    return roman.lowercased()", "    return int_to_roman(number)\n   \
    \     .lowercased()\n        .replacingOccurrences(of: \"i\", with: \"x\")\n \
    \       .replacingOccurrences(of: \"l\", with: \"c\")\n        .replacingOccurrences(of:\
    \ \"v\", with: \"d\")", "    var roman = String()\n    var romanDigits = String()\n\
    \    var numDigits = String()\n    var romanDigit = String()\n\n    // Roman numerals\
    \ are in base ten, with the most significative digit\n    // at the far left,\
    \ followed by the least significative at the right.\n    // The least significative\
    \ digit is on the farthest right of the numeral\n    // and the most significative\
    \ digit is on the farthest left of the numeral.\n    var base10 = String()\n \
    \   var base1 = String()\n\n    // Set the base10 string to the given number.\n\
    \    base10 = \"\"\n    for digit = String(); digit < 100; digit += \"\" {\n \
    \       base10 += String(digit)\n    }\n    base1 += String(number)\n\n    //\
    \ Count the number of digits in number.\n    for digit = base10; digit != \"\"\
    ; digit /= 10 {\n        numDigits += String(digit)\n    }\n    numDigits += String(number)\n\
    \n    // Iterate over the most significative digits in base10, storing each in\
    \ romanDigit.\n    for digit = base10; digit != \"\"; digit /= 10 {\n        romanDigit\
    \ += String(digit)\n    }\n    // Iterate over the least significative digits\
    \ in base10, storing each in romanDigits.\n    for digit = base1; digit != \"\"\
    ; digit /= 10 {\n        romanDigits += String(digit)\n    }\n\n    // Append\
    \ romanDigit to romanDigits.\n    romanDigits += romanDigit\n    // Append numDigits\
    \ after romanDigits as a string.\n    roman += romanDigits\n\n    // Remove leading\
    \ and trailing zeros.\n    roman = roman.trim()\n    // Remove trailing romanDigit.\n\
    \    roman = roman.substring(1)\n\n    return roman", "    guard number >= 1 else\
    \ {\n        return \"\"\n    }\n\n    let letters = (0..<(number + 1)) as [String]\n\
    \    let digits = (0..<number).map { \"McC\".string(radix: 10, uppercase: false)\
    \ }\n    let romanDigits = letters + digits\n    let romanNumbers = romanDigits.map\
    \ { Int($0, radix: 100) }\n\n    return romanNumbers.joinWithSeparator(\"\")",
  "    // We start by checking the condition that 1 <= num <= 1000\n    guard number\
    \ >= 1 && number <= 1000 else {\n        // If we got here, it means the number\
    \ passed the condition check\n        // but was neither 1 or 1000.\n        //\
    \ Therefore, we print a message stating this and our program will exit\n     \
    \   // with a non-zero exit status.\n        fatalError(\"number passed the condition\
    \ check\")\n    }\n    \n    let reversedNumber = reverseString(number: number)\n\
    \    \n    // We now check whether a letter is present or not\n    guard let letterIndex\
    \ = reversedNumber.index(of: \"M\") else {\n        // If no letter is present,\
    \ then the reversed number is a mini-roman\n        // number with only a digit\n\
    \        return \"\\(number)\"\n    }\n    \n    // If there is a letter, then\
    \ we remove it from the reversed string\n    let reversedNumberWithoutLetter =\
    \ reversedNumber.substring(to: letterIndex)\n    \n    // Now we check whether\
    \ a digit is present or not\n    guard let digitIndex = reversedNumberWithoutLetter.index(of:\
    \ \"0\")  else {\n        // If the reversed number only has a digit, we can now\
    \ convert it to\n        // a mini-roman number\n        return \"\\(reversedNumberWithoutLetter)\"\
    \n    }\n    \n    // Now we obtain all digits from the reversed number by slicing\n\
    \    let miniRomanNumberWithoutLetter = reversedNumberWithoutLetter.substring(to:\
    \ digitIndex)\n    \n    // We now check whether there is an \"i\" present in\
    \ the mini-roman number\n    guard let isII = miniRomanNumberWithoutLetter.index(of:\
    \ \"i\")  else {\n        // If there is no \"i\", then we return a mini-roman\
    \ number with only\n        // a digit\n        return \"\\(miniRomanNumberWithoutLetter)\"\
    \n    }\n    \n    // If there is an \"i\", then we remove the \"i\" from the\
    \ mini-roman number\n    let miniRomanNumberWithoutII = miniRomanNumberWithoutLetter.substring(to:\
    \ isII)\n    \n    // We now check whether there is a \"v\" or \"x\" present in\
    \ the mini-roman number\n    guard let isV = miniRomanNumberWithoutII.index(of:\
    \ \"v\")  else {\n        // If there is no \"v\" or \"x\", then we return a mini-roman\
    \ number with\n        // only a digit\n        return \"\\(miniRomanNumberWithoutII)\"\
    \n    }\n    \n    // If there is an \"v\" or \"x\", then we remove the \"v\"\
    \ or \"x\" from the\n    // mini-roman number\n    let miniRomanNumberWithoutV\
    \ = ", "  let num: Int = number - 1\n  let numString = \"\"\n  if num == 0 ||\
    \ num == 1 {\n    numString = \"x\"\n  } else if num < 5 && num > 0 {\n    numString\
    \ = int_to_mini_roman(number: num) + \"m\"\n  } else if num % 100 < 50 && num\
    \ % 100 > 1 {\n    numString = int_to_mini_roman(number: num / 100) + \"l\"\n\
    \  } else if num % 100 < 10 {\n    numString = int_to_mini_roman(number: num /\
    \ 100) + \"c\"\n  } else if num % 100 < 20 {\n    numString = int_to_mini_roman(number:\
    \ num / 100) + \"d\"\n  } else if num % 100 < 30 {\n    numString = int_to_mini_roman(number:\
    \ num / 100) + \"m\"\n  } else if num % 100 < 40 {\n    numString = int_to_mini_roman(number:\
    \ num / 100) + \"b\"\n  } else if num % 100 < 50 {\n    numString = int_to_mini_roman(number:\
    \ num / 100) + \"k\"\n  } else if num % 100 < 60 {\n    numString = int_to_mini_roman(number:\
    \ num / 100) + \"y\"\n  } else {\n    numString = int_to_mini_roman(number: num\
    \ / 100) + \"v\"\n  }\n  return numString.lowercased()", "    if number < 0 ||\
    \ number > 1000 {\n        throw IllegalArgumentError(\n            \"The number\
    \ \" + number.toString() + \" is out of bounds.\",\n        )\n    }\n\n    var\
    \ roman = \"\"\n    let numString = \"\\(number)\"\n\n    // Iterate backwards\
    \ to prevent adding numbers to roman numerals\n    // multiple times.\n    for\
    \ i in numString.reversed().reverse() {\n        var current = \"\"\n        var\
    \ romanString = roman\n\n        switch i {\n        case \"c\":\n           \
    \ current = \"C\"\n        case \"x\":\n            current = \"D\"\n        case\
    \ \"l\":\n            current = \"M\"\n        case \"v\":\n            current\
    \ = \"N\"\n        default:\n            continue\n        }\n\n        current\
    \ = current.uppercased()\n\n        if roman == \"\" {\n            romanString\
    \ = current\n        } else {\n            romanString = romanString + current\n\
    \        }\n    }\n\n    return roman.lowercased()", "    if number < 1 || number\
    \ > 1000 { return \"\" }\n    let romanNumerals = [\n        \"I\", \"II\", \"\
    III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\",\n        \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\",\n        \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XL\", \"L\",\n        \"LI\", \"LII\", \"LIII\", \"\
    LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\",\n        \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\", \"LXX\",\n        \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\",\n        \"LXXX\", \"LXXIII\"\
    , \"LXXIV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"XC\", \"C\",\n \
    \       \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\",\n        \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\",\n        \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXIII\", \"CXXIV\", \"CXXVI\", \"CXXVII\",\
    \ \"CXXVIII\", \"CXXIX\", \"CXL\", \"CL\",\n        \"LI\", \"LII\", \"LIII\"\
    , \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\",\n        \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LX", "    let romanNumerals =\
    \ [\n        \"\",\n        \"c\",\n        \"xix\",\n        \"l\",\n       \
    \ \"m\",\n        \"c\",\n        \"xix\",\n        \"d\",\n        \"m\",\n \
    \       \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\"\
    ,\n        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"\
    xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n   \
    \     \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n        \"l\"\
    ,\n        \"m\",\n        \"c\",\n        \"xix\",\n        \"l\",\n        \"\
    m\",\n        \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n     \
    \   \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n\
    \        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"\
    xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n   \
    \     \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n        \"l\"\
    ,\n        \"m\",\n        \"c\",\n        \"xix\",\n        \"l\",\n        \"\
    m\",\n        \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n     \
    \   \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n\
    \        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"\
    xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n   \
    \     \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n        \"l\"\
    ,\n        \"m\",\n        \"c\",\n        \"xix\",\n        \"l\",\n        \"\
    m\",\n        \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n     \
    \   \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n\
    \        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"\
    xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n   \
    \     \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n        \"l\"\
    ,\n        \"m\",\n        \"c\",\n        \"xix\",\n        \"l\",\n        \"\
    m\",\n        \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n     \
    \   \"c\",\n        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n\
    \        \"xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"\
    xix\",\n        \"l\",\n        \"m\",\n        \"c\",\n        \"xix\",\n", '    return
    int_to_roman(number).lowercased()', "    check(1 <= number && number <= 1000,\
    \ \"Invalid arguments\")\n    var result = StringBuilder()\n    var currentRomanNumber:\
    \ Int\n    var currentSum: Int\n    var lastNumber: Int?\n    var lastRomanNumber:\
    \ Int?\n    for number != 0 {\n        result += \"M\"\n        number -= 1\n\
    \    }\n    currentSum = number\n    while number > 0 {\n        number -= 1\n\
    \        currentRomanNumber = number / 1000\n        result += int_to_roman(currentRomanNumber)\n\
    \        currentSum -= currentRomanNumber * 1000\n    }\n    if currentSum > 0\
    \ {\n        result += int_to_roman(currentSum)\n    }\n    lastNumber = number\n\
    \    lastRomanNumber = currentRomanNumber\n    if lastRomanNumber != nil {\n \
    \       if lastRomanNumber! < 400 {\n            for lastNumber--; lastNumber\
    \ >= 1000; lastNumber-- {\n                result += \"M\"\n            }\n  \
    \      } else {\n            result += \"C\"\n            lastNumber -= 1\n  \
    \          currentRomanNumber = lastNumber / 100\n            currentSum += lastNumber\n\
    \            result += int_to_roman(currentRomanNumber)\n            if currentSum\
    \ > 0 {\n                result += \"L\"\n                currentSum -= currentRomanNumber\
    \ * 100\n            }\n        }\n    }\n    result.insertString(\" \", at: result.endIndex)\n\
    \    return result.toString()", "    var roman: String = String()\n    var lastLetter:\
    \ String = String()\n    let letters = Array(\"M\", \"CM\", \"D\", \"CD\", \"\
    C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\")\n    guard number\
    \ > 0 else { return roman  }\n    for n in 1...number {\n        if lastLetter\
    \ == \"\" {\n            if n%3 == 0 {\n                roman += letters[n-1]\n\
    \            } else if n%5 == 0 {\n                roman += letters[n-1]\n   \
    \             roman += \"I\"\n            } else {\n                roman += letters[n-1]\n\
    \                roman += \"IV\"\n            }\n            lastLetter = \"I\"\
    \n        } else {\n            if n%3 == 0 {\n                roman += letters[n-1]\n\
    \                lastLetter = \"M\"\n            } else if n%5 == 0 {\n      \
    \          roman += letters[n-1]\n                lastLetter = \"CM\"\n      \
    \      } else {\n                roman += letters[n-1]\n                lastLetter\
    \ = \"D\"\n            }\n        }\n    }\n    return roman", "    // check if\
    \ number is positive\n    if number < 0 || number > 1000 {\n        return \"\"\
    \n    }\n    // obtain first character (M for non-negative numbers)\n    var firstChar:\
    \ Char\n\n    if number < 500 {\n        // for numbers less than 500, we can\
    \ use the roman numeral equivalent\n        firstChar = \"M\"\n    } else {\n\
    \        // for numbers less than 1000, we can use the first letter of the roman\n\
    \        // alphabet (L for \"Loud\", X for \"Extra Loud\", D for \"Diamond\"\
    , and C\n        // for \"Club\")\n        firstChar = roman_alphabet[number -\
    \ 1000]\n    }\n    // obtain remainder of number\n    var remainder = number\
    \ % 1000\n    var rest = number - remainder\n    var secondChar: Char\n\n    if\
    \ rest < 500 {\n        // for numbers less than 500, we can use the roman numeral\
    \ equivalent\n        secondChar = \"M\"\n    } else {\n        // for numbers\
    \ less than 1000, we can use the first letter of the roman\n        // alphabet\
    \ (L for \"Loud\", X for \"Extra Loud\", D for \"Diamond\", and C\n        //\
    \ for \"Club\")\n        secondChar = roman_alphabet[rest - 1000]\n    }\n\n \
    \   // combine first and second characters\n    return String(firstChar + secondChar)",
  '    return MiniRomanConverter().int_to_mini_roman(number)', "    if number < 0\
    \ || number > 999 {\n        throw ArgumentError(\"number is not in range.\")\n\
    \    }\n\n    // Create the initial string, for which the numerals are appended\n\
    \    var numerals = [String]()\n    var remainder = number % 100\n    for _ in\
    \ 0..<5 {\n        // If the remainder is zero, then append zero, otherwise append\
    \ the\n        // numeral for the remainder and add it to the numerals array\n\
    \        let numeral = remainder % 10\n        let remainder = remainder / 10\n\
    \        numerals.append(\"\\(numeral)\")\n    }\n    numerals.append(String(numerals))\n\
    \n    // Add the rest to the string\n    numerals.append(String(remainder))\n\n\
    \    // Add all but the first character to the front and return the result\n \
    \   return numerals.dropFirst().reduce(\"\") { $0 + $1 == \"0\" ? $1 : $0.capitalized\
    \ + $1[0] }", "    var roman: String = \"\"\n    if number < 0 || number >= 1000\
    \ { // number must be in range 0<=number<=1000\n        return \"\"\n    }\n \
    \   switch number {\n    case 0:\n        roman = \"I\"\n    case 1:\n       \
    \ roman = \"II\"\n    case 2:\n        roman = \"III\"\n    case 3:\n        roman\
    \ = \"IV\"\n    case 4:\n        roman = \"V\"\n    case 5:\n        roman = \"\
    VI\"\n    case 6:\n        roman = \"VII\"\n    case 7:\n        roman = \"VIII\"\
    \n    case 8:\n        roman = \"IX\"\n    case 9:\n        roman = \"X\"\n  \
    \  case 10:\n        roman = \"XI\"\n    case 11:\n        roman = \"XII\"\n \
    \   case 12:\n        roman = \"XIII\"\n    case 13:\n        roman = \"XIV\"\n\
    \    case 14:\n        roman = \"XV\"\n    case 15:\n        roman = \"XVI\"\n\
    \    case 16:\n        roman = \"XVII\"\n    case 17:\n        roman = \"XVIII\"\
    \n    case 18:\n        roman = \"XIX\"\n    case 19:\n        roman = \"XX\"\n\
    \    case 20:\n        roman = \"XXI\"\n    case 21:\n        roman = \"XXII\"\
    \n    case 22:\n        roman = \"XXIII\"\n    case 23:\n        roman = \"XXIV\"\
    \n    case 24:\n        roman = \"XXV\"\n    case 25:\n        roman = \"XXVI\"\
    \n    case 26:\n        roman = \"XXVII\"\n    case 27:\n        roman = \"XXVIII\"\
    \n    case 28:\n        roman = \"XXIX\"\n    case 29:\n        roman = \"XXX\"\
    \n    case 30:\n        roman = \"XXXI\"\n    case 31:\n        roman = \"XXXII\"\
    \n    case 32:\n        roman = \"XXXIII\"\n    case 33:\n        roman = \"XXXIV\"\
    \n    case 34:\n        roman = \"XXXV\"\n    case 35:\n        roman = \"XXXVI\"\
    \n    case 36:\n        roman = \"XXXVII\"\n    case 37:\n        roman = \"XXXVIII\"\
    \n    case 38:\n        roman = \"XXXIX\"\n    case 39:\n        roman = \"XXVIII\"\
    \n    case 40:\n        roman = \"XIX\"\n    case 4", "    let roman_numeral_mapping\
    \ = [\n        \"I\": 1,\n        \"II\": 2,\n        \"III\": 3,\n        \"\
    IV\": 4,\n        \"V\": 5,\n        \"VI\": 6,\n        \"VII\": 7,\n       \
    \ \"VIII\": 8,\n        \"IX\": 9\n    ]\n\n    let mini_roman = String(repeating:\
    \ \"x\", count: number)\n\n    var roman_numeral = \"\"\n    for roman_numeral_letter\
    \ in mini_roman.unicodeScalars {\n        let roman_numeral_number = roman_numeral_mapping[roman_numeral_letter]!\n\
    \        let roman_numeral_letter_index = (roman_numeral_number - 1) % 9\n\n \
    \       roman_numeral += String(UnicodeScalar(roman_numeral_letter_index))\n \
    \   }\n    return roman_numeral.lowercased()", "\tswitch number {\n\tcase 1:\n\
    \t\treturn \"i\"\n\tcase 5:\n\t\treturn \"v\"\n\tcase 10:\n\t\treturn \"x\"\n\t\
    case 20:\n\t\treturn \"l\"\n\tcase 50:\n\t\treturn \"c\"\n\tcase 100:\n\t\treturn\
    \ \"d\"\n\tcase 200:\n\t\treturn \"h\"\n\tcase 400:\n\t\treturn \"m\"\n\tcase\
    \ 900:\n\t\treturn \"n\"\n\tdefault:\n\t\tvar roman = \"\"\n\t\tvar numeral =\
    \ number / 100\n\t\twhile numeral > 0 {\n\t\t\tif numeral >= 1000000 {\n\t\t\t\
    \tnumeral /= 1000\n\t\t\t\troman += \"m\"\n\t\t\t} else {\n\t\t\t\troman += String(non_digits[numeral\
    \ % 10])\n\t\t\t}\n\t\t\tnumeral /= 10\n\t\t}\n\t\tif number > 1000 {\n\t\t\t\
    numeral = number % 100\n\t\t\troman += \"m\"\n\t\t\twhile numeral > 0 {\n\t\t\t\
    \troman += String(non_digits[numeral % 10])\n\t\t\t\tnumeral /= 10\n\t\t\t}\n\t\
    \t}\n\t\tif len(roman) == 0 {\n\t\t\treturn \"\"\n\t\t}\n\t\tif len(roman) > 1\
    \ {\n\t\t\troman = roman[:len(roman) - 1]\n\t\t}\n\t\treturn roman\n\t}", "  \
    \  guard number >= 1 && number <= 1000 else {\n        return \"\"\n    }\n  \
    \  var roman = \"\"\n    var index = 0\n    var roman_number = 0\n    while number\
    \ >= 1 {\n        let remainder = number % 100\n        roman_number += remainder\
    \ / 10\n        roman_number += remainder % 10\n        number -= remainder\n\
    \        roman = roman_number.to_string() + roman\n    }\n    return roman.lowercased()",
  "    let romanNumbers = Roman + \" \"\n    let letters = String(repeating: \"X\"\
    , count: number)\n    return romanNumbers + letters", "    var mini_roman = \"\
    \"\n    var counter = Int()\n    var roman_number = Int()\n    var last_number\
    \ = Int()\n\n    last_number = number % 1000\n    number /= 1000\n    mini_roman\
    \ = \"M\"\n    if number > 0 { mini_roman += \"C\"; }\n\n    while number > 0\
    \ { counter += 1; number -= last_number; last_number = number % 1000; number /=\
    \ 1000; }\n\n    if counter > 1 {\n        mini_roman += \"C\"\n        if counter\
    \ > 2 { mini_roman += \"X\"; }\n    }\n\n    if last_number > 0 { mini_roman +=\
    \ \"M\"; }\n\n    return mini_roman", "    let numberString = number.toString()\n\
    \    var romanString = String()\n    var romanStringArray: [Int] = []\n\n    for\
    \ i in 0 ..< numberString.count {\n        let intChar = Int(String(numberString[i]))\n\
    \n        if intChar >= 100 {\n            romanString += \"M\"\n        }\n \
    \       else if intChar >= 9 {\n            romanString += \"CM\"\n        }\n\
    \        else if intChar >= 5 {\n            romanString += \"D\"\n        }\n\
    \        else if intChar >= 4 {\n            romanString += \"CD\"\n        }\n\
    \        else if intChar >= 1 {\n            romanString += \"C\"\n        }\n\
    \        else if intChar >= 0 {\n            romanString += \"X\"\n        }\n\
    \        else if intChar >= -100 {\n            romanString += \"L\"\n       \
    \ }\n        else if intChar >= -9 {\n            romanString += \"XL\"\n    \
    \    }\n        else if intChar >= -5 {\n            romanString += \"XC\"\n \
    \       }\n        else if intChar >= -4 {\n            romanString += \"XL\"\n\
    \        }\n        else if intChar >= -1 {\n            romanString += \"L\"\n\
    \        }\n        else if intChar >= 0 {\n            romanString += \"X\"\n\
    \        }\n        else {\n            romanString += String(numberString[i])\n\
    \        }\n    }\n\n    return romanString", "    let mut roman: Romand\n   \
    \ roman.init(&number, &MiniRoman)\n    return roman.to_lowercase()", "    let\
    \ mut numerals = String::new();\n\n    for n in number..<1000 {\n        let roman\
    \ = roman_numerals(n: n).collect();\n        let roman = roman.iter().map(|r|\
    \ r.to_lowercase()).collect();\n\n        let mut s = String::new();\n       \
    \ for &c in roman {\n            s.push_str(&c.to_string());\n        }\n\n  \
    \      numerals.push_str(&s);\n    }\n\n    return numerals;", "    var mini_roman\
    \ = \"\"\n    for n in String(number).characters.reversed().sorted() {\n     \
    \   mini_roman += roman_to_int(n)\n    }\n    return mini_roman.lowercased()",
  "    if number < 1 || number > 1000 {\n        return \"Error: number out of range\"\
    \n    }\n    var str = \"\"\n    var roman = \"\"\n    var lastDigit = 0\n   \
    \ var lastNumeral = 0\n    var firstRoman = \"x\"\n    var firstDigit = 1\n  \
    \  let romanToChar = Array(\n        \"I\", \"V\", \"X\", \"L\", \"C\", \"D\"\
    , \"M\", \"M\", \"I\", \"V\", \"X\")\n    let charToRoman = Array(\n        \"\
    I\", \"I\", \"I\", \"I\", \"II\", \"II\", \"II\", \"II\", \"IV\", \"IV\", \"IV\"\
    )\n\n    for digit in String(number).unicodeScalars {\n        if digit < 0x30\
    \ {\n            str += charToRoman[digit]\n            lastDigit = digit\n  \
    \          lastNumeral = digit\n        } else if digit == 0x30 {\n          \
    \  lastDigit = digit\n            lastNumeral = digit\n            if firstRoman.isEmpty\
    \ {\n                firstRoman = romanToChar[lastDigit]\n            }\n    \
    \    } else {\n            let newFirstRoman = romanToChar[lastNumeral]\n    \
    \        let newLastRoman = romanToChar[lastDigit]\n            var newFirstDigit\
    \ = firstDigit\n            var newLastDigit = lastDigit\n            var newLastNumeral\
    \ = lastNumeral\n            if firstRoman.isEmpty {\n                if lastDigit\
    \ == 0x31 {\n                    firstRoman = newFirstRoman\n                \
    \    firstDigit = newFirstDigit\n                    lastDigit = newLastDigit\n\
    \                    lastNumeral = newLastNumeral\n                }\n       \
    \     } else {\n                if lastDigit == 0x31 {\n                    if\
    \ newLastDigit != lastDigit {\n                        newFirstDigit = firstDigit\
    \ * 10\n                        newLastDigit = lastDigit\n                   \
    \     newLastNumeral = lastNumeral * 10\n                    }\n             \
    \       newFirstRoman = firstRoman\n                    newFirstDigit = firstDigit\n\
    \                    newLastDigit = newLastDigit\n                    newLastNumeral\
    \ = newLastNumeral\n                }\n            }\n            firstRoman =\
    \ newFirstRoman\n            firstDigit = newFirstDigit\n            lastDigit\
    \ = newLastDigit\n            lastNumeral = newLastNumeral\n        }\n    }\n\
    \    return firstRoman.lowercased", "    var miniRoman = \"\"\n    var roman =\
    \ \"\"\n\n    for num in 1...number {\n        var romanNum = Int((num - 1) /\
    \ 2)\n        roman += romanNum\n        miniRoman += miniRomans[romanNum]\n \
    \   }\n\n    return miniRoman.lowercased()", "  // Create an array with each letter\
    \ of the roman numeral and populate it\n  // with the corresponding digit.\n \
    \ var roman_array = Array<String>(count: 1000, repeatedValue: \"\")\n\n  // Populate\
    \ the array\n  switch number {\n  case 1:\n    roman_array[0] = \"I\"\n  case\
    \ 2:\n    roman_array[0] = \"II\"\n  case 3:\n    roman_array[0] = \"III\"\n \
    \ case 4:\n    roman_array[0] = \"IV\"\n  case 5:\n    roman_array[0] = \"V\"\n\
    \  case 6:\n    roman_array[0] = \"VI\"\n  case 7:\n    roman_array[0] = \"VII\"\
    \n  case 8:\n    roman_array[0] = \"VIII\"\n  case 9:\n    roman_array[0] = \"\
    IX\"\n  case 10:\n    roman_array[0] = \"X\"\n  case 11:\n    roman_array[0] =\
    \ \"XI\"\n  case 12:\n    roman_array[0] = \"XII\"\n  case 13:\n    roman_array[0]\
    \ = \"XIII\"\n  case 14:\n    roman_array[0] = \"XIV\"\n  case 15:\n    roman_array[0]\
    \ = \"XV\"\n  case 16:\n    roman_array[0] = \"XVI\"\n  case 17:\n    roman_array[0]\
    \ = \"XVII\"\n  case 18:\n    roman_array[0] = \"XVIII\"\n  case 19:\n    roman_array[0]\
    \ = \"XIX\"\n  case 20:\n    roman_array[0] = \"XX\"\n  case 21:\n    roman_array[0]\
    \ = \"XXI\"\n  case 22:\n    roman_array[0] = \"XXII\"\n  case 23:\n    roman_array[0]\
    \ = \"XXIII\"\n  case 24:\n    roman_array[0] = \"XXIV\"\n  case 25:\n    roman_array[0]\
    \ = \"XXV\"\n  case 26:\n    roman_array[0] = \"XXVI\"\n  case 27:\n    roman_array[0]\
    \ = \"XXVII\"\n  case 28:\n    roman_array[0] = \"XXVIII\"\n  case 29:\n    roman_array[0]\
    \ = \"XXIX\"\n  case 30:\n    roman_array[0] = \"XXX\"\n  case 31:\n    roman_array[0]\
    \ = \"XXXI\"\n  case 32:\n    roman_array[0] = \"XXXII\"\n  case 33:\n    roman_",
  "  // Check input\n  if number <= 0 || number > 1000 {\n    return \"\"\n  }\n\n\
    \  // Construct input string\n  var romanString = \"\"\n  var stringRepresentation\
    \ = String(number)\n  var previousDigit = 0\n  for index in 0..<stringRepresentation.count\
    \ {\n    let currentDigit = Int(stringRepresentation[index])\n    var nextDigit\
    \ = 0\n\n    // Digit check\n    if currentDigit >= previousDigit {\n      nextDigit\
    \ = currentDigit - previousDigit + 1\n    } else {\n      nextDigit = previousDigit\
    \ + 1\n    }\n    romanString = String(romanString + nextDigit > 9 ? romanString\
    \ + nextDigit : \"0\" + romanString + nextDigit)\n    previousDigit = currentDigit\n\
    \  }\n\n  return romanString", "    let romanNumerals = [\n        \"i\", \"ii\"\
    , \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\",\n        \"x\", \"\
    xi\", \"xii\", \"xiii\", \"xiv\", \"xv\", \"xvi\", \"xvii\", \"xviii\",\n    \
    \    \"xix\", \"xx\", \"xxx\", \"xxxx\"\n    ];\n    let romanNumeralsLowercase\
    \ = romanNumerals.map { $0.lowercased() };\n    let index = romanNumeralsLowercase.firstIndex(of:\
    \ String(number));\n    if index == -1 { return String(number) }\n    else { return\
    \ romanNumeralsLowercase[index].prefix(1) + String(number) }", "    switch number\
    \ {\n    case 1:\n        return \"x\"\n    case 5:\n        return \"l\"\n  \
    \  case 10:\n        return \"c\"\n    case 20:\n        return \"d\"\n    case\
    \ 50:\n        return \"h\"\n    case 100:\n        return \"x\"\n    case 200:\n\
    \        return \"lx\"\n    case 400:\n        return \"c\"\n    case 900:\n \
    \       return \"cd\"\n    case 1000:\n        return \"ccc\"\n    }\n    return\
    \ \"-\"", "    var miniRoman = \"\"\n    var num = 0\n    while number > 0 {\n\
    \        num += 1\n        miniRoman = miniRoman.characters.last + roman_map[number%10]\n\
    \        number = floor(number / 10)\n    }\n    for _ in 0..(6-(miniRoman.characters.count))\
    \ {\n        miniRoman = \"0\" + miniRoman\n    }\n    return miniRoman.lowercased()",
  "    var roman = \"\"\n    for num in 0..<number {\n        let r = roman.index(of:\
    \ String.fromCString(roman.utf8CString))\n        roman = roman.substring(to:\
    \ r)! + String(UnicodeScalar(UnicodeScalar(UnicodeScalar(Int(num))).value)!)\n\
    \    }\n    return roman.lowercased()", "  if number < 1 || number > 1000 { panic(\"\
    Invalid input\"); return \"\" }\n  \n  var mini_roman = \"\"\n  \n  switch number\
    \ {\n  case 1:\n    mini_roman = \"x\"\n  case 4:\n    mini_roman = \"iv\"\n \
    \ case 5:\n    mini_roman = \"v\"\n  case 9: // Nine in Romans\n    mini_roman\
    \ = \"x\"\n  case 20:\n    mini_roman = \"l\"\n  case 40:\n    mini_roman = \"\
    i\"\n  case 90:\n    mini_roman = \"x\"\n  case 400:\n    mini_roman = \"l\"\n\
    \  case 900:\n    mini_roman = \"x\"\n  case 4100:\n    mini_roman = \"l\"\n \
    \ case 9000:\n    mini_roman = \"x\"\n  case 41000:\n    mini_roman = \"l\"\n\
    \  case 9000:\n    mini_roman = \"x\"\n  default:\n    mini_roman = \"x\"\n  }\n\
    \  return mini_roman", "    // TODO: this could be improved by converting to a\
    \ string and using recursion\n    // to handle smaller numbers.\n    var result\
    \ = \"\"\n    var remainder = number\n\n    while (remainder >= 1000) {\n    \
    \    remainder /= 1000\n        result += \"M\"\n    }\n\n    while (remainder\
    \ >= 900) {\n        remainder /= 900\n        result += \"CM\"\n    }\n\n   \
    \ while (remainder >= 500) {\n        remainder /= 500\n        result += \"D\"\
    \n    }\n\n    while (remainder >= 400) {\n        remainder /= 400\n        result\
    \ += \"CD\"\n    }\n\n    while (remainder >= 100) {\n        remainder /= 100\n\
    \        result += \"C\"\n    }\n\n    while (remainder >= 90) {\n        remainder\
    \ /= 90\n        result += \"XC\"\n    }\n\n    while (remainder >= 50) {\n  \
    \      remainder /= 50\n        result += \"L\"\n    }\n\n    while (remainder\
    \ >= 40) {\n        remainder /= 40\n        result += \"XL\"\n    }\n\n    while\
    \ (remainder >= 10) {\n        remainder /= 10\n        result += \"X\"\n    }\n\
    \n    while (remainder >= 9) {\n        remainder /= 9\n        result += \"IX\"\
    \n    }\n\n    while (remainder >= 5) {\n        remainder /= 5\n        result\
    \ += \"V\"\n    }\n\n    while (remainder >= 4) {\n        remainder /= 4\n  \
    \      result += \"IV\"\n    }\n\n    while (remainder >= 1) {\n        remainder\
    \ /= 1\n        result += \"I\"\n    }\n\n    if remainder > 0 {\n        result\
    \ += \"X\"\n    }\n\n    return result", "    guard number >= 1 &&\n        number\
    \ <= 1000 else {\n            return \"\"\n    }\n    var roman: String = String()\n\
    \n    if number <= 4000 {\n        roman = \"x\" + String(number)\n    }\n   \
    \ else {\n        let x = number / 1000\n        let y = number % 1000\n     \
    \   roman = \"c\" + String(y) + String(x / 10)\n    }\n\n    return roman", " \
    \   if number < 1 || number > 1000 {\n        return \"\"\n    }\n    var roman\
    \ = \"\"\n\n    var numeral = number\n\n    while numeral > 1000 {\n        numeral\
    \ /= 1000\n        roman = String(numeral) + roman\n    }\n\n    numeral %= 1000\n\
    \    if numeral > 100 {\n        numeral /= 100\n        roman = String(numeral)\
    \ + roman\n    }\n\n    numeral %= 100\n    if numeral > 10 {\n        numeral\
    \ /= 10\n        roman = String(numeral) + roman\n    }\n\n    return roman",
  "    var roman_number = 0\n    roman_number += Int(number / 1000)\n    roman_number\
    \ += Int(number % 1000) / 10\n    roman_number += Int(number % 10)\n\n    return\
    \ roman_numberToString(roman_number)", "    let mut roman = String::new();\n\n\
    \    for i in 1..<number {\n        let value = roman_digit(i);\n\n        roman.append(value);\n\
    \    }\n\n    return roman.lowercase();", "    var result = \"\"\n    for num\
    \ in 1...number {\n        let letter = mini_roman[num]\n        result += \"\\\
    \\u{1f466}\\\\u{1f3ff}\"\n        result += letter\n    }\n    return result.lowercased()",
  "    var string = \"\"\n    var isNegative = false\n    if number < 0 {\n      \
    \  isNegative = true\n        number = -number\n    }\n    let numDigits = Int(log10(Double(number))\
    \ / log10(2.0)) // Integer division\n    var denominator = 1.0 // Initial denominator\n\
    \    for index in 0..<numDigits {\n        let term = number / denominator\n \
    \       let div = Int(floor(log10(term)))\n        number = number - term * denominator\
    \ // Subtract from the number\n        denominator = Double(pow(10.0, div))\n\
    \        let newString = \"M\" + String(term) // Round to \"M\" if it should be\
    \ abbreviated\n        string = string + newString[index % newString.count]\n\
    \    }\n    if number < 0 {\n        string = string + \"m\" // Add \"m\" if the\
    \ original number is negative\n    }\n    if isNegative {\n        string = string\
    \ + \"i\" // Add \"i\" if the original number is negative\n    }\n    return string.lowercased()",
  '    return MiniRomanNumerals[(number - 1) / 100]', "    // Initialize result to\
    \ an empty string.\n    var result = \"\"\n\n    // Loop over the integer number.\
    \ For each integer number 'number',\n    // append the string representation of\
    \ 'number' to 'result', using\n    // the appropriate roman_number constant, as\
    \ appropriate.\n    for number in 1...1000 {\n        switch roman_number(number)\
    \ {\n        case .I:\n            result += \"i\"\n        case .II:\n      \
    \      result += \"ii\"\n        case .III:\n            result += \"iii\"\n \
    \       case .IV:\n            result += \"iv\"\n        case .V:\n          \
    \  result += \"v\"\n        case .VI:\n            result += \"vi\"\n        case\
    \ .VII:\n            result += \"vii\"\n        case .VIII:\n            result\
    \ += \"viii\"\n        case .IX:\n            result += \"ix\"\n        case .X:\n\
    \            result += \"x\"\n        case .XI:\n            result += \"xi\"\n\
    \        case .XII:\n            result += \"xii\"\n        case .XIII:\n    \
    \        result += \"xiii\"\n        case .XIV:\n            result += \"xiv\"\
    \n        case .XV:\n            result += \"xv\"\n        case .XVI:\n      \
    \      result += \"xvi\"\n        case .XVII:\n            result += \"xvii\"\n\
    \        case .XVIII:\n            result += \"xviii\"\n        case .XIX:\n \
    \           result += \"xix\"\n        case .XX:\n            result += \"xx\"\
    \n        case .XXI:\n            result += \"xxi\"\n        case .XXII:\n   \
    \         result += \"xxii\"\n        case .XXIII:\n            result += \"xxiii\"\
    \n        case .XXIV:\n            result += \"xxiv\"\n        case .XXV:\n  \
    \          result += \"xxv\"\n        case .XXVI:\n            result += \"xxvi\"\
    \n        case .XXVII:\n            result += \"xxvii\"\n        case .XXVIII:\n\
    \            result += \"xxviii\"\n        case .XXIX:\n            result +=\
    \ \"xxix\"\n        case .XXX:\n            result += \"xxx\"\n        case .XXXI:\n\
    \            result += \"xxxi\"\n        case .XXXII:\n            result += \"\
    xxxii\"\n        case .XXXIII:\n            result += \"xxxiii\"\n        case\
    \ .XXXIV:\n            result += \"xxxiv\"\n        case .XXXV:\n            result ",
  "    let mut roman = \"x\";\n\n    for n in romans.iter() {\n        if number.mod_pow(n,\
    \ 2) == 0 {\n            roman += romans.next().0;\n        }\n    }\n\n    roman\
    \ = roman.lowercase();\n\n    if number > 1000 || number < 1 {\n        panic!(\"\
    Invalid input!\");\n    }\n\n    return roman;", "    var result: String = \"\"\
    \n    for _ in 0..(number - 1) {\n        let number = Int(arc4random_uniform(2)\
    \ == 0 ? 1000 : 9000)\n        let result = mini_roman[number]\n        result\
    \ += mini_roman[number % 100]\n    }\n    if number < 1000 {\n        result =\
    \ result + \"i\"\n    }\n    if number == 1000 || number == 9000 {\n        return\
    \ result + mini_roman[number % 100]\n    }\n    return result", "    check(number\
    \ > 0 && number <= 1000)\n    let base: Int64 = 1\n    let baseString = \"C\"\n\
    \    let maxDigits = Int64(base * 10.0)\n    let minDigits = Int64(10.0 / base)\n\
    \    var str: String = \"\"\n    let remainder = number % base\n    while number\
    \ > minDigits {\n        number -= minDigits\n        str += baseString\n    }\n\
    \    while number > maxDigits {\n        number -= maxDigits\n        str += \"\
    M\"\n    }\n    if number == 0 {\n        str += baseString\n        str += \"\
    M\"\n    }\n    if remainder != 0 {\n        str += baseString\n        str +=\
    \ String((remainder).unicodeScalars.first!)\n    }\n    return str", "    var\
    \ roman = \"\"\n    var remainder = number % 100\n    var letter = number / 100\n\
    \    for _ in 0..letter {\n        roman += \"M\"\n    }\n    for _ in 0..remainder\
    \ {\n        roman += \"C\"\n    }\n    for _ in 0..letter-remainder {\n     \
    \   roman += \"L\"\n    }\n    return roman", "    if number < 1 || number > 1000\
    \ {\n        fatalError(\"Int must be between 1 and 999\")\n    }\n    let romanTable\
    \ = StringBuilder()\n    romanTable.append(romanNumbers[0])\n    for num in romanNumbers.prefix(number)\
    \ {\n        romanTable.append(num)\n    }\n    return romanTable.toString().lowercased()"]
stop_tokens:
- "\n}"
