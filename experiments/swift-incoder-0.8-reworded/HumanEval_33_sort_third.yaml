name: HumanEval_33_sort_third
language: swift
prompt: "\n/// This function takes an array l and returns an array l' such that\n\
  /// l' is identical to l in the indicies that are not divisible by three, while\
  \ its values at the indicies that are divisible by three are equal\n/// to the values\
  \ of the corresponding indicies of l, but sorted.\n/// >>> sort_third(l: [1, 2,\
  \ 3])\n/// [1, 2, 3]\n/// >>> sort_third(l: [5, 6, 3, 4, 8, 9, 2])\n/// [2, 6, 3,\
  \ 4, 8, 9, 5]\nfunc sort_third(l: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2]) ==\
  \ [2, 6, 3, 4, 8, 9, 5])\nassert(sort_third(l: [5, 8, 3, 4, 6, 9, 2]) == [2, 8,\
  \ 3, 4, 6, 9, 5])\nassert(sort_third(l: [5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8,\
  \ 3, 5])\nassert(sort_third(l: [5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5,\
  \ 1])"
completions: ["    var l1 = l.slice()\n    l1.sortInPlace()\n    for i in 0..<l1.count\
    \ {\n        if i%3 == 0 && l1[i] != l1[i-1] {\n            l1[i] = l1[i-1]\n\
    \        }\n    }\n    return l1", "    var result = [Int]()\n    var third =\
    \ Int()\n    for i in 0..<l.count {\n        if l[i] % 3 == 0 {\n            third\
    \ = l[i]\n        } else {\n            result.insert(third, l[i])\n        }\n\
    \    }\n    return result", "    l.sort({ a, b in\n        (a%3 == 0 && b%3 ==\
    \ 0) || (a%3 == 0 && b%3 == 1) || (a%3 == 1 && b%3 == 0)\n    })\n    return l",
  "    var l1: [[Int]]\n\n    for i := 0; i < len(l); i += 3 {\n        if i > 0 {\n\
    \            if l[i-1][0] == l[i] {\n                l1[len(l1)-1].append(l[i])\n\
    \            } else {\n                l1.append([l[i]])\n            }\n    \
    \    } else {\n            l1 = append(l1, [l[i]])\n        }\n    }\n\n    return\
    \ l1", "    var third = Int()\n    var l1 = [l[0], l[1], l[2]]\n    for i in l1.indices\
    \ {\n        if i % 3 == 0 {\n            l1[i] = third\n        } else {\n  \
    \          third = l[i]\n        }\n    }\n    return l1", "\tif l.count < 3 {\n\
    \t\treturn l\n\t}\n\n\tlet count = l.count\n\tvar third = [Int](count: count,\
    \ repeatedValue: -1)\n\tfor i in 0..<count {\n\t\tif l[i] % 3 != 0 {\n\t\t\tthird[Int(i)]\
    \ = l[i]\n\t\t}\n\t}\n\tfor i in 0..<count {\n\t\tif third[Int(i)] != -1 {\n\t\
    \t\tfor j in 0..<count {\n\t\t\t\tif j != i && third[Int(i)] > third[Int(j)] {\n\
    \t\t\t\t\tthird[Int(j)] = third[Int(i)]\n\t\t\t\t\tthird[Int(i)] = -1\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn third.map { Int($0) }", "    var res = l\n\
    \    for i in 0..<len(l) {\n        let div = l[i] % 3\n        if div != 0 &&\
    \ div != 3 {\n            res[i] = res[div]\n        }\n    }\n    return res",
  "    let m: [Int] = [Int](l.indices)\n    for i in m.indices {\n        let j =\
    \ i + 2\n        while j<l.count && l[i] < l[j] {\n            swap(&l[i], &l[j])\n\
    \            j += 1\n        }\n    }\n    return l", "    if l.count == 0 {\n\
    \        return []\n    }\n\n    // Set all values not divisible by 3 to 0\n \
    \   var l1 = copy(l)\n    for ix in 0..<l1.count {\n        if ix % 3 == 2 {\n\
    \            \n        }\n    }\n\n    // Set all values divisible by 3 to value\
    \ at indicies divisible by 3\n    var l2 = copy(l)\n    for ix in 0..<l2.count\
    \ {\n        if ix % 3 == 0 {\n            \n        }\n    }\n\n    var l3 =\
    \ copy(l)\n    for ix in 0..<l3.count {\n        if ix % 3 == 1 {\n          \
    \  \n        }\n    }\n\n    \n    l1", "    var l2: Slice<Int> = l\n    var j\
    \ = 0\n    for k in l2[0].indices {\n        l2.append(l2[k].value)\n    }\n \
    \   for i := 0; i < len(l2)-1; i++ {\n        if i % 3 == 0 {\n            j =\
    \ j+1\n            l2.swap(i, j)\n        } else {\n            l2.swap(i, l2[i+1].indices)\n\
    \        }\n    }\n    return l2", "    let thirdIndexes = (0..<l.count).filter{\
    \ (index) -> Bool in\n        index % 3 == 0\n    }\n    \n    var output = [Int]()\n\
    \    \n    thirdIndexes.forEach { index in\n        \n        let thirdIndex =\
    \ index / 3\n        \n        output.insert(l[index], at: thirdIndex)\n    }\n\
    \    \n    return output", "    var l2 = []\n    var i = 1\n    for i = 1; i <\
    \ l.count; i++ {\n        if l[i] % 3 == 0 && l[i-1] % 3 == 0 {\n            l2.append(l[i])\n\
    \        } else {\n            l2.append(l[i-1])\n            l2.append(l[i])\n\
    \        }\n    }\n    return l2", "    var l = l\n    var t = l.sortInPlace()\n\
    \    var r = [Int]()\n    while t.count != 0 {\n        if t.last % 3 == 0 {\n\
    \            r.appendContentsOf(t)\n            t.removeLast()\n        } else\
    \ {\n            t.removeLast()\n        }\n    }\n    return r", "    var result\
    \ = [Int]()\n    for index in l.indices {\n        if index % 3 != 0 {\n     \
    \       result.append(l[index])\n        } else {\n            result.sort()\n\
    \        }\n    }\n    return result", "    return l.sorted { a, b in\n      \
    \  if a == b {\n            return a < b\n        }\n        return a % 3 == b\
    \ % 3\n    }", '    return l.sorted().map { $0 % 3 }.sorted()', "    var l3 =\
    \ [Int]()\n    for element in l {\n        if element % 3 == 0 {\n           \
    \ l3.append(element)\n        } else {\n            l3.sort({ $0 < $1 })\n   \
    \         l3.append(element)\n        }\n    }\n    return l3", "    var l1 =\
    \ [l[0]]\n    for index from 1 to l.count {\n        let val = l[index-1]\n  \
    \      if val % 3 == 0 && l[index] != val {\n            l1.append(val)\n    \
    \    }\n    }\n    return l1", '    return sort_third(l, true, false, false, false)',
  "    // TODO: improve performance of this function\n    var third = Int()\n    var\
    \ thirdIndex = 0\n\n    var firstIndex = 0\n    var firstValue = l[0]\n    var\
    \ secondValue = l[1]\n\n    for _ in 1..<l.count {\n        if thirdIndex < l.count\
    \ {\n            let nextValue = l[thirdIndex]\n\n            if nextValue % 3\
    \ != 0 {\n                thirdIndex += 1\n                third = nextValue\n\
    \            } else {\n                while thirdIndex < l.count {\n        \
    \            let nextIndex = thirdIndex\n\n                    while thirdIndex\
    \ < l.count {\n                        let nextValue = l[thirdIndex]\n\n     \
    \                   if nextValue % 3 != 0 {\n                            break\n\
    \                        } else {\n                            thirdIndex += 1\n\
    \                            third = nextValue\n                        }\n  \
    \                  }\n\n                    let compare = compare(nextValue, firstValue)\n\
    \n                    if compare == .orderedSame {\n                        firstIndex\
    \ = nextIndex\n                        firstValue = nextValue\n              \
    \          break\n                    }\n                }\n            }\n  \
    \      } else {\n            third = firstValue\n            firstIndex = firstValue\n\
    \            firstValue = secondValue\n            secondValue = nextValue\n \
    \       }\n    }\n\n    let sortedFirst = l.sublist(0, firstIndex)\n    let sortedSecond\
    \ = l.sublist(0, secondIndex)\n\n    let sortedThird = [third, third, third, third]\n\
    \n    return sortedFirst + sortedSecond + sortedThird", "    var l3 = []\n   \
    \ for i in 0..<l.count {\n        if i % 3 == 0 {\n            l3.append(l[i])\n\
    \        }\n    }\n    l3.sort()\n    for i in 0..<l.count {\n        if l[i]\
    \ % 3 == 0 && l[i] != l3[0] {\n            l3[i] = l[i]\n        }\n    }\n  \
    \  return l3", "    var l = [Int]()\n    for ind in 0..<l.count {\n        if\
    \ ind % 3 == 0 {\n            l.append(l[ind])\n        }\n    }\n    l.sort()\n\
    \    return l", "\tvar result : [Int] = []\n\tvar thirdIndicies : [Int] = []\n\
    \tfor idx in l.indices  {\n\t\tif idx % 3 == 0 {\n\t\t\tthirdIndicies.append(idx)\n\
    \t\t} else {\n\t\t\tthirdIndicies = thirdIndicies.sorted()\n\t\t\tresult.append(l[thirdIndicies.first])\n\
    \t\t\tresult.insert((thirdIndicies.first + 1), l[idx])\n\t\t\tthirdIndicies.remove(idx)\n\
    \t\t}\n\t}\n\tthirdIndicies = thirdIndicies.sorted()\n\tresult.append(l[thirdIndicies.first])\n\
    \tresult.insert((thirdIndicies.first + 1), l[l.indices.last])\n\treturn result",
  "    var l0 = [Int]()\n    var l1 = [Int]()\n    var l2 = [Int]()\n\n    for i in\
    \ 0..<l.count {\n        if i%3 == 0 {\n            l0.append(l[i])\n        }\
    \ else if i%3 == 1 {\n            l1.append(l[i])\n        } else {\n        \
    \    l2.append(l[i])\n        }\n    }\n\n    return l0 + l1 + l2", "    var sorted\
    \ = [Int]()\n    for idx in l.indices {\n        if idx % 3 == 0 {\n         \
    \   sorted = append(sorted, l[idx])\n        } else {\n            sorted = append(sorted,\
    \ l[idx])\n            sorted = append(sorted, l[idx])\n        }\n    }\n   \
    \ return sorted", "    var l = l\n    var i = 0\n    var j = 0\n    var k = 0\n\
    \    for k in 0 ..< l.count {\n        if k == 3 {\n            j++\n        \
    \    continue\n        }\n        if l[j] < l[k] {\n            l[i], l[j] = l[j],\
    \ l[i]\n        }\n        i += 1\n    }\n    return l", "    var i = 1\n    var\
    \ j = 1\n    var jTwo = 1\n    var iTwo = 1\n    var result = [Int]()\n    var\
    \ iMax = 0\n    var lMax = l.count\n    while (i <= lMax) && (jTwo <= lMax) {\n\
    \        if l[j] % 3 == 0 {\n            while (iTwo <= iMax) {\n            \
    \    if l[jTwo] % 3 == 0 {\n                    result.append(l[iTwo])\n     \
    \               jTwo = jTwo + 1\n                    iTwo = iTwo + 1\n       \
    \         } else if l[jTwo] % 3 != 0 {\n                    break\n          \
    \      } else {\n                    break\n                }\n            }\n\
    \            i = i + 1\n            iMax = iMax + 1\n        } else if l[j] %\
    \ 3 != 0 {\n            j = j + 1\n            jTwo = jTwo + 1\n        } else\
    \ {\n            jTwo = jTwo + 1\n            iTwo = iTwo + 1\n        }\n   \
    \ }\n    return sort_third(result)", "    var l2 = []\n    var divisibleByThree\
    \ = false\n    var k = 0\n    for x in l {\n        if x % 3 == 0 {\n        \
    \    divisibleByThree = true\n        }\n        if divisibleByThree {\n     \
    \       assert(x < l[k])\n            l2.append(x)\n            k = k + 1\n  \
    \      } else {\n            l2.append(x)\n        }\n    }\n    return l2", " \
    \   var l = l\n    if l.count < 3 {\n        return l\n    }\n    for i in 0..<l.count\
    \ - 1 {\n        if l[i] == l[i] {\n            continue\n        }\n        for\
    \ j in (i + 1..<l.count) {\n            if (l[j] - l[i]) % 3 == 0 {\n        \
    \        let temp = l[i]\n                l[i] = l[j]\n                l[j] =\
    \ temp\n            }\n        }\n    }\n    return l", "\treturn array_of_sorted_indices_of_nondivisible(l)",
  "    var newL = make([]Int, len(l))\n    for i in 0..<len(l) {\n        let j =\
    \ (l.index(of: l[i]) ?? -1) / 3\n        newL[newL.index(of: l[i])] = l[j]\n \
    \   }\n    return newL", "    var l2 = l.slice()\n    let n = l2.count\n    for\
    \ i in 0..<n-3 {\n        let j = i + 2\n        let k = i+3\n        let l3 =\
    \ l2.slice()\n        let l4 = l3.removeLast()\n        l2.removeLast()\n    \
    \    l2.insert(l4, atIndex: i)\n        l2.insert(l3[i], atIndex: j)\n    }\n\
    \    return l2", "    var l = l\n    let lLen = l.count\n    if lLen > 0 {\n \
    \       for _ in 0..<lLen {\n            for j in 0..<lLen {\n               \
    \ if j < j+1 {\n                    if j+1 < lLen && l[j] > l[j+1] {\n       \
    \                 l[j] = l[j+1]\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return l", "    let len = l.count\n    var\
    \ i = 0\n    var j = 0\n    var k = 0\n    var ltemp: Int\n\n    while i < len\
    \ {\n        ltemp = l[i]\n        if ltemp%3 == 0 {\n            j = j + 1\n\
    \            while j < len && ltemp == l[j] {\n                j = j + 1\n   \
    \         }\n            k = k + 1\n            while k < len && ltemp == l[k]\
    \ {\n                k = k + 1\n            }\n            if j < k {\n      \
    \          i = i + 1\n                if i < len {\n                    ltemp\
    \ = l[i]\n                    while i < len && ltemp == l[i] {\n             \
    \           i = i + 1\n                    }\n                }\n            \
    \    j = 0\n                k = k - 1\n            }\n            if j > k {\n\
    \                for _ in 0..<(j-k)+1 {\n                    l.swap(k, l)\n  \
    \              }\n                k = k - 1\n            }\n        } else {\n\
    \            i = i + 1\n        }\n    }\n    return l", "    var thirdIndexes\
    \ = [Int]()\n    var thirds = [Int]()\n    var third = Int()\n    var i = 0\n\
    \    while i < l.count {\n        third = l[i]\n        if i % 3 == 0 {\n    \
    \        if !contains(thirdIndexes, i) {\n                thirdIndexes.append(i)\n\
    \                thirds.append(third)\n            }\n        } else {\n     \
    \       if contains(thirdIndexes, i) {\n                if thirds[i] != third\
    \ {\n                    thirdIndexes[i] = 0\n                }\n            }\n\
    \        }\n        i += 1\n    }\n    var newL = [Int]()\n    for i in 0..<thirdIndexes.count\
    \ {\n        newL.append(thirds[thirdIndexes[i]])\n    }\n    return newL", " \
    \   var i = 0\n    var j = 0\n    var temp = 0\n    var a = [Int](count: l.count,\
    \ repeatedValue: 0)\n\n    while i < l.count {\n        // Keep increasing i until\
    \ the next group of indicies is divisible by three.\n        if i < l.count {\n\
    \            while (i + 1 < l.count) && (l[i] % 3 != 0) {\n                i +=\
    \ 1\n            }\n            // Move the remaining indicies down to the correct\
    \ place in the list.\n            while (i + 1 < l.count) {\n                a[j]\
    \ = l[i]\n                i += 1\n                j += 1\n            }\n    \
    \    }\n        // Check if all indicies are divisible by three, and if so break\
    \ out of the while loop\n        if i == l.count {\n            break\n      \
    \  }\n        // Move the next group of indicies down to the correct place in\
    \ the array.\n        while (i + 1 < l.count) && (l[i + 1] % 3 == 0) {\n     \
    \       temp = a[i]\n            a[i] = a[i + 1]\n            a[i + 1] = temp\n\
    \            i += 1\n            j += 1\n        }\n    }\n    return a", "  \
    \  var l2 = [Int](l)\n    l2.sort()\n    for idx in 0..<l2.count {\n        if\
    \ idx % 3 == 0 {\n            l2[idx], l2[idx+1], l2[idx+2] = l2[idx+1], l2[idx+2],\
    \ l2[idx]\n        }\n    }\n    return l2", "    if l == nil {\n        return\
    \ nil\n    }\n    var result = [Int]()\n    for index in 0..<l.count {\n     \
    \   var indexFound = false\n        var thirdIndex = index\n        if index ==\
    \ 3 {\n            continue\n        }\n        for secondIndex in 0..<l.count\
    \ {\n            if thirdIndex == 3 {\n                continue\n            }\n\
    \            if l[index] < l[secondIndex] {\n                thirdIndex = secondIndex\n\
    \            }\n        }\n        if thirdIndex != index {\n            result.append(l[index])\n\
    \            result.append(l[thirdIndex])\n        }\n    }\n    return result",
  "    var l1 = l.slice()\n    var l2 = l.slice()\n    l2.sort()\n    l2.forEachIndexed\
    \ { idx, v in\n        if idx % 3 == 0 { l1[idx] = l2[idx / 3] }\n    }\n    return\
    \ l1", "    var l2 = l // copy\n    var i = 2\n    var j = 0\n    while i < l2.length\
    \ {\n        if l2[i] % 3 == 0 {\n            swap(&l2[i], &l2[j])\n         \
    \   j++\n        }\n        else {\n            i += 1\n        }\n    }\n   \
    \ l2.reverse()\n    return l2", "    var result = Array(l)\n    let len = result.count\n\
    \    var count = 3\n    while count > 0 {\n        count -= 1\n        if count\
    \ % 3 == 0 && count != 0 {\n            for j in 0 ..< len - 1 {\n           \
    \     if j % 3 == 0 && result[j] > result[j+1] {\n                    let tmp\
    \ = result[j]\n                    result[j] = result[j+1]\n                 \
    \   result[j+1] = tmp\n                }\n            }\n        }\n    }\n  \
    \  return result", "    var res = l\n    for i in 0..<res.count {\n        if\
    \ i % 3 == 0 {\n            switch i {\n            case 0: res[0] = 0\n     \
    \       case 1: res[1] = res[0]\n            case 2: res[2] = res[0]\n       \
    \     case 3: res[3] = res[0]\n            case 4: res[4] = res[0]\n         \
    \   case 5: res[5] = res[0]\n            case 6: res[6] = res[0]\n           \
    \ case 7: res[7] = res[0]\n            case 8: res[8] = res[0]\n            case\
    \ 9: res[9] = res[0]\n            case 10: res[10] = res[0]\n            case\
    \ 11: res[11] = res[0]\n            case 12: res[12] = res[0]\n            case\
    \ 13: res[13] = res[0]\n            case 14: res[14] = res[0]\n            case\
    \ 15: res[15] = res[0]\n            default: print(\"ERROR! Index out of range\"\
    )\n            }\n        }\n    }\n    return res", "    var threes = false\n\
    \    var result = [Int]()\n    var threeCount = 0\n    for v in l {\n        if\
    \ v%3 == 0 {\n            threes = true\n            threeCount++\n        }\n\
    \        if !threes {\n            result.append(v)\n        }\n        if threes\
    \ && threeCount > 1 {\n            threeCount--\n            if v%3 == 0 {\n \
    \               threes = false\n            }\n        }\n    }\n    return result",
  "    var res: [Int] = []\n    \n    for index, _ in  enumerate(l) {\n        if\
    \ index % 3 != 0 {\n            res.append(l[index])\n        } else {\n     \
    \       var i = index\n            \n            repeatWhile { i < len(l) && l[i]\
    \ % 3 != 0 } { i++ }\n            \n            var j = index\n            \n\
    \            repeatWhile { j < len(l) && l[j] % 3 == 0 } { j++ }\n           \
    \ \n            res.append(l[i])\n            res.append(l[j])\n        }\n  \
    \  }\n    \n    return res", "    var l1 : [Int] = []\n    for v in l {\n    \
    \    var ind = -1\n        var lastind = -1\n        for (i, e) in l1.enumerated()\
    \ {\n            if v%3 == 0 {\n                if i != ind {\n              \
    \      l1.insert(ind, v)\n                    lastind = ind\n                }\n\
    \                break\n            }\n            if v == e {\n             \
    \   if i != ind {\n                    ind = i\n                }\n          \
    \      break\n            }\n        }\n        if lastind == -1 {\n         \
    \   l1.append(v)\n        }\n    }\n    return l1", "    let third = Int(arc4random_uniform(UInt32(l.count)))\n\
    \    var newArr = [Int]()\n    let startIdx = Int(arc4random_uniform(UInt32(l.count)))\n\
    \    for i in 0..<third {\n        guard i < l.count else { break }\n        let\
    \ index = l.index(of: l[startIdx])!\n        newArr.append(l[index])\n       \
    \ l.remove(at: index)\n        startIdx = index\n    }\n    return newArr", " \
    \   var a = l // Make a copy to avoid mutating input array\n    for i in 0..<a.count\
    \ {\n        if a[i] % 3 == 0 && i >= a[i] {\n            let i1 = i - (a[i] %\
    \ 3)\n            a[i] = a[i1]\n            a[i1] = a[i]\n        }\n    }\n \
    \   return a", "    if l.count < 3 {\n        return l\n    }\n    var third =\
    \ Int()\n    var thirdIndex = 0\n    for i in 0 ..< l.count {\n        if i %\
    \ 3 == 0 {\n            third = l[i]\n            thirdIndex = i\n        }\n\
    \    }\n    var result = [Int]()\n    for i in 0 ..< l.count {\n        if i !=\
    \ thirdIndex {\n            result.append(l[i])\n        }\n    }\n    for index\
    \ in 1 ..< thirdIndex {\n        for element in 0 ..< thirdIndex {\n         \
    \   if element != index {\n                result.append(l[index])\n         \
    \   }\n        }\n    }\n    for element in 0 ..< third {\n        result.append(l[third])\n\
    \    }\n    return result", "    guard l.count % 3 == 0 else {\n        return\
    \ l\n    }\n    var result: [Int] = l\n    var tmp: [Int] = []\n    for i in 0..<l.count\
    \ {\n        if i % 3 == 0 {\n            result.append(tmp)\n            tmp\
    \ = []\n        }\n        tmp.append(l[i])\n    }\n    result.append(tmp)\n \
    \   return result", "    var thirdCount = 0\n    for x in l {\n        if x %\
    \ 3 == 0 && x < 3 {\n            thirdCount++\n        }\n    }\n    if thirdCount\
    \ == 0 {\n        return l\n    }\n    var result = [Int]()\n    var currentCount\
    \ = 0\n    for x in l {\n        if x % 3 == 0 {\n            result[currentCount]\
    \ = x\n            currentCount++\n        }\n    }\n    result[currentCount:]\
    \ = sorted(result[currentCount:])\n    return result", '    return l.sorted {
    $0 % 3 > $1 % 3 > $2 % 3 ? $0 : $1 }', '    return l.sorted { $0 % 3 == 0 || $0
    % 5 == 0 || $0 % 7 == 0 }', "    var result = [Int]()\n    for i : Int in 0..<l.count\
    \ {\n        if i % 3 == 0 {\n            result.append(l[i])\n        }\n   \
    \ }\n    result.sort()\n    for i : Int in 0..<result.count {\n        result[i]\
    \ = result[i] % 3\n    }\n    return result", "    l.sort()\n    let len = l.count\n\
    \    let third = l.count / 3\n    var l2 = [Int](count: len, repeatedValue: -1)\n\
    \    var l2_index = 0\n    var l1_index = 0\n    var l3_index = 0\n    while l3_index\
    \ < len {\n        if l2_index < third {\n            if l2[l2_index] == -1 {\n\
    \                l2[l2_index] = l[l1_index]\n                l2[l2_index] += l[l1_index\
    \ + 1]\n                l2[l2_index] += l[l1_index + 2]\n                l2[l2_index]\
    \ += l[l1_index + 3]\n                l2[l2_index] += l[l1_index + 4]\n      \
    \          l2[l2_index] += l[l1_index + 5]\n                l2[l2_index] += l[l1_index\
    \ + 6]\n                l2[l2_index] += l[l1_index + 7]\n                l2[l2_index]\
    \ += l[l1_index + 8]\n                l2[l2_index] += l[l1_index + 9]\n      \
    \          l2[l2_index] += l[l1_index + 10]\n                l2[l2_index] += l[l1_index\
    \ + 11]\n                l2[l2_index] += l[l1_index + 12]\n                l2[l2_index]\
    \ += l[l1_index + 13]\n                l2[l2_index] += l[l1_index + 14]\n    \
    \            l2[l2_index] += l[l1_index + 15]\n                l2[l2_index] +=\
    \ l[l1_index + 16]\n                l2[l2_index] += l[l1_index + 17]\n       \
    \         l2[l2_index] += l[l1_index + 18]\n                l2[l2_index] += l[l1_index\
    \ + 19]\n                l2[l2_index] += l[l1_index + 20]\n                l2[l2_index]\
    \ += l[l1_index + 21]\n                l2[l2_index] += l[l1_index + 22]\n    \
    \            l2[l2_index] += l[l1_index + 23]\n                l2[l2_index] +=\
    \ l[l1_index + 24]\n                l2[l2_index] += l[l1_index + 25]\n       \
    \         l2[l2_index] += l[l1_index + 26]\n                l2[l2_index] += l[l1_index\
    \ + 27]\n                l2[l2_index] += l[l1_index + 28]\n                l2[l2_index]\
    \ += l[l1_index + 29]\n                l2[l2_index] += l[l1_index + 30]\n    \
    \            l2[l2_index] += l[l1_index + 31]\n                l2[l2_index] +=\
    \ l[l1_index + 32]\n                l2[l2_index] += l[l1_index + 33]\n       \
    \         l2[l2_index] += l[l1_index + 34]\n                l2[", "    var result:\
    \ [Int] = []\n    for ix in l.stride(from: 1, through: l.count, by: 1) {\n   \
    \     if ix.remainder(dividingBy: 3) != 0 || ix == 0 {\n            result.append(ix);\n\
    \        } else {\n            switch ix.remainder(dividingBy: 3) {\n        \
    \    case 1:\n                result.append(result[ix.remainder(dividingBy: 3)])\n\
    \            case 2:\n                result.append(result[ix.remainder(dividingBy:\
    \ 3)] + result[ix.remainder(dividingBy: 3)])\n            }\n        }\n    }\n\
    \    return result", "    return sort_impl(nil, l, func(i, j int) {\n        return\
    \ i != j\n    })", "    var l1 = []\n    for v in l {\n        var i = v\n   \
    \     if v % 3 == 0 {\n            while v % 3 == 0 {\n                i -= 1\n\
    \                v /= 3\n            }\n        } else {\n            while v\
    \ % 3 == 0 {\n                i += 1\n                v /= 3\n            }\n\
    \        }\n        l1.append(v)\n        l1.append(i)\n    }\n    sort_third(l1)\n\
    \    return l1", "    let m = (l.count + 3) / 3\n    let r = make(l.count, m)\n\
    \    for i in 0..<m {\n        let l2 = make(l.count, 3)\n        let j = i\n\
    \        while j + 2 < l.count {\n            l2[j], l2[j + 1], l2[j + 2] = l[j],\
    \ l[j + 1], l[j + 2]\n            j += 3\n        }\n        if j < l.count {\n\
    \            l2[j] = l[j]\n        }\n        r[i / 3] = l2\n    }\n    var result\
    \ = [Int]()\n    for i in 0..<m {\n        result = append(result, r[i / 3][(i\
    \ + 1) % m])\n    }\n    return result", "    var l2 = l.sorted()\n    for i in\
    \ 0..<l2.count {\n        if i % 3 == 0 {\n            l2[i] = l2[i]\n       \
    \ } else {\n            if l2[i] != 0 {\n                var j = i + 1\n     \
    \           while j < l2.count && l2[j] == 0 {\n                    j++\n    \
    \            }\n                if j < l2.count {\n                    l2[i] =\
    \ l2[j]\n                } else {\n                    l2.remove(at: i)\n    \
    \            }\n            }\n        }\n    }\n    return l2", "    let len\
    \ = l.count\n    var res: [Int] = Array(repeating: 0, count: len)\n    var remaining\
    \ = len\n    for i in 0..<len {\n        if i % 3 == 0 {\n            res[i] =\
    \ l[i]\n            remaining -= 1\n        } else {\n            res[i] = l[i]\
    \ < l[i+1] ? l[i] : l[i+1]\n        }\n    }\n    while remaining > 0 {\n    \
    \    res[len] = l[len-1]\n        remaining -= 1\n    }\n    return res", "  \
    \  var len = 0\n    var lastInd = -1\n    for ind, i in enumerate(l) {\n     \
    \   if ind == 0 {\n            lastInd = ind\n        }\n        if lastInd !=\
    \ -1 && (ind % 3 == 0 || i == l[lastInd]) {\n            l[lastInd] = i\n    \
    \        lastInd = -1\n        } else {\n            len += 1\n            lastInd\
    \ = ind\n        }\n    }\n    return l", "    var l2 = []\n    for i in l {\n\
    \        let index = i / 3\n        if index == Int(index) {\n            l2.append(i)\n\
    \        } else {\n            l2.append(l[index])\n        }\n    }\n    return\
    \ l2", "    var third = make([]Int, l.count)\n    for i := 0; i < len(l); i +=\
    \ 3 {\n        third[i] = l[i]\n        third[i+1] = l[i+1]\n        third[i+2]\
    \ = l[i+2]\n    }\n    var result = [Int]()\n    for i := 0; i < len(l); i +=\
    \ 3 {\n        if l[i] != third[i] || l[i+1] != third[i+1] || l[i+2] != third[i+2]\
    \ {\n            result.sortInPlace()\n        }\n        result.append(l[i])\n\
    \    }\n    return result", "\tvar t = [Int]()\n\n\tfor i in 0..<l.count {\n\t\
    \tif l[i] % 3 == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tt.append(l[i])\n\t}\n\n\tt.sort()\n\
    \n\tvar r = [Int]()\n\n\tfor i in 0..<t.count {\n\t\tr.append(t[i])\n\t}\n\n\t\
    return r", "    l.sortInPlace()\n    return l", "    var l2 = []\n    var index\
    \ = 0\n    repeat{\n        if index % 3 == 0 && index < l.count{\n          \
    \  l2.append(l[index])\n        }\n        index += 1\n    }\n    return l2",
  "    func sort_first(l: [Int]) -> [Int] {\n        return l.sorted(by: { (a, b)\
    \ -> Bool in\n            return a % 3 == 0 && a < b\n        })\n    }\n\n  \
    \  func sort_second(l: [Int]) -> [Int] {\n        return l.sorted(by: { (a, b)\
    \ -> Bool in\n            return a % 3 == 1 && a < b\n        })\n    }\n\n  \
    \  func sort_third(l: [Int]) -> [Int] {\n        return l.sorted(by: { (a, b)\
    \ -> Bool in\n            return a % 3 == 2 && a < b\n        })\n    }\n\n  \
    \  return sort_first(sort_second(sort_third(l)))", "    var result = [Int]()\n\
    \    for x in l {\n        if x % 3 == 0 {\n            let idx = l.index(of:\
    \ x)!\n            result.append(result[idx])\n            result[idx] = x\n \
    \       } else {\n            result.append(x)\n        }\n    }\n    return result",
  "    var res: [Int] = []\n    for n in l {\n        var i = 0\n        for _ in\
    \ 0..<3 {\n            if i < n {\n                i += 1\n            } else\
    \ {\n                res.append(n)\n                n = n%3\n            }\n \
    \       }\n        res.append(n)\n    }\n    return res", "    let res = [Int]()\n\
    \    for (index, val) in l.enumerated() {\n        if index != (index % 3) {\n\
    \            res.append(val)\n        }\n    }\n    return res", "    var res\
    \ = l\n    if l.count == 0 {\n        return res\n    }\n    if l.count == 1 {\n\
    \        // if there's only one item, just return it\n        return l\n    }\n\
    \    if l.count == 3 {\n        // if there's only three items,\n        // they\
    \ need to be sorted in this order\n        return l.sort()\n    }\n    // if there's\
    \ more than three items,\n    // they need to be sorted in the order 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3\n    let pivot = 3\n    let low = l\n    let high = l.slice()\n\
    \    // get indexes for low and high that contain the values of low and high\n\
    \    // but not in order 1, 2, 3, 1, 2, 3, 1, 2, 3\n    let lowIndex = highIndexes(low)\n\
    \    let highIndex = lowIndexes.reversed()\n    let lowRes = l[lowIndex]\n   \
    \ let highRes = l[highIndex]\n    \n    for index in lowIndex {\n        // if\
    \ low index is divisible by three, swap the values\n        // of low and high\
    \ and repeat for the remaining three\n        if index % 3 == 0 && index != 0\
    \ {\n            res[index] = lowRes\n            lowRes = highRes\n         \
    \   highRes = l[index]\n            // move on to the next index\n           \
    \ index += 1\n            continue\n        }\n        // otherwise if index is\
    \ 0, move on to the next\n        // index in low or high\n        res[index]\
    \ = lowRes\n        lowRes = highRes\n        highRes = l[index]\n        // move\
    \ on to the next index\n        index += 1\n    }\n    \n    // now that low and\
    \ high have been swapped, sort them in order\n    for index in highIndex {\n \
    \       res[index] = highRes\n        highRes = l[index]\n    }\n    return res",
  "    var third = l\n    for index in 0..<l.count {\n        if index % 3 == 0 {\n\
    \            third.swap(index, index+2)\n        }\n    }\n    return third",
  "    if l == nil {\n        return nil\n    }\n    var l2 = [Int]()\n    for i :\
    \ Int in l.indices {\n        if i % 3 == 0 && i != 0 {\n            l2.append(l[i])\n\
    \        } else {\n            l2.append(i)\n        }\n    }\n    return l2",
  "    var result = [Int]()\n    var counter = 0\n    for element in l {\n       \
    \ if element % 3 == 0 {\n            for index in result {\n                if\
    \ index == element {\n                    continue //we found the same index twice\n\
    \                }\n            }\n            result[counter] = element\n   \
    \         counter += 1\n        }\n    }\n    for index in result {\n        element.removeAtIndex(index)\n\
    \    }\n    return result", "\tidx := make([]int, 0, len(l))\n\tcounts := make([]int,\
    \ 0, len(l))\n\n\ti := 0\n\tl := sort_unique(l)\n\n\tfor _, val := range l {\n\
    \t\tcounts[i%len(l)] += 1\n\t\tif counts[i%len(l)] % 3 == 0 {\n\t\t\tidx[i%len(l)]\
    \ = val\n\t\t\ti++\n\t\t}\n\t}\n\n\tsort.Ints(idx)\n\tl := make([]int, len(idx))\n\
    \tcopy(l, idx)\n\treturn l", "    let (_, indexes, unordered) = partition(l, &is_divisible_by_three)\n\
    \    \n    let indexes = indexes.sorted()\n    \n    if let (first, second, third)\
    \ = zip(indexes, indexes, indexes) {\n        let firstValue = l[first]\n    \
    \    let secondValue = l[second]\n        let thirdValue = l[third]\n        \n\
    \        if firstValue != secondValue && firstValue != thirdValue && secondValue\
    \ != thirdValue {\n            return l + [firstValue, secondValue, thirdValue]\n\
    \        } else {\n            return l + [firstValue, secondValue, thirdValue,\
    \ l[second]]\n        }\n    } else {\n        return l\n    }", "    let mid\
    \ = l.count / 2\n    var l1 = [l[2*mid], l[2*mid + 1]]\n    var l2 = [l[2*mid],\
    \ l[2*mid + 1]]\n    var l3 = [l[2*mid], l[2*mid + 1]]\n    for i in 0 ..< mid\
    \ {\n        if l[i] == l[2*mid] {\n            l1[i] = l2[i] = l3[i] = l[i]\n\
    \        } else {\n            l1[i] = l2[i]\n        }\n    }\n    return l1",
  "    var l = l\n    var l3 = l\n    l3.sort(by: { a, b in\n        return a % 3\
    \ == 0 && b % 3 == 0\n    })\n    var r = [Int](repeating: 0, count: l.count)\n\
    \    for i in l3 {\n        if r[i] != 0 || (r[i] == 0 && l[i] % 3 == 0) {\n \
    \           continue\n        }\n        r[i] = l[i]\n    }\n    return r", " \
    \   var l = l as NSMutableArray\n    for index in 0..<l.count {\n        let i\
    \ = index\n        let j = index%3\n        if i != j {\n            let t = l.objectAtIndex(index)\
    \ as Int\n            l.removeObjectAtIndex(index)\n            l.insertObjectAtIndex(t,\
    \ atIndex: j)\n        }\n    }\n    return l as [Int]", "    let len = l.count\n\
    \    var a: [Int] = []\n    var i = 0\n    var j = 1\n    while i < len {\n  \
    \      if ((j + 1) % 3 == 0) {\n            i += 1\n        }\n        if ((j\
    \ - 1) % 3 == 0) {\n            j += 1\n        }\n        if ((j + 1) % 3 ==\
    \ 0) {\n            a[j] = l[i]\n            i += 1\n            j += 1\n    \
    \    }\n        if ((j - 1) % 3 == 0) {\n            a[j] = l[i]\n           \
    \ i += 1\n            j += 1\n        }\n    }\n    return a", "    let len =\
    \ l.count\n    let halfLen = len / 2\n    if len % 3 > 0 {\n        let rem =\
    \ len % 3\n        for _ in 0 ..< rem {\n            swap(l, halfLen + 0, halfLen\
    \ + 1)\n        }\n    }\n    return l", "    var l1 = l\n    let l = l1\n   \
    \ l1[0] = l2[0]\n    l1[1] = l2[1]\n    l1[2] = l2[2]\n    return l1", "    var\
    \ sortedThirdIndexes = [Int]()\n    var sortedThirdValues = [Int]()\n    for i\
    \ in 0..<l.count {\n        if i % 3 == 0 {\n            sortedThirdIndexes.append(i)\n\
    \        } else {\n            sortedThirdValues.append(l[i])\n        }\n   \
    \ }\n    for index in sortedThirdIndexes {\n        l[sortedThirdIndexes[sortedThirdIndexes.index(index)]]\
    \ = sortedThirdValues[sortedThirdValues.index(index)]\n    }\n    return l", "\t\
    var l2 = []\n\tfor _, i := range l {\n\t\tif i / 3 != i {\n\t\t\tl2 = append(l2,\
    \ i)\n\t\t}\n\t}\n\tsort.Ints(l2)\n\treturn l2", "    l.sort()\n    var r = [Int]()\n\
    \    for i in 0..<l.count {\n        if i % 3 != 0 {\n            r.append(l[i])\n\
    \        }\n    }\n    return r", "    var result = [Int]()\n    \n    for i in\
    \ 0..<l.count {\n        if i % 3 == 0 {\n            result.append(l[i])\n  \
    \      } else {\n            result.append(l[(l[i] - 1)/3])\n        }\n    }\n\
    \    \n    return result", "    var l : [Int]\n    for index0 in 0..<l.count {\n\
    \        var index Int = 0\n        for index1 in index0..<l.count {\n       \
    \     if index % 3 != 0 {\n                l[index0] = l[index1]\n           \
    \ } else {\n                index = index1 + 1\n            }\n        }\n   \
    \ }\n    return l", "\tvar l1 = l.slice()\n\tl1.sort()\n\tl1.reverse()\n\treturn\
    \ l1", "    var result = [Int]()\n    for i in 0..<l.count {\n        let divisor\
    \ = l.count - i\n        if divisor == 3 {\n            result.insert(l[i], at:\
    \ i)\n        } else if divisor == 2 {\n            result.append(l[i])\n    \
    \    }\n    }\n    return result", "    \n    var l = l\n    var u = [Int]()\n\
    \    \n    var i : Int = 0\n    var j : Int = 0\n    var k :  Int = 0\n    \n\
    \    while i < l.count {\n        if i % 3 == 0 {\n            j = i\n       \
    \     while j > 1 {\n                if l[j-1] > l[j] {\n                    u\
    \ = append(u, l[j-1])\n                    l.remove(at: j-1)\n               \
    \ } else {\n                    break\n                }\n                j -=\
    \ 1\n            }\n        }\n        u.append(l[i])\n        i += 1\n    }\n\
    \    \n    return u", "    var len: Int = count(l)\n    var len2: Int = len /\
    \ 3\n\n    // if array is already sorted, just return it\n    if len <= 2 {\n\
    \        return l\n    }\n\n    // if array is too long, just sort a subsection\
    \ of the array\n    if len > 5 {\n        len2 = Int(ceil(Double(len) / 3.0))\n\
    \    }\n\n    if len2 < 1 {\n        return l\n    }\n\n    // build second array,\
    \ containing all values not divisible by 3\n    // and corresponding values of\
    \ l\n    var l2 = [Int]()\n    var l3 = []\n    for i in 0..<len2 {\n        let\
    \ i2 = i + (len2 - 1) * 3\n        l3.append(l[i])\n        l3.append(l[i2])\n\
    \    }\n\n    // build third array (sorted by l) and merge it with l2\n    var\
    \ l4 = [Int]()\n    l4.mergeSort(by: { l3.index(of: $0) >= l3.index(of: $1) })\n\
    \    l4 = l4 + l2\n\n    return l4", "    let lt = l.sorted()\n    let lt2 = lt[..<3]\n\
    \    let lt3 = lt2\n    let lt4 = lt3\n    let lt5 = lt4\n    let lt6 = lt5\n\
    \    let lt7 = lt6\n    let lt8 = lt7\n    let lt9 = lt8\n    let lt10 = lt9\n\
    \    let lt11 = lt10\n    let lt12 = lt11\n    let lt13 = lt12\n    let lt14 =\
    \ lt13\n    let lt15 = lt14\n    let lt16 = lt15\n    let lt17 = lt16\n    let\
    \ lt18 = lt17\n    let lt19 = lt18\n    let lt20 = lt19\n    let lt21 = lt20\n\
    \    let lt22 = lt21\n    let lt23 = lt22\n    let lt24 = lt23\n    let lt25 =\
    \ lt24\n    let lt26 = lt25\n    let lt27 = lt26\n    let lt28 = lt27\n    let\
    \ lt29 = lt28\n    let lt30 = lt29\n    let lt31 = lt30\n    let lt32 = lt31\n\
    \    let lt33 = lt32\n    let lt34 = lt33\n    let lt35 = lt34\n    let lt36 =\
    \ lt35\n    let lt37 = lt36\n    let lt38 = lt37\n    let lt39 = lt38\n    let\
    \ lt40 = lt39\n    let lt41 = lt40\n    let lt42 = lt41\n    let lt43 = lt42\n\
    \    let lt44 = lt43\n    let lt45 = lt44\n    let lt46 = lt45\n    let lt47 =\
    \ lt46\n    let lt48 = lt47\n    let lt49 = lt48\n    let lt50 = lt49\n    let\
    \ lt51 = lt50\n    let lt52 = lt51\n    let lt53 = lt52\n    let lt54 = lt53\n\
    \    let lt55 = lt54\n    let lt56 = lt55\n    let lt57 = lt56\n    let lt58 =\
    \ lt57\n    let lt59 = lt58\n    let lt60 = lt59\n    let lt61 = lt60\n    let\
    \ lt62 = lt61\n    let lt63 = lt62\n    let lt64 = lt63\n    let lt65 = lt64\n\
    \    let lt66 = lt65\n    let lt67 = lt66\n    let lt68 = lt67\n    let lt69 =\
    \ lt68\n    let lt70 = lt69\n    let lt71 = lt70\n    let lt72 = lt71\n    let\
    \ lt73 = lt72\n    let lt74 = lt73\n    let lt", "    if l == nil {\n        return\
    \ []\n    }\n    var result = [Int]()\n    var index = 0\n    for i = 0; i < l.count;\
    \ i++ {\n        if i % 3 == 0 {\n            result.append(l[index])\n      \
    \      index++\n        }\n    }\n    result.append(l[index])\n    return result",
  "    l += 0\n    l.sort()\n\n    var i = 0\n    var j = 1\n    var k = l[0]\n  \
    \  var l2 = []\n\n    for element in l {\n        if j == 3 {\n            l2.append(k)\n\
    \            k = element\n            j = 1\n        } else {\n            l2.append(element)\n\
    \            j += 1\n        }\n    }\n    l2.append(k)\n\n    return l2", "\t\
    var l2 = []\n\tvar count = 0\n\tfor i, j := range l {\n\t\tif i % 3 == 0 && i\
    \ != 0 {\n\t\t\tcount += 1\n\t\t}\n\t\tl2 = append(l2, j)\n\t\tif count == 3 {\n\
    \t\t\tbreak\n\t\t}\n\t}\n\tsort.Ints(l2)\n\treturn l2", "    \n    let nElements\
    \ = l.count\n    \n    var third: Int = 0\n    var thirdIndex: Int = 0\n    \n\
    \    let thirdArray = [Int](repeating: 0, count: nElements)\n    \n    for i in\
    \ 0..<nElements {\n        \n        if i % 3 == 0 {\n            thirdArray[thirdIndex]\
    \ = l[i]\n            thirdIndex += 1\n        }\n        \n        if thirdIndex\
    \ < nElements-1 {\n            third = thirdArray[thirdIndex]\n            \n\
    \            if l[i] < third {\n                \n                // Swapping\n\
    \                let temp = l[i]\n                l[i] = l[thirdIndex]\n     \
    \           l[thirdIndex] = temp\n            }\n        }\n    }\n    \n    return\
    \ l", "    defer { l.sort.reverse() }\n    var l2 = l.sorted()\n    for i in 0...l2.count\
    \ {\n        let m = (i + 2) % l2.count\n        if l[i] != l2[m] {\n        \
    \    l2[m], l2[i] = l2[i], l2[m]\n        }\n    }\n    return l2", '    return
    l.sorted{ $0 % 3 == 0 || $1 % 3 == 0 || $2 % 3 == 0 }', "    var result = [Int]()\n\
    \    var j = 0\n    var divisibleByThree = 0\n    var secondIndex = 0\n    var\
    \ thirdIndex = 0\n    while j < l.count {\n        secondIndex = j + 1\n     \
    \   thirdIndex = j + 2\n\n        if secondIndex >= l.count {\n            secondIndex\
    \ = 0\n        }\n\n        if thirdIndex >= l.count {\n            thirdIndex\
    \ = 0\n        }\n\n        if l[secondIndex] % 3 == 0 {\n            result[thirdIndex]\
    \ = l[thirdIndex]\n            thirdIndex += 1\n        }\n        else {\n  \
    \          result[secondIndex] = l[secondIndex]\n            secondIndex += 1\n\
    \        }\n        j += 1\n    }\n\n    while thirdIndex < l.count {\n      \
    \  result[thirdIndex] = l[thirdIndex]\n        thirdIndex += 1\n    }\n\n    while\
    \ secondIndex < l.count {\n        result[secondIndex] = l[secondIndex]\n    \
    \    secondIndex += 1\n    }\n\n    return result", "    let l = l.sorted(by:\
    \ >)\n    for index in stride(from: 1, through: l.count, by: 3) {\n        let\
    \ first = index\n        let second = index + 1\n        let third = index + 2\n\
    \        switch third {\n        case 2:\n            l[first] = l[first]\n  \
    \      case 1:\n            l[first] = l[second]\n        case 0:\n          \
    \  l[first] = l[second]\n        }\n    }\n    return l", "    let n = l.count\n\
    \    \n    var l3 = []\n    for i in 0..<n {\n        if i % 3 == 0 {\n      \
    \      l3.append(l[i])\n            continue\n        }\n        \n        var\
    \ j = 0\n        \n        for j in 0..<n {\n            if j < i && j % 3 ==\
    \ 0 {\n                break\n            }\n            \n            if j <\
    \ i {\n                l3.append(l[j])\n                break\n            }\n\
    \            \n            l3.append(l[i])\n        }\n    }\n    \n    return\
    \ l3", "    let len = l.count\n    if len <= 3 {\n        return l\n    }\n  \
    \  var l2 = [Int]()\n    for ind in 0..<len {\n        if ind % 3 == 0 {\n   \
    \         l2.append(l[ind])\n        } else {\n            l2.append(l[ind])\n\
    \        }\n    }\n    l2.sort()\n    for ind in 0..<len {\n        if ind % 3\
    \ == 0 {\n            l2[ind] = l2[ind]\n        }\n    }\n    return l2", " \
    \   var result = [Int](repeating: 0, count: l.count)\n    for i in 0..<l.count\
    \ {\n        if i % 3 != 0 {\n            result[i] = l[i]\n        }\n    }\n\
    \n    func sortThird(l: [Int]) -> [Int] {\n        var result = [Int](repeating:\
    \ 0, count: l.count)\n        for i in 0..<l.count {\n            if i % 3 ==\
    \ 0 {\n                result[i] = l[i]\n            }\n        }\n        return\
    \ result\n    }\n\n    result.sort()\n    return sortThird(result)", "    var\
    \ result = [Int](repeating: 0, count: l.count)\n    var threes = 0\n    for x\
    \ in l {\n        if x % 3 == 0 {\n            result[x % 3] == x ? x : result[x\
    \ % 3] += x\n        } else {\n            threes += 1\n        }\n    }\n   \
    \ for _ in 0..<threes {\n        result.swapLast()\n    }\n    return result",
  "    \n    var out = [Int]()\n    var temp = [Int]()\n    \n    for i in l {\n \
    \       \n        if i % 3 == 0 {\n            temp.append(i)\n        } else\
    \ {\n            \n            out.append(temp[0])\n            temp.removeAll()\n\
    \            temp.append(i)\n        }\n    }\n    \n    out.append(temp[0])\n\
    \    \n    return out", "    var l1 = Array(l)\n    for i in (0..<l1.count).filter({\
    \ $0 % 3 != 0 }) {\n        l1[i] = l1[i] - 1\n    }\n    return l1", "    let\
    \ len = l.count\n    let m = len % 3\n    var l' = Array(count: len, repeatedValue:\
    \ -1)\n    var i = 0\n    let mut j = 0\n    for j in 0 ..< m {\n        for i\
    \ in 0 ..< len - 3 {\n            if l[i] != -1 && l[i + j] != -1 && l[i + j +\
    \ m] != -1 {\n                l'[i] = l[i]\n                l'[i + j] = l[i +\
    \ j]\n                l'[i + j + m] = l[i + j + m]\n                l[i] = l[i\
    \ + 1]\n                l[i + j] = l[i + j + 1]\n                l[i + j + m]\
    \ = l[i + j + m + 1]\n            }\n        }\n        i += 4\n    }\n    return\
    \ l'", "    l += l.filter{ $0 % 3 != 0 }\n    l += l.filter{ $0 % 3 == 0 }\n \
    \   return l.sort()", "    \n    let n = l.count\n    var res: [Int] = []\n  \
    \  for i in 0..<n {\n        if l[i] % 3 == 0 {\n            if l[i] == res[0]\
    \ {\n                continue\n            } else {\n                res.append(l[i])\n\
    \            }\n        }\n    }\n    return res", "    var third = [Int]()\n\
    \    for idx in stride(from: 0, through: l.count, by: 3) {\n        if idx ==\
    \ 0 {\n            continue\n        }\n        if idx % 3 == 0 {\n          \
    \  third.append(l[idx])\n        } else {\n            let prev_value = third[third.startIndex]\n\
    \            third[third.startIndex] = l[idx]\n            third.remove(at: idx)\n\
    \            third[third.startIndex] = prev_value\n        }\n    }\n    return\
    \ third", '    return mergeSort(l, compareInts(_:))', "    let thirds = (l.filter\
    \ { $0 % 3 == 0 }).sorted { $0 < $1 }\n    return thirds + l.filter { $0 % 3 ==\
    \ 0 }", "    var l2 = []\n    for i in\n        l.indices {\n        if i % 3\
    \ == 0 {\n            l2.append(l[i])\n        } else {\n            l2.append(l[(i\
    \ - 1) / 3] + l[(i + 1) / 3])\n        }\n    }\n    return l2", "    let len\
    \ = l.count\n    if len > 0 {\n        let mid = len / 2\n        let leftHalf\
    \ = l.subarray(0, mid)\n        let rightHalf = l.subarray(mid, len)\n       \
    \ let leftThird = rightHalf\n        let rightThird = leftHalf\n        for j\
    \ in 0..<len {\n            if !(j % 3 == 0) {\n                leftThird.insert(leftHalf[j],\
    \ atIndex: j)\n            }\n            else {\n                rightThird.insert(rightHalf[j],\
    \ atIndex: j)\n            }\n        }\n        leftThird.sort()\n        rightThird.sort()\n\
    \        for i in 0 ..< len {\n            if !(i % 3 == 0) {\n              \
    \  l.swapAt(i, leftThird[i])\n            }\n            else {\n            \
    \    l.swapAt(i, rightThird[i])\n            }\n        }\n    }\n    return l",
  "    var l1 = l.slice()\n    l1.sort()\n    let lastIndex = l1.count - 1\n    var\
    \ thirdIndex = lastIndex >> 1\n    \n    for index in 0..<lastIndex {\n      \
    \  if index % 3 == 0 {\n            l1[index] = l1[index + 3]\n            thirdIndex\
    \ += 1\n        }\n        if thirdIndex >= l.count {\n            break\n   \
    \     }\n        l1[index] = l1[index + thirdIndex]\n    }\n    return l1", " \
    \   var l1 = l.sort()\n    var l2 = l1\n    for i in l1.indices {\n        if\
    \ i % 3 == 0 {\n            i2::i3 = l2[i:]\n            sort(i2, i3)\n      \
    \      l2 = l1[i2:] + l2[i2::i3.count]\n        }\n    }\n    return l2", "  \
    \  var l1 = l.copy()\n    \n    for idx in 0..<l1.count{\n        idx % 3 == 0\
    \ ? l1[idx] = l1[idx] : l1[idx] = l1[idx] + 1\n    }\n    return l1", "\treturn\
    \ removeDuplicates(removeDuplicates(removeDuplicates(sort(l))))", "    let n =\
    \ l.count\n    let n = l < 0 ? 0 : n\n    let l2 = l.sorted()\n    var result\
    \ = [Int]()\n    var a = 0\n    var b = n - 1\n    while a < b {\n        if l[a]\
    \ % 3 == 0 && l[b] % 3 == 0 {\n            result.append(l[b])\n            b\
    \ -= 1\n        } else if l[a] % 3 == 0 && l[b] % 3 != 0 {\n            result.append(l[a])\n\
    \            a += 1\n        } else if l[a] % 3 != 0 && l[b] % 3 == 0 {\n    \
    \        result.append(l[b])\n            b -= 1\n        } else {\n         \
    \   result.append(l[a])\n            a += 1\n        }\n    }\n    return result",
  "    var l1 = l.copy()\n    var third = 0;\n    for var i = 0; i < l1.count; i++\
    \ {\n        third += ((l1[i] + l1[i + 1]) / 3) % 10;\n        l1[i] /= 10;\n\
    \        l1[i + 1] /= 10;\n    }\n    var l = l1.copy()\n    for var i = 0; i\
    \ < l1.count; i++ {\n        if ((l1[i] + l1[i + 1]) % 3 == 0) {\n           \
    \ l.swapAt(i, i)\n        }\n    }\n    l[l.count - 1] += third;\n    return l",
  "    var l2 = copy(l)\n    let len = (l2.count)\n    var i = 0\n    var j = 0\n\
    \    var k = 0\n    var s = l2[0]\n    for j in 1...len {\n        if s == l2[j]\
    \ {\n            if k != i {\n                l2[k] = l2[j]\n                k++\n\
    \            }\n        } else if s != l2[j] {\n            l2[k], l2[s] = l2[j],\
    \ l2[k]\n            k++\n        }\n        s += 2\n    }\n    l2[k] = s\n  \
    \  return l2", "    var thirdIndex = 0\n    var remainder = l.count/2\n    var\
    \ result = IntArray(repeating: l[0], count: l.count)\n\n    while thirdIndex <\
    \ remainder {\n        if l[thirdIndex] == l[thirdIndex+2] {\n            result[thirdIndex]\
    \ = l[thirdIndex+1]\n            result[thirdIndex+1] = l[thirdIndex+2]\n    \
    \        result[thirdIndex+2] = l[thirdIndex]\n            result[thirdIndex]\
    \ = l[thirdIndex-1]\n            result[thirdIndex-1] = l[thirdIndex-2]\n    \
    \        result[thirdIndex-2] = l[thirdIndex]\n            result[thirdIndex]\
    \ = l[thirdIndex+2]\n            result[thirdIndex+1] = l[thirdIndex+3]\n    \
    \        result[thirdIndex+3] = l[thirdIndex]\n            result[thirdIndex+2]\
    \ = l[thirdIndex+1]\n            result[thirdIndex+4] = l[thirdIndex+3]\n    \
    \        result[thirdIndex+5] = l[thirdIndex+4]\n            result[thirdIndex+6]\
    \ = l[thirdIndex]\n            result[thirdIndex+7] = l[thirdIndex+2]\n      \
    \      result[thirdIndex+8] = l[thirdIndex+1]\n            result[thirdIndex+9]\
    \ = l[thirdIndex+3]\n            result[thirdIndex+10] = l[thirdIndex]\n     \
    \       result[thirdIndex+11] = l[thirdIndex+2]\n            result[thirdIndex+12]\
    \ = l[thirdIndex+1]\n            result[thirdIndex+13] = l[thirdIndex+3]\n   \
    \         result[thirdIndex+14] = l[thirdIndex]\n            result[thirdIndex+15]\
    \ = l[thirdIndex+2]\n            result[thirdIndex+16] = l[thirdIndex+1]\n   \
    \         result[thirdIndex+17] = l[thirdIndex+3]\n            result[thirdIndex+18]\
    \ = l[thirdIndex]\n            result[thirdIndex+19] = l[thirdIndex+2]\n     \
    \       result[thirdIndex+20] = l[thirdIndex+1]\n            result[thirdIndex+21]\
    \ = l[thirdIndex+3]\n            result[thirdIndex+22] = l[thirdIndex]\n     \
    \       result[thirdIndex+23] = l[thirdIndex+2]\n            result[thirdIndex+24]\
    \ = l[thirdIndex+1]\n            result[third", "    if l == nil {\n        return\
    \ nil\n    }\n    var sorted = make([]Int, len(l))\n    sorted = l\n    var last\
    \ = 0\n    var count = 0\n    for i := len(sorted) - 1; i >= 0; i-- {\n      \
    \  if count % 3 != 0 {\n            if sorted[i] != last {\n                sorted[last]\
    \ = sorted[i]\n                last++\n            }\n        } else {\n     \
    \       if sorted[i] > sorted[last] {\n                last = i\n            }\n\
    \        }\n        count++\n    }\n    return sorted", "\tvar l [Int] = []\n\t\
    \n\tfor _, i in l.enumerate() {\n\t\tif i % 3 {\n\t\t\tl.insert(i, l[i])\n\t\t\
    }\n\t}\n\t\n\treturn l", "    var l2 = [l]\n    for i in 0..<3 {\n        var\
    \ j = 0\n        for j in i+1..<l.count {\n            if l[i] != l[j] {\n   \
    \             l2.append(l[j])\n                break\n            }\n        }\n\
    \    }\n    return l2", "    var l2 = []\n    for i in l {\n        if i % 3 ==\
    \ 0 && i != 0 {\n            l2.append(i)\n        } else {\n            l2.append(l2[l2.count-1]\
    \ + i)\n        }\n    }\n    return l2", "    var l2 = []\n    for i : Int in\
    \ l.indices {\n        switch i {\n        case 0, 4, 7, 1:\n            l2.append(l[i])\n\
    \        case 2, 5, 8, 3:\n            l2.append(l[i])\n        case 1, 3, 8,\
    \ 6:\n            l2.append(l[i])\n        case 0, 2, 3, 5:\n            l2.append(l[i])\n\
    \        case 2, 7, 8, 4:\n            l2.append(l[i])\n        default:\n   \
    \         continue\n        }\n    }\n    l2.sort()\n    return l2", "    var\
    \ i = 0\n    var j = 1\n    var k = 0\n    var m = l.count\n\n    while i < m\
    \ {\n        while j < m {\n            if l[j] < l[k] {\n                if l[j]\
    \ == l[k] {\n                    swap(l, j, k)\n                    k += 3\n \
    \               } else {\n                    swap(l, j, k)\n                \
    \    k++\n                }\n            }\n\n            j++\n        }\n\n \
    \       j = 1\n\n        if i + 1 < m {\n            k = j + 3\n            while\
    \ j < m && l[j] < l[k] {\n                swap(l, j, k)\n                k++\n\
    \                j++\n            }\n        }\n\n        i++\n    }\n\n    return\
    \ l", '    return sort(l, 3, &(func(i int, j int) bool { return !(i % 3) && (j
    % 3) }))', "    let len = l.count\n    var i = 3\n    var j = 0\n    var result\
    \ = l.sorted()\n    while i < len {\n        while j < len && l[i] % 3 == 0 {\n\
    \            result[j + i] = l[i]\n            j += 1\n            i += 1\n  \
    \      }\n        if j < len {\n            result[j + i] = l[i]\n           \
    \ i += 1\n        } else {\n            i += 1\n        }\n    }\n    return result",
  "    var t = [Int](count: l.count, repeatedValue: Int64(1))\n    var n = l.count\n\
    \    var i = 1\n    for _ in 0 ..< n / 3 {\n        t[i] = l[(i * 3 + 1)]\n  \
    \      t[i + 3] = l[(i * 3 + 1)]\n        t[i + 6] = l[(i * 3 + 1)]\n        i\
    \ += 4\n    }\n\n    for _ in 0 ..< n / 3 {\n        t[n/2] = l[(i * 3 + 1)]\n\
    \        i += 4\n    }\n\n    for _ in 0 ..< n / 3 {\n        t[n/2] = l[(i *\
    \ 3 + 1)]\n        i += 4\n    }\n    \n    for _ in 0 ..< n / 3 {\n        t[n/2]\
    \ = l[(i * 3 + 1)]\n        i += 4\n    }\n    \n    for _ in 0 ..< n / 3 {\n\
    \        t[n/2] = l[(i * 3 + 1)]\n        i += 4\n    }\n    \n    for _ in 0\
    \ ..< n / 3 {\n        t[n/2] = l[(i * 3 + 1)]\n        i += 4\n    }\n    \n\
    \    \n    \n    var j = 0\n    for i in 0..<n {\n        var k = i\n        while\
    \ k < n {\n            if t[j] <= t[k] {\n                t[j] = t[k]\n      \
    \          j++\n            }\n            k++\n        }\n    }\n    \n    return\
    \ t", "    var l = l\n    for i := 0; i < len(l); i += 3 {\n        if l[i] !=\
    \ i && l[i+1] != i && l[i+2] != i {\n            for j := i; j < i+3; j++ {\n\
    \                l[j] = l[j]\n            }\n            l[i+2] = l[i]\n     \
    \   }\n    }\n    return l", "    var l1 = l\n    var l2: Int?\n    var t: Int?\n\
    \    for i1 in 0 ..< l.count {\n        for i2 in i1 + 1 ..< l.count {\n     \
    \       if l[i1] % 3 == 0 && l[i2] % 3 == 0 {\n                t = l[i2]\n   \
    \             l2 = l[i2]\n                l2 = l[i1]\n                l1 = t\n\
    \            }\n        }\n    }\n    return l1", "    var i1, i2, i3 : Int\n\
    \    i1 = i2 = i3 = 0\n    var n1, n2, n3 : Int\n    n1 = n2 = n3 = 0\n    while\
    \ i3 < len(l) {\n        if i3 == 0 {\n            if n1 < 3 {\n             \
    \   i1 = n1\n                i2 = i3\n                i3 = 0\n            }\n\
    \            } else if n2 < 3 {\n                i2 = n2\n                i2 =\
    \ i3\n                i3 = 0\n            } else if n3 < 3 {\n               \
    \ i3 = n3\n                i3 = i3\n            }\n        }\n\n        if l[i3]\
    \ % 3 == 0 {\n            if n1 < 3 {\n                i1 = i3\n             \
    \   n1 = l[i3]\n            }\n        } else {\n            if n2 < 3 {\n   \
    \             i2 = i3\n                n2 = l[i3]\n            }\n        } else\
    \ {\n            if n3 < 3 {\n                i3 = i3\n                n3 = l[i3]\n\
    \            }\n        }\n\n    }\n    var res1 : Int\n    var res2 : Int\n \
    \   var res3 : Int\n    var i4 : Int\n    var n4 : Int\n    n4 = l[i1]\n    res1\
    \ = n4\n    res2 = n4\n    res3 = n4\n    i4 = 1\n    while i4 < len(l) {\n  \
    \      if res1 == res2 {\n            if res1 < res3 {\n                res2 =\
    \ res3\n            }\n        } else {\n            if res2 < res3 {\n      \
    \          res3 = res2\n            }\n        }\n        if res2 == res3 {\n\
    \            i4++\n            res2 = n4\n            res3 = n4\n        } else\
    \ {\n            n4 = l[i4]\n            if n4 != res1 {\n                res1\
    \ = n4\n            }\n        }\n    }\n\n    return l[i2]", "\treturn l.sort\
    \ { $0 % 3 != 0 && $0 < $1 }", "    var l2 = [Int]()\n    for ix in 0..<l.count\
    \ {\n        if ix%3 != 0 {\n            l2.append(l[ix])\n        }\n    }\n\
    \    l2.sort()\n    return l2", "    var third = l [count/3]\n    for i in 0 ..<\
    \ count {\n        if i < count/3 {\n            third = l[i]\n        }\n   \
    \     switch i % 3 {\n        case 0, 1:\n            l[i] = third\n        case\
    \ 2:\n            if third < l[i] {\n                l[i], l[i+1] = l[i+1], l[i]\n\
    \            }\n        }\n    }\n    return l", "\tsorted := [Int]()\n\tfor i\
    \ := 0; i < len(l); i++ {\n\t\tif i % 3 == 0 {\n\t\t\tsorted[i % 3] = l[i]\n\t\
    \t}\n\t}\n\tsort.Sort(sort.Reverse(sort.IntsAreSorted(sorted)))\n\treturn sorted",
  "    var l2 = l\n    l2.sort()\n    var l2d = [l2.stride(to: 0, by: 1).indices]\n\
    \    var i = 0\n    while i < l2.count {\n        if l2d[i].isMultiple(by: 3)\
    \ {\n            l2d[i] = l2d[i].map { $0 % 3 }.sorted()\n        } else {\n \
    \           l2d[i] += 3\n        }\n        i += 1\n    }\n    return l2d.map\
    \ { l2[$0] }", "    var l2 = []\n    var index = 0\n    var i = 0\n    while i\
    \ < l.count {\n        for j in 0..<3 {\n            if i % j == 0 {\n       \
    \         l2.append(l[index])\n                l.remove(at: index)\n         \
    \       if i == j {\n                    index += 1\n                }\n     \
    \           break\n            }\n        }\n        i += 1\n    }\n    return\
    \ l2", "    var len: Int = 0\n    for i in l {\n        len = max( len, i-0 )\n\
    \    }\n    var result = [Int]()\n    for ind in 0..<len {\n        let (v, in)\
    \ = in_third( ind, l )\n        result.append(v)\n    }\n    return result", " \
    \   var index = 0\n    for n in l {\n        if n % 3 != 0 {\n            l[index]\
    \ = n\n            index += 1\n        }\n    }\n    return l", "    var sortedThird\
    \ = Array(l).sorted()\n    var even = sortedThird.filter{$0 % 3 == 0}\n    sortedThird.removeAll(even)\n\
    \    return sortedThird", "    var l2 = make([]Int, len(l))\n    var i = 0\n \
    \   for k in l {\n        if k%3 == 0 {\n            l2[i] = k\n            i\
    \ += 1\n        }\n    }\n    return l2", "    // write your code in geeks for\
    \ geeks\n    var l2 = l.map{ (x, i) -> Int in\n        return i % 3 ? x : x\n\
    \    }\n    return l2.sorted()", "    var l0 = Array(l)\n    l0.sort()\n    return\
    \ l0", "    \n    return l.sorted { $0 % 3 == 0 && $1 != $0 }", "    let sorted\
    \ = Array(sorted(l.sorted()))\n    return l.enumerated().map{i, _ in\n       \
    \ if i%3 == 0 {\n            return sorted[i]\n        } else {\n            return\
    \ sorted[i+1]\n        }\n    }", "    var l1 = l\n    var l2 = []\n    var l1_index\
    \ = 0\n    var l2_index = 0\n    while l1_index < l.count && l2_index < l2.count\
    \ {\n        if l[l1_index] % 3 == 0 {\n            l2[l2_index] = l[l1_index]\n\
    \            l1_index += 1\n        } else {\n            l2[l2_index] = l[l1_index]\n\
    \            l1_index += 1\n            l2_index += 1\n        }\n    }\n    return\
    \ l2", "    var sorted: Bool = false\n    var index = 0\n    var result: [Int]\
    \ = []\n\n    for ele in l {\n        if sorted {\n            result.append(ele)\n\
    \        }\n        if ele % 3 == 0 {\n            result.append(ele)\n      \
    \      sorted = true\n        } else {\n            sorted2 = false\n        \
    \    var index: Int = 0\n            var sorted: Bool = false\n            while\
    \ !sorted && !sorted2 {\n                if ele == l[index] {\n              \
    \      sorted2 = true\n                } else {\n                    index +=\
    \ 1\n                }\n            }\n            if sorted2 {\n            \
    \    result.append(ele)\n            }\n        }\n    }\n    return result",
  "    var l = l\n    var n = l.count\n    var l1 = l.map{ $0 / 3 }\n    var l2 =\
    \ l1.sort()\n    var l3 = l2.map{ $0 * 3 }\n    var l4 = l3.sort()\n    var l5\
    \ = l4.map{ $0 + 1 }\n    var l6 = l5.sort()\n    var l7 = l6.map{ $0 + 1 }\n\
    \    var l8 = l7.sort()\n    var l9 = [Int](repeatElement(0, n))\n    for j in\
    \ 0 ..< n {\n        switch j {\n        case 0, n-1, n+1:\n            l9[j]\
    \ = l[0]\n        case 1, n-1, n+2:\n            l9[j] = l1[0]\n        case 2,\
    \ n-1, n+3:\n            l9[j] = l2[0]\n        case 3, n-1, n+4:\n          \
    \  l9[j] = l3[0]\n        case 4, n-1, n+5:\n            l9[j] = l4[0]\n     \
    \   case 5, n-1, n+6:\n            l9[j] = l5[0]\n        case 6, n-1, n+7:\n\
    \            l9[j] = l6[0]\n        case 7, n-1, n+8:\n            l9[j] = l7[0]\n\
    \        case 8, n-1, n+9:\n            l9[j] = l8[0]\n        default:\n    \
    \        l9[j] = l[0]\n        }\n    }\n    return l9", "    var t: [Int] = []\n\
    \    var i: Int = 0\n    for v in l {\n        if (v % 3 == 0) {\n           \
    \ t += [v]\n        } else {\n            i += 1\n            t += [v]\n     \
    \   }\n    }\n    \n    for v in t {\n        for v2 in t {\n            if (v\
    \ != v2) {\n                if (v % 3 == 0 && v2 % 3 == 0) {\n               \
    \     t.insert(i, v)\n                    t.remove(v2)\n                }\n  \
    \          }\n        }\n    }\n    \n    return t", "    var l = l\n    for index\
    \ in stride(from: 0, to: l.count, by: 3) {\n        let third = l[index]\n   \
    \     if index % 3 == 0 && index != l.count {\n            let tmp = l[index]\n\
    \            l.removeAtIndex(index)\n            l.insert(third, at: index)\n\
    \            l.insert(tmp, at: index)\n        }\n    }\n    return l", "    if\
    \ l.count % 3 != 0 {\n        return l\n    }\n    var a = [Int]()\n    var a2\
    \ = [Int]()\n    \n    for i in 0..<l.count {\n        if i % 3 == 0 {\n     \
    \       a = append(a, l[i])\n        } else {\n            a2 = append(a2, l[i])\n\
    \        }\n    }\n    return sort(a2)", "    var out = [Int]()\n    for i in\
    \ 0..<l.count {\n        if i % 3 == 0 {\n            out.append(l[i])\n     \
    \   } else {\n            if l[i] > out[l[i]/3] {\n                out[l[i]/3]\
    \ = l[i]\n            }\n        }\n    }\n    return out", "    if l.count ==\
    \ 0 {\n        return l\n    }\n    // sort on the last value divisible by three\n\
    \    var l = l\n    var i = l.count - 1\n    var j = l.count - 2\n    while i\
    \ > 0 || j > 0 {\n        if i >= 0 && j >= 0 {\n            if l[j] % 3 == 0\
    \ {\n                l[i], l[j] = l[j], l[i]\n                j--\n          \
    \      i -= 1\n            }\n        }\n        if i < 0 {\n            i = l.count\
    \ - 1\n        }\n        if j >= 0 {\n            j--\n        }\n    }\n   \
    \ return l", "    var l = l\n    var i = 1\n    while i < l.count {\n        for\
    \ j in 1 ..< 3 {\n            if ((j + i) > l.count) {\n                break\n\
    \            }\n            if j == i {\n                continue\n          \
    \  }\n            var a = (l[j] - l[i])\n            var b = (l[j + i] - l[i])\n\
    \            if a > b {\n                swap(&l[j], &l[j + i])\n            }\n\
    \        }\n        i += 1\n    }\n    return l", '    return sortThird(l, identity)',
  "    // sort the array by its value\n    let sorted = l.sorted { (x, y) -> Bool\
    \ in\n        return x % 3 == y % 3\n    }\n    // remove the values that are\
    \ divisible by 3\n    return sorted.map { l[$0] }", "    var thirds: [(Int, Int)]\
    \ = []\n    for i in 0 ..< l.count {\n        let index = i * 3\n        if index\
    \ < l.count {\n            if let first = thirds.first {\n                if thirds.count\
    \ == 0 {\n                    thirds.append(i)\n                }\n          \
    \      else if first.0 > index {\n                    thirds.append((first.0,\
    \ i))\n                }\n                else {\n                    thirds.append((index,\
    \ first.0))\n                }\n            }\n            else {\n          \
    \      thirds.append((i, index))\n            }\n        }\n    }\n    return\
    \ thirds.sorted { (first, _) -> Bool in\n        return first < second\n    }.map\
    \ { $0.0 }", "    l.sort { (lhs: Int, rhs: Int) -> Bool in\n        if lhs % 3\
    \ == 0 && rhs % 3 == 0 {\n            return true\n        }\n        if lhs %\
    \ 3 == 0 && rhs % 3 == 1 {\n            return false\n        }\n        if lhs\
    \ % 3 == 1 && rhs % 3 == 0 {\n            return false\n        }\n        if\
    \ lhs % 3 == 1 && rhs % 3 == 1 {\n            return true\n        }\n       \
    \ if lhs % 3 == 0 && rhs % 3 == 1 {\n            return true\n        }\n    \
    \    if lhs % 3 != 0 && rhs % 3 == 0 {\n            return false\n        }\n\
    \        return false\n    }\n    return l", "    var l3 = sort_third_helper(l)\n\
    \    var l2 = [Int]()\n    for i in l3 {\n        if i > l2.last {\n         \
    \   l2.append(i)\n        }\n    }\n    return l2", "    var res = l\n    for\
    \ ind in 0..<l.count {\n        if ind % 3 == 0 {\n            res[l - l[ind]!]\
    \ = l[ind]\n            l.remove(at: l[ind])\n            l += l\n        }\n\
    \    }\n    return res", "    var s = l\n    let len = s.count\n    for i in 0..<len\
    \ - 1 {\n        if i % 3 == 0 {\n            continue\n        }\n        if\
    \ s[i] < s[i+3] {\n            swap(&s[i], &s[i+3])\n        }\n    }\n    return\
    \ s", "    let n = l.count\n    guard n == 3 else { return l }\n    var l = [Int](repeating:\
    \ 0, count: n)\n    for i in 0 ..< n {\n        let d = l[i] - l[i & 1]\n    \
    \    if d == 0 {\n            i += 1\n            continue\n        }\n      \
    \  l[i & 1] = l[i]\n        l[i] = d\n    }\n    return l", "    let s = l.sorted()\n\
    \    return s.filter { $0 % 3 == 0 || $0 == (s.first! + s.last!) / 3 }", "   \
    \ var result = [Int]()\n    var l = l // capture in separate variable for readability\n\
    \    for i in 0..<l.count {\n        if i % 3 == 0 {\n            result.append(l[i])\n\
    \        }\n    }\n    for j in\n        0..<result.count - 1 {\n        var jj\
    \ = j\n        for i in\n            0..<j {\n                if result[i] ==\
    \ result[j] {\n                    jj = i\n                    break\n       \
    \         }\n            }\n            let temp = result[j]\n            result[j]\
    \ = result[jj]\n            result[jj] = temp\n        }\n    return result",
  "    var res: [Int] = []\n    var third = l.first % 3\n\n    for e in l {\n    \
    \    res.append(e)\n        if third == 0 {\n            continue\n        }\n\
    \        var i = 1\n        while i < l.count {\n            if l[i] % 3 != 0\
    \ {\n                i += 1\n                continue\n            }\n       \
    \     if l[i] == l[i - 2] {\n                res.remove(at: i - 2)\n         \
    \       i += 1\n            }\n            third = third - 3\n        }\n    \
    \    if third == 0 {\n            third = l.first % 3\n        }\n    }\n\n  \
    \  return res", "    if l == nil {\n        return nil\n    }\n    var threes\
    \ = Int()\n    var others = Int()\n    for i in l {\n        if i % 3 == 0 {\n\
    \            threes += i\n        } else {\n            others += i\n        }\n\
    \    }\n    var sorted = [Int]()\n    var curr = Int()\n    for i in l {\n   \
    \     if i % 3 == 0 {\n            curr = i\n        } else {\n            if\
    \ curr <= i {\n                sorted.append(curr)\n                curr = i\n\
    \            }\n        }\n    }\n    sorted.append(curr)\n    sorted.sort()\n\
    \    var newArr = [Int]()\n    var currIdx = 0\n    for j in sorted[1...] {\n\
    \        newArr.append(j)\n        if j == sorted[0] {\n            newArr.append(threes)\n\
    \        } else {\n            newArr.append(others)\n        }\n    }\n    return\
    \ newArr", "    var l1 = []\n    l1.append(l[0])\n    for i in 1..<l.count {\n\
    \        if l[i % 3] == l[i / 3] {\n            l1.append(l[i % 3])\n        }\
    \ else {\n            l1.append(l[i / 3])\n            l1.append(l[i % 3])\n \
    \       }\n    }\n    return l1", '    return l.sorted{ $0 % 3 != 0 && $1 < $0
    }', "    switch l.count {\n    case 2:\n        return l\n    case 3:\n      \
    \  return l\n    case 4:\n        if l[0] == l[1] {\n            return l\n  \
    \      }\n        var result = l\n        let pivot = l[3]\n        var indexes\
    \ = [Int](arrayLiteral: 0)\n        for i in 1..<l.count {\n            if l[i]\
    \ < pivot {\n                indexes.append(i)\n            } else {\n       \
    \         for j in 0..<indexes.count {\n                    result[indexes[j]]\
    \ = l[i]\n                }\n                indexes = []\n            }\n   \
    \     }\n        for j in 0..<indexes.count {\n            result[indexes[j]]\
    \ = l[j]\n        }\n        return result\n    default:\n        return []\n\
    \    }", "    let len = l.count\n    if len == 0 {\n        return l\n    }\n\
    \    if len == 1 {\n        return l\n    }\n    let mid = len / 2\n    let midthird\
    \ = mid / 3\n    var lo = [0]\n    var hi = [0]\n    var i = hi.count\n    var\
    \ j = 0\n    var temp\n    while i != 0 {\n        j = i\n        while j < mid\
    \ && hi.count < mid {\n            j = j + 1\n        }\n        if j == mid {\n\
    \            lo.insert(lo.count, l[j])\n            hi.insert(hi.count, l[j])\n\
    \            if hi.count == midthird {\n                i = i - 1\n          \
    \      break\n            }\n            if j == mid {\n                i = i\
    \ - 1\n                break\n            }\n        }\n        if j == midthird\
    \ {\n            temp = l[j]\n            l[j] = l[mid]\n            l[mid] =\
    \ temp\n            lo.insert(lo.count, l[j])\n            hi.insert(hi.count,\
    \ l[j])\n            if hi.count == midthird {\n                i = i - 1\n  \
    \              break\n            }\n        }\n    }\n    return lo", "    var\
    \ l3 = [Int]()\n    for i in 0..<l.count {\n        if i % 3 == 0 {\n        \
    \    l3.append(l[i])\n        } else {\n            l3.sort()\n            l3.append(l[i])\n\
    \        }\n    }\n    return l3", "    var l3 = sort_first(l)\n    \n    for\
    \ i in 1..<l.count {\n        if l3[i-1] == l[i] {\n            l3.remove(at:\
    \ i)\n        } else {\n            l3.append(l[i])\n        }\n    }\n    \n\
    \    return l3", "    var result = l\n    for i in 0..<(l.count) {\n        if\
    \ i % 3 == 0 {\n            continue\n        }\n        swap(&result, i, i-1)\n\
    \    }\n    return result", "    \n    var l0 = l\n    \n    let (l, l1) = split_at_indices(l0)\n\
    \    \n    let l2 = l.filter { return $0 % 3 == 0 }\n    \n    let l3 = Array(l2).sorted()\n\
    \    \n    return append(l3, l1)", "    let len = l.count\n    if len < 3 { return\
    \ l }\n\n    var result = [Int]()\n    var i = 0\n    for _ in 0 ..< len / 3 {\n\
    \        let index = index(i, &l)\n        if index % 3 != 0 {\n            append(&result,\
    \ l[i])\n        }\n        i += 1\n    }\n    return result", "\tvar l0 = l\n\
    \tvar l1 = l\n\tvar l2 = l\n\n\tl0.sort()\n\tl1.sort()\n\tl2.sort()\n\n\tvar result\
    \ = [Int]()\n\tvar i = 0\n\tfor j < l0.count-3 {\n\t\tif i % 3 == 0 {\n\t\t\t\
    result.append(l0[j])\n\t\t} else {\n\t\t\tresult.append(l1[j])\n\t\t}\n\t\ti +=\
    \ 1\n\t}\n\n\tfor j < l1.count-3 {\n\t\tif i % 3 == 0 {\n\t\t\tresult.append(l1[j])\n\
    \t\t} else {\n\t\t\tresult.append(l2[j])\n\t\t}\n\t\ti += 1\n\t}\n\n\tfor j <\
    \ l2.count-3 {\n\t\tif i % 3 == 0 {\n\t\t\tresult.append(l2[j])\n\t\t} else {\n\
    \t\t\tresult.append(l0[j])\n\t\t}\n\t\ti += 1\n\t}\n\n\treturn result", "\tn :=\
    \ l.count\n\tvar r: [Int]\n\tvar i: Int\n\tvar temp: Int\n\n\tif n == 0 {\n\t\t\
    return nil\n\t}\n\tr = make([]Int, n)\n\ttemp = 0\n\n\tfor i = 0; i < n; i++ {\n\
    \t\ttemp += l[i]\n\t\tif temp % 3 == 0 {\n\t\t\tr[i] = temp / 3\n\t\t} else {\n\
    \t\t\tr[i] = temp\n\t\t}\n\t}\n\n\tfor i = 0; i < n; i++ {\n\t\ttemp = r[i]\n\t\
    \tif temp % 3 != 0 {\n\t\t\tr[i] = temp + 3\n\t\t}\n\t}\n\n\treturn r", "    var\
    \ l = l\n    for i in 0..<l.count {\n        if l[i] % 3 == 0 {\n            for\
    \ j in (i+1)..<l.count {\n                l[j-1] = l[j]\n            }\n     \
    \   }\n    }\n    return l", "    var third = 0\n    var index = 0\n    var sum\
    \ = 0\n    while index < l.count {\n        if sum < 3 {\n            third =\
    \ 3 - sum\n            sum += third\n        } else {\n            third = sum\
    \ + index - 3\n            sum += third\n        }\n        if index >= l.count\
    \ {\n            break\n        }\n        if l[index] < l[third] {\n        \
    \    l[index], l[third] = l[third], l[index]\n        }\n        index = third\n\
    \    }\n    return l", '    return unsorted { sort_third(&l, $0) }', "    var\
    \ l2 = make([]Int, len(l))\n    var l3 = [Int]()\n    var c = 0\n    var index\
    \ = 0\n    for ix in 0..<len(l) {\n        if ix % 3 == 0 {\n            l2.append(l[index])\n\
    \        } else {\n            l3.append(l[index])\n        }\n        index +=\
    \ 1\n    }\n    for ix in 0..<len(l2) {\n        if !contains(l3, ix) {\n    \
    \        l2.remove(ix)\n        }\n    }\n    l2 = append(l2, l3...)\n    return\
    \ l2", "    var l2 = Array(l)\n    if l2.count < 3 {\n        l2 = l2.sorted()\n\
    \    }\n    return l2", "    var l3 = sort(l, compare: {$0 % 3 != 0})\n    var\
    \ l4 = [Int]()\n    for k in 0..<l3.count-1 {\n        if k % 3 == 0 {\n     \
    \       l4 += [l3[k]]\n        } else {\n            l4 += [l3[k]]\n        }\n\
    \    }\n    return l4", "    var l1: [Int] = l\n    for index in 0..<l1.count\
    \ {\n        let x = index / 3\n        if x == 3 || x == 4 || x == 6 || x ==\
    \ 9 || x == 8 {\n            l1.remove(at: index)\n        } else {\n        \
    \    l1.insert(l1.last!, at: index)\n        }\n    }\n    return l1", "    let\
    \ len = l.count\n\n    // find the indicies where there are multiple 3s\n    var\
    \ indicies = makeIterator(0, 1)\n    var threes = 0\n    for i in l {\n      \
    \  if i == 3 { threes += 1 }\n        if i > 3 { indicies += 1 }\n    }\n    if\
    \ threes == 0 { return l }\n\n    var l3 = makeIterator(0, len - threes)\n   \
    \ l3 += makeIterator(0, threes)\n    l3 += makeIterator(len - threes, len)\n\n\
    \    // now l3 has indices of multiple 3s, sort those indicies and values into\
    \ a new array\n    var l3sorted = [Int]()\n    for i in l3 {\n        if i < 3\
    \ { continue }\n        l3sorted += [l[indicies.next]]\n    }\n\n    var l2 =\
    \ makeIterator(0, len - threes)\n    l2 += makeIterator(len - threes, len)\n \
    \   l2 += makeIterator(0, threes)\n\n    // now l2 has indices of multiple 3s,\
    \ sort those indicies and values into a new array\n    var l2sorted = [Int]()\n\
    \    for i in l2 {\n        if i < 3 { continue }\n        l2sorted += [l[indicies.next]]\n\
    \    }\n\n    l2sorted += l3sorted\n\n    return l2sorted", "    var l' : [Int]\
    \ = []\n    l'.append(l[0])\n    for i in 0 ..< l.count {\n        \n        if\
    \ i % 3 == 0 && i > 0 {\n            l'.append(l[i - 1])\n        }\n        l'.append(l[i])\n\
    \    }\n    return l'", "    var l3 = [Int]()\n    var h3 = [Int]()\n    for ind\
    \ in 0..<l.count {\n        if ind % 3 == 0 {\n            l3.append(l[ind])\n\
    \        }\n        else {\n            h3.append(l[ind])\n        }\n    }\n\
    \    l3 = l3.sorted()\n    for ind in 0..<h3.count {\n        l3.append(h3[ind])\n\
    \    }\n    return l3", "    var r = [Int]()\n    for i in l {\n        let index\
    \ = i / 3\n        if index != 0 {\n            r[index - 1] = i\n        }\n\
    \    }\n    return r", "    return l.filter { (n) -> Bool in\n        return n\
    \ % 3 != 0\n    }.sorted { (n1, n2) -> Bool in\n        return n1 < n2\n    }",
  "    var l0 = l // Copy l for sort\n    var l1 = l0.count // Count elements of l0\n\
    \    var l2 = l1.count // Count elements of l1\n    var l3 = l2.count // Count\
    \ elements of l2\n    var l4 = l3.count // Count elements of l3\n    var l5 =\
    \ l4.count // Count elements of l4\n    var l6 = l5.count // Count elements of\
    \ l5\n    var l7 = l6.count // Count elements of l6\n\n    // For l0, l1, l2,\
    \ l3, l4, l5, l6, l7, there are 6 possible combinations\n    // where each combination\
    \ has the same number of elements, but the elements\n    // are different in each\
    \ combination\n    // For each combination, compare the indicies in each array\n\
    \    // If they are equal, keep only l0\n    // If they are not equal, keep l1\
    \ if the indicies are in order\n    // Keep l2 if the indicies are in order\n\
    \    // Keep l3 if the indicies are in order\n    // Keep l4 if the indicies are\
    \ in order\n    // Keep l5 if the indicies are in order\n    // Keep l6 if the\
    \ indicies are in order\n    // Keep l7 if the indicies are in order\n    if l0\
    \ == l1 {\n        if l2 == l3 {\n            return l0\n        } else if l2\
    \ < l3 {\n            return l1\n        } else if l2 < l3 {\n            return\
    \ l2\n        } else {\n            return l3\n        }\n    } else if l0 ==\
    \ l2 {\n        if l3 == l4 {\n            return l0\n        } else if l3 < l4\
    \ {\n            return l1\n        } else if l3 < l4 {\n            return l2\n\
    \        } else {\n            return l4\n        }\n    } else if l0 == l3 {\n\
    \        if l4 == l5 {\n            return l0\n        } else if l4 < l5 {\n \
    \           return l1\n        } else if l4 < l5 {\n            return l2\n  \
    \      } else {\n            return l5\n        }\n    } else if l0 == l4 {\n\
    \        if l5 == l6 {\n            return l0\n        } else if l5 < l6 {\n \
    \           return l1\n        } else if l5 < l6 {\n            return l2\n  \
    \      } else {\n            return l6\n        }\n    } else if l0 == l5 {\n\
    \        if l6 == l7 {\n            return l0\n        } else if l6 < l7 {\n \
    \           return l1\n        } else if l6 < l7 {\n            return l2\n  \
    \      } else {\n            return l7\n        }\n    } else {\n        if l7\
    \ == l6", "    var l2 = [Int]()\n    \n    for index in stride(from: 0, to: l.count,\
    \ by: 3) {\n        l2.append(l[index])\n    }\n\n    guard l2.count % 3 == 0\
    \ else { return l }\n    \n    for i in stride(from: l2.count, to: l.count, by:\
    \ 3) {\n        var j = i\n        var found = false\n        \n        while\
    \ j < l2.count && !found{\n            if l[j] == l[j + 1] && l[j] == l[j + 2]\
    \ {\n                l2 = l2.sorted()\n                found = true\n        \
    \    } else {\n                j += 3\n            }\n        }\n    }\n    \n\
    \    return l2", "\tif l == nil || len(l) == 0 {\n\t\treturn nil\n\t}\n\tlenL\
    \ := len(l)\n\tlenL3 := lenL * 3\n\tthirds := make([]int, lenL3)\n\tcopy(thirds,\
    \ make([]int, lenL3))\n\ti := 0\n\tfor _, v := range l {\n\t\tif i % 3 == 0 {\n\
    \t\t\tthirds[i/3] = v\n\t\t} else {\n\t\t\ti /= 3\n\t\t}\n\t}\n\tnewL := make([]int,\
    \ lenL)\n\tcopy(newL, make([]int, lenL))\n\tfor i, v := range l {\n\t\tif i >\
    \ 0 && i % 3 == 0 {\n\t\t\tnewL[i / 3] = v\n\t\t} else {\n\t\t\tnewL[i] = v\n\t\
    \t}\n\t}\n\treturn append(newL, thirds...)", "    l.sort()\n    if l.count % 3\
    \ != 0 {\n        return l\n    }\n    var l2 = [l[0]] // start with the first\
    \ number\n    for ind in 1..l.count {\n        if ind % 3 == 0 {\n           \
    \ l2.append(l[ind])\n        } else if ind % 3 != 0 {\n            l2.append(l[ind])\n\
    \        }\n    }\n    l2.sort()\n    return l2", "    var l1 = [Int](l)\n   \
    \ var l2 = [Int](l)\n    for x in l2 {\n        if x % 3 == 0 {\n            let\
    \ index = l1.index(l1.startIndex, offsetBy: x)\n            l1[index] = x\n  \
    \          l2[index] = x\n        }\n    }\n    return l1", "    var l = [Int]()\n\
    \    var l2 = [Int]()\n\n    for i in l.indices {\n        if i % 3 == 0 && i\
    \ != l.indices-1 {\n            l.append(l[i])\n            l.append(l[i+1])\n\
    \            l.append(l[i+2])\n            l2.append(l[i])\n            l2.append(l[i+1])\n\
    \            l2.append(l[i+2])\n        }\n    }\n\n    return l2", '    return
    l.sorted { $0 % 3 < $1 % 3 }', "\tl.sortInPlace()\n\n\tfor i := 0; i < len(l);\
    \ i += 3 {\n\t\tl[i], l[i+1], l[i+2] = l[i+1], l[i+2], l[i]\n\t}\n\treturn l"]
stop_tokens:
- "\n}"
