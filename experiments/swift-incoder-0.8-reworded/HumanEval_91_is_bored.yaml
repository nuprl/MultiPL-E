name: HumanEval_91_is_bored
language: swift
prompt: "\n/// You'll be given a string of words, and your task is to count the number\n\
  /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences\
  \ are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(S: \"Hello\
  \ world\")\n/// 0\n/// >>> is_bored(S: \"The sky is blue. The sun is shining. I\
  \ love this weather\")\n/// 1\nfunc is_bored(S: String) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_bored(S: \"Hello world\") == 0)\nassert(is_bored(S:\
  \ \"Is the sky blue?\") == 0)\nassert(is_bored(S: \"I love It !\") == 1)\nassert(is_bored(S:\
  \ \"bIt\") == 0)\nassert(is_bored(S: \"I feel good today. I will be productive.\
  \ will kill It\") == 2)\nassert(is_bored(S: \"You and I are going for a walk\")\
  \ == 0)"
completions: ["    // Your code here\n    let regex = try! NSRegularExpression(pattern:\
    \ \"I.*\")\n    return regex.numberOfMatchesInString(S, options: .RegularExpressionSearch,\
    \ range: NSMakeRange(0, S.utf16.count)) > 0 ? 1 : 0", "    // TODO: Task 2\n \
    \   // Write your code here\n    return 0", "    // Your code here\n    \n   \
    \ \n    return 1", "    var count = 0\n    for word in S.split(separator: \".,?!\"\
    ) { // split string at \".,?!\" and iterate over to get the words in the string\n\
    \        guard let isBored = is_bored(word: word) else {\n            continue\n\
    \        }\n        count += isBored\n    }\n    return count", "    var boredom_count\
    \ = 0\n    for word in S.split(separator: \".\") {\n        if word.startsWith(\"\
    I\") {\n            boredom_count = 1 + boredom_count\n        }\n    }\n    return\
    \ boredom_count", "    S += \" \"\n    var count = 0\n    for s in S.split(separator:\
    \ \".\") {\n        if s.contains(\"I\") {\n            count += s.count { s ==\
    \ \"I\" }\n        }\n    }\n    return count", "    var boredom_count = 0\n \
    \   for s in S.split(separator: \".? !\") {\n        if s.hasPrefix(\"I\") {\n\
    \            boredom_count += 1\n        }\n    }\n    return boredom_count",
  "    let boredoms = [\"I\"]\n    let boredom_count = S.split(separator: \".?,!\"\
    ).filter{ $0.containsString(boredoms)}\n    return boredom_count.count", "   \
    \ let boredoms = S.count(\"I\")\n    return boredoms", "    var bored = 0\n  \
    \  for s in S {\n        switch s {\n        case \"I\":\n        case \"i\":\n\
    \        case \"you\":\n        case \"you're\":\n        case \"you've\":\n \
    \       case \"we\":\n        case \"We\":\n        case \"we're\":\n        case\
    \ \"we've\":\n        case \"you\":\n        case \"you're\":\n        case \"\
    you've\":\n            bored += 1\n        default:\n            break\n     \
    \   }\n    }\n    return bored", "    var bored_words = [String]()\n    var count\
    \ = 0\n\n    for char in S {\n        switch char {\n        case \"?\", \".\"\
    , \"!\":\n            count += 1\n            if char == \".\" {\n           \
    \     bored_words.append(\"\")\n            }\n            if char == \"?\" {\n\
    \                bored_words.append(\"\")\n            }\n            if char\
    \ == \"!\" {\n                bored_words.append(\"\")\n            }\n      \
    \  default:\n            bored_words.append(char)\n        }\n    }\n\n    bored_words.removeFirst()\n\
    \n    if bored_words.count > 0 {\n        return 0\n    }\n    return count",
  "    let words: String = S.split(separator: \".?\")!.map { String($0) }\n    let\
    \ boredom = words.contains(\"I\")\n\n    return boredom ? 0 : words.count", " \
    \   var count = 0\n    for word in S.split() {\n        if word == \"I\" {\n \
    \           count++\n        }\n    }\n    return count", '    return is_bored_string(S,
    "")', "    var boredoms:Int = 0\n    for s in S.split(separator: \".,?!\") {\n\
    \        if s.hasPrefix(\"I\") {\n            boredoms += 1\n        }\n    }\n\
    \    return boredoms", "    var boredoms = 0\n    for s in S.split(\" \") {\n\
    \        if s.hasPrefix(\"I\") {\n            boredoms += 1\n        }\n    }\n\
    \    return boredoms", "    var count = 0\n    for s in S.split(separator: \"\
    .,?! \") {\n        if s.starts(with: \"I\") {\n            count += 1\n     \
    \   }\n    }\n    return count", "    let sentences = S.split('.')\n    let counts\
    \ = sentences.reduce([Int](), combine: { (arr, element) -> [Int] in\n        guard\
    \ let str = element as? String else { return arr }\n        if str == \"I\" {\n\
    \            arr.append(1)\n        } else {\n            arr.removeLast()\n \
    \       }\n        return arr\n    })\n    return counts.reduce(0, combine: {\
    \ (a, b) -> Int in\n        return a + b\n    })", '    return is_bored(S.lowercased())',
  "    var count = 0\n    for word in S.split(separator: \".,?!\") {\n        if word.starts(\"\
    I\") {\n            count += 1\n        }\n    }\n    return count", "    if S.hasPrefix(\"\
    I\") {\n        return Int(S.removePrefix(\"I\").count)\n    }\n    return 0",
  "    // Your code here\n    var a = 0\n    for _ in S.characters {\n        if S.hasPrefix(\"\
    I\") {\n            a += 1\n        }\n    }\n    return a", "    let bored =\
    \ S.contains(\"I\")\n    return bored.count", '    return is_bored2(S, 0)', " \
    \   // BEGIN Practice - Write your code below\n    var boredom = 0\n    for _\
    \ in S.characters.reversed() {\n        if S.characters.first == \"I\" {\n   \
    \         boredom++\n        }\n    }\n    return boredom\n    // END Practice",
  '    return count_bored(S, " . ? ! ") == 0', "\treturn is_boredIn(S, \".?!\")",
  "    var result: Int = 0\n\n    // TODO: Write your code here\n    return 0", " \
    \   if is_bored_rec(S, nil) == true {\n        return 1\n    } else {\n      \
    \  return 0\n    }", "    if is_bored_1(S: S) {\n        return 1\n    } else\
    \ {\n        return 0\n    }", '    return count(S, S("(?i)\b[IYy][\.\?!]\b"))',
  "    \n    var count = 0\n    \n    // Loop through all words\n    for word in S.split(separator:\
    \ \" \") {\n        \n        // Check if current word is bored\n        if word\
    \ == \"I\" {\n            count += 1\n        }\n    }\n    \n    return count",
  "    if is_bored_(S, \"\")\n        { return 0 }\n\n    S += \".\"\n\n    let i\
    \ = count_bored_index(S, \".\")\n    let j = count_bored_index(S, \"?\")\n   \
    \ let k = count_bored_index(S, \"!\")\n\n    return i + (j >= k ? 1 : 0)", "\t\
    let split_S: Array<String> = S.split(\".\").map{String($0)}\n\tlet split_S: Array<String>\
    \ = S.split(\"?\").map{String($0)}\n\tlet split_S: Array<String> = S.split(\"\
    !\").map{String($0)}\n\n\treturn count(split_S, \"I\")", '    return boredomsHelper(S)',
  "    let mut I = 0\n    for s in S.split(separator: \".? !\") {\n        if s.starts(with:\
    \ \"I\") {\n            I += 1\n        }\n    }\n    return I", "    var boredCount\
    \ = 0\n    for character in S {\n        switch character {\n        case \"I\"\
    :\n            boredCount++\n        default:\n            break\n        }\n\
    \    }\n    return boredCount", "    let chars = s.characters()\n    var count\
    \ = 0\n    for char in chars {\n        switch char {\n        case '?':\n   \
    \     case '!':\n        default:\n            if char.startsWith(\"I\") {\n \
    \               count += 1\n            }\n        }\n    }\n    return count",
  '    return is_bored(S: S, N: 0)', "    // TODO: Implement me\n    return 0", " \
    \   return S\n        .unicodeScalars\n        .filter({ $0.isBOremeter })\n \
    \       .count", "    guard let words = S.split(separator: CharacterSet.periodsAndNewlines)\
    \ else {\n        return 0\n    }\n    var boredoms = Int(0)\n    for word in\
    \ words {\n        if word.lowercased().hasPrefix(\"i\") {\n            boredoms\
    \ += 1\n        }\n    }\n    return boredoms", '    return boredom.isPrefixOf(S)
    // counts boredoms, not periods', "    let word = S.split(\" \")[0]\n    let index\
    \ = S.indexOf(word).map {\n        ($0, S.index($0, word))\n    }.filter { $0.1.1\
    \ == true }\n    .map { $0.1.2 }\n    .count\n    return index", "    var i =\
    \ 0\n    let sentences = S.split('.')\n    for sentence in sentences {\n     \
    \   if sentence == \"I\" || sentence == \"i\" {\n            i += 1\n        }\n\
    \    }\n    return i", "    // Your code here\n    var count = 0\n    var lastIsBol\
    \ = false\n    for _ in S.characters.reverse() {\n        if lastIsBol && S ==\
    \ \"I\" {\n            return count\n        }\n        lastIsBol = lastIsBol\
    \ || S == \"I\" || S == \"!\" || S == \"?\"\n        count += 1\n    }\n    return\
    \ count", "  let s = S\n  var bored = 0\n  for word in s.split(\" \") {\n    if\
    \ word == \"I\" {\n      bored += 1\n    }\n  }\n  return bored", "    var count\
    \ = 0\n    for str in S.split(separator: \".\"){\n        if str.hasPrefix(\"\
    I\") {\n            count += 1\n        }\n    }\n    return count", "    var\
    \ bored = 0\n    var bored_S = S\n    for _ in S.characters {\n        if S.starts(with:\
    \ \"I\") {\n            bored = 1\n            break\n        } else {\n     \
    \       bored_S = String(dropLast(bored_S)) + \".\" + String(dropLast(bored_S))\
    \ + \"?\"\n        }\n    }\n    return bored", '    return is_bored_impl(S: S)',
  "    let boredom = \"[I].*[.!?]\"\n    let words: [String] = S.components(separatedBy:\
    \ boredom)\n    return words.count - 1", "    let S = S.lowercased()\n    var\
    \ boredoms = 1\n    for word in S.split(separator: \". . ?\"){\n        if word\
    \ == \"i\" {\n            boredoms += 1\n        }\n    }\n    return boredoms",
  '  return count_bored(S, [".", "?", "!"])', "  guard S.contains(separator: String(\"\
    .\", \",\", \"?\", \"!\")) else {\n    return 0\n  }\n\n  var count = 0\n\n  for\
    \ word in S.components(separatedBy: separator) {\n    if word == \"I\" {\n   \
    \   count += 1\n    }\n  }\n\n  return count", '    return is_bored_helper(S:
    S, boredoms: ["I"])', '  return count_boredom(S).1', "    guard let S = S.split(separator:\
    \ \".?!\").joined(separator: \" \"),\n        let S: String = S\n        else\
    \ { return 0 }\n    let boredom = S.range(of: \"I\", options: .caseInsensitive)\
    \ != nil\n    let count = S.count(\"I\")\n    return boredom ? count : 0", " \
    \ var bored = 0\n  for s in S.split(separator: \".,?!\") {\n    if s.starts(with:\
    \ \"I\") {\n      bored += 1\n    }\n  }\n  return bored", "    let boredoms =\
    \ [\n        \"I\", \"!\", \"?\", \".\", \" \"\n    ]\n    \n    var count = 0\n\
    \    for char in S {\n        count += boredoms.contains(char)\n    }\n    return\
    \ count", "    guard S.contains(\".\") && S.contains(\"?\") && S.contains(\"!\"\
    ) else {\n        return 0\n    }\n    let boredom = S.range(of: \"I\", options:\
    \ .caseInsensitive) != nil\n    return boredom ? 0 : 1", "    var boredom = 1\n\
    \n    // Loop through each character in the string, checking to see if it is a\n\
    \    // boredom.\n    for char in S {\n        switch char {\n        case \"\
    I\":\n            boredom = boredom + 1 // Increase the count by 1 for each boredom.\n\
    \            break\n        case \"?\", \"!\", \".\":\n            boredom = boredom\
    \ + 0 // Increase the count by 0 for each character.\n            break\n    \
    \    default:\n            break\n        }\n    }\n\n    return boredom", " \
    \   var answer = 0\n    for words in S.split(separator: \". ? !\") {\n       \
    \ if words.range(of: \"I\") != nil {\n            answer += 1\n        }\n   \
    \ }\n    return answer", '    return is_bored_impl(S: S, caseSensitive: false)',
  "    if S == \"I\" {\n        return Int(1)\n    }\n    var count = 0\n    var i\
    \ = 0\n    for s in S.split(separator: \".\") {\n        if s == \"I\" {\n   \
    \         count = count + 1\n            i = i + 1\n        }\n    }\n    return\
    \ count", "    let boredoms = [String](\n        S.components(separatedBy: \"\
    .?\")!\n            .filter { $0.hasPrefix(\"I\") }\n            .map { $0.removeFirst()\
    \ }\n    )\n    return boredoms.count", "    var num = 0\n    for s in S.split(separator:\
    \ \".!?\") {\n        if s.contains(\"I\") {\n            num++\n        }\n \
    \   }\n    return num", "    // Your code here\n    var count = 0\n    for s in\
    \ S.split(\".\") {\n        if s[0] == \"I\" {\n            count += 1\n     \
    \   }\n    }\n    return count", "    \n    var boredoms = 0\n    \n    for s\
    \ in S.split(separator: \".\") {\n        if s.range(of: \"I\", options: .caseInsensitive)\
    \ != nil {\n            boredoms += 1\n        }\n    }\n    \n    return boredoms",
  "    if S.isEmpty{ \n        return 0\n    }\n    if S.starts(with: \"I\"){\n  \
    \      return 1\n    }\n    \n    var count = 0\n    \n    for word in S.split(separator:\
    \ \".\") where word == \"I\"{\n        count = count + 1\n    }\n    return count",
  "    guard let _ = S.characters.first else {\n        return 0\n    }\n    let boredom\
    \ = [\"I\".utf8.count, \"a\".utf8.count, \"the\".utf8.count]\n    return boredom.index(boredom.contains(S.characters.first!))\
    \ + 1", '    return boredoms(S)', "    var boredoms = 0\n    var firstIsA = false\n\
    \    var lastIsA = false\n\n    for index in 0..<S.count {\n        switch S[index]\
    \ {\n        case \"I\":\n            if !firstIsA {\n                firstIsA\
    \ = true\n            } else {\n                boredoms += 1\n            }\n\
    \        case \"A\":\n            if !lastIsA {\n                lastIsA = true\n\
    \            } else {\n                boredoms += 1\n            }\n        case\
    \ \"!\", \"?\", \".\":\n            break\n        default:\n            if !firstIsA\
    \ && !lastIsA {\n                boredoms += 1\n            }\n        }\n   \
    \ }\n    return boredoms", "    var i = 0\n    var num_bored = 0\n    var is_bored\
    \ = false\n    for word in S.split(separator: \".?!\") {\n        if word == \"\
    I\" {\n            is_bored = true\n        } else if is_bored {\n           \
    \ i += 1\n            if word != \" \" {\n                num_bored += 1\n   \
    \         }\n        }\n    }\n    return num_bored", "\t", "    let s = S.lowercased()\n\
    \    let l = s.count(\".\") + s.count(\"?\") + s.count(\"!\")\n    if l == 0 {\n\
    \        return 0\n    }\n    return s.startsWith(\"i\") ? 1 : 0", "    let boredom\
    \ = \"I\"\n    let arr = S.components(separatedBy: \".\")\n    var sum = 0\n \
    \   for i in 0..<arr.count{\n        let word = arr[i]\n        if word == boredom\
    \ {\n            sum += 1 // Increment the counter\n        }\n    }\n    return\
    \ sum", "\tguard let s = S.data(using: .utf8) else { return 0 }\n\tlet words:\
    \ [String] = s.enumerated().map { $0.element }.filter({ $0 != \"\\n\" })\n\treturn\
    \ words.filter{$0.range(of: \"^I\", options: .regularExpression) == nil}.count",
  "    if S.hasPrefix(\"I\") && S.hasSuffix(\".\") && S.hasSuffix(\"!\") {\n     \
    \   return 1 + is_bored(S.dropFirst(3))\n    }\n    return 0", "    let S1 = S.split(separator:\
    \ \".\", omittingEmptySubsequences: true)\n    let S2 = S1.map {\n        $0.split(separator:\
    \ \"?\", omittingEmptySubsequences: true)\n    }\n    let S3 = S2.map {\n    \
    \    $0.split(separator: \"!\", omittingEmptySubsequences: true)\n    }\n    let\
    \ S4 = S3.map {\n        $0.first?.lowercased()\n    }\n    return S4.count",
  "    // TODO: fill this in\n    return 0", "    // TODO: For task 2, write code\
    \ to return true if the given sentence is\n    // a boredom.\n    return 0", '    return
    is_bored_helper(S.utf8CString)', "  var result = 0.0\n  for str in S.split(separator:\
    \ \".?!\") {\n    if str.starts(with: \"I\") {\n      result += 1.0\n    }\n \
    \ }\n  return result", '    return is_bored(S: S, R: make([]rune, 0))', "    var\
    \ counter = 0\n    for c in S {\n        switch c {\n        case \"I\":\n   \
    \         counter += 1\n        default:\n            counter -= 1\n        }\n\
    \    }\n    return counter", "    if S.prefix(1).contains(\"I\") {\n        return\
    \ 0\n    }\n    return 1", "\treturn is_bored(S: S, char: \" \")", "    if S.characters.first\
    \ == \"I\" {\n        return 0\n    }\n    var boredom = 1\n    for x in S {\n\
    \        if x == '.' {\n            boredom++\n        } else if x == '?' || x\
    \ == '!' {\n            boredom = 0\n        }\n    }\n    return boredom", " \
    \   if S.contains(\"I\") {\n        var count = 0\n        for s in S.components(separatedBy:\
    \ \"I\") {\n            if s.count >= 2 {\n                count += 1\n      \
    \      }\n        }\n        return count\n    } else {\n        return 0\n  \
    \  }", "    var result = 0\n    var boredom = \"\"\n    var s = S.characters\n\
    \n    for c in S {\n        switch c {\n        case \"A\", \"E\", \"I\", \"O\"\
    , \"U\":\n            boredom = boredom + c\n        default:\n            if\
    \ boredom.characters.count == 0 || boredom[boredom.characters.count-1] != \".\"\
    \ && boredom[boredom.characters.count-1] != \"?\" && boredom[boredom.characters.count-1]\
    \ != \"!\" {\n                if !s.containsString(boredom) {\n              \
    \      result++\n                    boredom = \"\"\n                }\n     \
    \       }\n        }\n    }\n\n    return result", "    let arr = S.components(separatedBy:\
    \ \".\")\n    var count = 0\n    for (_, item) in arr.enumerated() {\n       \
    \ if item.first == \"I\" {\n            count += 1\n        }\n    }\n    return\
    \ count", "    let boredoms = S.contains(\"I\", options: .anchored)\n    return\
    \ boredoms.map { $0 }.filter { ($0 as Bool).count > 0 }.count", '    return is_bored(S:
    S, words: S.words)', '    return is_bored(S: S, words: nil)', "    let words =\
    \ S.split(separator: \" \")\n    \n    let boredoms = words.filter({ $0.hasPrefix(\"\
    I\") }).count\n    \n    return boredoms", "    // Return the length of the sentence\
    \ that is equal to len(S) - 1\n    // minus one.\n    \n    let boredom = S.characters.count\
    \ == S.characters.count - 1\n    return boredom", '    return is_bored(words:
    S.characters)', "    let words: Set<String> = S.componentsSeparatedByString(\"\
    \ \")\n    return words.filter { $0.hasPrefix(\"I\") }.count", '    return is_bored(S:
    S, boredoms: ["I"])', "    let S = S(start:S.startIndex, end:S.endIndex)\n   \
    \ return S.count { S[$0] == \"I\" } > 0", "    let mut count_boredoms = String::new();\n\
    \n    for word in S.split_whitespace() {\n        count_boredoms += \"I\".to_string();\n\
    \        count_boredoms += word.to_string();\n    }\n\n    return count_boredoms.len();",
  "    var i = 0\n    for s in S.split(separator: \".?!\") {\n        if s.hasPrefix(\"\
    I\") {\n            i += 1\n        }\n    }\n    return i", "    S = S.replacingOccurrences(of:\
    \ \"\\.\", with: \" \")\n    S = S.replacingOccurrences(of: \"\\?\", with: \"\
    \ \")\n    S = S.replacingOccurrences(of: \"!\", with: \" \")\n    var counter\
    \ = 0\n    for x in S {\n        if x == \"I\" {\n            counter += 1\n \
    \       }\n    }\n    return counter", "    \n    var count = 0\n    var current:\
    \ String = S.first\n    if S.first == \"I\" {\n        return count\n    }\n \
    \   \n    for word in S.characters {\n        switch word {\n        case \"?\"\
    , \".\", \"!\", \"\\n\", \"\\r\", \"\\t\":\n            return count\n       \
    \ default:\n            if current == word {\n                count += 1\n   \
    \         }\n            current = word\n        }\n    }\n    return count",
  "\treturn is_bored(S: S.characters)", '    return len(findBored(S)) > 0', "    var\
    \ count = 0\n    for c in S {\n        if c == 'I' {\n            count++\n  \
    \      } else if c == '.' || c == '?' || c == '!' {\n            count += 1\n\
    \        }\n    }\n    return count", "    var bored = 0\n    for word in S.split(separator:\
    \ \".?!\") where word != \"I\" {\n        if word == \"I\" {\n            bored\
    \ += 1\n        }\n    }\n    return bored", "    if S.hasPrefix(\"I\") {\n  \
    \      return S.count { $0 == \"I\" }\n    } else {\n        return S.count {\
    \ $0 == '.' || $0 == '?' || $0 == '!' }\n    }", '    return is_bored(S.characters)',
  "  let S = S.characters.reduce(\"\") {\n    if $0 == \".\" || $0 == \"?\" || $0\
    \ == \"!\" {\n      return $0 + \"$0\"\n    }\n    return $0\n  }\n  return S.characters.filter\
    \ { char in \"I\".characters.contains(char) }.count", "    var boredom_count =\
    \ 0\n    for s in S.split(separator: \".?!\") {\n        if s.starts(with: \"\
    I\") {\n            boredom_count += 1;\n        }\n    }\n    return boredom_count",
  '    return is_bored_words(S: S).count', "    let S = S.lowercased()\n    let chars\
    \ = [\"I\"]\n\n    for i in chars {\n        var count = 0\n        for j in S\
    \ {\n            let s = String(j).lowercased()\n            if s == i {\n   \
    \             count += 1\n            }\n        }\n        if count > 0 {\n \
    \           return count\n        }\n    }\n\n    return 0", "    var cnt = 0\n\
    \    for s in S.components(separatedBy: \".\") where s == \"I\" {\n        cnt\
    \ += 1\n    }\n    return cnt", "    let s = S.lowercased()\n    if s.contains(\"\
    i\") {\n        return s.range(of: \"i\", options: .caseInsensitive)?.lowerBound\
    \ != nil ?? 0\n    }\n    if s.contains(\"the\") {\n        return s.range(of:\
    \ \"the\", options: .caseInsensitive)?.lowerBound != nil ?? 0\n    }\n    if s.contains(\"\
    .\") {\n        return s.range(of: \".\", options: .caseInsensitive)?.lowerBound\
    \ != nil ?? 0\n    }\n    if s.contains(\"?\") {\n        return s.range(of: \"\
    ?\", options: .caseInsensitive)?.lowerBound != nil ?? 0\n    }\n    if s.contains(\"\
    !\") {\n        return s.range(of: \"!\", options: .caseInsensitive)?.lowerBound\
    \ != nil ?? 0\n    }\n    return 0", "    // BEGIN Question 2\n    return count_boredoms(S:\
    \ S, R: \"I\", I: 0)\n    // END Question 2", "    var result = 0\n    for word\
    \ in S.split(separator: \".?!\") {\n        if word == \"I\" {\n            result\
    \ += Int32(true)\n        }\n    }\n    return result", "    if S == \"\" { return\
    \ 0 }\n    var count = 0\n    var inBoredom = 0\n    var lastWord = \"\"\n   \
    \ for char in S {\n        switch char {\n        case 'I':\n            inBoredom\
    \ = 1\n            lastWord = char\n        case '?':\n            inBoredom =\
    \ 1\n            lastWord = char\n        default:\n            lastWord = \"\"\
    \n        }\n        if inBoredom {\n            count += 1\n            inBoredom\
    \ = 0\n        }\n    }\n    return count", "\treturn is_bored_1(S) == S", '    return
    count_bored(S, 1, true, false, true, false)', "    let splitS = S.split(\".\"\
    )\n    var count = 0\n    for i in splitS {\n        if i.starts(with: \"I\")\
    \ {\n            count += 1\n        }\n    }\n    return count", '    return
    is_bored_r(S).find(0, in: S).map({ Int($0) }).reduce(Int)(0)', "    let tokens\
    \ = S.components(separatedBy: \".\")\n    return tokens.count{\n        (_) ->\
    \ Bool in\n        switch $0 {\n        case \"I\":\n            return true\n\
    \        case \"!\", \"?\", \".\":\n            return false\n        }\n    }",
  "    \n    let is_bored: String -> Bool = {\n        (_: String) -> Bool in\n  \
    \      \n        (_: Int) -> Bool in\n        \n        return $0 == 0\n    }\n\
    \    \n    return count(S, is_bored)", '    return is_bored_1(S).count', '    return
    is_bored_helper(S).is_bored', "    var bored = 0\n    for word in S.split(separator:\
    \ \".?!\") {\n        if word == \"I\" {\n            bored += 1\n        }\n\
    \    }\n    return bored", "    var count = 0\n    for s in S.split(separator:\
    \ \".\") {\n        for letter in s {\n            if letter == \"I\" {\n    \
    \            count += 1\n                break\n            }\n        }\n   \
    \ }\n    return count", "    if S != \"\" {\n        var count = 0\n        for\
    \ ch in S {\n            if ch == \"I\" {\n                count += 1\n      \
    \      }\n        }\n        return count\n    }\n    return 0", "    let S =\
    \ S.lowercased()\n    var numBoredoms = 0\n    for i in S.characters.reverse()\
    \ {\n        switch i {\n        case \"i\": continue\n        case \"a\": continue\n\
    \        case \"e\": continue\n        case \"o\": continue\n        case \"u\"\
    : continue\n        case \"l\": continue\n        case \"s\": continue\n     \
    \   case \"d\": continue\n        case \"m\": continue\n        case \"t\": numBoredoms\
    \ = numBoredoms + 1\n        default: break\n        }\n    }\n    return numBoredoms",
  "    if !S.startsWith(\"I\") {\n        return 0\n    }\n    var count = 0\n   \
    \ for s in S.split(separator: \".,?!\") {\n        if s.startsWith(\"I\") {\n\
    \            count += 1\n        }\n    }\n    return count", "    // TODO: first\
    \ convert the string to lowercase and remove all punctuation\n    // Then split\
    \ on space and punctuation\n    \n    // TODO: write code here\n    return 0",
  "    let pattern = NSRegularExpression(\"^I\")\n\n    var count = 0\n\n    for str\
    \ in S {\n        let range: NSRange\n        range = str.rangeOfString(pattern,\
    \ options: .CaseInsensitive)\n\n        if range.location != NSNotFound {\n  \
    \          count += 1\n        }\n    }\n\n    return count", "    let boredoms:\
    \ Set<String> = [\"I\", \"!\", \".\"]\n\n    // Your code here\n\n    return 0",
  "  let lower = S.lowercased().characters()\n  let start = lower.startIndex\n  let\
    \ end = lower.endIndex\n\n  var result = 0.0\n\n  for word in S.characters.dropFirst(start)\
    \ {\n    if word == \"i\" {\n      result += 1.0\n    }\n  }\n\n  return result\
    \ / Float(end - start)", "    let boredom = [\"I\", \" .\", \"?\", \"!\"]\n  \
    \  return S.lowercased().components(separatedBy: boredom).count > 1", "    \n\
    \    var count = 0\n    for s in S.split(separator: \".,?!\") {\n        \n  \
    \      if s.starts(with: \"I\") {\n            count += 1\n        }\n    }\n\
    \    return count", "    if S.isEmpty {\n        return 0\n    }\n    let firstWord\
    \ = S.split(separator: \".\", omittingEmptySubsequences: false).first!\n    if\
    \ firstWord.rangeOfCharacter(from: CharacterSet.letters) == nil {\n        return\
    \ 0\n    }\n\n    let indexOfFirstI = firstWord.rangeOfCharacter(from: CharacterSet.letters.inverted)\n\
    \    if indexOfFirstI == nil {\n        return 0\n    }\n\n    return S.range(of:\
    \ \".\", options: .backwards)?.lowerBound?.distance(to: indexOfFirstI.upperBound!)\
    \ ?? 0", "    let words = S.split(\".\").map(String.init)\n    \n    if words[0]\
    \ == \"I\" {\n        return words.count\n    }\n    else if words[0] == \"!\"\
    \ {\n        return words.count - 1\n    }\n    else {\n        return -1\n  \
    \  }", '    return len(S) - is_bored_helper(S, "", 0, 0, 0)', "    var result\
    \ = 0\n    var i = 0\n    var j = 0\n\n    while (i < S.count) {\n        let\
    \ char = S[i]\n        i += 1\n\n        if (char == \"I\") {\n            j =\
    \ i\n            var count = 0\n            while (j < S.count) {\n          \
    \      if (S[j] == \".\") {\n                    count += 1\n                }\
    \ else if (S[j] == \"?\") {\n                    count += 1\n                }\
    \ else if (S[j] == \"!\") {\n                    count += 1\n                }\n\
    \n                j += 1\n            }\n\n            if (count == 0) {\n   \
    \             result++\n            }\n        } else if (char == \".\" || char\
    \ == \"?\" || char == \"!\") {\n            if (j != i) {\n                result++\n\
    \            }\n        }\n    }\n\n    return result", "    guard S.starts(with:\
    \ \"I\", caseSensitive: false), S.count == 1 else {\n        return 0\n    }\n\
    \    return 1", "    // BEGIN Practice Problem 3\n    return S.range(of: \"^I\"\
    , options: .regularExpression).count == 0 ? 0 : 1\n    // END Practice Problem\
    \ 3", "    var i: Int = 0\n    var j: Int = 0\n    for j in S.characters.indices{\n\
    \        if S[j] == \".\" || S[j] == \",\" || S[j] == \";\" || S[j] == \":\" ||\
    \ S[j] == \";\" || S[j] == \".\" || S[j] == \"!\" || S[j] == \"?\" {\n       \
    \     i = i + 1\n        }\n    }\n    return i", "\treturn is_bored_impl(S: S,\
    \ words: S.get_word_list())", "    var counter = Int()\n    for word in S.split(separator:\
    \ \".?!\") {\n        if word.first?.unicodeScalars.first == \"I\" {\n       \
    \     counter += 1\n        }\n    }\n    return counter", "    if S.count < 1\
    \ {\n        return 0\n    }\n    var boredom_count = 0\n    if S.hasPrefix(\"\
    I\") {\n        boredom_count = 1\n    }\n    if S.hasSuffix(\".\") || S.hasSuffix(\"\
    ?\") || S.hasSuffix(\"!\") {\n        boredom_count = boredom_count + 1\n    }\n\
    \    return boredom_count", '    return boredoms(S: S).count', '    return is_bored_helper(S,
    "", 0, 0, 0)', "\tvar boredoms: Int = 0\n\tfor _,w := range S.split(\" \") {\n\
    \t\tswitch w[0] {\n\t\tcase \"I\":\n\t\t\tboredoms += 1\n\t\tdefault:\n\t\t\t\
    break\n\t\t}\n\t}\n\treturn boredoms", "    return is_bored_recursive(S.characters\n\
    \        .filter({ $0 == '.' || $0 == '?' || $0 == '!' })\n        .map({ String($0)\
    \ }))", "    let arr = S.components(separatedBy: \".?!\").map { $0.isEmpty ? 0\
    \ : $0.count }\n    return arr.max().map { $0 + 1 }.min()", "    let S = S.lowercased()\n\
    \    guard let index = S.range(of: \"i\") else {\n        return 0\n    }\n  \
    \  return 1", "    var i = 0\n    for c in S {\n        if c == \".\" || c ==\
    \ \"?\" || c == \"!\" {\n            i = i + 1\n        }\n    }\n    return i",
  "  var numboredoms = 0\n\n  for s in S.split(separator: \".,?!\"){\n    if s.starts(with:\
    \ \"I\") {\n      numboredoms += 1\n    }\n  }\n\n  return numboredoms", "   \
    \ var result = 0\n    for word in S.split(\" \") {\n        switch word {\n  \
    \      case \"I\":\n        default:\n            result += 1 // boredom\n   \
    \     }\n    }\n    return result", '  return is_bored_3(S.characters)', "   \
    \ // TODO: implement this!\n    return 0", "    var sum = 0\n    for word in S.split(\"\
    \ \") {\n        switch word.first! {\n        case \"I\":\n            sum +=\
    \ 1\n        case \"?\", \"!\", \".\":\n        default:\n            break\n\
    \        }\n    }\n    return sum", '    return bored(S: string, S2: string.split("
    "))', "    // Your code here\n    var boredoms = 0\n    for words in S.split(separator:\
    \ \".,?!\") {\n        if words.rangeOfString(\"I\") != nil {\n            boredoms\
    \ += 1\n        }\n    }\n    return boredoms", '    return is_bored_helper(S,
    bored_words())', '    return count_boredom(S) == 0', "    if S.first == \"I\"\
    \ {\n        return 0\n    }\n    \n    var count = 0\n    for s in S {\n    \
    \    switch s {\n        case \"?\", \".\", \"!\": count++\n        default: break\n\
    \        }\n    }\n    return count", '    return count_boredoms(S: S)', "   \
    \ var boredCount = 0\n    for s in S.split(separator: \".\") {\n        if s[0]\
    \ == \"I\" {\n            boredCount += 1\n        }\n    }\n    return boredCount",
  "    let boredom = [\"I\", \"are\", \"you\", \"the\", \"i\", \"you\", \"the\", \"\
    the\", \"the\"]\n    let split = S.characters.split(separator: boredom).map(String.init)\n\
    \    return split.count { $0 == boredom[0] }", "    // TODO: Use a regex to solve\
    \ this problem\n    var count = 0\n    for word in S.split(separator: \".?,!\"\
    ) {\n        if word == \"I\" {\n            count += 1\n        }\n    }\n  \
    \  return count", "    \n    // TODO: implement a function to determine if a sentence\
    \ is a boredom or not\n    \n    return 0", "    let boredom = [\"I\".\".\".\"\
    !\"]\n    return boredom.filter({ S[$0.startIndex] == \"I\" }).count", '    return
    is_bored_internal(S: S, Boredoms: Boredoms, delimiters: [".", "?", "!"])', " \
    \   var boredoms = 0\n    var sentence = S.split(\".\").filter({ $0 == \"I\" })\n\
    \    var lastWord = \"\"\n    for word in sentence.prefix(sentence.length - 1)\
    \ {\n        if word == \"I\" {\n            boredoms += 1\n            lastWord\
    \ = word\n        }\n    }\n    return boredoms", "    let words    = S.characters.split(separator:\
    \ \".?!\").map{ $0.trimmingCharacters(in: .whitespaces) }\n    let boredoms =\
    \ [\"I\", \"a\", \"I\", \"a\", \"I\", \"a\", \"I\", \"a\", \"I\"]\n    let borems\
    \   = boredoms.filter({ words.contains($0) })\n    return borems.count", "   \
    \ guard S.count >= 2 else {\n        return 0\n    }\n    var result = 1\n   \
    \ if S.startsWith(\"I\", options: .literal) != nil {\n        result = 0\n   \
    \ }\n    return result", "    guard S.hasPrefix(\"I\") else {\n        return\
    \ 0\n    }\n    guard S.hasSuffix(\" .\") else {\n        return 0\n    }\n  \
    \  guard S.hasSuffix(\" ?\") else {\n        return 0\n    }\n    guard S.hasSuffix(\"\
    \ !\") else {\n        return 0\n    }\n    return 1", "    guard let S = S.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \",.?!\")) else { return 0 }\n    return S.hasPrefix(\"\
    I\") && S.count > 2", "    let words = S.split(\" \")\n    var bored = 0\n   \
    \ for word in words {\n        guard let word = word.capitalized else { continue\
    \ }\n        switch word {\n        case \"I\":\n            bored += 1\n    \
    \    case \"?\", \".\", \"!\":\n            break\n        default:\n        \
    \    continue //word isn't in [\"I\", \".\", \"!\"]\n        }\n    }\n    return\
    \ bored", "    var counter = 0;\n    for word in S.split(separator: \".,?,!\"\
    ) {\n        if word == \"I\" {\n            counter++;\n        }\n    }\n  \
    \  return counter;", "    \n    let sentences = S.split(separator: \".?!\")\n\
    \    return sentences.filter({ $0.hasPrefix(\"I\") }).count", "  let chars = S.characters.map\
    \ { String($0) }\n  let start = find(chars, \"I\")\n  if start == nil {\n    return\
    \ 0\n  }\n  var count = 0\n  var i = 0\n  for i = start.index; !chars[i].isLetterOrDigit;\
    \ i++ {\n    if chars[i] == \"!\" || chars[i] == \".\" || chars[i] == \"?\" {\n\
    \      break\n    }\n  }\n  for ; i < S.characters.count; i++ {\n    if chars[i]\
    \ == \"I\" {\n      break\n    }\n    if chars[i] == \"!\" || chars[i] == \".\"\
    \ || chars[i] == \"?\" {\n      break\n    }\n  }\n  for i = 1; i < S.characters.count;\
    \ i++ {\n    if chars[i] == \"I\" || chars[i] == \"!\" || chars[i] == \".\" ||\
    \ chars[i] == \"?\" {\n      break\n    }\n  }\n  guard i == S.characters.count\
    \ else {\n    return 0\n  }\n  count += i - start.index\n  return count", "  \
    \  let S = S.lowercased()\n    \n    let boredom = NSPredicate(format: \"SELF\
    \ MATCHES %@\", #\"^[I].*$\")\n    return S.count(byWord: boredom)", "    var\
    \ count = 0\n    \n    for char in S {\n        switch char {\n        case 'I':\n\
    \        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n\
    \        case 'u':\n        case 'y':\n            count += 1\n        default:\n\
    \            break\n        }\n    }\n    \n    return count", "    let words\
    \ = S.split(separator: \".\")\n    let startsWithI = words.filter{$0.hasPrefix(\"\
    I\")}\n    let countOfI = startsWithI.count\n    return countOfI", '    return
    is_bored_str(S).count', "    var count = 0\n    var idx = 0\n    while idx < S.count\
    \ {\n        if S[idx..<idx+3] == \"I\" {\n            count += 1\n        }\n\
    \        idx += 3\n    }\n    return count", "    let pattern = \"^[i.!]+\\.$\"\
    \n    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n  \
    \  let matches = regex.matches(in: S, options: [], range: NSRange(S.startIndex...,\
    \ in: S))\n    return matches.count ?? 0", "    guard S.isEmpty == false else\
    \ {\n        return 0\n    }\n    var count = 0\n    let words = S.components(separatedBy:\
    \ .whitespacesAndNewlines)\n    \n    for word in words {\n        let s = word.characters.first\n\
    \        if s == Character(\"I\") {\n            count += 1\n        }\n    }\n\
    \    \n    return count", "    var count = 0\n    \n    // Your code here\n  \
    \  \n    return count", '    return is_bored(S.characters)', "    // Your code\
    \ here\n    if S.hasPrefix(\"I\") {\n        return S.count(\"I\") + (S.count(\"\
    !\") + S.count(\"?\"))\n    } else {\n        return 0\n    }", "    var counter:\
    \ Int = 0\n    for word in S.split(separator: \".,?!\") {\n        if word ==\
    \ \"I\" {\n            counter += 1\n        }\n    }\n    return counter", " \
    \   \n    let I = \"I\"\n    var count = 0\n    \n    S += \"!\"\n    S += \"\
    .\"\n    S += \"?\"\n    S += \"!\"\n    \n    for s in S.characters.dropLast()\
    \ {\n        switch s {\n        case \"I\":\n        case \"!\":\n        case\
    \ \"?\":\n            count += 1\n        default:\n            break\n      \
    \  }\n    }\n    \n    return count", "    var count = 0\n    var words = S.characters.split{$0\
    \ == \"?\"} + S.characters.split{$0 == \"!\"} + S.characters.split{$0 == \".\"\
    }\n    guard !words.isEmpty else {\n        return count\n    }\n    for word\
    \ in words {\n        if word == \"I\" {\n            count += 1\n        }\n\
    \    }\n    return count", '    return is_bored_helper(S, is_bored_words)', '    return
    len(S) - count_boredoms(S: S) == 0', "    let wordList: Set<String> = [\"I\"]\n\
    \    return countStart(S, wordList)", "    if S.contains(\".\") || S.contains(\"\
    ?\") || S.contains(\"!\") {\n        return 0\n    }\n    if S.contains(\"I\"\
    ) {\n        return 1\n    }\n    return 0", "    var bored = 0\n    for let word\
    \ in S.split(separator: \".\") {\n        bored += is_bored_word(word: word)\n\
    \    }\n    return bored", "    // TODO: check whether S.startsWith(\"I\")\n \
    \   let N = S.characters.count\n    var bored = 0\n    for _ in 0..<S.characters.count\
    \ {\n        bored += is_bored(S.substring(with: NSRange.init(location: 1, length:\
    \ 2)))\n    }\n    return bored + N"]
stop_tokens:
- "\n}"
