name: HumanEval_49_modp
language: swift
prompt: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p:\
  \ 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
  /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc\
  \ modp(n: Int, p: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101,\
  \ p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
  assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
  \ 31, p: 5) == 3)"
completions: ["\tswitch n {\n\tcase 0:\n\t\treturn 0\n\tcase p:\n\t\treturn 1\n\t\
    case p:\n\t\treturn 0\n\tdefault:\n\t\treturn Int((p - 1) * n / p)\n\t}", "\t\
    switch {\n\tcase n == 0: return 1\n\tcase n < 0: return modp(abs(n), p)\n\tcase\
    \ p < 0: return modp(n, -p)\n\t}\n\treturn powMod(n, p, p)", "\tif n == 0 {\n\t\
    \treturn 1\n\t}\n\tvar q = p / 2\n\tvar r = p % 2\n\tswitch {\n\tcase n == p:\n\
    \t\treturn 1\n\tcase n < p:\n\t\tq = q - 1\n\t\tr = p - q\n\t\tif r > 0 {\n\t\t\
    \treturn r + modp(n, q)\n\t\t}\n\tdefault:\n\t\tq = q + 1\n\t\tr = p - q\n\t\t\
    if r > 0 {\n\t\t\treturn r + modp(n, q)\n\t\t}\n\t}\n\treturn 0", "    if n <\
    \ 0 {\n        n *= -p\n    }\n    if p < 2 {\n        p *= 2\n    }\n    if p\
    \ > p {\n        return p - 1\n    }\n    var mod = p\n    var d = n\n    while\
    \ n > 0 {\n        mod %= p\n        n /= p\n        d *= p\n    }\n    if d ==\
    \ 1 && mod != 1 {\n        return mod\n    }\n    return mod", "    let n = n\
    \ & Mask(p)\n    let p = p & Mask(p)\n    let result = p + (n & Mask(p))\n   \
    \ result %= p\n    return result | Mask(p)", "    switch n {\n    case 0: return\
    \ 0\n    case 1: return p\n    case 2: return n\n    case 3: return p + (n & 1)\n\
    \    case 4: return p + (n & 2)\n    case 5: return p + (n & 3)\n    case 6: return\
    \ p + (n & 4)\n    case 7: return p + (n & 5)\n    case 8: return p + (n & 6)\n\
    \    case 9: return p + (n & 7)\n    case 10: return p + (n & 8)\n    case 11:\
    \ return p + (n & 9)\n    case 12: return p + (n & 10)\n    case 13: return p\
    \ + (n & 11)\n    case 14: return p + (n & 12)\n    case 15: return p + (n & 13)\n\
    \    case 16: return p + (n & 14)\n    case 17: return p + (n & 15)\n    case\
    \ 18: return p + (n & 16)\n    case 19: return p + (n & 17)\n    case 20: return\
    \ p + (n & 18)\n    case 21: return p + (n & 19)\n    case 22: return p + (n &\
    \ 20)\n    case 23: return p + (n & 21)\n    case 24: return p + (n & 22)\n  \
    \  case 25: return p + (n & 23)\n    case 26: return p + (n & 24)\n    case 27:\
    \ return p + (n & 25)\n    case 28: return p + (n & 26)\n    case 29: return p\
    \ + (n & 27)\n    case 30: return p + (n & 28)\n    case 31: return p + (n & 29)\n\
    \    case 32: return p + (n & 30)\n    case 33: return p + (n & 31)\n    case\
    \ 34: return p + (n & 32)\n    case 35: return p + (n & 33)\n    case 36: return\
    \ p + (n & 34)\n    case 37: return p + (n & 35)\n    case 38: return p + (n &\
    \ 36)\n    case 39: return p + (n & 37)\n    case 40: return p + (n & 38)\n  \
    \  case 41: return p + (n & 39)\n    case 42: return p + (n & 40)\n    case 43:\
    \ return p + (n & 41)\n    case 44: return p + (n & 42)\n    case 45: return p\
    \ + (n & 43)\n    case 46: return p + (n & 44)\n    case 47: return p + (n & 45)\n\
    \    case 48: return p + (n & 46)\n    case 49: return p + (n & 47)\n    case\
    \ 50: return p + (n & 48)\n    case 51: return p + (n & 49)\n    case 52: return\
    \ p + (n & 50)\n    case 53: return p + (n & 51)\n    case 54: return p + (n &\
    \ 5", "    if n < p {\n        return 0\n    }\n    // The algorithm implemented\
    \ below is incomplete, it is only intended\n    // to convey an idea of what can\
    \ be done to reduce modulo p to n.\n    var q: Int\n    if n > p {\n        q\
    \ = p % n\n    } else {\n        q = 0\n    }\n    var x = 1\n    for _ in 0 ..\
    \ (p - n) {\n        x = x * q\n        q += 1\n    }\n    return x", '  return
    n & (p ^ n) < 0 ? n | p : n', "    if n >= 0 {\n        if n == p {\n        \
    \    return n\n        }\n        return p - modp(n - p, p)\n    }\n    return\
    \ modp((p - 1) * (p + 1), p)", "\tlet r = p % n\n\tif r == 0 {\n\t\treturn 1\n\
    \t}\n\treturn r", "    if n == 0 { return 1 }\n    if n == 1 { return n }\n  \
    \  let mask = (p - 1) << (n - 1)\n    return (n & mask) % (p - 1)", "\tvar res\
    \ = 0\n\tfor i := 0; i < n; i++ {\n\t\tres += p\n\t\tp %= p\n\t}\n\treturn res",
  "\tswitch {\n\tcase n < 0:\n\t\treturn modp(-n, p)\n\tcase p < 0:\n\t\treturn modp(abs(n),\
    \ -p)\n\t}\n\tswitch {\n\tcase p == 0:\n\t\treturn 0\n\tcase n <= (p-1):\n\t\t\
    return p\n\tdefault:\n\t\ta := modp(n / p, p)\n\t\tif a > 1 {\n\t\t\ta -= 1\n\t\
    \t}\n\t\treturn a * p\n\t}", "  if n < 0 {\n    return modp(abs(n), p)\n  }\n\n\
    \  if p <= 0 {\n    return 0\n  }\n\n  if n == 0 {\n    return 1\n  }\n\n  if\
    \ p == 1 {\n    return n\n  }\n\n  var r = 0\n  while n > 0 {\n    n := n / p\n\
    \    r ^= n\n  }\n  return r", "\tassert(n >= 0)\n\tassert(p >= 0)\n\tassert(p\
    \ < p)\n\t\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\n\tvar res = 1\n\t\n\twhile n\
    \ > 0 {\n\t\tif n&1 == 1 {\n\t\t\tres = (res*p) % p\n\t\t}\n\t\tn = n >> 1\n\t\
    }\n\t\n\treturn res", "\tswitch {\n\tcase n < 0:\n\t\treturn -modp(-n, p)\n\t\
    case n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}", "\treturn\
    \ (p - 1) & n", "\tif n < 0 || p < 0 {\n\t\tif n == 0 {\n\t\t\treturn 0\n\t\t\
    }\n\t\treturn 1\n\t}\n\tif n <= p {\n\t\treturn n - p\n\t}\n\treturn (p % n) +\
    \ 1", '    return ((n%p + p) % p) % p', "    var p = p\n    var result = 1\n \
    \   result %= p\n    while n > 0 {\n        result *= p\n        n--\n       \
    \ result %= p\n    }\n    return result", '    return (n * p + p) % (p * p) %
    p', "    if n >= 0 {\n        return Int(pow(2, Int(n)) - 1 + p)\n    }\n    if\
    \ n == 0 {\n        return Int(p)\n    }\n    if n < 0 {\n        return modp(-n,\
    \ p)\n    }\n    if p < 0 {\n        return modp(Int(-n), p)\n    }\n    return\
    \ 0", '  return modInt64ModInt(n, p)', "\tlet a = powMod(p, n-1, p)\n\tif a ==\
    \ 1 {\n\t\treturn 0\n\t}\n\treturn a", "    if n > p { return n }\n    if n <\
    \ 0 { return 0 }\n    if n == 0 { return 1 }\n    if n == p { return 0 }\n\n \
    \   let dp = p\n    let dn = n - p\n    let rem = n % dp\n    return rem == 0\
    \ ? dp : modp(rem, dp)", "\tlet t = n % (p - 1)\n\tlet r = t + (p - 1)\n\treturn\
    \ r", "    if n > p {\n        return n % p\n    }\n    if n < p {\n        return\
    \ p - (n % p)\n    }\n    return 0", "    if n == 0 {\n        return p\n    }\n\
    \    switch p {\n    case 0: return 1\n    case 1: return 0\n    case 2: return\
    \ 1\n    }\n    var result = p\n    var d = 0\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            result /= p\n            result += p\n        }\n  \
    \      d += 1\n        n /= 2\n    }\n    return (p - 1) & d", "    if n == 0\
    \ {\n        return 1\n    }\n    \n    return n % p", "\treturn n % p", "\tif\
    \ n == 0 || p == 0 {\n\t\treturn 0\n\t}\n\tif n < p {\n\t\treturn n\n\t}\n\tn\
    \ = n % (p - 1)\n\treturn p + n - p", "    if n == 0 { return 1 }\n    if p ==\
    \ 0 { return 0 }\n    var mod = 0\n    if n > p { mod += n - p }\n    mod += p\
    \ - 1\n    mod %= p\n    return mod", '    return (n - n % p) % p', "\treturn\
    \ (n & (p - 1)) + p", "\t// This assumes n and p are both positive.\n\tlet r =\
    \ p % n\n\tif r == 0 || n <= 0 {\n\t\tr = 0\n\t}\n\treturn r", "\tif n == 0 ||\
    \ p == 0 {\n\t\treturn 1\n\t}\n\treturn powmod(n, p, p)", "    if n == 0 {\n \
    \       return 1\n    }\n\n    if n == 1 {\n        return p\n    }\n\n    if\
    \ n >= p {\n        return modp(n - 1, p) % p\n    }\n\n    // Favor modp(n -\
    \ p, p) since modp(n-1, p) is prone to overflow\n    if n >= p - p {\n       \
    \ return p - (modp(n - p, p) + 1)\n    }\n\n    return modp((n - p) / p, p)",
  "    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return p\n \
    \   }\n    if n == p {\n        return n\n    }\n    if n < p {\n        return\
    \ modp(n+p, p)\n    }\n    return modp(n - p, p)", "\tlet m = n % (p - 1)\n\t\n\
    \tif (m > p / 2) {\n\t\tm %= p\n\t} else {\n\t\tm += p\n\t}\n\t\n\treturn m",
  "\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n < (p\
    \ - 1) {\n\t\treturn 0\n\t}\n\tif p == 1 {\n\t\treturn 1\n\t}\n\treturn modp(n-p-1,\
    \ p)", '    return ((n-1)&(n-p))&(n|(n-1))', "    if n < 0 {\n        if n >=\
    \ -p {\n            return n - p\n        }\n        return n - p + p\n    }\n\
    \    if n >= p {\n        return n - p\n    }\n    return n - p + p", "    //\
    \ we cannot use 'mod p' because 'mod p' can return 0\n    // (https://bugs.swift.org/browse/SR-5866)\n\
    \    var mod = 0\n    while n > 0 {\n        n /= p\n        mod += 1\n    }\n\
    \    return mod", "    if n == 0 {\n        return 1\n    }\n    if p < n {\n\
    \        return modp(n - p, p)\n    }\n    return p % n", "  let m = p % n\n \
    \ if m < 0 {\n    m += n\n  }\n  return m", "\tn %= p\n\tif n == 0 || n == p {\n\
    \t\treturn n\n\t} else if n == p {\n\t\treturn n - 1\n\t}\n\treturn n", "\treturn\
    \ (p & (-n)) + (((n & (-p)) | n) << n)", "\tif n < 0 {\n\t\tpanic(n + \" < 0\"\
    )\n\t} else if n > p {\n\t\tpanic(n + \" > \" + p)\n\t}\n\n\treturn n & ((p -\
    \ 1) ^ n)", "    let exp = p.logBase2()\n    return pow(Int(pow(Double(n), Double(exp))),\
    \ Double(exp))", "    if p < 1 {\n        return Int(p) - 1\n    }\n    return\
    \ n % p", "\treturn bits.TrailingZeros64(bits.RotateLeft64(n, 64)) % p", "\tswitch\
    \ {\n\tcase n == 0 && p == 0: return 1\n\tcase n >= p && n <= INT_MAX:\n\t\tif\
    \ n == p { return n }\n\t\tq := n - p\n\t\tif q <= INT_MAX { // p is prime\n\t\
    \t\tmod := 1\n\t\t\tfor x := 1; x < q; x++ {\n\t\t\t\tif n % (x + p) == 0 {\n\t\
    \t\t\t\tmod *= x\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mod\n\t\t\
    }\n\t\tmod := 1\n\t\tfor x := 2; x < q; x++ {\n\t\t\tif n % (x + p) == 0 {\n\t\
    \t\t\tmod *= x\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn mod\n\tdefault:\n\t\t\
    panic(\"modp failed\")\n\t}", "    if n <= 0 {\n        return 0\n    }\n    if\
    \ n > p { // n must be > p\n        return mod(n)\n    }\n    n %= p\n    if n\
    \ == 0 {\n        return 0\n    }\n    if n >= p {\n        return mod(p)\n  \
    \  }\n    return n", "\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn n + (p -\
    \ n)", "    if n > p {\n        return modp(n - p, p)\n    }\n    if n >= p {\n\
    \        return n - p\n    }\n    return 0", "    let x = powMod(p, n - 1, p)\n\
    \    return x % p", "\tn %= p\n\tif n < 0 {\n\t\tn = p + n\n\t}\n\treturn n",
  "    let res = pow(Double(n), Double(p)) - Double(p)\n    return res * res / pow(Double(p),\
    \ Double(p))", "    let r = n % p\n    if r == 0 {\n        return n\n    }\n\
    \    return r", "\treturn n & (p - 1)", "    n %= p\n    if n < 0 {\n        n\
    \ *= -1\n        n %= p\n    }\n    return n", "\treturn (n - 1)&(p - 1)", " \
    \ // TODO: This will be a lot more efficient with bit operations.\n  // TODO:\
    \ It would also be better if we could use signed integers.\n  // TODO: Signed\
    \ integers would make this quite a bit easier.\n  switch {\n  case n == 0: return\
    \ 1\n  case n == 1: return p\n  case n < 0: return modf(-n, p)\n  case p < 1:\
    \ return modpow(p, n)\n  case p > p: return modpow(p, n)\n  default: return n\
    \ % p\n  }", '  return ((1 << (p - 1)) + 1) & -((1 << (p - 1)) - 1)', '    return
    modpow(n, p, p)', "    let mask = 1 << (p - 1)\n\n    if n >= p {\n        return\
    \ ((n & (mask - 1)) ^ mask)\n    } else {\n        return ((n | -mask) & -p) +\
    \ p\n    }", '    return n.bitwiseAnd(p).bitwiseXor(1).bitwiseShiftLeft(n.bitCount())',
  "\treturn n & (p-1)", "  if n < 0 {\n    if p == 1 {\n      return n\n    }\n  \
    \  return -modp(-n, p)\n  }\n  if p < 2 {\n    return 0\n  }\n  if p > p {\n \
    \   p = 2\n  }\n  // TODO: replace with bit-shift.\n  if p == 1 {\n    return\
    \ n & -p\n  }\n  var q = p / 2\n  var r = n % p\n  if r > 0 {\n    return q +\
    \ modp(n - r, p)\n  }\n  return q", "    // TODO: this could be more efficient\
    \ with a bitwise and\n    // right shift (instead of modulo)\n    var result =\
    \ 1\n    for i := n - 1; result > 0 && i >= 0; i-- {\n        if ((result & 1)\
    \ == 1) {\n            result >>= 1\n        } else {\n            result >>=\
    \ 1\n            result |= p - 1\n        }\n    }\n    return result", "    if\
    \ n == 0 {\n        return 0\n    }\n    t := n >> p // t will be <= n >> p\n\
    \    if t == n {\n        t = t % (p - 1)\n    } else {\n        t = t % (p +\
    \ 1)\n    }\n    return t", "\tif n == 0 {\n\t\treturn 0\n\t}\n\n\tif n == 1 {\n\
    \t\treturn 1\n\t}\n\n\tlet mut product = 0\n\n\tfor bit in &p {\n\t\tif bit <\
    \ 2 {\n\t\t\tproduct *= n\n\t\t} else {\n\t\t\tproduct *= 2\n\t\t\tproduct %=\
    \ n\n\t\t}\n\t}\n\n\treturn product", "    switch {\n    case n >= p && n < p+1:\n\
    \        return n - p + (p - n)*(n-1)\n    case n < p:\n        return p\n   \
    \ case n < p+1:\n        return 0\n    }", "\tswitch {\n\tcase p < 0:\n\t\treturn\
    \ modp(n, -p) * -1\n\tcase p >= n:\n\t\treturn 0\n\tdefault:\n\t\tp = p * n\n\t\
    \tn %= p\n\t\treturn n / p\n\t}", "\tcheckTypes(n, p)\n\treturn n % p", '    return
    n - n % (p * p)', '    return n & (p - 1) | mod((n - 1) & p, p)', "    let m =\
    \ powMod(UInt32(p.bitLength), UInt32(n), p)\n    return UInt32(m & UInt32(n))",
  "\tvar result : Int\n\tswitch {\n\tcase n < 0 && (n & (n - 1)) == 0: // power of\
    \ 2\n\t\tresult = n\n\tcase n >= p:\n\t\tresult = p - n // mod p\n\tdefault:\n\
    \t\tlet d = p - n % p\n\t\tlet r = n % p\n\t\tresult = d + r\n\t}\n\treturn result",
  "  // TODO: use binary search and maybe optimize\n  return n % p", "\tif n < 0 {\n\
    \t\tpanic(fmt.Sprintf(\"n must be non-negative, got %v\", n))\n\t}\n\tif p < 1\
    \ {\n\t\tpanic(fmt.Sprintf(\"p must be positive, got %v\", p))\n\t}\n\tvar c uint\n\
    \tif n >= p {\n\t\tc = 1\n\t} else if p > 0 {\n\t\tc = p\n\t} else {\n\t\tpanic(fmt.Sprintf(\"\
    n must be >= 0, got %v\", n))\n\t}\n\tfor {\n\t\tx := n\n\t\tn /= p\n\t\tif n\
    \ == 0 {\n\t\t\treturn x\n\t\t}\n\t\tif n == 1 {\n\t\t\treturn c - x\n\t\t}\n\t\
    \tx -= n\n\t\tc *= p\n\t}", "    if n == 0 {\n        return 0\n    }\n    if\
    \ p < 2 {\n        return n % p\n    }\n    var q = 1\n    for ; p > 2 && n >=\
    \ p * q; q *= 2\n    return n % q", "    switch {\n    case n < p:\n        return\
    \ n + p - 1\n    case n == p:\n        return n\n    case n > p:\n        return\
    \ modp(n - p, p)\n    }", "\treturn n % p", "    // We use log2 to avoid overflow.\n\
    \    let log2 = log2(p)\n    if n > p {\n        return n - p\n    }\n    if n\
    \ == 0 {\n        return 1\n    }\n    if n == 1 {\n        return p\n    }\n\
    \    if n == 2 {\n        return p\n    }\n    if log2 < modpModulus {\n     \
    \   return modpModulus\n    }\n    if log2 < modpModulus - 1 {\n        return\
    \ modpModulus - log2\n    }\n    return modpModulus - log2", "\treturn (pow(2,\
    \ n) - 1) % (p - 1)", '    return ((n%p)+p) % p', '    return (n * pow(p, n))
    % p', "    if n >= p {\n        return n % p\n    }\n    n %= p\n    if n < 0\
    \ {\n        return modp(n - p, p) + p\n    }\n    return n", "  var a = BigUInt(n)\n\
    \  if a.isZero() { return 1 }\n  var d = BigUInt(p)\n  var e = BigUInt(0)\n  var\
    \ m = BigUInt(0)\n  var r = BigUInt(0)\n  while true {\n    var q = BigUInt(a.bitCount())\
    \ - BigUInt(1)\n    var t = r\n    if a.bitCount() > p.bitCount() {\n      t =\
    \ m\n    }\n    if t == BigUInt(0) {\n      return 1\n    } else if a.bitCount()\
    \ == p.bitCount() {\n      if t.isZero() {\n        return BigUInt(0)\n      }\n\
    \      return BigUInt(0)\n    }\n    r.shrRsh(t, q)\n    if r.isZero() {\n   \
    \   return BigUInt(0)\n    }\n    m.shrRsh(t, BigUInt(q))\n    if m.isZero() {\n\
    \      if a.bitCount() == p.bitCount() {\n        return r.isZero() ? BigUInt(1)\
    \ : BigUInt(0)\n      }\n      return BigUInt(0)\n    }\n    a.shrRsh(t, BigUInt(q))\n\
    \  }", "\tif n < 0 {\n\t\treturn -modp(-n, p)\n\t}\n\tif p <= 1 {\n\t\tif n >=\
    \ p {\n\t\t\treturn 0\n\t\t}\n\t\treturn n\n\t}\n\n\tx := p\n\ty := n\n\n\tfor\
    \ {\n\t\tif y % x == 0 {\n\t\t\treturn y\n\t\t}\n\t\tx /= 2\n\t\ty /= x\n\t}",
  "    if n <= 0 || p <= 0 {\n        return -1\n    }\n\n    if n == 0 {\n      \
    \  return 1\n    }\n\n    if n >= p {\n        return modp(n, p - 1)\n    }\n\n\
    \    let mut n = n\n\n    while n > p {\n        n = n - p\n    }\n\n    return\
    \ n", "  if n <= p { return n }\n  let t = p % n\n  if t == 0 {\n    return p\n\
    \  } else {\n    return n + t - 1\n  }", "    n &= p\n    return ((n & (-p)) +\
    \ (n & p))", "    var tmp: Int = n\n    for i in 0 ..< p {\n        tmp = tmp\
    \ & 1\n        tmp = tmp ^ 3\n    }\n    return tmp", "\tswitch {\n\tcase n <\
    \ 0:\n\t\treturn n % p\n\tcase n <= p:\n\t\treturn n\n\tdefault:\n\t\tn -= p\n\
    \t\treturn (n % p) + p\n\t}", "\tif n < 0 {\n\t\treturn 0\n\t}\n\n\tconst modPow:\
    \ Int = p - 1\n\n\tif p <= 1 {\n\t\treturn n\n\t}\n\n\tvar (\n\t\tq     = NewBigUint64(modPow)\n\
    \t\tresult = n.Abs().Cmp(modPow) * NewBigUint64(modPow)\n\t)\n\n\tfor ; n > 0;\
    \ n /= p { q = q.Mul(q, NewBigUint64(p)) }\n\tfor ; p.Cmp(q) == 0; p = p.Sub(p,\
    \ q, NewBigUint64(modPow)) { q = q.Mul(q, NewBigUint64(p)) }\n\n\treturn q", '    return
    n.pow(p).maskPow(p)', "    n %= p\n    if n < 0 {\n        n += p\n    }\n   \
    \ return n", "\tlet x = pow(IntPow(p, 1), n)\n\tlet y = round(x / p)\n\treturn\
    \ y", "    if n < 0 {\n        // modp of negative number is undefined\n     \
    \   // https://bugs.webkit.org/show_bug.cgi?id=143099\n        return -1\n   \
    \ }\n    if n == 0 {\n        return 1\n    }\n    if n < p {\n        // n is\
    \ a power of p\n        var r = 1\n        for i := 0; i < n; i++ {\n        \
    \    r *= p\n        }\n        return r\n    }\n    return n % p", "    \n  \
    \  var result: Int = 0\n    \n    let nMod = n % p\n    let nDivP = n % p\n  \
    \  let nDivPAnd2P = n % p + p\n    \n    if nMod == 0 {\n        result = 0\n\
    \    } else if nMod == 1 {\n        result = 1\n    } else if nMod == 2 {\n  \
    \      result = p - 1\n    } else {\n        if nDivP == 0 {\n            if nDivPAnd2P\
    \ == 0 {\n                result = n - p\n            } else {\n             \
    \   result = p - 1\n            }\n        } else {\n            if nDivPAnd2P\
    \ == 0 {\n                result = p - 1\n            } else {\n             \
    \   result = nDivPAnd2P\n            }\n        }\n    }\n    \n    return result",
  "    var result = 1\n    var i = 0\n    if n > p {\n        for _ in 1..<n-p {\n\
    \            result *= p\n        }\n    }\n    if n < p {\n        for _ in 0..<p-n\
    \ {\n            result /= p\n        }\n    }\n    return result", "\tlet nMinusOne\
    \ = n - 1\n\tlet pMinusOne = p - UInt32(nMinusOne)\n\n\tlet one = UInt32(1)\n\t\
    let two = UInt32(2)\n\n\tlet result = Int(nMinusOne)\n\tlet mask = result < p\
    \ ? one : two\n\n\treturn result & mask", "    if n == 0 && p == 0 {\n       \
    \ return 1\n    }\n    if n >= p {\n        return 0\n    }\n    if n < p {\n\
    \        return p - n\n    }\n    var remainder = n % p\n    return p + (n - remainder)",
  "  if n < 0 {\n    return 0\n  }\n  if p == 0 {\n    return 1\n  }\n  if n >= p\
    \ {\n    return p - (p % n)\n  }\n  if p <= 0 {\n    return 0\n  }\n  return p\
    \ + modp(n - p, p)", "    switch {\n    case n % p == 0:\n        return n\n \
    \   case n % p == p:\n        return n % p\n    case n % p == p - 1:\n       \
    \ return p + (n - p - 1) % p\n    default:\n        return n % p\n    }", "  \
    \  if n == 0 || (p == 0 && n == 1) {\n        return n\n    }\n\n    var r = 0\n\
    \    var mask = (1 << p) - 1 // 1<<p - 1 = 1 << p\n    var i = -1\n\n    guard\
    \ n > 0 else {\n        return -1\n    }\n\n    for i = 0; i <= n; i++ {\n   \
    \     r += i & mask\n        mask = (mask >> 1) // mask = (mask << 1)\n    }\n\
    \n    return r", "  var result = 1\n  while n > 0 {\n    if n % p == 0 {\n   \
    \   break\n    }\n    n /= p\n    result++\n  }\n  return result", '    return
    ((n % p) + p) % p', "    if n >= p {\n        return n - p\n    }\n    if n <\
    \ p {\n        return p + (p - n)\n    }\n    return 0", "  if n >= p { return\
    \ n - p }\n  else { return n % p }", '  return (n % (p - 1)) + 1', "    switch\
    \ {\n    case n < 0:\n        n += p\n    case n >= p:\n        n -= p\n    }\n\
    \    return n & (p - 1)", "    if n < 0 {\n        n = -n\n    }\n    if p < 0\
    \ {\n        p = -p\n    }\n    if p > p {\n        p = p\n    }\n    if n ==\
    \ 0 {\n        return 1\n    }\n    if n == 1 {\n        return n\n    }\n   \
    \ if p < 2 {\n        return n\n    }\n    var ret = 1\n    var p2: Int\n    for\
    \ p2 = p; p2 > 1; p2 = p2 * 2 {\n        if n % p2 == 0 {\n            ret = ret\
    \ * (n - p2)\n        }\n    }\n    return ret", "\tswitch {\n\tcase n < 0:\n\t\
    \tif p % 2 != 0 {\n\t\t\tn += p\n\t\t}\n\t\telse if p == 0 {\n\t\t\tn = 0\n\t\t\
    }\n\t\telse {\n\t\t\tn = 1\n\t\t}\n\tcase n > p:\n\t\tn = n - p\n\tcase p == 0:\n\
    \t\tn = n\n\tdefault:\n\t\tn = (n - p) % p\n\t}\n\treturn n", "\tif n >= p {\n\
    \t\treturn 0\n\t}\n\tconst q = p / 2\n\tvar result = 1\n\tvar k = 1\n\twhile n\
    \ > 0 {\n\t\tif n & 1 {\n\t\t\tresult *= q\n\t\t\tresult %= p\n\t\t}\n\t\tif k\
    \ <= n {\n\t\t\tk *= q\n\t\t\tk %= p\n\t\t}\n\t\tn >>= 1\n\t\tk *= q\n\t\tk %=\
    \ p\n\t}\n\treturn result", "    // TODO: check that 0 <= n <= p\n\n    return\
    \ n & (p - 1)", '    return n & (p-1) * (p-1)', "    if n == 0 {\n        return\
    \ 1\n    }\n    if n == p {\n        return n\n    }\n    return n % p", "\tif\
    \ n == 0 {\n\t\treturn 1\n\t}\n\n\t// Optimization: If n is even, then n%p can\
    \ never be even, since\n\t// p could be either even or odd.\n\tif n&1 == 0 {\n\
    \t\tn /= p\n\t}\n\n\treturn n % p", '  return n % p', '  return powmod(n, p -
    1, p) == 0 ? 0 : powmod(n, p - 1, p - 1)', '    return n % p', "    n %= p\n \
    \   if n == 0 {\n        return n\n    }\n    var low = n / p\n    var high =\
    \ n % p\n    return low + (high * p)", "    if n == 0 || p == 0 {\n        return\
    \ 0\n    }\n    if p == 1 {\n        return n\n    }\n    if p < 2 {\n       \
    \ return modp(p * 2, p)\n    }\n    if p < 4 {\n        if n % p == 0 {\n    \
    \        return p\n        }\n        return modp(p * 2, p)\n    }\n    if p <\
    \ 9 {\n        if n % p == 0 {\n            return p\n        }\n        if n\
    \ % p == 1 {\n            return p + 1\n        }\n        return modp(p * 2,\
    \ p)\n    }\n    if p < 18 {\n        if n % p == 1 {\n            return p +\
    \ 1\n        }\n        if n % p == 2 {\n            return p + 2\n        }\n\
    \        if n % p == 3 {\n            return p + 3\n        }\n        if n %\
    \ p == 4 {\n            return p + 4\n        }\n        if n % p == 5 {\n   \
    \         return p + 5\n        }\n        if n % p == 6 {\n            return\
    \ p + 6\n        }\n        if n % p == 7 {\n            return p + 7\n      \
    \  }\n        if n % p == 8 {\n            return p + 8\n        }\n        if\
    \ n % p == 9 {\n            return p + 9\n        }\n        if n % p == 10 {\n\
    \            return p + 10\n        }\n        if n % p == 11 {\n            return\
    \ p + 11\n        }\n        if n % p == 12 {\n            return p + 12\n   \
    \     }\n        if n % p == 13 {\n            return p + 13\n        }\n    \
    \    if n % p == 14 {\n            return p + 14\n        }\n        if n % p\
    \ == 15 {\n            return p + 15\n        }\n        return modp(p * 2, p)\n\
    \    }\n    if p < 99 {\n        if n % p == 2 {\n            return p + 2\n \
    \       }\n        if n % p == 3 {\n            return p + 3\n        }\n    \
    \    if n % p == 4 {\n            return p + 4\n        }\n        if n % p ==\
    \ 5 {\n            return p + 5\n        }\n        if n % p == 6 {\n        \
    \    return p + 6\n        }\n        if n % p == 7 {\n            return p +\
    \ 7\n        }\n        if n % p == 8 {\n            return p + 8\n        }\n\
    \        if n % p == 9 {\n            return p + 9\n        }\n        if n %\
    \ p == 10 {\n            return p + 10\n        }\n        if n % p == 11 {\n\
    \            return p + 11\n        }\n        if n % p == 12 {\n            return\
    \ p + 12\n        }\n        if n % p == 13 {\n            return p + 13\n   \
    \     }\n        if n % p == 14 {\n            return p + 14\n        }\n    \
    \    if n % p == 15 {\n            return p + 15\n        }\n        if n % p\
    \ == 16 {\n", "\tvar n1, m1, n2, m2 int\n\tn1 = int64(n)\n\tm1 = int64(p)\n\t\
    n2 = int64(n1)\n\tm2 = int64(m1)\n\t// If n1 and m1 are both even then n2 = m1\
    \ + 1 because n1 and m1 are even.\n\tif n1%2 == 0 && m1%2 == 0 {\n\t\tn2 = m1\
    \ + 1\n\t}\n\treturn n2 % m1", "\tswitch {\n\tcase n < 0:\n\t\tif p < 0 {\n\t\t\
    \treturn 0\n\t\t}\n\t\treturn p + modp(abs(n), -p)\n\tcase n <= p:\n\t\treturn\
    \ n\n\tcase n == p:\n\t\treturn 1\n\tcase n == p - 1:\n\t\treturn modp(n, p-2)\n\
    \tdefault:\n\t\treturn modp(n, p - 1)\n\t}", "    switch {\n    case n > p:\n\
    \        return n - p + p + 1\n    case n < p:\n        return p + p - n - 1\n\
    \    default:\n        return n\n    }", "\tlet m = p % n\n\tif m < 0 {\n\t\t\
    m = (n - m) % n\n\t}\n\treturn m", "  // https://en.wikipedia.org/wiki/Modulo_operation\n\
    \  precondition(n, LessThanOrEqual.self)\n  precondition(p, LessThanOrEqual.self)\n\
    \  var rem = 0\n  repeat: while true {\n    if n == 0 || p == 0 {\n      return\
    \ rem\n    }\n    var q = n\n    n = p % q\n    rem = q\n    p = n\n  }", "  \
    \  var result = 1\n    result ^= p + (n & p - n)\n    if result < n {\n      \
    \  result = result + p\n    }\n    return result", '    return n - p.powModInt(Int(n),
    Int(p))', "    func mod(i: Int, r: Int) -> Int {\n        return i % r\n    }\n\
    \    return n & (p-1)", "    n %= p\n    if n < 0 {\n        n += p\n    }\n \
    \   return n", "\tswitch {\n\tcase n < 0:\n\t\treturn n - 1\n\tcase n == 0:\n\t\
    \treturn 1\n\tcase p == 0:\n\t\treturn 0\n\tcase p < 0:\n\t\treturn modp(abs(n),\
    \ abs(p))\n\t}\n\n\tlet q = (p - 1) >> 31\n\tlet r = p << 31\n\tlet s = n - 1\n\
    \treturn modpow2(s, q, r)", "  var res = 1\n  for i = 0; i < p; i++ {\n    res\
    \ *= n\n  }\n  return Int(res)", "    assert(n >= 0, \"n must be non-negative\"\
    )\n    assert(p >= 1, \"p must be positive\")\n    if n == 0 {\n        return\
    \ 1\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 1 {\n      \
    \  return n\n    }\n    if n >= p {\n        return p + (n - p) * (p - 1) / n\n\
    \    }\n    // n == p or a == p or b == p\n    return p + (n - p) * (p - 1) *\
    \ (p - 2) / n", '    return (n+p-1)%p', "    if n > p { return n }\n    p %= n\n\
    \    return n + (p << 1)", "\tif n < p && p % 2 == 1 {\n\t\treturn n\n\t}\n\t\
    d := new(big.Int).SetInt64(1)\n\tfor i := 0; i < p; i++ {\n\t\td.Mul(d, n)\n\t\
    }\n\treturn d.Int64()", "    if n >= p {\n        return n - p;\n    } else {\n\
    \        return n - p + p;\n    }", "\tif n < 0 {\n\t\tpanic(\"mod: n < 0\")\n\
    \t} else if p < 2 {\n\t\treturn 0\n\t} else if p > n {\n\t\treturn n\n\t}\n\t\
    q, _ := NewModPowInt(n, p % p, p)\n\treturn q", "\tif n == 0 {\n\t\treturn 1\n\
    \t}\n\n\tif n >= p {\n\t\treturn 0\n\t}\n\n\tif n == p {\n\t\treturn 1\n\t}\n\n\
    \tvar acc Int\n\tfor i := 0; i < n; i++ {\n\t\tacc = acc*p + (1<<uint(i))\n\t\
    }\n\n\treturn acc", "    if p < 1 {\n        guard n > 0 else { return 1 }\n \
    \       return 0\n    }\n    var result = p % n\n    if result < 0 {\n       \
    \ result = result + n\n    }\n    return result", '    return n.wrap(p).wrap(p).wrap(p)',
  "    if n == 0 {\n        return 1\n    }\n    return n & (p - 1)", "    if n >=\
    \ p || n < 0 {\n        return -1\n    }\n    return n % p", "\tswitch n {\n\t\
    case 0:\n\t\treturn 1\n\tcase 3:\n\t\treturn mod3p(n, p)\n\tcase 1101:\n\t\treturn\
    \ mod101p(n, p)\n\t}\n\treturn mod100p(n, p)", "    if n == 0 {\n        return\
    \ 1\n    }\n    if p == 0 {\n        return 1\n    }\n    if p <= 1 {\n      \
    \  return 0\n    }\n    if n == 1 {\n        return p\n    }\n    if n >= p {\n\
    \        return p\n    }\n    if n >= p {\n        return modp(n - p, p)\n   \
    \ }\n    if n <= p {\n        return modp(n - p, p)\n    }\n    return modp(p,\
    \ n)", "\tswitch {\n\tcase n < 0:\n\t\tswitch {\n\t\tcase p < 0:\n\t\t\tpanic(\"\
    modp mod negative modulus (mod %d)\")\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\t\
    case n == 0:\n\t\treturn 1\n\tdefault:\n\t\treturn p % n\n\t}", "    n %= p\n\
    \    if n < 0 {\n        n += p\n    }\n    return n", "\tif n > p || n < 0 {\n\
    \t\tpanic(\"modp: invalid input\")\n\t}\n\tvar result UInt64\n\tfor n > 0 {\n\t\
    \tif n > p {\n\t\t\tresult += UInt64(p - 1)\n\t\t}\n\t\tn >>= 1\n\t\tif n == 0\
    \ {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn result", "    var res = 1\n    if n ==\
    \ 0 { return 1 }\n    if n == p { return 0 }\n    for i in 0..<n {\n        res\
    \ *= p\n        res %= p\n    }\n    return res", "  var result = 1\n  for _ in\
    \ 0..<n {\n    result = result * p\n  }\n  return result % p", "    switch n {\n\
    \    case 0: return 1\n    case 1: return 0\n    default:\n        let p = p %\
    \ n\n        if p < 0 {\n            p = p + n\n        }\n        return p\n\
    \    }", '    return n%p', "\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn p -\
    \ n", "    // TODO: switch to BigUint if performance is critical\n    if n >=\
    \ p {\n        return n\n    }\n    if p >= n {\n        return 0\n    }\n   \
    \ var result = n % p\n    if result > 0 {\n        result = (n - result) % p\n\
    \    } else {\n        result = ((n - result) + p) % p\n    }\n    return result",
  "\treturn (n & (p - 1)) - (n & p)", '    return n & (p - 1)', "\tif n == 0 || (n\
    \ == 1 && p == 1) || p == 1 {\n\t\treturn 0\n\t}\n\tn %= p\n\treturn n", '    return
    n & (p - 1)', "\tif n < p {\n\t\tif n < 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn\
    \ n\n\t}\n\tif p < n {\n\t\tif p < 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn p\n\t\
    }\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t}\n\tif n >= p {\n\t\tn -= p\n\t\t\
    return n\n\t}\n\treturn n", "    if n < p { panic(\"modp: n must be bigger than\
    \ p\") }\n    var result = n & (p - 1)\n    if n > p { result += (p - n) % p }\n\
    \    return result", "\tif n == 0 || p == 0 {\n\t\treturn 1\n\t}\n\tconst q =\
    \ p / n\n\tconst r = p % n\n\tif q == r {\n\t\treturn q\n\t}\n\tif r > 0 {\n\t\
    \treturn modp(n, n)\n\t}\n\treturn modp(q, p)", "    let a = pow(m, Int(n), p)\n\
    \    let b = pow(m, Int(n), p)\n    let result = a - b\n    if result > p { result\
    \ = result - p }\n    return result", "\tif n < 0 {\n\t\tlet modp = modp(Abs(n),\
    \ p)\n\t\tif modp == 1 {\n\t\t\treturn 0\n\t\t}\n\t\treturn modp\n\t}\n\n\tlet\
    \ m = Mod(n, p)\n\tif m == 0 {\n\t\treturn 1\n\t}\n\n\treturn m", "  // Special\
    \ case when n = 0\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return\
    \ 0\n  }\n\n  // Compute result = ((n-1)/p) % p\n  // We want to compute:\n  //\n\
    \  //     result = (result * p + 1) %p\n  //\n  // We want to make sure that the\
    \ modulo remainder is 0 when the\n  // result is larger than p. This means that\
    \ we have to\n  // shift our result one bit to the right, and correct the value\n\
    \  // to be zero if the result was smaller than p.\n  // If result > p, result\
    \ - p will be negative.\n  //\n  // Example 1:\n  //\n  // Let n = 6 and p = 7.\n\
    \  // The expression ((6-1)/7) % 7 yields 4, and the expression 4 % 7 yields\n\
    \  // 4. The value of (6-1)/7 is -4, and the value of 4 is 4.\n  //\n  // Example\
    \ 2:\n  //\n  // Let n = 10 and p = 5\n  // The expression ((10-1)/5) % 5 yields\
    \ 0, and the expression 0 % 5 yields\n  // 0. The value of (10-1)/5 is -2, and\
    \ the value of -2 is 0.\n  let result = ((n - 1) / (p - 1)) % p\n\n  // Make sure\
    \ we get a valid result, i.e. the modulo remainder is 0 when\n  // the result\
    \ is larger than p\n  if result > p {\n    return result - p\n  }\n  return result",
  "    switch {\n    case n < 0:\n        return (p - 1) & ^(n + 1)\n    case n >=\
    \ p:\n        return 0\n    case n == 0 && p > 0:\n        return 1\n    case\
    \ n == p && p > 1:\n        return n\n    }\n\n    // n == p && p >= 2\n    //\
    \ n == p && p >= 3\n    // n >= 0 && n > p\n    // n >= 0 && n < p\n    // n <\
    \ 0 && n < p\n    // n < 0 && n > p\n    // n < 0 && n == p\n    switch {\n  \
    \  case n < p && n >= p:\n        return n - p\n    case n > p && n >= p:\n  \
    \      return n + p\n    case n < p && n < p:\n        return n + p\n    case\
    \ n > p && n < p:\n        return n - p\n    }", "    // We only support integers\
    \ as input.\n    if n != Int(n) || p != Int(p) {\n        throw NumericError(\"\
    modp(): arguments must be integers\")\n    }\n\n    // Return n modulo p, or 0\
    \ when both n and p are 0.\n    if n == 0 && p == 0 {\n        return 0\n    }\n\
    \    if n <= p && n % p == 0 {\n        return n\n    }\n\n    // Find p1 such\
    \ that n and p are coprime. p1 must be odd.\n    var p1 = p - 1\n    if p1 % 2\
    \ == 1 {\n        p1 -= 1\n    }\n\n    // Choose m such that p1 < m*p < n and\
    \ m is coprime.\n    var m = Int(n)\n    var i = 1\n    while p*i < n && p*m >\
    \ n {\n        i += 1\n        m *= Int(p)\n    }\n\n    // Return n modulo m\
    \ when m*p is small enough.\n    return n - (m*p)", "\tif n == 0 {\n\t\treturn\
    \ 1\n\t} else if p == 0 {\n\t\treturn 0\n\t}\n\tswitch {\n\tcase n < 0:\n\t\t\
    switch {\n\t\tcase n >= p:\n\t\t\treturn n - p\n\t\tdefault:\n\t\t\treturn n -\
    \ 1\n\t\t}\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn 1 + modp(n -\
    \ 1, p) / p\n\t}", "    if n == 0 || p == 0 {\n        return 1\n    }\n    return\
    \ n % p", "\tassert(n >= 0 && p >= 0 && n > p)\n\tassert(p > 0)\n\t\n\treturn\
    \ (n - p) % (p + 1)", "\tif n < 0 {\n\t\tpanic(\"mod: negative modulus\")\n\t\
    }\n\n\tif n < p {\n\t\treturn powmod(n, p, p)\n\t}\n\n\trem := n % p\n\tn /= p\n\
    \n\tmod := powmod(n, p, p)\n\tif rem > 0 {\n\t\tmod = -mod\n\t}\n\n\treturn mod\
    \ * p + rem", "  switch {\n  case n == 0 where p != 1: return 0\n  case n >= p\
    \ where n % p == 0: return n\n  default: return (n + (p - 1)) % p\n  }", "\tswitch\
    \ {\n\tcase n > p || n <= 0: return 0\n\tcase n == 0: return 1\n\tcase n == 1:\
    \ return p\n\tcase n <= 9: return p + (n % p)\n\tcase n <= 18: return p + (n %\
    \ p) + ((p * p + (n % p)) % (p ^ p))\n\tcase n <= 27: return p + (n % p) + ((p\
    \ * p + (n % p) + (p ^ p)) % (p * p + (p ^ p)))\n\tcase n <= 36: return p + (n\
    \ % p) + ((p * p + (n % p) + (p * p + p)) % (p * p + p)) + ((p * p + (n % p))\
    \ % (p * p + (p ^ p)))\n\tcase n <= 45: return p + (n % p) + ((p * p + (n % p)\
    \ + (p * p + p) + (p ^ p)) % (p * p + p)) + ((p * p + (n % p) + (p * p + p)) %\
    \ (p * p + (p ^ p)))\n\tcase n <= 54: return p + (n % p) + ((p * p + (n % p) +\
    \ (p * p + p) + (p * p + p)) % (p * p + p)) + ((p * p + (n % p) + (p * p + p)\
    \ + (p * p + p)) % (p * p + (p ^ p)))\n\t}\n\treturn 0", "\tlet mask = n - p\n\
    \tlet mask2 = mask * mask\n\tlet mask3 = (mask2 >> 1) + 1\n\treturn mask & mask3",
  "    var q = p - 1\n    for ; n >= q; n-- {\n        q %= p\n    }\n    return n",
  "\tn %= p\n\tif n < 0 {\n\t\treturn ((p - 1) &+ n) % (p)\n\t}\n\treturn n", "\t\
    if n >= p {\n\t\tif n == 0 {\n\t\t\treturn 1\n\t\t}\n\t\treturn n % p\n\t}\n\n\
    \tlet k = p - n\n\treturn n % p", "    // Avoid overflow by limiting n's magnitude\
    \ to MIN_P and MAX_P respectively.\n    n = clamp(n, 0, p + 1)\n    let r = n\
    \ % p\n    if r == 0 || r == p {\n        return n\n    }\n    return p - r",
  "\treturn n - p.power(n).signum()", "    var res = 0\n    var m = 1\n    var i =\
    \ 0\n    for n > 0 {\n        if m % 2 == 1 {\n            res += (n % 2) * m\
    \ / p\n        }\n        m *= p\n        n /= p\n        i += 1\n    }\n    return\
    \ res", "    switch {\n    case n < 0 {\n        return modp(negate(n), p)\n \
    \   } else if n < p {\n        return n\n    }\n    return p % n", "    assert(n\
    \ >= 0, \"modulo in negative numbers\")\n    assert(p >= 1, \"modulo in prime\
    \ numbers\")\n    \n    if p*n > n {\n        return modp(n-p*p, p)\n    }\n \
    \   \n    n -= p - 1\n    \n    if n == 0 {\n        return 1\n    }\n    \n \
    \   // calculate first n-1 digits\n    var firstDigits: Int = n % p\n    var remainder\
    \ = n / p\n    \n    // calculate digits for next iteration, until we run out\
    \ of digits\n    var digits = p\n    for remaining := 0; digits < firstDigits;\
    \ digits++ {\n        if remainder == 0 {\n            return 0\n        }\n \
    \       remainder--\n    }\n    \n    // calculate last digit\n    var lastDigit:\
    \ Int\n    if remainder == 0 {\n        lastDigit = 1\n    } else {\n        lastDigit\
    \ = remainder % p\n        remainder = remainder / p\n    }\n    \n    var result\
    \ = lastDigit + digits\n    \n    if result > p {\n        return modp(p*result,\
    \ p)\n    }\n    \n    return result", "  let mut s = n\n  let mut r = 0\n  while\
    \ n > 0 {\n    r = r * p % s + 1\n    s = s * p % s\n    n = n / p\n  }\n  return\
    \ r", "    let t = Int((1 << p) * n) >> p\n    return t % p", "    if n < 0 ||\
    \ p < 0 {\n        return 0 // should never happen\n    }\n    if n == 0 {\n \
    \       return 1\n    }\n    if p == 1 {\n        return n\n    }\n    let res\
    \ = n % p\n    if res == 0 || res == p {\n        return res\n    }\n    return\
    \ n - res", "    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n     \
    \   return 0\n    }\n    if n <= p {\n        return n & (p - 1)\n    }\n    if\
    \ p < 2 {\n        return n - p\n    }\n    d := (p - 1) >> 1\n    return (n >>\
    \ d) & p", "    if n == 0 { return 1 }\n    if p == 0 { return 0 }\n    if n ==\
    \ p { return n }\n    if n % p == 0 { return modp(n / p, p) }\n    if p % n ==\
    \ 0 { return modp(n, p) }\n    return modp(n / p, p) * modp(n, p)", "    if n\
    \ == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n\
    \    if n >= p {\n        return n % p\n    } else {\n        return ((n - 1)\
    \ % p + p) % p\n    }", "    if n > p || n < 0 {\n        return n\n    }\n  \
    \  var res = 1\n    if n < p {\n        res = (p % n) + n\n    }\n    if p < n\
    \ {\n        res = (n % p) + p\n    }\n    return res", "\tif n >= p {\n\t\treturn\
    \ n - p\n\t}\n\treturn p - n", "\tswitch {\n\tcase n < p:\n\t\treturn n % p\n\t\
    case n == p:\n\t\treturn 1\n\tcase n > 0:\n\t\treturn modp(n - 1, p) + modp(n,\
    \ p)\n\tdefault:\n\t\treturn modp(n + 1, p)\n\t}", "    if n < 0 {\n        p\
    \ *= -1\n        n *= -1\n    }\n    if n < p {\n        return n\n    }\n   \
    \ if p < n {\n        p *= -1\n    }\n    return p - (n%p)", "\tif n == 0 || p\
    \ == 0 {\n\t\treturn 1\n\t}\n\tif n >= p {\n\t\treturn n - p\n\t}\n\treturn n\
    \ + p - 1", "\tif n == 0 || p == 0 {\n\t\treturn 1\n\t} else if n <= p {\n\t\t\
    return 0\n\t}\n\n\tif p < 2*n {\n\t\treturn n - p\n\t} else {\n\t\tif p < 2*n+1\
    \ {\n\t\t\treturn modp(n - p, p) + p\n\t\t} else {\n\t\t\tmod := 1\n\t\t\tfor\
    \ i := 0; i < n-p && i < p; i++ {\n\t\t\t\tif mod*p > p {\n\t\t\t\t\tbreak\n\t\
    \t\t\t}\n\t\t\t\tmod *= p\n\t\t\t}\n\t\t\tif mod < p {\n\t\t\t\treturn p\n\t\t\
    \t} else {\n\t\t\t\treturn mod\n\t\t\t}\n\t\t}\n\t}", "    let res = n % p\n \
    \   if res == 0 {\n        return res\n    }\n    return p - res", "    var result\
    \ = 1\n    for n > 0 {\n        if n < p {\n            result = result * n\n\
    \        }\n        n >>= 1\n    }\n    return result"]
stop_tokens:
- "\n}"
