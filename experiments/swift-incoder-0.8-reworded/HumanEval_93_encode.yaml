name: HumanEval_93_encode
language: swift
prompt: "\n/// Write a function that takes a message, and encodes in such a \n///\
  \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
  \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
  \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(message:\
  \ \"test\")\n/// \"TGST\"\n/// >>> encode(message: \"This is a message\")\n/// \"\
  tHKS KS C MGSSCGG\"\nfunc encode(message: String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(encode(message: \"TEST\") == \"tgst\")\n\
  assert(encode(message: \"Mudasir\") == \"mWDCSKR\")\nassert(encode(message: \"YES\"\
  ) == \"ygs\")\nassert(encode(message: \"This is a message\") == \"tHKS KS C MGSSCGG\"\
  )\nassert(encode(message: \"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq\
  \ wRkTg\")"
completions: ["    // TODO: fill in the missing code for this function.\n    // If\
    \ the length of the message is not even,\n    // the function should return the\
    \ same message\n    // It should also return the same message if the message is\
    \ empty or if the message is one letter long.\n    return message", "    let count\
    \ = message.characters.count\n    \n    if count > 2 {\n        return \"\"\n\
    \    }\n    \n    var encodedString = \"\"\n    for i in 0..<count {\n       \
    \ if i != 0 && i == count-1 {\n            encodedString += String(message.characters[i-1])\n\
    \        } else {\n            encodedString += String(message.characters[i]).swapcase()\n\
    \        }\n    }\n    \n    for _ in 0..<count {\n        encodedString += String(message.characters[i])\n\
    \    }\n    \n    return encodedString", "    let letters = message.characters\n\
    \    var result = \"\"\n\n    for letter in letters {\n        let index = letters.indexOf(letter)\n\
    \        let replacement = englishAlphabet[index] + englishAlphabet[index+1]\n\
    \        result = result + String(replacement)\n    }\n\n    return result", '  return
    message(message: message).message', "    if message == \"\" {\n        return\
    \ message\n    }\n\n    var result = \"\"\n    var count = [Character: Int]()\n\
    \    for i in 0..<message.characters.count {\n        let current = message.character(i)\n\
    \        if !count.keys.contains(current) {\n            count[current] = 1\n\
    \        } else {\n            count[current] = count[current] + 1\n        }\n\
    \    }\n\n    for i in 0..<count.count {\n        let current: Character = key.character(i)\n\
    \        if i == 0 {\n            result += current\n        } else {\n      \
    \      if count[current] > 1 {\n                result += current\n          \
    \  } else {\n                result += String(current.uppercased())\n        \
    \    }\n        }\n    }\n    return result", "    if let vowels = \"AEIOUaeiouA\"\
    .unicodeScalars {\n        return message.unicodeScalars.map { character -> String\
    \ in\n            if let index = vowels.index(of: character) {\n             \
    \   if index == 0 {\n                    return String(character)\n          \
    \      }\n                if let index = vowels.indices.dropFirst(where: { $0\
    \ == index + 1 }), let currentCharacter = String(vowels[index - 1], radix: 16)\
    \ {\n                    return currentCharacter + String(character)\n       \
    \         }\n            }\n            return String(character)\n        }.reduce(\"\
    \", { result, character in\n            return result + String(Character(character).isUppercase)\
    \ ? character : String(Character(character).isLowercase) ? String(character).lowercased()\
    \ : String(character)\n        })\n    }\n    return \"\"", "    let vowels =\
    \ \"AEIOUaeiou\"\n    var newMessage = \"\"\n    for letter in message {\n   \
    \     if let idx = vowels.index(of: letter) {\n            newMessage += String(letter)\n\
    \            newMessage += String(letters[(idx+2)%26])\n        } else {\n   \
    \         newMessage += String(letter)\n        }\n    }\n    return newMessage",
  "    // This algorithm is designed to replace vowels with their \n    // letters\
    \ in the english alphabet, swapping case. \n    // The swap happens first on the\
    \ second letter of \n    // the vowel. The final swap is performed on the first\
    \ letter \n    // of the second vowel. \n    var swappedMessage = \"\"\n    \n\
    \    var englishAlphabet = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"\
    I\",\"J\",\n                           \"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"\
    Q\",\"R\",\"S\",\"T\",\n                           \"U\",\"V\",\"W\",\"X\",\"\
    Y\",\"Z\"]\n    \n    var vowels = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n   \
    \ \n    var vowelsCount = vowels.count\n    var englishAlphabetCount = englishAlphabet.count\n\
    \    \n    for i in 0..<(englishAlphabet.count) {\n        let firstLetter = englishAlphabet[i]\n\
    \        \n        // Find the first vowel after the current letter\n        for\
    \ j in 0..<(vowels.count) {\n            let secondLetter = vowels[j]\n      \
    \      \n            // If the letter is not a vowel, continue to the next\n \
    \           if (firstLetter == secondLetter) {\n                continue\n   \
    \         }\n            \n            // If the letter is one of the vowels,\
    \ swap the case\n            if (firstLetter == secondLetter) {\n            \
    \    let firstChar = firstLetter\n                let secondChar = secondLetter\n\
    \                \n                // Swap the case for both characters\n    \
    \            firstChar = firstChar.uppercaseString\n                secondChar\
    \ = secondChar.uppercaseString\n                \n                let firstLetterIndex\
    \ = englishAlphabet.index(of: firstChar)!\n                let secondLetterIndex\
    \ = englishAlphabet.index(of: secondChar)!\n                \n               \
    \ let firstCharIndex = englishAlphabet.index(of: firstChar)!\n               \
    \ let secondCharIndex = englishAlphabet.index(of: secondChar)!\n             \
    \   \n                swappedMessage += englishAlphabet[firstLetterIndex] + \n\
    \                                 englishAlphabet[secondLetterIndex] + \n    \
    \                             englishAlphabet[firstCharIndex] + \n           \
    \                      englishAlphabet[secondCharIndex] + \n                 \
    \                englishAlphabet[firstLetterIndex] + \n                      \
    \           englishAlphabet[secondLetterIndex] + \n                          \
    \       \" \" \n            }\n        }\n    }\n    \n    swappedMessage = swappedMessage.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    \n    return swappedMessage", "    var alphabet = \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".characters()\n    var vowels\
    \ = \"AEIOU\".characters()\n    for char in message {\n        if vowels.contains(char)\
    \ {\n            var index = 0\n            while index < vowels.count {\n   \
    \             if let index = alphabet.index(of: vowels[index], options: []) {\n\
    \                    alphabet[index] = char\n                }\n             \
    \   index += 1\n            }\n        } else {\n            var index = 0\n \
    \           while index < alphabet.count {\n                if let index = alphabet.index(of:\
    \ char) {\n                    alphabet[index] = vowels[index]\n             \
    \   }\n                index += 1\n            }\n        }\n    }\n    return\
    \ String(alphabet)", "    var result = \"\"\n\n    for letter in message {\n \
    \       if letter <= 'z' {\n            result += \"A\" + String(letter).lowercased()\n\
    \        } else {\n            result += String(letter).lowercased()\n       \
    \ }\n    }\n\n    for vowel in \"aeiou\" {\n        let index = result.index(of:\
    \ vowel)\n        let start = result.index(before: index)\n        let end = result.index(before:\
    \ start, offsetBy: 2)\n\n        result.remove(at: start)\n        result.remove(at:\
    \ end)\n        result.remove(at: index)\n    }\n\n    return result", "    var\
    \ result = \"\"\n    var index = 0\n    for char in message {\n        let index2\
    \ = getIndex(char, index) \n        result += getLetter(char, index2)\n      \
    \  index = index2\n    }\n    return result", "    var result = \"\"\n    for\
    \ letter in message.characters.reverse() {\n        guard let firstLetter = letter.unicodeScalars.first\
    \ else { continue }\n        let vowels = firstLetter.value == \"A\" || firstLetter.value\
    \ == \"E\" || firstLetter.value == \"I\" || firstLetter.value == \"O\" || firstLetter.value\
    \ == \"U\"\n        let currentIndex = letter.unicodeScalars.count - 1\n     \
    \   var nextLetter = letter\n        \n        // Swap case for all letters in\
    \ the message\n        while currentIndex >= 0 && vowels {\n            nextLetter\
    \ = UnicodeScalar(letter.unicodeScalars[currentIndex].value - \"a\".unicodeScalars.first!.value)\n\
    \            currentIndex -= 1\n        }\n        \n        // Replace all vowels\
    \ in the message with the letter that appears 2 places ahead of that vowel\n \
    \       if vowels {\n            result += nextLetter\n        } else {\n    \
    \        result += letter.unicodeScalars.first!.value\n        }\n    }\n    return\
    \ result", "    var encodedMessage = \"\"\n    for char in message {\n       \
    \ if let currentChar = char.unicodeScalars.first?.value {\n            if currentChar\
    \ >= 0x61 &&\n                currentChar <= 0x7A {\n                encodedMessage\
    \ += \"A\"\n            } else {\n                let index = (currentChar - 0x61)\
    \ / 2\n                if index != 0 {\n                    encodedMessage +=\
    \ String(UniChar(UnicodeScalar(UInt8(index + 0x61))))\n                }\n   \
    \         }\n        } else {\n            encodedMessage += char\n        }\n\
    \    }\n    return encodedMessage", "    var output = \"?\"\n    for (index, letter)\
    \ in message.characters.enumerated() {\n        var vowels = \"AEIOUaeiou\"\n\
    \        let index = letters.index(letter, options: .forceLiteralSearch)!\n  \
    \      let nextLetter = letters[(index + 1) % letters.count]\n        output +=\
    \ \"\\(letters.prefix(index: index) + nextLetter + letters.suffix(index: index))\"\
    \n    }\n    return output", "    return message.map { letterInMessage -> String\
    \ in\n        switch letterInMessage {\n        case \"A\": return \"G\"\n   \
    \     case \"E\": return \"I\"\n        case \"I\": return \"U\"\n        case\
    \ \"O\": return \"A\"\n        case \"U\": return \"I\"\n        case \"a\": return\
    \ \"g\"\n        case \"e\": return \"i\"\n        case \"i\": return \"u\"\n\
    \        case \"o\": return \"a\"\n        case \"u\": return \"i\"\n        case\
    \ \"z\": return \"a\"\n        default:\n            return letterInMessage\n\
    \        }\n    }.joined()", "    var output = \"\"\n    for char in message {\n\
    \        var upperChar = char.uppercased()\n        var lower = char.lowercased()\n\
    \        var vowel = \"AEIOUaeiou\".characters()\n        for vowelIndex in 0..<vowel.count{\n\
    \            var vowelIndex = vowel.index(of: vowel[vowelIndex], in: lower)\n\
    \            if vowelIndex != nil {\n                var index = vowelIndex! +\
    \ 2\n                if index > lower.count {\n                    index = lower.count\n\
    \                }\n                output += upperChar[index..<lower.count]\n\
    \                upperChar = lower[index..<lower.count]\n                lower\
    \ = lower[index..<lower.count]\n            }\n        }\n        output = output\
    \ + upperChar + lower\n    }\n    return output", "\tlet alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\tvar result = \"\"\n\tfor ch in message.unicodeScalars {\n\t\tif let index\
    \ = alphabet.unicodeScalars.index(of: ch.value) {\n\t\t\tlet index = alphabet.unicodeScalars.index(of:\
    \ ch.value, offsetBy: 2)\n\t\t\tresult += alphabet[index!]\n\t\t} else {\n\t\t\
    \tresult += String(ch.value)\n\t\t}\n\t}\n\treturn result", "    var encodedMessage\
    \ = \"\"\n\n    for letter in message.characters {\n        if letter.isUppercase\
    \ {\n            encodedMessage += letter\n        } else {\n            switch\
    \ letter {\n            case \"a\", \"e\", \"i\", \"o\", \"u\":\n            \
    \    encodedMessage += letter\n            case \"A\", \"E\", \"I\", \"O\", \"\
    U\":\n                encodedMessage += letter\n            default:\n       \
    \         let index = Int(letter) - Int(\"a\")\n                encodedMessage\
    \ += String(message.substringWithRange(NSMakeRange(index, 1)))\n            }\n\
    \        }\n    }\n    return encodedMessage", "    let result = \"\"\n    let\
    \ vowels = vowels.characters\n\n    for char in message {\n        if let index\
    \ = vowels.index(of: char) {\n            let vowel = vowels[index]\n        \
    \    let index2 = vowels.index(of: vowel, offsetBy: 1)\n            if index2\
    \ != nil {\n                result += vowels[index!] + char\n            } else\
    \ {\n                result += vowel\n            }\n        } else {\n      \
    \      result += char\n        }\n    }\n\n    return result", "    \n    var\
    \ result = \"\"\n    for char in message {\n        \n        let letter = UnicodeScalar(char)\n\
    \        \n        // Swaps case for all letters.\n        // Replace all vowels\
    \ in message with 2 letters ahead\n        if letter.value > 64 && letter.value\
    \ < 91 {\n            \n            result += String(UnicodeScalar(letter.value\
    \ - 64))\n            result += String(UnicodeScalar(letter.value + 2))\n    \
    \    }\n        \n        // Replace all vowels in message with 1 letter ahead\n\
    \        /*\n        if letter.value > 64 && letter.value < 91 {\n           \
    \ \n            result += String(UnicodeScalar(letter.value))\n            result\
    \ += String(UnicodeScalar(letter.value + 1))\n        }\n        */\n    }\n \
    \   return result", "    guard let vowels = \"aeiouAEIOU\".characters.map{ String($0)\
    \ }.sorted \n        else { return message }\n    let messageAsArray = message.characters\n\
    \    let vowelsAsArray = vowels.characters\n    let vowelIndexLookup = Array(vowelsAsArray).enumerated().map\
    \ { index, element in\n        let index = index\n        let vowel = element\n\
    \        return (index, vowel)\n    }\n    let messageWithVowels = messageAsArray.reduce(\"\
    \") {\n        (acc, nextCharacter, index, vowels) in\n        if let index =\
    \ vowelIndexLookup[(index + 1)] where index < vowels.count {\n            return\
    \ acc + String(vowels[index])\n        } else {\n            return acc + nextCharacter\n\
    \        }\n    }\n    var result = ''\n    for char in messageWithVowels {\n\
    \        result = result + String(vowels.sorted().firstIndex(of: char))\n    }\n\
    \    return String(result)", "    return message.characters\n        .reduce(\"\
    \") { acc, character -> String in\n            let (currentVowelCount, currentVowel)\
    \ = character.isVowel()\n            switch currentVowelCount {\n            case\
    \ 0: return acc + character\n            case 1: return acc + currentVowel + character\n\
    \            default:\n                if character.isLetter() && ((acc.index(of:\
    \ character) != acc.endIndex) && currentVowelCount == 1) {\n                 \
    \   return acc + currentVowel + character\n                } else {\n        \
    \            return acc\n                }\n            }\n        }", "    var\
    \ result = \"\"\n    for i in 0..<message.characters.count {\n        let letter\
    \ = message.characters[i]\n        if let vowel = vowelsMap[letter] {\n      \
    \      result += vowel\n        } else {\n            result += letter\n     \
    \   }\n    }\n    return result", "    var result = \"\"\n    for letter in message\
    \ {\n        var newLetter = letter\n        var vowelIndex = 2\n        if letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" {\n            vowelIndex = 1\n\
    \        }\n        newLetter = SwiftVowels[letter][vowelIndex]\n        for vowel\
    \ in SwiftVowels[letter] {\n            result += newLetter\n            vowelIndex++\n\
    \        }\n    }\n    return result", "    var encodedMessage = [String]()\n\
    \    \n    // Build a dictionary to map the english letters to the 2 letter\n\
    \    // ones ahead of them. \n    var pairs: [String: String] = [:]\n    \n  \
    \  // Iterate over the entire message and swap case\n    for i in 0..<message.count\
    \ {\n        \n        let index = Int(i) % message.count\n        \n        let\
    \ character = message[index]\n        \n        // Get the 2 letters ahead of\
    \ 'character'\n        let pair = pairs[character]\n        \n        // The letter\
    \ appears 2 places ahead, swap with the letter\n        // appearing 2 places\
    \ ago.\n        if pair != nil {\n            encodedMessage.append(pair!)\n \
    \       } else {\n            encodedMessage.append(character)\n        }\n  \
    \      \n        pairs[character] = message[index + 1:]\n    }\n    \n    return\
    \ encodedMessage.joinWithSeparator(\"\")", "    let vowels = \"aeiouAEIOU\"\n\
    \    var resultString = \"\"\n    \n    for i in 0..<message.characters.count\
    \ {\n        let letter = message.substring(with: NSRange(location: i, length:\
    \ 1))\n        let letterIndex = letter.characters.firstIndex(of: vowels)\n  \
    \      if letterIndex == nil {\n            resultString += letter\n        }\
    \ else {\n            let replacement = letter.substring(to: letterIndex!)\n \
    \           resultString += letter.substring(from: letterIndex!.advanced(by: 1))\n\
    \            resultString += replacement\n        }\n    }\n    return resultString",
  "    var encodedMessage = \"\"\n    for c in message {\n        if letters[c.asciiValue]\
    \ != nil {\n            if let nextLetter = letters[c.asciiValue]!.unicodeScalars.first\
    \ {\n                let replacement = Character(nextLetter)\n               \
    \ encodedMessage += replacement\n            }\n        } else {\n           \
    \ encodedMessage += c\n        }\n    }\n    return encodedMessage", "\tvar result\
    \ = \"\"\n\tfor ch in message {\n\t\tch = replaceLetters(ch)\n\t\tswitch ch {\n\
    \t\tcase \"a\":\n\t\t\tresult += \"A\"\n\t\tcase \"b\":\n\t\t\tresult += \"B\"\
    \n\t\tcase \"c\":\n\t\t\tresult += \"C\"\n\t\tcase \"d\":\n\t\t\tresult += \"\
    D\"\n\t\tcase \"e\":\n\t\t\tresult += \"E\"\n\t\tcase \"f\":\n\t\t\tresult +=\
    \ \"F\"\n\t\tcase \"g\":\n\t\t\tresult += \"G\"\n\t\tcase \"h\":\n\t\t\tresult\
    \ += \"H\"\n\t\tcase \"i\":\n\t\t\tresult += \"I\"\n\t\tcase \"j\":\n\t\t\tresult\
    \ += \"J\"\n\t\tcase \"k\":\n\t\t\tresult += \"K\"\n\t\tcase \"l\":\n\t\t\tresult\
    \ += \"L\"\n\t\tcase \"m\":\n\t\t\tresult += \"M\"\n\t\tcase \"n\":\n\t\t\tresult\
    \ += \"N\"\n\t\tcase \"o\":\n\t\t\tresult += \"O\"\n\t\tcase \"p\":\n\t\t\tresult\
    \ += \"P\"\n\t\tcase \"q\":\n\t\t\tresult += \"Q\"\n\t\tcase \"r\":\n\t\t\tresult\
    \ += \"R\"\n\t\tcase \"s\":\n\t\t\tresult += \"S\"\n\t\tcase \"t\":\n\t\t\tresult\
    \ += \"T\"\n\t\tcase \"u\":\n\t\t\tresult += \"U\"\n\t\tcase \"v\":\n\t\t\tresult\
    \ += \"V\"\n\t\tcase \"w\":\n\t\t\tresult += \"W\"\n\t\tcase \"x\":\n\t\t\tresult\
    \ += \"X\"\n\t\tcase \"y\":\n\t\t\tresult += \"Y\"\n\t\tcase \"z\":\n\t\t\tresult\
    \ += \"Z\"\n\t\t}\n\t}\n\treturn result", "\tletters := Array(message).map{ String($0)\
    \ }\n\tvowels := [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tresult := \"\"\n\tfor\
    \ _, letter := range letters {\n\t\tresult += letter\n\t\tfor _, vowel := range\
    \ vowels {\n\t\t\tn := vowels.index(vowel)\n\t\t\tif n > 0 {\n\t\t\t\tresult +=\
    \ vowels[(n-1)%len(vowels)]\n\t\t\t}\n\t\t}\n\t\tresult += \" \"\n\t}\n\treturn\
    \ result", "    // TODO: Replace this implementation with the solution to the\
    \ \n    // previous question that uses the improved String/character\n    // solution.\
    \ \n    let vowels = \"aeiouAEIOU\"\n    let messageLength = message.characters.count\n\
    \    \n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".characters\n    \n  \
    \  var output = [String]()\n    var index = 0\n    \n    // For each letter in\
    \ the message\n    for letter in message.characters {\n        // Replace the\
    \ vowels\n        let vowelIndex = alphabet.index(of: letter)\n        if let\
    \ vowelIndex = vowelIndex {\n            letter = alphabet[vowelIndex + 2]\n \
    \       }\n        \n        // Swap the letters\n        let firstIndex: Int\
    \ = alphabet.index(of: letter, offsetBy: index)\n        let secondIndex: Int\
    \ = alphabet.index(of: letter, offsetBy: index + 1)\n        \n        if firstIndex\
    \ != nil && secondIndex != nil {\n            let first = alphabet[firstIndex]\n\
    \            let second = alphabet[secondIndex]\n            \n            output\
    \ += [first, second]\n            \n            index += 2\n        }\n      \
    \  \n        // Add the letter to the output\n        output += [letter]\n   \
    \ }\n    \n    return String(output)", "\tlet vowels: Set<Character> = Set(\"\
    AEIOUaeiou\")\n\treturn message.unicodeScalars.filter({ vowels.contains($0.value)}).map\
    \ {\n\t\tlet index = vowels.index($0.value)!\n\t\treturn message.unicodeScalars.map\
    \ { \n\t\t\tlet c = String($0.value)\n\t\t\tif c == $0.value {\n\t\t\t\treturn\
    \ String(index)\n\t\t\t} else {\n\t\t\t\treturn c\n\t\t\t}\n\t\t}.join()\n\t}.reduce(\"\
    \") { (acc, c) in \n\t\treturn acc + c\n\t}", "    var encoded: String = \"\"\n\
    \    for letter in message {\n        if letter.lowercased() == \"a\" || letter.lowercased()\
    \ == \"e\" || letter.lowercased() == \"i\" || letter.lowercased() == \"o\" ||\
    \ letter.lowercased() == \"u\" {\n            encoded += letter\n        } else\
    \ {\n            let position = vowels.position(of: letter)\n            let index\
    \ = (position?.element ?? 0) - 1\n            if index >= 0 {\n              \
    \  let vowel = vowels[index]\n                let replacement = vowel.uppercased()\n\
    \                encoded += String(replacement)\n            }\n        }\n  \
    \  }\n    return encoded", "    // Create an array that keeps track of which letters\
    \ have been swapped.\n    var swapped = [String]()\n\n    // Loop through every\
    \ letter in message\n    for letter in message {\n        // If the letter is\
    \ in the swapped array\n        if swapped.contains(letter) {\n            //\
    \ If there are 2 letters ahead of it, replace the vowel\n            index = swapped.index(of:\
    \ letter)\n            swapped[index] = letter + letters[index + 1 ..< letters.count].first!\n\
    \        } else if letters.contains(letter) {\n            // If it's not a vowel,\
    \ replace it with a vowel\n            index = letters.index(of: letter)\n   \
    \         swapped[index] = letter + letters[index + 1 ..< letters.count].first!\n\
    \        } else {\n            // If the letter is not in the swapped array,\n\
    \            // then it's not a vowel.\n            swapped.append(letter)\n \
    \       }\n    }\n\n    // Reverse the array\n    return String(swapped).reversed()",
  "  var vowels = \"aeiouAEIOU\"\n  var message = message.lowercased()\n\n  for c\
    \ in message {\n    if vowels.contains(c.lowercased()) {\n      c = c.swapcase()\n\
    \    }\n    \n    let i = indexOf(c, vowels)\n    \n    if i == nil {\n      c\
    \ += \" \"\n    }\n    else {\n      c = String(c).dropFirst(i! + 1).append(String(c).dropFirst(i!))\n\
    \    }\n  }\n\n  return String(message)", "    if message == \"\" {\n        return\
    \ message\n    }\n    \n    let vowels = \"aeiouAEIOU\"\n    var newMessage =\
    \ \"\"\n    let vowelIndices = Array(0...message.characters.count).filter { (idx:\
    \ Int) -> Bool in\n        let char = message.characters.index(of: String.init(charactersIn:\
    \ message.characters)[idx])!\n        \n        return vowels.contains(String(char))\n\
    \    }\n    \n    for letter in message.characters {\n        if let idx = vowelIndices.index(of:\
    \ String(letter)) {\n            let twoLettersBeforeVowel = String(message.characters[idx\
    \ + (1 ..< message.characters.count)].characters)\n            if let vowelIndex\
    \ = vowelIndices.first {\n                let vowel = String(message.characters[vowelIndex])\n\
    \                \n                if twoLettersBeforeVowel.contains(vowel) {\n\
    \                    newMessage = newMessage + String(vowel)\n               \
    \     vowelIndices.remove(at: idx)\n                }\n            }\n       \
    \ }\n    }\n    \n    for idx in vowelIndices {\n        let char = String(message.characters[idx])\n\
    \        newMessage = newMessage + String(char)\n    }\n    \n    return newMessage",
  "    var result = \"\"\n    \n    for letter in message {\n        \n        //\
    \ TODO: swap case\n        \n        // TODO: replace vowels\n    }\n    \n  \
    \  return result", "    let letters = Array(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"\
    ,\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\"\
    ,\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n    let vowels = Array(\"a\",\"e\"\
    ,\"i\",\"o\",\"u\")\n    let swapped = message.characters.map { $0.lowercased().swapped().map\
    \ { letters.contains($0) ? letters[letters.firstIndex(of: $0)!] : letter } }\n\
    \    return String(swapped)", "    if message.isEmpty {\n        return message\n\
    \    }\n    var ascii = [UInt8](count: 256, repeatedValue: 0)\n    var message\
    \ = message.lowercased()\n    message.forEach { \n        let value = $0.asciiValue\
    \ \n        if value < 97 || value > 122 {\n            return\n        }\n  \
    \      ascii[value] = value \n    }\n\n    var resultString = \"\"\n    for i\
    \ in 0..<message.count {\n        let previousVowel = message.index(message.startIndex,\
    \ offsetBy: -i)\n        if ascii[message[i]] != ascii[previousVowel] {\n    \
    \        resultString += String(ascii[message[i]])\n        }\n    }\n    return\
    \ resultString", "    if message.characters.count < 3 {\n        return \"\"\n\
    \    }\n    \n    var result = \"\"\n    let vowels = \"aeiou\"\n    for letter\
    \ in message.characters {\n        let index = alphabet.index(of: letter)!\n \
    \       if vowels.contains(String(letter)) {\n            let index = alphabet.index(of:\
    \ String(letter))!\n            result += String(alphabet[index + (index + 1)])\n\
    \        } else {\n            result += String(alphabet[index + (index + 1)])\n\
    \        }\n    }\n    return result", "    let characters = Array(message)\n\
    \        .filter {\n            let unicodeScalar = $0.unicodeScalars.first!\n\
    \            return unicodeScalar.value > 65 && unicodeScalar.value < 65 + 26\n\
    \        }\n\n    let replacements = [\n        \"A\"    : \"a\",\n        \"\
    B\"    : \"b\",\n        \"C\"    : \"c\",\n        \"D\"    : \"d\",\n      \
    \  \"E\"    : \"e\",\n        \"F\"    : \"f\",\n        \"G\"    : \"g\",\n \
    \       \"H\"    : \"h\",\n        \"I\"    : \"i\",\n        \"J\"    : \"j\"\
    ,\n        \"K\"    : \"k\",\n        \"L\"    : \"l\",\n        \"M\"    : \"\
    m\",\n        \"N\"    : \"n\",\n        \"O\"    : \"o\",\n        \"P\"    :\
    \ \"p\",\n        \"Q\"    : \"q\",\n        \"R\"    : \"r\",\n        \"S\"\
    \    : \"s\",\n        \"T\"    : \"t\",\n        \"U\"    : \"u\",\n        \"\
    V\"    : \"v\",\n        \"W\"    : \"w\",\n        \"X\"    : \"x\",\n      \
    \  \"Y\"    : \"y\",\n        \"Z\"    : \"z\"\n    ]\n\n    return characters\n\
    \        .map({ String($0) })\n        .map {\n            return $0.lowercased()\n\
    \                .reduce(\"\", { \n                    let previous = $1\n   \
    \                 var replacement: Character = \"\"\n                    for case\
    \ let character in $1.unicodeScalars {\n                        if case let previousCharacter\
    \ = previous.lowercased() {\n                            if let replacement =\
    \ replacements[previousCharacter] {\n                                replacement\
    \ = replacement\n                            } else {\n                      \
    \          replacement = previousCharacter\n                            }\n  \
    \                      } else {\n                            replacement = character\n\
    \                        }\n                        previous = String($0) \n \
    \                       return  replacement + String($1)\n                   \
    \ }\n                    return $0 + replacement\n                })\n       \
    \ }\n        .reduce(\"\", { $0 + $1 })", "    \n    let chars = message.characters\n\
    \n    var result = \"\"\n\n    for (index, char) in chars.enumerate() {\n    \
    \    let uppercase = char.uppercased()\n        let replacement = uppercase[uppercase.index(uppercase,\
    \ offsetBy: 2)]\n        result += replacement.string(using: String.Encoding.ascii)\n\
    \    }\n\n    return result", "    var output = \"\"\n    for character in message\
    \ {\n        let asciiCode = UInt32(character)\n        let index = asciiCode\
    \ - 65\n        let twoLetterAsciiCode = asciiCode + 64\n        switch asciiCode\
    \ {\n        case 97 ... 122:\n            // Swap case to letter that comes 2\
    \ places ahead of vowel.\n            let twoLetterAsciiCode = asciiCode + 64\n\
    \            output += String(UnicodeScalar(twoLetterAsciiCode).value).uppercased\n\
    \        case 65 ... 90:\n            // Replace all vowels with that letter that\
    \ comes 2 places ahead of vowel.\n            let twoLetterAsciiCode = asciiCode\
    \ + 64\n            output += String(UnicodeScalar(twoLetterAsciiCode).value)\n\
    \        default:\n            output += String(asciiCode)\n        }\n    }\n\
    \    return output", "    var messageAsMutable = message\n    var result = \"\"\
    \n    for char in messageAsMutable {\n        let letterIndex = alphabet.indexOf(char)\
    \ + 2\n        let letter = alphabet[letterIndex]\n        var replacement = \"\
    \"\n        if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter\
    \ == \"o\" || letter == \"u\" {\n            replacement = alphabet[letterIndex\
    \ + 1]\n        }\n        result += replacement\n    }\n    return result", " \
    \   var result = \"\"\n    for letter in message {\n        let letterCode = letter.asciiValue\n\
    \        result += String(UInt8(letterCode - 65 + 1))\n    }\n    return result",
  "    let vowels = \"aeiouAEIOU\"\n    let regex = NSRegularExpression.regularExpressionWithPattern(\"\
    [aeiouy]+\", options: 0, error: nil)\n    var chars: [String] = []\n    var lastChar\
    \ = \"\"\n    let maxLength = message.characters.count\n    for i in 0..<maxLength\
    \ {\n        let c = message[i]\n        var replacement = \"\"\n        if c.isLetter\
    \ {\n            if let match = regex.firstMatchInString(message.lowercaseString,\
    \ options: 0, range: NSMakeRange(i, 1)) {\n                replacement = match.stringByReplacingMatchesInString(message.lowercaseString,\
    \ options: 0, range: NSMakeRange(i, 1), withTemplate: c)\n                replacement\
    \ = replacement.stringByReplacingCharactersInRange(match.range, with: c)\n   \
    \             lastChar = replacement\n            }\n            replacement =\
    \ c.lowercaseString.substringToIndex(replacement)!\n        } else {\n       \
    \     replacement = c\n        }\n        if lastChar != replacement {\n     \
    \       lastChar = replacement\n            chars.append(replacement)\n      \
    \  } else {\n            if chars.count > 0 {\n                chars[chars.count\
    \ - 1] += c\n            } else {\n                chars.append(c)\n         \
    \   }\n        }\n    }\n    return String(chars)", "    let vowels = \"AEIOU\"\
    \n    return message\n        .characters\n        .reduce(\"\") { $0 + String(Character(UnicodeScalar($1).value).cased())[vowels.indexOf($1)]\
    \ + String(Character(UnicodeScalar($1).value).replaceCharactersInRange(NSRange(location:\
    \ vowels.indexOf($1) + 1, length: 1), withString: String(Character(UnicodeScalar($1).value).cased())))\
    \ }", "    \n    // Replace all vowels with the letter that appears 2 places ahead\n\
    \    // of it in the alphabet\n    var replacement: Character = \"a\"\n    let\
    \ vowels = \"aeiou\"\n    for char in message {\n        if vowels.contains(char)\
    \ {\n            replacement = char.successor()\n        }\n    }\n    \n    //\
    \ Swap case for all letters\n    var converted = \"\"\n    for char in message\
    \ {\n        converted = converted.appending(cut(String(char).lowercased(), 2))\n\
    \    }\n    \n    // Replace all vowels in converted with the replacement letter\n\
    \    for char in converted {\n        if vowels.contains(char) {\n           \
    \ converted = converted.replacingOccurrences(of: char, with: replacement)\n  \
    \      }\n    }\n    \n    return converted", "    let vowels = \"aeiou\"\n  \
    \  return message.characters.reduce(\"\") { \n        let replaced = $0.unicodeScalars.map\
    \ { \n            if vowels.contains($0.value) {\n                return String($0.value\
    \ - 2)\n            } else {\n                return String($0.value)\n      \
    \      }\n        }\n        guard let last = $0.unicodeScalars.last else { return\
    \ replaced }\n        replaced.append(String(last.value))\n        return replaced.joinWithSeparator(\"\
    \")\n    }", "    var encodedString = message\n    \n    for index in 0..<message.characters.count\
    \ {\n        let char = message.characters[index]\n        \n        // swap case\n\
    \        switch char {\n        case let upcasedChar as Character.UnicodeScalar:\n\
    \            encodedString.replaceSubrange(index..<index + upcasedChar.value,\
    \ with: upcasedChar.value)\n        default:\n            break\n        }\n \
    \   }\n    \n    // replace all vowels\n    for vowel in \"aeiouAEIOU\" {\n  \
    \      encodedString = encodedString.replacingOccurrences(of: vowel, with: vowel.nextUp)\n\
    \    }\n    return encodedString", "\treturn replace(replace(message, 2, 1), 3,\
    \ 1)", "    if message == \"\" {\n        return \"\"\n    }\n    var letters\
    \ = Array(Array(String(message).unicodeScalars))\n    var vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n    var vowelsWithTwoPlaces = [\"ae\", \"ei\", \"io\"\
    , \"ou\"]\n    letters.forEach {\n        if let first = letters.first {\n   \
    \         let index = vowels.firstIndex(where: {\n                $0.isEqualToString(String(first)\n\
    \            })\n            if index != nil {\n                letters[0] = first\n\
    \                letters.dropFirst()\n            }\n        }\n    }\n    letters.forEach\
    \ {\n        if let first = letters.first {\n            var index = vowelsWithTwoPlaces.firstIndex(where:\
    \ {\n                $0.isEqualToString(String(first)\n            })\n      \
    \      if index != nil {\n                letters[0] = first\n               \
    \ letters.dropFirst()\n            }\n        }\n    }\n    var result = \"\"\n\
    \    letters.forEach {\n        result += String($0)\n    }\n    return result",
  "    \n    let alphabet = Array(message.characters)\n    let vowels = \"AEIOU\"\n\
    \    let replacementsDict = Dictionary(uniqueKeysWithValues: \n              \
    \                         [\n                                          (\"A\"\
    , vowels[0]), \n                                          (\"E\", vowels[1]),\
    \ \n                                          (\"I\", vowels[2]), \n         \
    \                                 (\"O\", vowels[3]), \n                     \
    \                     (\"U\", vowels[4])\n                                   \
    \    ]\n    )\n    \n    var encodedString = \"\"\n    for (index, character)\
    \ in alphabet.enumerate() {\n        let replacement = replacementsDict.get(character)\n\
    \        \n        if let replacement = replacement {\n            let replacementIndex\
    \ = index - 2\n            let replacementCharacter = vowels[replacementIndex]\n\
    \            \n            if replacementIndex >= 0 {\n                encodedString.append(replacement)\n\
    \            } else {\n                encodedString.append(replacementCharacter)\n\
    \            }\n        } else {\n            encodedString.append(character)\n\
    \        }\n    }\n    \n    return encodedString", '    return message(message:
    "test", replace: "test", swap: "AEIOUYaeiouy", swapCount: 2)', "    var message\
    \ = message\n\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ]\n    let vowelsRep: [Character] = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n\n  \
    \  var result = \"\"\n    for char in message {\n        let index = message.index(of:\
    \ char) \n        var newChar = char\n\n        if char.isLetter {\n         \
    \   let nextLetter = message.index(of: char.next(), offset: 1)\n            if\
    \ nextLetter != nil { \n                newChar = vowelsRep[(nextLetter! - 1)]\n\
    \            }\n        }\n        \n        result = result + newChar\n    }\n\
    \    return result", '    return String(friendlyEncoding(message))', "\treturn\
    \ message.characters.map({ charToCode[String($0)] }).reduce((acc: String, code:\
    \ Int)-> String in\n\t\tif code < 65 {\n\t\t\treturn String(code)\n\t\t}\n\t\t\
    let lowerChar = String(code) - 65\n\t\treturn String(charToCode[lowerChar]) +\
    \ acc\n\t).reversed()", "    \n    var alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    \n    var result = \"\"\n    \n    for  letter in message {\n        \n\
    \        let index = alphabet.indexOf(letter)\n        \n        let nextIndex\
    \ = alphabet.indexOf(letter, index + 1)\n        \n        if nextIndex < 0 {\n\
    \            result += \"?\"\n            continue\n        }\n        \n    \
    \    let nextLetter = alphabet[nextIndex + 1]\n        \n        if letter.isUppercase\
    \ {\n            result += alphabet[index + (alphabet.index(nextLetter) ?? 0)]\n\
    \        } else {\n            result += alphabet[index + (alphabet.index(nextLetter)\
    \ ?? 0) - 1]\n        }\n        \n    }\n    \n    return result", "    return\
    \ message.unicodeScalars.map {\n        String($0.value, radix: 10)\n    }.joined()",
  "    let vowels = \"aeiouAEIOU\"\n    var encodedMessage = message\n\n    var currentLetter\
    \ = String()\n    for let letter in encodedMessage {\n        if let index = vowels.firstIndex(of:\
    \ letter) {\n            let oneLetterBefore = vowels[index - 1]\n           \
    \ let twoLettersBefore = vowels[index - 2]\n            encodedMessage = encodedMessage.replacingOccurrences(of:\
    \ letter, with: oneLetterBefore)\n            encodedMessage = encodedMessage.replacingOccurrences(of:\
    \ twoLettersBefore, with: letter)\n        } else {\n            encodedMessage\
    \ = encodedMessage.replacingOccurrences(of: letter, with: letter)\n        }\n\
    \    }\n\n    return encodedMessage", "    return message(\n    letter: \"S\"\
    ,\n    vowel: \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n\
    \    vowel: \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n\
    \    vowel: \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n\
    \    vowel: \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n\
    \    vowel: \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n\
    \    vowel: \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n\
    \    vowel: \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n\
    \    vowel: \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n\
    \    vowel: \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n\
    \    vowel: \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n\
    \    vowel: \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n\
    \    vowel: \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n\
    \    vowel: \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n\
    \    vowel: \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n\
    \    vowel: \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n\
    \    vowel: \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n\
    \    vowel: \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n\
    \    vowel: \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n\
    \    vowel: \"A\",\n    vowel: \"E\",\n    vowel: \"I\",\n    vowel: \"O\",\n\
    \    vowel: \"U\",\n    vowel: \"O\",\n    vowel: \"A\",\n    vowel: \"E\",\n\
    \    vowel: \"I\",\n    vowel: \"O\",\n    vowel: \"U\",\n    vowel: \"O\",\n",
  "    var result = \"\"\n    for character in message {\n        var index = 0\n\
    \        var nextVowelIndex = nextVowelIndex(character)\n        while index <\
    \ len(character) && index != nextVowelIndex {\n            index++\n        }\n\
    \        if index == len(character) {\n            result += character\n     \
    \   } else {\n            result += \"\\(\\(character[index]\\))\"\n        }\n\
    \    }\n    return result", "    let vowels = \"aeiouAEIOU\"\n    let vowelIndex:\
    \ Dictionary = Dictionary(uniqueKeysWithValues:\n        Array(vowels.enumerated().map({\
    \ $0.element, $0.offset+1 }))\n    )\n    return String(message.characters.flatMap\
    \ { char -> String in\n        let index = vowelIndex[char] ?? 0\n        let\
    \ newChar = String(repeatElement(char.uppercased(), index))\n        return newChar\
    \ == char.uppercased() ? char.lowercased() : newChar\n    }.joinWithSeparator(\"\
    \"))", "\tlet alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\tlet vowels = \"aeiou\"\
    \n\tlet mapping = vowels.reduce(\"\") { acc, char in\n\t\tlet index = alphabet.index(of:\
    \ char)!\n\t\tlet previous = acc[index-2] ?? \"\"\n\t\tlet next = acc[index-1]\
    \ ?? \"\"\n\t\treturn acc + previous + String(alphabet.index(of: next)!)\n\t}\n\
    \treturn mapping[message.characters.map({ alphabet.index(of: $0)!}).max()]", " \
    \   let vowels = \"AEIOUaeiou\"\n    var string = String()\n    for i in 0..<message.characters.count\
    \ {\n        var c = message.characters[i]\n        \n        let index = string.characters.index(of:\
    \ c)\n        var nextVowel = string.characters[index + 1]\n        nextVowel\
    \ = nextVowel.lowercased()\n\n        if let idx = vowels.firstIndex(of: nextVowel)\
    \ {\n            let newVowel = String(vowels[idx : idx + 1])\n            let\
    \ replacement = string.substring(to: index)\n            string = string.replacingOccurrences(of:\
    \ c, with: newVowel)\n        }\n        string = string.append(c)\n    }\n  \
    \  return string", "    var result = \"\"\n    for i in 0..<message.count {\n\
    \        var newChar = message[i]\n        if newChar == \" \" {\n           \
    \ newChar = \"0\"\n        }\n        result += String(crSwappingDict[newChar])\n\
    \    }\n    return result", "    let map = [\n        \"A\": \"A\", \n       \
    \ \"E\": \"E\",\n        \"I\": \"I\",\n        \"O\": \"O\",\n        \"U\":\
    \ \"U\", \n        \"a\": \"a\", \n        \"e\": \"e\",\n        \"i\": \"i\"\
    ,\n        \"o\": \"o\",\n        \"u\": \"u\"\n    ]\n    let res = \"ABCDEFGHIJKLMNOPU\"\
    .characters.map({ $0 }).reduce(\"\", { acc, c in\n        if let prev = map.index(of:\
    \ c) {\n            return acc + map[prev]\n        } else {\n            return\
    \ acc + c\n        }\n    })\n    return message.characters.map({ res + map[$0]\
    \ }).reduce(\"\") { acc, c in\n        if let index = res.index(of: c) {\n   \
    \         let prev = res[index]\n            return acc + prev.capitalized + map[prev.next!]\n\
    \        } else {\n            return acc + c\n        }\n    }", "    return\
    \ message.map { Character($0).lowercased().replaceWithCharacter(String($0.unicodeScalars.drop(2)))\
    \ }\n        .joined()", "    return message\n        .characters\n        .map\
    \ { (c) -> ((Char) -> Char)? in \n            return isVowel(c) ? nil : { \n \
    \               let index = c as UInt32\n                var index2 = 0\n    \
    \            let index3 = (index + 1)\n                return {\n            \
    \        index2\n                } \n            }\n        }\n        .reduce(\"\
    \") { (acc, letter, currentIndex) -> String in\n            switch letter {\n\
    \            case let .some(letter as String):\n                return acc + String(letter)\n\
    \            case .none:\n                return acc + String(currentIndex)\n\
    \            }\n        }", "    return message.map{ c -> String in\n        let\
    \ index = alphabet.index(of: c)\n        if index < alphabet.count - 2 {\n   \
    \         let first = alphabet.index(before: index)\n            let second =\
    \ alphabet.index(before: index + 1)\n            let third = alphabet.index(before:\
    \ index + 2)\n            let result = (first! + second! + third!)!\n        \
    \    let i = alphabet.index(of: result)\n            return alphabet[i] \n   \
    \     }\n        else if index == 0 {\n            return alphabet[alphabet.count\
    \ - 1]\n        }\n        else if index == alphabet.count - 2 {\n           \
    \ return alphabet[0]\n        }\n        else if index == alphabet.count - 3 {\n\
    \            return alphabet[alphabet.count - 2]\n        }\n        else if index\
    \ == alphabet.count - 4 {\n            return alphabet[0]\n        }\n       \
    \ else{\n            return \"-\"\n        }\n    }.joined()", "\tguard let alphabet\
    \ = CharacterSet.letters else {\n\t\tfatalError(\"Invalid alphabet specified\"\
    )\n\t}\n\t\n\treturn message\n\t.unicodeScalars\n\t.map { character in\n\t\tlet\
    \ charIndex = alphabet.index(of: character)\n\t\tguard charIndex != alphabet.endIndex\
    \ - 1 else { return character }\n\t\tlet previousCharIndex = alphabet.index(of:\
    \ character, offsetBy: -1)\n\t\tlet previousChar = String(alphabet[previousCharIndex])\n\
    \t\treturn previousChar.lowercased() + String(alphabet[charIndex])\n\t}\n\t.joined()",
  "    return message\n        .unicodeScalars\n        .map { letter -> String in\n\
    \            let index = letter - 'a'\n            let vowel = letter == 'a' ||\
    \ letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' || letter ==\
    \ 'y' ? 'A' : 'a'\n            let pair = vowel + String(index + 1)\n        \
    \    return pair\n        }\n        .join(\"\")", "    let vowels = \"AEIOUaeiou\"\
    \n    let indexToLetter = map([vowels.startIndex, vowels.endIndex].map({ $0 +\
    \ 1 }))\n\n    return map({ (index: Int, letter: Character) -> String in\n   \
    \     let index = indexToLetter(index)\n        let letter = String(indexToLetter[index\
    \ + 1])\n\n        return (letter == letter) ? letter + letter : String(letter)\n\
    \    })(message.characters)", "    var result = \"\"\n    \n    for letter in\
    \ message {\n        let index = letter.unicodeScalars.indexOf(unicodeScalars.lowercaseB)\n\
    \        var a = index\n        var b = index + 1\n        if a < 0 {\n      \
    \      a = 0\n        }\n        if b < 0 {\n            b = 0\n        }\n  \
    \      if a != b {\n            let c = message.substring(a, a+1)\n          \
    \  let d = message.substring(b, b+1)\n            if c == c {\n              \
    \  result += c\n                result += d\n            }\n            else {\n\
    \                let i = message.indexOf(c, b)\n                if i != b {\n\
    \                    let e = message.substring(b, i+1)\n                    result\
    \ += c\n                    result += e\n                }\n                result\
    \ += d\n            }\n        }\n        else {\n            result += letter\n\
    \        }\n    }\n    return result", "    // Your code here\n    var result\
    \ = [Character]()\n    var prevLetter = \"\"\n    for letter in message {\n  \
    \      switch letter {\n        case \"a\",\"e\",\"i\",\"o\",\"u\":\n        \
    \    prevLetter += \"B\"\n        case \"A\",\"E\",\"I\",\"O\",\"U\":\n      \
    \      prevLetter += \"bB\"\n        case \"t\",\"t\",\"h\",\"k\":\n         \
    \   prevLetter += \"S\"\n        case \"T\",\"T\",\"H\",\"K\":\n            prevLetter\
    \ += \"sS\"\n        case \"r\",\"n\",\"g\":\n            prevLetter += \"R\"\n\
    \        case \"R\",\"N\",\"G\":\n            prevLetter += \"rR\"\n        case\
    \ \"p\",\"f\",\"v\",\"b\",\"q\",\"x\",\"j\",\"z\":\n            prevLetter +=\
    \ \"W\"\n        case \"P\",\"F\",\"V\",\"B\",\"Q\",\"X\",\"J\",\"Z\":\n     \
    \       prevLetter += \"wW\"\n        case \"g\",\"c\",\"m\",\"k\",\"s\",\"s\"\
    ,\"c\",\"g\",\"s\",\"a\":\n            prevLetter += \"M\"\n        case \"G\"\
    ,\"C\",\"M\",\"K\",\"S\",\"S\",\"C\",\"G\",\"S\",\"A\":\n            prevLetter\
    \ += \"mM\"\n        case \"w\",\"t\",\"s\",\"c\",\"m\",\"g\",\"k\",\"s\",\"c\"\
    ,\"g\",\"s\":\n            prevLetter += \"H\"\n        case \"W\",\"T\",\"S\"\
    ,\"C\",\"M\",\"G\",\"K\",\"S\",\"C\",\"G\",\"S\":\n            prevLetter += \"\
    hH\"\n        case \"s\",\"a\",\"c\",\"m\",\"c\",\"g\",\"k\",\"s\",\"c\",\"g\"\
    ,\"s\",\"a\":\n            prevLetter += \"D\"\n        case \"S\",\"A\",\"C\"\
    ,\"M\",\"C\",\"G\",\"K\",\"S\",\"C\",\"G\",\"S\",\"A\":\n            prevLetter\
    \ += \"dD\"\n        default:\n            prevLetter += letter\n        }\n \
    \       prevLetter = prevLetter[letter]\n        result += prevLetter\n    }\n\
    \    return String(result)", "    guard let vowels = [\"a\",\"e\",\"i\",\"o\"\
    ,\"u\"] else { return \"\" }\n    var index = 0\n    var result: String = message\n\
    \    for character in result {\n        if character == \"a\" || character ==\
    \ \"e\" || character == \"i\" || character == \"o\" || character == \"u\" {\n\
    \            result[index] = vowels[Int(index)/2]\n        } else {\n        \
    \    result[index] = character\n        }\n        index += 1\n    }\n    return\
    \ result", "    // TODO: Implement me!\n    return \"\"", "    letters := [String]()\n\
    \    for letter in message {\n        letters.append(letter)\n    }\n    var encodedString\
    \ = \"\"\n    for letter := range letters {\n        encodedString += replacement[letter]\n\
    \    }\n    return encodedString", "\t\n\t//find all the vowels in the message\n\
    \tvowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n\t\n\t//find all the\
    \ letters in the message\n\tletters = Set(\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\");\n\t\n\t//create\
    \ a map for storing letter pairs, so that we can reorder the letters \n\t//while\
    \ swaping letters\n\tletterPairs = Dictionary<String, String>();\n\t\n\t//go through\
    \ each letter in the message\n\tfor letter in message.characters {\n\t\t//swap\
    \ case for current letter\n\t\tlet swap = letter.lowercaseString;\n\t\t\n\t\t\
    //if the letter is already in the map, use that value\n\t\tif letterPairs[swap]\
    \ != nil {\n\t\t\t//swap case for new letter\n\t\t\tlet swap2 = letterPairs[swap].lowercaseString;\n\
    \t\t\t\n\t\t\t//if the letter is not in the map, add it to the map\n\t\t\tif !letterPairs[swap2]\
    \ == nil {\n\t\t\t\t//move the old letter to the end of the map\n\t\t\t\tletterPairs[swap]\
    \ = nil;\n\t\t\t\t//add new letter\n\t\t\t\tletterPairs[swap2] = letter;\n\t\t\
    \t}\n\t\t}\n\t\telse {\n\t\t\t//if the letter is not in the map, then add it to\
    \ the map\n\t\t\tletterPairs[swap] = letter;\n\t\t}\n\t}\n\t\n\t//go through each\
    \ vowel\n\tfor vowel in vowels {\n\t\t\n\t\t//move the vowel to the start of the\
    \ message\n\t\tlet swapped = message.characters.firstIndex(of: vowel);\n\t\tlet\
    \ moved = message.characters[swapped - 1]\n\t\t\n\t\t//replace vowel in message\n\
    \t\tmessage.characters[swapped - 1] = vowel;\n\t\t\n\t\t//add new letter to message\n\
    \t\tmessage.characters.insert(moved, letter);\n\t}\n\t\n\treturn message;", " \
    \   var result = \"\"\n    for i in 0..<message.count {\n        var c = message[i]\n\
    \        let index = alphabet.index(of: c)!\n        let first = alphabet.index(before:\
    \ index)!\n        let last = alphabet.index(before: first)!\n        if i ==\
    \ 0 {\n            let a = alphabet.index(of: message[i])!\n            let b\
    \ = alphabet.index(of: message[a])!\n            if a == b {\n               \
    \ result += message[i]\n            } else {\n                result += message[i].capitalized\n\
    \            }\n        } else {\n            result += message[i].capitalized\n\
    \        }\n    }\n    return result", "    return message.uppercase().replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: \"E\", options: .regularExpression)\n        .replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: \"\", options: .regularExpression)\n        .replacingOccurrences(of:\
    \ \"aeiou\", with: \"E\", options: .regularExpression)\n        .replacingOccurrences(of:\
    \ \"AEIOUaeiou\", with: \"\", options: .regularExpression)\n        .replacingOccurrences(of:\
    \ \"aeiou\", with: \"I\", options: .regularExpression)", "    var result = \"\"\
    \n    for letter in message {\n        let vowels = \"aeiou\"\n        let letterIndex\
    \ = letters.index(of: letter)\n        let vowelIndex = vowels.firstIndex(of:\
    \ letter)\n        if letterIndex > vowelIndex {\n            let letterBefore\
    \ = letters.index(letterIndex, offsetBy: -1)\n            let letterAfter = letters.index(letterIndex,\
    \ offsetBy: 1)\n            let replacement = letters[letterIndex - 1]\n     \
    \       result.append(replacement)\n            result.append(letters[letterAfter])\n\
    \        }\n    }\n    return result", "    var messageAsCharArray: [Character]\
    \ = Array(message.characters)\n    var output: String = String()\n    for var\
    \ i = 0; i < messageAsCharArray.count; i++ {\n        var currentChar: Character\
    \ = messageAsCharArray[i]\n        if let currentCharIsVowel = currentChar.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n            var currentCharIsNextVowel = messageAsCharArray[i.advancedBy(1)]\n\
    \            if currentCharIsNextVowel.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n                let currentCharIsNextVowelIsNextChar = messageAsCharArray[i.advancedBy(2)]\n\
    \                if currentCharIsNextVowelIsNextChar.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n                    let currentCharIsNextVowelIsNextCharIsNextChar = messageAsCharArray[i.advancedBy(3)]\n\
    \                    if currentCharIsNextVowelIsNextCharIsNextChar.unicodeScalars.filter({$0.isVowel}).first\
    \ {\n                        let currentCharIsNextVowelIsNextCharIsNextCharIsNextChar\
    \ = messageAsCharArray[i.advancedBy(4)]\n                        output.append(currentChar)\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return String(output)", "    var result = \"\"\n    \n    for letter in message\
    \ {\n        let letterIndex = alphabet.indexOf(letter)\n        var newLetter:\
    \ Char\n        if letterIndex < 0 {\n            newLetter = letter\n       \
    \ } else {\n            if letterIndex > 0 {\n                newLetter = alphabet[letterIndex-1]\
    \ + alphabet[letterIndex]\n            } else {\n                newLetter = alphabet[letterIndex]\n\
    \            }\n        }\n        \n        // Only append if 2 letters ahead.\n\
    \        if letterIndex > 1 {\n            result += newLetter\n        }\n  \
    \  }\n    \n    return result", "    if let firstLetter = message.first{\n   \
    \     let twoLetters = message.dropFirst()\n        return String(twoLetters.map\
    \ { $0.unicodeScalars.first }) + String(firstLetter.unicodeScalars.dropFirst())\n\
    \    }\n    return message", "    return message\n        .reduce(\"\") { acc,\
    \ curr in\n            var vowels = Set.init([\"a\", \"e\", \"i\", \"o\", \"u\"\
    ])\n            let splitted = curr.characters.split(separator: \"\")\n      \
    \      splitted.forEach { char in\n                if vowels.contains(char) {\n\
    \                    vowels.insert(char.lowercased())\n                    acc\
    \ += \"\\(char.lowercased())\"\n                    vowels.remove(char.lowercased())\n\
    \                }\n            }\n            acc += String(splitted.count)\n\
    \            return acc\n        }\n        .reduce(\"\") { acc, curr in\n   \
    \         let splitted = curr.characters.split(separator: \"\")\n            let\
    \ letters = [\"a\", \"e\", \"i\", \"o\", \"u\"].sorted(by: <)\n            let\
    \ vowels = [\"\", \"a\", \"e\", \"i\", \"o\", \"u\"].sorted(by: <)\n         \
    \   var acc = \"\"\n            for char in splitted {\n                if vowels.contains(char)\
    \ {\n                    acc += \"\\(letters[vowels.index(char)]).\"\n       \
    \         } else {\n                    acc += \"\\(char).\"\n               \
    \ }\n            }\n            return acc\n        }\n        .reduce(\"\") {\
    \ acc, curr in\n            let splitted = curr.characters.split(separator: \"\
    \")\n            return acc + String(splitted.count)\n        }", "    // Fill\
    \ this in.\n    return \"\"", "    return message\n        .unicodeScalars\n \
    \       .filter({ !$0.isASCII })\n        .flatMap { encode($0) }\n        .map\
    \ { $0.replacingOccurrences(of: \"a...z\", with: \"A$1\") }\n        .flatMap\
    \ { $0.unicodeScalars.filter { $0.isASCII } }\n        .joined()\n        .replacingOccurrences(of:\
    \ \"aeiouAEIOU\", with: \"A$0\")", "    return message.lowercased().toUpperString.replaceAll(\"\
    A\", \"D\")\n    .replaceAll(\"B\", \"E\")\n    .replaceAll(\"C\", \"G\")\n  \
    \  .replaceAll(\"D\", \"A\")\n    .replaceAll(\"E\", \"B\")\n    .replaceAll(\"\
    F\", \"C\")\n    .replaceAll(\"G\", \"D\")\n    .replaceAll(\"H\", \"E\")\n  \
    \  .replaceAll(\"I\", \"F\")\n    .replaceAll(\"J\", \"G\")\n    .replaceAll(\"\
    K\", \"H\")\n    .replaceAll(\"L\", \"I\")\n    .replaceAll(\"M\", \"J\")\n  \
    \  .replaceAll(\"N\", \"K\")\n    .replaceAll(\"O\", \"L\")\n    .replaceAll(\"\
    P\", \"M\")\n    .replaceAll(\"Q\", \"N\")\n    .replaceAll(\"R\", \"S\")\n  \
    \  .replaceAll(\"T\", \"O\")\n    .replaceAll(\"U\", \"P\")\n    .replaceAll(\"\
    V\", \"Q\")\n    .replaceAll(\"W\", \"R\")\n    .replaceAll(\"X\", \"T\")\n  \
    \  .replaceAll(\"Y\", \"U\")\n    .replaceAll(\"Z\", \"V\")", "    var outputMessage\
    \ = \"\"\n    var alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"\
    , \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"\
    , \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n    for char in message\
    \ {\n        for index in 0..<alphabet.count {\n            if char == alphabet[index]\
    \ {\n                let nextIndex = alphabet.index(before: index)! + 1\n    \
    \            if nextIndex < alphabet.count {\n                    outputMessage.append(alphabet[nextIndex])\n\
    \                } else {\n                    outputMessage.append(char.lowercased())\n\
    \                }\n                break\n            }\n        }\n    }\n \
    \   return outputMessage", '    return ""', "    var result : String = \"\"\n\
    \    for i in message {\n        result += String([i as Char]) + String([i as\
    \ Char].isUpper) \n    }\n    let vowels : [String] = [\"\", \"A\", \"I\", \"\
    O\", \"U\"]\n    for element in vowels {\n        let startIndex = result.characters.index(of:\
    \ element)\n        let endIndex = result.characters.index(of: element, offsetBy:\
    \ 2, limitedBy: result.endIndex) \n        let substring = String(result.characters.suffix(from:\
    \ startIndex))\n        let newSubString = String(substring).replacingOccurrences(of:\
    \ element, with: element.lowercased())\n        result = result.replaceSubrange(startIndex..<endIndex,\
    \ with: newSubString)\n    }\n    return result", "    let vowels: Set<Character>\
    \ = [ \"a\", \"e\", \"i\", \"o\", \"u\" ]\n\n    var result: String = \"\"\n \
    \   var currentLetter = message[0]\n\n    for char in message {\n        if vowels.contains(char)\
    \ {\n            let index = vowels.firstIndex(of: char)\n            if index\
    \ > 0 {\n                let twoLetters = vowels[index-2]\n                result\
    \ += char + twoLetters\n            }\n        }\n        else {\n           \
    \ result += char\n        }\n    }\n    return result", "    var result = \"\"\
    \n\n    let vowels = \"aeiou\"\n\n    for letter in message {\n        if let\
    \ upper = String(letter).uppercaseString{\n            result += upper\n     \
    \   } else {\n            let index = letter.unicodeScalars.firstIndex(of: vowels)!\n\
    \            let firstVowel = vowels.unicodeScalars.first\n            let secondVowel\
    \ = vowels.unicodeScalars.last\n            let swappedLetter = String(firstVowel).replacingCharacters(in:\
    \ index, with: String(secondVowel))\n            result += String(letter).replacingCharacters(in:\
    \ index, with: swappedLetter)\n        }\n    }\n\n    return result", "    let\
    \ encoded = NSMutableString(string: message)\n    for index in 0..<encoded.length\
    \ {\n        let ch = encoded.characterAtIndex(index)\n        let ch = ch.uppercaseString\n\
    \        let vowelIndex = String(ch.unicodeScalars.indexOfObject(NSRange(location:\
    \ 2, length: 2)))\n        switch vowelIndex {\n        case \"E\":\n        \
    \    encoded.replaceCharactersInRange(NSRange(location: index, length: 1), withString:\
    \ \"E\")\n        case \"I\":\n            encoded.replaceCharactersInRange(NSRange(location:\
    \ index, length: 1), withString: \"I\")\n        case \"O\":\n            encoded.replaceCharactersInRange(NSRange(location:\
    \ index, length: 1), withString: \"O\")\n        case \"U\":\n            encoded.replaceCharactersInRange(NSRange(location:\
    \ index, length: 1), withString: \"U\")\n        default:\n            encoded.replaceCharactersInRange(NSRange(location:\
    \ index, length: 1), withString: ch)\n        }\n    }\n    return encoded.capitalizedString",
  "    var outString = message\n    for char in message.unicodeScalars {\n       \
    \ if char.value >= 0x41 && char.value <= 0x5A {\n            outString = outString.replacingCharacters(in:\
    \ char.unicodeScalars.allCases, with: \"A\")\n        } else {\n            outString\
    \ = outString.replacingCharacters(in: char.unicodeScalars.allCases.map { $0.value\
    \ }, with: \"a\")\n        }\n    }\n    return outString", "    // Initialize\
    \ an output string\n    var output = \"\"\n\n    // Iterate over the characters\
    \ in the message\n    for char in message {\n        // If the character is a\
    \ vowel...\n        if char.isUppercase {\n            // Iterate over the vowels...\n\
    \            for vowel in vowels {\n                // Replace the vowel with\
    \ the letter that is two places ahead of the vowel\n                output = output.replace(vowel,\
    \ vowels[vowels.index(vowel)+1])\n            }\n            // Append the character\
    \ to the output\n            output = output + char\n        } else {\n      \
    \      // Append the character to output\n            output = output + char\n\
    \        }\n    }\n    return output", "\t\n\tvar resultString = \"\"\n\t\n\t\
    let vowels = \"aeiouAEIOU\"\n\t\n\tfor char in message {\n\t\tif vowels.contains(char)\
    \ {\n\t\t\tlet index = vowels.index(of: char)!\n\t\t\tresultString += String(message[index\
    \ - 1])\n\t\t\tresultString += String(message[index + 1])\n\t\t}\n\t\telse {\n\
    \t\t\tresultString += char\n\t\t}\n\t}\n\treturn resultString", "    \n    let\
    \ alphabet = message.unicodeScalars\n    let vowels = \"aeiouAEIOU\"\n    \n \
    \   let mut encodedString = String()\n    for (_,c) in alphabet.enumerated() {\n\
    \        if c.unicodeScalars.count < 2 || vowels.contains(c.scalar) {\n      \
    \      encodedString += c.unicodeScalars.last.string.capitalize + c.unicodeScalars.first!.string\n\
    \        } else if c.unicodeScalars.count == 2 {\n            encodedString +=\
    \ c.unicodeScalars.first!.string + c.unicodeScalars.last!.string\n        } else\
    \ {\n            encodedString += c.unicodeScalars.first!.string + c.unicodeScalars.last!.string\
    \ + c.unicodeScalars.last!.string\n        }\n    }\n    \n    return encodedString",
  "    var messageIndex = 0\n    var result = \"\"\n    for char in message {\n  \
    \      let isVowel = Character.isLetter(char)\n        let shouldSwitchCase =\
    \ isVowel && (messageIndex % 2 == 0)\n        let isInEnglishLetterRange = Character.isLetter(message[messageIndex])\n\
    \        let shouldReplaceVowel = Character.isLetter(message[messageIndex + 1])\
    \ && (messageIndex % 2 != 0)\n        \n        if shouldSwitchCase {\n      \
    \      result += Char.swapCase(char)\n        }\n        \n        if shouldReplaceVowel\
    \ {\n            result += message[messageIndex + 1]\n        }\n        \n  \
    \      messageIndex += 1\n    }\n    \n    return result", "    var result = \"\
    \"\n\n    for i in 0..<message.characters.count {\n        let char = message.characters[i]\n\
    \        let index = (i + 1)/2\n\n        if char.isUppercase {\n            if\
    \ index == 0 {\n                result = result + char\n            } else {\n\
    \                result = result + char.uppercaseString[i - 1]\n            }\n\
    \        } else {\n            if index == 0 {\n                result = result\
    \ + char\n            } else {\n                result = result + char.lowercaseString[i\
    \ - 1]\n            }\n        }\n    }\n\n    return result", "    var encodedMessage\
    \ = \"\"\n    for character in message {\n        if character == character.lowercased()\
    \ {\n            encodedMessage += character.uppercased()\n        }\n       \
    \ encodedMessage += character.lowercased()\n    }\n    return encodedMessage",
  "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result = ''\n    for\
    \ char in message {\n        let index = alphabet.characters.index(of: char)\n\
    \        let charBefore = alphabet.characters[index-1]\n        let charAfter\
    \ = alphabet.characters[index+1]\n        switch char {\n        case \"a\" ...\
    \ \"z\" where charBefore == \"a\" ... \"z\":\n            result += \"T\"\n  \
    \      case \"A\" ... \"Z\" where charBefore == \"A\" ... \"Z\":\n           \
    \ result += \"t\"\n        case \"0\" ... \"9\" where charBefore == \"0\" ...\
    \ \"9\":\n            result += \"k\"\n        default:\n            result +=\
    \ char\n        }\n    }\n    return result", '    return encode(message, lettersGuessed:
    lettersGuessed)', "    return message.map {\n        switch $0 {\n        case\
    \ \"A\": return \"a\"\n        case \"B\": return \"b\"\n        case \"C\": return\
    \ \"c\"\n        case \"D\": return \"d\"\n        case \"E\": return \"e\"\n\
    \        case \"F\": return \"f\"\n        case \"G\": return \"g\"\n        case\
    \ \"H\": return \"h\"\n        case \"I\": return \"i\"\n        case \"J\": return\
    \ \"j\"\n        case \"K\": return \"k\"\n        case \"L\": return \"l\"\n\
    \        case \"M\": return \"m\"\n        case \"N\": return \"n\"\n        case\
    \ \"O\": return \"o\"\n        case \"P\": return \"p\"\n        case \"Q\": return\
    \ \"q\"\n        case \"R\": return \"r\"\n        case \"S\": return \"s\"\n\
    \        case \"T\": return \"t\"\n        case \"U\": return \"u\"\n        case\
    \ \"V\": return \"v\"\n        case \"W\": return \"w\"\n        case \"X\": return\
    \ \"x\"\n        case \"Y\": return \"y\"\n        case \"Z\": return \"z\"\n\
    \        case \"a\": return \"a\"\n        case \"b\": return \"b\"\n        case\
    \ \"c\": return \"c\"\n        case \"d\": return \"d\"\n        case \"e\": return\
    \ \"e\"\n        case \"f\": return \"f\"\n        case \"g\": return \"g\"\n\
    \        case \"h\": return \"h\"\n        case \"i\": return \"i\"\n        case\
    \ \"j\": return \"j\"\n        case \"k\": return \"k\"\n        case \"l\": return\
    \ \"l\"\n        case \"m\": return \"m\"\n        case \"n\": return \"n\"\n\
    \        case \"o\": return \"o\"\n        case \"p\": return \"p\"\n        case\
    \ \"q\": return \"q\"\n        case \"r\": return \"r\"\n        case \"s\": return\
    \ \"s\"\n        case \"t\": return \"t\"\n        case \"u\": return \"u\"\n\
    \        case \"v\": return \"v\"\n        case \"w\": return \"w\"\n        case\
    \ \"x\": return \"x\"\n        case \"y\": return \"y\"\n        case \"z\": return\
    \ \"z\"\n        default:\n            if let vowel = UnicodeScalar($0).unicodeScalars.filter({\
    \ $0.value > 0 && $0.value < 256 }).first {\n                return String(repeatElement(vowel,\
    \ count: 2))\n            } else {\n                return String($0)\n      \
    \      }\n        }\n    }.reduce(\"\", +)", "    return message.unicodeScalars\n\
    \        .map { unicodeScalar: UnicodeScalar in\n            let lowerCase = unicodeScalar.value.lowercased\n\
    \            let index = lowercase[lowercase.length - 1]\n            if index\
    \ == \"e\" {\n                return \"a\" // lowerCase is \"\xE6\"\n        \
    \    } else if index == \"i\" {\n                return \"o\" // lowerCase is\
    \ \"\xEF\"\n            } else if index == \"a\" {\n                return \"\
    e\" // lowerCase is \"\xE5\"\n            } else if index == \"o\" {\n       \
    \         return \"i\" // lowerCase is \"\xF4\"\n            } else {\n      \
    \          return \"o\" // lowerCase is \"\xF8\"\n            }\n        }\n \
    \       .joined()", "    return message\n        .stringByReplacingOccurrencesOfString(\n\
    \            \"aeiouAEIOU\", withString: \"\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"aAeiouAEIOU\", withString: \"e\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"yYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"AAYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"uUyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"AUYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"UuyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"UUyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YYYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YYAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"YyAEIOU\", withString: \"i\", options: NSStringCompareOptions.CaseInsensitive,\n\
    \            range: nil)\n        .stringByReplacingOccurrencesOfString(\n   \
    \         \"uUy", "    var result = \"\"\n    var vowels = String()\n    for char\
    \ in message {\n        let unicodeScalar = char.unicodeScalars.first!\n     \
    \   \n        if unicodeScalar.value > 0x5F { // A consonant\n            let\
    \ index = unicodeScalar.value - 0x5F\n            result += \"K\" + String(UnicodeScalar(index).value)\n\
    \        } else if unicodeScalar.value > 0x41 { // A vowel\n            let index\
    \ = unicodeScalar.value - 0x41\n            result += \"t\" + String(UnicodeScalar(index).value)\n\
    \            vowels += String(UnicodeScalar(index).value)\n        } else { //\
    \ A letter\n            result += String(unicodeScalar.value)\n        }\n   \
    \ }\n    if vowels.count > 0 {\n        result += String(UnicodeScalar(vowels.unicodeScalars.first!.value).value)\n\
    \    }\n    return result", "    \n    var encoded = \"\"\n    \n    for character\
    \ in message {\n        \n        switch character {\n            \n        case\
    \ \" \":\n            encoded += \"S\"\n            \n        case \"a\":\n  \
    \          encoded += \"T\"\n            \n        case \"b\":\n            encoded\
    \ += \"G\"\n            \n        case \"c\":\n            encoded += \"C\"\n\
    \            \n        case \"d\":\n            encoded += \"Y\"\n           \
    \ \n        case \"e\":\n            encoded += \"S\"\n            \n        case\
    \ \"f\":\n            encoded += \"G\"\n            \n        case \"g\":\n  \
    \          encoded += \"C\"\n            \n        case \"h\":\n            encoded\
    \ += \"K\"\n            \n        case \"i\":\n            encoded += \"M\"\n\
    \            \n        case \"j\":\n            encoded += \"K\"\n           \
    \ \n        case \"k\":\n            encoded += \"K\"\n            \n        case\
    \ \"l\":\n            encoded += \"K\"\n            \n        case \"m\":\n  \
    \          encoded += \"K\"\n            \n        case \"n\":\n            encoded\
    \ += \"C\"\n            \n        case \"o\":\n            encoded += \"C\"\n\
    \            \n        case \"p\":\n            encoded += \"S\"\n           \
    \ \n        case \"q\":\n            encoded += \"G\"\n            \n        case\
    \ \"r\":\n            encoded += \"C\"\n            \n        case \"s\":\n  \
    \          encoded += \"S\"\n            \n        case \"t\":\n            encoded\
    \ += \"T\"\n            \n        case \"u\":\n            encoded += \"S\"\n\
    \            \n        case \"v\":\n            encoded += \"G\"\n           \
    \ \n        case \"w\":\n            encoded += \"C\"\n            \n        case\
    \ \"x\":\n            encoded += \"G\"\n            \n        case \"y\":\n  \
    \          encoded += \"C\"\n            \n        case \"z\":\n            encoded\
    \ += \"C\"\n            \n        default:\n            \n            if isLetter(character)\
    \ {\n                \n                let currentPosition = countVowels(character)\n\
    \                \n                if currentPosition == 0 {\n               \
    \     \n                    encoded += character\n                    \n     \
    \           } else if currentPosition == 1 { //first vowel in the word\n     \
    \               \n                    let firstVowelPosition = currentPosition\
    \ - 1\n                    \n                    let firstVowel = message[firstVowelPosition]\n\
    \                    \n                    let secondVowelPosition = currentPosition\
    \ + 2\n                    \n                    let secondVowel = message[secondVowelPosition]\n\
    \                    \n                    if firstVowel == secondVowel {\n  \
    \                      \n                        encoded += firstVow", "    //\
    \ Your code here\n    if let messageCount = message.count {\n        let result\
    \ = \"\"\n        for i in 0..<messageCount {\n            let currentCharacter\
    \ = message[i]\n            let nextCharacter = message[i+1]\n\n            if\
    \ currentCharacter.isUppercase {\n                result += nextCharacter.uppercaseString\n\
    \            } else if currentCharacter.isLowercase {\n                result\
    \ += nextCharacter.lowercaseString\n            } else {\n                result\
    \ += currentCharacter\n            }\n        }\n        return result\n    }\
    \ else {\n        return message\n    }", "    var result = \"\"\n    let vowels\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n\n    for (index, char) in message.characters\
    \ {\n        if let vowelIndex = vowels.indexOf(char) {\n            let aChar\
    \ = String(vowels[vowelIndex+1])\n            let bChar = String(vowels[vowelIndex-1])\n\
    \n            let letterIndex = index(of: aChar)!\n            let letterIndex\
    \ = index(of: bChar)!\n            let newChar = String(vowels[letterIndex])\n\
    \            result += newChar\n        }\n        else {\n            let letterIndex\
    \ = index(of: char)!\n            let newChar = String(vowels[letterIndex])\n\
    \            result += newChar\n        }\n    }\n\n    return result", "    return\
    \ message\n        .map{ $0.lowercased() }\n        .map{ $0.replaceAll(\"a\"\
    , \"t\") }\n        .map{ $0.replaceAll(\"e\", \"h\") }\n        .map{ $0.replaceAll(\"\
    i\", \"k\") }\n        .map{ $0.replaceAll(\"o\", \"s\") }\n        .map{ $0.replaceAll(\"\
    u\", \"g\") }\n        .map{ $0.replaceAll(\"w\", \"w\") }\n        .map{ $0.replaceAll(\"\
    y\", \"k\") }\n        .map{ $0.replaceAll(\"b\", \"g\") }\n        .map{ $0.replaceAll(\"\
    l\", \"s\") }\n        .map{ $0.replaceAll(\"n\", \"k\") }\n        .map{ $0.replaceAll(\"\
    m\", \"c\") }\n        .map{ $0.replaceAll(\"s\", \"y\") }\n        .map{ $0.replaceAll(\"\
    c\", \"h\") }\n        .map{ $0.replaceAll(\"g\", \"s\") }\n        .map{ $0.replaceAll(\"\
    h\", \"k\") }\n        .map{ $0.replaceAll(\"k\", \"h\") }\n        .map{ $0.replaceAll(\"\
    d\", \"k\") }\n        .map{ $0.replaceAll(\"g\", \"s\") }\n        .map{ $0.replaceAll(\"\
    t\", \"a\") }\n        .map{ $0.replaceAll(\"j\", \"t\") }\n        .map{ $0.replaceAll(\"\
    z\", \"z\") }\n        .map{ $0.replaceAll(\"x\", \"g\") }\n        .map{ $0.replaceAll(\"\
    v\", \"g\") }\n        .map{ $0.replaceAll(\"z\", \"s\") }\n        .map{ $0.replaceAll(\"\
    z\", \"z\") }\n        .map{ $0.replaceAll(\"y\", \"s\") }\n        .map{ $0.replaceAll(\"\
    g\", \"t\") }\n        .map{ $0.replaceAll(\"s\", \"h\") }\n        .map{ $0.replaceAll(\"\
    c\", \"h\") }\n        .map{ $0.replaceAll(\"g\", \"s\") }\n        .map{ $0.replaceAll(\"\
    z\", \"t\") }\n        .map{ $0.replaceAll(\"d\", \"k\") }\n        .map{ $0.replaceAll(\"\
    g\", \"s\") }\n        .map{ $0.replaceAll(\"d\", \"h\") }\n        .map{ $0.replaceAll(\"\
    w\", \"w\") }\n        .map{ $0.replaceAll(\"y\", \"k\") }\n        .map{ $0.replaceAll(\"\
    a\", \"t\") }\n        .map", "    var encodedMessage = \"\"\n\n    for symbol\
    \ in message {\n        // Get the index of this symbol in the english alphabet.\
    \ \n        // If this symbol is not in the english alphabet, \n        // move\
    \ on to the next symbol. \n        let index = alphabet.index(of: symbol)\n  \
    \      if index == nil {\n            continue\n        }\n\n        // If this\
    \ symbol is a vowel, move on to the next symbol.\n        if symbol.isUppercase\
    \ {\n            encodedMessage += symbol\n            continue\n        }\n\n\
    \        // If this symbol is a lowercase letter, move on to the next symbol.\n\
    \        if symbol.isLowercase {\n            // If this symbol is before or at\
    \ the same index as this symbol\n            // on a vowel, then move on to the\
    \ next symbol.\n            if index == alphabet.index(of: symbol) {\n       \
    \         continue\n            }\n\n            // If this symbol is at the index\
    \ of this symbol on a vowel, \n            // then encode this symbol by swapping\
    \ case.\n            if alphabet[index!].isUppercase {\n                encodedMessage\
    \ += symbol\n                continue\n            }\n\n            // If this\
    \ symbol is at the index of this symbol on a lowercase \n            // letter,\
    \ encode this symbol by swapping case.\n            if alphabet[index!].isLowercase\
    \ {\n                encodedMessage += alphabet[index!]\n                continue\n\
    \            }\n        }\n\n        // If this symbol is neither a vowel nor\
    \ lowercase letter,\n        // move on to the next symbol.\n        encodedMessage\
    \ += symbol\n    }\n\n    return encodedMessage", "    // Write your code here\n\
    \    if message.isEmpty {\n        return \"\"\n    }\n    var enc = \"\"\n  \
    \  var prevLetter = \"\"\n    for char in message {\n        if char.isLetter()\
    \ {\n            if prevLetter.isUpper() {\n                enc += char.lowercaseString()\n\
    \            } else {\n                enc += char.uppercaseString()\n       \
    \     }\n        } else if char.isVowel() {\n            enc += char.lowercaseString()\n\
    \        } else {\n            enc += char\n        }\n        prevLetter = char\n\
    \    }\n    return enc", "    var result = [Character]()\n    for char in message\
    \ {\n        switch char {\n        case \"a\":\n            result.append(\"\
    b\")\n        case \"e\":\n            result.append(\"f\")\n        case \"i\"\
    :\n            result.append(\"g\")\n        case \"o\":\n            result.append(\"\
    h\")\n        case \"u\":\n            result.append(\"j\")\n        case \"y\"\
    :\n            result.append(\"k\")\n        default:\n            result.append(char)\n\
    \        }\n    }\n    var result = ArraySlice(result).map({ String($0) })\n \
    \   let newMessage = result.joinWithSeparator(\"\")\n    return newMessage", " \
    \   return message.\n        characters.\n        map { String($0) }.\n      \
    \  map({ \n            let x = Int($0);\n            let y = x % 2\n         \
    \   let z = (x - (y ?? 0)) / 2\n            return (y ? \"T\" : \"F\") + (z ?\
    \ \"H\" : \"M\")\n        }).\n        joined()", "    let map = [\n        \"\
    A\": \"A\",\n        \"A\": \"B\",\n        \"A\": \"C\",\n        \"A\": \"D\"\
    ,\n        \"A\": \"E\",\n        \"A\": \"F\",\n        \"A\": \"G\",\n     \
    \   \"A\": \"H\",\n        \"A\": \"I\",\n        \"A\": \"J\",\n        \"A\"\
    : \"K\",\n        \"A\": \"L\",\n        \"A\": \"M\",\n        \"A\": \"N\",\n\
    \        \"A\": \"O\",\n        \"A\": \"P\",\n        \"A\": \"Q\",\n       \
    \ \"A\": \"R\",\n        \"A\": \"S\",\n        \"A\": \"T\",\n        \"A\":\
    \ \"U\",\n        \"A\": \"V\",\n        \"A\": \"W\",\n        \"A\": \"X\",\n\
    \        \"A\": \"Y\",\n        \"A\": \"Z\",\n        \"B\": \"B\",\n       \
    \ \"B\": \"C\",\n        \"B\": \"D\",\n        \"B\": \"E\",\n        \"B\":\
    \ \"F\",\n        \"B\": \"G\",\n        \"B\": \"H\",\n        \"B\": \"I\",\n\
    \        \"B\": \"J\",\n        \"B\": \"K\",\n        \"B\": \"L\",\n       \
    \ \"B\": \"M\",\n        \"B\": \"N\",\n        \"B\": \"O\",\n        \"B\":\
    \ \"P\",\n        \"B\": \"Q\",\n        \"B\": \"R\",\n        \"B\": \"S\",\n\
    \        \"B\": \"T\",\n        \"B\": \"U\",\n        \"B\": \"V\",\n       \
    \ \"B\": \"W\",\n        \"B\": \"X\",\n        \"B\": \"Y\",\n        \"B\":\
    \ \"Z\",\n        \"C\": \"C\",\n        \"C\": \"D\",\n        \"C\": \"E\",\n\
    \        \"C\": \"F\",\n        \"C\": \"G\",\n        \"C\": \"H\",\n       \
    \ \"C\": \"I\",\n        \"C\": \"J\",\n        \"C\": \"K\",\n        \"C\":\
    \ \"L\",\n        \"C\": \"M\",\n        \"C\": \"N\",\n        \"C\": \"O\",\n\
    \        \"C\": \"P\",\n        \"C\": \"Q\",\n        \"C\": \"R\",\n       \
    \ \"C\": \"S\",\n        \"C\": \"T\",\n        \"C\": \"U\",\n        \"C\":\
    \ \"V\",\n        \"C\": \"W\",\n        \"C\": \"X\",\n        \"C\": \"Y\",\n\
    \        \"C\": \"Z\",\n        \"D\": \"D\",\n        \"D\": \"E\",\n       \
    \ \"D\": \"F\",\n        \"D\": \"G\",\n        \"D\": \"H\",\n        \"D\":\
    \ \"I\",\n        \"D\": \"J\",\n        \"D\": \"K\",\n        \"D\": \"L\",\n\
    \        \"D\": \"M\",\n        \"D\": \"N\",\n        \"D\": \"O\",\n       \
    \ \"D\": \"P\",\n        \"D\": \"Q\",\n        \"D\": \"R\",\n        \"D\":\
    \ \"S\",\n        \"", "    \n    return message", "    return message.characters.map\
    \ {\n        letter in letter.lowercaseString.characters.map {\n            if\
    \ letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" {\n\
    \                letter = letter + \"b\"\n            }\n            if letter\
    \ == \"u\" || letter == \"i\" || letter == \"o\" {\n                letter = letter\
    \ + \"v\"\n            }\n            if letter == \"a\" || letter == \"e\" ||\
    \ letter == \"i\" || letter == \"o\" {\n                letter = letter + \"h\"\
    \n            }\n            if letter == \"u\" || letter == \"i\" || letter ==\
    \ \"o\" {\n                letter = letter + \"j\"\n            }\n          \
    \  if letter == \"u\" || letter == \"i\" || letter == \"o\" {\n              \
    \  letter = letter + \"s\"\n            }\n            return letter\n       \
    \ }.joined()\n    }.joined()", "    var encString = \"\"\n    for _ in message.unicodeScalars\
    \ {\n        switch self {\n        case .vowel:\n            encString = encString\
    \ + String.UnicodeScalarView(message)\n        case .consonant:\n            switch\
    \ {\n            case (encString.unicodeScalars.index(of: unicodeScalar.vowel)\
    \ == (encString.unicodeScalars.endIndex - 1)) && encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) != 0\n                || (encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) != (encString.unicodeScalars.endIndex - 1)) && encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) == 0\n                || (encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) != (encString.unicodeScalars.endIndex - 1)) && encString.unicodeScalars.index(of:\
    \ unicodeScalar.vowel) == (encString.unicodeScalars.endIndex - 1)\n          \
    \      || (encString.unicodeScalars.index(of: unicodeScalar.vowel) != (encString.unicodeScalars.endIndex\
    \ - 1)) && encString.unicodeScalars.index(of: unicodeScalar.vowel) != (encString.unicodeScalars.endIndex\
    \ - 2)\n            , let index = encString.unicodeScalars.index(of: unicodeScalar.vowel)\
    \ {\n                encString = encString + String.UnicodeScalarView(message)[index]\n\
    \            }\n            default:\n                encString = encString +\
    \ String.UnicodeScalarView(message)\n            }\n        }\n    }\n    return\
    \ encString", "\tlet vowels = \"aeiouAEIOU\".makeIterator()\n\n\tlet indexes =\
    \ (0..<message.characters.count).filter { message[$0] == nil }\n\tvar encodedMessage\
    \ = \"\"\n\n\tfor index in indexes {\n\t\tlet currentChar = message[index]\n\n\
    \t\tlet nextChar = vowels.next().element ?? currentChar\n\n\t\tif currentChar\
    \ == nextChar {\n\t\t\tencodedMessage += nextChar\n\t\t} else {\n\t\t\tencodedMessage\
    \ += String(Int(nextChar) - Int(currentChar))\n\t\t}\n\t}\n\n\treturn encodedMessage",
  "    var result: String = \"\"\n    var lastLetter = \"\"\n    for letter in message\
    \ {\n        if letter.isUppercase {\n            if lastLetter == letter {\n\
    \                // first letter is a capital, keep it\n                result\
    \ += \"A\" + lastLetter\n            } else {\n                // first letter\
    \ isn't a capital, keep it\n                result += \"a\" + lastLetter\n   \
    \         }\n        } else {\n            if lastLetter == letter {\n       \
    \         // last letter is a capital, keep it\n                result += letter\n\
    \            } else {\n                // last letter isn't a capital, keep it\n\
    \                result += letter + lastLetter\n            }\n        }\n   \
    \     lastLetter = letter\n    }\n    return result", "    var msgArr = message.characters\n\
    \    \n    func isVowel(c: unichar) -> Bool {\n        var iArr = c.unicodeScalars\n\
    \        for u in iArr {\n            switch u.scalarValue {\n            case\
    \ 0x2BC: // yes this is really a vowel\n                return true\n        \
    \    case 0x2D0: // 0\n            case 0x2D9: // 9\n                return false\n\
    \            default:\n                break\n            }\n        }\n     \
    \   return false\n    }\n    \n    func encodeWithLettersBehindVowels(c1: unichar,\
    \ c2: unichar) -> unichar {\n        switch c1 {\n        case 0x30A0: // Zero\
    \ width joiner\n            return c2\n        case 0x30F0: // Latin small letter\
    \ z\n            return 0x2D0\n        case 0x30A1: // Zero width non-joiner\n\
    \            return 0x2D9\n        default:\n            return c1\n        }\n\
    \    }\n    \n    func encode(char: unichar) -> unichar {\n        switch char\
    \ {\n        case 0x30F0: // Latin small letter z\n            return 0x2D0\n\
    \        case 0x30A1: // Zero width non-joiner\n            return 0x2D9\n   \
    \     case 0x30A0: // Zero width joiner\n            return 0x2D0\n        default:\n\
    \            return char\n        }\n    }\n    \n    func encodeWithLettersBeforeVowels(char1:\
    \ unichar) -> unichar {\n        switch char1 {\n        case 0x30F0: // Latin\
    \ small letter z\n            return 0x2D0\n        case 0x30A1: // Zero width\
    \ non-joiner\n            return 0x2D9\n        case 0x30A0: // Zero width joiner\n\
    \            return 0x2D0\n        default:\n            return char1\n      \
    \  }\n    }\n    \n    func encodeWithLettersAfterVowels(char1: unichar) -> unichar\
    \ {\n        switch char1 {\n        case 0x30F0: // Latin small letter z\n  \
    \          return 0x2D0\n        case 0x30A1: // Zero width non-joiner\n     \
    \       return 0x2D9\n        case 0x30A0: // Zero width joiner\n            return\
    \ 0x2D0\n        default:\n            return char1\n        }\n    }\n    \n\
    \    func encodeWithLettersBeforeVowelsAndLettersAfterVowels(char1: unichar, char2:\
    \ unichar) -> unichar {\n        switch char1 {\n        case 0x30F0: // Latin\
    \ small letter z\n            return 0x2D0\n        case ", "    guard let letters\
    \ = message.characters\n        else { return \"\" }\n    let vowels = CharacterSet.vowels\n\
    \    return String(\n        letters.map { character in\n            let upperCasedCharacter\
    \ = Character(character).uppercased()\n            let i = vowels.index(of: upperCasedCharacter)!\n\
    \            let doubleVowels = Character(characters.suffix(from: i)!).uppercased()\n\
    \            return upperCasedCharacter + doubleVowels\n        }\n    )", " \
    \   var encodedString = \"\"\n    for i in 0..<message.characters.count {\n  \
    \      let char = message.characters[i]\n        let vowelIndex = Character.ascii(char)\n\
    \        if vowelIndex != 0 || i != 0 {\n            encodedString += String(char)\n\
    \            continue\n        }\n        let lowerChar = String(char).lowercased()\n\
    \        let lowerIndex2 = Character.ascii(lowerChar)\n        let vowelIndex2\
    \ = Character.ascii(char.lowercased())\n        switch vowelIndex {\n        case\
    \ vowelIndex2, vowelIndex + 1:\n            encodedString += String(char)\n  \
    \      case vowelIndex + 2:\n            encodedString += String(lowerChar)\n\
    \        default:\n            encodedString += String(char.lowercased())\n  \
    \      }\n    }\n    return encodedString", "    var encodedMessage = \"\"\n \
    \   for character in message {\n        let index = alphabet.index(of: character)\n\
    \        switch character {\n        case \"a\":\n            encodedMessage +=\
    \ \"B\"\n        case \"b\":\n            encodedMessage += \"b\"\n        case\
    \ \"c\":\n            encodedMessage += \"C\"\n        case \"d\":\n         \
    \   encodedMessage += \"D\"\n        case \"e\":\n            encodedMessage +=\
    \ \"E\"\n        case \"f\":\n            encodedMessage += \"F\"\n        case\
    \ \"g\":\n            encodedMessage += \"G\"\n        case \"h\":\n         \
    \   encodedMessage += \"H\"\n        case \"i\":\n            encodedMessage +=\
    \ \"I\"\n        case \"j\":\n            encodedMessage += \"J\"\n        case\
    \ \"k\":\n            encodedMessage += \"K\"\n        case \"l\":\n         \
    \   encodedMessage += \"L\"\n        case \"m\":\n            encodedMessage +=\
    \ \"M\"\n        case \"n\":\n            encodedMessage += \"N\"\n        case\
    \ \"o\":\n            encodedMessage += \"O\"\n        case \"p\":\n         \
    \   encodedMessage += \"P\"\n        case \"q\":\n            encodedMessage +=\
    \ \"Q\"\n        case \"r\":\n            encodedMessage += \"R\"\n        case\
    \ \"s\":\n            encodedMessage += \"S\"\n        case \"t\":\n         \
    \   encodedMessage += \"T\"\n        case \"u\":\n            encodedMessage +=\
    \ \"U\"\n        case \"v\":\n            encodedMessage += \"V\"\n        case\
    \ \"w\":\n            encodedMessage += \"W\"\n        case \"x\":\n         \
    \   encodedMessage += \"X\"\n        case \"y\":\n            encodedMessage +=\
    \ \"Y\"\n        case \"z\":\n            encodedMessage += \"Z\"\n        default:\n\
    \            encodedMessage += character\n        }\n    }\n    return encodedMessage",
  "    // TODO: Complete this function.\n    return \"\"", "    return message.map\
    \ { letter in \n        var first = letter.first\n        var second = letter.first\n\
    \        var third = letter.first\n        \n        if letter == first {\n  \
    \          return letter\n        } else if letter == second {\n            first\
    \ = letter.second\n            return first\n        } else if letter == third\
    \ {\n            second = letter.second\n            third = letter.second\n \
    \           return second\n        } else {\n            first = (first + second)\
    \ mod 26\n            second = (first + second) mod 26\n            third = (first\
    \ + second) mod 26\n            return String.fromCharCode(first+65) + String.fromCharCode(second+65)\
    \ + String.fromCharCode(third+65)\n        }\n    }.joinWithSeparator(\"\").capitalized",
  "\talphabetLetters.forEach { (letter) in\n\t\tlet nextLetter = message[message.index(message.startIndex,\
    \ offsetBy: 1)].lowercased()\n\t\tswitch letter{\n\t\tcase \"a\",\"e\",\"i\",\"\
    o\",\"u\":\n\t\t\tlet nextVowel = message[message.index(message.startIndex, offsetBy:\
    \ 2)].lowercased()\n\t\t\tlet nextVowelIndex = alphabetLetters.firstIndex(of:\
    \ nextVowel)!\n\t\t\tlet newLetter = alphabetLetters[nextVowelIndex]\n\t\t\tlet\
    \ newLetterIndex = alphabetLetters.index(of: newLetter)!\n\t\t\tlet oldIndex =\
    \ message.index(message.startIndex, offsetBy: 0)\n\t\t\tlet newValue = String(message.characters.dropFirst().map\
    \ { $0 == \"a\" || $0 == \"e\" || $0 == \"i\" || $0 == \"o\" || $0 == \"u\" ?\
    \ (oldIndex + newLetterIndex + 2) : Character($0) })\n\t\t\tlet newMessage = newValue.trimmingCharacters(in:\
    \ .whitespaces)\n\t\t\tlet oldMessage = message\n\t\t\tmessage = newMessage\n\t\
    \t\tnextLetter = newLetter\n\t\t\tnextVowel = newVowel\n\t\tdefault:\n\t\t\tbreak\n\
    \t\t}\n\t}\n\treturn message", "    var encoded = \"\"\n    for i in 0..<message.count\
    \ {\n        var currentVowel = message[i]\n        if !isVowel(currentVowel)\
    \ {\n            currentVowel = lowercaseLetters[(alphabet.indexOf(currentVowel)!\
    \ + 1)]\n        }\n        var nextVowel = message[i]\n        if isVowel(nextVowel)\
    \ {\n            nextVowel = lowercaseLetters[(alphabet.indexOf(nextVowel)! +\
    \ 1)]\n        }\n        var index = alphabet.indexOf(currentVowel)! + 1\n  \
    \      encoded = encoded.appending(\"\\(nextVowel)\", separator: \"\").appending(\"\
    \\(currentVowel)\", separator: \"\")\n    }\n    return encoded", "\tlet messageArray\
    \ = message.characters\n\t\n\tlet vowel = \"A\" \n\t\n\tlet vowelIndex = messageArray.index(of:\
    \ vowel!)\n\t\n\tlet swapCaseArray = [ \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"\
    g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"\
    t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\t\n\tlet swapCaseIndex = swapCaseArray.index(of:\
    \ messageArray[vowelIndex!])!\n\n\treturn String(messageArray[vowelIndex!].stringByReplacingOccurrencesOfString(String(swapCaseArray[swapCaseIndex]),\
    \ withString: String(swapCaseArray[swapCaseIndex+1])!))", "    var result = \"\
    \"\n    \n    for letter in message {\n        result += \"tHKS\"\n        if\
    \ letter == \"A\" {\n            result += \"a\"\n        } else if letter ==\
    \ \"B\" {\n            result += \"b\"\n        } else if letter == \"C\" {\n\
    \            result += \"c\"\n        } else if letter == \"D\" {\n          \
    \  result += \"d\"\n        } else if letter == \"E\" {\n            result +=\
    \ \"e\"\n        } else if letter == \"F\" {\n            result += \"f\"\n  \
    \      } else if letter == \"G\" {\n            result += \"g\"\n        } else\
    \ if letter == \"H\" {\n            result += \"h\"\n        } else if letter\
    \ == \"I\" {\n            result += \"i\"\n        } else if letter == \"J\" {\n\
    \            result += \"j\"\n        } else if letter == \"K\" {\n          \
    \  result += \"k\"\n        } else if letter == \"L\" {\n            result +=\
    \ \"l\"\n        } else if letter == \"M\" {\n            result += \"m\"\n  \
    \      } else if letter == \"N\" {\n            result += \"n\"\n        } else\
    \ if letter == \"O\" {\n            result += \"o\"\n        } else if letter\
    \ == \"P\" {\n            result += \"p\"\n        } else if letter == \"Q\" {\n\
    \            result += \"q\"\n        } else if letter == \"R\" {\n          \
    \  result += \"r\"\n        } else if letter == \"S\" {\n            result +=\
    \ \"s\"\n        } else if letter == \"T\" {\n            result += \"t\"\n  \
    \      } else if letter == \"U\" {\n            result += \"u\"\n        } else\
    \ if letter == \"V\" {\n            result += \"v\"\n        } else if letter\
    \ == \"W\" {\n            result += \"w\"\n        } else if letter == \"X\" {\n\
    \            result += \"x\"\n        } else if letter == \"Y\" {\n          \
    \  result += \"y\"\n        } else if letter == \"Z\" {\n            result +=\
    \ \"z\"\n        } else {\n            result += letter\n        }\n    }\n  \
    \  \n    return result", "    let countOfA: String = \"a\".unicodeScalars.filter{$0.isUpper}.count\n\
    \    let countOfE: String = \"e\".unicodeScalars.filter{$0.isUpper}.count\n  \
    \  let countOfI: String = \"i\".unicodeScalars.filter{$0.isUpper}.count\n    let\
    \ countOfO: String = \"o\".unicodeScalars.filter{$0.isUpper}.count\n    let countOfU:\
    \ String = \"u\".unicodeScalars.filter{$0.isUpper}.count\n    let countOfIJKLMNOP:\
    \ String = \"ijklmnop\".unicodeScalars.filter{$0.isUpper}.count\n    let countOfBCDGHJKL:\
    \ String = \"bcdefghjkl\".unicodeScalars.filter{$0.isUpper}.count\n    \n    switch\
    \ message {\n    case \"a\":\n        return \"t\"\n    case \"b\":\n        return\
    \ \"b\"\n    case \"c\":\n        return \"k\"\n    case \"d\":\n        return\
    \ \"d\"\n    case \"e\":\n        return \"k\"\n    case \"f\":\n        return\
    \ \"m\"\n    case \"g\":\n        return \"g\"\n    case \"h\":\n        return\
    \ \"h\"\n    case \"i\":\n        return \"h\"\n    case \"j\":\n        return\
    \ \"h\"\n    case \"k\":\n        return \"k\"\n    case \"l\":\n        return\
    \ \"s\"\n    case \"m\":\n        return \"g\"\n    case \"n\":\n        return\
    \ \"g\"\n    case \"o\":\n        return \"c\"\n    case \"p\":\n        return\
    \ \"c\"\n    case \"q\":\n        return \"c\"\n    case \"r\":\n        return\
    \ \"c\"\n    case \"s\":\n        return \"gs\"\n    case \"t\":\n        return\
    \ \"t\"\n    case \"u\":\n        return \"u\"\n    case \"v\":\n        return\
    \ \"v\"\n    case \"w\":\n        return \"w\"\n    case \"x\":\n        return\
    \ \"x\"\n    case \"y\":\n        return \"y\"\n    case \"z\":\n        return\
    \ \"z\"\n    case \"A\":\n        return \"T\"\n    case \"B\":\n        return\
    \ \"B\"\n    case \"C\":\n        return \"K\"\n    case \"D\":\n        return\
    \ \"D\"\n    case \"E\":\n        return \"K\"\n    case \"F\":\n        return\
    \ \"M\"\n    case \"G\":\n        return \"G\"\n    case \"H\":\n        return\
    \ \"H\"\n    case \"I\":\n        return \"H\"\n    case \"J\":\n        return\
    \ \"H\"\n    case \"K\":\n        return \"K\"\n    case \"L\":\n        return\
    \ \"S\"\n    case \"M\":\n        return \"G\"\n    case \"N\":\n        return\
    \ \"G\"\n    case \"O\":\n        return \"C\"\n    case \"P\":\n", "\tlet alphabet\
    \ = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"\
    M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"\
    Z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"\
    m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"\
    z\"]\n\tlet vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n\tlet replacedLetters =\
    \ [\n\t\t[\"e\", \"e\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"\
    a\", \"X\"], \n\t\t[\"o\", \"O\"], \n\t\t[\"i\", \"I\"], \n\t\t[\"u\", \"U\"],\
    \ \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"\
    u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"],\
    \ \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"\
    i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"],\
    \ \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"\
    o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"],\
    \ \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"\
    a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"],\
    \ \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"\
    u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"],\
    \ \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"], \n\t\t[\"\
    i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"o\", \"o\"],\
    \ \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"], \n\t\t[\"\
    o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"u\"], \n\t\t[\"a\", \"a\"],\
    \ \n\t\t[\"o\", \"o\"], \n\t\t[\"i\", \"i\"], \n\t\t[\"u\", \"", "    var result\
    \ = \"\"\n\n    for c in message {\n        let achar = String.fromCharCode(toInt64(c))\n\
    \        let achar2 = String.fromCharCode(toInt64(c + 1))\n        var achar3\
    \ = achar.lowercased()\n        achar3.removeAll(\"aeiou\")\n        achar3 =\
    \ achar3.replaceAll(with: achar2)\n        achar3 = achar3.lowercased()\n    \
    \    achar3 = achar3.replaceAll(with: \"a\")\n        achar3 = achar3.replaceAll(with:\
    \ \"e\")\n        achar3 = achar3.replaceAll(with: \"i\")\n        achar3 = achar3.replaceAll(with:\
    \ \"o\")\n        achar3 = achar3.replaceAll(with: \"u\")\n        achar3 = achar3.replaceAll(with:\
    \ \"A\")\n        achar3 = achar3.replaceAll(with: \"E\")\n        achar3 = achar3.replaceAll(with:\
    \ \"I\")\n        achar3 = achar3.replaceAll(with: \"O\")\n        achar3 = achar3.replaceAll(with:\
    \ \"U\")\n        achar3 = achar3.replaceAll(with: \"H\")\n        achar3 = achar3.replaceAll(with:\
    \ \"R\")\n        achar3 = achar3.replaceAll(with: \"L\")\n        achar3 = achar3.replaceAll(with:\
    \ \"Y\")\n        achar3 = achar3.replaceAll(with: \"S\")\n        achar3 = achar3.replaceAll(with:\
    \ \"W\")\n        achar3 = achar3.replaceAll(with: \"G\")\n        achar3 = achar3.replaceAll(with:\
    \ \"V\")\n        achar3 = achar3.replaceAll(with: \"H\")\n        achar3 = achar3.replaceAll(with:\
    \ \"D\")\n        achar3 = achar3.replaceAll(with: \"O\")\n        achar3 = achar3.replaceAll(with:\
    \ \"R\")\n        achar3 = achar3.replaceAll(with: \"L\")\n        achar3 = achar3.replaceAll(with:\
    \ \"W\")\n        achar3 = achar3.replaceAll(with: \"Y\")\n        achar3 = achar3.replaceAll(with:\
    \ \"X\")\n        achar3 = achar3.replaceAll(with: \"Z\")\n        achar3 = achar3.replaceAll(with:\
    \ \"Z\")\n        achar3 = achar3.replaceAll(with: \"Y\")\n        achar3 = achar3.replaceAll(with:\
    \ \"W\")\n        achar3 = achar3.replaceAll(with: \"G\")\n        achar3 = achar3.replaceAll(with:\
    \ \"W\")\n        achar3 = achar3.replaceAll(with: \"Y\")\n        achar3 = achar",
  "    // write your code in here\n    let vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"\
    ]\n    let alpha = \"abcdefghijklmnopqrstuvwxyz\"\n    var encodedMessage = \"\
    \"\n    for character in message {\n        if let index = vowels.indexOf(character)\
    \ {\n            let replacement = alpha[Int(index)+2]\n            encodedMessage\
    \ += replacement\n        } else {\n            encodedMessage += character\n\
    \        }\n    }\n    return encodedMessage", "\tvar messageArray: [Character]\
    \ = [Character]()\n\tvar j = 0\n\tvar newMessage = \"\"\n\tfor var i = 0; i <\
    \ message.characters.count; i++ {\n\t\tlet letter = message.characters[i]\n\t\t\
    if letter == ' ' {\n\t\t\tnewMessage.append(\" \")\n\t\t} else if letter.isUpperCase\
    \ {\n\t\t\tnewMessage.append(letter)\n\t\t} else {\n\t\t\tmessageArray.append(letter)\n\
    \t\t}\n\t}\n\tvar i = 0\n\tvar currentLetter = messageArray[i]\n\t\n\twhile i\
    \ < messageArray.count {\n\t\tif i + 1 < messageArray.count {\n\t\t\tlet secondLetter\
    \ = messageArray[i + 1]\n\t\t\tif secondLetter == \"A\" {\n\t\t\t\tcurrentLetter\
    \ = \"a\"\n\t\t\t} else if secondLetter == \"E\" {\n\t\t\t\tcurrentLetter = \"\
    e\"\n\t\t\t} else if secondLetter == \"I\" {\n\t\t\t\tcurrentLetter = \"i\"\n\t\
    \t\t} else if secondLetter == \"O\" {\n\t\t\t\tcurrentLetter = \"o\"\n\t\t\t}\
    \ else if secondLetter == \"U\" {\n\t\t\t\tcurrentLetter = \"u\"\n\t\t\t}\n\t\t\
    }\n\t\tnewMessage.append(currentLetter)\n\t\ti = i + 1\n\t}\n\treturn newMessage",
  "    // TODO: fill this in\n    return \"\"", "    var alphabet = [String]()\n \
    \   var vowels = [String]()\n\n    for letter in message {\n        switch letter\
    \ {\n        case \"a\":\n            alphabet.append(\"a\")\n        case \"\
    e\":\n            alphabet.append(\"e\")\n        case \"i\":\n            alphabet.append(\"\
    i\")\n        case \"o\":\n            alphabet.append(\"o\")\n        case \"\
    u\":\n            alphabet.append(\"u\")\n        case \"y\":\n            alphabet.append(\"\
    y\")\n        default:\n            continue\n        }\n    }\n\n    for letter\
    \ in message {\n        switch letter {\n        case \"a\":\n            if alphabet.count\
    \ > 0 {\n                vowels.append(alphabet[alphabet.count - 2])\n       \
    \         alphabet.removeLast()\n            } else {\n                continue\n\
    \            }\n        case \"e\":\n            if alphabet.count > 0 {\n   \
    \             vowels.append(alphabet[alphabet.count - 2])\n                alphabet.removeLast()\n\
    \            } else {\n                continue\n            }\n        case \"\
    i\":\n            if alphabet.count > 0 {\n                vowels.append(alphabet[alphabet.count\
    \ - 2])\n                alphabet.removeLast()\n            } else {\n       \
    \         continue\n            }\n        case \"o\":\n            if alphabet.count\
    \ > 0 {\n                vowels.append(alphabet[alphabet.count - 2])\n       \
    \         alphabet.removeLast()\n            } else {\n                continue\n\
    \            }\n        case \"u\":\n            if alphabet.count > 0 {\n   \
    \             vowels.append(alphabet[alphabet.count - 2])\n                alphabet.removeLast()\n\
    \            } else {\n                continue\n            }\n        case \"\
    y\":\n            if alphabet.count > 0 {\n                vowels.append(alphabet[alphabet.count\
    \ - 2])\n                alphabet.removeLast()\n            } else {\n       \
    \         continue\n            }\n        default:\n            continue\n  \
    \      }\n    }\n\n    var message2 = \"\"\n    for letter in message {\n    \
    \    message2 += letter\n    }\n    var index = 0\n    for letter in message2\
    \ {\n        if letter == \"a\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"e\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"i\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"o\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"u\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        if letter == \"y\" {\n            message2 = message2.substringFromIndex(index)\n\
    \        }\n        index += 1\n    }\n\n    return message2", "    var newMessage\
    \ = \"\"\n    for i in 0..<message.count {\n        var x = message[i]\n     \
    \   var y = message[i]\n        if x < \"a\" || x > \"z\" {\n            newMessage\
    \ += \"z\"\n        }\n        else if x > \"A\" || x < \"Z\" {\n            newMessage\
    \ += \"A\"\n        }\n        \n        if x < \"a\" || y > \"z\" {\n       \
    \     newMessage += y\n        }\n        else if y > \"A\" || x < \"Z\" {\n \
    \           newMessage += x\n        }\n    }\n    \n    return newMessage", " \
    \   \n    let vowels = \"aeiouAEIOU\"\n    \n    guard !message.isEmpty else {\
    \ return \"\"}\n    \n    var stringBuilder = StringBuilder()\n    \n    var index\
    \ = 0\n    \n    while index < message.characters.count {\n        \n        let\
    \ currentChar = message.characters[index]\n        let currentCharIndex = string.Index(of:\
    \ currentChar)\n        \n        if currentCharIndex == nil {\n            break\n\
    \        }\n        \n        let nextChar = message.characters[index + 1]\n \
    \       let nextCharIndex = string.Index(of: nextChar)\n        \n        if nextCharIndex\
    \ == nil {\n            break\n        }\n        \n        let indexInMessage\
    \ = currentCharIndex! + 1 // the letter in the message\n        let indexInEnglish\
    \ = nextCharIndex! + 1 // the letter 2 places ahead\n        \n        guard indexInMessage\
    \ < message.characters.count else { return \"\"}\n        \n        guard indexInEnglish\
    \ < string.characters.count else { return \"\"}\n        \n        switch currentChar\
    \ {\n            \n        case \".\": stringBuilder.append(\".\")\n        case\
    \ \"!\": stringBuilder.append(\"!\")\n        case \"\\\"\": stringBuilder.append(\"\
    \\\"\")\n        case \"#\": stringBuilder.append(\"#\")\n        case \"$\":\
    \ stringBuilder.append(\"$\")\n        case \"%\": stringBuilder.append(\"%\"\
    )\n        case \"&\": stringBuilder.append(\"&\")\n        case \"'\": stringBuilder.append(\"\
    '\")\n        case \"(\": stringBuilder.append(\"(\")\n        case \")\": stringBuilder.append(\"\
    )\")\n        case \"*\": stringBuilder.append(\"*\")\n        case \"+\": stringBuilder.append(\"\
    +\")\n        case \",\": stringBuilder.append(\",\")\n        case \"-\": stringBuilder.append(\"\
    -\")\n        case \"/\": stringBuilder.append(\"/\")\n        case \":\": stringBuilder.append(\"\
    :\")\n        case \"<\": stringBuilder.append(\"<\")\n        case \">\": stringBuilder.append(\"\
    >\")\n        case \".\": stringBuilder.append(\".\")\n        case \"0\": stringBuilder.append(\"\
    0\")\n        case \"1\": stringBuilder.append(\"1\")\n        case \"2\": stringBuilder.append(\"\
    2\")\n        case \"3\": stringBuilder.append(\"3\")\n        case \"4\": stringBuilder.append(\"\
    4\")\n        case \"5\": stringBuilder.append(\"5\")\n        case \"6\": stringBuilder.append(\"\
    6\")\n        case \"7\": stringBuilder.append(\"7\")\n        case \"8\": stringBuilder.append(\"\
    8\")\n        case \"9\": stringBuilder.append(\"9\")\n        case \"0\": stringBuilder.append(\"\
    0\")\n        case \"", "    let len = message.count\n    var result = \"\"\n\
    \    for i in 0..<len {\n        let letter = message[i]\n        let letterIndex\
    \ = letterIndexOf(letter)\n        if (letterIndex < 0) || (letterIndex > message.count\
    \ - 2) {\n            continue\n        }\n        let letter2Index = letterIndexOf(message[letterIndex\
    \ + 1])\n        if (letter2Index < 0) || (letter2Index > message.count - 2) {\n\
    \            continue\n        }\n        let letter3 = message[letterIndex +\
    \ 1]\n        let letter4 = message[letter2Index]\n        var newLetter = letter\n\
    \        if (letter3 != \"a\") && letter3 != \"e\") && letter3 != \"i\") && letter3\
    \ != \"o\") && letter3 != \"u\" {\n            newLetter = \"\\(letter).\\(letter3)\"\
    \n        }\n        if (letter4 != \"a\") && letter4 != \"e\") && letter4 !=\
    \ \"i\") && letter4 != \"o\") && letter4 != \"u\" {\n            newLetter = \"\
    \\(letter).\\(letter4).\\(letter3)\"\n        }\n        result = result.appending(\"\
    \\(newLetter)\")\n    }\n    return result", "    var firstLetter: Character =\
    \ \"a\"\n    var secondLetter: Character = \"A\"\n    var thirdLetter: Character\
    \ = \"e\"\n    var fourthLetter: Character = \"E\"\n    var fifthLetter: Character\
    \ = \"i\"\n    var sixthLetter: Character = \"I\"\n    var seventhLetter: Character\
    \ = \"o\"\n    var eighthLetter: Character = \"O\"\n    var ninthLetter: Character\
    \ = \"u\"\n    var tenthLetter: Character = \"U\"\n    var firstVowel: Character\
    \ = \"a\"\n    var secondVowel: Character = \"A\"\n    var thirdVowel: Character\
    \ = \"e\"\n    var fourthVowel: Character = \"E\"\n    var fifthVowel: Character\
    \ = \"i\"\n    var sixthVowel: Character = \"I\"\n    var seventhVowel: Character\
    \ = \"o\"\n    var eighthVowel: Character = \"O\"\n    var ninthVowel: Character\
    \ = \"u\"\n    var tenthVowel: Character = \"U\"\n\n    var allLetters: [Character]\
    \ = [firstLetter, secondLetter, thirdLetter, fourthLetter, fifthLetter, sixthLetter,\
    \ seventhLetter, eighthLetter, ninthLetter, tenthLetter]\n    var allVowels: [Character]\
    \ = [firstVowel, secondVowel, thirdVowel, fourthVowel, fifthVowel, sixthVowel,\
    \ seventhVowel, eighthVowel, ninthVowel, tenthVowel]\n\n    var newMessage = String()\n\
    \n    for letter in message {\n        if allLetters.contains(letter) {\n    \
    \        newMessage += letter\n        } else if allVowels.contains(letter) {\n\
    \            newMessage += letter\n            switch letter{\n            case\
    \ \"a\":\n                newMessage = newMessage + firstVowel\n            case\
    \ \"A\":\n                newMessage = newMessage + secondVowel\n            case\
    \ \"e\":\n                newMessage = newMessage + thirdVowel\n            case\
    \ \"E\":\n                newMessage = newMessage + fourthVowel\n            case\
    \ \"i\":\n                newMessage = newMessage + fifthVowel\n            case\
    \ \"I\":\n                newMessage = newMessage + sixthVowel\n            case\
    \ \"o\":\n                newMessage = newMessage + seventhVowel\n           \
    \ case \"O\":\n                newMessage = newMessage + eighthVowel\n       \
    \     case \"u\":\n                newMessage = newMessage + n", "    var messageCopy\
    \ = message\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    for letter\
    \ in vowels {\n        messageCopy = messageCopy.replacingOccurrences(of: letter,\
    \ with: letters[letters.index(of: letter) + 2])\n    }\n    for letter in letters\
    \ {\n        let indexLetter = letters.index(of: letter)!\n        let indexVowel\
    \ = letters.index(of: \"a\")!\n        messageCopy = messageCopy.replacingOccurrences(of:\
    \ letter, with: letters[(indexLetter + (indexVowel - indexLetter)) - 1])\n   \
    \ }\n    return messageCopy", "\tlet letters = message.characters\n\tlet result\
    \ = \"\"\n\tvar index = messages.startIndex\n\twhile index < messages.endIndex\
    \ {\n\t\tlet value = message[index]\n\t\tlet letter = letters[index]\n\t\tlet\
    \ newLetter = letter // first letter of the alphabet\n\t\tif newLetter == \"a\"\
    \ || newLetter == \"i\" { // if the letter is not a vowel\n\t\t\tindex += 1 //\
    \ move to the next letter\n\t\t\tcontinue\n\t\t}\n\t\tif value.isLetterAndLowerCase()\
    \ { // if letter is a vowel\n\t\t\tnewLetter = String(index)\n\t\t\tindex += 1\
    \ // move to the next letter\n\t\t}\n\t\tif index != messages.startIndex {\n\t\
    \t\tresult += String(index)\n\t\t}\n\t\tresult += newLetter\n\t\tindex += 1 //\
    \ move to the next letter\n\t}\n\treturn result", "    let vowels = \"AEIOUaeiou\"\
    \n    var result = \"\"\n    for c in message {\n        if vowels.contains(String(format:\
    \ \"%C\", c)) {\n            var nextVowel = vowels.index(of: String(format: \"\
    %C\", c))!\n            result.append(String(format: \"%C\", c))\n           \
    \ result.append(String(format: \"%C\", next(string: message, currentIndex: nextVowel)))\n\
    \        } else {\n            result.append(String(format: \"%C\", c))\n    \
    \    }\n    }\n    return result", "    let letterIndexes = message.characters.map\
    \ { (letter, index) -> (char, Int) in\n        let firstVowelIndex = letters.firstIndex(of:\
    \ letter)\n        if firstVowelIndex == NSNotFound {\n            return letter,\
    \ index\n        } else {\n            let vowels = Array(letters[firstVowelIndex\
    \ ..< letterIndex])\n            let lastVowelIndex = letters.lastIndex(of: letter)\n\
    \            let count = lastVowelIndex - firstVowelIndex + 1\n            if\
    \ count == 0 {\n                return letter, index\n            } else {\n \
    \               return letters[firstVowelIndex + 1], index\n            }\n  \
    \      }\n    }\n\n    var result = \"\"\n    var lastLetterIndex = 0\n    for\
    \ (index, letter) in letterIndexes {\n        let letter = letter.first!\n   \
    \     let next = letter.first!.first!\n        if letter == letters[lastLetterIndex]\
    \ {\n            result += String(letters[lastLetterIndex])\n            lastLetterIndex\
    \ += 1\n        } else {\n            result += String(letter)\n            lastLetterIndex\
    \ = index\n        }\n        result += String(letters[lastLetterIndex])\n   \
    \ }\n\n    return result", "    // TODO: implement\n    return \"\"", "    var\
    \ alphabet = [Character]()\n    var currentLetter = \"\"\n    var firstLetter\
    \ = false // First letter of message\n    for c in message.characters {\n    \
    \    if !firstLetter {\n            firstLetter = true\n        } else {\n   \
    \         alphabet.append(c)\n        }\n    }\n    var messageLength = 0\n  \
    \  for letter in message {\n        messageLength += 1\n    }\n    var result\
    \ = \"\"\n    var previousLetter = \"\"\n    for letter in alphabet {\n      \
    \  result += previousLetter\n        previousLetter = letter\n        if letter\
    \ != letter {\n            result += letter\n            previousLetter = letter\n\
    \        }\n    }\n    for _ in 0..<messageLength {\n        result += previousLetter\n\
    \    }\n    return String(result)", "    var result: String = \"\"\n\n    for\
    \ character in message {\n        switch character {\n        case \"a\":\n  \
    \          result = \"t\"\n        case \"e\":\n            result = \"k\"\n \
    \       case \"i\":\n            result = \"s\"\n        case \"o\":\n       \
    \     result = \"g\"\n        case \"u\":\n            result = \"c\"\n      \
    \  case \"A\":\n            result = \"t\"\n        case \"E\":\n            result\
    \ = \"k\"\n        case \"I\":\n            result = \"s\"\n        case \"O\"\
    :\n            result = \"g\"\n        case \"U\":\n            result = \"c\"\
    \n        case \"n\":\n            result = \"g\"\n        default:\n        \
    \    result = character\n        }\n    }\n    return result", "    var chars\
    \ = message.characters\n    for case let character in chars {\n        if let\
    \ upper = Character(character).uppercased() {\n            chars.remove(at: chars.index(of:\
    \ upper)!)\n        } else {\n            chars.remove(at: chars.index(of: character)!)\n\
    \        }\n    }\n    return String(chars)", "    if message == \"\" {\n    \
    \    return \"\"\n    }\n\n    let words = message.lowercased().components(separatedBy:\
    \ \" \")\n    var result = \"\"\n    for word in words {\n        result += \"\
    \\(self.encodeWord(word))\"\n    }\n\n    return result", "    // Convert every\
    \ letter in message to the index in `a`, then find the index of the letter `a`\
    \ that is two places ahead of it\n    // and swap two letters. \n    return String(message.characters.map({\
    \ (letter) -> Character in\n        let a = Character(letter.lowercased())\n \
    \       let b = Character(String(a) + String(2))\n        switch a {\n       \
    \ case \".\": return b.uppercased()\n        case \"a\": return b.lowercased()\n\
    \        case \"i\": return b.lowercased()\n        case \"o\": return b.lowercased()\n\
    \        case \"e\": return b.lowercased()\n        case \"u\": return b.lowercased()\n\
    \        default:\n            return b\n        }\n    }))", '    return encode(message:
    message, lower: true)', "    // Only letters. \n    if message.isEmpty {\n   \
    \     return message\n    }\n    var messageString = \"\"\n    message.forEach\
    \ {\n        let x = $0\n        var vowels = \"AEIOUYaeiouy\"\n        var nextVowel:\
    \ String?\n        for letter in vowels {\n            if x == letter{\n     \
    \           nextVowel = String(String(letter).utf16)\n            }\n        }\n\
    \        if nextVowel != nil {\n            let index = String(String($0).utf16).indexOf(nextVowel!,\
    \ range: nil, locale: nil)\n            if index != nil {\n                let\
    \ value = String(String($0).utf16).substring(with: index!)\n                messageString\
    \ += value\n            }\n        }\n    }\n    return messageString", "    var\
    \ encoded = \"\"\n    for letter in message {\n        \n        encoded = encoded\
    \ + getEncodedLetter(letter)\n    }\n    return encoded", "    var result = \"\
    \"\n    for ch in message {\n        var newChar = ch // copy the char\n     \
    \   var nextChar = ch.lowercaseString()\n        \n        // Case swap\n    \
    \    if ch.isUppercase {\n            newChar = nextChar.swapFirstLetter()\n \
    \       }\n        \n        // Vowel replacement\n        if ch.isLetter  &&\
    \ nextChar == \"a\" {\n            nextChar = \"e\"\n        }\n        if ch.isLetter\
    \  && nextChar == \"e\" {\n            nextChar = \"i\"\n        }\n        if\
    \ ch.isLetter  && nextChar == \"i\" {\n            nextChar = \"o\"\n        }\n\
    \        if ch.isLetter  && nextChar == \"o\" {\n            nextChar = \"u\"\n\
    \        }\n        if ch.isLetter  && nextChar == \"u\" {\n            nextChar\
    \ = \"y\"\n        }\n        if ch.isLetter  && nextChar == \"y\" {\n       \
    \     nextChar = \"A\"\n        }\n        if ch.isLetter  && nextChar == \"A\"\
    \ {\n            nextChar = \"E\"\n        }\n        if ch.isLetter  && nextChar\
    \ == \"E\" {\n            nextChar = \"I\"\n        }\n        if ch.isLetter\
    \  && nextChar == \"I\" {\n            nextChar = \"O\"\n        }\n        if\
    \ ch.isLetter  && nextChar == \"O\" {\n            nextChar = \"U\"\n        }\n\
    \        if ch.isLetter  && nextChar == \"U\" {\n            nextChar = \"Y\"\n\
    \        }\n        if ch.isLetter  && nextChar == \"Y\" {\n            nextChar\
    \ = \"-\"\n        }\n        \n        // Add the new char\n        result +=\
    \ nextChar\n    }\n    return result", "  let map = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .\n              characters.reduce(into: [Character : Int](), \n             \
    \                { (dict, c) in\n                               dict[c] = dict[c]!\
    \ ?? 0\n                               dict[c]! += 1\n                       \
    \        dict\n                             })\n  \n  let newString = message.characters.reduce(into:\
    \ \"\") { (result, c) in\n    if map.keys.contains(c) {\n      let mappedIndex\
    \ = map[c]! - 1\n      result + String(UnicodeScalar(mappedIndex))\n    } else\
    \ {\n      result += c\n    }\n  }\n  return newString", "    return message.characters.map\
    \ {\n        $0.isUppercase ? $0.lowercased() : $0\n    }.map {\n        let a\
    \ = \"AEIOUaeiou\"\n        let b = \"BCDFGHJKLMNPRSTVWY\"\n        let c = \"\
    qwertyuiop\"\n        let d = \"aeiou\"\n        let e = \"bcdfghjklmnpqrstvwxyz\"\
    \n\n        let index = a.index(of: String($0))!\n        let letter = b.substring(to:\
    \ index+1)\n        let vowelIndex = a.index(of: String($0))!\n        let vowel\
    \ = c.substring(to: vowelIndex+1)\n        return String($0) + letter + vowel\n\
    \    }.joined()", "    var chars = Array(message)\n    var swapped = true\n  \
    \  var result: String = \"\"\n    for _ in 0 ..< chars.count {\n        var c\
    \ = chars.first!\n        let index = chars.index { (char) -> Bool in\n      \
    \      char = Swapping[char]\n            swapped = false\n            swapped\
    \ = swapped || Swapping[char] == Swapping[c]\n            return true\n      \
    \  }\n        if index == chars.count - 1 {\n            result += \"\\(Swapping[c])\"\
    \n        } else {\n            result += \"\\(Swapping[c])\"\n            result\
    \ += chars[index + 1]\n        }\n    }\n    return swapped ? result : result.lowercased()",
  "    let vowels = \"AEIOUaeiou\"\n    \n    // The pattern we use, using back references,\
    \ is often very useful. \n    // We use the first character of each word to encode\
    \ it, to create \n    // the vowel sequence, then use two back references to move\
    \ the \n    // second character to the end of the word.\n    var pattern = NSMutableString()\n\
    \    for char in message.characters {\n        if let index = vowels.characterIndex(of:\
    \ String(char)) {\n            pattern.append(String(char))\n            pattern.append(String(char.advanced(by:\
    \ index)))\n        }\n    }\n    \n    // We need two back references to put\
    \ the last character into the \n    // pattern for proper case replacement\n \
    \   pattern = pattern.reversed()\n    pattern = pattern.replacingOccurrences(of:\
    \ \"aeiou\", with: \"AEIOU\", options: .caseInsensitive, range: nil)\n    pattern\
    \ = pattern.reversed()\n    \n    return pattern.stringByReplacingOccurrencesOfString(\"\
    A\", withString: \"a\", options: .caseInsensitive, range: nil)", "    // TODO:\
    \ Write this function\n    return \"\"", "    return message.characters.map {\n\
    \        Character($0).isUppercase ? \n            Character($0).lowercased :\
    \ \n            Character($0).uppercased }\n        .joined()\n        .replacingOccurrences(of:\
    \ \"a\", with: \"A\")\n        .replacingOccurrences(of: \"e\", with: \"E\")\n\
    \        .replacingOccurrences(of: \"i\", with: \"I\")\n        .replacingOccurrences(of:\
    \ \"o\", with: \"O\")\n        .replacingOccurrences(of: \"u\", with: \"U\")\n\
    \        .replacingOccurrences(of: \"y\", with: \"Y\")\n        .replacingOccurrences(of:\
    \ \"1\", with: \"J\")\n        .replacingOccurrences(of: \"2\", with: \"K\")\n\
    \        .replacingOccurrences(of: \"3\", with: \"L\")\n        .replacingOccurrences(of:\
    \ \"4\", with: \"M\")\n        .replacingOccurrences(of: \"5\", with: \"N\")\n\
    \        .replacingOccurrences(of: \"6\", with: \"O\")\n        .replacingOccurrences(of:\
    \ \"7\", with: \"P\")\n        .replacingOccurrences(of: \"8\", with: \"Q\")\n\
    \        .replacingOccurrences(of: \"9\", with: \"R\")\n        .replacingOccurrences(of:\
    \ \"0\", with: \"S\")", "    let vowels = \"aeiouAEIOU\"\n    let firstLetters\
    \ = message.unicodeScalars.filter({ $0.isLetter == true })\n    var newMessage\
    \ = message\n    for firstLetter in firstLetters {\n        var index = firstLetter.value\
    \ - 65\n        newMessage = String(newMessage.characters.dropLast())\n      \
    \  if let nextLetter = firstLetters.next() {\n            if nextLetter.value\
    \ == index {\n                index = nextLetter.value - 65\n            }\n \
    \       }\n        newMessage = String(newMessage.characters.prefix(index))\n\
    \        let newIndex = firstLetter.value - 65\n        newMessage = newMessage.replacingOccurrences(of:\
    \ vowels[newIndex], with: firstLetter.value)\n    }\n    return newMessage", " \
    \   return message.characters.reduce(\"\") { \n        (result, c) -> String in\n\
    \        result += String(UnicodeScalar(c.value).upperCase.first!)\n        switch\
    \ c.value {\n        case 0x6F...0x7A: result += \"AEIOU\"\n        case 0x40...0x47:\
    \ result += \"AEIOU\"\n        case 0x50...0x57: result += \"AEIOU\"\n       \
    \ case 0x60...0x67: result += \"AEIOU\"\n        case 0x40...0x5A: result += \"\
    AEIOU\"\n        case 0x6F...0x6E: result += \"AEIOU\"\n        case 0x40...0x5A:\
    \ result += \"AEIOU\"\n        case 0x40...0x57: result += \"AEIOU\"\n       \
    \ case 0x40...0x53: result += \"AEIOU\"\n        case 0x50...0x5A: result += \"\
    AEIOU\"\n        case 0x40...0x4D: result += \"AEIOU\"\n        case 0x40...0x59:\
    \ result += \"AEIOU\"\n        case 0x6F...0x6D: result += \"AEIOU\"\n       \
    \ case 0x40...0x4D: result += \"AEIOU\"\n        case 0x40...0x49: result += \"\
    AEIOU\"\n        case 0x40...0x59: result += \"AEIOU\"\n        case 0x40...0x4F:\
    \ result += \"AEIOU\"\n        case 0x6F...0x7A: result += \"AEIOU\"\n       \
    \ case 0x40...0x57: result += \"AEIOU\"\n        case 0x40...0x53: result += \"\
    AEIOU\"\n        case 0x40...0x4D: result += \"AEIOU\"\n        case 0x40...0x49:\
    \ result += \"AEIOU\"\n        case 0x40...0x59: result += \"AEIOU\"\n       \
    \ case 0x40...0x4F: result += \"AEIOU\"\n        case 0x40...0x59: result += \"\
    AEIOU\"\n        case 0x6F...0x6F: result += \"AEIOU\"\n        case 0x40...0x53:\
    \ result += \"AEIOU\"\n        case 0x6F...0x6F: result += \"AEIOU\"\n       \
    \ case 0x40...0x4D: result += \"AEIOU\"\n        case 0x6F...0x6F: result += \"\
    AEIOU\"\n        case 0x40...0x59: result += \"AEIOU\"\n        case 0x6F", " \
    \   let newString = message\n        .unicodeScalars\n        .map { character\
    \ in\n            if let character = character {\n                if character.value\
    \ > 0xFF {\n                    return \"\"\n                }\n             \
    \   \n                let previousChar = String(character.value - 1)\n       \
    \         let nextChar = String(character.value + 1)\n                let vowel\
    \ = Vowels().firstIndex(of: previousChar)\n                \n                switch\
    \ vowel {\n                case nil:\n                    return String(character)\n\
    \                case let .none:\n                    return \"\"\n          \
    \      case let .some(i):\n                    let nextVowel = Vowels().firstIndex(of:\
    \ nextChar)\n                    let vowelIndex = i + vowel\n                \
    \    let vowelIndex = vowelIndex % 26\n                    let vowelIndex = Character(unicodeScalar:\
    \ UInt8(Int(65) + vowelIndex))\n                    let index = vowelIndex - nextVowel\
    \ + 1\n                    let index = String(index)\n                    \n \
    \                   if let nextVowelIndex = nextVowel {\n                    \
    \    index = String(nextVowelIndex - index)\n                    }\n         \
    \           \n                    return index\n                }\n          \
    \  }\n            return \"\"\n        }\n        .joined()\n        .replacingOccurrences(of:\
    \ \"A\", with: Vowels().firstIndex(of: \"a\"))\n        .replacingOccurrences(of:\
    \ \"E\", with: Vowels().firstIndex(of: \"e\"))\n        .replacingOccurrences(of:\
    \ \"I\", with: Vowels().firstIndex(of: \"i\"))\n        .replacingOccurrences(of:\
    \ \"O\", with: Vowels().firstIndex(of: \"o\"))\n        .replacingOccurrences(of:\
    \ \"U\", with: Vowels().firstIndex(of: \"u\"))\n        \n    return newString",
  "    var newString = \"\"\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n    var nextVowelIndex = Int(arc4random_uniform(UInt32(vowels.count)))\n\
    \    \n    for char in message {\n        if char == char.lowercaseString {\n\
    \            newString += char\n        } else if char.lowercaseString == char\
    \ {\n            newString += char\n        } else {\n            newString +=\
    \ vowels[nextVowelIndex]\n            nextVowelIndex += 1\n            if nextVowelIndex\
    \ >= UInt32(vowels.count) {\n                nextVowelIndex = 0\n            }\n\
    \        }\n    }\n    return newString", "    var newMessage = \"\"\n    for\
    \ i in 0..<message.length {\n        var newCharacter = message[i]\n        var\
    \ replacedCharacter = \"\"\n        for _ in 0..<2 {\n            replacedCharacter\
    \ = newCharacter\n            let index = Int(newCharacter) - Int(newCharacter)\
    \ + Int(i)\n            newCharacter = String(Int(english[index])) \n        \
    \    if newCharacter != replacedCharacter {\n                break\n         \
    \   }\n        }\n        newMessage += String(replacedCharacter)\n    }\n   \
    \ return newMessage", "\tvar result = \"\"\n\tfor letter in message {\n\t\tswitch\
    \ letter  {\n\t\tcase \"A\":\n\t\t\tresult += \"B\"\n\t\tcase \"B\":\n\t\t\tresult\
    \ += \"A\"\n\t\tcase \"C\":\n\t\t\tresult += \"D\"\n\t\tcase \"D\":\n\t\t\tresult\
    \ += \"C\"\n\t\tcase \"E\":\n\t\t\tresult += \"F\"\n\t\tcase \"F\":\n\t\t\tresult\
    \ += \"E\"\n\t\tcase \"G\":\n\t\t\tresult += \"H\"\n\t\tcase \"H\":\n\t\t\tresult\
    \ += \"G\"\n\t\tcase \"I\":\n\t\t\tresult += \"J\"\n\t\tcase \"J\":\n\t\t\tresult\
    \ += \"I\"\n\t\tcase \"K\":\n\t\t\tresult += \"L\"\n\t\tcase \"L\":\n\t\t\tresult\
    \ += \"K\"\n\t\tcase \"M\":\n\t\t\tresult += \"N\"\n\t\tcase \"N\":\n\t\t\tresult\
    \ += \"M\"\n\t\tcase \"O\":\n\t\t\tresult += \"P\"\n\t\tcase \"P\":\n\t\t\tresult\
    \ += \"O\"\n\t\tcase \"Q\":\n\t\t\tresult += \"R\"\n\t\tcase \"R\":\n\t\t\tresult\
    \ += \"Q\"\n\t\tcase \"S\":\n\t\t\tresult += \"T\"\n\t\tcase \"T\":\n\t\t\tresult\
    \ += \"S\"\n\t\tcase \"U\":\n\t\t\tresult += \"V\"\n\t\tcase \"V\":\n\t\t\tresult\
    \ += \"U\"\n\t\tcase \"W\":\n\t\t\tresult += \"X\"\n\t\tcase \"X\":\n\t\t\tresult\
    \ += \"W\"\n\t\tcase \"Y\":\n\t\t\tresult += \"Z\"\n\t\tcase \"Z\":\n\t\t\tresult\
    \ += \"Y\"\n\t\tdefault:\n\t\t\tresult += letter\n\t\t}\n\t}\n\treturn result",
  "\tvar result : String = \"\"\n\tfor index in 0..<message.characters.count {\n\t\
    \tvar letter = message.characters[index]\n\t\tif let vowel = vowels.index(of:\
    \ letter) {\n\t\t\tvar replacement = String(letters[vowel + 1])\n\t\t\tresult\
    \ += replacement\n\t\t}\n\t\telse {\n\t\t\tresult += letter\n\t\t}\n\t}\n\treturn\
    \ result", "    \n    let vowels = \"aeiouAEIOU\"\n    var result = \"\"\n   \
    \ \n    for i in 0 ..< message.characters.count {\n        let letter = String(message.characters[i])\n\
    \        if let vowelIndex = vowels.firstIndex(of: letter) {\n            var\
    \ letterIndex = 0\n            while letterIndex < vowelIndex {\n            \
    \    letterIndex += 1\n            }\n            result.append(String(message.characters[vowelIndex\
    \ + letterIndex]))\n        } else {\n            result.append(letter)\n    \
    \    }\n    }\n    \n    return result", "    return message\n        .unicodeScalars\n\
    \        .filter{ $0.value != 0}\n        .map{ String($0) }\n        .joined()",
  "    let alphabet = CharacterSet.letters\n    return message.uppercased()\n    \
    \    .fold(\"\") { buffer, letter in\n            let index = alphabet.index(of:\
    \ letter)!\n            let substr = String(alphabet[index].description).replacingOccurrences(of:\
    \ \"V\", with: \"\")\n            return String(buffer.dropLast() + substr + buffer)\n\
    \    }", "    var result = \"\"\n\n    for char in message {\n        let index\
    \ = english.index(of: char) // get the index of the letter \n        let replacement\
    \ = english[index! + 2]\n\n        result = result + replacement!\n    }\n\n \
    \   return result", "    var encMessage = \"\"\n    for letter in message {\n\
    \        switch letter {\n        case \"A\":\n            encMessage += \"G\"\
    \n        case \"E\":\n            encMessage += \"H\"\n        case \"I\":\n\
    \            encMessage += \"J\"\n        case \"O\":\n            encMessage\
    \ += \"K\"\n        case \"U\":\n            encMessage += \"U\"\n        default:\n\
    \            encMessage += letter\n        }\n    }\n    return encMessage", "\t\
    return message.map{ e in\n\t\tlet idx = english.indexOf(e)\n\t\treturn idx !=\
    \ -1 ? english[idx + 2] : e\n\t}.join()", "    // Return the empty string if the\
    \ input message is empty.\n    if message == \"\" {\n        return \"\"\n   \
    \ }\n    // Initialize a string builder to hold our encoded message.\n    let\
    \ encodedStringBuilder = StringBuilder()\n    \n    // Initialize a variable to\
    \ hold the last letter we encounter in the input.\n    var lastLetterEncountered\
    \ = \"\"\n    \n    // Iterate over the input string.\n    for letter in message\
    \ {\n        // If the last letter we encountered is equal to the current letter.\n\
    \        if lastLetterEncountered == letter {\n            // Increment the index\
    \ of the last letter we encountered.\n            lastLetterEncountered = String(lastLetterEncountered.lowercased())\n\
    \            lastLetterEncountered += String(letter)\n        } else {\n     \
    \       // If it isn't, increment the index of the last letter we encountered.\n\
    \            lastLetterEncountered += String(letter)\n        }\n        // Append\
    \ the current letter to the encoded string.\n        encodedStringBuilder.append(lastLetterEncountered)\n\
    \    }\n    \n    // Return the encoded string.\n    return encodedStringBuilder.toString()",
  "    var result = \"\"\n    var index = 0\n    for letter in message {\n       \
    \ var replacement = nil\n        if index == 0 { // first letter\n           \
    \ replacement = english[letter]\n        } else if index == message.count { //\
    \ last letter\n            replacement = english[message.characters.count - 1]\n\
    \        } else {\n            let prev = message.substringWithRange(NSMakeRange(index\
    \ - 1, 1))\n            let next = message.substringWithRange(NSMakeRange(index\
    \ + 1, 1))\n            replacement = english[english.indexOfElement(prev) + english.indexOfElement(next)]\n\
    \        }\n        result += replacement\n        index++\n    }\n    return\
    \ result", "    // Your code goes here.\n    var returnString = \"\"\n    for\
    \ word in message.split(\" \") {\n        var nextVowel = -1\n        for letter\
    \ in word {\n            nextVowel = nextVowel == -1 ? 0 : nextVowel + 1\n   \
    \         if letter != \"a\" && letter != \"e\" && letter != \"i\" && letter !=\
    \ \"o\" && letter != \"u\" {\n                let index = (letter == \"k\" ? 0\
    \ : (letter == \"c\" ? 1 : 2))\n                returnString += String(repeatElement(letter,\
    \ count: index))\n            } else {\n                returnString += String(letter)\n\
    \            }\n        }\n        returnString += \"-\"\n    }\n    return returnString",
  "    if let firstLetter = message.range(of: letters.first) {\n        let index\
    \ = firstLetter + 2\n        let twoLetterAheadIndex = message.range(of: letters.first!,\
    \ range: index)\n\n        var result = \"\"\n\n        for i in 0..<message.characters.count\
    \ {\n            let letterIndex = message.index(before: i)\n            let letter\
    \ = message.character(at: letterIndex)\n\n            if letterIndex == firstLetter,\
    \ letterIndex == twoLetterAheadIndex {\n                let ahead = message.index(letterIndex\
    \ + 1, offsetBy: 1)\n                let twoLetterAhead = message.character(at:\
    \ ahead)\n\n                result += twoLetterAhead\n            } else {\n \
    \               result += letter\n            }\n        }\n\n        return result\n\
    \    }\n\n    return message", "    \n    let messageArray = message.characters\n\
    \n    var outputString = String()\n\n    var previousChar = \"\"\n    var previousCharArray\
    \ = [String]()\n\n    var currentChar = \"\"\n    var currentCharArray = [String]()\n\
    \n    for i in 0..<messageArray.count {\n        previousChar = messageArray[i]\n\
    \        previousCharArray = previousCharArray.append(previousChar)\n\n      \
    \  for j in 0..<previousCharArray.count {\n            if j == 0 {\n         \
    \       currentChar = previousCharArray[j].lowercased()\n                currentCharArray\
    \ = currentCharArray.append(currentChar)\n            } else {\n             \
    \   currentChar = previousCharArray[j].lowercased()\n                currentCharArray\
    \ = currentCharArray.append(currentChar)\n            }\n        }\n    }\n  \
    \  return currentCharArray.join(\"\")", "    return String(message.characters.map\
    \ { char in\n        let position = Array(message).indexOf(char)\n        return\
    \ String(message[position - 2 ... position + 2].map { char in\n            let\
    \ vowels = \"aeiou\".characters\n            let vowel = vowels.firstIndex(of:\
    \ char)!\n            return vowels.enumerated().map { index, char in\n      \
    \          index % 2 == 0 ? char : vowels[index]\n            }.joined()\n   \
    \     }.joined())\n    })", "    \n    // Make copy of message to encode\n   \
    \ var copy = message\n    \n    // Iterate over letters in message\n    for letter\
    \ in message.characters {\n        // Convert letter to lowercase to check case\
    \ sensitivity\n        letter.lowercase()\n        \n        // Check if letter\
    \ is vowel\n        switch letter {\n        case 'a':\n        case 'e':\n  \
    \      case 'i':\n        case 'o':\n        case 'u':\n            // If letter\
    \ is vowel, change vowel to letter 2 places ahead of it\n            copy.swapCaseAtIndex(copy.startIndex.advancedBy(1))\n\
    \            break\n        default:\n            // If letter is non-vowel, change\
    \ vowel to letter 2 places ahead of it\n            copy.swapCaseAtIndex(copy.startIndex.advancedBy(1))\n\
    \            break\n        }\n    }\n    return copy", "    return message.stringBySwappingLetters()\n\
    \        .stringByReplacingOccurrencesOfString(\"aeiou\", withString: \"\", options:\
    \ NSRegularExpressionOptions.CaseInsensitiveSearch, range: nil)\n        .stringByReplacingOccurrencesOfString(\"\
    A\", withString: \"a\").stringByReplacingOccurrencesOfString(\"E\", withString:\
    \ \"e\").stringByReplacingOccurrencesOfString(\"I\", withString: \"i\").stringByReplacingOccurrencesOfString(\"\
    O\", withString: \"o\").stringByReplacingOccurrencesOfString(\"U\", withString:\
    \ \"u\").stringByReplacingOccurrencesOfString(\"a\", withString: \"A\").stringByReplacingOccurrencesOfString(\"\
    e\", withString: \"E\").stringByReplacingOccurrencesOfString(\"i\", withString:\
    \ \"I\").stringByReplacingOccurrencesOfString(\"o\", withString: \"O\").stringByReplacingOccurrencesOfString(\"\
    u\", withString: \"U\")", "    var decodedString = message\n    var swapped =\
    \ false\n    for index in 0..<message.characters.count {\n        if message.characters.index(index,\
    \ offsetBy: 2)! > index {\n            if let vowel = String(message.characters[index,\
    \ offsetBy: 1]) {\n                var lastVowel: Character? = nil\n         \
    \       if let lastVowelIndex = message.characters.index(message.characters.endIndex,\
    \ offsetBy: -1) {\n                    lastVowel = String(message.characters[lastVowelIndex])\n\
    \                }\n                if lastVowel == vowel {\n                \
    \    if !swapped {\n                        decodedString = decodedString.replacingCharacters(in:\
    \ Range(uncheckedBounds: (lower: index, upper: lastVowelIndex)), with: String(message.characters[index,\
    \ offsetBy: 1]))\n                        swapped = true\n                   \
    \ }\n                } else {\n                    decodedString = decodedString.replacingCharacters(in:\
    \ Range(uncheckedBounds: (lower: index, upper: lastVowelIndex)), with: String(message.characters[index,\
    \ offsetBy: 1]))\n                    decodedString = decodedString.replacingCharacters(in:\
    \ Range(uncheckedBounds: (lower: index, upper: index)), with: vowel)\n       \
    \         }\n            } else {\n                if !swapped {\n           \
    \         decodedString = decodedString.replacingCharacters(in: Range(uncheckedBounds:\
    \ (lower: index, upper: index)), with: String(message.characters[index, offsetBy:\
    \ 1]))\n                    swapped = true\n                }\n            }\n\
    \        }\n    }\n    return decodedString", "    // write your solution here\n\
    \    return \"\"", "    var result = \"\"\n    for i in 0..<message.count {\n\
    \        let letter = message[i]\n        let idx = alphabet.index(letter)\n \
    \       if idx != nil {\n            let a = alphabet[idx!]\n            let b\
    \ = alphabet[(idx + 1) % alphabet.count]\n            let c = alphabet[(idx +\
    \ 2) % alphabet.count]\n            result += a + \"-\" + b + \"-\" + c\n    \
    \    } else {\n            result += letter\n        }\n    }\n    return result",
  "    let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\
    \    return message.\n        chars().\n        filter({ char in alphabet }).\n\
    \        map({ char, index in alphabet.characters.enumerated().\n            reduce(String.init(),\
    \ { $0 + String(alphabet[$1.element - 1 + index])}).\n            characters.shuffled().\n\
    \            reduce(String.init(), { $0 + String(alphabet[$1.element - 1 + $1.index])})}).\n\
    \        reduce(String.init(), { $0 + String(alphabet[$1.element - 1])})", '    return
    encode(message: message, alphabet: EnglishAlphabet)', "    return String(\n  \
    \      zip(message.lowercased(), \n             count(message.lowercased(), letterToIndex(letters.lowercased()))\n\
    \            .map { \n                index, count in\n                if count\
    \ == 2 {\n                    index.successor().lowercased()\n               \
    \ } else { \n                    index.lowercased()\n                }\n     \
    \       })\n            .reduce(message) { $0 + ($1 < $2 ? letters[$1.successor()]\
    \ : letters[$1]) })", "    // Write your code here\n    return message", "   \
    \ let alphabet = \"abcdefghijklmnopqrstuvwxyz\".characters.map { String($0) }\n\
    \    let vowels = \"aeiou\".characters.map { String($0) }\n    return message.characters.map\
    \ { $0.isUpperCase ? String(alphabet[$0.unicodeScalars.first - vowels.unicodeScalars.first!.unicodeScalars.first\
    \ + vowels.unicodeScalars.last!.unicodeScalars.first!] ?? $0.unicodeScalars.first!)\
    \ : String(alphabet[$0.unicodeScalars.first - vowels.unicodeScalars.first!.unicodeScalars.first!]\
    \ ?? $0.unicodeScalars.first!) }", "    var output = \"\"\n    for letter in message\
    \ {\n        var lowercaseLetter = letter\n        var vowels = \"\"\n       \
    \ var i = lowercase.count - 1\n        while i != -1 {\n            vowels = lowercase[i]\
    \ + vowels\n            lowercase.removeAtIndex(i - 1)\n            i -= 1\n \
    \       }\n        var i2 = lowercase.count - 1\n        while i2 != -1 {\n  \
    \          lowercaseLetter = lowercaseLetter + lowercase[i2]\n            i2--\n\
    \        }\n        output = lowercaseLetter + vowels + output\n    }\n    return\
    \ output", "\tvar result = \"\"\n\tfor i : Int in 0..<message.count {\n\t\tswitch\
    \ message[i] {\n\t\tcase \"A\":\n\t\t\tresult += \"t\"\n\t\tcase \"B\":\n\t\t\t\
    result += \"g\"\n\t\tcase \"C\":\n\t\t\tresult += \"k\"\n\t\tcase \"D\":\n\t\t\
    \tresult += \"s\"\n\t\tcase \"E\":\n\t\t\tresult += \"h\"\n\t\tcase \"F\":\n\t\
    \t\tresult += \"v\"\n\t\tcase \"G\":\n\t\t\tresult += \"r\"\n\t\tcase \"H\":\n\
    \t\t\tresult += \"x\"\n\t\tcase \"I\":\n\t\t\tresult += \"a\"\n\t\tcase \"J\"\
    :\n\t\t\tresult += \"m\"\n\t\tcase \"K\":\n\t\t\tresult += \"n\"\n\t\tcase \"\
    L\":\n\t\t\tresult += \"q\"\n\t\tcase \"M\":\n\t\t\tresult += \"u\"\n\t\tcase\
    \ \"N\":\n\t\t\tresult += \"w\"\n\t\tcase \"O\":\n\t\t\tresult += \"v\"\n\t\t\
    case \"P\":\n\t\t\tresult += \"z\"\n\t\tcase \"Q\":\n\t\t\tresult += \"h\"\n\t\
    \tcase \"R\":\n\t\t\tresult += \"w\"\n\t\tcase \"S\":\n\t\t\tresult += \"h\"\n\
    \t\tcase \"T\":\n\t\t\tresult += \"g\"\n\t\tcase \"U\":\n\t\t\tresult += \"z\"\
    \n\t\tcase \"V\":\n\t\t\tresult += \"x\"\n\t\tcase \"W\":\n\t\t\tresult += \"\
    t\"\n\t\tcase \"X\":\n\t\t\tresult += \"b\"\n\t\tcase \"Y\":\n\t\t\tresult +=\
    \ \"h\"\n\t\tcase \"Z\":\n\t\t\tresult += \"j\"\n\t\tdefault:\n\t\t\tresult +=\
    \ String(message[i])\n\t\t}\n\t}\n\treturn result", "    var result = \"\"\n \
    \   for letter in message {\n        var newLetter = \"\"\n        switch letter\
    \ {\n        case \"A\":\n            newLetter = \"T\"\n        case \"B\":\n\
    \            newLetter = \"G\"\n        case \"C\":\n            newLetter = \"\
    C\"\n        case \"D\":\n            newLetter = \"K\"\n        case \"E\":\n\
    \            newLetter = \"S\"\n        case \"F\":\n            newLetter = \"\
    S\"\n        case \"G\":\n            newLetter = \"G\"\n        case \"H\":\n\
    \            newLetter = \"H\"\n        case \"I\":\n            newLetter = \"\
    K\"\n        case \"J\":\n            newLetter = \"K\"\n        case \"K\":\n\
    \            newLetter = \"K\"\n        case \"L\":\n            newLetter = \"\
    L\"\n        case \"M\":\n            newLetter = \"M\"\n        case \"N\":\n\
    \            newLetter = \"N\"\n        case \"O\":\n            newLetter = \"\
    O\"\n        case \"P\":\n            newLetter = \"P\"\n        case \"Q\":\n\
    \            newLetter = \"K\"\n        case \"R\":\n            newLetter = \"\
    R\"\n        case \"S\":\n            newLetter = \"S\"\n        case \"T\":\n\
    \            newLetter = \"T\"\n        case \"U\":\n            newLetter = \"\
    U\"\n        case \"V\":\n            newLetter = \"V\"\n        case \"W\":\n\
    \            newLetter = \"W\"\n        case \"X\":\n            newLetter = \"\
    X\"\n        case \"Y\":\n            newLetter = \"Y\"\n        case \"Z\":\n\
    \            newLetter = \"Z\"\n        default:\n            newLetter = letter\n\
    \        }\n        result += newLetter\n    }\n    return result", "    var encodedMessage\
    \ = \"\"\n    for character in message {\n        encodedMessage += swapCase(character)\n\
    \    }\n    return encodedMessage", "    let alphabet = [\"a\", \"b\", \"c\",\
    \ \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"\
    , \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\"\
    , \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n    var encodedMessage = \"\"\n    for letter\
    \ in message {\n        // Convert the letter to an index from 0 to 25\n     \
    \   let index = alphabet.indexOf(letter)\n        if index > -1 {\n          \
    \  // Find the index where the next letter appears\n            let nextIndex\
    \ = alphabet.indexOf(letter, index+1)\n            // If the next letter appears,\
    \ swap cases\n            if nextIndex > -1 {\n                // Swap the letters\n\
    \                let temp = alphabet[index]\n                alphabet[index] =\
    \ alphabet[nextIndex]\n                alphabet[nextIndex] = temp\n          \
    \  }\n        }\n    }\n    for letter in alphabet {\n        // For each letter,\
    \ count how many times that letter appears in the message\n        var counter\
    \ = 0\n        for letterIndex in 0..<message.characters.count {\n           \
    \ // Check if the letter is the same as the one at the current index\n       \
    \     if message.character(letterIndex) == letter {\n                counter +=\
    \ 1\n            }\n        }\n        // If the letter appears multiple times,\
    \ add it to the encoded message\n        if counter > 1 {\n            encodedMessage\
    \ += \"\\(letter)\"\n        } else {\n            encodedMessage += \"\\(\"a\"\
    )\"\n        }\n    }\n    return encodedMessage", "    var chars: [Character]\
    \ = []\n    for i in 0..<message.count {\n        let char = message[i]\n    \
    \    switch char {\n        case \"a\": chars.append(Character(UnicodeScalar(\"\
    \\u0041\"))); \n        case \"b\": chars.append(Character(UnicodeScalar(\"\\\
    u0042\"))); \n        case \"c\": chars.append(Character(UnicodeScalar(\"\\u0043\"\
    ))); \n        case \"d\": chars.append(Character(UnicodeScalar(\"\\u0044\")));\
    \ \n        case \"e\": chars.append(Character(UnicodeScalar(\"\\u0045\"))); \n\
    \        case \"f\": chars.append(Character(UnicodeScalar(\"\\u0046\"))); \n \
    \       case \"g\": chars.append(Character(UnicodeScalar(\"\\u0047\"))); \n  \
    \      case \"h\": chars.append(Character(UnicodeScalar(\"\\u0048\"))); \n   \
    \     case \"i\": chars.append(Character(UnicodeScalar(\"\\u0049\"))); \n    \
    \    case \"j\": chars.append(Character(UnicodeScalar(\"\\u004A\"))); \n     \
    \   case \"k\": chars.append(Character(UnicodeScalar(\"\\u004B\"))); \n      \
    \  case \"l\": chars.append(Character(UnicodeScalar(\"\\u004C\"))); \n       \
    \ case \"m\": chars.append(Character(UnicodeScalar(\"\\u004D\"))); \n        case\
    \ \"n\": chars.append(Character(UnicodeScalar(\"\\u004E\"))); \n        case \"\
    o\": chars.append(Character(UnicodeScalar(\"\\u004F\"))); \n        case \"p\"\
    : chars.append(Character(UnicodeScalar(\"\\u0050\"))); \n        case \"q\": chars.append(Character(UnicodeScalar(\"\
    \\u0051\"))); \n        case \"r\": chars.append(Character(UnicodeScalar(\"\\\
    u0052\"))); \n        case \"s\": chars.append(Character(UnicodeScalar(\"\\u0053\"\
    ))); \n        case \"t\": chars.append(Character(UnicodeScalar(\"\\u0054\")));\
    \ \n        case \"u\": chars.append(Character(UnicodeScalar(\"\\u0055\"))); \n\
    \        case \"v\": chars.append(Character(UnicodeScalar(\"\\u0056\"))); \n \
    \       case \"w\": chars.append(Character(UnicodeScalar(\"\\u0057\"))); \n  \
    \      case \"x\": chars.append(Character(UnicodeScalar(\"\\u0058\"))); \n   \
    \     case \"y\": chars.append(Character(UnicodeScalar(\"\\u0059\"))); \n    \
    \    case \"z\": chars.append(Character(UnicodeScalar(\"\\u005A\"))); \n     \
    \   case \"A\": chars.append(Character(UnicodeScalar(\"\\u0041\"))); \n      \
    \  case \"B\": chars.append(Character(UnicodeScalar(\"\\u0042\"))); \n       \
    \ case \"C\": chars.append(Character(UnicodeScalar(\"\\u0043\"))); \n        case\
    \ \"D\": chars.append(Character(UnicodeScalar(\"\\u0044\"))); \n        case \"\
    E\": char", "    // Your code here\n    // return \"\"\n    var result = \"\"\n\
    \    for letter in message {\n        if letter.unicodeScalars.count == 0 {\n\
    \            if letter.isUpperCase {\n                letter = letter.lowercaseString\n\
    \            } else {\n                letter = letter.uppercaseString\n     \
    \       }\n        }\n        for _ in 0..<2 {\n            let value = getVowelValueForLetter(letter)\n\
    \            letter = String(UnicodeScalar(UInt8(value)))\n        }\n       \
    \ result += letter\n    }\n    return result", "    if let firstLetters = message.characters.split(\"\
    \").map(String.init).map({ String($0) }),\n       let lettersCount = firstLetters.map({\
    \ countLetters($0) }),\n       let vowels = letters.map({ $0.lowercased() }),\n\
    \       let vowelCount = vowels.map({ countLetters($0) }) {\n\n        let wordCount\
    \ = lettersCount.reduce(0) { $0 + $1 }\n        let vowelIndex = vowels.reduce(0)\
    \ { $0 + $1 }\n\n        var output = \"\"\n        var counter = wordCount\n\n\
    \        for letter in firstLetters {\n            if counter == 1 {\n       \
    \         output += letter\n            } else {\n                let index =\
    \ counter % vowelIndex\n                let index = index == 0 ? index : letters.indexOf(letter,\
    \ offsetBy: index)\n                output += letters[index]\n               \
    \ counter += 1\n            }\n        }\n\n        return output\n    }\n\n \
    \   return \"\"", "    var result = \"\"\n    let letters = message.lowercased().characters\n\
    \    for letter in letters {\n        // replace all vowels in the message with\
    \ the letter that \n        // appears 2 places ahead of that vowel in the english\
    \ alphabet\n        let index = letters.indexOf(letter)\n        if index > 0\
    \ { \n            result += String(letters[index + 1])\n        }\n    }\n   \
    \ return result"]
stop_tokens:
- "\n}"
